<?xml version="1.0" encoding="UTF-8"?>
<tracingresults>
  <environment>
    <toolname>ReqM2</toolname>
    <toolversion>1.30.0 (stable)</toolversion>
    <toolcopyright>Copyright 2010 - 2018 Elektrobit Automotive GmbH</toolcopyright>
    <libxmlversion>2.0207</libxmlversion>
    <libxml2compileversion>2.9.10</libxml2compileversion>
    <libxml2runtimeversion>20912</libxml2runtimeversion>
    <perlversion>v5.32.1</perlversion>
    <perlptrsize>64</perlptrsize>
    <commandline>-t -q -o asc_EthIf_tracing_cmdb.oreqm -O /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/TestProtocols/LogBase/requirements -c /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_PluginBuildEnv/common/config/AutoCoreReqM2Rules_RMP4_0.xml -s approved,rejected --wfatal WDUPLICATEID,WDUPLICATEIDANDVER /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/build/reqm/ReqM2_Native/asc_EthIf_public_modulereference_integration_req.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/build/reqm/ReqM2_Native/asc_EthIf_requirements_EthIf_4_2_1.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/build/reqm/ReqM2_Native/asc_EthIf_requirements_EthIf_4_2_1_Refinements.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/build/reqm/ReqM2_Native/asc_EthIf_requirements_EthIf_4_3_0.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/build/reqm/ReqM2_Native/asc_EthIf_requirements_EthIf_4_3_0_Refinements.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/build/reqm/ReqM2_Native/asc_EthIf_requirements_EthIf_EBExtensions.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/build/reqm/ReqM2_Native/asc_EthIf_requirements_EthIf_R20-11.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/build/reqm/ReqM2_Native/asc_EthIf_requirements_EthIf_R22-11.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/build/reqm/ReqM2_Native/asc_EthIf_requirements_EthIf_SWS_BSWGeneral_Refinement.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/build/reqm/common_req/EthIf_DbgInst_EB_Extension.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/build/reqm/common_req/EthIf_PbcfgM_EB_Extension.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/build/reqm/common_req/EthIf_PostBuildSelectable_EB_Extension.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/build/reqm/common_req/EthIf_VerifyStub_EB_Extension.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/build/reqm/ReqM2_GenericImporter/reqm_DEV.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/build/reqm/ReqM2_GenericImporter/reqm_IMPL.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/build/reqm/ReqM2_GenericImporter/reqm_IMPLXML.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/build/reqm/ReqM2_DocBookImporter/reqm_SWDD.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/build/reqm/ReqM2_OldCImporter/reqm_SWUTS_LEGACY.reqm</commandline>
    <timestamp>Mon Jun 17 21:49:17 2024</timestamp>
  </environment>
  <cmdline>
    <cmdparam>
      <name>I</name>
      <values>
        <value>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/TestProtocols/LogBase/requirements</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>O</name>
      <values>
        <value>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/TestProtocols/LogBase/requirements</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>c</name>
      <values>
        <value>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_PluginBuildEnv/common/config/AutoCoreReqM2Rules_RMP4_0.xml</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>o</name>
      <values>
        <value>asc_EthIf_tracing_cmdb.oreqm</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>q</name>
    </cmdparam>
    <cmdparam>
      <name>s</name>
      <values>
        <value>approved</value>
        <value>rejected</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>t</name>
    </cmdparam>
    <cmdparam>
      <name>wfatal</name>
      <values>
        <value>WDUPLICATEID</value>
        <value>WDUPLICATEIDANDVER</value>
      </values>
    </cmdparam>
  </cmdline>
  <inputfiles>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/build/reqm/ReqM2_Native/asc_EthIf_public_modulereference_integration_req.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/build/reqm/ReqM2_Native/asc_EthIf_requirements_EthIf_4_2_1.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/build/reqm/ReqM2_Native/asc_EthIf_requirements_EthIf_4_2_1_Refinements.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/build/reqm/ReqM2_Native/asc_EthIf_requirements_EthIf_4_3_0.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/build/reqm/ReqM2_Native/asc_EthIf_requirements_EthIf_4_3_0_Refinements.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/build/reqm/ReqM2_Native/asc_EthIf_requirements_EthIf_EBExtensions.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/build/reqm/ReqM2_Native/asc_EthIf_requirements_EthIf_R20-11.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/build/reqm/ReqM2_Native/asc_EthIf_requirements_EthIf_R22-11.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/build/reqm/ReqM2_Native/asc_EthIf_requirements_EthIf_SWS_BSWGeneral_Refinement.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/build/reqm/common_req/EthIf_DbgInst_EB_Extension.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/build/reqm/common_req/EthIf_PbcfgM_EB_Extension.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/build/reqm/common_req/EthIf_PostBuildSelectable_EB_Extension.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/build/reqm/common_req/EthIf_VerifyStub_EB_Extension.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/build/reqm/ReqM2_GenericImporter/reqm_DEV.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/build/reqm/ReqM2_GenericImporter/reqm_IMPL.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/build/reqm/ReqM2_GenericImporter/reqm_IMPLXML.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/build/reqm/ReqM2_DocBookImporter/reqm_SWDD.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/build/reqm/ReqM2_OldCImporter/reqm_SWUTS_LEGACY.reqm</inputfile>
  </inputfiles>
  <configuration>
    <doctypes>
    <regexs>
      <!-- external level -->
      <regex>creq</regex>       <!-- since 10/1018: introduced for updated tracing model-->

      <!-- product line level -->
      <regex>fea</regex>
      <regex>swpad</regex>      <!-- since 10/1018: introduced for updated tracing model-->
      <regex>swts</regex>

      <!-- bundle level -->
      <regex>swrs</regex>
      <regex>swad</regex>
      <regex>swintts</regex>

      <!-- module level -->
      <regex>swdd</regex>
      <regex>swurs</regex>      <!-- since 10/1018: introduced for updated tracing model-->
      <regex>swmts</regex>      <!-- since 01/1010: introduced for updated tracing model RMP4.0-->
      <regex>swuts</regex>
      <regex>impl</regex>

      <!-- legacy items -->
      <regex>dev</regex>
      <regex>man</regex>
      <regex>lim</regex>
    </regexs>
  </doctypes>
    <rules>
    <!-- The Ruleset for RMP4.0 is currently identical to the previous rule set. This rule is
        intoduce to show that the right file is uses. It will be removed when the RMP4.0 rule set is
    reworked -->
    <rule>
      <name>INFO.Rule set RMP4.0</name>
      <description>This rules indicates that RMP4.0 rule set is used.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status!='approved') and (./status!='rejected')]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>WRN.general.doctypes</name>
      <description>The used doctype is not part of the tracing model</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobjects/@doctype</applyto>
          <condition>((. != 'creq') or (. != 'fea') or (. != 'swpad') or (. != 'swts') or (. != 'swrs') or (. !='swad') or (. != 'swintts') or (.!= 'swdd') or (. != 'swurs') or (. != 'swmts') or (. != 'swuts') or (. != 'impl') or (. != 'dev') or (. != 'man') or (. != 'lim'))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.status</name>
      <description>All specification objects must be either in status=approved or in status=rejected. Other
        statuses are not allowed. How to fix: Set status to rejected or approved.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status!='approved') and (./status!='rejected')]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.rejected</name>
      <description>Status status=rejected is only allowed for requirements. How to fix: set to approved for specification object that are not requirements.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype!='swrs')  and (../@doctype!='swmrs') and (../@doctype!='swurs') and (./status='rejected')]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.comment</name>
      <description>Specification objects with status=rejected shall have a comment or rationale that
        starts with on of the following texts: "This requirement is informational only", "This requirement is not applicable".
        How to fix: Add some text starting with "This requirement is informational only"
        or "This requirement is not applicable" to either the comment or to the rationale.
        Comment: Implementation of check checks for contains instead of starts-with since there is
        no trim function in the used XPATH engine.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status='rejected')]</applyto>
          <condition>contains(./comment,"This requirement is informational only") or contains(./rationale,"This requirement is informational only") or contains(./comment,"This requirement is not applicable") or contains(./rationale,"This requirement is not applicable")</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.rejected.coverage</name>
      <description>Specification objects with status=rejected shall not need coverage. How to fix: remove need for coverage.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status='rejected')]</applyto>
          <condition>count(./needscoverage)=0</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swurs.needscoverage.count</name>
      <description>Unit requirements with status=approved need to be covered, exceptions from
      this rule: configuration requirements (postfix "_CONF" or "_Conf" or prefix "ECUC_") and requirements with
      a comment starting with "The adherence to this requirement is ensured by the following
      release check (URL to the checklist template plus ID of the check):".
      How to fix: Provide a needsobj element for those specobjects or comment according to the rule.
      </description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swurs') and (./status='approved') and count(./needscoverage/needsobj)=0 and count(./fulfilledby/ffbObj)=0]</applyto>
          <!--This condition is false if the id of a specification object does not end with '_Conf' or '_CONF' or does not start with ECUC_ -->
          <condition>substring-after(./id,"ECUC_")!="" or substring-before(./id,"_Conf")!="" or substring-before(./id,"_CONF")!="" or contains(./comment,"The adherence to this requirement is ensured by the following release check (URL to the checklist template plus ID of the check):")</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swurs.needscoverage.rationale</name>
      <description>Requirements with status=approved and without coverage needs that are
        configuration requirements (postfix "_CONF" or "_Conf" or prefix "ECUC_") shall have a comment or rationale
        with the following text: "This is a configuration parameter requirement without functional
        specification.". How to fix: Add some text starting with "This is a configuration parameter
        requirements without functional specification" to either the comment or to the rationale.</description>
      <regexchecks>
        <regexcheck>
          <applyto>//specobject[(../@doctype='swurs') and (./status='approved') and count(./needscoverage/needsobj)=0 and (substring-after(./id,"ECUC_")!="" or substring-before(./id,"_CONF")!="" or substring-before(./id,"_Conf")!="")]</applyto>
          <regex>This is a configuration parameter requirement without functional specification.</regex>
        </regexcheck>
      </regexchecks>
    </rule>

    <rule>
      <name>ERR.swrs.needscoverage.rationale</name>
      <description>Requirements with status=approved and without coverage needs that are
        configuration requirements (postfix "_CONF" or "_Conf" or prefix "ECUC_") shall have a comment or rationale
        with the following text: "This is a configuration parameter requirement without functional
        specification.". How to fix: Add some text starting with "This is a configuration parameter
        requirements without functional specification" to either the comment or to the rationale.</description>
      <regexchecks>
        <regexcheck>
          <applyto>//specobject[(../@doctype='swrs') and (./status='approved') and count(./needscoverage/needsobj)=0 and (substring-after(./id,"ECUC_")!="" or substring-before(./id,"_CONF")!="" or substring-before(./id,"_Conf")!="")]</applyto>
          <regex>This is a configuration parameter requirement without functional specification.</regex>
        </regexcheck>
      </regexchecks>
    </rule>

    <rule>
      <name>ERR.swurs.releases</name>
      <description>Requirements which originates from AUTOSAR (source tag contains term 'AUTOSAR_SWS', 'AUTOSAR_TPS',
        'AUTOSAR_ASWS' or 'AUTOSAR_TR') shall have their release tag set to 'AUTOSAR {major}.{minor}.{patch}' (e.g. 'AUTOSAR 4.3.0').
        Other requirements (including refinements of AUTOSAR requirements) must not contain any of the listed prefixes as
        part of the source tag.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swurs') and (contains(./source,'AUTOSAR_SWS') or contains(./source,'AUTOSAR_TPS') or contains(./source,'AUTOSAR_ASWS') or contains(./source,'AUTOSAR_TR'))]</applyto>
          <condition>contains(./releases/release,'AUTOSAR')</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swrs.releases</name>
      <description>Requirements which originates from AUTOSAR (source tag contains term 'AUTOSAR_SWS', 'AUTOSAR_TPS',
        'AUTOSAR_ASWS' or 'AUTOSAR_TR') shall have their release tag set to 'AUTOSAR {major}.{minor}.{patch}' (e.g. 'AUTOSAR 4.3.0').
        Other requirements (including refinements of AUTOSAR requirements) must not contain any of the listed prefixes as
        part of the source tag.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swrs') and (contains(./source,'AUTOSAR_SWS') or contains(./source,'AUTOSAR_TPS') or contains(./source,'AUTOSAR_ASWS') or contains(./source,'AUTOSAR_TR'))]</applyto>
          <condition>contains(./releases/release,'AUTOSAR')</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swdd.needscoverage.count</name>
      <description>Design elements with status=approved need to be covered.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swdd') and (./status='approved') and count(./needscoverage/needsobj)=0]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swurs.needscoverage.doctypes</name>
      <description>Requirements can be covered only by swurs, swad, dev, lim, swdd, impl, swuts, swmts, or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swurs')]</applyto>
          <condition>(./needscoverage/needsobj="swurs" or ./needscoverage/needsobj="swad" or ./needscoverage/needsobj="dev" or ./needscoverage/needsobj="lim" or ./needscoverage/needsobj="swdd" or ./needscoverage/needsobj="impl" or ./needscoverage/needsobj="swuts" or ./needscoverage/needsobj="swmts" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swrs.needscoverage.doctypes</name>
      <description>Requirements of type swrs can be covered only by swrs, swurs, swad, swintts or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swrs')]</applyto>
          <condition>(./needscoverage/needsobj="swrs" or ./needscoverage/needsobj="swurs" or ./needscoverage/needsobj="swad" or ./needscoverage/needsobj="swuts" or ./needscoverage/needsobj="swintts" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swdd.needscoverage.doctypes</name>
      <description>Design elements of type swdd can only be covered by swdd, swurs, impl, swuts, lim or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swdd')]</applyto>
          <condition>(./needscoverage/needsobj="swdd" or ./needscoverage/needsobj="swurs" or ./needscoverage/needsobj="impl" or ./needscoverage/needsobj="swuts" or ./needscoverage/needsobj="swmts" or ./needscoverage/needsobj="lim" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.dev.needscoverage.count</name>
      <description>Deviations shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='dev')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swuts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swuts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swmts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swmts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swintts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swintts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.man.needscoverage.count</name>
      <description>Manual test cases shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='man')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.impl.needscoverage.count</name>
      <description>Source code shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='impl')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.lim.needscoverage.count</name>
      <description>Limitations shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='lim')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.fea.needscoverage.test</name>
      <description>Features shall be tested by software test ('swts') or manuel test ('man'). If no test is planned a justification shall be given.
                   A justification can be given in the futherinfo tag. The justification shall start with this rule name.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='fea')]</applyto>
          <condition>(
               ./needscoverage/needsobj="swts" or ./needscoverage/needsobj="man" or ./fulfilledby/ffbObj/ffbType="swts" or ./fulfilledby/ffbObj/ffbType="man" or contains(./furtherinfo,"fea.needscoverage.test") or contains(./furtherinfo,"fea.needscoverage.doctypes"))</condition>
        </conditioncheck>
      </conditionchecks>
          </rule>

    <rule>
      <name>WRN.fea.needscoverage.impl</name>
      <description>Features shall be covered by implementation fea, swrs, swad, swpad, swurs, man and swts. For lagacy features a justification is acceppted. A justification can be given in the futherinfo tag. The justification shall start with this rule name.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='fea')]</applyto>
          <condition>( ./needscoverage/needsobj="swrs" or ./fulfilledby/ffbObj/ffbType="swrs" or ./fulfilledby/ffbObj/ffbType="swad" or ./needscoverage/needsobj="swpad" or ./fulfilledby/ffbObj/ffbType="swpad" or ./needscoverage/needsobj="swurs" or ./fulfilledby/ffbObj/ffbType="swurs" or ./needscoverage/needsobj="fea" or ./fulfilledby/ffbObj/ffbType="fea" or contains(./furtherinfo,"fea.needscoverage.impl"))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>


    <rule>
      <name>ERR.swad.fulfilledby.doctypes</name>
      <description>Architectural design objects of type swad can only be covered by swurs, swad, swdd, swintts, man, otherwise they should be refined with swrs</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swad')]</applyto>
          <condition>(./fulfilledby/ffbObj/ffbType="swurs" or ./needscoverage/needsobj="swurs" or ./fulfilledby/ffbObj/ffbType="req" or ./needscoverage/needsobj="req" or ./fulfilledby/ffbObj/ffbType="swad" or ./needscoverage/needsobj="swad" or ./fulfilledby/ffbObj/ffbType="swdd" or ./fulfilledby/ffbObj/ffbType="swintts" or ./needscoverage/needsobj="swintts" or ./fulfilledby/ffbObj/ffbType="man" or ./needscoverage/needsobj="man") </condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swmts.providescoverage.doctypes</name>
      <description>Test case specifications (tcs) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='tcs')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.man.providescoverage.doctypes</name>
      <description>Manual test case specification (man) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='man')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

   <rule>
      <name>ERR.swuts.providescoverage.doctypes</name>
      <description>Software unit test case specification (swuts) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swuts')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

   <rule>
      <name>ERR.swintts.providescoverage.doctypes</name>
      <description>Software integration test case specification (swintts) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swintts')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

   <rule>
      <name>ERR.swts.providescoverage.doctypes</name>
      <description>Software test case specification (swts) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swts')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

  </rules>
    <oreqmRules>

        <rule>
            <name>WRN.swts.needscoverage.count</name>
            <description>Violated if there are more than 10 swts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
        <rule>
            <name>WRN.man.needscoverage.count</name>
            <description>Violated if there are more than 10 man specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='man']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='man']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>man.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
        <rule>
            <name>WRN.swintts.needscoverage.count</name>
            <description>Violated if there are more than 10 swintts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swintts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swintts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swintts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
        <rule>
            <name>WRN.swmts.needscoverage.count</name>
            <description>Violated if there are more than 10 swmts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swmts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swmts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swmts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swuts.needscoverage.count</name>
            <description>Violated if there are more than 10 swuts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swuts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swuts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swuts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swpad.needscoverage.count</name>
            <description>Violated if there are more than 10 swpad specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swpad']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swpad']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swpad.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swrs.needscoverage.count</name>
            <description>Violated if there are more than 10 swrs specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swrs']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swrs']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swrs.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swad.needscoverage.count</name>
            <description>Violated if there are more than 10 swad specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swad']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swad']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swad.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swurs.needscoverage.count</name>
            <description>Violated if there are more than 10 swurs specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swurs']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swurs']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swurs.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swdd.needscoverage.count</name>
            <description>Violated if there are more than 10 swdd specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swdd']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swdd']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swdd.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.impl.needscoverage.count</name>
            <description>Violated if there are more than 10 impl specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='impl']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='impl']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>impl.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swrs.fulfilledby.count</name>
            <description>Violated if there are more than 10 swrs specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swrs'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swrs'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swrs.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swad.fulfilledby.count</name>
            <description>Violated if there are more than 10 swad specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swad'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swad'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swad.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swurs.fulfilledby.count</name>
            <description>Violated if there are more than 10 swurs specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swurs'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swurs'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swurs.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swdd.fulfilledby.count</name>
            <description>Violated if there are more than 10 swdd specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swdd'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swdd'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swdd.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
  </oreqmRules>
  </configuration>
  <specdocument>
    <specobjects doctype="dev">
    <specobject>
      <id>lim.EthIf.EB_INTREQ_EthIf_0001</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
        <!-- class: minor, short term -->
        <!-- class-reason:
            * will be updated in future releases -->
        EthIf must not use receive or transmit interrupts.
        The integrator must assure that neither <code>EthIf</code> uses interrupts
        nor the function <code>EthIf_MainFunctionRx()</code> is called in an interrupt context.
      </description>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>0</internalId></specobject>
    <specobject>
      <id>lim.EthIf.EB_INTREQ_EthIf_0002</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
        The reinitialization process shall not interrupt other module functions.
        If reinitialization of the module is required, the call of
        <code>EthIf_Init()</code> shall not interrupt other module functions.
      </description>
      <rationale>
        The reinitialization process resets all internal variables. Continuing an interrupted
        module function after reinitialization can lead to undefined module behavior.
      </rationale>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1</internalId></specobject>
    <specobject>
      <id>lim.EthIf.EB_INTREQ_EthIf_0003</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
        The call of <code>EthIf_GetControllerMode()</code> always results in the call of
        <code>Eth_GetControllerMode()</code>. The returned mode is not processed within
        EthIf. In case of an erroneous behavior of the hardware (controller returns another
        value as previously set by the upper layer), the upper layer shall take care to set
        EthIf to the new mode by calling the respective APIs.
      </description>
      <rationale>
        It is not specified which layer calls <code>EthIf_GetControllerMode()</code> and
        for what reason since the upper layer already set the mode.
      </rationale>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2</internalId></specobject>
    <specobject>
      <id>lim.EthIf.EB_INTREQ_EthIf_0004</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
        <!--  ASCETHIF-125 -->
        <code>EthIf_Init()</code> shall not be preempted by any other module API calls.
        It needs to be ensured that the function call <code>EthIf_Init()</code> is not
        preempted by any other module API calls.
      </description>
      <rationale>
        During the call of <code>EthIf_Init()</code>, global variables and pointers get
        initialized. It is easy for the integrator to avoid this preemption, thus no data protection
        mechanism is implemented for function <code>EthIf_Init()</code>.
      </rationale>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>3</internalId></specobject>
    <specobject>
      <id>lim.EthIf.EB_INTREQ_EthIf_0005</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
        The integrator must assure that different <code>EthIf_MainFunctionRx_PrioProcessing[name]()
        </code> functions (for prioritized reception of traffic) as well as the
        <code>EthIf_MainFunctionRx()</code> do not preempt each other.
      </description>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>4</internalId></specobject>
    <specobject>
      <id>lim.EthIf.EB_INTREQ_EthIf_0006</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
        The config parameter EthIfInitControllersTransceivers shall be enabled only for Eth drivers
        and transceivers below AUTOSAR 4.2.2.
        The functions Eth_ControllerInit() and EthTrcv_TransceiverInit() shall be called by integration
        code for EB Eth drivers and transceivers for AUTOSAR 4.2.2 or higher.
      </description>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>5</internalId></specobject>
    <specobject>
      <id>lim.EthIf.EB_INTREQ_EthIf_0007</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
        If EB Eth drivers and transceivers for AUTOSAR 4.3.0 are used, then the config parameter
        EthIfSupportEthAPI needs to be set to ASR430_EB.
        A compilation error stating a syntax issue with EthIf_TxConfirmation() is an indication
        that the EthIfSupportEthAPI is not properly configured.
      </description>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>6</internalId></specobject>
    <specobject>
      <id>lim.EthIf.EB_INTREQ_EthIf_0008</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
        If EthIfSwitch and/or EthIfSwitchPortGroup elements are configured, then the EthTrcv configuration
        parameter EthTrcvGeneral/EthTrcvGetLinkStateApi must be set and at least one of EthSwtPorts,
        configured in EthSwt/EthSwtConfig/*/EthSwtPort must have an EthSwtPortTrcvRef defined.
      </description>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>7</internalId></specobject>
    <specobject>
      <id>lim.EthIf.EB_INTREQ_EthIf_0009</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
        Locking per switch port for all switch APIs prevents a preemptive access to the same Trcv registers
        in the chip. However, different switch ports may access e.g. the same SPI. Preemption of an SPI cannot
        be solved by EthIf since it has no knowledge about the topology of the connected transceivers.
        This is out of scope of EthIf and should be solved in the SPI.
        It shall be ensured that the same Trcv instance (registers) is not shared between switch ports and
        configured transceivers. Each Trcv instance shall be used only once, either for a dedicated switch
        port or a configured Trcv in the EthIf configuration.
      </description>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>8</internalId></specobject>
    <specobject>
      <id>lim.EthIf.EB_INTREQ_EthIf_0010</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
        If the config parameter EthIfRetransmitApiEnable is enabled, the DataPtr parameter used in the
        EthIf_Retransmit() API shall provide space for a VLAN header in front of the used buffer.
      </description>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>9</internalId></specobject>
    <specobject>
      <id>lim.EthIf.EB_INTREQ_EthIf_0011</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
        If Eth drivers of a version below AUTOSAR 4.3.0 are used, then EthCtrlIdx of all referenced
        EthCtrl must be 0-based and consecutive.
      </description>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>10</internalId></specobject>
    <specobject>
      <id>lim.EthIf.EB_INTREQ_EthIf_0012</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
        If support of drivers that contain vendor ID and vendorApiInfix is required, then every
        driver that requires it (Eth, EthTrcv, or EthSwt) needs to have a valid BswModuleDescription
        which shall be referenced from EthIf to provide it with vendor ID and vendorApiInfix.
        Support is not available for AUTOSAR versions below 4.3.0.
      </description>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>11</internalId></specobject>
    <specobject>
      <id>lim.EthIf.EB_INTREQ_EthIf_0013</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
        Port group mode and link state are related in a way that when mode is set to DOWN, link
        state is reported LINK_STATE_DOWN, although ports, when used by another active port
        group, could still be ACTIVE and consequently the accumulated port group link state ACTIVE.
        <pre/>
        In case when the port group is under control of BswM, shut-down of ports when port group mode
        is set to DOWN could be delayed as specified in [SWS_EthIf_00270] and [SWS_EthIf_00271].
        During this time period, EthIf accumulates and reports the actual port group link
        state to BswM. When the delay timer expires, EthIf reports the port group link state
        LINK_STATE_DOWN as described in the previous paragraph.
        <pre/>
        The integrator shall be aware of this behavior, verify, and if necessary adjust the related
        project-specific BswM logic.
      </description>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>12</internalId></specobject>
    <specobject>
      <id>lim.EthIf.EB_INTREQ_EthIf_0014</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
        If support of multiple drivers is required, then all the drivers must have an unique combination
        of VendorId and/or VendorApiInfix defined in driver's BswModuleDescription file.
      </description>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>13</internalId></specobject>
    <specobject>
      <id>lim.EthIf.EB_INTREQ_EthIf_0015</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
        EthIf requires some optional API of Eth, EthTrcv and EthSwt to be configured.

        If EthTrcv is present in the configuration following APIs need to be enabled:
        EthTrcv_SetTransceiverMode()
        EthTrcv_GetTransceiverMode()
        EthTrcv_GetLinkState()
        EthTrcv_SetPhyTestMode()
        EthTrcv_GetCableDiagnosticsResult()
        EthTrcv_GetPhyIdentifier()

        If EthSwt is present in the configuration:
        EthSwt_SetSwitchPortMode() and EthSwt_GetSwitchPortMode() need to be enabled if
        port management is expected.

        This list may not be exhaustive.
      </description>
      <rationale>
        Although lower layer APIs are defined as optional in the AUTOSAR specification, the absence
        of them may causes serious and unwanted side effects in EthIf core functionalities.
      </rationale>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>14</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs">
    <specobject>
      <id>EthIf.ASR42.SWS_EthIf_00091</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_ EthIf_4_2_1.xml</source>
      <version>1</version>
      <description>
        Service name:       EthIf_TxConfirmation
        Syntax:             void
        EthIf_TxConfirmation(
        uint8                                       CtrlIdx,
        Eth_BufIdxType                              BufIdx
        Service ID[hex]:    0x11
        Sync/Async:        Synchronous
        Reentrancy:        Non Reentrant
        Parameters (in):   CtrlIdx Index of the Ethernet controller within the context of the Ethernet 
        Interface
        BufIdx Index of the transmitted buffer
        Parameters         None
        inout)
        Parameters (out):  None
        Return value:      None
        Description:       Confirms frame transmission by the indexed controller
      </description>
      <releases>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/EthIf.c.m4_2587</srcid><srcstatus/><internalId>1062</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>15</internalId></specobject>
    <specobject>
      <id>EthIf.ASR42.SWS_EthIf_00106</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_ EthIf_4_2_1.xml</source>
      <version>1</version>
      <description>
        Service name:       &lt;User&gt;_TxConfirmation
        Syntax:             void                                                     &lt;User&gt;
        _TxConfirmation(
        uint8                               CtrlIdx,
        Eth_BufIdxType                                      BufIdx
        Service ID[hex]
        Sync/Async:
        Reentrancy:         Dont care
        Parameters (in):    CtrlIdx Index of the Ethernet controller within the context of the Ethernet 
        Interface
        BufIdx Index of the buffer resource
        Parameters          None
        inout)
        Parameters (out):   None
        Return value:       void 
        Description:        Confirms the transmission of an Ethernet frame
      </description>
      <releases>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.SWS_EthIf_00125</srcid><srcstatus/><internalId>478</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>16</internalId></specobject>
    <specobject>
      <id>EthIf.ASR42.SWS_EthIf_00178</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_ EthIf_4_2_1.xml</source>
      <version>1</version>
      <description>
        Service name:       EthIf_SetCorrectionTime
        Syntax:             void                                                   
        EthIf_SetCorrectionTime(
        uint8                              CtrlIdx,
        Eth_TimeIntDiffType*                        timeOffsetPtr,
        Eth_RateRatioType*                           rateRatioPtr
        Service ID[hex]:    0x26
        Sync/Async:         Synchronous
        Reentrancy:         Non Reentrant
        Parameters (in):    CtrlIdx          Index of the addresses ETH controller.
        timeOffsetPtr offset     between   time  stamp   grandmaster  and   time  stamp   by  local
        clock:
        Parameters                           (OriginTimeStampSync[FUP] ­ IngressTimeStampSync) + Pdelay
        inout):            rateRatioPtr     time elements to calculate and to modify the ratio of the 
        frequency of
        the grandmaster in relation to the frequency of the Local Clock with:
        ratio = OriginTimeStampDelta / IngressTimeStampDelta
        Parameters (out):   None
        Return value:       None
        Description:        Allows the Time Slave to adjust the local ETH Reference clock in HW.
      </description>
      <comment>
        Note: timeOffsetPtr, rateRatioPtr are used to transfer data from EthTSyn to Eth only.
        This requirement is not applicable. This API is no longer used.
      </comment>
      <releases>
        <release>AUTOSAR 4.2.1</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>17</internalId></specobject>
    <specobject>
      <id>EthIf.ASR42.SWS_EthIf_00179</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_ EthIf_4_2_1.xml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service EthIf_Init 
        was previously called. If the check fails, the function shall raise the development error 
        ETHIF_E_NOT_INITIALIZED.
      </description>
      <comment>
        EthIf_SetCorrectionTime()
        This requirement is not applicable. This API is no longer used.
      </comment>
      <releases>
        <release>AUTOSAR 4.2.1</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>18</internalId></specobject>
    <specobject>
      <id>EthIf.ASR42.SWS_EthIf_00180</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_ EthIf_4_2_1.xml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter CtrlIdx for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_INV_CTRL_IDX.
      </description>
      <comment>
        EthIf_SetCorrectionTime()
        This requirement is not applicable. This API is no longer used.
      </comment>
      <releases>
        <release>AUTOSAR 4.2.1</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>19</internalId></specobject>
    <specobject>
      <id>EthIf.ASR42.SWS_EthIf_00181</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_ EthIf_4_2_1.xml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter timeOffsetPtr 
        and timeRatioPtr for being valid. If the check fails, the function shall raise the development 
        error ETHIF_E_PARAM_POINTER.
      </description>
      <comment>
        EthIf_SetCorrectionTime()
        This requirement is not applicable. This API is no longer used.
      </comment>
      <releases>
        <release>AUTOSAR 4.2.1</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>20</internalId></specobject>
    <specobject>
      <id>EthIf.ASR42.SWS_EthIf_00182</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_ EthIf_4_2_1.xml</source>
      <version>1</version>
      <description>
        The function shall be pre compile time configurable On/Off by the configuration parameter: 
        EthIfGlobalTimeSupport.
      </description>
      <comment>
        EthIf_SetCorrectionTime()
        This requirement is not applicable. This API is no longer used.
      </comment>
      <releases>
        <release>AUTOSAR 4.2.1</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>21</internalId></specobject>
    <specobject>
      <id>EthIf.ASR42.SWS_EthIf_00183</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_ EthIf_4_2_1.xml</source>
      <version>1</version>
      <description>
        Caveat: The function requires previous initialization (EthIf_Init)
      </description>
      <comment>
        EthIf_SetCorrectionTime()
        This requirement is not applicable. This API is no longer used.
      </comment>
      <releases>
        <release>AUTOSAR 4.2.1</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>22</internalId></specobject>
    <specobject>
      <id>EthIf.ASR42.SWS_EthIf_00184</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_ EthIf_4_2_1.xml</source>
      <version>1</version>
      <description>
        Service name:       EthIf_SetGlobalTime
        Syntax:             Std_ReturnType                                                    
        EthIf_SetGlobalTime(
        uint8                               CtrlIdx,
        Eth_TimeStampType*                              timeStampPtr
        Service ID[hex]:    0x27
        Sync/Async:         Synchronous
        Reentrancy:         Non Reentrant
        Parameters (in):    CtrlIdx                              Index of the addresses ETH controller.
        timeStampPtr                         new time stamp
        Parameters          None
        inout)
        Parameters (out):   None
        Return value:       Std_ReturnType                       E_OK:
        successful
        E_NOT_OK: failed
        Description:        Allows     the  Time     Master  to   adjust  the  global   ETH   Reference 
        clock  in  HW.
        We     can  use  this    method   to  set  a  global  time  base  on  ETH  in  general    or 
        to
        synchronize the global ETH time base with another time base, e.g. FlexRay.
      </description>
      <comment>
        This requirement is not applicable. This API is no longer used.
      </comment>
      <releases>
        <release>AUTOSAR 4.2.1</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>23</internalId></specobject>
    <specobject>
      <id>EthIf.ASR42.SWS_EthIf_00185</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_ EthIf_4_2_1.xml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service EthIf_Init 
        was previously called. If the check fails, the function shall raise the development error 
        ETHIF_E_NOT_INITIALIZED.
      </description>
      <comment>
        EthIf_SetGlobalTime()
        This requirement is not applicable. This API is no longer used.
      </comment>
      <releases>
        <release>AUTOSAR 4.2.1</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>24</internalId></specobject>
    <specobject>
      <id>EthIf.ASR42.SWS_EthIf_00186</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_ EthIf_4_2_1.xml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter CtrlIdx for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_INV_CTRL_IDX.
      </description>
      <comment>
        EthIf_SetGlobalTime()
        This requirement is not applicable. This API is no longer used.
      </comment>
      <releases>
        <release>AUTOSAR 4.2.1</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>25</internalId></specobject>
    <specobject>
      <id>EthIf.ASR42.SWS_EthIf_00187</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_ EthIf_4_2_1.xml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter timeStampPtr 
        for being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_PARAM_POINTER.
      </description>
      <comment>
        EthIf_SetGlobalTime()
        This requirement is not applicable. This API is no longer used.
      </comment>
      <releases>
        <release>AUTOSAR 4.2.1</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>26</internalId></specobject>
    <specobject>
      <id>EthIf.ASR42.SWS_EthIf_00188</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_ EthIf_4_2_1.xml</source>
      <version>1</version>
      <description>
        The function shall be pre compile time configurable On/Off by the configuration parameter: 
        EthIfGlobalTimeSupport.
      </description>
      <comment>
        EthIf_SetGlobalTime()
        This requirement is not applicable. This API is no longer used.
      </comment>
      <releases>
        <release>AUTOSAR 4.2.1</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>27</internalId></specobject>
    <specobject>
      <id>EthIf.ASR42.SWS_EthIf_00189</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_ EthIf_4_2_1.xml</source>
      <version>1</version>
      <description>
        Caveat: The function requires previous initialization (EthIf_Init)
      </description>
      <comment>
        EthIf_SetGlobalTime()
        This requirement is not applicable. This API is no longer used.
      </comment>
      <releases>
        <release>AUTOSAR 4.2.1</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>28</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs">
    <specobject>
      <id>EthIf.ASR42.SWS_EthIf_00178.ServiceId</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_EthernetInterface.pdf, V4.2.1</source>
      <version>1</version>
      <description>
        The macro ETHIF_SETCORRECTIONTIME_SVCID shall have the value:
        Service ID[hex]: 0x26
      </description>
      <comment>
        This requirement is not applicable. This API is not used anymore.
      </comment>
      <releases>
        <release>AUTOSAR 4.2.1</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>29</internalId></specobject>
    <specobject>
      <id>EthIf.ASR42.SWS_EthIf_00178.SetCorrectionTime.ForwardCall</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_EthernetInterface.pdf, V4.2.1</source>
      <version>1</version>
      <description>
        The call of EthIf_SetCorrectionTime() shall be forwarded to Eth_SetCorrectionTime().
        The input parameter CtrlIdx (which is EthIf CtrlIdx) shall be translated to Eth CtrlIdx.
        All other parameters and return values, if exist, shall be passed between the two APIs
        without any modification.
      </description>
      <comment>
        Note: timeOffsetPtr, rateRatioPtr are used to transfer data from EthTSyn to Eth only.
        This requirement is not applicable. This API is not used anymore.
      </comment>
      <releases>
        <release>AUTOSAR 4.2.1</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>30</internalId></specobject>
    <specobject>
      <id>EthIf.ASR42.SWS_EthIf_00184.ServiceId</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_EthernetInterface.pdf, V4.2.1</source>
      <version>1</version>
      <description>
        The macro ETHIF_SETGLOBALTIME_SVCID shall have the value:
        Service ID[hex]: 0x27
      </description>
      <comment>
        This requirement is not applicable. This API is not used anymore.
      </comment>
      <releases>
        <release>AUTOSAR 4.2.1</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>31</internalId></specobject>
    <specobject>
      <id>EthIf.ASR42.SWS_EthIf_00184.SetGlobalTime.ForwardCall</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_EthernetInterface.pdf, V4.2.1</source>
      <version>1</version>
      <description>
        The call of EthIf_SetGlobalTime() shall be forwarded to Eth_SetGlobalTime().
        The input parameter CtrlIdx (which is EthIf CtrlIdx) shall be translated to Eth CtrlIdx.
        All other parameters and return values, if exist, shall be passed between the two APIs
        without any modification.
      </description>
      <comment>
        This requirement is not applicable. This API is not used anymore.
      </comment>
      <releases>
        <release>AUTOSAR 4.2.1</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>32</internalId></specobject>
    <specobject>
      <id>EthIf.ASR42.EthIf_SwtGetCounterValues</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface.pdf</source>
      <version>1</version>
      <description>
        Service name: EthIf_SwtGetCounterValues
        Syntax: Std_ReturnType EthIf_SwtGetCounterValues(
        uint8 SwitchIdx,
        uint8 SwitchPortIdx,
        Eth_CounterType *CounterPtr)
        Service ID[hex]: 0x40
        Sync/Async: Synchronous /Asynchronous
        Reentrancy: Non Reentrant
        SwitchIdx Index of the switch within the context of the Ethernet
        Parameters (in):
        Switch Driver
        Parameters None
        (inout):
        Parameters (out): DropCount The interpretation of this list of values is switch dependent
        Std_ReturnType E_OK: success
        Return value:
        E_NOT_OK: switch port could not be initialized
        Description: Reads a list with drop counter values of the corresponding switch. The meaning of
        these values is switch dependent and can include values like 1.) dropped packets
        due to buffer overrun, 2.) dropped packets due to CRC errors, etc.
      </description>
      <comment>
        RFC link https://www.autosar.org/bugzilla/show_bug.cgi?id=68804
      </comment>
      <releases>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ComTest_06_Swt_support</srcid><srcstatus/><internalId>1243</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.ASR42.EthIf_SwtGetCounterValues.ServiceId</srcid><srcstatus/><internalId>38</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>33</internalId></specobject>
    <specobject>
      <id>EthIf.ASR42.EthIf_SwtGetCounterValues.detailed</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface.pdf</source>
      <version>1</version>
      <description>
        The function EthIf_SwtGetCounterValues shall read a list of values of the switch.
      </description>
      <comment>
        RFC link https://www.autosar.org/bugzilla/show_bug.cgi?id=68804
      </comment>
      <releases>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest05_SwtSupport_SwtGetCounterValues</srcid><srcstatus/><internalId>1464</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>34</internalId></specobject>
    <specobject>
      <id>EthIf.ASR42.EthIf_SwtGetCounterValues.Api_parameter</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface.pdf</source>
      <version>1</version>
      <description>
        The function EthIf_SwtGetCounterValues shall be pre compile time configurable On/Off by
        the configuration parameter: EthIfSwtGetCounterValuesApi.
      </description>
      <comment>
        RFC link https://www.autosar.org/bugzilla/show_bug.cgi?id=68804
      </comment>
      <releases>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ComTest_06_Swt_support</srcid><srcstatus/><internalId>1243</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>35</internalId></specobject>
    <specobject>
      <id>EthIf.ASR42.EthIf_SwtGetCounterValues.NOT_INIT</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface.pdf</source>
      <version>1</version>
      <description>
        If default error detection is enabled: the function shall check that the service EthIf_Init
        was previously called. If the check fails, the function  shall raise the default error
        ETHIF_E_NOT_INITIALIZED. Requirement in relation with function EthIf_SwtGetCounterValues.
      </description>
      <releases>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest05_SwtSupport_SwtGetCounterValue_Uninit</srcid><srcstatus/><internalId>1448</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>36</internalId></specobject>
    <specobject>
      <id>EthIf.ASR42.EthIf_SwtGetCounterValues.INV_POINTER</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface.pdf</source>
      <version>1</version>
      <description>
        If default error detection is enabled: the function shall check the parameter
        CounterPtr for being valid. If the check fails, the
        function shall raise the default error ETHIF_E_PARAM_POINTER.
        Requirement in relation twith function EthIf_SwtGetCounterValues.
      </description>
      <releases>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest05_SwtSupport_SwtGetCounterValues_InvPointer</srcid><srcstatus/><internalId>1454</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>37</internalId></specobject>
    <specobject>
      <id>EthIf.ASR42.EthIf_SwtGetCounterValues.ServiceId</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface.pdf</source>
      <version>1</version>
      <description>
        The function EthIf_SwtGetCounterValues shall have the value:
        Service ID[hex]: 0x40
      </description>
      <comment>
        RFC link https://www.autosar.org/bugzilla/show_bug.cgi?id=68804
      </comment>
      <releases>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompTest_05_ServiceId_ErrorId</srcid><srcstatus/><internalId>1242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR42.EthIf_SwtGetCounterValues</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>33</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>38</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs">
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00017</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_4_3_0.xml</source>
      <version>1</version>
      <description>
        Type or error | Relevance | Related error code | Value [hex]
        Invalid controller index | Default Error | ETHIF_E_INV_CTRL_IDX | 0x01 
        Invalid transceiver index | Default Error | ETHIF_E_INV_TRCV_IDX | 0x02 
        Invalid port group index | Default Error | ETHIF_E_INV_PORT_GROUP_IDX | 0x03 
        EthIf module was not initialized | Default Error | ETHIF_E_NOT_INITIALIZED | 0x04 
        Invalid pointer in parameter list | Default Error | ETHIF_E_PARAM_POINTER | 0x05 
        Invalid parameter | Default Error | ETHIF_E_INV_PARAM | 0x06 
        Initialization failure | Default Error | ETHIF_E_INIT_FAILED | 0x07
      </description>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00017.ValueCheck.ETHIF_E_INV_CTRL_IDX</srcid><srcstatus/><internalId>86</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00017.ValueCheck.ETHIF_E_INV_TRCV_IDX</srcid><srcstatus/><internalId>87</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00017.ValueCheck.ETHIF_E_INV_PORT_GROUP_IDX</srcid><srcstatus/><internalId>88</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00017.ValueCheck.ETHIF_E_NOT_INITIALIZED</srcid><srcstatus/><internalId>89</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00017.ValueCheck.ETHIF_E_PARAM_POINTER</srcid><srcstatus/><internalId>90</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00017.ValueCheck.ETHIF_E_INV_PARAM</srcid><srcstatus/><internalId>91</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00017.ValueCheck.ETHIF_E_INIT_FAILED</srcid><srcstatus/><internalId>92</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.SWS_EthIf_00017.ValueCheck.ETHIF_E_INV_SWT_IDX</srcid><srcstatus/><internalId>137</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.ValueCheck.ETHIF_E_HW_NOT_INITIALIZED</srcid><srcstatus/><internalId>165</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>39</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00036</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_4_3_0.xml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service EthIf_Init 
        was previously called. If the check fails, the function shall raise the development error 
        ETHIF_E_NOT_INITIALIZED otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01072_SetControllerMode_Uninit</srcid><srcstatus/><internalId>1260</internalId></linkedfrom><linkedfrom><srcid>EthIf_T112_DET_00_SetControllerMode_DetUninit</srcid><srcstatus/><internalId>1755</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>413</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>40</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00041</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_4_3_0.xml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service
        EthIf_Init was previously called. If the check fails, the function shall raise the
        development error ETHIF_E_NOT_INITIALIZED otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <comment>
        EthIf_GetControllerMode
      </comment>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01073_GetControllerMode_Uninit</srcid><srcstatus/><internalId>1261</internalId></linkedfrom><linkedfrom><srcid>EthIf_T111_DET_00_GetControllerMode_DetUninit</srcid><srcstatus/><internalId>1751</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>413</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>41</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00063</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface.pdf, V4.3.0</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service
        EthIf_Init was previously called. If the check fails, the function shall raise the
        development error ETHIF_E_NOT_INITIALIZED.
      </description>
      <comment/>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01080_GetPhysAddr_Uninit</srcid><srcstatus/><internalId>1262</internalId></linkedfrom><linkedfrom><srcid>EthIf_T160_DET_00_GetPhysAddr_DetUninit</srcid><srcstatus/><internalId>1778</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>413</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>42</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00077</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_4_3_0.xml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service EthIf_Init 
        was previously called. If the check fails, the function shall raise the development error 
        ETHIF_E_NOT_INITIALIZED otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <comment>
        EthIf_Transmit
      </comment>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_T130_DET_00_Transmit_DetUninit</srcid><srcstatus/><internalId>1759</internalId></linkedfrom><linkedfrom><srcid>EthIf_T330_DET_00_Transmit_DetUninit</srcid><srcstatus/><internalId>1782</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>413</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>43</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00086</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface.pdf, V4.3.0</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service
        EthIf_Init was previously called. If the check fails, the function shall raise the
        development error ETHIF_E_NOT_INITIALIZED.
      </description>
      <comment>EthIf_RxIndication</comment>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01003_EthIf_RxIndication_Uninit</srcid><srcstatus/><internalId>1253</internalId></linkedfrom><linkedfrom><srcid>EthIf_T140_DET_00_RxIndication_DetUninit</srcid><srcstatus/><internalId>1765</internalId></linkedfrom><linkedfrom><srcid>EthIf_T340_DET_00_RxIndication_DetUninit</srcid><srcstatus/><internalId>1787</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>413</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>44</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00092</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_ EthIf_4_3_0.xml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service
        EthIf_Init was previously called. If the check fails, the function shall raise the
        development error ETHIF_E_NOT_INITIALIZED.
      </description>
      <comment>
        EthIf_TxConfirmation
      </comment>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01081_TxConfirmation_Uninit</srcid><srcstatus/><internalId>1263</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest03000_TxConfirmation_Uninit</srcid><srcstatus/><internalId>1381</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>413</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>45</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00135</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface.pdf, V4.3.0</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service
        EthIf_Init was previously called. If the check fails, the function shall raise the
        development error ETHIF_E_NOT_INITIALIZED.
      </description>
      <comment/>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01000_SetPhysAddr_Uninit</srcid><srcstatus/><internalId>1250</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>413</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>46</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00141</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface.pdf, V4.3.0</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service
        EthIf_Init was previously called. If the check fails, the function shall raise the
        development error ETHIF_E_NOT_INITIALIZED.
      </description>
      <comment>EthIf_UpdatePhysAddrFilter</comment>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01001_UpdatePhysAddrFilter_Uninit</srcid><srcstatus/><internalId>1251</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>413</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>47</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00152</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_4_3_0.xml</source>
      <version>1</version>
      <description>
        EthIf.h shall include Eth_GeneralTypes.h to include general Eth type declarations.
      </description>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/EthIf.h_60</srcid><srcstatus/><internalId>1054</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/include/EthIf_Types.h_23</srcid><srcstatus/><internalId>1055</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>48</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00153</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_4_3_0.xml</source>
      <version>1</version>
      <description>
        The types specified in SWS_EthernetInterface shall be declared in Eth_GeneralTypes.h.
      </description>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/EthIf_Types.h_24</srcid><srcstatus/><internalId>1056</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>49</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00155</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface.pdf, V4.3.0</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service
        EthIf_Init was previously called. If the check fails, the function shall raise the
        development error ETHIF_E_NOT_INITIALIZED.
      </description>
      <comment>EthIf_GetCurrentTime()</comment>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01004_EthIf_GetCurrentTime_Uninit</srcid><srcstatus/><internalId>1254</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00159</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>51</internalId></provcov>
        <provcov>
          <linksto>EthIf.dsn.Func.GlobalTime</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1116</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>50</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00159</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_4_3_0.xml</source>
      <version>1</version>
      <description>
        Caveat: The function requires previous initialization (EthIf_Init)
      </description>
      <comment>
        EthIf_GetCurrentTime()
      </comment>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00155</srcid><srcstatus/><internalId>50</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.GlobalTime</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1116</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>51</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00161</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface.pdf, V4.3.0</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service
        EthIf_Init was previously called. If the check fails, the function shall raise the
        development error ETHIF_E_NOT_INITIALIZED.
      </description>
      <comment>EthIf_EnableEgressTimeStamp()</comment>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01005_EthIf_EnableEgressTimeStamp_Uninit</srcid><srcstatus/><internalId>1255</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
           <linksto>EthIf.ASR43.SWS_EthIf_00165</linksto>
           <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>53</internalId></provcov>
        <provcov>
          <linksto>EthIf.dsn.Func.GlobalTime</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1116</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>52</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00165</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_4_3_0.xml</source>
      <version>1</version>
      <description>
        Caveat: The function requires previous initialization (EthIf_Init)
      </description>
      <comment>
        EthIf_EnableEgressTimeStamp()
      </comment>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00161</srcid><srcstatus/><internalId>52</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.GlobalTime</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1116</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>53</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00167</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface.pdf, V4.3.0</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service
        EthIf_Init was previously called. If the check fails, the function shall raise the
        development error ETHIF_E_NOT_INITIALIZED.
      </description>
      <comment>EthIf_GetEgressTimeStamp()</comment>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01006_EthIf_GetEgressTimeStamp_Uninit</srcid><srcstatus/><internalId>1256</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
           <linksto>EthIf.ASR43.SWS_EthIf_00171</linksto>
           <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>55</internalId></provcov>
        <provcov>
          <linksto>EthIf.dsn.Func.GlobalTime</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1116</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>54</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00171</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_4_3_0.xml</source>
      <version>1</version>
      <description>
        Caveat: The function requires previous initialization (EthIf_Init)
      </description>
      <comment>
        EthIf_GetEgressTimeStamp()
      </comment>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00167</srcid><srcstatus/><internalId>54</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.GlobalTime</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1116</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>55</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00173</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface.pdf, V4.3.0</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service
        EthIf_Init was previously called. If the check fails, the function shall raise the
        development error ETHIF_E_NOT_INITIALIZED.
      </description>
      <comment>EthIf_GetIngressTimeStamp()</comment>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
         <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01007_EthIf_GetIngressTimeStamp_Uninit</srcid><srcstatus/><internalId>1257</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00177</linksto>
           <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>57</internalId></provcov>
        <provcov>
          <linksto>EthIf.dsn.Func.GlobalTime</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1116</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>56</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00177</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_4_3_0.xml</source>
      <version>1</version>
      <description>
        Caveat: The function requires previous initialization (EthIf_Init)
      </description>
      <comment>
        EthIf_GetCurrentTime()
      </comment>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00173</srcid><srcstatus/><internalId>56</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.GlobalTime</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1116</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>57</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00193</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_4_3_0.xml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service
        EthIf_Init was previously called. If the check fails, the function shall raise the
        development error ETHIF_E_NOT_INITIALIZED.
      </description>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest05_SwtSupport_GetPortMacAddr_Uninit</srcid><srcstatus/><internalId>1445</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>58</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00199</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_4_3_0.xml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service
        EthIf_Init was previously called. If the check fails, the function shall raise the
        development error ETHIF_E_NOT_INITIALIZED.
      </description>
      <comment>
        This requirement is informational only
      </comment>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest05_SwtSupport_GetArlTable_Uninit</srcid><srcstatus/><internalId>1446</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>59</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00202</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_4_3_0.xml</source>
      <version>1</version>
      <description>
        Service name: | EthIf_GetBufferLevel 
        Syntax: | Std_ReturnType EthIf_GetBufferLevel(uint8 SwitchIdx,uint32* SwitchBufferLevelPtr)
        Service ID[hex]: | 0x2a 
        Sync/Async: | Synchronous /Asynchronous 
        Reentrancy: | Non Reentrant 
        Parameters (in): | SwitchIdx | Index of the switch within the context of the Ethernet Switch 
        Driver 
        Parameters (inout): | None 
        Parameters (out): | SwitchBufferLevelPtr | The interpretation of this value is switch dependent 
        Return value: | Std_ReturnType | E_OK: success E_NOT_OK: switch port could not be initialized 
        Description: | Reads the buffer level of the corresponding switch. Whether this buffer level is 
        one value for the entire switch (shared memory) or one value for each port at a switch is 
        technology dependent.
      </description>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ComTest_06_Swt_support</srcid><srcstatus/><internalId>1243</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00202.ServiceId</srcid><srcstatus/><internalId>105</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>60</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00203</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_4_3_0.xml</source>
      <version>1</version>
      <description>
        The function EthIf_GetBufferLevel shall read the buffer level of the currently used buffer of 
        the switch.
      </description>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest05_SwtSupport_GetBufferLevel</srcid><srcstatus/><internalId>1463</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>61</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00204</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_4_3_0.xml</source>
      <version>1</version>
      <description>
        The function shall be pre compile time configurable On/Off by the configuration parameter: 
        EthIfGetBufferLevelApi.
      </description>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ComTest_06_Swt_support</srcid><srcstatus/><internalId>1243</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>62</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00205</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_4_3_0.xml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service EthIf_Init 
        was previously called. If the check fails, the function shall raise the development error 
        ETHIF_E_NOT_INITIALIZED.
      </description>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest05_SwtSupport_GetBufferLevel_Uninit</srcid><srcstatus/><internalId>1447</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>63</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00206</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_4_3_0.xml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter 
        SwitchBufferLevelPtr for being valid. If the check fails, the function shall raise the 
        development error ETHIF_E_PARAM_POINTER.
      </description>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest05_SwtSupport_GetBufferLevel_InvPointer</srcid><srcstatus/><internalId>1452</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>64</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00217</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_4_3_0.xml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service
        EthIf_Init was previously called. If the check fails, the function shall raise the
        development error ETHIF_E_NOT_INITIALIZED.
      </description>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest05_SwtSupport_StoreConfiguration_Uninit</srcid><srcstatus/><internalId>1449</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>65</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00222</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_4_3_0.xml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service
        EthIf_Init was previously called. If the check fails, the function shall raise the
        development error ETHIF_E_NOT_INITIALIZED.
      </description>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest05_SwtSupport_ResetConfiguration_Uninit</srcid><srcstatus/><internalId>1450</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>66</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00225</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_EthIf_4_3_0.xml</source>
      <version>1</version>
      <description>
        The EthIf shall include the following header file:
        EthSwt_&lt;vendorID&gt;_&lt;Vendor specific name&gt;&lt;driver abbreviation&gt;.h for services and type 
        definitions of the EthSwt (e.g.: EthSwt_99_Ext1.h)
      </description>
      <comment>
        This requirement is not applicable. EthIf includes EthSwt.h which is hardware
        independent interface definition of EthSwt module.
      </comment>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>67</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00226</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_EthIf_4_3_0.xml</source>
      <version>1</version>
      <description>
        The EthIf shall include the following header files which contain the configuration data used by 
        the EthIf:
        EthSwt_&lt;vendorID&gt;_&lt;Vendor specific name&gt;&lt;driver abbreviation&gt;_Cfg.h for configuration data of 
        the EthSwt (e.g.: EthSwt_99_Ext1_Cfg.h)
      </description>
      <comment>
        This requirement is not applicable. EthIf includes EthSwt.h which is hardware
        independent interface definition of EthSwt module.
      </comment>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>68</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00235</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface.pdf, V4.3.0</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service
        EthIf_Init was previously called. If the check fails, the function shall raise the
        development error ETHIF_E_NOT_INITIALIZED otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <comment/>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest07000_SetTransceiverWakeupMode_Uninit</srcid><srcstatus/><internalId>1528</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.WakeUp</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1115</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>69</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00240</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface.pdf, V4.3.0</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service
        EthIf_Init was previously called. If the check fails, the function shall raise the
        development error ETHIF_E_NOT_INITIALIZED otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <comment/>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest07000_GetTransceiverWakeupMode_Uninit</srcid><srcstatus/><internalId>1529</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.WakeUp</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1115</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>70</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00242</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface.pdf, V4.3.0</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter
        TrcvWakeupModePtr for being valid. If the check fails, the function shall raise the
        development error ETHIF_E_INV_POINTER otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <comment/>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest07000_GetTransceiverWakeupMode_InvPtr</srcid><srcstatus/><internalId>1534</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.WakeUp</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1115</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>71</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00246</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface.pdf, V4.3.0</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service
        EthIf_Init was previously called. If the check fails, the function shall raise the
        development error ETHIF_E_NOT_INITIALIZED otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <comment/>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest07000_CheckWakeup_Uninit</srcid><srcstatus/><internalId>1530</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.WakeUp</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1115</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>72</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00249</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_4_3_0.xml</source>
      <version>1</version>
      <description>
        Caveat: The function EthIf_CheckWakeup() requires previous transceiver initialization (
        EthIf_Init)
      </description>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest07000_CheckWakeup_Uninit</srcid><srcstatus/><internalId>1530</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.WakeUp</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1115</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>73</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00265</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_4_3_0.xml</source>
      <version>1</version>
      <description>
        If EthIf_SetController is called for an EthIfController with ETH_MODE_DOWN and this 
        EthIfController has a reference to an EthIfSwitchPortGroup of type "control" then EthIf shall 
        forward the call to function EthSwt_SetSwitchPortMode for all ports of the respective 
        EthIf_SwitchPortGroup if the mode ETHTRCV_MODE_DOWN has been requested for all Switch Port 
        Groups referencing the port and the current mode is ETHTRCV_MODE_ACTIVE.
      </description>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06002_SetControllerMode_PortGroup</srcid><srcstatus/><internalId>1471</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06009_PortGroup_AllPortsNotDown</srcid><srcstatus/><internalId>1476</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06031_SetControllerMode_PortGroup</srcid><srcstatus/><internalId>1501</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest08002_SetControllerModeAsync_PortGroup</srcid><srcstatus/><internalId>1542</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>74</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00271</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_4_3_0.xml</source>
      <version>1</version>
      <description>
        If the timer to switch off ports  elapses for a port EthIf shall call EthSwt_SetSwitchPortMode 
        with ETHTRCV_MODE_DOWN for the corresponding EthSwtPort.
      </description>
      <comment>
        Rationale: "Delaying with EthIfSwitchOffPortTimedelay is needed to ensure that if
        port is connected to an ECU without switch this ECU has shut down its transceiver
        and if port is connected to a port of a further switch that this port is shutdown at a
        similar point in time.
        Rationale: The implementation has to ensure that EthSwtPorts within
        EthIfSwitchPortGroups are only disabled if all prior activation requests have been
        withdrawn. This could be realized e.g. by a counter mechanism.
      </comment>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06003_SwitchPortGroupRequestMode</srcid><srcstatus/><internalId>1472</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06012_SwitchPortGroup_SetSwitchPortMode_NOK</srcid><srcstatus/><internalId>1479</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06018_PortLinkState_ModeStateNotSet</srcid><srcstatus/><internalId>1486</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06032_BswMPortGroup_LinkStateChg</srcid><srcstatus/><internalId>1502</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06034_BswMPortGroup_LinkStateChg_LINK_INFO</srcid><srcstatus/><internalId>1503</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>75</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00272</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_4_3_0.xml</source>
      <version>1</version>
      <description>
        If EthIf_SwitchPortGroupRequestMode is called with ETHTRCV_MODE_ACTIVE, EthIf shall forward the 
        call to function EthSwt_SetSwitchPortMode for all EthSwtPorts of the respective 
        EthIfSwitchPortGroup if the requested mode and the current mode are different.
      </description>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06003_SwitchPortGroupRequestMode</srcid><srcstatus/><internalId>1472</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06005_StartAllPorts_PortGroupRequestMode</srcid><srcstatus/><internalId>1474</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06012_SwitchPortGroup_SetSwitchPortMode_NOK</srcid><srcstatus/><internalId>1479</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>76</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00275</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_4_3_0.xml</source>
      <version>1</version>
      <description>
        If EthIf_StartAllPorts is called, EthIf shall set the mode to ETHTRCV_MODE_ACTIVE of all ports 
        which are not in a port group referenced by EthIfController and start a timer with 
        EthIfPortStartupActiveTime for all this ports.
      </description>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06004_StartAllPorts</srcid><srcstatus/><internalId>1473</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>77</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00276</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_4_3_0.xml</source>
      <version>1</version>
      <description>
        If the timer to switch off all ports  elapses EthIf shall call EthSwt_SetSwitchPortMode with 
        ETHTRCV_MODE_DOWN for EthSwtPort which are not requested with ETHTRCV_MODE_ACTIVE via 
        EthIf_SwitchPortGroupRequestMode.
      </description>
      <comment>
        Rationale: "Delaying with EthIfPortStartupActiveTime is needed to ensure that NM
        messages with PNC information are received and the requested PNCs are activated.
        Note: EthIf_StartAllPorts could be called in context of BswM_EcuM_CurrentWakeup.
        After a wakeup occurred on the wakeup line all EthIfPortGroups shall be activated to
        enable communication stack to receive NM messages (PNC information). With this it
        is possible to start the EthIfSwitchPortGroups without starting a PNC.
      </comment>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06004_StartAllPorts</srcid><srcstatus/><internalId>1473</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06005_StartAllPorts_PortGroupRequestMode</srcid><srcstatus/><internalId>1474</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>78</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00292</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_4_3_0.xml</source>
      <version>1</version>
      <description>
        Caveat: The function requires previous Switch initialization (EthSwt_Init(
      </description>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01070_SwitchMgmtInfoIndication_Uninit</srcid><srcstatus/><internalId>1294</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>79</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00325</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface.pdf, V4.3.0</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service
        EthIf_Init was previously called. If the check fails, the function shall raise the
        development error ETHIF_E_NOT_INITIALIZED otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <comment>
        Clarification for this requirement: The check of the input parameter is only done in
        case the default error detection is enabled. In this case the function arise a default error
        and returns with E_NOT_OK. This is according to SWS_BSW_00049.
      </comment>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest04039_SetPhyTestMode_Uninit</srcid><srcstatus/><internalId>1412</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91016</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>735</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>80</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00331</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface.pdf, V4.3.0</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service
        EthIf_Init was previously called. If the check fails, the function shall raise the
        development error ETHIF_E_NOT_INITIALIZED otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <comment>
        Clarification for this requirement: The check of the input parameter is only done in
        case the default error detection is enabled. In this case the function arise a default error
        and returns with E_NOT_OK. This is according to SWS_BSW_00049.
      </comment>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest04042_GetCableDiagnosticsResult_Uninit</srcid><srcstatus/><internalId>1415</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91014</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>734</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>81</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00335</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface.pdf, V4.3.0</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service
        EthIf_Init was previously called. If the check fails, the function shall raise the
        development error ETHIF_E_NOT_INITIALIZED otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <comment>
        Clarification for this requirement: The check of the input parameter is only done in
        case the default error detection is enabled. In this case the function arise a default error
        and returns with E_NOT_OK. This is according to SWS_BSW_00049.
      </comment>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest04043_GetPhyIdentifier_Uninit</srcid><srcstatus/><internalId>1416</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91020</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>738</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>82</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00338</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface.pdf, V4.3.0</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter
        ModelNrPtr for being valid. If the check fails, the function shall raise the development
        error ETHIF_E_INV_POINTER otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <comment>
        Clarification for this requirement: The check of the input parameter is only done in
        case the default error detection is enabled. In this case the function arise a default error
        and returns with E_NOT_OK. This is according to SWS_BSW_00049.
      </comment>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest04053_GetPhyIdentifier_InvalidModNrPtr</srcid><srcstatus/><internalId>1426</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91020</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>738</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>83</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.ECUC_EthIf_00048</id>
      <status>approved</status>
      <version>1</version>
      <description>
        description=Name: EthIfSwitchRefOrPortGroupRef
        Description: The choice reference allows to configure either the EthIfController
        references an EthIfSwitch or an EthIfSwitchPortGroup.
        Reference to a EthIfSwitchPortGroup. In case port groups are controlled
        by PNC EthIfSwitchPortGroupRefSemantics shall have the value
        ETHIF_SWITCH_PORT_GROUP_LINK_INFO. In case port groups are
        controlled by the EhtIfController EthIfSwitchPortGroupRefSemantics shall
        have the value ETHIF_SWITCH_PORT_GROUP_CONTROL.
        Multiplicity: 0..1
        Type: Choice reference to [ EthIfSwitch , EthIfSwitchPortGroup 
        Post-Build Variant Multiplicity: true
        Post-Build Variant Value: true
        Multiplicity Configuration Class: Pre-compile time: X VARIANT-PRE-COMPILE
        Link time:        X VARIANT-LINK-TIME
        Post-build time:  X VARIANT-POST-BUILD
        Value Configuration Class: Pre-compile time: X VARIANT-PRE-COMPILE
        Link time:        X VARIANT-LINK-TIME
        Post-build time:  X VARIANT-POST-BUILD-
        Scope / Dependency: Scope: local
        Dependency: no reference to EthIfSwitchPortGroup is only allowed if
        there are no EthIfSwitchPortGroups defined.
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>84</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.ECUC_EthIf_00049</id>
      <status>approved</status>
      <version>1</version>
      <description>
        description=Module Name: EthIf
        Module Description: Configuration of the EthIf (Ethernet Interface) module.
        Post-Build Variant Support: true
        Supported Config Variants: VARIANT-LINK-TIME, VARIANT-POST-BUILD, VARIANT-PRE-COMPILE.
        Included Containers:
        Container Name    Multiplicity    Scope / Dependency
        EthIfConfigSet        1           Collecting container for all parameters with post-build
        configuration classes.
        EthIfGeneral          1           This container contains the general configuration
        parameters of the Ethernet Interface.
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>85</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs">
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00017.ValueCheck.ETHIF_E_INV_CTRL_IDX</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_4_3_0.xml</source>
      <version>1</version>
      <description>
        ETHIF_E_INV_CTRL_IDX shall have the value 0x01.
      </description>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompTest_05_ServiceId_ErrorId</srcid><srcstatus/><internalId>1242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00017</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>39</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>86</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00017.ValueCheck.ETHIF_E_INV_TRCV_IDX</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_4_3_0.xml</source>
      <version>1</version>
      <description>
        ETHIF_E_INV_TRCV_IDX shall have the value 0x02.
      </description>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompTest_05_ServiceId_ErrorId</srcid><srcstatus/><internalId>1242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00017</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>39</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>87</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00017.ValueCheck.ETHIF_E_INV_PORT_GROUP_IDX</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_4_3_0.xml</source>
      <version>1</version>
      <description>
        ETHIF_E_INV_PORT_GROUP_IDX shall have the value 0x03.
      </description>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompTest_05_ServiceId_ErrorId</srcid><srcstatus/><internalId>1242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00017</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>39</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>88</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00017.ValueCheck.ETHIF_E_NOT_INITIALIZED</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_4_3_0.xml</source>
      <version>1</version>
      <description>
        ETHIF_E_NOT_INITIALIZED shall have the value 0x04.
      </description>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompTest_05_ServiceId_ErrorId</srcid><srcstatus/><internalId>1242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00017</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>39</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>89</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00017.ValueCheck.ETHIF_E_PARAM_POINTER</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_4_3_0.xml</source>
      <version>1</version>
      <description>
        ETHIF_E_PARAM_POINTER shall have the value 0x05.
      </description>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompTest_05_ServiceId_ErrorId</srcid><srcstatus/><internalId>1242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00017</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>39</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>90</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00017.ValueCheck.ETHIF_E_INV_PARAM</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_4_3_0.xml</source>
      <version>1</version>
      <description>
        ETHIF_E_INV_PARAM shall have the value 0x06.
      </description>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompTest_05_ServiceId_ErrorId</srcid><srcstatus/><internalId>1242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00017</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>39</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>91</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00017.ValueCheck.ETHIF_E_INIT_FAILED</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_4_3_0.xml</source>
      <version>1</version>
      <description>
        ETHIF_E_INIT_FAILED shall have the value 0x07.
      </description>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompTest_05_ServiceId_ErrorId</srcid><srcstatus/><internalId>1242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00017</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>39</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>92</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00024.ServiceId</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        The macro ETHIF_INIT_SVCID shall have the value:
          Service ID[hex]: 0x01
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompTest_05_ServiceId_ErrorId</srcid><srcstatus/><internalId>1242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00024</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>421</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>93</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.ECUC_EthIf_00029_2</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface.pdf, V4.3.0</source>
      <version>1</version>
      <description>
        Config parameter EthIfVlanId shall be optional. Enabling/disabling this parameter shall also
        enable/disable VLAN support the respective EthIfController.
      </description>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_T330_00_Transmit_ValidParameters</srcid><srcstatus/><internalId>1785</internalId></linkedfrom><linkedfrom><srcid>EthIf_T330_01_Transmit_ValidParameters</srcid><srcstatus/><internalId>1786</internalId></linkedfrom></coveredby></needscov>
        <!-- for enabling/disabling VLAN support -->
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/EthIf.xdm.m4_121</srcid><srcstatus/><internalId>1067</internalId></linkedfrom></coveredby></needscov>
        <!-- for tracing that parameter is optional -->
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
            <linksto>EthIf.SWS_EthIf_00128</linksto>
            <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>490</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>94</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00034.ServiceId</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        The macro ETHIF_SETCONTROLLERMODE_SVCID shall have the value:
        Service ID[hex]: 0x03
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompTest_05_ServiceId_ErrorId</srcid><srcstatus/><internalId>1242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00034</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>423</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>95</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00039.ServiceId</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        The macro ETHIF_GETCONTROLLERMODE_SVCID shall have the value:
        Service ID[hex]: 0x04
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompTest_05_ServiceId_ErrorId</srcid><srcstatus/><internalId>1242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00039</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>427</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>96</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00233.ServiceId</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface.pdf, V4.3.0</source>
      <version>1</version>
      <description>
        The macro ETHIF_SETTRANSCEIVERWAKEUPMODE_SVCID shall have the value:
        Service ID[hex]: 0x2EU
      </description>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompTest_05_ServiceId_ErrorId</srcid><srcstatus/><internalId>1242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00233</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>558</internalId></provcov>
        <provcov>
          <linksto>EthIf.dsn.Func.WakeUp</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1115</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>97</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00238.ServiceId</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface.pdf, V4.3.0</source>
      <version>1</version>
      <description>
        The macro ETHIF_GETTRANSCEIVERWAKEUPMODE_SVCID shall have the value:
        Service ID[hex]: 0x2FU
      </description>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompTest_05_ServiceId_ErrorId</srcid><srcstatus/><internalId>1242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00238</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>563</internalId></provcov>
        <provcov>
          <linksto>EthIf.dsn.Func.WakeUp</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1115</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>98</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00244.ServiceId</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface.pdf, V4.3.0</source>
      <version>1</version>
      <description>
        The macro ETHIF_CHECKWAKEUP_SVCID shall have the value:
        Service ID[hex]: 0x30U
      </description>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompTest_05_ServiceId_ErrorId</srcid><srcstatus/><internalId>1242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00244</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>569</internalId></provcov>
        <provcov>
          <linksto>EthIf.dsn.Func.WakeUp</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1115</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>99</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00061.ServiceId</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        The macro ETHIF_GETPHYSADDR_SVCID shall have the value:
        Service ID[hex]: 0x08
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompTest_05_ServiceId_ErrorId</srcid><srcstatus/><internalId>1242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00061</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>432</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>100</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00132.ServiceId</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        The macro ETHIF_SETPHYSADDR_SVCID shall have the value:
        Service ID[hex]: 0x0d
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompTest_05_ServiceId_ErrorId</srcid><srcstatus/><internalId>1242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00132</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>493</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>101</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00139.ServiceId</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        The macro ETHIF_UPDATEPHYSADDRFILTER_SVCID shall have the value:
        Service ID[hex]: 0x0c
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompTest_05_ServiceId_ErrorId</srcid><srcstatus/><internalId>1242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00139</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>498</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>102</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00190.ServiceId</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The macro ETHIF_GETPORTMACADDR_SVCID shall have the value:
        Service ID[hex]: 0x28
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompTest_05_ServiceId_ErrorId</srcid><srcstatus/><internalId>1242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00190</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>534</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>103</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00196.ServiceId</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The macro ETHIF_GETARLTABLE_SVCID shall have the value:
        Service ID[hex]: 0x29
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompTest_05_ServiceId_ErrorId</srcid><srcstatus/><internalId>1242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00196</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>539</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>104</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00202.ServiceId</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The macro ETHIF_GETBUFFERLEVEL_SVCID shall have the value:
        Service ID[hex]: 0x2a
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompTest_05_ServiceId_ErrorId</srcid><srcstatus/><internalId>1242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00202</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>60</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>105</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00214.ServiceId</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The macro ETHIF_STORECONFIGURATION_SVCID shall have the value:
        Service ID[hex]: 0x2c
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompTest_05_ServiceId_ErrorId</srcid><srcstatus/><internalId>1242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00214</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>544</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>106</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00219.ServiceId</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The macro ETHIF_RESETCONFIGURATION_SVCID shall have the value:
        Service ID[hex]: 0x2d
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompTest_05_ServiceId_ErrorId</srcid><srcstatus/><internalId>1242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00219</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>548</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>107</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00154.ServiceId</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The macro ETHIF_GETCURRENTTIME_SVCID shall have the value:
        Service ID[hex]: 0x22
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompTest_05_ServiceId_ErrorId</srcid><srcstatus/><internalId>1242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00154</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>515</internalId></provcov>
        <provcov>
          <linksto>EthIf.dsn.Func.GlobalTime</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1116</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>108</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00154.GetCurrentTime.ForwardCall</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The call of EthIf_GetCurrentTime() shall be forwarded to Eth_GetCurrentTime().
        The input parameter CtrlIdx (which is EthIf CtrlIdx) shall be translated to Eth CtrlIdx.
        All other parameters and return values, if exist, shall be passed between the two APIs
        without any modification.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01032_EthIf_GetCurrentTime_Forward_Call</srcid><srcstatus/><internalId>1285</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00154</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>515</internalId></provcov>
        <provcov>
          <linksto>EthIf.dsn.Func.GlobalTime</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1116</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>109</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00160.ServiceId</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The macro ETHIF_ENABLEEGRESSTIMESTAMP_SVCID shall have the value:
        Service ID[hex]: 0x23
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompTest_05_ServiceId_ErrorId</srcid><srcstatus/><internalId>1242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00160</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>520</internalId></provcov>
        <provcov>
          <linksto>EthIf.dsn.Func.GlobalTime</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1116</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>110</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00160.EnableEgressTimeStamp.ForwardCall</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The call of EthIf_EnableEgressTimeStamp() shall be forwarded to Eth_EnableEgressTimeStamp().
        The input parameter CtrlIdx (which is EthIf CtrlIdx) shall be translated to Eth CtrlIdx.
        All other parameters and return values, if exist, shall be passed between the two APIs
        without any modification.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01033_EthIf_EnableEgressTimeStamp_Forw_Call</srcid><srcstatus/><internalId>1286</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00160</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>520</internalId></provcov>
        <provcov>
          <linksto>EthIf.dsn.Func.GlobalTime</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1116</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>111</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00166.ServiceId</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The macro ETHIF_GETEGRESSTIMESTAMP_SVCID shall have the value:
        Service ID[hex]: 0x24
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompTest_05_ServiceId_ErrorId</srcid><srcstatus/><internalId>1242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00166</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>524</internalId></provcov>
        <provcov>
          <linksto>EthIf.dsn.Func.GlobalTime</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1116</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>112</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00166.GetEgressTimeStamp.ForwardCall</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The call of EthIf_GetEgressTimeStamp() shall be forwarded to Eth_GetEgressTimeStamp().
        The input parameter CtrlIdx (which is EthIf CtrlIdx) shall be translated to Eth CtrlIdx.
        All other parameters and return values, if exist, shall be passed between the two APIs
        without any modification.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01034_EthIf_GetEgressTimeStamp_Forward_Call</srcid><srcstatus/><internalId>1287</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00166</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>524</internalId></provcov>
        <provcov>
          <linksto>EthIf.dsn.Func.GlobalTime</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1116</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>113</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00172.ServiceId</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The macro ETHIF_GETINGRESSTIMESTAMP_SVCID shall have the value:
        Service ID[hex]: 0x25
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompTest_05_ServiceId_ErrorId</srcid><srcstatus/><internalId>1242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00172</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>529</internalId></provcov>
        <provcov>
          <linksto>EthIf.dsn.Func.GlobalTime</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1116</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>114</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00172.GetIngressTimeStamp.ForwardCall</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The call of EthIf_GetIngressTimeStamp() shall be forwarded to Eth_GetIngressTimeStamp().
        The input parameter CtrlIdx (which is EthIf CtrlIdx) shall be translated to Eth CtrlIdx.
        All other parameters and return values, if exist, shall be passed between the two APIs
        without any modification.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01035_EthIf_GetIngressTimeStamp_Forward_Call</srcid><srcstatus/><internalId>1288</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00172</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>529</internalId></provcov>
        <provcov>
          <linksto>EthIf.dsn.Func.GlobalTime</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1116</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>115</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_91016.ServiceId</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The macro ETHIF_SETPHYTESTMODE_SVCID shall have the value:
        Service ID[hex]: 0x17
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompTest_05_ServiceId_ErrorId</srcid><srcstatus/><internalId>1242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91016</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>735</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>116</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_91018.ServiceId</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The macro ETHIF_SETPHYLOOPBACKMODE_SVCID shall have the value:
        Service ID[hex]: 0x12
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompTest_05_ServiceId_ErrorId</srcid><srcstatus/><internalId>1242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91018</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>737</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>117</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00328_SetPhyLoopbackMode</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface.pdf, V4.3.0</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service
        EthIf_Init was previously called. If the check fails, the function shall raise the
        development error ETHIF_E_NOT_INITIALIZED otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <comment>
        Clarification for this requirement: The check of the input parameter is only done in
        case the default error detection is enabled. In this case the function shall raise the default error
        and return with E_NOT_OK. This is according to SWS_BSW_00049.
      </comment>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest04040_SetPhyLoopbackMode_Uninit</srcid><srcstatus/><internalId>1413</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91018</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>737</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>118</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_91005.ServiceId</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The macro ETHIF_SETPHYTXMODE_SVCID shall have the value:
        Service ID[hex]: 0x13
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompTest_05_ServiceId_ErrorId</srcid><srcstatus/><internalId>1242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>728</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>119</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00328_SetPhyTxMode</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface.pdf, V4.3.0</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service
        EthIf_Init was previously called. If the check fails, the function shall raise the
        development error ETHIF_E_NOT_INITIALIZED otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <comment>
        Clarification for this requirement: The check of the input parameter is only done in
        case the default error detection is enabled. In this case the function arise a default error
        and returns with E_NOT_OK. This is according to SWS_BSW_00049.
      </comment>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest04041_SetPhyTxMode_Uninit</srcid><srcstatus/><internalId>1414</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>728</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>120</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_91014.ServiceId</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The macro ETHIF_GETCABLEDIAGNOSTICSRESULT_SVCID shall have the value:
        Service ID[hex]: 0x14
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompTest_05_ServiceId_ErrorId</srcid><srcstatus/><internalId>1242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91014</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>734</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>121</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_91020.ServiceId</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The macro ETHIF_GETPHYIDENTIFIER_SVCID shall have the value:
        Service ID[hex]: 0x15
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompTest_05_ServiceId_ErrorId</srcid><srcstatus/><internalId>1242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91020</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>738</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>122</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00067.ServiceId</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        The macro ETHIF_PROVIDETXBUFFER_SVCID shall have the value:
        Service ID[hex]: 0x09
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompTest_05_ServiceId_ErrorId</srcid><srcstatus/><internalId>1242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00067</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>437</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>123</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00075.ServiceId</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        The macro ETHIF_TRANSMIT_SVCID shall have the value:
        Service ID[hex]: 0x0a
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompTest_05_ServiceId_ErrorId</srcid><srcstatus/><internalId>1242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00075</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>443</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>124</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00082.ServiceId</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        The macro ETHIF_GETVERSIONINFO_SVCID shall have the value:
        Service ID[hex]: 0x0b
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompTest_05_ServiceId_ErrorId</srcid><srcstatus/><internalId>1242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00082</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>448</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>125</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00085.ServiceId</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        The macro ETHIF_CBK_RXINDICATION_SVCID shall have the value:
        Service ID[hex]: 0x10
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompTest_05_ServiceId_ErrorId</srcid><srcstatus/><internalId>1242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00085</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>449</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>126</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00091.ServiceId</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        The macro ETHIF_CBK_TXCONFIRMATION_SVCID shall have the value:
        Service ID[hex]: 0x11
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompTest_05_ServiceId_ErrorId</srcid><srcstatus/><internalId>1242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00091</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>453</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>127</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00097.ServiceId</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        The macro ETHIF_MAINFUNCTIONRX_SVCID shall have the value:
        Service ID[hex]: 0x20
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompTest_05_ServiceId_ErrorId</srcid><srcstatus/><internalId>1242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00097</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>457</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>128</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_MainFunctionRx_PollEthTrcvLinkState</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        EthIf_MainFunctionRx() shall poll EthTrcv_GetLinkState() for all configured transceivers to
        detect a link state change.
      </description>
      <comment>
        See AUTOSAR_SWS_EthernetStateManager.pdf, figure 11
          Precondition:
          - Controllers are initialized.
          - Controllers are set to ETH_MODE_ACTIVE.
          - At least on transceiver is configured and set to ETHTRCV_MODE_ACTIVE.
          - EthIfTrcvSupportEnable is enabled.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest02008_RX_GetLinkState</srcid><srcstatus/><internalId>1899</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91104</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>749</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>129</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If EthIf_MainFunctionRx() polls EthTrcv_GetLinkState() and detects a link state change for a
        certain transceiver, UL_TrcvLinkStateChg() shall be called to notify the link state
        change for all EthIfCtrlIdx configured to this transceiver.
      </description>
      <furtherinfo>
        WRN.swuts.needscoverage.count - Linking all relevant test cases to the single requirement brings clear benefits and
        splitting them up would only increase complexity without any real improvements.
      </furtherinfo>
      <comment>
        See AUTOSAR_SWS_EthernetStateManager.pdf, figure 11.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest03005_UL_RX_TrcvLinkStateChg</srcid><srcstatus/><internalId>1386</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest07009_SetControllerMode_Wakeup_Activate</srcid><srcstatus/><internalId>1526</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest07010_SetControllerMode_Wakeup_Deactivate</srcid><srcstatus/><internalId>1527</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR403_SetControllerMode_Wakeup_Activate_Transceiver</srcid><srcstatus/><internalId>1547</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR403_SetControllerMode_Wakeup_Deactivate_Transceiver</srcid><srcstatus/><internalId>1548</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR403_SetControllerMode_Wakeup_Deactivate_NoRef</srcid><srcstatus/><internalId>1570</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR422_SetControllerMode_Wakeup_Activate_Transceiver</srcid><srcstatus/><internalId>1586</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR422_SetControllerMode_Wakeup_Deactivate_Transceiver</srcid><srcstatus/><internalId>1587</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR422_SetControllerMode_Wakeup_Deactivate_NoRef</srcid><srcstatus/><internalId>1609</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR430_SetControllerMode_Wakeup_Activate_Transceiver</srcid><srcstatus/><internalId>1634</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR430_SetControllerMode_Wakeup_Deactivate_Transceiver</srcid><srcstatus/><internalId>1635</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR430_SetControllerMode_Wakeup_Deactivate_NoRef</srcid><srcstatus/><internalId>1658</internalId></linkedfrom><linkedfrom><srcid>EthIf_T500_SetControllerMode_Wakeup_Activate</srcid><srcstatus/><internalId>1807</internalId></linkedfrom><linkedfrom><srcid>EthIf_T500_SetControllerMode_Wakeup_Deactivate</srcid><srcstatus/><internalId>1808</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest02048_SetControllerMode_Wakeup_Activate</srcid><srcstatus/><internalId>1891</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest02049_SetControllerMode_Wakeup_Deactivate</srcid><srcstatus/><internalId>1892</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00108</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>467</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00109</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>468</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91104</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>749</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00230</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>555</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>130</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange_MultipleUL</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If EthIf_MainFunctionRx() polls EthTrcv_GetLinkState() and detects a link state change for a
        certain transceiver, all UL_TrcvLinkStateChg() shall be called to notify the link state
        change for all EthIfCtrlIdx configured to this transceiver.
      </description>
      <comment>
        See AUTOSAR_SWS_EthernetStateManager.pdf, figure 11.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest03002_Multiple_UL_RX_TrcvLinkStateChg</srcid><srcstatus/><internalId>1383</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00108</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>467</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00109</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>468</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91104</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>749</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00230</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>555</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>131</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_MainFunctionRx_PollEthReceiveMax</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        EthIf_MainFunctionRx() shall poll Eth_Receive() to the maximum number defined by
        configuration parameter EthIfRxIndicationIterations for each configured controller.
      </description>
      <comment>
        See AUTOSAR_SWS_EthernetStateManager.pdf, figure 11.
          Precondition:
          - Controllers are initialized.
          - Controller are set to ETH_MODE_ACTIVE.
          - EthIfUseEBPollingBehavior is enabled.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_T490_02_MainFunctionRx_PollEthReceiveMax</srcid><srcstatus/><internalId>1806</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>132</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_MainFunctionRx_PollEthReceiveNoData</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If EthIf_MainFunctionRx() polls Eth_Receive() and no further data are available (Output
        parameter RxStatus != ETH_RECEIVED_MORE_DATA_AVAILABLE), the function shall stop polling
        for data of this controller.
      </description>
      <comment>
        See AUTOSAR_SWS_EthernetStateManager.pdf, figure 11.
        Precondition:
          - Controllers are initialized.
          - Controller are set to ETH_MODE_ACTIVE.
          - EthIfUseEBPollingBehavior is enabled.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_T490_00_MainFunctionRx_EthReceive</srcid><srcstatus/><internalId>1804</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>133</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00097_3</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        EthIf_MainFunctionRx() shall check the controller mode and skip all controllers in state
        ETH_MODE_DOWN and not check for available data.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_T390_01_MainFunctionRx_VLan_ETH_MODE_DOWN</srcid><srcstatus/><internalId>1803</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>134</internalId></specobject>
    <specobject>
      <id>EthIf.ASR43.SWS_EthIf_00113.ServiceId</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        The macro ETHIF_MAINFUNCTIONTX_SVCID shall have the value:
        Service ID[hex]: 0x21
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompTest_05_ServiceId_ErrorId</srcid><srcstatus/><internalId>1242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00113</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>471</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>135</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs">
    <specobject>
      <id>EthIf.EB.EthIf_00005</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The Ethernet Interface module shall support postbuild time configuration.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate_var/xgen/EthIf.xgen_67</srcid><srcstatus/><internalId>1113</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
        <linksto>EthIf.SWS_EthIf_00005</linksto>
        <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>410</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>136</internalId></specobject>
    <specobject>
      <id>EthIf.EB.SWS_EthIf_00017.ValueCheck.ETHIF_E_INV_SWT_IDX</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        ETHIF_E_INV_SWT_IDX shall have the value 0x90.
      </description>
      <comment>
        EB extension requirement - required for checking the correct switch index.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompTest_05_ServiceId_ErrorId</srcid><srcstatus/><internalId>1242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00017</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>39</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>137</internalId></specobject>
    <specobject>
      <id>EthIf.EB.ECUC_EthIf_00058</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name: EthIfSwitchPortGroupIdx
        Description: This parameter provides a zero-based consecutive index of the Ethernet
                     Switch Port Groups. Upper layer BSW modules and the EthIf itself use this
                     index to identify an Ethernet Switch Port Group.
        Multiplicity: 1
        Type: EcucIntegerParamDef (Symbolic Name generated for this parameter)
        Range: 0 .. 255
        Default value: -
        Post-Build Variant Value: true
        Value Configuration Class: Pre-compile time: X VARIANT-PRE-COMPILE
                                   Link time:        X VARIANT-LINK-TIME
                                   Post-build time:  X VARIANT-POST-BUILD
        Scope / Dependency: Scope: ECU
      </description>
      <comment>
          This is a configuration parameter requirement without functional specification.
      </comment>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00058</linksto><dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>590</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>138</internalId></specobject>
    <specobject>
      <id>EthIf.EB.SWS_EthIf_00073_2</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the
        parameter Priority for being valid (i.e. smaller than 8). If the check fails, the function
        shall raise the development error ETHIF_E_INV_PARAM and return
        BUFREQ_E_NOT_OK.()
      </description>
      <comment>EthIf_ProvideTxBuffer</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01017_EthIf_ProvideTxBuffer_InvalidPriority</srcid><srcstatus/><internalId>1276</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>413</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>139</internalId></specobject>
    <specobject>
      <id>EthIf.EB.SWS_EthIf_00082_2</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        EthIf_GetVersionInfo shall return the module version information, irrespective of whether
        EthIf_Init was called before.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_T100_00_GetVersionInfo_VersionTest</srcid><srcstatus/><internalId>1750</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>140</internalId></specobject>
    <specobject>
      <id>EthIf.EB.ETHIF085</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
      Provide API function with the following signature:
      void EthIf_Cbk_RxIndication
        (
          uint8 CtrlIdx,
          Eth_DataType* DataPtr,
          uint16 LenByte
        )
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompileTest_01</srcid><srcstatus/><internalId>1237</internalId></linkedfrom><linkedfrom><srcid>EthIf_ComTest02</srcid><srcstatus/><internalId>1239</internalId></linkedfrom><linkedfrom><srcid>EthIf_CompileTest_03</srcid><srcstatus/><internalId>1240</internalId></linkedfrom><linkedfrom><srcid>EthIf_ComTest04</srcid><srcstatus/><internalId>1241</internalId></linkedfrom><linkedfrom><srcid>EthIf_CompileTest_SchM</srcid><srcstatus/><internalId>1249</internalId></linkedfrom><linkedfrom><srcid>EthIf_T340_00_RxIndication_NoVLanControllers</srcid><srcstatus/><internalId>1790</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>141</internalId></specobject>
    <specobject>
      <id>EthIf.EB.ETHIF085_2</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
      API function EthIf_Cbk_RxIndication shall call EthIf_RxIndication and
      - set the 'FrameType' argument to DataPtr + 12 bytes
      - set the 'isBroadcast' argument to
          TRUE, if the target MAC address (i.e. bytes 0 to 5 of DataPtr) is FF:FF:FF:FF:FF:FF
          FALSE otherwise
      - set the 'PhysAddrPtr' argument to DataPtr + 6 bytes
      - set the 'DataPtr' argument to DataPtr + 14 bytes (i.e. start of data or start of TCI in case
        of VLAN)
      - set the 'LenByte' argument to LenByte - 14 bytes
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_T140_00_RxIndication_ValidParameters</srcid><srcstatus/><internalId>1768</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>142</internalId></specobject>
    <specobject>
      <id>EthIf.EB.ETHIF085_3a</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If DET is enabled, API function EthIf_Cbk_RxIndication shall check
        if the module is initialized and report to DET with errorId ETHIF_E_NOT_INITIALIZED
        and service ID 0x10 if it is not.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01002_Cbk_RxIndication_Uninit</srcid><srcstatus/><internalId>1252</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06000_Cbk_RxIndication_Uninit</srcid><srcstatus/><internalId>1505</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>143</internalId></specobject>
    <specobject>
      <id>EthIf.EB.ETHIF085_3b</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If DET is enabled, API function EthIf_Cbk_RxIndication shall check
        argument CtrlIdx for being valid and report to DET with errorId
        ETHIF_E_INV_CTRL_IDX and service ID 0x10 if it is not.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01012_Cbk_RxIndication_InvalidCtrlIdx</srcid><srcstatus/><internalId>1270</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06000_Cbk_RxIndication_InvCtrlIdx</srcid><srcstatus/><internalId>1506</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>144</internalId></specobject>
    <specobject>
      <id>EthIf.EB.ETHIF085_3c</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If DET is enabled, API function EthIf_Cbk_RxIndication shall check DataPtr for being
        NULL and report to DET with errorId ETHIF_E_PARAM_POINTER and service ID 0x10 if it is.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01013_1_Cbk_RxIndication_InvalidDataPtr</srcid><srcstatus/><internalId>1271</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>145</internalId></specobject>
    <specobject>
      <id>EthIf.EB.ETHIF085_3d</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If DET is enabled, API function EthIf_Cbk_RxIndication shall check LenByte for being valid
        and if it is smaller then ETHIF_ETH_HEADER_LENGTH report to DET with errorId
        ETHIF_E_INV_PARAM and service ID 0x10.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01013_2_Cbk_RxIndication_InvalidLenByte</srcid><srcstatus/><internalId>1272</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>146</internalId></specobject>
    <specobject>
      <id>EthIf.EB.ETHIF091</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
      Provide API function with the following signature:
      void EthIf_Cbk_TxConfirmation
        (
          uint8 CtrlIdx,
          Eth_BufIdxType BufIdx
        )
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ComTest02</srcid><srcstatus/><internalId>1239</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>147</internalId></specobject>
    <specobject>
      <id>EthIf.EB.ETHIF091_2</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        API EthIf_Cbk_TxConfirmation() shall call EthIf_TxConfirmation() and directly pass on all
        parameters.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest03009_UL_Cbk_TxConfirmation</srcid><srcstatus/><internalId>1390</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>148</internalId></specobject>
    <specobject>
      <id>EthIf.EB.SWS_EthIf_00098</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        EthIf_MainFunctionRx shall check that the
        service EthIf_Init was previously called. If the check fails, the
        function shall return without taking any action.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest02000_MainFunction_Uninit</srcid><srcstatus/><internalId>1893</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>149</internalId></specobject>
    <specobject>
      <id>EthIf.EB.SWS_EthIf_00124</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        EthIf_MainFunctionTx shall check that the
        service EthIf_Init was previously called. If the check fails, the
        function shall return without taking any action.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest02000_MainFunction_Uninit</srcid><srcstatus/><internalId>1893</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>150</internalId></specobject>
    <specobject>
      <id>EthIf.EB.SWS_EthIf_00278</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        EthIf_MainFunctionState shall check that the
        service EthIf_Init was previously called. If the check fails, the
        function shall return without taking any action.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest08000_MainFunctionState_Uninit</srcid><srcstatus/><internalId>1543</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>151</internalId></specobject>
    <!-- Requirements relating to virtual controller access -->
    <specobject>
      <id>EthIf.EB.VLANReception</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        On reception of an Ethernet frame, if VLAN is enabled for the respective EthIfCtrlIdx:
        If a Ethernet frame contains a VLAN tag, then this shall be evaluated and the VID mapped
        to a EthIf CtrlIdx which is finally indicated to the upper layer.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_T340_01_RxIndication_VLanControllers</srcid><srcstatus/><internalId>1791</internalId></linkedfrom><linkedfrom><srcid>EthIf_T500_RxIndication_VLAN_Forwarding</srcid><srcstatus/><internalId>1810</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>152</internalId></specobject>
    <specobject>
      <id>EthIf.EB.RxIndication.VLAN.InvFrameType</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        If EthIf_RxIndication() is called for a VLAN frame and the encapsulated frame type is not
        configured for the called EthCtrlIdx, then the received frame is discarded silently without
        taking any action.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest02030_RxIndication_VLAN_InvFrameType</srcid><srcstatus/><internalId>1911</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>153</internalId></specobject>
    <specobject>
      <id>EthIf.EB.RxIndication.VLAN.InvVID</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        If EthIf_RxIndication() is called for a VLAN frame and VID is not
        configured for the called EthCtrlIdx, then the received frame is discarded silently without
        taking any action.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest02024_RxIndication_VLAN_InvVID</srcid><srcstatus/><internalId>1908</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>154</internalId></specobject>
    <specobject>
      <id>EthIf.EB.RxIndication.VLAN.InvLenByte</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        If EthIf_RxIndication() is called for a VLAN frame and the parameter LenByte is smaller
        as the header of a VLAN frame, then the received frame is discarded silently without
        taking any action.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest02032_RxIndication_VLAN_InvLenByte</srcid><srcstatus/><internalId>1913</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>155</internalId></specobject>
    <specobject>
      <id>EthIf.EB.RxIndication.InvFrameType</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        If EthIf_RxIndication() is called for a frame without VLAN tag and the frame type is not
        configured for the called EthCtrlIdx, then the received frame is discarded silently without
        taking any action.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest02031_RxIndication_InvFrameType</srcid><srcstatus/><internalId>1912</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>156</internalId></specobject>
    <specobject>
      <id>EthIf.EB.RxIndication.VLANOnly.InvFrame</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        If EthIf_RxIndication() is called for a frame without VLAN tag and all configured EthIf
        controller for the called EthCtrlIdx have VID enabled, then the received frame is discarded
        silently without taking any action.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest02033_RxIndication_VLANOnly_InvFrame</srcid><srcstatus/><internalId>1914</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>157</internalId></specobject>
    <specobject>
      <id>EthIf.EB.MixedMapping</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        On reception of an Ethernet frame:
        If both, an EthIf controller with VLAN ID and an EthIf controller without VLAN ID are mapped
        to the same Eth controller and an Ethernet frame contains no VLAN tag, the EthIf
        CtrlIdx of EthIf controller without VLAN ID shall be indicated to the upper layer
        for reception.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_T340_02_RxIndication_MixedControllers</srcid><srcstatus/><internalId>1792</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>158</internalId></specobject>
    <specobject>
      <id>EthIf.EB.SetCtrlMode.HwNotOk</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If EthIf_SetControllerMode() is called and Eth_SetControllerMode() returns E_NOT_OK,
        EthIf_SetControllerMode() shall return E_NOT_OK.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06028_EthIf_PortGroup_Inv</srcid><srcstatus/><internalId>1498</internalId></linkedfrom><linkedfrom><srcid>EthIf_T112_00_SetControllerMode_EthSetControllerMode_NotOk</srcid><srcstatus/><internalId>1758</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest02003_SetControllerMode</srcid><srcstatus/><internalId>1896</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>159</internalId></specobject>
    <specobject>
      <id>EthIf.EB.SetCtrlMode.NoVirtCtrlAccess.EthSetControllerMode_NotOk</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If EthIf_SetControllerMode() is called for virtual controller support disabled and
        Eth_SetControllerMode() returns E_NOT_OK, EthSM_CtrlModeIndication shall not be called.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_T112_00_SetControllerMode_EthSetControllerMode_NotOk</srcid><srcstatus/><internalId>1758</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>160</internalId></specobject>
    <specobject>
      <id>EthIf.EB.VirtCtrlAccess.RepeatSetCtrlModeActive.HwNotOk</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For virtual controller support and the first call to set the physical controller active:
        If EthIf_SetControllerMode() with ETH_MODE_ACTIVE is called and Eth_SetControllerMode()
        returns E_NOT_OK, the next call to EthIf_MainFunction() shall call Eth_SetControllerMode()
        with ETH_MODE_ACTIVE again.
        Once Eth_SetControllerMode() returns E_OK the process of repeat calling
        of Eth_SetControllerMode() in a MainFunction() is stopped.
      </description>
      <comment>
        Rationale:
        Verify that virtual controller reference counter is not incremented.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06028_EthIf_PortGroup_Inv</srcid><srcstatus/><internalId>1498</internalId></linkedfrom><linkedfrom><srcid>EthIf_T112_00_SetControllerMode_EthSetControllerMode_NotOk</srcid><srcstatus/><internalId>1758</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest02003_SetControllerMode</srcid><srcstatus/><internalId>1896</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>161</internalId></specobject>
    <specobject>
      <id>EthIf.EB.VirtCtrlAccess.RepeatSetCtrlModeDown.HwNotOk</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For virtual controller support and the last call to set the physical controller down:
        If EthIf_SetControllerMode() with ETH_MODE_DOWN is called and Eth_SetControllerMode()
        returns E_NOT_OK, the next call to EthIf_MainFunction() shall call Eth_SetControllerMode()
        with ETH_MODE_DOWN again.
        Once Eth_SetControllerMode() returns E_OK the process of repeat calling
        of Eth_SetControllerMode() in a MainFunction() is stopped.
      </description>
      <comment>
        Rationale:
        Verify that virtual controller reference counter is not decremented.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest02015_SetControllerMode_DownRepeat</srcid><srcstatus/><internalId>1901</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>162</internalId></specobject>
    <specobject>
      <id>EthIf.EB.RepeatSetCtrlModeDown</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If EthIf_SetControllerMode() is called twice with ETH_MODE_DOWN for the same EthIfCtrlIdx,
        the second call of EthIf_SetControllerMode() shall not call Eth_SetControllerMode() and
        only return E_OK.

        A further call of EthIf_SetControllerMode() with ETH_MODE_ACTIVE for the same EthIfCtrlIdx
        shall call Eth_SetControllerMode() with ETH_MODE_ACTIVE.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest02010_SetControllerMode_Down</srcid><srcstatus/><internalId>1900</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>163</internalId></specobject>
    <specobject>
      <id>EthIf.EB.VLAN_Support</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        There shall be a precompile configuration parameter EthIfGeneral/EthIfVLANSupportEnable
        which globally enables or disables VLAN support.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompileTest_01</srcid><srcstatus/><internalId>1237</internalId></linkedfrom><linkedfrom><srcid>EthIf_CompileTest_03</srcid><srcstatus/><internalId>1240</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00128</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>490</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>164</internalId></specobject>
    <specobject>
      <id>EthIf.EB.ValueCheck.ETHIF_E_HW_NOT_INITIALIZED</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        ETHIF_E_HW_NOT_INITIALIZED shall have the value 0x80.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompTest_05_ServiceId_ErrorId</srcid><srcstatus/><internalId>1242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00017</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>39</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>165</internalId></specobject>
    <specobject>
      <id>EthIf.EB.Det.SetController_HardwareUninit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled, parameter EthIfInitControllersTransceivers
        is set to true and EthIf_SetControllerMode() is called while the controller is not
        initialized (EthIf_ControllerInit() was not called for this controller), an error shall
        be reported to Det with error code ETHIF_E_HW_NOT_INITIALIZED and corresponding service
        ID and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01076_SetControllerMode_HardwareUninit</srcid><srcstatus/><internalId>1298</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>166</internalId></specobject>
    <specobject>
      <id>EthIf.EB.Det.GetController_HardwareUninit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled, parameter EthIfInitControllersTransceivers
        is set to true and EthIf_GetControllerMode() is called while the controller is not
        initialized (EthIf_ControllerInit() was not called for this controller), an error shall
        be reported to Det with error code ETHIF_E_HW_NOT_INITIALIZED and corresponding service ID
        and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01078_GetControllerMode_HardwareUninit</srcid><srcstatus/><internalId>1300</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>167</internalId></specobject>
    <specobject>
      <id>EthIf.EB.Det.SwitchPortGroupRequest_InvPortMode</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled and EthIf_SwitchPortGroupRequestMode() is called
        with invalid parameter PortMode
        (PortMode != ETHTRCV_MODE_DOWN and PortMode != ETHTRCV_MODE_ACTIVE), an error shall be
        reported to Det with error code ETHIF_E_INV_PARAM and corresponding service ID and
        E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01088_SwitchPortGroupRequestMode_InvPortMode</srcid><srcstatus/><internalId>1312</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>168</internalId></specobject>

    <specobject>
      <id>EthIf.EB.Det.SwitchPortGroupRequest_InvPortMode.WakeUpOnDataLine</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled, WakeUpOnDataLine is enabled and
        EthIf_SwitchPortGroupRequestMode() is called with invalid parameter PortMode
        (PortMode != ETHTRCV_MODE_DOWN and PortMode != ETHTRCV_MODE_ACTIVE and 
        PortMode != ETHTRCV_MODE_ACTIVE), an error shall be reported to Det with error code
        ETHIF_E_INV_PARAM and corresponding service ID and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06042_SwitchPortGroupRequestMode_Det_Wodl_InvalidPortMode</srcid><srcstatus/><internalId>1523</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>169</internalId></specobject>
    
    <specobject>
      <id>EthIf.EB.Det.SwitchPortGroupRequest_InvPortGroupIdx</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled and EthIf_SwitchPortGroupRequestMode() is called
        with PortGroupIdx which addresses a Logical PortGroup - which is not accessible from BswM,
        ETHIF_E_INV_PORT_GROUP_IDX will be reported to DET and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01089_SwitchPortGroupRequestMode_LogPortGrInd</srcid><srcstatus/><internalId>1313</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>170</internalId></specobject>
    <specobject>
      <id>EthIf.EB.Det.SetController_InvCtrlMode</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled and EthIf_SetControllerMode() is called with
        invalid parameter CtrlMode (CtrlMode != ETH_MODE_DOWN and CtrlMode != ETH_MODE_ACTIVE),
        an error shall be reported to Det with error code ETHIF_E_INV_PARAM
        and corresponding service ID, and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01022_SetControllerMode_InvalidCtrlMode</srcid><srcstatus/><internalId>1278</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest01075_SetControllerMode_InvalidParam</srcid><srcstatus/><internalId>1297</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>171</internalId></specobject>

    <specobject>
      <id>EthIf.EB.Det.SetController_InvCtrlMode_2</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled, EthIfWakeupSleepOnDatalineSupportEnabled is
        disabled and EthIf_SetControllerMode() is called with parameter
        CtrlMode = ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST E_NOT_OK will be returned and an error shall
        be reported to Det with error code ETHIF_E_INV_PARAM and corresponding service ID.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest07007_SetControllerMode_Wakeup_Inv_Param</srcid><srcstatus/><internalId>1524</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>172</internalId></specobject>

    <specobject>
      <id>EthIf.EB.Det.SetController_InvCtrlMode_3</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled, EthIfWakeupSleepOnDatalineSupportEnabled is
        enabled and EthIf_SetControllerMode() is called with
        invalid parameter CtrlMode.
          CtrlMode != ETH_MODE_DOWN, 
          CtrlMode != ETH_MODE_ACTIVE
          CtrlMode != ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST
        E_NOT_OK will be returned, an error shall be reported to Det with error code ETHIF_E_INV_PARAM
        and corresponding service ID.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest07008_SetControllerMode_Wakeup_Inv_Param_2</srcid><srcstatus/><internalId>1525</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>173</internalId></specobject>

    <specobject>
      <id>EthIf.EB.Det.SetTransceiverWakeupMode_InvTrcvWakeupMode</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled and EthIf_SetTransceiverWakeupMode() is called
        with invalid parameter TrcvWakeupMode (TrcvWakeupMode != ETHTRCV_WUM_DISABLE and
        TrcvWakeupMode != ETHTRCV_WUM_ENABLE and TrcvWakeupMode != ETHTRCV_WUM_CLEAR),
        an error shall be reported to Det with error code ETHIF_E_INV_PARAM
        and corresponding service ID, and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest07000_SetTransceiverWakeupMode_InvWakeupMode</srcid><srcstatus/><internalId>1532</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>174</internalId></specobject>
    <specobject>
      <id>EthIf.EB.MainFunctionRx.CtrlNotInit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        EthIf_MainFunctionRx() shall check for all EthCtrlIdx if controller is initialized and
        shall not perform any API call to other modules if not initialized.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest02005_MainFunction_NotInit</srcid><srcstatus/><internalId>1897</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>175</internalId></specobject>
    <specobject>
      <id>EthIf.EB.MainFunctionTx.CtrlNotInit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        EthIf_MainFunctionTx() shall check for all EthCtrlIdx if controller is initialized and
        shall not perform any API call to other modules if not initialized.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest02005_MainFunction_NotInit</srcid><srcstatus/><internalId>1897</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>176</internalId></specobject>
    <specobject>
      <id>EthIf.EB.MainFunctionRx.GetTransceiverMode_NotOk</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        EthIf_MainFunctionRx() shall call EthTrcv_GetTransceiverMode() for all initialized
        transceivers. If EthTrcv_GetTransceiverMode() returns a value not equal E_OK, the
        transceiver shall not be processed any further until next main function cycle.
      </description>
      <comment>
        Precondition: Controller is active.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest02027_MainFunction_GetTransceiverMode_NotOk</srcid><srcstatus/><internalId>1910</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>177</internalId></specobject>
    <specobject>
      <id>EthIf.EB.MainFunctionTx.GetTransceiverMode_NotOk</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        EthIf_MainFunctionTx() shall call EthTrcv_GetTransceiverMode() for all initialized
        transceivers. If EthTrcv_GetTransceiverMode() returns a value not equal E_OK, the
        transceiver shall not be processed any further until next main function cycle.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest02027_MainFunction_GetTransceiverMode_NotOk</srcid><srcstatus/><internalId>1910</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>178</internalId></specobject>
    <specobject>
      <id>EthIf.EB.MainFunctionRx.GetTransceiverMode_NotActive</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        EthIf_MainFunctionRx() shall call Eth_GetTransceiverMode() for all initialized transceivers.
        If EthTrcv_GetTransceiverMode() returns TrcvMode not ETHTRCV_MODE_ACTIVE, the transceiver
        shall not be processed any further until next main function cycle.
      </description>
      <comment>
        Precondition: Controller is active.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest02026_MainFunction_GetTransceiverMode_NotActive</srcid><srcstatus/><internalId>1909</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>179</internalId></specobject>
    <specobject>
      <id>EthIf.EB.MainFunctionTx.GetTransceiverMode_NotActive</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        EthIf_MainFunctionTx() shall call EthTrcv_GetTransceiverMode() for all initialized
        transceivers. If EthTrcv_GetTransceiverMode() returns TrcvMode not ETHTRCV_MODE_ACTIVE,
        the transceiver shall not be processed any further until next main function cycle.
      </description>
      <comment>
        Precondition: Controller is active.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest02026_MainFunction_GetTransceiverMode_NotActive</srcid><srcstatus/><internalId>1909</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>180</internalId></specobject>
    <specobject>
      <id>EthIf.EB.MainFunctionRx.HW_GetsDown</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If both controller and transceiver are set to mode down, the next call of
        EthIf_MainFunctionRx() shall call all configured UL_TrcvLinkStateChg()
        with ETHTRCV_LINK_STATE_DOWN for this transceiver.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest03011_MainFunctionRx_HW_GetsDown</srcid><srcstatus/><internalId>1392</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06013_MainFunctionCycleCounter</srcid><srcstatus/><internalId>1480</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>181</internalId></specobject>
    <specobject>
      <id>EthIf.EB.EthIfSetPhysAddrSupportEnable_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        Name EthIfSetPhysAddrSupportEnable {ETHIF_ETH_SETPHYSADDR_API_ENABLE}
        Location: In container General
        Description: Allows to enable or disable the usage of Eth_SetPhysAddr().
        Multiplicity 1
        Type: EcucBooleanParamDef
        ConfigurationClass
        Pre-compile time X All Variants
        Link time --
        Post-build time --
      </description>
      <comment>
        AUTOSAR 4.0.3 Ethernet drivers do not provide the API Eth_SetPhysAddr(). Therefore, it must
        be possible to disable the usage of this function.
      </comment>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.EB.EthIfSetPhysAddrSupportEnable_Enable</srcid><srcstatus/><internalId>183</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.EthIfSetPhysAddrSupportEnable_Disable</srcid><srcstatus/><internalId>184</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>182</internalId></specobject>
    <specobject>
      <id>EthIf.EB.EthIfSetPhysAddrSupportEnable_Enable</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        EthIf_SetPhysAddr() shall call Eth_SetPhysAddr() if configuration parameter
        EthIfSetPhysAddrSupportEnable is enabled.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest02001_SetPhysAddr</srcid><srcstatus/><internalId>1894</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.EthIfSetPhysAddrSupportEnable_Conf</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>182</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>183</internalId></specobject>
    <specobject>
      <id>EthIf.EB.EthIfSetPhysAddrSupportEnable_Disable</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        EthIf_SetPhysAddr() shall NOT call Eth_SetPhysAddr() if configuration parameter
        EthIfSetPhysAddrSupportEnable is disabled.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_T500_SetPhysAddr_UpdatePhysAddr_Disabled</srcid><srcstatus/><internalId>1812</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.EthIfSetPhysAddrSupportEnable_Conf</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>182</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>184</internalId></specobject>
    <specobject>
      <id>EthIf.EB.EthIfUpdatePhysAddrFilterSupportEnable_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        Name EthIfUpdatePhysAddrFilterSupportEnable {ETHIF_ETH_UPDATEPHYSADDRFILTER_API_ENABLE}
        Location: In container General
        Description: Allows to enable or disable the usage of Eth_UpdatePhysAddrFilter().
        Multiplicity 1
        Type: EcucBooleanParamDef
        ConfigurationClass
        Pre-compile time X All Variants
        Link time --
        Post-build time --
      </description>
      <comment>
        AUTOSAR 4.0.3 Ethernet drivers do not provide the API Eth_UpdatePhysAddrFilter(). Therefore,
        it must be possible to disable the usage of this function.
      </comment>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.EB.EthIfUpdatePhysAddrFilterSupportEnable_Enable</srcid><srcstatus/><internalId>186</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.EthIfUpdatePhysAddrFilterSupportEnable_Disable</srcid><srcstatus/><internalId>187</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>185</internalId></specobject>
    <specobject>
      <id>EthIf.EB.EthIfUpdatePhysAddrFilterSupportEnable_Enable</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        EthIf_UpdatePhysAddrFilter() shall call Eth_UpdatePhysAddrFilter() if
        configuration parameter EthIfUpdatePhysAddrFilterSupportEnable is enabled.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest02002_UpdatePhysAddrFilter</srcid><srcstatus/><internalId>1895</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.EthIfUpdatePhysAddrFilterSupportEnable_Conf</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>185</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>186</internalId></specobject>
    <specobject>
      <id>EthIf.EB.EthIfUpdatePhysAddrFilterSupportEnable_Disable</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        EthIf_UpdatePhysAddrFilter() shall NOT call Eth_UpdatePhysAddrFilter() if configuration
        parameter EthIfUpdatePhysAddrFilterSupportEnable is disabled.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_T500_SetPhysAddr_UpdatePhysAddr_Disabled</srcid><srcstatus/><internalId>1812</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.EthIfUpdatePhysAddrFilterSupportEnable_Conf</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>185</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>187</internalId></specobject>
    <!-- Missing SWS requirements ================================================================== -->
    <specobject>
      <id>EthIf.EB.User_RxIndication.VLAN</id>
      <status>approved</status>
      <source>EB (counterpart of  SWS_EthIf_00147 for RX)</source>
      <version>1</version>
      <description>
        If EthIf_RxIndication() is called FrameType is VLAN (0x8100):
        EthIf_RxIndication() shall call corresponding configured User_RxIndication() with the
        following arguments:
        If FrameType is VLAN (0x8100): the first 4 bytes of DataPtr are evaluated and the
        VLAN Id is extracted from bytes 1 and 2.
        - CtrlIdx: EthIfCtrlIdx with matching configured VLAN Id.
        - FrameType: is extracted from bytes 3 and 4 of DataPtr
        - IsBroadcast: passed on
        - PhysAddrPtr: passed on
        - DataPtr: DataPtr+4
        - LenByte: LenByte-4
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_T500_RxIndication_VLAN_Forwarding</srcid><srcstatus/><internalId>1810</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>188</internalId></specobject>
    <specobject>
      <id>EthIf.EB.User_RxIndication.VLAN_MultipleUL</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If EthIf_RxIndication() is called with FrameType VLAN (0x8100):
        EthIf shall extract and use the in payload encapsulated frame type to choose the
        corresponding User_RxIndication().
        It shall be verified that EthIf really maps the frame type to the corresponding frame owner
        and uses the configured User_RxIndication() of configuration list EthIfRxIndicationConfig.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest03004_Multiple_UL_RxIndication_VLAN</srcid><srcstatus/><internalId>1385</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00104</linksto>
          <dstversion>3</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>463</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00105</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>464</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>189</internalId></specobject>
    <specobject>
      <id>EthIf.EB.User_RxIndication</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If EthIf_RxIndication() is called and FrameType is not VLAN (0x8100):
        EthIf_RxIndication() shall call corresponding configured User_RxIndication() with the
        following arguments: all arguments are just passed on
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_T500_RxIndication_NoVLAN_Forwarding</srcid><srcstatus/><internalId>1811</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>190</internalId></specobject>
    <specobject>
      <id>EthIf.EB.User_RxIndication_MultipleUL</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If EthIf_RxIndication() is called and FrameType is not 0x8100 (VLAN):
        EthIf_RxIndication() shall call corresponding configured User_RxIndication() with the
        following arguments: all arguments are just passed on
        It shall be verified that EthIf really maps the frame type to the corresponding frame owner
        and uses the configured User_RxIndication() of configuration list EthIfRxIndicationConfig.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest03003_Multiple_UL_RxIndication_NotVLAN</srcid><srcstatus/><internalId>1384</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00104</linksto>
          <dstversion>3</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>463</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00105</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>464</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>191</internalId></specobject>
    <specobject>
      <id>EthIf.EB.EthIf_RxIndication.IgnorInvalidNoVLANCtrlIdx</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If EthIf_RxIndication() is called and FrameType is not 0x8100 (no VLAN):
        If the parameter CtrlIdx does not match to any EthIfCtrlIdx with disabled config parameter
        EthIfVlanId, the frame shall be ignored.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest02020_InvalidNoVLANCtrlIdx_RxIndication</srcid><srcstatus/><internalId>1904</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>192</internalId></specobject>
    <specobject>
      <id>EthIf.EB.EthIf_RxIndication.NotConfiguredFrameType</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If EthIf_RxIndication() is called and FrameType is not configured in EthIfFrameOwnerConfig
        the module shall ignore the received frame.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest03010_RxIndication_NotConf_FrameType</srcid><srcstatus/><internalId>1391</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>193</internalId></specobject>
    <specobject>
      <id>EthIf.EB.EthIf_TxConfirmation.InvBufIdx</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If EthIf_TxConfirmation() is called with parameter BufIdx set to a value which was not
        been used with a previously call of EthIf_Transmit() for corresponding EthIfCtrlIdx, the
        confirmation shall be ignored.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest02023_TxConfirmation_Invalid_BufIdx</srcid><srcstatus/><internalId>1907</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>194</internalId></specobject>
    <specobject>
      <id>EthIf.EB.SWS_EthIf_00125.Result_E_NOT_OK</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        EthIf_TxConfirmation shall not forward the confirmation to the registered call-back
        functions User_TxConfirmation if the Result parameter is E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest03012_User_TxConfirmation_NOK</srcid><srcstatus/><internalId>1393</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>195</internalId></specobject>
    <specobject>
      <id>EthIf.EB.EthIf_ProvideTxBuffer.DriverError</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If EthIf_ProvideTxBuffer() is called and the lower layer function Eth_ProvideTxBuffer()
        returned a value other than BUFREQ_OK, the function shall return the lower layer return
        value.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest02021_BufReq_NOTOK</srcid><srcstatus/><internalId>1905</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>196</internalId></specobject>
    <specobject>
      <id>EthIf.EB.EthIf_MainFunctionRx.EthTrcvGetLinkStateError</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If EthIf_MainFunctionRx() is called and the lower layer function EthTrcv_GetLinkState()
        returned a value other than E_OK, the function shall skip this EthIf controller until next
        main function cycle.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest03008_UL_TrcvLinkStateChg_GetLinkState_NOTOK</srcid><srcstatus/><internalId>1389</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>197</internalId></specobject>
    <specobject>
      <id>EthIf.EB.EthIf_MainFunctionRx.NoEthTrcv</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If transceiver support is disabled, EthIf shall emulate a transceiver for the upper layer:
        If EthIf_MainFunctionRx() is called the first time, the function shall set all
        EthIf controller to ETHTRCV_LINK_STATE_ACTIVE and inform the upper layer.
      </description>
      <comment>
        Precondition:
        EthIf_TransceiverInit() is called.
        Transceiver mode is set active upon reception of EthIf_CtrlModeIndication().
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest03007_UL_TrcvLinkStateChg_TrcvRef_False</srcid><srcstatus/><internalId>1388</internalId></linkedfrom><linkedfrom><srcid>EthIf_T112_00_SetControllerMode_EthSetControllerMode_NotOk</srcid><srcstatus/><internalId>1758</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>198</internalId></specobject>
    <specobject>
      <id>EthIf.EB.EthTrcvTransceiverInit_NotOk</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If EthTrcv_TransceiverInit() returns E_NOT_OK, EthIf shall handle this transceiver as not
        initialized.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest02007_TransceiverInit_NotOK</srcid><srcstatus/><internalId>1898</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>199</internalId></specobject>
    <!-- Requirements relating to Ethernet Interface MII extension -->
    <specobject>
      <id>EthIf.EB.MIIExtension.ApiSupport</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        There shall be a precompile configuration parameter EthIfGeneral/EthIfMiiApiEnable
        which globally enables or disables ReadMii and WriteMii APIs.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ComTest04</srcid><srcstatus/><internalId>1241</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>200</internalId></specobject>
    <specobject>
      <id>EthIf.EB.MIIExtension.ReadMii.ApiSignature</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Provide API function with the following signature:
        Std_ReturnType EthIf_ReadMii
           (
              uint8 CtrlIdx,
              uint8 RegIdx,
              uint16* RegValPtr
           )
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ComTest04</srcid><srcstatus/><internalId>1241</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>201</internalId></specobject>
    <specobject>
      <id>EthIf.EB.MIIExtension.ReadMii.ServiceId</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The macro ETHIF_READMII_SVCID shall have the value:
        Service ID[hex]: 0x70
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompTest_05_ServiceId_ErrorId</srcid><srcstatus/><internalId>1242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>202</internalId></specobject>
    <specobject>
      <id>EthIf.EB.MIIExtension.WriteMii.ApiSignature</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Provide API function with the following signature:
        Std_ReturnType EthIf_WriteMii
           (
              uint8 CtrlIdx,
              uint8 RegIdx,
              uint16 RegVal
           )
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ComTest04</srcid><srcstatus/><internalId>1241</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>203</internalId></specobject>
    <specobject>
      <id>EthIf.EB.MIIExtension.WriteMii.ServiceId</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The macro ETHIF_WRITEMII_SVCID shall have the value:
        Service ID[hex]: 0x71
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompTest_05_ServiceId_ErrorId</srcid><srcstatus/><internalId>1242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>204</internalId></specobject>
    <specobject>
      <id>EthIf.EB.MIIExtension.ReadMii.Behaviour</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If Mii API feature is enabled, the function EthIf_ReadMii() shall forward the call to function
        Eth_ReadMii() of the respective Ethernet Controller Driver if
        the Mii access flag is not active otherwise the function shall
        return E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest04002_ReadMii_MiiIsFree</srcid><srcstatus/><internalId>1397</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest04003_ReadMii_vs_GetTransceiverMode</srcid><srcstatus/><internalId>1398</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest04006_GetTransceiverMode_vs_ReadMii</srcid><srcstatus/><internalId>1401</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>205</internalId></specobject>
    <specobject>
      <id>EthIf.EB.MIIExtension.WriteMii.Behaviour</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If Mii API feature is enabled, the function EthIf_WriteMii() shall forward the
        call to function Eth_WriteMii() of the respective Ethernet Controller Driver if
        the Mii access flag is not active otherwise the function shall
        return E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest04001_WriteMii_MiiIsFree</srcid><srcstatus/><internalId>1396</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest04004_WriteMii_vs_SetTransceiverMode</srcid><srcstatus/><internalId>1399</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest04005_SetTransceiverMode_vs_WriteMii</srcid><srcstatus/><internalId>1400</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>206</internalId></specobject>
    <specobject>
      <id>EthIf.EB.MIIExtension.ReadMii.DetCheck.NotInit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If DET and Mii API feature is enabled, API function EthIf_ReadMii() shall check
        if the module is initialized and report to DET with errorId ETHIF_E_NOT_INITIALIZED
        and service ID 0x70 if it is not, and return E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01009_1_EthIf_ReadMii_Uninit</srcid><srcstatus/><internalId>1258</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>207</internalId></specobject>
    <specobject>
      <id>EthIf.EB.MIIExtension.WriteMii.DetCheck.NotInit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If DET and Mii API feature is enabled, API function EthIf_WriteMii() shall check
        if the module is initialized and report to DET with errorId ETHIF_E_NOT_INITIALIZED
        and service ID 0x71 if it is not, and return E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01009_2_EthIf_WriteMii_Uninit</srcid><srcstatus/><internalId>1259</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>208</internalId></specobject>
    <specobject>
      <id>EthIf.EB.MIIExtension.ReadMii.DetCheck.InvalidCtrlId</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If DET and Mii API feature is enabled, API function EthIf_ReadMii() shall check
        if parameter CtrlIdx is valid and report to DET with errorId ETHIF_E_INV_CTRL_IDX
        and service ID 0x70 if it is not, and return E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01012_1_EthIf_ReadMii_InvalidCtrlIdx</srcid><srcstatus/><internalId>1268</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>209</internalId></specobject>
    <specobject>
      <id>EthIf.EB.MIIExtension.WriteMii.DetCheck.InvalidCtrlIdx</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If DET and Mii API feature is enabled, API function EthIf_WriteMii() shall check
        if parameter CtrlIdx is valid and report to DET with errorId ETHIF_E_INV_CTRL_IDX
        and service ID 0x71 if it is not, and return E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01012_2_EthIf_WriteMii_InvalidCtrlIdx</srcid><srcstatus/><internalId>1269</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>210</internalId></specobject>
    <specobject>
      <id>EthIf.EB.MIIExtension.ReadMii.DetCheck.CtrlNotInit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If DET and Mii API feature is enabled and API function EthIf_ReadMii() is called while
        the controller is not initialized (EthIf_ControllerInit() was not called for this
        controller), an error shall be reported to Det with error code ETHIF_E_HW_NOT_INITIALIZED
        and corresponding service ID, and E_NOT_OK will be returned.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01084_ReadMii_HardwareUninit</srcid><srcstatus/><internalId>1306</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>211</internalId></specobject>
    <specobject>
      <id>EthIf.EB.MIIExtension.WriteMii.DetCheck.CtrlNotInit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If DET and Mii API feature is enabled and API function EthIf_WriteMii() is called while
        the controller is not initialized (EthIf_ControllerInit() was not called for this
        controller), an error shall be reported to Det with error code ETHIF_E_HW_NOT_INITIALIZED
        and corresponding service ID, and E_NOT_OK will be returned.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01083_WriteMii_HardwareUninit</srcid><srcstatus/><internalId>1305</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>212</internalId></specobject>
    <specobject>
      <id>EthIf.EB.MIIExtension.SetTransceiverMode.CheckMiiAccessFlag.Not_Active</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Upon reception of EthIf_CtrlModeIndication() EthIf module will call
        EthTrcv_SetTransceiverMode() of the respective Ethernet Transceiver Driver if
        the Mii access flag is not active.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest04005_SetTransceiverMode_vs_WriteMii</srcid><srcstatus/><internalId>1400</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>213</internalId></specobject>
    <specobject>
      <id>EthIf.EB.MIIExtension.SetTransceiverMode.CheckMiiAccessFlag.Active</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Upon reception of EthIf_CtrlModeIndication() EthIf module will not call
        EthTrcv_SetTransceiverMode() of the respective Ethernet Transceiver Driver if
        the Mii access flag is active.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest04004_WriteMii_vs_SetTransceiverMode</srcid><srcstatus/><internalId>1399</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>214</internalId></specobject>
    <specobject>
      <id>EthIf.EB.MIIExtension.GetTransceiverMode.CheckMiiAccessFlag.Not_Active</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The function EthTrcv_GetTransceiverMode will be called only if the Mii access flag
        is not active.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest04006_GetTransceiverMode_vs_ReadMii</srcid><srcstatus/><internalId>1401</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>215</internalId></specobject>
    <specobject>
      <id>EthIf.EB.MIIExtension.GetTransceiverMode.CheckMiiAccessFlag.Active</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The function EthTrcv_GetTransceiverMode shall not be called if the Mii access
        flag is active.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest04003_ReadMii_vs_GetTransceiverMode</srcid><srcstatus/><internalId>1398</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>216</internalId></specobject>
    <specobject>
      <id>EthIf.EB.MIIExtension.SetSwitchPortMode.CheckMiiAccessFlag</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The function EthSwt_SetSwitchPortMode() shall not be called if the Mii access
        flag is active. The call will be repeated in the next EthIf_MainFunction() call.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06019_SetSwitchPortMode_MiiCheck</srcid><srcstatus/><internalId>1487</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06019_SetSwitchPortMode_MiiCheck_Wakeup</srcid><srcstatus/><internalId>1488</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR430_SetControllerMode_Wakeup_Preemption_Switch_4</srcid><srcstatus/><internalId>1654</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>217</internalId></specobject>
    <specobject>
      <id>EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        EthIf_MainFunctionRx() shall only perform API calls to module EthTrcv of
        the respective Ethernet Transceiver Driver if the Mii access flag is not active.
        This is also valid for API calls to EthSwt driver in case referenced port is
        connected to a transceiver.
      </description>
      <furtherinfo>
        WRN.swuts.needscoverage.count - Linking all relevant test cases to the single requirement brings clear benefits and
        splitting them up would only increase complexity without any real improvements.
      </furtherinfo>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest04009_MainFunctionRx_InactiveMiiAccessFlag</srcid><srcstatus/><internalId>1402</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest04011_MainFunctionRx_ActiveMiiAccessFlag</srcid><srcstatus/><internalId>1403</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06017_MainFunction_SwitchPortMiiCheck</srcid><srcstatus/><internalId>1484</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06020_EthSwt_GetLinkState_MiiCheck</srcid><srcstatus/><internalId>1489</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06020_EthSwt_GetLinkState_MiiCheck_Wakeup</srcid><srcstatus/><internalId>1490</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR403_SetControllerMode_Wakeup_Preemption_Transceiver</srcid><srcstatus/><internalId>1552</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR403_SetControllerMode_Wakeup_Preemption_Transceiver_2</srcid><srcstatus/><internalId>1553</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR403_SetControllerMode_Wakeup_Preemption_Transceiver_3</srcid><srcstatus/><internalId>1554</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR403_SetControllerMode_Wakeup_Preemption_Transceiver_4</srcid><srcstatus/><internalId>1555</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR403_SetControllerMode_Wakeup_Preemption_Switch</srcid><srcstatus/><internalId>1564</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR403_SetControllerMode_Wakeup_Preemption_Switch_2</srcid><srcstatus/><internalId>1565</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR403_SetControllerMode_Wakeup_Preemption_Switch_3</srcid><srcstatus/><internalId>1566</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR403_SetControllerMode_Wakeup_Preemption_SwitchPortGroup</srcid><srcstatus/><internalId>1579</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR403_SetControllerMode_Wakeup_Preemption_SwitchPortGroup_2</srcid><srcstatus/><internalId>1580</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR403_SetControllerMode_Wakeup_Preemption_SwitchPortGroup_3</srcid><srcstatus/><internalId>1581</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR422_SetControllerMode_Wakeup_Preemption_Transceiver</srcid><srcstatus/><internalId>1591</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR422_SetControllerMode_Wakeup_Preemption_Transceiver_2</srcid><srcstatus/><internalId>1592</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR422_SetControllerMode_Wakeup_Preemption_Transceiver_3</srcid><srcstatus/><internalId>1593</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR422_SetControllerMode_Wakeup_Preemption_Transceiver_4</srcid><srcstatus/><internalId>1594</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR422_SetControllerMode_Wakeup_Preemption_Switch</srcid><srcstatus/><internalId>1603</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR422_SetControllerMode_Wakeup_Preemption_Switch_2</srcid><srcstatus/><internalId>1604</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR422_SetControllerMode_Wakeup_Preemption_Switch_3</srcid><srcstatus/><internalId>1605</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR422_SetControllerMode_Wakeup_Preemption_SwitchPortGroup</srcid><srcstatus/><internalId>1618</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR422_SetControllerMode_Wakeup_Preemption_SwitchPortGroup_2</srcid><srcstatus/><internalId>1619</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR422_SetControllerMode_Wakeup_Preemption_SwitchPortGroup_3</srcid><srcstatus/><internalId>1620</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR430_SetControllerMode_Wakeup_Preemption_Transceiver</srcid><srcstatus/><internalId>1639</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR430_SetControllerMode_Wakeup_Preemption_Transceiver_2</srcid><srcstatus/><internalId>1640</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR430_SetControllerMode_Wakeup_Preemption_Transceiver_3</srcid><srcstatus/><internalId>1641</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR430_SetControllerMode_Wakeup_Preemption_Transceiver_4</srcid><srcstatus/><internalId>1642</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR430_SetControllerMode_Wakeup_Preemption_Switch</srcid><srcstatus/><internalId>1651</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR430_SetControllerMode_Wakeup_Preemption_Switch_2</srcid><srcstatus/><internalId>1652</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR430_SetControllerMode_Wakeup_Preemption_Switch_3</srcid><srcstatus/><internalId>1653</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR430_SetControllerMode_Wakeup_Preemption_SwitchPortGroup</srcid><srcstatus/><internalId>1667</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR430_SetControllerMode_Wakeup_Preemption_SwitchPortGroup_2</srcid><srcstatus/><internalId>1668</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR430_SetControllerMode_Wakeup_Preemption_SwitchPortGroup_3</srcid><srcstatus/><internalId>1669</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>218</internalId></specobject>
    <specobject>
      <id>EthIf.EB.MIIExtension.EthIf_MacSecUpdateSecY.CheckMiiAccessFlag.Active</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The function EthIf_MacSecUpdateSecY shall not forward the call to function
        EthTrcv_MacSecUpdateSecY of the respective Ethernet Transceiver Driver if the Mii
        access flag is active and the function shall return E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01305_MacSecUpdateSecY_ActiveMiiAccessFlag</srcid><srcstatus/><internalId>1735</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>219</internalId></specobject>
    <specobject>
      <id>EthIf.EB.MIIExtension.EthIf_MacSecAddTxSa.CheckMiiAccessFlag.Active</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The function EthIf_MacSecAddTxSa shall not forward the call to function
        EthTrcv_MacSecAddTxSa of the respective Ethernet Transceiver Driver if the Mii
        access flag is active and the function shall return E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01306_MacSecAddTxSa_ActiveMiiAccessFlag</srcid><srcstatus/><internalId>1736</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>220</internalId></specobject>
    <specobject>
      <id>EthIf.EB.MIIExtension.EthIf_MacSecAddRxSa.CheckMiiAccessFlag.Active</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The function EthIf_MacSecAddRxSa shall not forward the call to function
        EthTrcv_MacSecAddRxSa of the respective Ethernet Transceiver Driver if the Mii
        access flag is active and the function shall return E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01307_MacSecAddRxSa_ActiveMiiAccessFlag</srcid><srcstatus/><internalId>1737</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>221</internalId></specobject>
    <specobject>
      <id>EthIf.EB.MIIExtension.EthIf_MacSecGetMacSecStats.CheckMiiAccessFlag.Active</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The function EthIf_MacSecGetMacSecStats shall not forward the call to function
        EthTrcv_MacSecGetMacSecStats of the respective Ethernet Transceiver Driver if the Mii
        access flag is active and the function shall return E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01308_MacSecGetMacSecStats_ActiveMiiAccessFlag</srcid><srcstatus/><internalId>1738</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>222</internalId></specobject>
    <specobject>
      <id>EthIf.EB.MIIExtension.EthIf_MacSecInitRxSc.CheckMiiAccessFlag.Active</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The function EthIf_MacSecInitRxSc shall not forward the call to function
        EthTrcv_MacSecInitRxSc of the respective Ethernet Transceiver Driver if the Mii
        access flag is active and the function shall return E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01309_MacSecInitRxSc_ActiveMiiAccessFlag</srcid><srcstatus/><internalId>1739</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>223</internalId></specobject>
    <specobject>
      <id>EthIf.EB.MIIExtension.EthIf_MacSecResetRxSc.CheckMiiAccessFlag.Active</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The function EthIf_MacSecResetRxSc shall not forward the call to function
        EthTrcv_MacSecResetRxSc of the respective Ethernet Transceiver Driver if the Mii
        access flag is active and the function shall return E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01310_MacSecResetRxSc_ActiveMiiAccessFlag</srcid><srcstatus/><internalId>1740</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>224</internalId></specobject>
    <specobject>
      <id>EthIf.EB.MIIExtension.EthIf_MacSecUpdateTxSa.CheckMiiAccessFlag.Active</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The function EthIf_MacSecUpdateTxSa shall not forward the call to function
        EthTrcv_MacSecUpdateTxSa of the respective Ethernet Transceiver Driver if the Mii
        access flag is active and the function shall return E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01311_MacSecUpdateTxSa_ActiveMiiAccessFlag</srcid><srcstatus/><internalId>1741</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>225</internalId></specobject>
    <specobject>
      <id>EthIf.EB.MIIExtension.EthIf_MacSecDeleteTxSa.CheckMiiAccessFlag.Active</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The function EthIf_MacSecDeleteTxSa shall not forward the call to function
        EthTrcv_MacSecDeleteTxSa of the respective Ethernet Transceiver Driver if the Mii
        access flag is active and the function shall return E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01312_MacSecDeleteTxSa_ActiveMiiAccessFlag</srcid><srcstatus/><internalId>1742</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>226</internalId></specobject>
    <specobject>
      <id>EthIf.EB.MIIExtension.EthIf_MacSecUpdateRxSa.CheckMiiAccessFlag.Active</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The function EthIf_MacSecUpdateRxSa shall not forward the call to function
        EthTrcv_MacSecUpdateRxSa of the respective Ethernet Transceiver Driver if the Mii
        access flag is active and the function shall return E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01313_MacSecUpdateRxSa_ActiveMiiAccessFlag</srcid><srcstatus/><internalId>1743</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>227</internalId></specobject>
    <specobject>
      <id>EthIf.EB.MIIExtension.EthIf_MacSecDeleteRxSa.CheckMiiAccessFlag.Active</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The function EthIf_MacSecDeleteRxSa shall not forward the call to function
        EthTrcv_MacSecDeleteRxSa of the respective Ethernet Transceiver Driver if the Mii
        access flag is active and the function shall return E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01314_MacSecDeleteRxSa_ActiveMiiAccessFlag</srcid><srcstatus/><internalId>1744</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>228</internalId></specobject>
    <specobject>
      <id>EthIf.EB.MIIExtension.EthIf_MacSecGetTxSaNextPn.CheckMiiAccessFlag.Active</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The function EthIf_MacSecGetTxSaNextPn shall not forward the call to function
        EthTrcv_MacSecGetTxSaNextPn of the respective Ethernet Transceiver Driver if the Mii
        access flag is active and the function shall return E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01315_MacSecGetTxSaNextPn_ActiveMiiAccessFlag</srcid><srcstatus/><internalId>1745</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>229</internalId></specobject>
    <specobject>
      <id>EthIf.EB.MIIExtension.EthIf_MacSecSetControlledPortEnabled.CheckMiiAccessFlag.Active</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The function EthIf_MacSecSetControlledPortEnabled shall not forward the call to function
        EthTrcv_MacSecSetControlledPortEnabled of the respective Ethernet Transceiver Driver if the
        Mii access flag is active and the function shall return E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01316_MacSecSetControlledPortEnabled_ActiveMiiAccessFlag</srcid><srcstatus/><internalId>1746</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>230</internalId></specobject>
    <specobject>
      <id>EthIf.EB.No_MIIExtension</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
          EthIf shall not set the link state to down if Mii can not be accessed.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest04019_Mii_Blocked</srcid><srcstatus/><internalId>1410</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>231</internalId></specobject>
    <specobject>
      <id>EthIf.EB.SchedulerExclusiveArea</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        EthIf module requires scheduler exclusive area for the purpose of protecting Ethernet
        Transceiver Driver Mii access.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ComTest_08_SwcdCheck_CheckExclusiveArea</srcid><srcstatus/><internalId>1245</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>232</internalId></specobject>
    <specobject>
      <id>EthIf.EB.ScheduleMainFuctionState</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
          If EthIfMainFunctionStatePeriod is enabled, EthIf shall provide the information to
          schedule the EthIf_MainFunctionState() used by RTE.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ComTest_08_SwcdCheck_CheckScheduleMainFuctionState</srcid><srcstatus/><internalId>1246</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>233</internalId></specobject>
    <specobject>
      <id>EthIf.EB.EthSwtSupport.SWS_EthIf_00190.INV_SWT_IDX</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function EthIf_GetPortMacAddr
        shall check the parameter SwitchIdx for being valid. If the check fails, the function
        shall raise the development error ETHIF_E_INV_SWT_IDX.
      </description>
      <comment>
        EB extension requirement - required for checking the correct switch index.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest05_SwtSupport_GetPortMacAddr_InvSwtIdx</srcid><srcstatus/><internalId>1455</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>234</internalId></specobject>
    <specobject>
      <id>EthIf.EB.EthSwtSupport.SWS_EthIf_00196.INV_SWT_IDX</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function EthIf_GetArlTable
        shall check the parameter SwitchIdx for being valid. If the check fails, the function
        shall raise the development error ETHIF_E_INV_SWT_IDX.
      </description>
      <comment>
        EB extension requirement - required for checking the correct switch index.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest05_SwtSupport_GetArlTable_InvSwtIdx</srcid><srcstatus/><internalId>1456</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>235</internalId></specobject>
    <specobject>
      <id>EthIf.EB.EthSwtSupport.SWS_EthIf_00202.INV_SWT_IDX</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function EthIf_GetBufferLevel
        shall check the parameter SwitchIdx for being valid. If the check fails, the function
        shall raise the development error ETHIF_E_INV_SWT_IDX.
      </description>
      <comment>
        EB extension requirement - required for checking the correct switch index.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest05_SwtSupport_GetBufferLevel_InvSwtIdx</srcid><srcstatus/><internalId>1457</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>236</internalId></specobject>
    <specobject>
      <id>EthIf.EB.EthSwtSupport.EthIf_SwtGetCounterValues.INV_SWT_IDX</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function EthIf_SwtGetCounterValues
        shall check the parameter SwitchIdx for being valid. If the check fails, the function
        shall raise the development error ETHIF_E_INV_SWT_IDX.
      </description>
      <comment>
        EB extension requirement - required for checking the correct switch index.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest05_SwtSupport_SwtGetCounterValue_InvSwtIdx</srcid><srcstatus/><internalId>1458</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>237</internalId></specobject>
    <specobject>
      <id>EthIf.EB.EthSwtSupport.SWS_EthIf_00214.INV_SWT_IDX</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function EthIf_StoreConfiguration
        shall check the parameter SwitchIdx for being valid. If the check fails, the function
        shall raise the development error ETHIF_E_INV_SWT_IDX.
      </description>
      <comment>
        EB extension requirement - required for checking the correct switch index.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest05_SwtSupport_StoreConfiguration_InvSwtIdx</srcid><srcstatus/><internalId>1459</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>238</internalId></specobject>
    <specobject>
      <id>EthIf.EB.EthSwtSupport.SWS_EthIf_00219.INV_SWT_IDX</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function EthIf_ResetConfiguration
        shall check the parameter SwitchIdx for being valid. If the check fails, the function
        shall raise the development error ETHIF_E_INV_SWT_IDX.
      </description>
      <comment>
        EB extension requirement - required for checking the correct switch index.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest05_SwtSupport_ResetConfiguration_InvSwtIdx</srcid><srcstatus/><internalId>1460</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>239</internalId></specobject>
    <!-- Requirements relating to Ethernet Interface QoS extension -->
    <specobject>
      <id>EthIf.EB.QoSExtension.MainFunctionRxPrio.Uninit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        EthIf_MainFunctionRxPrio shall check that the service EthIf_Init was previously called.
        If the check fails, the function shall return without taking any action.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest05000_MainFunction_Uninit</srcid><srcstatus/><internalId>1434</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>240</internalId></specobject>
    <specobject>
      <id>EthIf.EB.QoSExtension.MainFunctionRxPrio.CtrlNotInit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        EthIf_MainFunctionRxPrio() shall check for EthCtrlIdx if controller is initialized and
        shall not perform any API call to other modules if not initialized.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest05001_MainFunction_NotInit</srcid><srcstatus/><internalId>1435</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>241</internalId></specobject>
    <specobject>
      <id>EthIf.EB.QoSExtension.MainFunctionRxPrio_PollEthReceiveMax</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        EthIf_MainFunctionRxPrio() shall poll Eth_PriorityReceive() to the maximum number defined
        by configuration parameter EthIfRxIndicationIterations for each configured controller.
      </description>
      <comment>
        Precondition:
        - Controllers are initialized.
        - Controller are set to ETH_MODE_ACTIVE.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest05005_MainFunctionRxPrio_Polling</srcid><srcstatus/><internalId>1436</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest05006_MainFunctionRx_Polling</srcid><srcstatus/><internalId>1437</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>242</internalId></specobject>
    <specobject>
      <id>EthIf.EB.QoSExtension.MainFunctionRxPrio_PollEthReceiveNoData</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If EthIf_MainFunctionRxPrio() polls Eth_PriorityReceive() and no further data are available
        (Output parameter RxStatus != ETH_RECEIVED_MORE_DATA_AVAILABLE), the function shall stop
        polling for data of this controller.
      </description>
      <comment>
        Precondition:
        - Controllers are initialized.
        - Controller are set to ETH_MODE_ACTIVE.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest05007_MainFunctionRxPrio_ETH_RECEIVED</srcid><srcstatus/><internalId>1438</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>243</internalId></specobject>
    <specobject>
      <id>EthIf.EB.EthIfSupportEthAPI</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        There shall be a precompile configuration parameter EthIfGeneral/EthIfSupportEthAPI of
        enumeration type which is used to select support of correct version of Eth API, according
        to the version of AUTOSAR.
        Enumeration values:
         - ASR403: AUTOSAR 4.0 rev. 3
         - ASR422: AUTOSAR 4.2 rev. 2
         - ASR430: AUTOSAR 4.3 rev. 0
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompileTest_01</srcid><srcstatus/><internalId>1237</internalId></linkedfrom><linkedfrom><srcid>EthIf_ComTest02</srcid><srcstatus/><internalId>1239</internalId></linkedfrom><linkedfrom><srcid>EthIf_CompileTest_03</srcid><srcstatus/><internalId>1240</internalId></linkedfrom><linkedfrom><srcid>EthIf_ComTest04</srcid><srcstatus/><internalId>1241</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>244</internalId></specobject>
    <specobject>
      <id>EthIf.EB.MIIExtension.EthIf_SetPhyLoopbackMode.CheckMiiAccessFlag.Active</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The function EthIf_SetPhyLoopbackMode shall not forward the call to function
        EthTrcv_SetPhyLoopbackMode of the respective Ethernet Transceiver Driver if the Mii access
        flag is active and the function shall return E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest04013_SetPhyLoopbackMode_ActiveMiiAccessFlag</srcid><srcstatus/><internalId>1404</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>245</internalId></specobject>
    <specobject>
      <id>EthIf.EB.MIIExtension.EthIf_SetPhyTxMode.CheckMiiAccessFlag.Active</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The function EthIf_SetPhyTxMode shall not forward the call to function
        EthTrcv_SetPhyTxMode of the respective Ethernet Transceiver Driver if the Mii access
        flag is active and the function shall return E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest04014_SetPhyTxMode_ActiveMiiAccessFlag</srcid><srcstatus/><internalId>1405</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>246</internalId></specobject>
    <specobject>
      <id>EthIf.EB.MIIExtension.EthIf_GetCableDiagnosticsResult.CheckMiiAccessFlag.Active</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The function EthIf_GetCableDiagnosticsResult shall not forward the call to function
        EthTrcv_GetCableDiagnosticsResult of the respective Ethernet Transceiver Driver if the Mii
        access flag is active and the function shall return E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest04015_GetCableDiagnosticsResult_ActiveMiiAccessFlag</srcid><srcstatus/><internalId>1406</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>247</internalId></specobject>
    <specobject>
      <id>EthIf.EB.MIIExtension.EthIf_GetPhyIdentifier.CheckMiiAccessFlag.Active</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The function EthIf_GetPhyIdentifier shall not forward the call to function
        EthTrcv_GetPhyIdentifier of the respective Ethernet Transceiver Driver if the Mii
        access flag is active and the function shall return E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest04016_GetPhyIdentifier_ActiveMiiAccessFlag</srcid><srcstatus/><internalId>1407</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>248</internalId></specobject>
    <specobject>
      <id>EthIf.EB.MIIExtension.EthIf_GetTrcvSignalQuality.CheckMiiAccessFlag.Active</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The function EthIf_GetTrcvSignalQuality shall not forward the call to function
        EthTrcv_GetTrcvSignalQuality of the respective Ethernet Transceiver Driver if the Mii
        access flag is active and the function shall return E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest04017_GetTrcvSignalQuality_ActiveMiiAccessFlag</srcid><srcstatus/><internalId>1408</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>249</internalId></specobject>
    <specobject>
      <id>EthIf.EB.MIIExtension.EthIf_SetPhyTestMode.CheckMiiAccessFlag.Active</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The function EthIf_SetPhyTestMode shall not forward the call to function
        EthTrcv_SetPhyTestMode of the respective Ethernet Transceiver Driver if the Mii
        access flag is active and the function shall return E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest04018_SetPhyTestMode_ActiveMiiAccessFlag</srcid><srcstatus/><internalId>1409</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>250</internalId></specobject>
    <specobject>
      <id>EthIf.EB.HandleIDWizard</id>
      <status>approved</status>
      <source>EB specific</source>
      <version>1</version>
      <description>
        The module shall support the correct automatic calculation of
        the handle IDs for the following parameters:
        - EthIfTransceiverIdx
        - EthIfPhysControllerIdx
        - EthIfSwitchIdx
        - EthIfSwitchPortGroupIdx
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.EB.HandleIDWizard.EthIfTransceiverIdx</srcid><srcstatus/><internalId>252</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.HandleIDWizard.EthIfPhysControllerIdx</srcid><srcstatus/><internalId>253</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.HandleIDWizard.EthIfSwitchIdx</srcid><srcstatus/><internalId>254</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.HandleIDWizard.EthIfSwitchPortGroupIdx</srcid><srcstatus/><internalId>255</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>251</internalId></specobject>
    <specobject>
      <id>EthIf.EB.HandleIDWizard.EthIfTransceiverIdx</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The module shall support the correct automatic calculation of
        the handle IDs for EthIfTransceiverIdx.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ComTest_07_HandleId_Gen</srcid><srcstatus/><internalId>1244</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.HandleIDWizard</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>251</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>252</internalId></specobject>
    <specobject>
      <id>EthIf.EB.HandleIDWizard.EthIfPhysControllerIdx</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The module shall support the correct automatic calculation of
        the handle IDs for EthIfPhysControllerIdx.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ComTest_07_HandleId_Gen</srcid><srcstatus/><internalId>1244</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.HandleIDWizard</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>251</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>253</internalId></specobject>
    <specobject>
      <id>EthIf.EB.HandleIDWizard.EthIfSwitchIdx</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The module shall support the correct automatic calculation of
        the handle IDs for EthIfSwitchIdx.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ComTest_07_HandleId_Gen</srcid><srcstatus/><internalId>1244</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.HandleIDWizard</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>251</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>254</internalId></specobject>
    <specobject>
      <id>EthIf.EB.HandleIDWizard.EthIfSwitchPortGroupIdx</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The module shall support the correct automatic calculation of
        the handle IDs for EthIfSwitchPortGroupIdx.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ComTest_07_HandleId_Gen</srcid><srcstatus/><internalId>1244</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.HandleIDWizard</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>251</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>255</internalId></specobject>
    <!-- Requirements relating to the configuration parameter EthIfSetModeTimeout -->
    <specobject>
      <id>EthIf.EB.SetModeTimeout_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name                EthIfSetModeTimeout  {ETHIF_SET_MODE_TIMEOUT}
        Description         Specifies in which time duration the EthIf module shall repeat (delay)
                            a call to set mode APIs.
        Multiplicity        0..1
        Type                EcucFloatParamDef
        Default value       -
        ConfigurationClass
        Pre-compile time   X   VARIANT-PRE-COMPILE
        Link time          X   VARIANT-LINK-TIME
        Post-build time    X   VARIANT-POST-BUILD
        Scope / Dependency  scope: Local
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.EB.SetModeTimeout.Maximum</srcid><srcstatus/><internalId>257</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.SetModeTimeout.RepeatRequest.GetLinkStateDown</srcid><srcstatus/><internalId>258</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.SetModeTimeout.RepeatRequest.EthSwtGetLinkStateDown</srcid><srcstatus/><internalId>259</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.SetModeTimeout.RepeatRequest.ReadFail</srcid><srcstatus/><internalId>260</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.SetModeTimeout.NotMultipleValue</srcid><srcstatus/><internalId>1209</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.SetModeTimeout.MaxValue</srcid><srcstatus/><internalId>1210</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>256</internalId></specobject>
    <specobject>
      <id>EthIf.EB.SetModeTimeout.Maximum</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If calculation of (EthIfSetModeTimeout/EthIfMainFunctionPeriod) together with
        rounding results is a value greater than 65535, the macro ETHIF_SET_MODE_TIMEOUT shall
        be limited to 65535.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompileTest_SetModeTimeout</srcid><srcstatus/><internalId>1238</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SetModeTimeout_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>256</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>257</internalId></specobject>
    <specobject>
      <id>EthIf.EB.SetModeTimeout.RepeatRequest.GetLinkStateDown</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If EthIfSetModeTimeout is enabled (ETHIF_SET_MODE_TIMEOUT &gt; 0) and respective
        controller and transceiver are both ACTIVE, and a call to EthTrcv_GetLinkState() returns
        ETHTRCV_LINK_STATE_DOWN for ETHIF_SET_MODE_TIMEOUT times, EthIf module shall repeat a
        call to EthTrcv_SetTransceiverMode(ETHTRCV_MODE_ACTIVE).
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest02035_SetModeTimeout_GetLinkStateDown</srcid><srcstatus/><internalId>1916</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SetModeTimeout_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>256</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>258</internalId></specobject>
    <specobject>
      <id>EthIf.EB.SetModeTimeout.RepeatRequest.EthSwtGetLinkStateDown</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If EthIfSetModeTimeout is enabled (ETHIF_SET_MODE_TIMEOUT &gt; 0) and respective switch port
        is ACTIVE (as a part of an active switch port group), and a call to EthSwt_GetLinkState()
        returns ETHTRCV_LINK_STATE_DOWN for ETHIF_SET_MODE_TIMEOUT times, EthIf module shall
        repeat a call to EthSwt_SetSwitchPortMode().
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06011_SetModeTimeout_EthSwtGetLinkStateDown</srcid><srcstatus/><internalId>1477</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR403_SetControllerMode_Wakeup_Repeat_Switch</srcid><srcstatus/><internalId>1562</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR403_SetControllerMode_Wakeup_Repeat_SwitchPortGroup</srcid><srcstatus/><internalId>1577</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR422_SetControllerMode_Wakeup_Repeat_Switch</srcid><srcstatus/><internalId>1601</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR422_SetControllerMode_Wakeup_Repeat_SwitchPortGroup</srcid><srcstatus/><internalId>1616</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR430_SetControllerMode_Wakeup_Repeat_Switch</srcid><srcstatus/><internalId>1649</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR430_SetControllerMode_Wakeup_Repeat_SwitchPortGroup</srcid><srcstatus/><internalId>1665</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SetModeTimeout_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>256</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>259</internalId></specobject>
    <specobject>
      <id>EthIf.EB.SetModeTimeout.RepeatRequest.ReadFail</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If EthIfSetModeTimeout is enabled (ETHIF_SET_MODE_TIMEOUT &gt; 0) and a respective
        controller is active and a call to EthTrcv_GetTransceiverMode() returns transceiver mode
        that is different to the value previously set for ETHIF_SET_MODE_TIMEOUT times,
        EthIf module shall repeat a call to EthTrcv_SetTransceiverMode().
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ASR403_SetControllerMode_Wakeup_Repeat_Transceiver</srcid><srcstatus/><internalId>1550</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR403_SetControllerMode_Wakeup_Repeat_Next_Transceiver</srcid><srcstatus/><internalId>1551</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR422_SetControllerMode_Wakeup_Repeat_Transceiver</srcid><srcstatus/><internalId>1589</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR422_SetControllerMode_Wakeup_Repeat_Next_Transceiver</srcid><srcstatus/><internalId>1590</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR430_SetControllerMode_Wakeup_Repeat_Transceiver</srcid><srcstatus/><internalId>1637</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR430_SetControllerMode_Wakeup_Repeat_Next_Transceiver</srcid><srcstatus/><internalId>1638</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest02036_SetModeTimeout_ReadFail</srcid><srcstatus/><internalId>1917</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SetModeTimeout_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>256</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>260</internalId></specobject>
    <specobject>
      <id>EthIf.EB.Repeat.SetTransceiverMode.HwNotOk</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If a call to EthSwt_SetTransceiverMode() fails, the call will be repeated in the following
        EthIf_MainFunction() call.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06043_SetTransceiverMode_NOT_OK</srcid><srcstatus/><internalId>1468</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06044_SetTransceiverMode_NOT_OK_2</srcid><srcstatus/><internalId>1469</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>261</internalId></specobject>
    <specobject>
      <id>EthIf.EB.StartAllPorts_SetPortMode_NOK</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If EthSwt_SetSwitchPortMode() called within EthIf_StartAllPorts() returned E_NOT_OK for any
        of requested ports, then EthSwt_SetSwitchPortMode() shall also return E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06010_StartAllPorts_SetPortMode_NOK</srcid><srcstatus/><internalId>1478</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>262</internalId></specobject>
    <specobject>
      <id>EthIf.EB.PhyEthCtrlState_NotInit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        PhyEthCtrl state can not be updated if it is not initialized.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06014_PhyEthCtrlState_NotInitialized</srcid><srcstatus/><internalId>1481</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>263</internalId></specobject>
    <specobject>
      <id>EthIf.EB.Repeat.SetSwitchPortMode.HwNotOk</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If a call to EthSwt_SetSwitchPortMode() fails, the call will be repeated in the following
        EthIf_MainFunction() call.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06017_MainFunction_SwitchPortMiiCheck</srcid><srcstatus/><internalId>1484</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06017_MainFunction_SwitchPortMiiCheck_Wakeup</srcid><srcstatus/><internalId>1485</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR403_SetControllerMode_Wakeup_Repeat_Next_Switch</srcid><srcstatus/><internalId>1563</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR403_SetControllerMode_Wakeup_Repeat_Next_SwitchPortGroup</srcid><srcstatus/><internalId>1578</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR422_SetControllerMode_Wakeup_Repeat_Next_Switch</srcid><srcstatus/><internalId>1602</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR422_SetControllerMode_Wakeup_Repeat_Next_SwitchPortGroup</srcid><srcstatus/><internalId>1617</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR430_SetControllerMode_Wakeup_Repeat_Next_Switch</srcid><srcstatus/><internalId>1650</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR430_SetControllerMode_Wakeup_Repeat_Next_SwitchPortGroup</srcid><srcstatus/><internalId>1666</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>264</internalId></specobject>
    <specobject>
      <id>EthIf.EB.MainFunctionCycleCounter</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        In order to avoid multpile calculation procedures (like link state accumulation)
        or hardware accesses within a single MainFunction cycle each relevant object should
        be provided with a variable holding current MainFunction cycle counter.
        Prior object updating it is checked weather this variable is already set to the current
        MainFunction cycle cunter, and if update is avoided, and value is only red.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06013_MainFunctionCycleCounter</srcid><srcstatus/><internalId>1480</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>265</internalId></specobject>
    <specobject>
      <id>EthIf.EB.SetTransceiverWakeupMode_NoChange</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If EthIf_SetTransceiverWakeupMode() is called with ETHTRCV_WUM_ENABLE and the current wake-up
        mode is ETHTRCV_WUM_ENABLE, or it is called with ETHTRCV_WUM_DISABLE, while the current mode is
        ETHTRCV_WUM_DISABLE, no call to Ethernet transcever driver will be made and E_OK will be
        returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest07001_SetTransceiverWakeupMode</srcid><srcstatus/><internalId>1535</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>266</internalId></specobject>
    <specobject>
      <id>EthIf.EB.SetTransceiverWakeupMode_ClearEnabled</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If EthIf_SetTransceiverWakeupMode() is called with ETHTRCV_WUM_CLEAR and the current
        state of the requested transceiver is ETHTRCV_WUM_ENABLE, the call shall not be forwarded
        to EthTrcv and E_NOT_OK shall be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest07006_SetTransceiverWakeupMode_ClearEnabled</srcid><srcstatus/><internalId>1540</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>267</internalId></specobject>
    <specobject>
      <id>EthIf.EB.SWS_EthIf_00245_PoolAllTrcvs</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        EthIf_CheckWakeup() calls EthTrcv_CheckWakeup() for all configured EthIfTransceivers.
        Rationale:
        Although EthIf_CheckWakeup() is called with a parameter WakeupSource specifying which wake-up
        sources should be checked and reported, the function EthTrcv_CheckWakeup() does not have
        the parameter WakeupSource. This means that it will report all active wake-up sources, not
        only those requested by EcuM.
        This requires EcuM to filter-out unwanted wake-up sources. Since this mechanism is in place
        EthIf can poll all configured transceivers, with no need to parse transceiver configuration
        related to wake-up source configuration.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest07004_CheckWakeup_Ok</srcid><srcstatus/><internalId>1538</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>268</internalId></specobject>
    <specobject>
      <id>EthIf.EB.CheckWakeup_RetVal</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        EthIf_CheckWakeup() will return E_OK if all calls to EthTrcv_CheckWakeup() returned E_OK.
        Otherwise E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest07004_CheckWakeup_Ok</srcid><srcstatus/><internalId>1538</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest07005_CheckWakeup_NotOk</srcid><srcstatus/><internalId>1539</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>269</internalId></specobject>
    <specobject>
      <id>EthIf.EB.InitControllersTransceivers</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If configuration parameter EthIfInitControllersTransceivers is set to true, EthIf will
        initialize configured transceivers and controllers by calling Eth_ControllerInit() and
        EthTrcv_TransceiverInit().
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest02037_InitControllersTransceivers</srcid><srcstatus/><internalId>1918</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>270</internalId></specobject>
    <specobject>
      <id>EthIf.EB.GetTrcvSignalQuality.Configurable</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The function shall be pre compile time configurable On/Off by the configuration parameter
        EthIfEnableSignalQualityApi.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompileTest_01</srcid><srcstatus/><internalId>1237</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91056</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>775</internalId></provcov>
        <provcov>
          <linksto>EthIf.dsn.Func.LinkQuality</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1119</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>271</internalId></specobject>
    <specobject>
      <id>EthIf.EB.GetSwitchPortSignalQuality.Configurable</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The function shall be pre compile time configurable On/Off by the configuration parameter
        EthIfEnableSignalQualityApi.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompileTest_01</srcid><srcstatus/><internalId>1237</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.LinkQuality</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1119</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>272</internalId></specobject>
    <specobject>
      <id>EthIf.EB.ClearTrcvSignalQuality.Configurable</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The function shall be pre compile time configurable On/Off by the configuration parameter
        EthIfEnableSignalQualityApi.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompileTest_01</srcid><srcstatus/><internalId>1237</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.LinkQuality</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1119</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>273</internalId></specobject>
    <specobject>
      <id>EthIf.EB.ClearSwitchPortSignalQuality.Configurable</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The function shall be pre compile time configurable On/Off by the configuration parameter
        EthIfEnableSignalQualityApi.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompileTest_01</srcid><srcstatus/><internalId>1237</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.LinkQuality</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1119</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>274</internalId></specobject>
    <specobject>
      <id>EthIf.EB.GetTrcvSignalQuality_00320</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The function shall forward the call to function
        EthTrcv_GetPhySignalQuality of the corresponding Ethernet Transceiver Driver
        (EthIfTransceiverIdx).
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest04055_GetTrcvSignalQuality_Forward_Call</srcid><srcstatus/><internalId>1428</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.LinkQuality</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1119</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>275</internalId></specobject>
    <specobject>
      <id>EthIf.EB.ProvideTxBuffer_EthSwtVLAN</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If EthIf_ProvideTxBuffer() is called for the controller that references an Ethernet
        switch and has VLAN and EthIfSwtAdpatTxFrame enabled, functions
        EthSwt_EthIfTxAdaptFrameTypeBufferLength(), Eth_ProvideTxBuffer() and
        EthSwt_EthIfTxPreProcessFrame() will be called.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06025_ProvideTxBuffer_Enabled_Vlan</srcid><srcstatus/><internalId>1495</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>276</internalId></specobject>
    <specobject>
      <id>EthIf.EB.ProvideTxBuffer_BufferContent</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If EthIf_ProvideTxBuffer() is called for the controller that references an Ethernet
        switch and has VLAN and EthIfSwtAdpatTxFrame enabled, Tx buffer should contain EthSwt header
        without the Frame type, VLAN frame type, VID and priority, Frame type and payload.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06025_ProvideTxBuffer_Enabled_Vlan</srcid><srcstatus/><internalId>1495</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>277</internalId></specobject>
    <specobject>
      <id>EthIf.EB.ProvideTxBuffer_EthSwt_EthIf</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If EthIf_ProvideTxBuffer() is called for the controller that references an Ethernet
        switch and has VLAN and EthIfSwtAdpatTxFrame enabled, function
        EthSwt_EthIfTxAdaptFrameTypeBufferLength() shall be able to modify the length to be used for
        Eth_ProvideTxBuffer(). The module shall internally use the EthIf_ProvideTxBuffer() FrameType
        parameter only. Changes to FrameType done in EthSwt_EthIfTxAdaptFrameTypeBufferLength()
        shall not be stored in buffer (VLAN) and shall not be passed to
        EthSwt_EthIfPreProcessTxFrame().
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06025_ProvideTxBuffer_Enabled_Vlan</srcid><srcstatus/><internalId>1495</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>278</internalId></specobject>
    <specobject>
      <id>EthIf.EB.Transmit_EthSwtVLAN</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If EthIf_Transmit() is called for the controller that references an Ethernet switch
        and has VLAN and EthIfSwtAdpatTxFrame enabled, functions
        EthSwt_EthIfTxAdaptFrameTypeBufferLength() and Eth_Transmit() will be called.
        EthSwt_EthIfTxAdaptFrameTypeBufferLength() shall be able to modify the length and FrameType
        to be used for Eth_Transmit().
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06025_ProvideTxBuffer_Enabled_Vlan</srcid><srcstatus/><internalId>1495</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.VLAN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1114</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>279</internalId></specobject>
    <specobject>
      <id>EthIf.EB.GetIngressTimeStamp_EthVLAN</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If EthIf_GetIngressTimeStamp() is called for the controller that has VLAN enabled, passed
        data will be moved for the size of ethernet header length with VLAN tagging inserted and
        then function Eth_GetIngressTimeStamp() will be called.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06027_EthIf_GetIngressTimeStamp_VLAN</srcid><srcstatus/><internalId>1497</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>280</internalId></specobject>
    <!-- Requirements relating to Support of async handling of transceiver/controller mode extension -->
    <specobject>
      <id>EthIf.EB.AsyncEthTrcvMode_Extension.ApiSupport_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name: EthIfAsyncEthTrcvModeSupport
        Description: Configures if asyn communication of Eth transceivers is supported or not.
        Multiplicity: 1
        Type: EcucBooleanParamDef
        Default value: false
        Post-Build Variant Value: false
        Value Configuration Class: Pre-compile time: X All Variants
                                   Link time: -
                                   Post-build time: -
        Scope / Dependency: Scope: local
      </description>
      <comment>
         This is a configuration parameter requirement without functional specification.
      </comment>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.AsyncHandling</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1120</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>281</internalId></specobject>
    <specobject>
      <id>EthIf.EB.AsyncEthCtrlMode_Extension.ApiSupport_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name: EthIfAsyncEthCtrlModeSupport
        Description: Configures if asyn communication of Eth physical controllers is supported or not.
        Multiplicity: 1
        Type: EcucBooleanParamDef
        Default value: false
        Post-Build Variant Value: false
        Value Configuration Class: Pre-compile time: X All Variants
                                   Link time: -
                                   Post-build time: -
        Scope / Dependency: Scope: local
      </description>
      <comment>
         This is a configuration parameter requirement without functional specification.
      </comment>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.AsyncHandling</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1120</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>282</internalId></specobject>
    <specobject>
      <id>EthIf.EB.RelocatablePBCfg</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
          Name: EthIfRelocatablePbcfgEnable
          Description: In order to support post-build-time configuration data handled
                       by relative offsets to the configuration start address,
                       the container EthIfGeneral is extended with the configuration
                       parameter EthIfRelocatablePbcfgEnable.
          Config class: Pre-compile : VARIANT-POST-BUILD
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/EthIf_EBParameters.xdm.m4_278</srcid><srcstatus/><internalId>1080</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_Test_PBcfgM_Off</srcid><srcstatus/><internalId>1234</internalId></linkedfrom><linkedfrom><srcid>EthIf_Test_PBcfgM_On</srcid><srcstatus/><internalId>1235</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>283</internalId></specobject>
    <!-- Requirements relating to Ethernet Interface Device Authentication extension -->
    <specobject>
      <id>EthIf.EB.DevAuthExtension.ApiSupport</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
          There shall be a precompile configuration parameter
          EthIfGeneral/EthIfDeviceAuthenticationApiEnable which globally enables or disables
          EnableRelatedEthIfCtrls and DisableRelatedEthIfCtrls APIs.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompileTest_01</srcid><srcstatus/><internalId>1237</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.DeviceAuthenticationSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1122</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>284</internalId></specobject>
    <specobject>
      <id>EthIf.EB.DevAuthExtension.EnableRelatedEthIfCtrls.ApiSignature</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
          Provide API function with the following signature:
          Std_ReturnType EthIf_EnableRelatedEthIfCtrls
            (
              uint8 CtrlIdx
            )
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest02042_EnableRelatedEthIfCtrls</srcid><srcstatus/><internalId>1923</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.DeviceAuthenticationSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1122</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>285</internalId></specobject>
    <specobject>
      <id>EthIf.EB.DevAuthExtension.EnableRelatedEthIfCtrls.ServiceId</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The macro ETHIF_ENABLERELATEDETHIFCTRLS_SVCID shall have the value:
        Service ID[hex]: 0xF0
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompTest_05_ServiceId_ErrorId</srcid><srcstatus/><internalId>1242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.DeviceAuthenticationSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1122</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>286</internalId></specobject>
    <specobject>
      <id>EthIf.EB.DevAuthExtension.DisableRelatedEthIfCtrls.ApiSignature</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
          Provide API function with the following signature:
          Std_ReturnType EthIf_DisableRelatedEthIfCtrls
          (
            uint8 CtrlIdx
          )
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest02041_DisableRelatedEthIfCtrls</srcid><srcstatus/><internalId>1922</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.DeviceAuthenticationSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1122</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>287</internalId></specobject>
    <specobject>
      <id>EthIf.EB.DevAuthExtension.DisableRelatedEthIfCtrls.ServiceId</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
          The macro ETHIF_DISABLERELATEDETHIFCTRLS_SVCID shall have the value:
          Service ID[hex]: 0xF1
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompTest_05_ServiceId_ErrorId</srcid><srcstatus/><internalId>1242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.DeviceAuthenticationSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1122</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>288</internalId></specobject>
    <specobject>
      <id>EthIf.EB.DevAuthExtension.EnableRelatedEthIfCtrls.Behaviour</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
          If Device Authentication API feature is enabled, the function
          EthIf_EnableRelatedEthIfCtrls() shall within a group of EthIfControllers that
          reference the same PhyController, enable all but one received as a parameter.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest02042_EnableRelatedEthIfCtrls</srcid><srcstatus/><internalId>1923</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>289</internalId></specobject>
    <specobject>
      <id>EthIf.EB.DevAuthExtension.DisableRelatedEthIfCtrls.Behaviour</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
          If Device Authentication API feature is enabled, the function
          EthIf_DisableRelatedEthIfCtrls() shall within a group of EthIfControllers that reference
          the same PhyController, disable all but one received as a parameter.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest02041_DisableRelatedEthIfCtrls</srcid><srcstatus/><internalId>1922</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>290</internalId></specobject>
    <specobject>
      <id>EthIf.EB.DevAuthExtension.EnableRelatedEthIfCtrls.DetCheck.NotInit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
          If DET and Device Authentication API feature is enabled, API function
          EthIf_EnableRelatedEthIfCtrls() shall check if the module is initialized and report to DET
          with errorId ETHIF_E_NOT_INITIALIZED and service ID 0xF0 if it is not, and return
          E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01082_EnableRelatedEthIfCtrls_Uninit</srcid><srcstatus/><internalId>1264</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>291</internalId></specobject>
    <specobject>
      <id>EthIf.EB.DevAuthExtension.DisableRelatedEthIfCtrls.DetCheck.NotInit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
          If DET and Device Authentication API feature is enabled, API function
          EthIf_DisableRelatedEthIfCtrls() shall check if the module is initialized and report to
          DET with errorId ETHIF_E_NOT_INITIALIZED and service ID 0xF1 if it is not, and return
          E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01083_DisableRelatedEthIfCtrls_Uninit</srcid><srcstatus/><internalId>1265</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>292</internalId></specobject>
    <specobject>
      <id>EthIf.EB.DevAuthExtension.EnableRelatedEthIfCtrls.DetCheck.InvalidCtrlIdx</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
          If DET and Device Authentication API feature is enabled, API function
          EthIf_EnableRelatedEthIfCtrls() shall check if parameter CtrlIdx is valid and report to
          DET with errorId ETHIF_E_INV_CTRL_IDX and service ID 0xF0 if it is not,
          and return E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01080_EnableRelatedEthIfCtrls_InvalidCtrlIdx</srcid><srcstatus/><internalId>1302</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>293</internalId></specobject>
    <specobject>
      <id>EthIf.EB.DevAuthExtension.DisableRelatedEthIfCtrls.DetCheck.InvalidCtrlIdx</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
          If DET and Device Authentication API feature is enabled, API function
          EthIf_DisableRelatedEthIfCtrls() shall check if parameter CtrlIdx is valid and report to
          DET with errorId ETHIF_E_INV_CTRL_IDX and service ID 0xF1 if it is not,
          and return E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01081_DisableRelatedEthIfCtrls_InvalidCtrlIdx</srcid><srcstatus/><internalId>1303</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>294</internalId></specobject>
    <specobject>
      <id>EthIf.EB.DevAuthExtension.EnableRelatedEthIfCtrls.DetCheck.HwNotInit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
          If development error detection is enabled and EthIf_EnableRelatedEthIfCtrls() is called
          while the Physical controller is not initialized , an error shall be reported to DET with
          error code ETHIF_E_HW_NOT_INITIALIZED and service ID 0xF0, and E_NOT_OK will be returned.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01085_EnableRelatedEthIfCtrls_HardwareUninit</srcid><srcstatus/><internalId>1307</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>295</internalId></specobject>
    <specobject>
      <id>EthIf.EB.DevAuthExtension.DisableRelatedEthIfCtrls.DetCheck.HwNotInit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
          If development error detection is enabled and EthIf_DisableRelatedEthIfCtrls() is called
          while the Physical controller is not initialized , an error shall be reported to DET with
          error code ETHIF_E_HW_NOT_INITIALIZED and service ID 0xF1, and E_NOT_OK will be returned.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01086_DisableRelatedEthIfCtrls_HardwareUninit</srcid><srcstatus/><internalId>1308</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>296</internalId></specobject>
    <!-- Requirements relating to Ethernet Interface Retransmit extension -->
    <specobject>
      <id>EthIf.EB.RetransmitExtension.ApiSupport</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
          There shall be a precompile configuration parameter
          EthIfGeneral/EthIfRetransmitApiEnable which globally enables or disables
          EthIf_Retransmit API.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompileTest_01</srcid><srcstatus/><internalId>1237</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.RetransmitSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1123</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>297</internalId></specobject>
    <specobject>
      <id>EthIf.EB.RetransmitExtension.Retransmit.ApiSignature</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
          Provide API function with the following signature:
          Std_ReturnType EthIf_Retransmit
          (
              uint8 CtrlIdx,
              uint8 OrigCtrlIdx,
              Eth_BufIdxType *BufIdxPtr,
              Eth_DataType *DataPtr,
              Eth_FrameType FrameType,
              uint16 LenByte,
              const Eth_RetransmitInfoType *RetransmitInfoPtr
           )
           Sync/Async: Synchronous
           Reentrancy: Non Reentrant.
           Parameters (in): CtrlIdx Index of the controller where frame shall be re-transmitted
                            within the context of the Ethernet Interface.
                            OrigCtrlIdx Index of the controller of the provided buffer
                            within the context of the Ethernet Interface.
                            DataPtr Buffer pointer of retransmitted frame (in case of
                            EthIf_RxIndication context) else it is a NULL_PTR.
                            FrameType Ethernet frame type
                            LenByte Length of the payload contained in the tx buffer to transmit.
                            RetransmitInfoPtr Pointer to additional retransmit info.
          Parameters (inout): BufIdxPtr Pointer to the Index of the buffer to transmit.
          Parameters (out): None.
          Return value: Std_ReturnType
                        E_OK: Re-transmission of the buffer was successful.
                        E_NOT_OK: If provided CtrlIdx-es refer to not compatible EthIf controllers
                                  (VLAN and non VLAN).
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06030_Retransmit_NonVlanCtrl</srcid><srcstatus/><internalId>1500</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.RetransmitSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1123</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>298</internalId></specobject>
    <specobject>
      <id>EthIf.EB.RetransmitExtension.Retransmit.ServiceId</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
           The macro ETHIF_RETRANSMIT_SVCID shall have the value:
           Service ID[hex]: 0xF2
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompTest_05_ServiceId_ErrorId</srcid><srcstatus/><internalId>1242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.RetransmitSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1123</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>299</internalId></specobject>
    <specobject>
      <id>EthIf.EB.RetransmitExtension.Retransmit.Behaviour</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
          If Retransmit API feature is enabled, the function EthIf_Retransmit()
          shall forward the call to the respective Ethernet Controller Driver.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06025_ProvideTxBuffer_Enabled_Vlan</srcid><srcstatus/><internalId>1495</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest11022_Transmit_NoVendor</srcid><srcstatus/><internalId>1721</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest11023_Transmit_NoVendor</srcid><srcstatus/><internalId>1722</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.RetransmitSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1123</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>300</internalId></specobject>
    <specobject>
      <id>EthIf.EB.RetransmitExtension.Retransmit.InvCtrlIndexes</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
          If EthIf_Retransmit() is called with non compatible EthIf controllers
          (origin EthIf controller uses VLAN and EthIf controller uses no VLAN or vice versa)
          E_NOT_OK will be returned.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06030_Retransmit_NonVlanCtrl</srcid><srcstatus/><internalId>1500</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.RetransmitSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1123</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>301</internalId></specobject>
    <specobject>
      <id>EthIf.EB.RetransmitExtension.Retransmit.DetCheck.NotInit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
          If development error detection is enabled: the function shall check that the service
          EthIf_Init was previously called. If the check fails, the function shall raise the
          development error ETHIF_E_NOT_INITIALIZED otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01100_Retransmit_Uninit</srcid><srcstatus/><internalId>1314</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.RetransmitSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1123</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>302</internalId></specobject>
    <specobject>
      <id>EthIf.EB.RetransmitExtension.Retransmit.DetCheck.InvCtrlIdx</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
          If development error detection is enabled: the function shall check the parameters
          CtrlIdx and OrigCtrlIdx for being valid. If the check fails, the function shall raise the
          development error ETHIF_E_INV_CTRL_IDX otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01101_Retransmit_InvalidCtrlIdx</srcid><srcstatus/><internalId>1315</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.RetransmitSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1123</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>303</internalId></specobject>
    <specobject>
      <id>EthIf.EB.RetransmitExtension.Retransmit.DetCheck.InvBufIdxPtr</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
          If development error detection is enabled: the function shall check the parameter
          BufIdxPtr for being valid. If the check fails, the function shall raise the
          development error ETHIF_E_PARAM_POINTER otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01103_Retransmit_InvalidBufIdxPtr</srcid><srcstatus/><internalId>1317</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.RetransmitSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1123</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>304</internalId></specobject>
    <specobject>
      <id>EthIf.EB.RetransmitExtension.Retransmit.DetCheck.InvRetransmitInfoPtr</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
          If development error detection is enabled: the function shall check the parameter
          RetransmitInfoPtr for being valid. If the check fails, the function shall raise the
          development error ETHIF_E_PARAM_POINTER otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01102_Retransmit_InvalidRetInfoPtr</srcid><srcstatus/><internalId>1316</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.RetransmitSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1123</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>305</internalId></specobject>
    <specobject>
      <id>EthIf.EB.RetransmitExtension.Retransmit.DetCheck.InvDataPtr</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
          If development error detection is enabled: the function shall check the parameter
          DataPtr for being valid. If the check fails, the function shall raise the
          development error ETHIF_E_PARAM_POINTER otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01104_Retransmit_InvalidDataPtr</srcid><srcstatus/><internalId>1318</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.RetransmitSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1123</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>306</internalId></specobject>
    <specobject>
      <id>EthIf.EB.CtrlModeIndication.DetCheck.NotInit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service
        EthIf_Init was previously called. If the check fails, the function shall raise the
        development error ETHIF_E_NOT_INITIALIZED otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06000_CtrlModeIndication_Uninit</srcid><srcstatus/><internalId>1514</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>307</internalId></specobject>
    <specobject>
      <id>EthIf.EB.TrcvModeIndication.DetCheck.NotInit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service
        EthIf_Init was previously called. If the check fails, the function shall raise the
        development error ETHIF_E_NOT_INITIALIZED otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06000_TrcvModeIndication_Uninit</srcid><srcstatus/><internalId>1515</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>308</internalId></specobject>
<!-- EthIf_MacSecUpdateSecY -->
    <specobject>
      <id>EthIf.EB.Det.MacSecUpdateSecY.Uninit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled, MacSec is enabled (EthIfEnableMacSecSupport = true) and
        EthIf_MacSecUpdateSecY is called while the EthIf is not initialized, an error shall be reported to
        Det with error code ETHIF_E_NOT_INITIALIZED and corresponding service ID and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01105_MacSecUpdateSecY_Uninit</srcid><srcstatus/><internalId>1319</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>309</internalId></specobject>
    <specobject>
      <id>EthIf.EB.Det.MacSecUpdateSecY.HwUninit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled, MacSec is enabled (EthIfEnableMacSecSupport = true) and
        EthIf_MacSecUpdateSecY is called while the controller is not initialized (EthIf_ControllerInit() was
        not called for this controller), an error shall be reported to Det with error code ETHIF_E_HW_NOT_INITIALIZED
        and corresponding service ID and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01106_MacSecUpdateSecY_HwUninit</srcid><srcstatus/><internalId>1320</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>310</internalId></specobject>
    <specobject>
      <id>EthIf.EB.Det.MacSecUpdateSecY.InvalidCtrlIdx</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled and EthIf_MacSecUpdateSecY is called
        and parameter CtrlIdx is higher than the number of configured controlled ports, an error
        shall be reported to Det with error code ETHIF_E_INV_CTRL_IDX and corresponding service ID
        and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01107_MacSecUpdateSecY_InvalidCtrlIdx</srcid><srcstatus/><internalId>1321</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>311</internalId></specobject>
    <specobject>
      <id>EthIf.EB.Det.MacSecUpdateSecY.InvalidPointer</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled and EthIf_MacSecUpdateSecY is called and MACsecCfgPtr
        is a NULL_PTR, an error shall be reported to Det with error code ETHIF_E_PARAM_POINTER and corresponding
        service ID and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01108_MacSecUpdateSecY_InvalidPtr</srcid><srcstatus/><internalId>1322</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>312</internalId></specobject>
    <specobject>
      <id>EthIf.EB.Det.MacSecUpdateSecY.InvalidValidateFrames</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled and EthIf_MacSecUpdateSecY is called and parameter
        MACsecCfgPtr-&gt;ValidateFrames is higher than the maximum value (2), an error shall be reported to
        Det with error code ETHIF_E_INV_PARAM and corresponding service ID and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01109_MacSecUpdateSecY_InvalidValidateFrames</srcid><srcstatus/><internalId>1323</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>313</internalId></specobject>
    <specobject>
      <id>EthIf.EB.Det.MacSecUpdateSecY.InvalidConfidentialityOffset</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled and EthIf_MacSecUpdateSecY is called and parameter
        MACsecCfgPtr-&gt;ConfidentialityOffset is higher than the maximum value (3), an error shall be
        reported to Det with error code ETHIF_E_INV_PARAM and corresponding service ID and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01110_MacSecUpdateSecY_InvalidConfidentialOffset</srcid><srcstatus/><internalId>1324</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>314</internalId></specobject>
<!-- EthIf_MacSecAddTxSa -->
    <specobject>
      <id>EthIf.EB.Det.MacSecAddTxSa.Uninit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled, MacSec is enabled (EthIfEnableMacSecSupport = true) and
        EthIf_MacSecAddTxSa is called while the EthIf is not initialized, an error shall be reported to
        Det with error code ETHIF_E_NOT_INITIALIZED and corresponding service ID and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01111_MacSecAddTxSa_Uninit</srcid><srcstatus/><internalId>1325</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>315</internalId></specobject>
    <specobject>
      <id>EthIf.EB.Det.MacSecAddTxSa.HwUninit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled, MacSec is enabled (EthIfEnableMacSecSupport = true) and
        EthIf_MacSecAddTxSa is called while the controller is not initialized (EthIf_ControllerInit() was
        not called for this controller), an error shall be reported to Det with error code ETHIF_E_HW_NOT_INITIALIZED
        and corresponding service ID and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01112_MacSecAddTxSa_HwUninit</srcid><srcstatus/><internalId>1326</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>316</internalId></specobject>
    <specobject>
      <id>EthIf.EB.Det.MacSecAddTxSa.InvalidCtrlIdx</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled and EthIf_MacSecAddTxSa is called
        and parameter CtrlIdx is higher than the number of configured controlled ports, an error
        shall be reported to Det with error code ETHIF_E_INV_CTRL_IDX and corresponding service ID
        and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01113_MacSecAddTxSa_InvalidCtrlIdx</srcid><srcstatus/><internalId>1327</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>317</internalId></specobject>
   <specobject>
      <id>EthIf.EB.Det.MacSecAddTxSa.InvalidPointer</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled and EthIf_MacSecAddTxSa is called and KeysPtr
        is a NULL_PTR, an error shall be reported to Det with error code ETHIF_E_PARAM_POINTER and corresponding
        service ID and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01114_MacSecAddTxSa_InvalidPtr</srcid><srcstatus/><internalId>1328</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>318</internalId></specobject>
    <specobject>
      <id>EthIf.EB.Det.MacSecAddTxSa.InvalidAn</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled and EthIf_MacSecAddTxSa is called and parameter An
        is higher than the maximum value (3), an error shall be reported to Det with error code ETHIF_E_INV_PARAM
        and corresponding service ID and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01115_MacSecAddTxSa_InvalidAn</srcid><srcstatus/><internalId>1329</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>319</internalId></specobject>
<!-- EthIf_MacSecAddRxSa -->
    <specobject>
      <id>EthIf.EB.Det.MacSecAddRxSa.Uninit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled, MacSec is enabled (EthIfEnableMacSecSupport = true) and
        EthIf_MacSecAddRxSa is called while the EthIf is not initialized, an error shall be reported to
        Det with error code ETHIF_E_NOT_INITIALIZED and corresponding service ID and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01116_MacSecAddRxSa_Uninit</srcid><srcstatus/><internalId>1330</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>320</internalId></specobject>
    <specobject>
      <id>EthIf.EB.Det.MacSecAddRxSa.HwUninit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled, MacSec is enabled (EthIfEnableMacSecSupport = true) and
        EthIf_MacSecAddRxSa is called while the controller is not initialized (EthIf_ControllerInit() was
        not called for this controller), an error shall be reported to Det with error code ETHIF_E_HW_NOT_INITIALIZED
        and corresponding service ID and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01117_MacSecAddRxSa_HwUninit</srcid><srcstatus/><internalId>1331</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>321</internalId></specobject>
    <specobject>
      <id>EthIf.EB.Det.MacSecAddRxSa.InvalidCtrlIdx</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled and EthIf_MacSecAddRxSa is called
        and parameter CtrlIdx is higher than the number of configured controlled ports, an error
        shall be reported to Det with error code ETHIF_E_INV_CTRL_IDX and corresponding service ID
        and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01118_MacSecAddRxSa_InvalidCtrlIdx</srcid><srcstatus/><internalId>1332</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>322</internalId></specobject>
    <specobject>
      <id>EthIf.EB.Det.MacSecAddRxSa.InvalidPointer</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled and EthIf_MacSecAddRxSa is called and KeysPtr
        is a NULL_PTR, an error shall be reported to Det with error code ETHIF_E_PARAM_POINTER and corresponding
        service ID and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01119_MacSecAddRxSa_InvalidPtr</srcid><srcstatus/><internalId>1333</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>323</internalId></specobject>
    <specobject>
      <id>EthIf.EB.Det.MacSecAddRxSa.InvalidAn</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled and EthIf_MacSecAddRxSa is called and parameter An
        is higher than the maximum value (3), an error shall be reported to Det with error code ETHIF_E_INV_PARAM
        and corresponding service ID and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01120_MacSecAddRxSa_InvalidAn</srcid><srcstatus/><internalId>1334</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>324</internalId></specobject>
<!-- EthIf_MacSecGetMacSecStats -->
    <specobject>
      <id>EthIf.EB.Det.MacSecGetMacSecStats.Uninit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled, MacSec is enabled (EthIfEnableMacSecSupport = true) and
        EthIf_MacSecGetMacSecStats is called while the EthIf is not initialized, an error shall be reported to
        Det with error code ETHIF_E_NOT_INITIALIZED and corresponding service ID and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01121_MacSecGetMacSecStats_Uninit</srcid><srcstatus/><internalId>1335</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>325</internalId></specobject>
    <specobject>
      <id>EthIf.EB.Det.MacSecGetMacSecStats.HwUninit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled, MacSec is enabled (EthIfEnableMacSecSupport = true) and
        EthIf_MacSecGetMacSecStats is called while the controller is not initialized (EthIf_ControllerInit() was
        not called for this controller), an error shall be reported to Det with error code ETHIF_E_HW_NOT_INITIALIZED
        and corresponding service ID and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01122_MacSecGetMacSecStats_HwUninit</srcid><srcstatus/><internalId>1336</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>326</internalId></specobject>
    <specobject>
      <id>EthIf.EB.Det.MacSecGetMacSecStats.InvalidCtrlIdx</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled and EthIf_MacSecGetMacSecStats is called
        and parameter CtrlIdx is higher than the number of configured controlled ports, an error
        shall be reported to Det with error code ETHIF_E_INV_CTRL_IDX and corresponding service ID
        and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01123_MacSecGetMacSecStats_InvalidCtrlIdx</srcid><srcstatus/><internalId>1337</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>327</internalId></specobject>
<!-- EthIf_MacSecInitRxSc -->
    <specobject>
      <id>EthIf.EB.Det.MacSecInitRxSc.Uninit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled, MacSec is enabled (EthIfEnableMacSecSupport = true) and
        EthIf_MacSecInitRxSc is called while the EthIf is not initialized, an error shall be reported to
        Det with error code ETHIF_E_NOT_INITIALIZED and corresponding service ID and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01124_MacSecInitRxSc_Uninit</srcid><srcstatus/><internalId>1338</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>328</internalId></specobject>
    <specobject>
      <id>EthIf.EB.Det.MacSecInitRxSc.HwUninit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled, MacSec is enabled (EthIfEnableMacSecSupport = true) and
        EthIf_MacSecInitRxSc is called while the controller is not initialized (EthIf_ControllerInit() was
        not called for this controller), an error shall be reported to Det with error code ETHIF_E_HW_NOT_INITIALIZED
        and corresponding service ID and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01125_MacSecInitRxSc_HwUninit</srcid><srcstatus/><internalId>1339</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>329</internalId></specobject>
    <specobject>
      <id>EthIf.EB.Det.MacSecInitRxSc.InvalidCtrlIdx</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled and EthIf_MacSecInitRxSc is called
        and parameter CtrlIdx is higher than the number of configured controlled ports, an error
        shall be reported to Det with error code ETHIF_E_INV_CTRL_IDX and corresponding service ID
        and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01126_MacSecInitRxSc_InvalidCtrlIdx</srcid><srcstatus/><internalId>1340</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>330</internalId></specobject>
<!-- EthIf_MacSecResetRxSc -->
    <specobject>
      <id>EthIf.EB.Det.MacSecResetRxSc.Uninit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled, MacSec is enabled (EthIfEnableMacSecSupport = true) and
        EthIf_MacSecResetRxSc is called while the EthIf is not initialized, an error shall be reported to
        Det with error code ETHIF_E_NOT_INITIALIZED and corresponding service ID and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01127_MacSecResetRxSc_Uninit</srcid><srcstatus/><internalId>1341</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>331</internalId></specobject>
    <specobject>
      <id>EthIf.EB.Det.MacSecResetRxSc.HwUninit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled, MacSec is enabled (EthIfEnableMacSecSupport = true) and
        EthIf_MacSecResetRxSc is called while the controller is not initialized (EthIf_ControllerInit() was
        not called for this controller), an error shall be reported to Det with error code ETHIF_E_HW_NOT_INITIALIZED
        and corresponding service ID and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01128_MacSecResetRxSc_HwUninit</srcid><srcstatus/><internalId>1342</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>332</internalId></specobject>
    <specobject>
      <id>EthIf.EB.Det.MacSecResetRxSc.InvalidCtrlIdx</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled and EthIf_MacSecResetRxSc is called
        and parameter CtrlIdx is higher than the number of configured controlled ports, an error
        shall be reported to Det with error code ETHIF_E_INV_CTRL_IDX and corresponding service ID
        and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01129_MacSecResetRxSc_InvalidCtrlIdx</srcid><srcstatus/><internalId>1343</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>333</internalId></specobject>
<!-- EthIf_MacSecUpdateTxSa -->
    <specobject>
      <id>EthIf.EB.Det.MacSecUpdateTxSa.Uninit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled, MacSec is enabled (EthIfEnableMacSecSupport = true) and
        EthIf_MacSecUpdateTxSa is called while the EthIf is not initialized, an error shall be reported to
        Det with error code ETHIF_E_NOT_INITIALIZED and corresponding service ID and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01130_MacSecUpdateTxSa_Uninit</srcid><srcstatus/><internalId>1344</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>334</internalId></specobject>
    <specobject>
      <id>EthIf.EB.Det.MacSecUpdateTxSa.HwUninit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled, MacSec is enabled (EthIfEnableMacSecSupport = true) and
        EthIf_MacSecUpdateTxSa is called while the controller is not initialized (EthIf_ControllerInit() was
        not called for this controller), an error shall be reported to Det with error code ETHIF_E_HW_NOT_INITIALIZED
        and corresponding service ID and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01131_MacSecUpdateTxSa_HwUninit</srcid><srcstatus/><internalId>1345</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>335</internalId></specobject>
    <specobject>
      <id>EthIf.EB.Det.MacSecUpdateTxSa.InvalidCtrlIdx</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled and EthIf_MacSecUpdateTxSa is called
        and parameter CtrlIdx is higher than the number of configured controlled ports, an error
        shall be reported to Det with error code ETHIF_E_INV_CTRL_IDX and corresponding service ID
        and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01132_MacSecUpdateTxSa_InvalidCtrlIdx</srcid><srcstatus/><internalId>1346</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>336</internalId></specobject>
    <specobject>
      <id>EthIf.EB.Det.MacSecUpdateTxSa.InvalidAn</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled and EthIf_MacSecUpdateTxSa is called and parameter An
        is higher than the maximum value (3), an error shall be reported to Det with error code ETHIF_E_INV_PARAM
        and corresponding service ID and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01133_MacSecUpdateTxSa_InvalidAn</srcid><srcstatus/><internalId>1347</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>337</internalId></specobject>
<!-- EthIf_MacSecDeleteTxSa -->
    <specobject>
      <id>EthIf.EB.Det.MacSecDeleteTxSa.Uninit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled, MacSec is enabled (EthIfEnableMacSecSupport = true) and
        EthIf_MacSecDeleteTxSa is called while the EthIf is not initialized, an error shall be reported to
        Det with error code ETHIF_E_NOT_INITIALIZED and corresponding service ID and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01134_MacSecDeleteTxSa_Uninit</srcid><srcstatus/><internalId>1348</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>338</internalId></specobject>
    <specobject>
      <id>EthIf.EB.Det.MacSecDeleteTxSa.HwUninit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled, MacSec is enabled (EthIfEnableMacSecSupport = true) and
        EthIf_MacSecDeleteTxSa is called while the controller is not initialized (EthIf_ControllerInit() was
        not called for this controller), an error shall be reported to Det with error code ETHIF_E_HW_NOT_INITIALIZED
        and corresponding service ID and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01135_MacSecDeleteTxSa_HwUninit</srcid><srcstatus/><internalId>1349</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>339</internalId></specobject>
    <specobject>
      <id>EthIf.EB.Det.MacSecDeleteTxSa.InvalidCtrlIdx</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled and EthIf_MacSecDeleteTxSa is called
        and parameter CtrlIdx is higher than the number of configured controlled ports, an error
        shall be reported to Det with error code ETHIF_E_INV_CTRL_IDX and corresponding service ID
        and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01136_MacSecDeleteTxSa_InvalidCtrlIdx</srcid><srcstatus/><internalId>1350</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>340</internalId></specobject>
    <specobject>
      <id>EthIf.EB.Det.MacSecDeleteTxSa.InvalidAn</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled and EthIf_MacSecDeleteTxSa is called and parameter An
        is higher than the maximum value (3), an error shall be reported to Det with error code ETHIF_E_INV_PARAM
        and corresponding service ID and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01137_MacSecDeleteTxSa_InvalidAn</srcid><srcstatus/><internalId>1351</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>341</internalId></specobject>
<!-- EthIf_MacSecUpdateRxSa -->
    <specobject>
      <id>EthIf.EB.Det.MacSecUpdateRxSa.Uninit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled, MacSec is enabled (EthIfEnableMacSecSupport = true) and
        EthIf_MacSecUpdateRxSa is called while the EthIf is not initialized, an error shall be reported to
        Det with error code ETHIF_E_NOT_INITIALIZED and corresponding service ID and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01138_MacSecUpdateRxSa_Uninit</srcid><srcstatus/><internalId>1352</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>342</internalId></specobject>
    <specobject>
      <id>EthIf.EB.Det.MacSecUpdateRxSa.HwUninit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled, MacSec is enabled (EthIfEnableMacSecSupport = true) and
        EthIf_MacSecUpdateRxSa is called while the controller is not initialized (EthIf_ControllerInit() was
        not called for this controller), an error shall be reported to Det with error code ETHIF_E_HW_NOT_INITIALIZED
        and corresponding service ID and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01139_MacSecUpdateRxSa_HwUninit</srcid><srcstatus/><internalId>1353</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>343</internalId></specobject>
    <specobject>
      <id>EthIf.EB.Det.MacSecUpdateRxSa.InvalidCtrlIdx</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled and EthIf_MacSecUpdateRxSa is called
        and parameter CtrlIdx is higher than the number of configured controlled ports, an error
        shall be reported to Det with error code ETHIF_E_INV_CTRL_IDX and corresponding service ID
        and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01140_MacSecUpdateRxSa_InvalidCtrlIdx</srcid><srcstatus/><internalId>1354</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>344</internalId></specobject>
    <specobject>
      <id>EthIf.EB.Det.MacSecUpdateRxSa.InvalidAn</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled and EthIf_MacSecUpdateRxSa is called and parameter An
        is higher than the maximum value (3), an error shall be reported to Det with error code ETHIF_E_INV_PARAM
        and corresponding service ID and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01141_MacSecUpdateRxSa_InvalidAn</srcid><srcstatus/><internalId>1355</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>345</internalId></specobject>
<!-- EthIf_MacSecDeleteRxSa -->
    <specobject>
      <id>EthIf.EB.Det.MacSecDeleteRxSa.Uninit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled, MacSec is enabled (EthIfEnableMacSecSupport = true) and
        EthIf_MacSecDeleteRxSa is called while the EthIf is not initialized, an error shall be reported to
        Det with error code ETHIF_E_NOT_INITIALIZED and corresponding service ID and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01142_MacSecDeleteRxSa_Uninit</srcid><srcstatus/><internalId>1356</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>346</internalId></specobject>
    <specobject>
      <id>EthIf.EB.Det.MacSecDeleteRxSa.HwUninit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled, MacSec is enabled (EthIfEnableMacSecSupport = true) and
        EthIf_MacSecDeleteRxSa is called while the controller is not initialized (EthIf_ControllerInit() was
        not called for this controller), an error shall be reported to Det with error code ETHIF_E_HW_NOT_INITIALIZED
        and corresponding service ID and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01143_MacSecDeleteRxSa_HwUninit</srcid><srcstatus/><internalId>1357</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>347</internalId></specobject>
    <specobject>
      <id>EthIf.EB.Det.MacSecDeleteRxSa.InvalidCtrlIdx</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled and EthIf_MacSecDeleteRxSa is called
        and parameter CtrlIdx is higher than the number of configured controlled ports, an error
        shall be reported to Det with error code ETHIF_E_INV_CTRL_IDX and corresponding service ID
        and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01144_MacSecDeleteRxSa_InvalidCtrlIdx</srcid><srcstatus/><internalId>1358</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>348</internalId></specobject>
    <specobject>
      <id>EthIf.EB.Det.MacSecDeleteRxSa.InvalidAn</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled and EthIf_MacSecDeleteRxSa is called and parameter An
        is higher than the maximum value (3), an error shall be reported to Det with error code ETHIF_E_INV_PARAM
        and corresponding service ID and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01145_MacSecDeleteRxSa_InvalidAn</srcid><srcstatus/><internalId>1359</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>349</internalId></specobject>
<!-- EthIf_MacSecGetTxSaNextPn -->
    <specobject>
      <id>EthIf.EB.Det.MacSecGetTxSaNextPn.Uninit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled, MacSec is enabled (EthIfEnableMacSecSupport = true)
        and EthIf_MacSecGetTxSaNextPn is called while the EthIf is not initialized, an error shall be reported to
        Det with error code ETHIF_E_NOT_INITIALIZED and corresponding service ID and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01146_MacSecGetTxNextPn_Uninit</srcid><srcstatus/><internalId>1360</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>350</internalId></specobject>
    <specobject>
      <id>EthIf.EB.Det.MacSecGetTxSaNextPn.HwUninit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled, MacSec is enabled (EthIfEnableMacSecSupport = true) and
        EthIf_MacSecGetTxSaNextPn is called while the controller is not initialized (EthIf_ControllerInit() was
        not called for this controller), an error shall be reported to Det with error code ETHIF_E_HW_NOT_INITIALIZED
        and corresponding service ID and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01147_MacSecGetTxNextPn_HwUninit</srcid><srcstatus/><internalId>1361</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>351</internalId></specobject>
    <specobject>
      <id>EthIf.EB.Det.MacSecGetTxSaNextPn.InvalidCtrlIdx</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled and EthIf_MacSecGetTxSaNextPn is called
        and parameter CtrlIdx is higher than the number of configured controlled ports, an error
        shall be reported to Det with error code ETHIF_E_INV_CTRL_IDX and corresponding service ID
        and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01148_MacSecGetTxNextPn_InvalidCtrlIdx</srcid><srcstatus/><internalId>1362</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>352</internalId></specobject>
    <specobject>
      <id>EthIf.EB.Det.MacSecGetTxSaNextPn.InvalidPointer</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled and EthIf_MacSecGetTxSaNextPn is called and NextPnPtr
        is a NULL_PTR, an error shall be reported to Det with error code ETHIF_E_PARAM_POINTER and corresponding
        service ID and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01149_MacSecGetTxNextPn_InvalidPointer</srcid><srcstatus/><internalId>1363</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>353</internalId></specobject>
    <specobject>
      <id>EthIf.EB.Det.MacSecGetTxSaNextPn.InvalidAn</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled and EthIf_MacSecGetTxSaNextPn is called and parameter An
        is higher than the maximum value (3), an error shall be reported to Det with error code ETHIF_E_INV_PARAM
        and corresponding service ID and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01150_MacSecGetTxNextPn_InvalidAn</srcid><srcstatus/><internalId>1364</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>354</internalId></specobject>
<!-- EthIf_MacSecGetMacSecStatsNotification -->
    <specobject>
      <id>EthIf.EB.Det.MacSecGetMacSecStatsNotification.Uninit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled, MacSec is enabled (EthIfEnableMacSecSupport = true)
        and EthIf_MacSecGetMacSecStatsNotification is called while the EthIf is not initialized, an error shall be reported to
        Det with error code ETHIF_E_NOT_INITIALIZED and corresponding service ID and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01151_MacSecStatsNotification_Uninit</srcid><srcstatus/><internalId>1365</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>355</internalId></specobject>
    <specobject>
      <id>EthIf.EB.Det.MacSecGetMacSecStatsNotification.InvalidCtrlIdx</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled and EthIf_MacSecGetMacSecStatsNotification is called
        and parameter CtrlIdx is higher than the number of configured controlled ports, an error
        shall be reported to Det with error code ETHIF_E_INV_CTRL_IDX and corresponding service ID
        and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01152_MacSecStatsNotification_InvalidCtrlIdx</srcid><srcstatus/><internalId>1366</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>356</internalId></specobject>
    <specobject>
      <id>EthIf.EB.Det.MacSecGetMacSecStatsNotification.InvalidPointer</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled and EthIf_MacSecGetMacSecStatsNotification is called and
        MacSecStatsPtr is a NULL_PTR, an error shall be reported to Det with error code ETHIF_E_PARAM_POINTER
        and corresponding service ID and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01153_MacSecStatsNotification_InvalidPointer</srcid><srcstatus/><internalId>1367</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>357</internalId></specobject>
<!-- EthIf_MacSecOperational -->
    <specobject>
      <id>EthIf.EB.Det.MacSecOperational.Uninit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled, MacSec is enabled (EthIfEnableMacSecSupport = true)
        and EthIf_MacSecOperational is called while the EthIf is not initialized, an error shall be reported to
        Det with error code ETHIF_E_NOT_INITIALIZED and corresponding service ID and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01154_MacSecOperational_Uninit</srcid><srcstatus/><internalId>1368</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>358</internalId></specobject>
    <specobject>
      <id>EthIf.EB.Det.MacSecOperational.HwUninit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled, MacSec is enabled (EthIfEnableMacSecSupport = true) and
        EthIf_MacSecOperational is called while the controller is not initialized (EthIf_ControllerInit() was
        not called for this controller), an error shall be reported to Det with error code ETHIF_E_HW_NOT_INITIALIZED
        and corresponding service ID and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01155_MacSecOperational_HwUninit</srcid><srcstatus/><internalId>1369</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>359</internalId></specobject>
    <specobject>
      <id>EthIf.EB.Det.MacSecOperational.InvalidCtrlIdx</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled and EthIf_MacSecOperational is called
        and parameter CtrlIdx is higher than the number of configured controlled ports, an error
        shall be reported to Det with error code ETHIF_E_INV_CTRL_IDX and corresponding service ID
        and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01156_MacSecOperational_InvalidCtrlIdx</srcid><srcstatus/><internalId>1370</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>360</internalId></specobject>
<!-- EthIf_MacSecSetControlledPortEnabled -->
    <specobject>
      <id>EthIf.EB.Det.MacSecSetControlledPortEnabled.Uninit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled, MacSec is enabled (EthIfEnableMacSecSupport = true) and
        EthIf_MacSecSetControlledPortEnabled is called while the EthIf is not initialized, an error shall be reported to
        Det with error code ETHIF_E_NOT_INITIALIZED and corresponding service ID and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01157_MacSecControlledPortEnabled_Uninit</srcid><srcstatus/><internalId>1371</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>361</internalId></specobject>
    <specobject>
      <id>EthIf.EB.Det.MacSecSetControlledPortEnabled.HwUninit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled, MacSec is enabled (EthIfEnableMacSecSupport = true) and
        EthIf_MacSecSetControlledPortEnabled is called while the controller is not initialized (EthIf_ControllerInit() was
        not called for this controller), an error shall be reported to Det with error code ETHIF_E_HW_NOT_INITIALIZED
        and corresponding service ID and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01158_MacSecControlledPortEnabled_HwUninit</srcid><srcstatus/><internalId>1372</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>362</internalId></specobject>
    <specobject>
      <id>EthIf.EB.Det.MacSecSetControlledPortEnabled.InvalidCtrlIdx</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled and EthIf_MacSecSetControlledPortEnabled is called
        and parameter CtrlIdx is higher than the number of configured controlled ports, an error
        shall be reported to Det with error code ETHIF_E_INV_CTRL_IDX and corresponding service ID
        and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01159_MacSecControlledPortEnabled_InvalidCtrlIdx</srcid><srcstatus/><internalId>1373</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>363</internalId></specobject>
<!-- EthIf_MacSecUpdateSecYNotification -->
    <specobject>
      <id>EthIf.EB.Det.MacSecUpdateSecYNotification.Uninit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled, MacSec is enabled (EthIfEnableMacSecSupport = true)
        and EthIf_MacSecUpdateSecYNotification is called while the EthIf is not initialized, an error shall be reported to
        Det with error code ETHIF_E_NOT_INITIALIZED and corresponding service ID and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01160_MacSecUpdateSecYNotification_Uninit</srcid><srcstatus/><internalId>1374</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>364</internalId></specobject>
    <specobject>
      <id>EthIf.EB.Det.MacSecUpdateSecYNotification.InvalidCtrlIdx</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled and EthIf_MacSecUpdateSecYNotification is called
        and parameter CtrlIdx is higher than the number of configured controlled ports, an error
        shall be reported to Det with error code ETHIF_E_INV_CTRL_IDX and corresponding service ID
        and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01161_MacSecUpdateSecYNotification_InvalidCtrlIdx</srcid><srcstatus/><internalId>1375</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>365</internalId></specobject>
<!-- EthIf_MacSecAddTxSaNotification -->
    <specobject>
      <id>EthIf.EB.Det.MacSecAddTxSaNotification.Uninit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled, MacSec is enabled (EthIfEnableMacSecSupport = true)
        and EthIf_MacSecAddTxSaNotification is called while the EthIf is not initialized, an error shall be reported to
        Det with error code ETHIF_E_NOT_INITIALIZED and corresponding service ID and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01162_MacSecAddTxSaNotification_Uninit</srcid><srcstatus/><internalId>1376</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>366</internalId></specobject>
    <specobject>
      <id>EthIf.EB.Det.MacSecAddTxSaNotification.InvalidCtrlIdx</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled and EthIf_MacSecAddTxSaNotification is called
        and parameter CtrlIdx is higher than the number of configured controlled ports, an error
        shall be reported to Det with error code ETHIF_E_INV_CTRL_IDX and corresponding service ID
        and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01163_MacSecAddTxSaNotification_InvalidCtrlIdx</srcid><srcstatus/><internalId>1377</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>367</internalId></specobject>
<!-- EthIf_MacSecAddRxSaNotification -->
    <specobject>
      <id>EthIf.EB.Det.MacSecAddRxSaNotification.Uninit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled, MacSec is enabled (EthIfEnableMacSecSupport = true)
        and EthIf_MacSecAddRxSaNotification is called while the EthIf is not initialized, an error shall be reported to
        Det with error code ETHIF_E_NOT_INITIALIZED and corresponding service ID and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01164_MacSecAddRxSaNotification_Uninit</srcid><srcstatus/><internalId>1378</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>368</internalId></specobject>
    <specobject>
      <id>EthIf.EB.Det.MacSecAddRxSaNotification.InvalidCtrlIdx</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled and EthIf_MacSecAddRxSaNotification is called
        and parameter CtrlIdx is higher than the number of configured controlled ports, an error
        shall be reported to Det with error code ETHIF_E_INV_CTRL_IDX and corresponding service ID
        and E_NOT_OK will be returned.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01165_MacSecAddRxSaNotification_InvalidCtrlIdx</srcid><srcstatus/><internalId>1379</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>369</internalId></specobject>

    <specobject>
      <id>EthIf.EB.SWS_EthIf_91006.E_NOT_INITIALIZED</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled, the service EthIf_SleepIndication()
        shall raise the development error ETHIF_E_NOT_INITIALIZED if invoked uninitialized.
      </description>
      <needscoverage>
         <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ASR430_SleepIndication_Uninit</srcid><srcstatus/><internalId>1622</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
         <provcov>
            <linksto>EthIf.SWS_EthIf_91006</linksto>
            <dstversion>1</dstversion>
         <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>947</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>370</internalId></specobject>

    <specobject>
      <id>EthIf.EB.SWS_EthIf_91006.INV_TRCV_IDX.1</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled, the service EthIf_SleepIndication()
        shall raise the development error ETHIF_E_INV_TRCV_IDX if invoked with an
        invalid value for TrcvIdx.
      </description>
      <needscoverage>
         <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ASR430_SleepIndication_Trcv_Idx_1</srcid><srcstatus/><internalId>1629</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
         <provcov>
            <linksto>EthIf.SWS_EthIf_91006</linksto>
            <dstversion>1</dstversion>
         <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>947</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>371</internalId></specobject>

    <specobject>
      <id>EthIf.EB.SWS_EthIf_91006.INV_TRCV_IDX.2</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled, the service EthIf_SleepIndication()
        shall raise the development error ETHIF_E_INV_TRCV_IDX if invoked with an
        TrcvIdx which isn't referencing transceiver with EthTrcvActAsSlavePassiveEnabled
        set to TRUE.
      </description>
      <needscoverage>
         <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ASR430_SleepIndication_Trcv_Idx_2</srcid><srcstatus/><internalId>1630</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
         <provcov>
            <linksto>EthIf.SWS_EthIf_91006</linksto>
            <dstversion>1</dstversion>
         <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>947</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>372</internalId></specobject>

    <specobject>
      <id>EthIf.EB.EthIfWakeupSleepOnDatalineSupportEnabled</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        There shall exist a configuration parameter 'EthIfWakeupSleepOnDatalineSupportEnabled'
        which enables or disables the support for wakeup and sleep on data line.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ComTest_10_TC10_support</srcid><srcstatus/><internalId>1247</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>373</internalId></specobject>

    <specobject>
      <id>EthIf.EB.SWS_EthIf_00479</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Everytime EthIf_SetControllerMode has been called for an EthIfController with 
        ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST and this EthIfController has a reference to an 
        EthIfTransceiver, then EthIf shall forward the call to the following function in the given 
        order, independent of the current mode:
        EthTrcv_SetTransceiverMode with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST
      </description>
      <furtherinfo>
        WRN.swuts.needscoverage.count - Linking all relevant test cases to the single requirement brings clear benefits and
        splitting them up would only increase complexity without any real improvements.
      </furtherinfo>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ASR403_SetControllerMode_Wakeup_Transceiver</srcid><srcstatus/><internalId>1544</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR403_SetControllerMode_Wakeup_Second_Transceiver</srcid><srcstatus/><internalId>1545</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR403_SetControllerMode_Wakeup_Second_Transceiver_2</srcid><srcstatus/><internalId>1546</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR403_CtrlModeIndication_Wakeup_Mix_Transceiver</srcid><srcstatus/><internalId>1549</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR422_SetControllerMode_Wakeup_Transceiver</srcid><srcstatus/><internalId>1583</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR422_SetControllerMode_Wakeup_Second_Transceiver</srcid><srcstatus/><internalId>1584</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR422_SetControllerMode_Wakeup_Second_Transceiver_2</srcid><srcstatus/><internalId>1585</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR422_CtrlModeIndication_Wakeup_Mix_Transceiver</srcid><srcstatus/><internalId>1588</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR430_SetControllerMode_Wakeup_Transceiver</srcid><srcstatus/><internalId>1631</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR430_SetControllerMode_Wakeup_Second_Transceiver</srcid><srcstatus/><internalId>1632</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR430_SetControllerMode_Wakeup_Second_Transceiver_2</srcid><srcstatus/><internalId>1633</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR430_CtrlModeIndication_Wakeup_Mix_Transceiver</srcid><srcstatus/><internalId>1636</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.EthTrcv_SetTransceiverMode.Async.CtrlModeIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>380</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>374</internalId></specobject>

    <specobject>
      <id>EthIf.EB.SWS_EthIf_00480</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Everytime EthIf_SetControllerMode has been called for an EthIfController with 
        ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST and this EthIfController has a reference to an EthIfSwitch,
        then EthIf shall forward the call to the following function in the given order for all 
        EthSwtPorts of the respective EthIfSwitchPortGroup, independ of the current mode:
        EthSwt_SetSwitchPortMode with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ASR403_SetControllerMode_Wakeup_Switch</srcid><srcstatus/><internalId>1556</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR403_SetControllerMode_Wakeup_Second_Switch</srcid><srcstatus/><internalId>1557</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR403_SetControllerMode_Wakeup_Second_Switch_2</srcid><srcstatus/><internalId>1558</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR422_SetControllerMode_Wakeup_Switch</srcid><srcstatus/><internalId>1595</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR422_SetControllerMode_Wakeup_Second_Switch</srcid><srcstatus/><internalId>1596</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR422_SetControllerMode_Wakeup_Second_Switch_2</srcid><srcstatus/><internalId>1597</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR430_SetControllerMode_Wakeup_Switch</srcid><srcstatus/><internalId>1643</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR430_SetControllerMode_Wakeup_Second_Switch</srcid><srcstatus/><internalId>1644</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR430_SetControllerMode_Wakeup_Second_Switch_2</srcid><srcstatus/><internalId>1645</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.EthSwt_SetSwitchPortMode.Async.CtrlModeIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>381</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>375</internalId></specobject>

    <specobject>
      <id>EthIf.EB.SWS_EthIf_00481</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Everytime EthIf_SetControllerMode has been called for an EthIfController with 
        ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST and this EthIfController has a reference to an 
        EthIfSwitchPortGroup of type "control", then EthIf shall forward the call to the following 
        function in the given order for all EthSwtPorts of the respective EthIfSwitchPortGroup, 
        independent of the current mode:
        EthSwt_SetSwitchPortMode with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ASR403_SetControllerMode_Wakeup_SwitchPortGroup</srcid><srcstatus/><internalId>1571</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR403_SetControllerMode_Wakeup_Second_SwitchPortGroup</srcid><srcstatus/><internalId>1572</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR403_SetControllerMode_Wakeup_Second_SwitchPortGroup_2</srcid><srcstatus/><internalId>1573</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR422_SetControllerMode_Wakeup_SwitchPortGroup</srcid><srcstatus/><internalId>1610</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR422_SetControllerMode_Wakeup_Second_SwitchPortGroup</srcid><srcstatus/><internalId>1611</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR422_SetControllerMode_Wakeup_Second_SwitchPortGroup_2</srcid><srcstatus/><internalId>1612</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR430_SetControllerMode_Wakeup_SwitchPortGroup</srcid><srcstatus/><internalId>1659</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR430_SetControllerMode_Wakeup_Second_SwitchPortGroup</srcid><srcstatus/><internalId>1660</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR430_SetControllerMode_Wakeup_Second_SwitchPortGroup_2</srcid><srcstatus/><internalId>1661</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.EthSwt_SetSwitchPortMode.Async.CtrlModeIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>381</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>376</internalId></specobject>

    <specobject>
      <id>EthIf.EB.SWS_EthIf_00482</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Everytime EthIf_SwitchPortGroupRequestMode has been called with 
        ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST, EthIf shall forward the call for all EthSwtPorts of the 
        respective EthIfSwitchPortGroup to the following function in the given order independent of 
        the current EthSwtPort mode:
        EthSwt_SetSwitchPortMode with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06017_MainFunction_SwitchPortMiiCheck_Wakeup</srcid><srcstatus/><internalId>1485</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06019_SetSwitchPortMode_MiiCheck_Wakeup</srcid><srcstatus/><internalId>1488</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR403_SwitchPortGroupRequestMode_Wakeup_Second_SwitchPortGroup</srcid><srcstatus/><internalId>1576</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR422_SwitchPortGroupRequestMode_Wakeup_Second_SwitchPortGroup</srcid><srcstatus/><internalId>1615</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR430_SwitchPortGroupRequestMode_Wakeup_Second_SwitchPortGroup</srcid><srcstatus/><internalId>1664</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>377</internalId></specobject>

    <specobject>
      <id>EthIf.EB.SWS_EthIf_00479_00481</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Everytime EthIf_SetControllerMode has been called for an EthIfController with 
        ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST and this EthIfController has no reference to an 
        EthIfTransceiver, EthIfSwitch or to an EthIfSwitchPortGroup of type "control"
        then EthIf shall not forward any calls.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ASR403_SetControllerMode_Wakeup_Second_Switch_PortGroup_NoControl</srcid><srcstatus/><internalId>1559</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR403_SetControllerMode_Wakeup_NoRef</srcid><srcstatus/><internalId>1567</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR422_SetControllerMode_Wakeup_Second_Switch_PortGroup_NoControl</srcid><srcstatus/><internalId>1598</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR422_SetControllerMode_Wakeup_NoRef</srcid><srcstatus/><internalId>1606</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR430_SetControllerMode_Wakeup_Second_Switch_PortGroup_NoControl</srcid><srcstatus/><internalId>1646</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR430_SetControllerMode_Wakeup_NoRef</srcid><srcstatus/><internalId>1655</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>378</internalId></specobject>

    <specobject>
      <id>EthIf.EB.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange.NoRef</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If EthIf_MainFunctionRx() polls link state for a EthIfCtrlIdx with no reference to EthTrcv,
        EthIfSwitch or a port group UL_TrcvLinkStateChg() shall be called to notify the link state
        change for that controller.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ASR403_SetControllerMode_Wakeup_Activate_NoRef</srcid><srcstatus/><internalId>1569</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR422_SetControllerMode_Wakeup_Activate_NoRef</srcid><srcstatus/><internalId>1608</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR430_SetControllerMode_Wakeup_Activate_NoRef</srcid><srcstatus/><internalId>1657</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00108</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>467</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00109</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>468</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91104</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>749</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00230</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>555</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>379</internalId></specobject>

    <specobject>
      <id>EthIf.EB.EthTrcv_SetTransceiverMode.Async.CtrlModeIndication</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If EthIf is configured for asynchronous mode and  EthIf_SetControllerMode has been called with
        ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST, EthIf will not call EthTrcv_SetTransceiverMode with
        ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST before CtrlModeIndication was called.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ASR403_SetControllerMode_Wakeup_Second_Transceiver_2</srcid><srcstatus/><internalId>1546</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR422_SetControllerMode_Wakeup_Second_Transceiver_2</srcid><srcstatus/><internalId>1585</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR430_SetControllerMode_Wakeup_Second_Transceiver_2</srcid><srcstatus/><internalId>1633</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.EB.SWS_EthIf_00479</srcid><srcstatus/><internalId>374</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>380</internalId></specobject>

    <specobject>
      <id>EthIf.EB.EthSwt_SetSwitchPortMode.Async.CtrlModeIndication</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If EthIf is configured for asynchronous mode and  EthIf_SetControllerMode has been called with
        ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST, EthIf will not call EthSwt_SetSwitchPortMode with
        ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST before CtrlModeIndication was called.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ASR403_SetControllerMode_Wakeup_Second_Switch_2</srcid><srcstatus/><internalId>1558</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR403_SetControllerMode_Wakeup_Second_SwitchPortGroup_2</srcid><srcstatus/><internalId>1573</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR422_SetControllerMode_Wakeup_Second_Switch_2</srcid><srcstatus/><internalId>1597</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR422_SetControllerMode_Wakeup_Second_SwitchPortGroup_2</srcid><srcstatus/><internalId>1612</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR430_SetControllerMode_Wakeup_Second_Switch_2</srcid><srcstatus/><internalId>1645</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR430_SetControllerMode_Wakeup_Second_SwitchPortGroup_2</srcid><srcstatus/><internalId>1661</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.EB.SWS_EthIf_00480</srcid><srcstatus/><internalId>375</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.SWS_EthIf_00481</srcid><srcstatus/><internalId>376</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>381</internalId></specobject>

    <specobject>
      <id>EthIf.EB.ReportIssueCallout.Signature</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If enabled the reporting function configured in EthIfGeneral/EthIfReportIssueCalloutFuncName
        shall have the following signature:
        void &lt;EthIfReportIssueCalloutFuncName&gt;
        (
          EthIf_ReportIdType ReportId,
          P2CONST(EthIf_ReportIssueContextType, AUTOMATIC, ETHIF_APPL_DATA) ContextDataPtr
        )
        Parameters:
        (in): ReportId - Specifies reason for the IP datagram drop.
        (in): ContextDataPtr - Contains additional information on the dropped frame
      </description>
      <tags>
        <tag>Unit:None</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest12000_RptSecEvToIdsM_ETHIF_SEV_DROP_INV_VLAN</srcid><srcstatus/><internalId>1723</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest12001_RptSecEvToIdsM_ETHIF_SEV_DROP_INV_VLAN_2</srcid><srcstatus/><internalId>1724</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest12002_RptSecEvToIdsM_ETHIF_SEV_DROP_VLAN_DOUBLE_TAG</srcid><srcstatus/><internalId>1725</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest12003_RptSecEvToIdsM_ETHIF_SEV_DROP_INV_VLAN_3</srcid><srcstatus/><internalId>1726</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest12004_RptSecEvToIdsM_ETHIF_SEV_DROP_UNKNOWN_ETHERTYPE</srcid><srcstatus/><internalId>1727</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>382</internalId></specobject>

    <specobject>
      <id>EthIf.EB.ReportIssueCallout.INV_VLAN</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If enabled the reporting function configured in EthIfGeneral/EthIfReportIssueCalloutFuncName
        shall be called if a frame is dropped due to an invalid VlanId inside the received header.
      </description>
      <tags>
        <tag>Unit:None</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest12000_RptSecEvToIdsM_ETHIF_SEV_DROP_INV_VLAN</srcid><srcstatus/><internalId>1723</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest12001_RptSecEvToIdsM_ETHIF_SEV_DROP_INV_VLAN_2</srcid><srcstatus/><internalId>1724</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest12003_RptSecEvToIdsM_ETHIF_SEV_DROP_INV_VLAN_3</srcid><srcstatus/><internalId>1726</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>383</internalId></specobject>
    
    <specobject>
      <id>EthIf.EB.ReportIssueCallout.VLAN_DOUBLE_TAG</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If enabled the reporting function configured in EthIfGeneral/EthIfReportIssueCalloutFuncName
        shall be called if a frame is dropped due to a double VlanId inside the received header.
      </description>
      <tags>
        <tag>Unit:None</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest12002_RptSecEvToIdsM_ETHIF_SEV_DROP_VLAN_DOUBLE_TAG</srcid><srcstatus/><internalId>1725</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>384</internalId></specobject>
    
    <specobject>
      <id>EthIf.EB.ReportIssueCallout.UNKNOWN_ETHERTYPE</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If enabled the reporting function configured in EthIfGeneral/EthIfReportIssueCalloutFuncName
        shall be called if a frame is dropped due to invalid ether type indicated inside the received packet.
      </description>
      <tags>
        <tag>Unit:None</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest12004_RptSecEvToIdsM_ETHIF_SEV_DROP_UNKNOWN_ETHERTYPE</srcid><srcstatus/><internalId>1727</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>385</internalId></specobject>
    
    <specobject>
      <id>EthIf.EB.RxIndication.PhysAddrPtr</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function EthIf_RxIndication shall check the
        parameter PhysAddrPtr for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_PARAM_POINTER.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01166_EthIf_RxIndication_InvalidPhysAddrPtr</srcid><srcstatus/><internalId>1380</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_BSW_00212.NullPointerChecking</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>961</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>386</internalId></specobject>

  </specobjects>
    <specobjects doctype="swurs">
      <specobject>
      <id>EthIf.ECUC_EthIf_00001</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfGeneral
        Container Type: Container
        Sub-Containers: EthIfSecurityEventRefs 
        Description: This container contains the general configuration parameters of the Ethernet 
        Interface.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>387</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00002</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfMaxTxBufsTotal
        Parameter Type: Integer
        Parent Containers: EthIfController,
        Description: Limits the total number of transmit buffers.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: 4294967295 (Type:
        Min-Value: 1 (Type:
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.EthIfMaxTxBufsTotal</srcid><srcstatus/><internalId>988</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>388</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00003</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfMaxTrcvsTotal
        Parameter Type: Integer
        Parent Containers: EthIfGeneral,
        Description: Limits the total number of transceivers.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: 255 (Type:
        Min-Value: 1 (Type:
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>389</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00004</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfDevErrorDetect
        Parameter Type: Boolean
        Parent Containers: EthIfGeneral,
        Description: Switches the development error detection and notification on or off.
        Introduction: * true: detection and notification is enabled. * false: detection and 
        notification is disabled.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>390</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00005</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfEnableRxInterrupt
        Parameter Type: Boolean
        Parent Containers: EthIfGeneral,
        Description: Enables / Disables receive interrupt.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.InterruptMode</srcid><srcstatus/><internalId>983</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>391</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00006</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfEnableTxInterrupt
        Parameter Type: Boolean
        Parent Containers: EthIfGeneral,
        Description: Enables / Disables the transmit interrupt.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.InterruptMode</srcid><srcstatus/><internalId>983</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>392</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00007</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfVersionInfoApi
        Parameter Type: Boolean
        Parent Containers: EthIfGeneral,
        Description: Enables / Disables version info API
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompileTest_03</srcid><srcstatus/><internalId>1240</internalId></linkedfrom><linkedfrom><srcid>EthIf_ComTest04</srcid><srcstatus/><internalId>1241</internalId></linkedfrom><linkedfrom><srcid>EthIf_ComTest_06_Swt_support</srcid><srcstatus/><internalId>1243</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>393</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00008</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfVersionInfoApiMacro
        Parameter Type: Boolean
        Parent Containers: EthIfGeneral,
        Description: Enables / Disables version info API macro implementation.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.GetVersionApiMacro</srcid><srcstatus/><internalId>985</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>394</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00009</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfTrcvLinkStateChgMainReload
        Parameter Type: Integer
        Parent Containers: EthIfGeneral,
        Description: Specifies the frequency of transceiver link state change checks in each
        Introduction: period of main function EthIf_MainFunctionTx.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: 255 (Type:
        Min-Value: 1 (Type:
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.TrcvLinkStateChgPolling</srcid><srcstatus/><internalId>984</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>395</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00010</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfConfigSet
        Container Type: Container
        Sub-Containers: EthIfController EthIfFrameOwnerConfig EthIfPhysController 
        EthIfRxIndicationConfig EthIfSwitch EthIfSwitchMgmtInfoIndicationConfig EthIfSwitchPortGroup 
        EthIfSwitchTimeStampIndicationConfig EthIfTransceiver EthIfTrcvLinkStateChgConfig 
        EthIfTxConfirmationConfig 
        Description: Collecting container for all parameters with post-build configuration classes.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>396</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00011</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfFrameOwnerConfig
        Container Type: Sub-Container
        Parent Containers: EthIfConfigSet,
        Description: Configuration of Ethernet frame owner
        Lower Multiplicity: 1
        infinite
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>397</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00012</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfFrameType
        Parameter Type: Integer
        Parent Containers: EthIfFrameOwnerConfig,
        Description: Selects the Ethernet frame type.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: 65535 (Type:
        Min-Value: 0 (Type:
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.ConfigClassGenUL</srcid><srcstatus/><internalId>990</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>398</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00013</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfOwner
        Parameter Type: Integer
        Parent Containers: EthIfFrameOwnerConfig,
        Description: Selects the owner of an Ethernet frame type. The owner is a zero based index into 
        the callback function configuration 'EthIfRxIndicationConfig'. I.e. an Ethernet frame of type 
        IPv4 (0x800) at index 0 will call the first callback function configured in '
        EthIfRxIndicationConfig'
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: 255 (Type:
        Min-Value: 0 (Type:
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.ConfigClassGenUL</srcid><srcstatus/><internalId>990</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>399</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00014</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfRxIndicationConfig
        Container Type: Sub-Container
        Parent Containers: EthIfConfigSet,
        Description: Configuration of receive callback functions.
        Lower Multiplicity: 1
        infinite
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>400</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00015</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfRxIndicationFunction
        Parameter Type: FunctionRef
        Parent Containers: EthIfRxIndicationConfig,
        Description: Specifies receive indication callback function.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        FunctionName Def Condition:Max-Length: , Min-Length
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.ConfigClassGenUL</srcid><srcstatus/><internalId>990</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>401</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00016</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfTxConfirmationConfig
        Container Type: Sub-Container
        Parent Containers: EthIfConfigSet,
        Description: Configuration of transmit indication callback functions.
        Lower Multiplicity: 0
        infinite
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>402</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00017</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfTxConfirmationFunction
        Parameter Type: FunctionRef
        Parent Containers: EthIfTxConfirmationConfig,
        Description: Specifies transmit indication callback function
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        FunctionName Def Condition:Max-Length: , Min-Length
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.ConfigClassGenUL</srcid><srcstatus/><internalId>990</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>403</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00018</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfTrcvLinkStateChgConfig
        Container Type: Sub-Container
        Parent Containers: EthIfConfigSet,
        Description: Specifies link state change callback function
        Lower Multiplicity: 1
        infinite
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>404</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00019</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfTrcvLinkStateChgFunction
        Parameter Type: FunctionRef
        Parent Containers: EthIfTrcvLinkStateChgConfig,
        Description: Specifies link state change callback function
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        FunctionName Def Condition:Max-Length: , Min-Length
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.ConfigClassGenUL</srcid><srcstatus/><internalId>990</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>405</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00023</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfMainFunctionPeriod
        Parameter Type: FloatValue
        Parent Containers: EthIfGeneral,
        Description: Specifies the period of main function EthIf_MainFunctionRx and 
        EthIf_MainFunctionTx in seconds. Ethernet Interface does not require this information but the 
        BSW scheduler.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: INF (Type: OPEN)
        Min-Value: 0 (Type: OPEN)
      </description>
      <comment>
        Check in BSWMD, maybe also with computation of timers
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate_swcd/swcd/EthIf_Bswmd.arxml.m4_124</srcid><srcstatus/><internalId>1110</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/generate_swcd/swcd/EthIf_Bswmd.arxml.m4_136</srcid><srcstatus/><internalId>1111</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>409</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>406</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00024</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfPublicCddHeaderFile
        Parameter Type: StringParameter
        Parent Containers: EthIfGeneral,
        Description: Defines header files for callback functions which shall be included in case of 
        CDDs. Range of characters is 1.. 32.
        Lower Multiplicity: 0
        infinite
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: false
        Post-Build-Variant-Value: false
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        String Param Def Condition: Default Value: , Max-Length: 32, Min-Length: 1, Regular-Expression:
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>407</internalId></specobject>

    <specobject>
      <id>EthIf.SWS_EthIf_00003</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The Ethernet Interface is using an index (EthIfCtrlIdx) to abstract the access to VLANs from 
        the underlying communication system compromised of Ethernet Controller and Ethernet Transceiver.
        Therefore the Ethernet Interface shall implement a mapping from Ethernet Interface controllers 
        EthIfCtrlIdx) to respective hardware resource controllers (EthCtrlId + EthTrcvId)
      </description>
      <furtherinfo>
        WRN.swurs.needscoverage.count - Linking all relevant requirements to the single top-level
        requirement brings clear benefits and splitting them up would only increase complexity
        without any real benefit.
      </furtherinfo>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.SWS_EthIf_00035</srcid><srcstatus/><internalId>424</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00040</srcid><srcstatus/><internalId>428</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00134</srcid><srcstatus/><internalId>494</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00140</srcid><srcstatus/><internalId>499</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00068</srcid><srcstatus/><internalId>939</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00068.1</srcid><srcstatus/><internalId>940</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00068.2</srcid><srcstatus/><internalId>941</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00068.3</srcid><srcstatus/><internalId>942</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00076</srcid><srcstatus/><internalId>943</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00076.1</srcid><srcstatus/><internalId>944</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00076.2</srcid><srcstatus/><internalId>945</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00076.3</srcid><srcstatus/><internalId>946</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>408</internalId></specobject>

    <specobject>
      <id>EthIf.SWS_EthIf_00004</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The Ethernet Interface shall implement main functions to be used for frame transmission 
        confirmation and frame reception in polling mode with a calling period configurable at system 
        configuration time.
      </description>
      <comment>
        Calling period should be written to BSWMD.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.ECUC_EthIf_00023</srcid><srcstatus/><internalId>406</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>409</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00005</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The Ethernet Interface module shall support pre-compile time, link time and post-build time 
        configuration.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.PostbuildSupport</srcid><srcstatus/><internalId>986</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.EB.EthIf_00005</srcid><srcstatus/><internalId>136</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>410</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00006</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The header file EthIf.h shall include a software and specification version number.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/EthIf.h_58</srcid><srcstatus/><internalId>1053</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/include/EthIf_Version.h.m4_2</srcid><srcstatus/><internalId>1060</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>411</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00007</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The Ethernet Interface module shall perform a consistency check between code files and header 
        files based on pre-process-checking the version numbers of related code files and header files.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.ConsChck</srcid><srcstatus/><internalId>987</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>412</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00008</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        In case development error detection is enabled for the Ethernet Interface module: The Ethernet 
        Interface module shall check API parameters for validity and report detected errors to the DET.
      </description>
      <furtherinfo>
        WRN.swurs.needscoverage.count - Linking all relevant requirements to the single top-level
        requirement brings clear benefits and splitting them up would only increase complexity
        without any real benefit.
      </furtherinfo>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00036</srcid><srcstatus/><internalId>40</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00041</srcid><srcstatus/><internalId>41</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00063</srcid><srcstatus/><internalId>42</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00077</srcid><srcstatus/><internalId>43</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00086</srcid><srcstatus/><internalId>44</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00092</srcid><srcstatus/><internalId>45</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00135</srcid><srcstatus/><internalId>46</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00141</srcid><srcstatus/><internalId>47</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.SWS_EthIf_00073_2</srcid><srcstatus/><internalId>139</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00042</srcid><srcstatus/><internalId>430</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00043</srcid><srcstatus/><internalId>431</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00064</srcid><srcstatus/><internalId>435</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00065</srcid><srcstatus/><internalId>436</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00070</srcid><srcstatus/><internalId>439</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00071</srcid><srcstatus/><internalId>440</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00072</srcid><srcstatus/><internalId>441</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00078</srcid><srcstatus/><internalId>445</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00079</srcid><srcstatus/><internalId>446</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00080</srcid><srcstatus/><internalId>447</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00087</srcid><srcstatus/><internalId>451</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00088</srcid><srcstatus/><internalId>452</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00093</srcid><srcstatus/><internalId>455</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00094</srcid><srcstatus/><internalId>456</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00116</srcid><srcstatus/><internalId>474</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00127</srcid><srcstatus/><internalId>479</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00136</srcid><srcstatus/><internalId>496</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00137</srcid><srcstatus/><internalId>497</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00142</srcid><srcstatus/><internalId>501</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00143</srcid><srcstatus/><internalId>502</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>413</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00010</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The Ethernet Interface module shall implement the API functions specified by the Ethernet 
        Interface SWS as real C-code functions and shall not implement the API as macros for object 
        code deliveries.
      </description>
      <comment>
        This requirement is not applicable.
        Rationale:
        Requirement does not exist in other AUTOSAR modules making it inconstant. Furthermore it is
        up to the stack vendor how code is delivered.
        AUTOSAR R20-11 comment: Requirement was not changed.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>414</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00011</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        None of the Ethernet Interface module header files shall define global variables.
      </description>
      <comment>
        This requirement is not applicable.
        Rationale:
        It is up to the architecture and design if sharing of global variables between
        module internal units/files or between modules of a bundle make sense or not.
        
        AUTOSAR R20-11 comment: Requirement was not changed.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>415</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00012</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The Ethernet Interface module shall provide an XML file that contains the data, which is 
        required for the SW identification (it shall contain the vendor identification, module ID and 
        software version information), configuration and integration process. This file should describe 
        vendor specific configuration parameters as well as it should contain recommended configuration 
        parameter values.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate_swcd/swcd/EthIf_Bswmd.arxml.m4_314</srcid><srcstatus/><internalId>1112</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>416</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00013</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The configuration of the Ethernet Interface module shall be configured at ECU configuration 
        time. None of the communication parameters shall be configured at runtime.
      </description>
      <comment>
        This requirement is not applicable.
        Rationale:
        This requirement is in contradiction with post-build time configuration. Additionally all
        configuration parameters have specified a configuration class making this requirement
        obsolete.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>417</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00014</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The start address of post-build time configuration data shall be passed during module 
        initialization
      </description>
      <comment>
        This requirement is informational only.
        Rationale:
        The integrator has to take care that this requirement is fulfilled.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>418</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00017</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Type of error | Related error code | Error value 
        API service called with invalid controller index | ETHIF_E_INV_CTRL_IDXEthIf.
        ETHIF_E_INV_CTRL_IDX | 0x01 
        API service called with invalid transceiver index | ETHIF_E_INV_TRCV_IDXEthIf.
        ETHIF_E_INV_TRCV_IDX | 0x02 
        API service called with invalid switch index | ETHIF_E_INV_SWT_IDXEthIf.ETHIF_E_INV_SWT_IDX | 
        0x03 
        API service called with invalid port group index | ETHIF_E_INV_PORT_GROUP_IDXEthIf.
        ETHIF_E_INV_PORT_GROUP_IDX | 0x04 
        API service called when EthIf module was not initialized | ETHIF_E_UNINITEthIf.ETHIF_E_UNINIT 
        0x05 
        API service called with invalid pointer in parameter list | ETHIF_E_PARAM_POINTEREthIf.
        ETHIF_E_PARAM_POINTER | 0x06 
        API service called with invalid parameter | ETHIF_E_INV_PARAMEthIf.ETHIF_E_INV_PARAM | 0x07 
        EthIf_Init called with an invalid configuration pointer | ETHIF_E_INIT_FAILEDEthIf.
        ETHIF_E_INIT_FAILED | 0x08 
        Invalid port index | ETHIF_E_INV_PORT_IDXEthIf.ETHIF_E_INV_PORT_IDX | 0x09
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.DevelopmentErrors</srcid><srcstatus/><internalId>1003</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>419</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00023</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Module | Header File | Imported Type 
        ComStack_Types | ComStack_Types.h | BufReq_ReturnType 
        EcuM | EcuM.h | EcuM_WakeupSourceType 
        Eth | Eth_GeneralTypes.h | Eth_BufIdxType 
        Eth_GeneralTypes.h | Eth_CounterType 
        Eth_GeneralTypes.h | Eth_DataType 
        Eth_GeneralTypes.h | Eth_FilterActionType 
        Eth_GeneralTypes.h | Eth_FrameType 
        Eth_GeneralTypes.h | Eth_MacVlanType 
        Eth_GeneralTypes.h | Eth_ModeType 
        Eth_GeneralTypes.h | Eth_RxStatsType 
        Eth_GeneralTypes.h | Eth_RxStatusType 
        Eth_GeneralTypes.h | Eth_TimeStampQualType 
        Eth_GeneralTypes.h | Eth_TimeStampType 
        Eth_GeneralTypes.h | Eth_TxErrorCounterValuesType 
        Eth_GeneralTypes.h | Eth_TxStatsType 
        EthSwt | Eth_GeneralTypes.h | EthSwt_MacLearningType 
        Eth_GeneralTypes.h | EthSwt_MgmtInfoType 
        Eth_GeneralTypes.h | EthSwt_MgmtObjectType 
        Eth_GeneralTypes.h | EthSwt_MgmtObjectValidType 
        Eth_GeneralTypes.h | EthSwt_MgmtOwner 
        Eth_GeneralTypes.h | EthSwt_PortMirrorCfgType 
        Eth_GeneralTypes.h | EthSwt_PortMirrorStateType 
        EthTrcv | Eth_GeneralTypes.h | EthTrcv_BaudRateType 
        Eth_GeneralTypes.h | EthTrcv_CableDiagResultType 
        Eth_GeneralTypes.h | EthTrcv_DuplexModeType 
        Eth_GeneralTypes.h | EthTrcv_LinkStateType 
        Eth_GeneralTypes.h | EthTrcv_MacMethodType 
        Eth_GeneralTypes.h | EthTrcv_PhyLoopbackModeType 
        Eth_GeneralTypes.h | EthTrcv_PhyTestModeType 
        Eth_GeneralTypes.h | EthTrcv_PhyTxModeType 
        Eth_GeneralTypes.h | EthTrcv_WakeupModeType 
        Eth_GeneralTypes.h | EthTrcv_WakeupReasonType 
        IdsM | IdsM_Types.h | IdsM_SecurityEventIdType 
        Std | Std_Types.h | Std_ReturnType 
        Std_Types.h | Std_VersionInfoType 
        WEth | WEth_GeneralTypes.h | WEth_BufWRxParamIdType 
        WEth_GeneralTypes.h | WEth_BufWTxParamIdType 
        WEthTrcv | WEth_GeneralTypes.h | WEthTrcv_GetChanRxParamIdType 
        WEth_GeneralTypes.h | WEthTrcv_SetChanRxParamIdType 
        WEth_GeneralTypes.h | WEthTrcv_SetChanTxParamIdType 
        WEth_GeneralTypes.h | WEthTrcv_SetRadioParamIdType
      </description>
      <comment>
        This requirement is informational only.
      AUTOSAR R20-11 comment: Requirement was changed, but is informational only.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>420</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00024</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_Init 
        Syntax 
        void EthIf_Init (const EthIf_ConfigType* CfgPtr)
        Service ID [hex] | 0x01 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | CfgPtr | Points to the implementation specific structure 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | Initializes the Ethernet Interface 
        Available via | EthIf.h
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompileTest_01</srcid><srcstatus/><internalId>1237</internalId></linkedfrom><linkedfrom><srcid>EthIf_ComTest02</srcid><srcstatus/><internalId>1239</internalId></linkedfrom><linkedfrom><srcid>EthIf_CompileTest_03</srcid><srcstatus/><internalId>1240</internalId></linkedfrom><linkedfrom><srcid>EthIf_ComTest04</srcid><srcstatus/><internalId>1241</internalId></linkedfrom><linkedfrom><srcid>EthIf_CompileTest_SchM</srcid><srcstatus/><internalId>1249</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest01318_MacSec_MacSecOperational_3</srcid><srcstatus/><internalId>1748</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00024.ServiceId</srcid><srcstatus/><internalId>93</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>421</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00025</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function shall store the access to the configuration structure for subsequent API calls.
      </description>
      <comment>
        This requirement is informational only.
        Rationale: This is a prerequisite for the module in order to work correctly.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>422</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00034</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_SetControllerMode 
        Syntax 
        Std_ReturnType EthIf_SetControllerMode (uint8 CtrlIdx, Eth_ModeType CtrlMode)
        Service ID [hex] | 0x03 
        Sync/Async | Asynchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | CtrlIdx | Index of the Ethernet controller within the context of the Ethernet 
        Interface 
        CtrlMode | ETH_MODE_DOWN: disable the controller ETH_MODE_ACTIVE: enable the controller 
        ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST: enable the controller and request a wake-up on the network.
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | Std_ReturnType | E_OK: successE_NOT_OK: controller mode could not be changed 
        Description | Enables / disables the indexed controller 
        Available via | EthIf.h
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompileTest_01</srcid><srcstatus/><internalId>1237</internalId></linkedfrom><linkedfrom><srcid>EthIf_ComTest02</srcid><srcstatus/><internalId>1239</internalId></linkedfrom><linkedfrom><srcid>EthIf_CompileTest_03</srcid><srcstatus/><internalId>1240</internalId></linkedfrom><linkedfrom><srcid>EthIf_ComTest04</srcid><srcstatus/><internalId>1241</internalId></linkedfrom><linkedfrom><srcid>EthIf_CompileTest_SchM</srcid><srcstatus/><internalId>1249</internalId></linkedfrom><linkedfrom><srcid>EthIf_T112_DET_00_SetControllerMode_DetUninit</srcid><srcstatus/><internalId>1755</internalId></linkedfrom><linkedfrom><srcid>EthIf_T112_DET_01_SetControllerMode_DetInvCtrlIdx</srcid><srcstatus/><internalId>1756</internalId></linkedfrom><linkedfrom><srcid>EthIf_T112_00_SetControllerMode_ValidParameters</srcid><srcstatus/><internalId>1757</internalId></linkedfrom><linkedfrom><srcid>EthIf_T112_00_SetControllerMode_EthSetControllerMode_NotOk</srcid><srcstatus/><internalId>1758</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00034.ServiceId</srcid><srcstatus/><internalId>95</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>423</internalId></specobject>

    <specobject>
      <id>EthIf.SWS_EthIf_00035</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_SetControllerMode shall forward the call to function Eth_SetControllerMode 
        of the corresponding Ethernet Controller Driver (EthIfPhysControllerIdx) with ETH_MODE_ACTIVE, 
        if mode ETH_MODE_ACTIVE or ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST has been requested and the 
        corresponding Ethernet Controller Driver (EthIfPhysControllerIdx) has NOT already indicated 
        ETH_MODE_ACTIVE.
      </description>
      <furtherinfo>
        WRN.swuts.needscoverage.count - Linking all relevant test cases to the single requirement brings clear benefits and
        splitting them up would only increase complexity without any real improvements.
      </furtherinfo>
      <comment>
        Arguments of Eth_SetControllerMode:
      - CtrlIdx: search for the EthIfCtrl with EthIfCtrlIdx==CtrlIdx, follow reference to EthCtrl, pass on EthCtrlIdx
      - CfgIdx: if referenced by single EthIfCtrl: just passed on, otherwise see SWS_EthIf_00263
      - return value: if referenced by single EthIfCtrl: just passed on, otherwise see SWS_EthIf_00263
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest05010_SetControllerMode_Active</srcid><srcstatus/><internalId>1441</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR403_SetControllerMode_Wakeup_Transceiver</srcid><srcstatus/><internalId>1544</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR403_SetControllerMode_Wakeup_Second_Transceiver</srcid><srcstatus/><internalId>1545</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR403_SetControllerMode_Wakeup_Switch</srcid><srcstatus/><internalId>1556</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR403_SetControllerMode_Wakeup_Second_Switch</srcid><srcstatus/><internalId>1557</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR403_SetControllerMode_Wakeup_NoRef</srcid><srcstatus/><internalId>1567</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR403_SetControllerMode_Wakeup_Second_NoRef</srcid><srcstatus/><internalId>1568</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR403_SetControllerMode_Wakeup_SwitchPortGroup</srcid><srcstatus/><internalId>1571</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR403_SetControllerMode_Wakeup_Second_SwitchPortGroup</srcid><srcstatus/><internalId>1572</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR422_SetControllerMode_Wakeup_Transceiver</srcid><srcstatus/><internalId>1583</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR422_SetControllerMode_Wakeup_Second_Transceiver</srcid><srcstatus/><internalId>1584</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR422_SetControllerMode_Wakeup_Switch</srcid><srcstatus/><internalId>1595</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR422_SetControllerMode_Wakeup_Second_Switch</srcid><srcstatus/><internalId>1596</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR422_SetControllerMode_Wakeup_NoRef</srcid><srcstatus/><internalId>1606</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR422_SetControllerMode_Wakeup_Second_NoRef</srcid><srcstatus/><internalId>1607</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR422_SetControllerMode_Wakeup_SwitchPortGroup</srcid><srcstatus/><internalId>1610</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR422_SetControllerMode_Wakeup_Second_SwitchPortGroup</srcid><srcstatus/><internalId>1611</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR430_SetControllerMode_Wakeup_Transceiver</srcid><srcstatus/><internalId>1631</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR430_SetControllerMode_Wakeup_Second_Transceiver</srcid><srcstatus/><internalId>1632</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR430_SetControllerMode_Wakeup_Switch</srcid><srcstatus/><internalId>1643</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR430_SetControllerMode_Wakeup_Second_Switch</srcid><srcstatus/><internalId>1644</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR430_SetControllerMode_Wakeup_NoRef</srcid><srcstatus/><internalId>1655</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR430_SetControllerMode_Wakeup_Second_NoRef</srcid><srcstatus/><internalId>1656</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR430_SetControllerMode_Wakeup_SwitchPortGroup</srcid><srcstatus/><internalId>1659</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR430_SetControllerMode_Wakeup_Second_SwitchPortGroup</srcid><srcstatus/><internalId>1660</internalId></linkedfrom><linkedfrom><srcid>EthIf_T112_00_SetControllerMode_EthSetControllerMode_NotOk</srcid><srcstatus/><internalId>1758</internalId></linkedfrom><linkedfrom><srcid>EthIf_T500_SetControllerMode_Concurrent</srcid><srcstatus/><internalId>1809</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>408</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>424</internalId></specobject>

    <specobject>
      <id>EthIf.SWS_EthIf_00036</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service EthIf_Init 
        was previously called. If the check fails, the function shall raise the development error 
        ETHIF_E_UNINIT otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.DevelopmentErrors</srcid><srcstatus/><internalId>1003</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>425</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00037</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter CtrlIdx for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_INV_CTRL_IDX otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01075_SetControllerMode_InvalidParam</srcid><srcstatus/><internalId>1297</internalId></linkedfrom><linkedfrom><srcid>EthIf_T112_DET_01_SetControllerMode_DetInvCtrlIdx</srcid><srcstatus/><internalId>1756</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>426</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00039</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_GetControllerMode 
        Syntax 
        Std_ReturnType EthIf_GetControllerMode (uint8 CtrlIdx, Eth_ModeType* CtrlModePtr)
        Service ID [hex] | 0x04 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | CtrlIdx | Index of the Ethernet controller within the context of the Ethernet 
        Interface 
        Parameters (inout) | None 
        Parameters (out) | CtrlModePtr | ETH_MODE_DOWN: the controller is disabled ETH_MODE_ACTIVE: the 
        controller is enabled 
        Return value | Std_ReturnType | E_OK: successE_NOT_OK: controller could not be initialized 
        Description | Obtains the state of the indexed controller 
        Available via | EthIf.h
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompileTest_01</srcid><srcstatus/><internalId>1237</internalId></linkedfrom><linkedfrom><srcid>EthIf_ComTest02</srcid><srcstatus/><internalId>1239</internalId></linkedfrom><linkedfrom><srcid>EthIf_CompileTest_03</srcid><srcstatus/><internalId>1240</internalId></linkedfrom><linkedfrom><srcid>EthIf_ComTest04</srcid><srcstatus/><internalId>1241</internalId></linkedfrom><linkedfrom><srcid>EthIf_CompileTest_SchM</srcid><srcstatus/><internalId>1249</internalId></linkedfrom><linkedfrom><srcid>EthIf_T111_DET_00_GetControllerMode_DetUninit</srcid><srcstatus/><internalId>1751</internalId></linkedfrom><linkedfrom><srcid>EthIf_T111_DET_01_GetControllerMode_DetInvCtrlIdx</srcid><srcstatus/><internalId>1752</internalId></linkedfrom><linkedfrom><srcid>EthIf_T111_DET_02_GetControllerMode_DetInvParPtr</srcid><srcstatus/><internalId>1753</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00039.ServiceId</srcid><srcstatus/><internalId>96</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>427</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00040</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_GetControllerMode shall forward the call to function Eth_GetControllerMode 
        of the corresponding Ethernet Controller Driver (EthIfPhysControllerIdx)
      </description>
      <comment>
        Arguments of Eth_GetControllerMode:
      - CtrlIdx: search for the EthIfCtrl with EthIfCtrlIdx == CtrlIdx, follow reference to EthCtrl,
                 pass on EthCtrlIdx
      - CtrlModePtr: if referenced by single EthIfCtrl: just passed on
      - return value: if referenced by single EthIfCtrl: just passed on
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_T111_00_GetControllerMode_ValidParameters</srcid><srcstatus/><internalId>1754</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest02016_GetControllerMode</srcid><srcstatus/><internalId>1902</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>408</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>428</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00041</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service EthIf_Init 
        was previously called. If the check fails, the function shall raise the development error 
        ETHIF_E_UNINIT otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <comment>
        EthIf_GetControllerMode
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.DevelopmentErrors</srcid><srcstatus/><internalId>1003</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>429</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00042</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter CtrlIdx for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_INV_CTRL_IDX otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <comment>
        EthIf_GetControllerMode
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01077_GetControllerMode_InvalidParam</srcid><srcstatus/><internalId>1299</internalId></linkedfrom><linkedfrom><srcid>EthIf_T111_DET_01_GetControllerMode_DetInvCtrlIdx</srcid><srcstatus/><internalId>1752</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>413</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>430</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00043</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter CtrlModePtr 
        for being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_PARAM_POINTER otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <comment>
        EthIf_GetControllerMode
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01077_GetControllerMode_InvalidParam</srcid><srcstatus/><internalId>1299</internalId></linkedfrom><linkedfrom><srcid>EthIf_T111_DET_02_GetControllerMode_DetInvParPtr</srcid><srcstatus/><internalId>1753</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>413</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>431</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00061</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_GetPhysAddr 
        Syntax 
        void EthIf_GetPhysAddr (uint8 CtrlIdx, uint8* PhysAddrPtr)
        Service ID [hex] | 0x08 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | CtrlIdx | Index of the Ethernet controller within the context of the Ethernet 
        Interface 
        Parameters (inout) | None 
        Parameters (out) | PhysAddrPtr | Physical source address (MAC address) in network byte order.
        Return value | None 
        Description | Obtains the physical source address used by the indexed controller 
        Available via | EthIf.h
      </description>
      <comment>
        Arguments of Eth_GetPhysAddr:
      - CtrlIdx: search for the EthIfCtrl with EthIfCtrlIdx==CtrlIdx, follow reference to EthCtrlConfig, pass on EthCtrlIdx
      - PhysAddrPtr: just passed on
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompileTest_01</srcid><srcstatus/><internalId>1237</internalId></linkedfrom><linkedfrom><srcid>EthIf_ComTest02</srcid><srcstatus/><internalId>1239</internalId></linkedfrom><linkedfrom><srcid>EthIf_CompileTest_03</srcid><srcstatus/><internalId>1240</internalId></linkedfrom><linkedfrom><srcid>EthIf_ComTest04</srcid><srcstatus/><internalId>1241</internalId></linkedfrom><linkedfrom><srcid>EthIf_CompileTest_SchM</srcid><srcstatus/><internalId>1249</internalId></linkedfrom><linkedfrom><srcid>EthIf_T160_DET_00_GetPhysAddr_DetUninit</srcid><srcstatus/><internalId>1778</internalId></linkedfrom><linkedfrom><srcid>EthIf_T160_DET_01_GetPhysAddr_DetInvCtrlIdx</srcid><srcstatus/><internalId>1779</internalId></linkedfrom><linkedfrom><srcid>EthIf_T160_DET_02_GetPhysAddr_DetInvParPtr</srcid><srcstatus/><internalId>1780</internalId></linkedfrom><linkedfrom><srcid>EthIf_T160_00_GetPhysAddr_ValidParameters</srcid><srcstatus/><internalId>1781</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00061.ServiceId</srcid><srcstatus/><internalId>100</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>432</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00062</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_GetPhysAddr shall forward the call to the respective Ethernet Controller 
        Driver.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_T160_00_GetPhysAddr_ValidParameters</srcid><srcstatus/><internalId>1781</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>433</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00063</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service EthIf_Init 
        was previously called. If the check fails, the function shall raise the development error 
        ETHIF_E_UNINIT.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.DevelopmentErrors</srcid><srcstatus/><internalId>1003</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>434</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00064</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter CtrlIdx for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_INV_CTRL_IDX.
      </description>
      <comment>
        EthIf_GetPhysAddr
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01079_GetPhysAddr_InvalidParam</srcid><srcstatus/><internalId>1301</internalId></linkedfrom><linkedfrom><srcid>EthIf_T160_DET_01_GetPhysAddr_DetInvCtrlIdx</srcid><srcstatus/><internalId>1779</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>413</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>435</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00065</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter PhysAddrPtr 
        for being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_PARAM_POINTER.
      </description>
      <comment>
        EthIf_GetPhysAddr
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01079_GetPhysAddr_InvalidParam</srcid><srcstatus/><internalId>1301</internalId></linkedfrom><linkedfrom><srcid>EthIf_T160_DET_02_GetPhysAddr_DetInvParPtr</srcid><srcstatus/><internalId>1780</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>413</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>436</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00067</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_ProvideTxBuffer 
        Syntax 
        BufReq_ReturnType EthIf_ProvideTxBuffer (uint8 CtrlIdx, Eth_FrameType FrameType, uint8 Priority,
        Eth_BufIdxType* BufIdxPtr, uint8** BufPtr, uint16* LenBytePtr)
        Service ID [hex] | 0x09 
        Sync/Async | Synchronous 
        Reentrancy | Reentrant 
        Parameters (in) | CtrlIdx | Index of the Ethernet controller within the context of the Ethernet 
        Interface 
        FrameType | Ethernet Frame Type (EtherType)
        Priority | Priority value which shall be used for the 3-bit PCP field of the VLAN tag 
        Parameters (inout) | LenBytePtr | in: desired length in bytes, out: granted length in bytes 
        Parameters (out) | BufIdxPtr | Index to the granted buffer resource. To be used for subsequent 
        requests 
        BufPtr | Pointer to the granted buffer 
        Return value | BufReq_ReturnType | BUFREQ_OK: successBUFREQ_E_NOT_OK: development error 
        detectedBUFREQ_E_BUSY: all buffers in useBUFREQ_E_OVFL: requested buffer too large 
        Description | Provides access to a transmit buffer of the specified Ethernet controller.
        Available via | EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompileTest_01</srcid><srcstatus/><internalId>1237</internalId></linkedfrom><linkedfrom><srcid>EthIf_ComTest02</srcid><srcstatus/><internalId>1239</internalId></linkedfrom><linkedfrom><srcid>EthIf_CompileTest_03</srcid><srcstatus/><internalId>1240</internalId></linkedfrom><linkedfrom><srcid>EthIf_ComTest04</srcid><srcstatus/><internalId>1241</internalId></linkedfrom><linkedfrom><srcid>EthIf_CompileTest_SchM</srcid><srcstatus/><internalId>1249</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00067.ServiceId</srcid><srcstatus/><internalId>123</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00130</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>492</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>437</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00069</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service EthIf_Init 
        was previously called. If the check fails, the function shall raise the development error 
        ETHIF_E_UNINIT and return BUFREQ_E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_T150_DET_00_ProvideTxBuffer_DetUninit</srcid><srcstatus/><internalId>1771</internalId></linkedfrom><linkedfrom><srcid>EthIf_T350_DET_00_ProvideTxBuffer_DetUninit</srcid><srcstatus/><internalId>1796</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.DevelopmentErrors</srcid><srcstatus/><internalId>1003</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>438</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00070</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter CtrlIdx for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_INV_CTRL_IDX and return BUFREQ_E_NOT_OK.
      </description>
      <comment>
        EthIf_ProvideTxBuffer
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_T150_DET_01_ProvideTxBuffer_DetInvCtrlIdx</srcid><srcstatus/><internalId>1772</internalId></linkedfrom><linkedfrom><srcid>EthIf_T350_DET_01_ProvideTxBuffer_DetInvCtrlIdx</srcid><srcstatus/><internalId>1797</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>413</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>439</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00071</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter BufIdxPtr for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_PARAM_POINTER and return BUFREQ_E_NOT_OK.
      </description>
      <comment>
        EthIf_ProvideTxBuffer
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_T150_DET_02_ProvideTxBuffer_DetInvParPtr_BufIdxPtr</srcid><srcstatus/><internalId>1773</internalId></linkedfrom><linkedfrom><srcid>EthIf_T350_DET_02_ProvideTxBuffer_DetInvParPtr_BufIdxPtr</srcid><srcstatus/><internalId>1798</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>413</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>440</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00072</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter BufPtr for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_PARAM_POINTER and return BUFREQ_E_NOT_OK.
      </description>
      <comment>
        EthIf_ProvideTxBuffer
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_T150_DET_03_ProvideTxBuffer_DetInvParPtr_BufPtr</srcid><srcstatus/><internalId>1774</internalId></linkedfrom><linkedfrom><srcid>EthIf_T350_DET_03_ProvideTxBuffer_DetInvParPtr_BufPtr</srcid><srcstatus/><internalId>1799</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>413</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>441</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00073</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter LenBytePtr 
        for being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_PARAM_POINTER and return BUFREQ_E_NOT_OK.
      </description>
      <comment>
        EthIf_ProvideTxBuffer
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_T150_DET_04_ProvideTxBuffer_DetInvParPtr_LenBytePtr</srcid><srcstatus/><internalId>1775</internalId></linkedfrom><linkedfrom><srcid>EthIf_T350_DET_04_ProvideTxBuffer_DetInvParPtr_LenBytePtr</srcid><srcstatus/><internalId>1800</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>442</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00075</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>2</version>
      <description>
        Service Name | EthIf_Transmit 
        Syntax 
        Std_ReturnType EthIf_Transmit (uint8 CtrlIdx, Eth_BufIdxType BufIdx, Eth_FrameType FrameType, 
        boolean TxConfirmation, uint16 LenByte, const uint8* PhysAddrPtr)
        Service ID [hex] | 0x0a 
        Sync/Async | Synchronous 
        Reentrancy | Reentrant for different buffer indexes and Ctrl indexes 
        Parameters (in) | CtrlIdx | Index of the Ethernet controller within the context of the Ethernet 
        Interface 
        BufIdx | Index of the buffer resource 
        FrameType | Ethernet frame type 
        TxConfirmation | Activates transmission confirmation 
        LenByte | Data length in byte 
        PhysAddrPtr | Physical target address (MAC address) in network byte order 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | Std_ReturnType | E_OK: successE_NOT_OK: transmission failed 
        Description | Triggers transmission of a previously filled transmit buffer 
        Available via | EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompileTest_01</srcid><srcstatus/><internalId>1237</internalId></linkedfrom><linkedfrom><srcid>EthIf_ComTest02</srcid><srcstatus/><internalId>1239</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00075.ServiceId</srcid><srcstatus/><internalId>124</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>443</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00077</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service EthIf_Init 
        was previously called. If the check fails, the function shall raise the development error 
        ETHIF_E_UNINIT otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.DevelopmentErrors</srcid><srcstatus/><internalId>1003</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>444</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00078</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter CtrlIdx for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_INV_CTRL_IDX otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <comment>
        EthIf_Transmit
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_T130_DET_01_Transmit_DetInvCtrlIdx</srcid><srcstatus/><internalId>1760</internalId></linkedfrom><linkedfrom><srcid>EthIf_T330_DET_01_Transmit_DetInvCtrlIdx</srcid><srcstatus/><internalId>1783</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>413</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>445</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00079</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter BufIdx for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_INV_PARAM otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <comment>
        EthIf_Transmit
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.EthIfMaxTxBufsTotal</srcid><srcstatus/><internalId>988</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>413</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>446</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00080</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter PhysAddrPtr 
        for being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_PARAM_POINTER otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <comment>
        EthIf_Transmit
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_T130_DET_02_Transmit_DetInvParPtr</srcid><srcstatus/><internalId>1761</internalId></linkedfrom><linkedfrom><srcid>EthIf_T330_DET_02_Transmit_DetInvParPtr</srcid><srcstatus/><internalId>1784</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>413</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>447</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00082</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_GetVersionInfo 
        Syntax 
        void EthIf_GetVersionInfo (Std_VersionInfoType* VersionInfoPtr)
        Service ID [hex] | 0x0b 
        Sync/Async | Synchronous 
        Reentrancy | Reentrant 
        Parameters (in) | None 
        Parameters (inout) | None 
        Parameters (out) | VersionInfoPtr | Version information of this module 
        Return value | None 
        Description | Returns the version information of this module 
        Available via | EthIf.h
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompileTest_01</srcid><srcstatus/><internalId>1237</internalId></linkedfrom><linkedfrom><srcid>EthIf_ComTest02</srcid><srcstatus/><internalId>1239</internalId></linkedfrom><linkedfrom><srcid>EthIf_CompileTest_03</srcid><srcstatus/><internalId>1240</internalId></linkedfrom><linkedfrom><srcid>EthIf_ComTest04</srcid><srcstatus/><internalId>1241</internalId></linkedfrom><linkedfrom><srcid>EthIf_CompileTest_SchM</srcid><srcstatus/><internalId>1249</internalId></linkedfrom><linkedfrom><srcid>EthIf_T100_DET_00_GetVersionInfo_DetInvPointer</srcid><srcstatus/><internalId>1749</internalId></linkedfrom><linkedfrom><srcid>EthIf_T100_00_GetVersionInfo_VersionTest</srcid><srcstatus/><internalId>1750</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00082.ServiceId</srcid><srcstatus/><internalId>125</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>448</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00085</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>2</version>
      <description>
        Service Name | EthIf_RxIndication 
        Syntax 
        void EthIf_RxIndication (uint8 CtrlIdx, Eth_FrameType FrameType, boolean IsBroadcast, const 
        uint8* PhysAddrPtr, const Eth_DataType* DataPtr, uint16 LenByte)
        Service ID [hex] | 0x10 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | CtrlIdx | Index of the physical Ethernet controller within the context of the 
        Ethernet Interface 
        FrameType | Frame type of received Ethernet frame 
        IsBroadcast | parameter to indicate a broadcast frame 
        PhysAddrPtr | Pointer to Physical source address (MAC address in network byte order) of 
        received Ethernet frame 
        DataPtr | Pointer to payload of received Ethernet frame.
        LenByte | Length (bytes) of the payload in received frame.
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | Handles a received frame received by the indexed controller 
        Available via | EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompileTest_01</srcid><srcstatus/><internalId>1237</internalId></linkedfrom><linkedfrom><srcid>EthIf_ComTest02</srcid><srcstatus/><internalId>1239</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00085.ServiceId</srcid><srcstatus/><internalId>126</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>449</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00086</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service EthIf_Init 
        was previously called. If the check fails, the function shall raise the development error 
        ETHIF_E_UNINIT.
      </description>
      <comment>
        EthIf_RxIndication
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.DevelopmentErrors</srcid><srcstatus/><internalId>1003</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>450</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00087</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter CtrlIdx for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_INV_CTRL_IDX.
      </description>
      <comment>
        EthIf_RxIndication
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01024_EthIf_RxIndication_InvalidCtrlIdx</srcid><srcstatus/><internalId>1279</internalId></linkedfrom><linkedfrom><srcid>EthIf_T140_DET_01_RxIndication_DetInvCtrlIdx</srcid><srcstatus/><internalId>1766</internalId></linkedfrom><linkedfrom><srcid>EthIf_T340_DET_01_RxIndication_DetInvCtrlIdx</srcid><srcstatus/><internalId>1788</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>413</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>451</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00088</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter DataPtr for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_PARAM_POINTER.
      </description>
      <comment>
        EthIf_RxIndication
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01025_EthIf_RxIndication_InvalidDataPtr</srcid><srcstatus/><internalId>1280</internalId></linkedfrom><linkedfrom><srcid>EthIf_T140_DET_02_RxIndication_DetInvParPtr</srcid><srcstatus/><internalId>1767</internalId></linkedfrom><linkedfrom><srcid>EthIf_T340_DET_02_RxIndication_DetInvParPtr</srcid><srcstatus/><internalId>1789</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>413</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>452</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00091</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_TxConfirmation 
        Syntax 
        void EthIf_TxConfirmation (uint8 CtrlIdx, Eth_BufIdxType BufIdx, Std_ReturnType Result)
        Service ID [hex] | 0x11 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | CtrlIdx | Index of the physical Ethernet controller within the context of the 
        Ethernet Interface 
        BufIdx | Index of the transmitted buffer 
        Result | E_OK: The transmission was successful, E_NOT_OK: The transmission failed.
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | Confirms frame transmission by the indexed controller 
        Available via | EthIf.h
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompileTest_01</srcid><srcstatus/><internalId>1237</internalId></linkedfrom><linkedfrom><srcid>EthIf_ComTest02</srcid><srcstatus/><internalId>1239</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00091.ServiceId</srcid><srcstatus/><internalId>127</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/EthIf.c.m4_2543</srcid><srcstatus/><internalId>1061</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>453</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00092</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service EthIf_Init 
        was previously called. If the check fails, the function shall raise the development error 
        ETHIF_E_UNINIT.
      </description>
      <comment>
        EthIf_TxConfirmation
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.DevelopmentErrors</srcid><srcstatus/><internalId>1003</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>454</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00093</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter CtrlIdx for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_INV_CTRL_IDX.
      </description>
      <comment>
        EthIf_Cbk_TxConfirmation
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01082_TxConfirmation_InvalidCtrlIdx</srcid><srcstatus/><internalId>1304</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest03001_TxConfirmation_InvalidCtrlIdx</srcid><srcstatus/><internalId>1382</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>413</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>455</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00094</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter BufIdx for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_INV_PARAM.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.EthIfMaxTxBufsTotal</srcid><srcstatus/><internalId>988</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>413</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>456</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00097</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_MainFunctionRx 
        Syntax 
        void EthIf_MainFunctionRx (void)
        Service ID [hex] | 0x20 
        Description | The function checks for new received frames and issues reception indications in 
        polling mode.
        Available via | SchM_EthIf.h
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ComTest02</srcid><srcstatus/><internalId>1239</internalId></linkedfrom><linkedfrom><srcid>EthIf_T490_00_MainFunctionRx_EthReceive</srcid><srcstatus/><internalId>1804</internalId></linkedfrom><linkedfrom><srcid>EthIf_T490_01_MainFunctionRx_TrcvLinkStateChg</srcid><srcstatus/><internalId>1805</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00097.ServiceId</srcid><srcstatus/><internalId>128</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>457</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00099</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The receive frame check shall be pre compile time configurable On/Off by the configuration 
        parameter: EthIfEnableRxInterrupt.
      </description>
      <comment>
        EthIf_MainFunctionRx
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.InterruptMode</srcid><srcstatus/><internalId>983</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>458</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00100</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The transmission confirmation check shall be pre compile time configurable On/Off by the 
        configuration parameter: EthIfEnableTxInterrupt.
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.InterruptMode</srcid><srcstatus/><internalId>983</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>459</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00101</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The frequency of polling the transceiver state change shall be configurable by the 
        configuration parameter: EthIfTrcvLinkStateChgMainReload.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.TrcvLinkStateChgPolling</srcid><srcstatus/><internalId>984</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>460</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00102</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        API Function | Header File | Description 
        There are no mandatory interfaces.
      </description>
      <comment>
        This requirement is informational only.
        Rationale:
        This is a list of APIs which are provided from other modules for EthIf. This requirement
        does not contain any information on how the APIs shall be used by EthIf.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>461</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00103</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        API Function | Header File | Description 
        BswM_EthIf_PortGroupLinkStateChg | BswM_EthIf.h | Function called by EthIf to indicate the link 
        state change of a certain Ethernet switch port group.
        Eth_GetControllerMode | Eth.h | Obtains the communication state of the indexed controller Tags:
        atp.Status=draft 
        GetControllerMode_obs | Eth.h | Obtains the state of the indexed controller Tags:atp.Status=
        obsolete 
        Eth_GetPhysAddr | Eth.h | Obtains the physical source address used by the indexed controller 
        Eth_ProvideTxBuffer | Eth.h | Provides access to a transmit buffer of the FIFO related to the 
        specified priority 
        Eth_ReadMii | Eth.h | Reads a transceiver register 
        Eth_Receive | Eth.h | Receive a frame from the related fifo.
        Eth_SetControllerMode | Eth.h | Enables / Disables Rx/Tx communication of the indexed 
        controller Tags:atp.Status=draft 
        SetControllerMode_obs | Eth.h | Enables / disables the indexed controller Tags:atp.Status=
        obsolete 
        Eth_Transmit | Eth.h | Triggers transmission of a previously filled transmit buffer 
        Eth_TxConfirmation | Eth.h | Triggers frame transmission confirmation 
        Eth_WriteMii | Eth.h | Configures a transceiver register or triggers a function offered by the 
        receiver 
        EthSM_CtrlModeIndication | EthSM.h | Called when mode has been read out. Either triggered by 
        previous EthIf_GetControllerMode or by EthIf_SetControllerMode call. Can directly be called 
        within the trigger functions.
        EthSM_SleepIndication | EthSM.h | This API is called by the EthIf and indicate that a sleep 
        indication was detected on the network. This API is only called if the ECU is acting as a 
        passive communication slave on the corresponding communication channel (the referenced EthTrcv 
        of the affected EthIfTransceiver has set EthTrcvActAsSlavePassiveEnabled to TRUE). This could 
        be used e.g. for Ethernet hardware which is compliant to the OA TC10. In this case the Ethernet 
        hardware detect an Sleep.Indication which was triggered by a Sleep.Request of the connected 
        link partner. Tags:atp.Status=draft 
        EthSM_TrcvLinkStateChg | EthSM.h | This service is called by the Ethernet Interface to report a 
        transceiver link state change.
        EthSwt_PortEnableTimeStamp | EthSwt.h | Activates egress time stamping on a dedicated message 
        object on a dedicated port of a Switch if EthSwtPortTimeStampSupport is set to TRUE for this 
        port. The selective activation of dedicated message objects for time stamping reduces the 
        number of notification calls only to the required calls. Some HW does store once the egress 
        time stamp marker and some HW needs it always before transmission. There will be no disabled 
        functionality, due to the fact, that the message type is always "time stamped" by network 
        design.
        EthSwt_SetMgmtInfo | EthSwt.h | Extends the Ethernet frame prepared previously by 
        EthSwt_EthTxPrepareFrame() with the management information to achieve transmission only on 
        specific ports.
        EthTrcv_GetBaudRate | EthTrcv.h | Obtains the baud rate of the indexed transceiver 
        EthTrcv_GetDuplexMode | EthTrcv.h | Obtains the duplex mode of the indexed transceiver 
        EthTrcv_GetLinkState | EthTrcv.h | Obtains the link state of the indexed transceiver 
        EthTrcv_GetTransceiverMode | EthTrcv.h | Obtains the state of the indexed transceiver 
        EthTrcv_SetTransceiverMode | EthTrcv.h | Enables / disables the indexed transceiver 
        EthTrcv_StartAutoNegotiation | EthTrcv.h | Restarts the negotiation of the transmission 
        parameters used by the indexed transceiver 
        IdsM_SetSecurityEvent | IdsM.h | This API is the application interface to report security 
        events to the IdsM.
        IdsM_SetSecurityEventWithContextData | IdsM.h | This API is the application interface to report 
        security events with context data to the IdsM.
        WEth_GetBufWRxParams | WEth.h | Read out values related to the receive direction for a received 
        packet. For example, this could be RSSI or Channel belonging to one single packet.This API is 
        valid only within the context of WEth_Receive 
        WEth_GetBufWTxParams | WEth.h | Read out values related to the transmit direction for a 
        transmitted packet. For example, this could be transaction ID belonging to one single packet.
        This API is valid only within the context of WEth_TxConfirmation.
        WEth_SetBufWTxParams | WEth.h | Set values related to the transmit direction for a specific 
        buffer (packet to be sent). For example, this can be the desired transmit power or the channel 
        belonging to one single packet.
        WEthTrcv_GetChanRxParams | WEthTrcv.h | Read values related to the receive direction of the 
        transceiver. For example, this could be a Channel Busy Ratio (CBR) or the average Channel Idle 
        Time (CIT)
        WEthTrcv_SetChanRxParams | WEthTrcv.h | Set values related to the receive direction of a 
        transceiver's wireless channel.For example, this could be a channel parameter like the 
        frequency.
        WEthTrcv_SetChanTxParams | WEthTrcv.h | Set values related to the transmit direction of a 
        transceiver's wireless channel. For example, this could be the bitrate of a channel.
        WEthTrcv_SetRadioParams | WEthTrcv.h | Set values related to a transceiver's wireless radio. 
        For example, this could be the selection of the radio settings (channel,
      </description>
      <comment>
        This requirement is informational only.
        Rationale:
        This is a list of APIs which are provided from other modules for EthIf. This requirement
        does not contain any information on how the APIs shall be used by EthIf.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest010072_CallDummyFunctions</srcid><srcstatus/><internalId>1295</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>462</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00104</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>3</version>
      <description>
        Service Name | &lt;User&gt;_RxIndication 
        Syntax 
        void &lt;User&gt;_RxIndication (uint8 CtrlIdx, Eth_FrameType FrameType, boolean IsBroadcast, const 
        uint8* PhysAddrPtr, const uint8* DataPtr, uint16 LenByte)
        Service ID [hex]
        Sync/Async 
        Reentrancy | Dont care 
        Parameters (in) | CtrlIdx | Index of the Ethernet controller within the context of the Ethernet 
        Interface 
        FrameType | frame type of received Ethernet frame 
        IsBroadcast | parameter to indicate a broadcast frame 
        PhysAddrPtr | pointer to Physical source address (MAC address in network byte order) of 
        received Ethernet frame 
        DataPtr | Pointer to payload of the received Ethernet frame (i.e. Ethernet header is not 
        provided)
        LenByte | Length of received data.
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | Indicates the reception of an Ethernet frame 
        Available via | configurable
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.EB.User_RxIndication.VLAN_MultipleUL</srcid><srcstatus/><internalId>189</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.User_RxIndication_MultipleUL</srcid><srcstatus/><internalId>191</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>463</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00105</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The callback function shall be configurable by the configuration parameter: 
        EthIfRxIndicationFunction.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.EB.User_RxIndication.VLAN_MultipleUL</srcid><srcstatus/><internalId>189</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.User_RxIndication_MultipleUL</srcid><srcstatus/><internalId>191</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>464</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00106</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | &lt;UL&gt;_TxConfirmation 
        Syntax 
        void &lt;UL&gt;_TxConfirmation (uint8 CtrlIdx, Eth_BufIdxType BufIdx, Std_ReturnType Result)
        Service ID [hex]
        Sync/Async 
        Reentrancy | Dont care 
        Parameters (in) | CtrlIdx | Index of the Ethernet controller within the context of the Ethernet 
        Interface 
        BufIdx | Index of the buffer resource 
        Result 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | Confirms the transmission of an Ethernet frame 
        Available via | configurable
      </description>
      <comment>
        UL shall only be informed if Result of EthIf_TxConfirmation() is E_OK.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.TxConfirmation_Result</srcid><srcstatus/><internalId>999</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>465</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00107</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The callback function shall be configurable by the configuration parameter: 
        EthIfTxConfirmationFunction.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.SWS_EthIf_00125</srcid><srcstatus/><internalId>478</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>466</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00108</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | &lt;User&gt;_TrcvLinkStateChg 
        Syntax 
        void &lt;User&gt;_TrcvLinkStateChg (uint8 CtrlIdx, EthTrcv_LinkStateType TrcvLinkState)
        Service ID [hex]
        Sync/Async 
        Reentrancy | Don’t care 
        Parameters (in) | CtrlIdx | Index of the Ethernet controller within the context of the Ethernet 
        Interface 
        TrcvLinkState | ETHTRCV_LINK_STATE_DOWN transceiver link is down ETHTRCV_LINK_STATE_ACTIVE 
        transceiver link is up 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | Indicates the change of a transceiver state 
        Available via | configurable
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange</srcid><srcstatus/><internalId>130</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange_MultipleUL</srcid><srcstatus/><internalId>131</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange.NoRef</srcid><srcstatus/><internalId>379</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>467</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00109</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The callback function shall be configurable by the configuration parameter: 
        EthIfTrcvLinkStateChgFunction.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange</srcid><srcstatus/><internalId>130</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange_MultipleUL</srcid><srcstatus/><internalId>131</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange.NoRef</srcid><srcstatus/><internalId>379</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>468</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00111</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        In order to access the Ethernet controller(s), the Ethernet Interface shall use one or multiple 
        Ethernet Driver modules, which abstract the specific features and interfaces of the respective 
        Ethernet controller(s)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_T160_00_GetPhysAddr_ValidParameters</srcid><srcstatus/><internalId>1781</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>469</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00112</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Therefore, the Ethernet Interface executable code (however, not the configuration used during 
        runtime) shall be completely independent of the Ethernet Communication Controller(s)
      </description>
      <comment>
        This requirement is informational only.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>470</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00113</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_MainFunctionTx 
        Syntax 
        void EthIf_MainFunctionTx (void)
        Service ID [hex] | 0x21 
        Description | The function issues transmission confirmations in polling mode. It checks also 
        for transceiver state changes.
        Available via | SchM_EthIf.h
      </description>
      <comment>
        EthIf_MainFunctionTx will not check transceiver state changes. They are checked in
         function EthIf_MainFunctionState.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompileTest_01</srcid><srcstatus/><internalId>1237</internalId></linkedfrom><linkedfrom><srcid>EthIf_ComTest02</srcid><srcstatus/><internalId>1239</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00113.ServiceId</srcid><srcstatus/><internalId>135</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>471</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00114</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function shall change the state of the component from uninitialized to initialized.
      </description>
      <comment>
        EthIf_Init
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest02019_MainFunction_Init_ACTIVE</srcid><srcstatus/><internalId>1903</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>472</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00115</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        In each call of EthIf_MainFunctionTx the component shall call Eth_TxConfirmation for
        all Ethernet Controller Drivers.
        Note: The Ethernet Interface expects that each Ethernet Controller Driver issues
        confirmations for all transmitted frames using the call-back function
        EthIf_TxConfirmation.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest11022_Transmit_NoVendor</srcid><srcstatus/><internalId>1721</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest11023_Transmit_NoVendor</srcid><srcstatus/><internalId>1722</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest02019_MainFunction_Init_ACTIVE</srcid><srcstatus/><internalId>1903</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>473</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00116</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter CfgPtr for 
        containing a valid configuration. If the check fails, the function shall raise the development 
        error ETHIF_E_INIT_FAILED.
      </description>
      <comment>
        EthIf_Init()
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01010_InvalidCfgPtr</srcid><srcstatus/><internalId>1266</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>413</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>474</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00117</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The MCG shall read the ECU configuration description of the Ethernet Driver and the Ethernet 
        Interface module(s). While cluster related configuration parameters are contained in the 
        Ethernet Interface module configuration description, Ethernet Driver related configuration data 
        is contained in the Ethernet Driver module configuration description. The Ethernet Interface 
        module specific configuration tool shall read both ECU module descriptions to derive the 
        configuration data for all Ethernet Drivers mapped to the Ethernet Interface module.
      </description>
      <comment>
        This requirement is informational only.
        Rationale:
        It only tells where the MCG can find lower layer configurations. Nothing that can be tested.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>475</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00118</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The MCG shall ensure the consistency of the generated configuration data.
      </description>
      <furtherinfo>
        WRN.swurs.needscoverage.count - Linking all relevant requirements to the single top-level
        requirement brings clear benefits and splitting them up would only increase complexity
        without any real benefit.
      </furtherinfo>
      <comment>
        Consistency is ensured by generator and XDM checks.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfOwner.ZeroBasedConsecutive</srcid><srcstatus/><internalId>1157</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfPhysControllerIdx.ZeroBased</srcid><srcstatus/><internalId>1158</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfPhysControllerIdx.Consecutive</srcid><srcstatus/><internalId>1159</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfPhysControllerRef.Valid</srcid><srcstatus/><internalId>1160</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfEthCtrlRef.Valid</srcid><srcstatus/><internalId>1161</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfEthTrcvRef.Valid</srcid><srcstatus/><internalId>1162</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfTransceiverIdx.ZeroBased</srcid><srcstatus/><internalId>1163</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfTransceiverIdx.Consecutive</srcid><srcstatus/><internalId>1164</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfCtrlIdx.ZeroBased</srcid><srcstatus/><internalId>1165</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfCtrlIdx.Consecutive</srcid><srcstatus/><internalId>1166</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfSwitchRef.Valid</srcid><srcstatus/><internalId>1167</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfSwitch.ZeroBased</srcid><srcstatus/><internalId>1168</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfSwitch.Consecutive</srcid><srcstatus/><internalId>1169</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfCtrlIdx.NoVlanGroupedFirst</srcid><srcstatus/><internalId>1170</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfMaxCtrl</srcid><srcstatus/><internalId>1171</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfVirtualCtrlSupportEnable</srcid><srcstatus/><internalId>1172</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfVlanId.MultipleControllersNotConfigured</srcid><srcstatus/><internalId>1173</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfController.SameEthController.DiffEthTrcv</srcid><srcstatus/><internalId>1174</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthTrcv.MultipleEthControllers</srcid><srcstatus/><internalId>1175</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfVlanId.Unique</srcid><srcstatus/><internalId>1176</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfOwner.Range</srcid><srcstatus/><internalId>1177</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfMaxPhyCtrl</srcid><srcstatus/><internalId>1178</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthCtrl.NotReferenced</srcid><srcstatus/><internalId>1179</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfTransciever.BothReferencesDisabled</srcid><srcstatus/><internalId>1180</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfTransciever.NotReferenced</srcid><srcstatus/><internalId>1181</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthCtrlEnableRxInterrupt.Enabled</srcid><srcstatus/><internalId>1182</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthCtrlEnableTxInterrupt.Enabled</srcid><srcstatus/><internalId>1183</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfMainFunctionPeriod.Range</srcid><srcstatus/><internalId>1184</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfRxIndicationIterations.Range</srcid><srcstatus/><internalId>1185</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfPhysCtrlRxMainFuncPrioProces.EthIfEthCtrlRef.Invalid</srcid><srcstatus/><internalId>1186</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfPhysCtrlRxMainFuncPrioProces.FifoAlreadyMapped</srcid><srcstatus/><internalId>1187</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfPhysCtrlRxIndicationIterations.Range</srcid><srcstatus/><internalId>1188</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfPhysCtrlRxMainFunctionPeriod.Range</srcid><srcstatus/><internalId>1189</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfMaxSwtPorts</srcid><srcstatus/><internalId>1190</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfSwitchPortGroupIdx.ZeroBased</srcid><srcstatus/><internalId>1191</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfSwitchPortGroupIdx.Consecutive</srcid><srcstatus/><internalId>1192</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfSwitchIdx.ZeroBased</srcid><srcstatus/><internalId>1193</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfSwitchIdx.Consecutive</srcid><srcstatus/><internalId>1194</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfMaxSwtPortGroups</srcid><srcstatus/><internalId>1195</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.Trcv.PortGroup.InvalidReference</srcid><srcstatus/><internalId>1196</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfSwitchRefOrPortGroupRef.InvalidReference</srcid><srcstatus/><internalId>1197</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.PortGroupRefByIfCtrl.PortSemanticsNotSet</srcid><srcstatus/><internalId>1198</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.PortsInPortGroup.Unique</srcid><srcstatus/><internalId>1199</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfSwitchingPortGroupSupport</srcid><srcstatus/><internalId>1200</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfSwitchPortGroup.EthIfPortRef.Invalid</srcid><srcstatus/><internalId>1201</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfSwitchPortGroup.EthIfPortRef.SwitchUndefined</srcid><srcstatus/><internalId>1202</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfSupportEthAPI.EthCompatible</srcid><srcstatus/><internalId>1203</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfSwitch.GetBufferLevelApiSupport</srcid><srcstatus/><internalId>1204</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfSwitch.GetArlTableApiSupport</srcid><srcstatus/><internalId>1205</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfSwitch.GetCounterValuesApiSupport</srcid><srcstatus/><internalId>1206</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfSwitch.StoreConfigurationApiSupport</srcid><srcstatus/><internalId>1207</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfSwitch.ResetConfigurationApiSupport</srcid><srcstatus/><internalId>1208</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.SetModeTimeout.NotMultipleValue</srcid><srcstatus/><internalId>1209</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.SetModeTimeout.MaxValue</srcid><srcstatus/><internalId>1210</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfAsyncEthTrcvModeSupport</srcid><srcstatus/><internalId>1211</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfEthControllerBswmdImplementationRefs.Valid</srcid><srcstatus/><internalId>1212</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfEthControllerBswmdImplementationRefs.Unique</srcid><srcstatus/><internalId>1213</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfEthControllerBswmdImplementationRefs.WrongASRVers</srcid><srcstatus/><internalId>1214</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfEthControllerBswmdImplementationRefs.InitCtrlTrcvSet</srcid><srcstatus/><internalId>1215</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfEthTrcvBswmdImplementationRefs.Valid</srcid><srcstatus/><internalId>1216</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfEthTrcvBswmdImplementationRefs.Unique</srcid><srcstatus/><internalId>1217</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfEthTrcvBswmdImplementationRefs.WrongASRVers</srcid><srcstatus/><internalId>1218</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfEthTrcvBswmdImplementationRefs.InitCtrlTrcvSet</srcid><srcstatus/><internalId>1219</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfEthSwtBswmdImplementationRefs.Valid</srcid><srcstatus/><internalId>1220</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfEthSwtBswmdImplementationRefs.WrongASRVers</srcid><srcstatus/><internalId>1221</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfFrameOwnerConfig.EthIfRxIndicationConfig.NumberOfElementsMatch</srcid><srcstatus/><internalId>1222</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>476</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00123</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        In order to access the Ethernet transceiver(s), the Ethernet Interface shall use one or 
        multiple Ethernet Transceiver Driver modules, which abstract the specific features and 
        interfaces of the respective Ethernet transceiver(s)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest04057_SetPhyLoopbackMode_Forward_Call</srcid><srcstatus/><internalId>1430</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>477</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00125</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        EthIf_ TxConfirmation shall forward the confirmation to the registered call-back
        Name:         EthIf_T ransm i ssi onInterrupt
        Package:      EthIf
        Ve rsi o n :  1.0
        Author:       fi x0 e c2
        UL                                                               «module»
        module»
        EthIf                                                       :Eth
        Provi deT xBuffer(BufReq_ReturnT ype,
        uint8, Eth_FrameType, uint8,
        Eth_BufIdxType**, uint8***, uint16**)                                              Eth_Provi 
        deT xBuffer(BufReq_ReturnT ype,
        uint8, uint8, Eth_BufIdxType**, uint8*
        uint16*
        Eth_T xIrqHdl r_&lt;Ctrl Idx&gt;(voi d)
        EthIf_T xConfi rm ati on(ui nt8,
        Eth_BufIdxType, Std_ReturnType)
        UL_T xConfi rm ati on(Ctrl Idx,
        BufIdx)
        Figure 8: Frame Transmission                               in         Interrupt         Mode
      </description>
      <comment>
        - EthIf_TxConfirmation() shall pass the parameter BufIdx to User_TxConfirmation().
        - EthIf_TxConfirmation() shall translate CtrlIdx (EthCtrlIdx) to EthIfCtrlIdx.

        For all EthIfCtrlIdx linked to the EthCtrlIdx all configured User_TxConfirmation() shall
        be called. The upper layer shall filter based on the BufIdx.

        Rationale:
        EthIf does not have the relation ship between BufIdx of EthIf_TxConfirmation() and
        FrameType of EthIf_Transmit(). The approach of storing the last transmitted FrameType and
        BufIdx to be used for the confirmation does not work since multiple frames can be
        transmitted before one is confirmed.
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest03006_User_TxConfirmation</srcid><srcstatus/><internalId>1387</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR42.SWS_EthIf_00106</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>16</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00107</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>466</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>478</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00127</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter 
        VersionInfoPtr for being valid. If the check fails, the function shall raise the development 
        error ETHIF_E_PARAM_POINTER.
      </description>
      <comment>
        EthIf_GetVersionInfo
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01074_EthIf_GetVersionInfo_ParamPtr</srcid><srcstatus/><internalId>1296</internalId></linkedfrom><linkedfrom><srcid>EthIf_T100_DET_00_GetVersionInfo_DetInvPointer</srcid><srcstatus/><internalId>1749</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>413</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>479</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00025</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfController
        Container Type: Sub-Container
        Parent Containers: EthIfConfigSet,
        Description: This container contains the configuration of EthIfController.
        Lower Multiplicity: 1
        infinite
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>480</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00026</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfCtrlIdx
        Parameter Type: Integer
        Parent Containers: EthIfController,
        Description: This parameter provides a zero-based consecutive index of the Ethernet 
        Communication Controllers. Upper layer BSW modules and the EthIf itself use this index to 
        identify a Ethernet CC.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: true
        Max-Value: 255 (Type:
        Min-Value: 0 (Type:
      </description>
      <comment>
        Add xdm check that index is 0-based and consecutive
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.PostBuild.EthIfCtrlIdx</srcid><srcstatus/><internalId>1002</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/EthIf_Extension.xdm.m4_42</srcid><srcstatus/><internalId>1094</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>481</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00027</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfPhysControllerRef
        Parameter Type: Reference
        Parent Containers: EthIfController,
        Description: Reference to a physical Ethernet controller, which is handled by the Ethernet 
        Interface.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Destination: /AUTOSAR/EcucDefs/EthIf/EthIfConfigSet/EthIfPhysController
        Destination type: ECUC-PARAM-CONF-CONTAINER-DEF
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>482</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00028</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfEthTrcvRef
        Parameter Type: Reference
        Parent Containers: EthIfController,
        Description: Reference to an Ethernet transceiver, which is handled by the Ethernet Interface.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: true
        Post-Build-Variant-Value: true
        Multiplicity-Configuration Class: LINK, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Destination: /AUTOSAR/EcucDefs/EthIf/EthIfConfigSet/EthIfTransceiver
        Destination type: ECUC-PARAM-CONF-CONTAINER-DEF
      </description>
      <comment>
        Test with different references to various transceiver
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest05007_MainFunctionRxPrio_ETH_RECEIVED</srcid><srcstatus/><internalId>1438</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>483</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00029</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfVlanId
        Parameter Type: Integer
        Parent Containers: EthIfController,
        Description: A virtual-LAN is identified by this attribute according to IEEE 802.1Q.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: true
        Post-Build-Variant-Value: true
        Multiplicity-Configuration Class: LINK, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: 4095 (Type:
        Min-Value: 0 (Type:
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>484</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00030</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfRxIndicationIterations
        Parameter Type: Integer
        Parent Containers: EthIfGeneral,
        Description: Maximum number of Ethernet frames per Ethernet controller polled from the Ethernet 
        driver within EthIf_MainFunctionRx.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: 65535 (Type:
        Min-Value: 0 (Type:
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>485</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00032</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfCtrlMtu
        Parameter Type: Integer
        Parent Containers: EthIfController,
        Description: Specifies the maximum transmission unit (MTU) of the EthIfCtrl in [bytes]
        Introduction: Note: In case a VLAN tag is used for the EthIfCtrl, the frame length of the 
        Ethernet frame will increase by 4 bytes.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: 9000 (Type:
        Min-Value: 64 (Type:
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>486</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00033</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfStartAutoNegotiation
        Parameter Type: Boolean
        Parent Containers: EthIfGeneral,
        Description: Enables / Disables StartAutoNegotiation API.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.OptAPIs</srcid><srcstatus/><internalId>989</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>487</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00034</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfGetBaudRate
        Parameter Type: Boolean
        Parent Containers: EthIfGeneral,
        Description: Enables / Disables GetBaudRate API.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.OptAPIs</srcid><srcstatus/><internalId>989</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>488</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00035</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfGetCounterState
        Parameter Type: Boolean
        Parent Containers: EthIfGeneral,
        Description: Enables / Disables GetCounterState API.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.OptAPIs</srcid><srcstatus/><internalId>989</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>489</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00128</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The Ethernet Interface shall support Virtual Local Area Networks (VLAN)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.ASR43.ECUC_EthIf_00029_2</srcid><srcstatus/><internalId>94</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.VLAN_Support</srcid><srcstatus/><internalId>164</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.VLAN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1114</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>490</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00129</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The Ethernet Interface shall encapsulate Virtual Local Area Networks (VLAN) into virtual 
        controllers (Ethernet Interface controller) representing a dedicated VLAN. All BSW modules 
        above the Ethernet Interface shall interact based on those virtual controllers. The Ethernet 
        Driver and Transceiver deal only with real controllers and are not aware of the existence of 
        virtual controllers. Caveat: the virtual controller represents the untagged VLAN if no VLAN ID 
        is set.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.SWS_EthIf_00263</srcid><srcstatus/><internalId>616</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.VLAN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1114</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>491</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00130</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The Ethernet Interface shall use the buffers provided by the Ethernet Driver for VLAN support.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.SWS_EthIf_00067</srcid><srcstatus/><internalId>437</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.VLAN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1114</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>492</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00132</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_SetPhysAddr 
        Syntax 
        void EthIf_SetPhysAddr (uint8 CtrlIdx, const uint8* PhysAddrPtr)
        Service ID [hex] | 0x0d 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant for the same CtrlIdx, reentrant for different 
        Parameters (in) | CtrlIdx | Index of the Ethernet controller within the context of the Ethernet 
        Driver.
        PhysAddrPtr | Pointer to memory containing the physical source address (MAC address) in network 
        byte order.
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | Sets the physical source address used by the indexed controller.
        Available via | EthIf.h
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompileTest_01</srcid><srcstatus/><internalId>1237</internalId></linkedfrom><linkedfrom><srcid>EthIf_ComTest02</srcid><srcstatus/><internalId>1239</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00132.ServiceId</srcid><srcstatus/><internalId>101</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>493</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00134</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_SetPhysAddr shall forward the call to the respective Ethernet Controller 
        Driver.
      </description>
      <comment>
        Arguments of Eth_SetPhysAddr():
        - CtrlIdx: EthIfCtrlIdx of EthIf_SetPhysAddr() is translated to EthCtrlIdx.
        - PhysAddrPtr: just passed on
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest02001_SetPhysAddr</srcid><srcstatus/><internalId>1894</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>408</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>494</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00135</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service EthIf_Init 
        was previously called. If the check fails, the function shall raise the development error 
        ETHIF_E_UNINIT.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.DevelopmentErrors</srcid><srcstatus/><internalId>1003</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>495</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00136</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter CtrlIdx for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_INV_CTRL_IDX.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01011_SetPhysAddr_InvalidCtrlIdx</srcid><srcstatus/><internalId>1267</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>413</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>496</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00137</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter PhysAddrPtr 
        for being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_PARAM_POINTER.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01016_SetPhysAddr_InvalidPhysAddrPtr</srcid><srcstatus/><internalId>1275</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>413</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>497</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00139</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_UpdatePhysAddrFilter 
        Syntax 
        Std_ReturnType EthIf_UpdatePhysAddrFilter (uint8 CtrlIdx, const uint8* PhysAddrPtr, 
        Eth_FilterActionType Action)
        Service ID [hex] | 0x0c 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant for the same CtrlIdx, reentrant for different 
        Parameters (in) | CtrlIdx | Index of the Ethernet controller within the context of the Ethernet 
        Driver.
        PhysAddrPtr | Pointer to memory containing the physical destination address (MAC address) in 
        network byte order. This is the multicast destination address of the layer 2 Ethernet packet.
        Action | Add or remove the address from the Ethernet controllers filter.
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | Std_ReturnType | E_OK: filter was successfully changedE_NOT_OK: filter could not 
        be changed 
        Description | Update the physical source address to/from the indexed controller filter. If the 
        Ethernet Controller is not capable to do the filtering, the software has to do this.
        Available via | EthIf.h
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompileTest_01</srcid><srcstatus/><internalId>1237</internalId></linkedfrom><linkedfrom><srcid>EthIf_ComTest02</srcid><srcstatus/><internalId>1239</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00139.ServiceId</srcid><srcstatus/><internalId>102</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>498</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00140</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_SetPhysAddrFilter shall forward the call to the respective Ethernet 
        Controller Driver.
      </description>
      <comment>
        Assuming it's meant to be 'EthIf_UpdatePhysAddrFilter() shall call
        Eth_UpdatePhysAddrFilter()'.
        Arguments of Eth_UpdatePhysAddrFilter():
        - CtrlIdx: EthIfCtrlIdx of EthIf_UpdatePhysAddrFilter() is translated to EthCtrlIdx.
        - PhysAddrPtr: just passed on
        - Action: just passed on
        - return value: just passed on
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest02002_UpdatePhysAddrFilter</srcid><srcstatus/><internalId>1895</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>408</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>499</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00141</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service EthIf_Init 
        was previously called. If the check fails, the function shall raise the development error 
        ETHIF_E_UNINIT.
      </description>
      <comment>
        EthIf_UpdatePhysAddrFilter
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.DevelopmentErrors</srcid><srcstatus/><internalId>1003</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>500</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00142</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter CtrlIdx for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_INV_CTRL_IDX.
      </description>
      <comment>
        EthIf_UpdatePhysAddrFilter
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01014_UpdatePhysAddrFilter_InvalidCtrlIdx</srcid><srcstatus/><internalId>1273</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>413</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>501</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00143</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter PhysAddrPtr 
        for being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_PARAM_POINTER.
      </description>
      <comment>
        EthIf_UpdatePhysAddrFilter
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01015_UpdatePhysAddrFilter_InvPhysAddrPtr</srcid><srcstatus/><internalId>1274</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>413</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>502</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00145</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If the VLAN is not active the Ethernet Interface shall increment the corresponding measurement 
        data and filter the message
      </description>
      <comment>
        This seems to mean:
        filtering out any messages containing VLAN tags if VLAN is not active.
        The parameter FrameType would be used to identify VLAN tagged messages.

        see http://www.autosar.org/bugzilla/show_bug.cgi?id=58492#c8
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_T500_RxIndication_VLAN_Forwarding</srcid><srcstatus/><internalId>1810</internalId></linkedfrom><linkedfrom><srcid>EthIf_T500_RxIndication_NoVLAN_Forwarding</srcid><srcstatus/><internalId>1811</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>503</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00146</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If CtrlIdx refers to an EthIfCtrl where no EthIfVlanID is configured, the parameters FrameType 
        and Priority are not used.
      </description>
      <comment>
        EthIf_ProvideTxBuffer
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_T150_00_ProvideTxBuffer_ValidParameters</srcid><srcstatus/><internalId>1776</internalId></linkedfrom><linkedfrom><srcid>EthIf_T150_01_ProvideTxBuffer_ValidParameters</srcid><srcstatus/><internalId>1777</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>504</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00147</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If VLAN is used
        EthIf shall increment the input desired length by 4 bytes before calling the Ethernet Driver 
        module
        EthIf shall store the PCP (Priority parameter), CFI (always 0), VID (configured VLAN ID) and 
        value of the FrameType parameter at the beginning of the buffer received from 
        Eth_ProvideTxBuffer)
        EthIf shall increment the BufPtr by 4 bytes when returning the granted buffer
        EthIf shall decrement the output granted length by 4 bytes
      </description>
      <comment>
        EthIf_ProvideTxBuffer:
      If VLAN is used the first 4 bytes should look like:
      3 bit PCP (from argument Priority of EthIf_ProvideTxBuffer)
      1 bit CFI (always 0)
      12 bit VLAN ID (from configuration)
      16 bit FrameType (from argument of EthIf_ProvideTxBuffer)
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_T350_00_ProvideTxBuffer_VLanControllers</srcid><srcstatus/><internalId>1801</internalId></linkedfrom><linkedfrom><srcid>EthIf_T350_01_ProvideTxBuffer_VLanControllers</srcid><srcstatus/><internalId>1802</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>505</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00149</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name | EthIf_ConfigType 
        Kind | Structure 
        Description | Implementation specific structure of the post build configuration 
        Available via | EthIf.h
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate_macros/EthIf_PreCompileConfig.m_21</srcid><srcstatus/><internalId>1109</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>506</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00150</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name | EthIf_StateType 
        Kind | Enumeration 
        Range | ETHCTRL_STATE_UNINIT | 0x00 | Ethernet Interface is not yet configured 
        ETHCTRL_STATE_INIT | 0x01 | Ethernet Interface is configured 
        Description | Status supervision used for Development Error Detection. The state shall be 
        available for debugging.
        Available via | EthIf.h
      </description>
      <comment>
        This requirement is not applicable.
          Rationale:
          EthIf_StateType is not used and it is removed from AUTOSAR SWS 4.3.1.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>507</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00151</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The Ethernet Driver shall indicate broadcast message with the parameter 'IsBroadcast' to the 
        Ethernet Interface.
      </description>
      <comment>
        This requirement is informational only.
        Rationale:
        This is a requirement for the Ethernet Driver.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>508</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00036</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfSwitch
        Container Type: Sub-Container
        Parent Containers: EthIfConfigSet,
        Description: This container contains the configuration of EthIfSwitches.
        Lower Multiplicity: 0
        infinite
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>509</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00037</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfSwitchIdx
        Parameter Type: Integer
        Parent Containers: EthIfSwitch,
        Description: This parameter provides a zero-based consecutive index of the Ethernet Interface 
        Switches. Upper layer BSW modules and the EthIf itself use this index to identify a Ethernet 
        Switch.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: true
        Max-Value: 255 (Type:
        Min-Value: 0 (Type:
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.PostBuildSelectable</srcid><srcstatus/><internalId>1001</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>510</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00038</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfSwitchRef
        Parameter Type: Reference
        Parent Containers: EthIfSwitch,
        Description: Reference to a Ethernet Switch, which is handled by a specific Ethernet Switch 
        driver.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Destination: /AUTOSAR/EcucDefs/EthSwt/EthSwtConfig
        Destination type: ECUC-PARAM-CONF-CONTAINER-DEF
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>511</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00039</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfGlobalTimeSupport
        Parameter Type: Boolean
        Parent Containers: EthIfGeneral,
        Description: Enables/Disables the Global Time APIs used amongst others by Global Time 
        Synchronization over Ethernet.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>512</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00040</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfWakeUpSupport
        Parameter Type: Boolean
        Parent Containers: EthIfGeneral,
        Description: Configures if wake-up handling is supported or not:
        Introduction: TRUE: wake-up handling is supported FALSE: wake-up handling is not supported This 
        configuration parameter also enables particular other the API at Pre-Compile-Time, e.g. 
        EthIf_CheckWakeup.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>513</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00041</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfGetTransceiverWakeupModeApi
        Parameter Type: Boolean
        Parent Containers: EthIfGeneral,
        Description: Enables / Disables EthIf_GetTransceiverWakeupMode API Tags: atp.Status=obsolete
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: false
        Post-Build-Variant-Value: false
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>514</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00154</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_GetCurrentTime 
        Syntax 
        Std_ReturnType EthIf_GetCurrentTime (uint8 CtrlIdx, Eth_TimeStampQualType* timeQualPtr, 
        Eth_TimeStampType* timeStampPtr)
        Service ID [hex] | 0x22 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | CtrlIdx | Index of the addresses ETH controller.
        Parameters (inout) | None 
        Parameters (out) | timeQualPtr | quality of HW time stamp, e.g. based on current drift 
        timeStampPtr | current time stamp 
        Return value | Std_ReturnType | E_OK: successfulE_NOT_OK: failed 
        Description | Returns a time value out of the HW registers according to the capability of the 
        HW. Is the HW resolution is lower than the Eth_TimeStampType resolution resp. range, the 
        remaining bits will be filled with 0. Important Note: EthIf_GetCurrentTime may be called within 
        an exclusive area.
        Available via | EthIf.h
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ComTest02</srcid><srcstatus/><internalId>1239</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00154.ServiceId</srcid><srcstatus/><internalId>108</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00154.GetCurrentTime.ForwardCall</srcid><srcstatus/><internalId>109</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.GlobalTime</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1116</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>515</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00155</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service EthIf_Init 
        was previously called. If the check fails, the function shall raise the development error 
        ETHIF_E_UNINIT.
      </description>
      <comment>
        EthIf_GetCurrentTime()
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.DevelopmentErrors</srcid><srcstatus/><internalId>1003</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>516</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00156</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter CtrlIdx for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_INV_CTRL_IDX.
      </description>
      <comment>
        EthIf_GetCurrentTime()
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01026_EthIf_GetCurrentTime_Invalid_Param</srcid><srcstatus/><internalId>1281</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.GlobalTime</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1116</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>517</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00157</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter timeQualPtr 
        and timeStampPtr for being valid. If the check fails, the function shall raise the development 
        error ETHIF_E_PARAM_POINTER.
      </description>
      <comment>
        EthIf_GetCurrentTime()
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01026_EthIf_GetCurrentTime_Invalid_Param</srcid><srcstatus/><internalId>1281</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.GlobalTime</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1116</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>518</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00158</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function shall be pre compile time configurable On/Off by the configuration parameter: 
        EthIfGlobalTimeSupport.
      </description>
      <comment>
        EthIf_GetCurrentTime()
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompileTest_01</srcid><srcstatus/><internalId>1237</internalId></linkedfrom><linkedfrom><srcid>EthIf_ComTest02</srcid><srcstatus/><internalId>1239</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.GlobalTime</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1116</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>519</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00160</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_EnableEgressTimeStamp 
        Syntax 
        void EthIf_EnableEgressTimeStamp (uint8 CtrlIdx, Eth_BufIdxType BufIdx)
        Service ID [hex] | 0x23 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | CtrlIdx | Index of the addresses ETH controller.
        BufIdx | Index of the message buffer, where Application expects egress time stamping 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | Activates egress time stamping on a dedicated message object. Some HW does store 
        once the egress time stamp marker and some HW needs it always before transmission. There will 
        be no "disable" functionality, due to the fact, that the message type is always "time stamped" 
        by network design.
        Available via | EthIf.h
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ComTest02</srcid><srcstatus/><internalId>1239</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00160.ServiceId</srcid><srcstatus/><internalId>110</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00160.EnableEgressTimeStamp.ForwardCall</srcid><srcstatus/><internalId>111</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.GlobalTime</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1116</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>520</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00161</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service EthIf_Init 
        was previously called. If the check fails, the function shall raise the development error 
        ETHIF_E_UNINIT.
      </description>
      <comment>
        EthIf_EnableEgressTimeStamp()
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.DevelopmentErrors</srcid><srcstatus/><internalId>1003</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>521</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00162</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter CtrlIdx for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_INV_CTRL_IDX.
      </description>
      <comment>
        EthIf_EnableEgressTimeStamp()
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01027_EthIf_EnableEgressTimeStamp_Inv_Param</srcid><srcstatus/><internalId>1282</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.GlobalTime</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1116</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>522</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00164</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function shall be pre compile time configurable On/Off by the configuration parameter: 
        EthIfGlobalTimeSupport.
      </description>
      <comment>
        EthIf_EnableEgressTimeStamp()
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompileTest_01</srcid><srcstatus/><internalId>1237</internalId></linkedfrom><linkedfrom><srcid>EthIf_ComTest02</srcid><srcstatus/><internalId>1239</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.GlobalTime</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1116</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>523</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00166</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_GetEgressTimeStamp 
        Syntax 
        Std_ReturnType EthIf_GetEgressTimeStamp (uint8 CtrlIdx, Eth_BufIdxType BufIdx, 
        Eth_TimeStampQualType* timeQualPtr, Eth_TimeStampType* timeStampPtr)
        Service ID [hex] | 0x24 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | CtrlIdx | Index of the address ETH controller.
        BufIdx | Index of the message buffer, where the Upper Layer expects egress time stamping 
        Parameters (inout) | None 
        Parameters (out) | timeQualPtr | quality of HW time stamp, e.g. based on current drift 
        timeStampPtr | current time stamp 
        Return value | Std_ReturnType | E_OK: successE_NOT_OK: failed to read time stamp.
        Description | Reads back the egress time stamp on a dedicated message object. It must be called 
        within the TxConfirmation() function.
        Available via | EthIf.h
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ComTest02</srcid><srcstatus/><internalId>1239</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00166.ServiceId</srcid><srcstatus/><internalId>112</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00166.GetEgressTimeStamp.ForwardCall</srcid><srcstatus/><internalId>113</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.GlobalTime</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1116</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>524</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00167</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service EthIf_Init 
        was previously called. If the check fails, the function shall raise the development error 
        ETHIF_E_UNINIT.
      </description>
      <comment>
        EthIf_GetEgressTimeStamp()
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.DevelopmentErrors</srcid><srcstatus/><internalId>1003</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>525</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00168</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter CtrlIdx for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_INV_CTRL_IDX.
      </description>
      <comment>
        EthIf_GetEgressTimeStamp()
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01028_EthIf_GetEgressTimeStamp_Invalid_Param</srcid><srcstatus/><internalId>1283</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.GlobalTime</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1116</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>526</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00169</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter timeQualPtr 
        and timeStampPtr for being valid. If the check fails, the function shall raise the development 
        error ETHIF_E_PARAM_POINTER.
      </description>
      <comment>
        EthIf_GetEgressTimeStamp()
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01028_EthIf_GetEgressTimeStamp_Invalid_Param</srcid><srcstatus/><internalId>1283</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.GlobalTime</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1116</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>527</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00170</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function shall be pre compile time configurable On/Off by the configuration parameter: 
        EthIfGlobalTimeSupport.
      </description>
      <comment>
        EthIf_GetEgressTimeStamp()
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompileTest_01</srcid><srcstatus/><internalId>1237</internalId></linkedfrom><linkedfrom><srcid>EthIf_ComTest02</srcid><srcstatus/><internalId>1239</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.GlobalTime</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1116</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>528</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00172</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>2</version>
      <description>
        Service Name | EthIf_GetIngressTimeStamp 
        Syntax 
        Std_ReturnType EthIf_GetIngressTimeStamp (uint8 CtrlIdx, const Eth_DataType* DataPtr, 
        Eth_TimeStampQualType* timeQualPtr, Eth_TimeStampType* timeStampPtr)
        Service ID [hex] | 0x25 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | CtrlIdx | Index of the addresses ETH controller.
        DataPtr | Pointer to the message buffer, where Application expects ingress time stamping 
        Parameters (inout) | None 
        Parameters (out) | timeQualPtr | quality of HW time stamp, e.g. based on current drift 
        timeStampPtr | current time stamp 
        Return value | Std_ReturnType | E_OK: successE_NOT_OK: failed to read time stamp.
        Description | Reads back the ingress time stamp on a dedicated message object. It must be 
        called within the RxIndication() function.
        Available via | EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ComTest02</srcid><srcstatus/><internalId>1239</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00172.ServiceId</srcid><srcstatus/><internalId>114</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00172.GetIngressTimeStamp.ForwardCall</srcid><srcstatus/><internalId>115</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.GlobalTime</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1116</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>529</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00173</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service EthIf_Init 
        was previously called. If the check fails, the function shall raise the development error 
        ETHIF_E_UNINIT.
      </description>
      <comment>
        EthIf_GetIngressTimeStamp()
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.DevelopmentErrors</srcid><srcstatus/><internalId>1003</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>530</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00174</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter CtrlIdx for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_INV_CTRL_IDX.
      </description>
      <comment>
        EthIf_GetIngressTimeStamp()
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01029_EthIf_GetIngressTimeStamp_Inv_Param</srcid><srcstatus/><internalId>1284</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.GlobalTime</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1116</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>531</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00175</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter DataPtr, 
        timeQualPtr and timeStampPtr for being valid. If the check fails, the function shall raise the 
        development error ETHIF_E_PARAM_POINTER.
      </description>
      <comment>
        EthIf_GetIngressTimeStamp()
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01029_EthIf_GetIngressTimeStamp_Inv_Param</srcid><srcstatus/><internalId>1284</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.GlobalTime</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1116</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>532</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00176</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function shall be pre compile time configurable On/Off by the configuration parameter: 
        EthIfGlobalTimeSupport.
      </description>
      <comment>
        EthIf_GetIngressTimeStamp()
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompileTest_01</srcid><srcstatus/><internalId>1237</internalId></linkedfrom><linkedfrom><srcid>EthIf_ComTest02</srcid><srcstatus/><internalId>1239</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.GlobalTime</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1116</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>533</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00190</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_GetPortMacAddr 
        Syntax 
        Std_ReturnType EthIf_GetPortMacAddr (const uint8* MacAddrPtr, uint8* SwitchIdxPtr, uint8* 
        PortIdxPtr)
        Service ID [hex] | 0x28 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | MacAddrPtr | MAC-address for which a switch port is searched over which the 
        node with this MAC-address can be reached.
        Parameters (inout) | None 
        Parameters (out) | SwitchIdxPtr | Pointer to the switch index 
        PortIdxPtr | Pointer to the port index 
        Return value | Std_ReturnType | E_OK: successE_NOT_OK: an error occurred, e.g. multiple ports 
        were found 
        Description | Obtains the port over which this MAC-address can be reached 
        Available via | EthIf.h
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ComTest_06_Swt_support</srcid><srcstatus/><internalId>1243</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest05_SwtSupport_GetPortMacAddr</srcid><srcstatus/><internalId>1461</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00190.ServiceId</srcid><srcstatus/><internalId>103</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>534</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00191</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_GetPortMacAddr shall return the switch and port index over which the given 
        MAC-address is reachable. If multiple or no ports are possible, this API call will return 
        E_NOT_OK. EthSwt_GetPortMacAddr will be called for all Ethernet Switch drivers.
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.GetPortMacAddr</srcid><srcstatus/><internalId>993</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>535</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00192</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function shall be pre compile time configurable On/Off by the configuration parameter: 
        EthIfGetPortMacAddrApi.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ComTest_06_Swt_support</srcid><srcstatus/><internalId>1243</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>536</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00193</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service EthIf_Init 
        was previously called. If the check fails, the function shall raise the development error 
        ETHIF_E_UNINIT.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.DevelopmentErrors</srcid><srcstatus/><internalId>1003</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>537</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00194</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter MacAddrPtr, 
        SwitchIdxPtr and PortIdxPtr for being valid. If the check fails, the function shall raise the 
        development error ETHIF_E_PARAM_POINTER.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest05_SwtSupport_GetPortMacAddr_InvPointer</srcid><srcstatus/><internalId>1451</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>538</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00196</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_GetArlTable 
        Syntax 
        Std_ReturnType EthIf_GetArlTable (uint8 switchIdx, uint16* numberOfElements, Eth_MacVlanType* 
        arlTableListPointer)
        Service ID [hex] | 0x29 
        Sync/Async | Synchronous /Asynchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | switchIdx | Index of the switch within the context of the Ethernet Switch 
        Driver 
        Parameters (inout) | numberOfElements | In: Maximum number of elements which can be written 
        into the arlTable Out: Number of elements which are currently available in the EthSwitch module.
        Parameters (out) | arlTableListPointer | Returns a pointer to the memory where the ARL table of 
        the switch consisting of a list of structs with MAC-address, VLAN-ID and port shall be stored.
        Return value | Std_ReturnType | E_OK: successE_NOT_OK: requested switchIdx is not valid or 
        inactive 
        Description | Obtains the address resolution table of a switch and copies the list into a user 
        provided buffer. The function will copy all or numberOfElements into the output list. If input 
        value of numberOfElements is 0 the function will not copy any data but only return the number 
        of valid entries in the cache. arlTableListPointer may be NULL_PTR in this case.
        Available via | EthIf.h
      </description>
      <comment>
        RFC link https://www.autosar.org/bugzilla/show_bug.cgi?id=71988
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ComTest_06_Swt_support</srcid><srcstatus/><internalId>1243</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00196.ServiceId</srcid><srcstatus/><internalId>104</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>539</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00197</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_GetArlTable shall return a list of structs with MAC-address, VLAN-ID and 
        port for the indexed switch.
      </description>
      <comment>
        RFC link https://www.autosar.org/bugzilla/show_bug.cgi?id=71988
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest05_SwtSupport_GetArlTable</srcid><srcstatus/><internalId>1462</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>540</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00198</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function shall be pre compile time configurable On/Off by the configuration parameter: 
        EthIfGetArlTable.
      </description>
      <comment>
        RFC link https://www.autosar.org/bugzilla/show_bug.cgi?id=71988
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ComTest_06_Swt_support</srcid><srcstatus/><internalId>1243</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>541</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00199</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service EthIf_Init 
        was previously called. If the check fails, the function shall raise the development error 
        ETHIF_E_UNINIT.
      </description>
      <comment>
        RFC link https://www.autosar.org/bugzilla/show_bug.cgi?id=71988
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.DevelopmentErrors</srcid><srcstatus/><internalId>1003</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>542</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00200</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter ArlTable for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_PARAM_POINTER.
      </description>
      <comment>
        RFC link https://www.autosar.org/bugzilla/show_bug.cgi?id=71988
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest05_SwtSupport_GetArlTable_InvPointer</srcid><srcstatus/><internalId>1453</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>543</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00214</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_StoreConfiguration 
        Syntax 
        Std_ReturnType EthIf_StoreConfiguration (uint8 SwitchIdx)
        Service ID [hex] | 0x2c 
        Sync/Async | Synchronous /Asynchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | SwitchIdx | Index of the switch within the context of the Ethernet Switch 
        Driver 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | Std_ReturnType | E_OK: Request to persistently store the MAC/Port table was 
        acceptedE_NOT_OK: Request to persistently store the MAC/Port table was not accepted 
        Description | The function shall request to store the configuration of the learned MAC/Port 
        tables of a Ethernet switch in a persistent manner. This could be used by e.g. a CDD.
        Available via | EthIf.h
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ComTest_06_Swt_support</srcid><srcstatus/><internalId>1243</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00214.ServiceId</srcid><srcstatus/><internalId>106</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>544</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00215</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_StoreConfiguration shall trigger to store the learned MAC/Port tables of a 
        Ethernet switch.
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest05_SwtSupport_StoreConfiguration</srcid><srcstatus/><internalId>1466</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>545</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00216</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function shall be pre compile time configurable On/Off by the configuration parameter: 
        EthIfStoreConfigurationApi.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ComTest_06_Swt_support</srcid><srcstatus/><internalId>1243</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>546</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00217</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service EthIf_Init 
        was previously called. If the check fails, the function shall raise the development error 
        ETHIF_E_UNINIT.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.DevelopmentErrors</srcid><srcstatus/><internalId>1003</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>547</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00219</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_ResetConfiguration 
        Syntax 
        Std_ReturnType EthIf_ResetConfiguration (uint8 SwitchIdx)
        Service ID [hex] | 0x2d 
        Sync/Async | Synchronous /Asynchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | SwitchIdx | Index of the switch within the context of the Ethernet Switch 
        Driver 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | Std_ReturnType | E_OK: Request to persistently reset the MAC/Port table was 
        acceptedE_NOT_OK: Request to persistently reset the MAC/Port table was not accepted 
        Description | The function shall request to reset the configuration of the learned MAC/Port 
        tables of a Ethernet switch in a persistent manner. This could be used by e.g. a CDD. The 
        statically configured entries shall still remain.
        Available via | EthIf.h
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ComTest_06_Swt_support</srcid><srcstatus/><internalId>1243</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00219.ServiceId</srcid><srcstatus/><internalId>107</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>548</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00220</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_ResetConfiguration shall trigger to reset the learned MAC/Port tables of a 
        Ethernet switch.
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest05_SwtSupport_ResetConfiguration</srcid><srcstatus/><internalId>1467</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>549</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00221</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function shall be pre compile time configurable On/Off by the configuration parameter: 
        EthIfResetConfigurationApi.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ComTest_06_Swt_support</srcid><srcstatus/><internalId>1243</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>550</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00222</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service EthIf_Init 
        was previously called. If the check fails, the function shall raise the development error 
        ETHIF_E_UNINIT.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.DevelopmentErrors</srcid><srcstatus/><internalId>1003</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>551</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00224</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The EthIf shall dispatch all accesses by the EthIfSwitchIdx index to the respective EthSwt 
        driver module with the EthSwtIdx value
      </description>
      <comment>
        This requirement is informational only.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>552</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00228</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        In order to access the Ethernet switch(es), the Ethernet Interface shall use one or multiple 
        Ethernet Switch Driver modules, which abstract the specific features and interfaces of the 
        respective Ethernet switch(es)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest05_SwtSupport_GetArlTable</srcid><srcstatus/><internalId>1462</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>553</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00229</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        EthIfControllers not referring to an Ethernet Transceiver, i.e. no valid EthIfEthTrcvRef is 
        configured, shall act as if the transceiver was present and the transceiver status was 
        ETHTRCV_LINK_STATE_ACTIVE.
      </description>
      <comment>
        This requirement is informational only
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>554</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00230</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Upon change of link state &lt;User&gt;_TrcvLinkStateChg shall be invoked for every affected 
        EthIfController.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange</srcid><srcstatus/><internalId>130</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange_MultipleUL</srcid><srcstatus/><internalId>131</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange.NoRef</srcid><srcstatus/><internalId>379</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>555</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00231</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_CtrlModeIndication 
        Syntax 
        void EthIf_CtrlModeIndication (uint8 CtrlIdx, Eth_ModeType CtrlMode)
        Service ID [hex] | 0x0e 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant for the same CtrlIdx, reentrant for different 
        Parameters (in) | CtrlIdx | Index of the physical Ethernet controller within the context of the 
        Ethernet Interface 
        CtrlMode | Notified Ethernet controller mode 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | Called asynchronously when mode has been read out. Triggered by previous 
        Eth_SetControllerMode call. Can directly be called within the trigger functions.
        Available via | EthIf.h
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompileTest_01</srcid><srcstatus/><internalId>1237</internalId></linkedfrom><linkedfrom><srcid>EthIf_ComTest02</srcid><srcstatus/><internalId>1239</internalId></linkedfrom><linkedfrom><srcid>EthIf_CompileTest_03</srcid><srcstatus/><internalId>1240</internalId></linkedfrom><linkedfrom><srcid>EthIf_ComTest04</srcid><srcstatus/><internalId>1241</internalId></linkedfrom><linkedfrom><srcid>EthIf_CompTest_05_ServiceId_ErrorId</srcid><srcstatus/><internalId>1242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>556</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00232</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_TrcvModeIndication 
        Syntax 
        void EthIf_TrcvModeIndication (uint8 TrcvIdx, Eth_ModeType TrcvMode)
        Service ID [hex] | 0x0f 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant for the same CtrlIdx, reentrant for different 
        Parameters (in) | TrcvIdx | Index of the Ethernet transceiver within the context of the 
        Ethernet Interface 
        TrcvMode | Notified Ethernet transceiver mode 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | Called asynchronously when a mode change has been read out. If the function is 
        triggered by previous call of EthTrcv_SetTransceiverMode it can directly be called within the 
        trigger function.
        Available via | EthIf.h
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompileTest_01</srcid><srcstatus/><internalId>1237</internalId></linkedfrom><linkedfrom><srcid>EthIf_ComTest02</srcid><srcstatus/><internalId>1239</internalId></linkedfrom><linkedfrom><srcid>EthIf_CompileTest_03</srcid><srcstatus/><internalId>1240</internalId></linkedfrom><linkedfrom><srcid>EthIf_ComTest04</srcid><srcstatus/><internalId>1241</internalId></linkedfrom><linkedfrom><srcid>EthIf_CompTest_05_ServiceId_ErrorId</srcid><srcstatus/><internalId>1242</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR403_EthIf_TrcvModeIndication_Wodl_UnexpectedMode</srcid><srcstatus/><internalId>1582</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR422_EthIf_TrcvModeIndication_Wodl_UnexpectedMode</srcid><srcstatus/><internalId>1621</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR430_EthIf_TrcvModeIndication_Wodl_UnexpectedMode</srcid><srcstatus/><internalId>1670</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>557</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00233</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_SetTransceiverWakeupMode (obsolete)
        Syntax 
        Std_ReturnType EthIf_SetTransceiverWakeupMode (uint8 TrcvIdx, EthTrcv_WakeupModeType 
        TrcvWakeupMode)
        Service ID [hex] | 0x2e 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | TrcvIdx | Index of the transceiver within the context of the Ethernet 
        Interface 
        TrcvWakeupMode | ETHTRCV_WUM_DISABLE: disable transceiver wake up ETHTRCV_WUM_ENABLE: enable 
        transceiver wake up ETHTRCV_WUM_CLEAR: clears transceiver wake up reason 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | Std_ReturnType | E_OK: successE_NOT_OK: transceiver wake up could not be changed 
        or wake-up reason could not be cleared 
        Description | Enables / disables the wake up mode or clear the wake-up reason of the indexed 
        transceiver Tags:atp.Status=obsolete 
        Available via | EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ComTest02</srcid><srcstatus/><internalId>1239</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00233.ServiceId</srcid><srcstatus/><internalId>97</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.WakeUp</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1115</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>558</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00234</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_SetTransceiverWakeupMode shall forward the call to function 
        EthTrcv_SetTransceiverWakeupMode of the corresponding Ethernet Transceiver Driver (
        EthIfTransceiverIdx) if mode ETHTRCV_WUM_ENABLE has been requested and the current state of the 
        requested Ethernet Transceiver Driver is ETHTRCV_WUM_DISABLE
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest07001_SetTransceiverWakeupMode</srcid><srcstatus/><internalId>1535</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest07003_SetTransceiverWakeupMode_NotOk</srcid><srcstatus/><internalId>1537</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.WakeUp</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1115</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>559</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00235</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service EthIf_Init 
        was previously called. If the check fails, the function shall raise the development error 
        ETHIF_E_UNINIT otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.DevelopmentErrors</srcid><srcstatus/><internalId>1003</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>560</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00236</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter TrcvIdx for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_INV_TRCV_IDX otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest07000_SetTransceiverWakeupMode_InvTrcvIdx</srcid><srcstatus/><internalId>1531</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.WakeUp</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1115</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>561</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00237</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function shall be pre compile time configurable On/Off by the configuration parameter 
        EthIfWakeUpSupport.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompileTest_01</srcid><srcstatus/><internalId>1237</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.WakeUp</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1115</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>562</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00238</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_GetTransceiverWakeupMode (obsolete)
        Syntax 
        Std_ReturnType EthIf_GetTransceiverWakeupMode (uint8 TrcvIdx, EthTrcv_WakeupModeType* 
        TrcvWakeupModePtr)
        Service ID [hex] | 0x2f 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | TrcvIdx | Index of the transceiver within the context of the Ethernet 
        Interface 
        Parameters (inout) | None 
        Parameters (out) | TrcvWakeupModePtr | ETHTRCV_WUM_DISABLE: transceiver wake up is disabled 
        ETHTRCV_WUM_ENABLE: transceiver wake up is enabled 
        Return value | Std_ReturnType | E_NOT_OK: transceiver wake up mode could not be obtained 
        Description | Returns the wake up mode of the indexed transceiver Tags:atp.Status=obsolete 
        Available via | EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ComTest02</srcid><srcstatus/><internalId>1239</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00238.ServiceId</srcid><srcstatus/><internalId>98</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.WakeUp</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1115</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>563</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00239</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_GetTransceiverWakeupMode shall forward the call to function 
        EthTrcv_GetTransceiverWakeupMode of the corresponding Ethernet Transceiver Driver (
        EthIfTransceiverIdx)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest07002_GetTransceiverWakeupMode</srcid><srcstatus/><internalId>1536</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.WakeUp</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1115</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>564</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00240</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service EthIf_Init 
        was previously called. If the check fails, the function shall raise the development error 
        ETHIF_E_UNINIT otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.DevelopmentErrors</srcid><srcstatus/><internalId>1003</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>565</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00241</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter TrcvIdx for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_INV_TRCV_IDX otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest07000_GetTransceiverWakeupMode_InvTrcvIdx</srcid><srcstatus/><internalId>1533</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.WakeUp</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1115</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>566</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00242</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter 
        TrcvWakeupModePtr for being valid. If the check fails, the function shall raise the development 
        error ETHIF_E_PARAM_POINTER otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.PointerMacroChanged</srcid><srcstatus/><internalId>1005</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>567</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00243</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function shall be pre compile time configurable On/Off by the configuration parameter 
        EthIfGetTransceiverWakeupModeApi.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompileTest_01</srcid><srcstatus/><internalId>1237</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.WakeUp</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1115</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>568</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00244</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_CheckWakeup 
        Syntax 
        Std_ReturnType EthIf_CheckWakeup (EcuM_WakeupSourceType WakeupSource)
        Service ID [hex] | 0x30 
        Sync/Async | Asynchronous 
        Reentrancy | Reentrant 
        Parameters (in) | WakeupSource | Source device which initiated the wake up event. The source 
        device could either be a Ethernet switch or a Ethernet transceiver 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | Std_ReturnType | E_OK when the request to check for a wake-up of the affected 
        Ethernet hardware (e.g. PHY) has been accepted.E_NOT_OK when the request to check for a wake-up 
        of the affected Ethernet hardware is rejected.
        Description | This API request the affected Ethernet hardware to check for a signaled wake-up. 
        The used Ethernet hardware could be an Ethernet switch or Ethernet transceiver (PHY). This is 
        used e.g. for Ethernet hardware which is compliant to the specification of Open Alliance TC10. 
        This API is called by the integration code. The function could be called in context of the 
        interrupt or on task level.
        Available via | EthIf.h
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ComTest02</srcid><srcstatus/><internalId>1239</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00244.ServiceId</srcid><srcstatus/><internalId>99</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.WakeUp</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1115</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>569</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00245</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        For all affected Ethernet transceiver (either referenced by EthIfTransceiver or by 
        EthIfSwitchPortGroups) the function EthIf_CheckWakeup shall forward the call to function 
        EthTrcv_CheckWakeup of the respective Ethernet Transceiver Driver.
      </description>
      <comment>
        Please check EthIf.EB.SWS_EthIf_00245_PoolAllTrcvs.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.EthIf_CheckWakeup</srcid><srcstatus/><internalId>992</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>570</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00246</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service EthIf_Init 
        was previously called. If the check fails, the function shall raise the development error 
        ETHIF_E_UNINIT otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.DevelopmentErrors</srcid><srcstatus/><internalId>1003</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>571</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00247</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter WakeupSource 
        for being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_INV_PARAM otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <comment>
        This requirement is not applicable. EthIf does not have information about configured
        wake-up sources. This information is available in EcuM, which calls EthIf_CheckWakeup().
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>572</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00248</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_CheckWakeup() shall be pre-compile time configurable On/Off by the 
        configuration parameter EthIfWakeUpSupport.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompileTest_01</srcid><srcstatus/><internalId>1237</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.WakeUp</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1115</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>573</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00250</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If CtrlIdx refers to an EthIfCtrl where an EthIfVlanID is configured, the parameters FrameType 
        is not used, and 0x8100 is provided to Eth_Transmit instead.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_T330_00_Transmit_ValidParameters</srcid><srcstatus/><internalId>1785</internalId></linkedfrom><linkedfrom><srcid>EthIf_T330_01_Transmit_ValidParameters</srcid><srcstatus/><internalId>1786</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>574</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00252</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function shall call EthSM_CtrlModeIndication.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06028_EthIf_PortGroup_Inv</srcid><srcstatus/><internalId>1498</internalId></linkedfrom><linkedfrom><srcid>EthIf_T112_00_SetControllerMode_ValidParameters</srcid><srcstatus/><internalId>1757</internalId></linkedfrom><linkedfrom><srcid>EthIf_T112_00_SetControllerMode_EthSetControllerMode_NotOk</srcid><srcstatus/><internalId>1758</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest02003_SetControllerMode</srcid><srcstatus/><internalId>1896</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest02034_CtrlModeIndication</srcid><srcstatus/><internalId>1915</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>575</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00042</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfTransceiver
        Container Type: Sub-Container
        Parent Containers: EthIfConfigSet,
        Description: This container contains the configuration of EthIfTransceiver.
        Introduction: The usage of EthIfEthTrcvRef and EthIfWEthTrcvRefis exclusive OR.
        Lower Multiplicity: 0
        infinite
        Post-Build-Variant-Multiplicity: false
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>576</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00043</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfTransceiverIdx
        Parameter Type: Integer
        Parent Containers: EthIfTransceiver,
        Description: This parameter provides a zero-based consecutive index of the Ethernet 
        transceivers. Upper layer BSW modules and the Ethernet Interface itself use this index to 
        identify an Ethernet tranceiver.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: true
        Max-Value: 255 (Type:
        Min-Value: 0 (Type:
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/EthIf_Extension.xdm.m4_763</srcid><srcstatus/><internalId>1103</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>577</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00044</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfEthTrcvRef
        Parameter Type: Reference
        Parent Containers: EthIfTransceiver,
        Description: Reference to an Ethernet transceiver, which is handled by a specific Ethernet 
        transceiver driver.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Destination: /AUTOSAR/EcucDefs/EthTrcv/EthTrcvConfigSet/EthTrcvConfig
        Destination type: ECUC-PARAM-CONF-CONTAINER-DEF
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/EthIf_Extension.xdm.m4_779</srcid><srcstatus/><internalId>1104</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>578</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00045</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfPhysController
        Container Type: Sub-Container
        Parent Containers: EthIfConfigSet,
        Sub-Containers: EthIfPhysCtrlRxMainFunctionPriorityProcessing 
        Description: This container contains the configuration of EthIfPhysController.
        Introduction: The usage of EthIfEthCtrlRef and EthIfWEthCtrlRef is exclusive OR.
        Lower Multiplicity: 1
        infinite
        Post-Build-Variant-Multiplicity: false
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>579</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00046</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfPhysControllerIdx
        Parameter Type: Integer
        Parent Containers: EthIfPhysController,
        Description: This parameter provides a zero-based consecutive index of the physical Ethernet 
        controllers. Upper layer BSW modules and the Ethernet Interface itself use this index to 
        identify a physical Ethernet controller.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: true
        Max-Value: 255 (Type:
        Min-Value: 0 (Type:
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/EthIf_Extension.xdm.m4_330</srcid><srcstatus/><internalId>1096</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest05007_MainFunctionRxPrio_ETH_RECEIVED</srcid><srcstatus/><internalId>1438</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>580</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00047</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfEthCtrlRef
        Parameter Type: Reference
        Parent Containers: EthIfPhysController,
        Description: Reference to a physical Ethernet controller, which is handled by a specific 
        Ethernet controller driver.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Destination: /AUTOSAR/EcucDefs/Eth/EthConfigSet/EthCtrlConfig
        Destination type: ECUC-PARAM-CONF-CONTAINER-DEF
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/EthIf_Extension.xdm.m4_346</srcid><srcstatus/><internalId>1097</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest05007_MainFunctionRxPrio_ETH_RECEIVED</srcid><srcstatus/><internalId>1438</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>581</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00050</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfPhysCtrlRxMainFunctionPriorityProcessing
        Container Type: Sub-Container
        Parent Containers: EthIfPhysController,
        Description: Configuration of ingress FIFO based main function processing.
        Lower Multiplicity: 0
        infinite
        Post-Build-Variant-Multiplicity: false
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>582</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00051</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfPhysCtrlRxMainFunctionPeriod
        Parameter Type: FloatValue
        Parent Containers: EthIfPhysCtrlRxMainFunctionPriorityProcessing,
        Description: Specifies the period of main function in seconds.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/EthIf_Extension.xdm.m4_426</srcid><srcstatus/><internalId>1100</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>583</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00052</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfPhysCtrlRxIndicationIterations
        Parameter Type: Integer
        Parent Containers: EthIfPhysCtrlRxMainFunctionPriorityProcessing,
        Description: Max number of Ethernet frames polled per main function invocation.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: 18446744073709551615 (Type:
        Min-Value: 0 (Type:
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/EthIf_Extension.xdm.m4_411</srcid><srcstatus/><internalId>1099</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest05005_MainFunctionRxPrio_Polling</srcid><srcstatus/><internalId>1436</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>584</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00053</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfPhysCtrlRxIngressFifoRef
        Parameter Type: Reference
        Parent Containers: EthIfPhysCtrlRxMainFunctionPriorityProcessing,
        Description: Reference to the reception FIFO.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Destination: /AUTOSAR/EcucDefs/Eth/EthConfigSet/EthCtrlConfig/EthCtrlConfigIngress/
        EthCtrlConfigIngressFifo
        Destination type: ECUC-PARAM-CONF-CONTAINER-DEF
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/EthIf_Extension.xdm.m4_444</srcid><srcstatus/><internalId>1101</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest05007_MainFunctionRxPrio_ETH_RECEIVED</srcid><srcstatus/><internalId>1438</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>585</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00054</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfSwitchOffPortTimeDelay
        Parameter Type: FloatValue
        Parent Containers: EthIfGeneral,
        Description: Denote the time delay after the mode "ETH_MODE_DOWN" of a EthIfSwitchPortGroup 
        will be executed.
        Introduction: This is only used for EthIfSwtPortGroups which are not referenced by any 
        EthIfController. The time delay shall be greater than the UdpNm timings, because UdpNm shall 
        finish its shutdown handling. (Repeat Message State, Prepare Bus-Sleep state, Bus-Sleep state)
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: true
        Post-Build-Variant-Value: true
        Multiplicity-Configuration Class: LINK, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: LINK, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: 65.535 (Type: CLOSED)
        Min-Value: 0.001 (Type: CLOSED)
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>586</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00055</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfPortStartupActiveTime
        Parameter Type: FloatValue
        Parent Containers: EthIfGeneral,
        Description: Denote the time delay after the mode "ETH_MODE_ACTIVE" of all EthIfSwitchPorts are 
        requested via EthIf_StartAllPorts.
        Introduction: This is only used for ports in EthIfSwtPortGroups which are not referenced by any 
        EthIfController.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: true
        Post-Build-Variant-Value: true
        Multiplicity-Configuration Class: LINK, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: LINK, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: 65.535 (Type: CLOSED)
        Min-Value: 0.001 (Type: CLOSED)
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>587</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00056</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfMainFunctionStatePeriod
        Parameter Type: FloatValue
        Parent Containers: EthIfGeneral,
        Description: Specifies the period of main function EthIf_MainFunctionState in seconds. Ethernet 
        Interface does not require this information but the BSW scheduler.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: false
        Post-Build-Variant-Value: false
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: INF (Type: OPEN)
        Min-Value: 0 (Type: OPEN)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/EthIf_Extension.xdm.m4_1081</srcid><srcstatus/><internalId>1105</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>588</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00057</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfSwitchPortGroup
        Container Type: Sub-Container
        Parent Containers: EthIfConfigSet,
        Description: This container contains the configuration of EthIfSwitchPortGroups.
        Introduction: If EthIfSwitchPortGroups are controlled by PNC one EthIfSwitchPortGroup per PNC 
        shall exist. The host port shall be part of all EthIfSwitchPortGroups. The up link port of a 
        master switch and the up link port of the slave switch shall be part of all 
        EthIfSwitchPortGroups that contain EthSwtPorts belonging to the slave switch.
        Lower Multiplicity: 0
        infinite
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>589</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00058</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfSwitchPortGroupIdx
        Parameter Type: Integer
        Parent Containers: EthIfSwitchPortGroup,
        Description: This parameter provides a zero-based consecutive index of the Ethernet Switch Port 
        Groups. Upper layer BSW modules and the EthIf itself use this index to identify an Ethernet 
        Switch Port Group.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: true
        Max-Value: 255 (Type:
        Min-Value: 0 (Type:
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.PostBuildSelectable</srcid><srcstatus/><internalId>1001</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.EB.ECUC_EthIf_00058</srcid><srcstatus/><internalId>138</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>590</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00059</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfSwitchPortGroupRefSemantics
        Parameter Type: Enumeration
        Parent Containers: EthIfSwitchPortGroup,
        Description: Defines how the EthIfSwitchRefOrPortGroupRef refering to a EthIfSwitchPortGroup 
        shall be interpreted.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Enumeration Literal: ETHIF_SWITCH_PORT_GROUP_CONTROL, AUTOSAR_ECUC
        Enumeration Literal: ETHIF_SWITCH_PORT_GROUP_LINK_INFO, AUTOSAR_ECUC
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>591</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00060</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfPortRef
        Parameter Type: Reference
        Parent Containers: EthIfSwitchPortGroup,
        Description: Reference to an Ethernet Switch Port.
        Lower Multiplicity: 1
        infinite
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Destination: /AUTOSAR/EcucDefs/EthSwt/EthSwtConfig/EthSwtPort
        Destination type: ECUC-PARAM-CONF-CONTAINER-DEF
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>592</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00062</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfSetForwardingModeApi
        Parameter Type: Boolean
        Parent Containers: EthIfGeneral,
        Description: Enables /disables EthIf_SetForwardingMode API.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>593</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00063</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfVerifyConfigApi
        Parameter Type: Boolean
        Parent Containers: EthIfGeneral,
        Description: Enables /disables EthIf_VerifyConfig API.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>594</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00064</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfSwitchManagementSupport
        Parameter Type: Boolean
        Parent Containers: EthIfGeneral,
        Description: Enables/Disables the Switch management APIs to support a Switch-port specific 
        communication attribute access.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>595</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00065</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfSwitchMgmtInfoIndicationConfig
        Container Type: Sub-Container
        Parent Containers: EthIfConfigSet,
        Description: Configuration of Switch Management callback function.
        Lower Multiplicity: 0
        infinite
        Post-Build-Variant-Multiplicity: false
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>596</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00066</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfSwitchTimeStampIndicationConfig
        Container Type: Sub-Container
        Parent Containers: EthIfConfigSet,
        Description: Configuration of Switch timestamp indications.
        Lower Multiplicity: 0
        infinite
        Post-Build-Variant-Multiplicity: false
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>597</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00067</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfSwitchMgmtInfoIndicationFunction
        Parameter Type: FunctionRef
        Parent Containers: EthIfSwitchMgmtInfoIndicationConfig,
        Description: Enables/Disables the ingress Switch management info indication redirected call to 
        upper layers who registered for the call.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        FunctionName Def Condition:Max-Length: , Min-Length
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>598</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00068</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfSwitchEgressTimeStampIndicationFunction
        Parameter Type: FunctionRef
        Parent Containers: EthIfSwitchTimeStampIndicationConfig,
        Description: Enables/Disables to upper layers an egress timestamp indication function.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        FunctionName Def Condition:Max-Length: , Min-Length
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>599</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00069</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfSwitchIngressTimeStampIndicationFunction
        Parameter Type: FunctionRef
        Parent Containers: EthIfSwitchTimeStampIndicationConfig,
        Description: Enables/Disables to upper layers an ingress timestamp indication function.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        FunctionName Def Condition:Max-Length: , Min-Length
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>600</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00070</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfGetCtrlIdxList
        Parameter Type: Boolean
        Parent Containers: EthIfGeneral,
        Description: Enables / Disables GetCtrlIdxList API.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>601</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00071</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfGetVlanIdSupport
        Parameter Type: Boolean
        Parent Containers: EthIfGeneral,
        Description: Enables / Disables GetVlanId API.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>602</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00072</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfGetAndResetMeasurementDataApi
        Parameter Type: Boolean
        Parent Containers: EthIfGeneral,
        Description: Enables / Disables the Get and Reset Measurement Data API
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.GetAndResetMeasurementData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1121</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>603</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00073</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfWEthCtrlRef
        Parameter Type: Reference
        Parent Containers: EthIfPhysController,
        Description: Reference to a physical Wireless Ethernet controller, which is handled by a 
        specific Wireless Ethernet controller driver.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Destination: /AUTOSAR/EcucDefs/WEth/WEthConfigSet/WEthCtrlConfig
        Destination type: ECUC-PARAM-CONF-CONTAINER-DEF
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>604</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00074</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfWEthTrcvRef
        Parameter Type: Reference
        Parent Containers: EthIfTransceiver,
        Description: Reference to an Wireless Ethernet transceiver, which is handled by a specific 
        Wireless Ethernet transceiver driver.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Destination: /AUTOSAR/EcucDefs/WEthTrcv/WEthTrcvConfigSet/WEthTrcvConfig
        Destination type: ECUC-PARAM-CONF-CONTAINER-DEF
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>605</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00075</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfEnableWEthApi
        Parameter Type: Boolean
        Parent Containers: EthIfGeneral,
        Description: Enables / Disables API's for WEth / WEthTrcv
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: false
        Post-Build-Variant-Value: false
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>606</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00254</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_GetArlTable shall forward the call to function EthSwt_GetArlTable of the 
        respective Ethernet Switch Driver.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest05_SwtSupport_GetArlTable</srcid><srcstatus/><internalId>1462</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>607</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00255</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        EthIf_TxConfirmation shall pass the Result received within EthIf_TxConfirmation to the 
        configured upper layer via &lt;UL&gt;_TxConfirmation.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.TxConfirmation_Result</srcid><srcstatus/><internalId>999</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>608</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00256</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        EthIf shall delay the shutdown of an EthIfPhysController referencing a EthIfSwitch until all 
        EthSwtPorts of the referenced switch are in state ETH_MODE_DOWN.
      </description>
      <comment>
        Rationale: In case of using e.g. MDIO as control path for the EthSwt the
        EthIfPhysController should stay in ETH_MODE_ACTIVE until all EthSwt controlling
        actions (e.g. switch of EthSwtPorts) have been finished.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06009_PortGroup_AllPortsNotDown</srcid><srcstatus/><internalId>1476</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06013_MainFunctionCycleCounter</srcid><srcstatus/><internalId>1480</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06029_AllPortsNotDown_2</srcid><srcstatus/><internalId>1499</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.SwitchPortGroup</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1117</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>609</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00257</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If no EthIfSwitchPortGroup is configured, all EthSwtPorts belonging to a switch shall be 
        switched on if a least one EthIfController referencing this switch is requested with 
        ETH_MODE_ACTIVE.
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06001_SetControllerMode_Switch</srcid><srcstatus/><internalId>1470</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06015_UpdateRequestedPortState</srcid><srcstatus/><internalId>1482</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06016_PortGroup_LinkStateChg</srcid><srcstatus/><internalId>1483</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06017_MainFunction_SwitchPortMiiCheck</srcid><srcstatus/><internalId>1484</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06017_MainFunction_SwitchPortMiiCheck_Wakeup</srcid><srcstatus/><internalId>1485</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest08001_SetControllerModeAsync_Switch</srcid><srcstatus/><internalId>1541</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.SwitchPortGroup</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1117</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>610</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00258</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If no EthIfSwitchPortGroup is configured, all EthSwtPorts belonging to a switch shall be 
        switched off if all EthIfController referencing this switch are requested with ETH_MODE_DOWN.
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06001_SetControllerMode_Switch</srcid><srcstatus/><internalId>1470</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06013_MainFunctionCycleCounter</srcid><srcstatus/><internalId>1480</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06029_AllPortsNotDown_2</srcid><srcstatus/><internalId>1499</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest08001_SetControllerModeAsync_Switch</srcid><srcstatus/><internalId>1541</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.SwitchPortGroup</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1117</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>611</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00259</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The link state for an EthIfSwitchPortGroup is computed over all link states of the EthSwtPorts 
        which are referenced by the EthIfSwitchPortGroup. Its status is ETHTRCV_LINK_STATE_DOWN (link 
        down) if one of the following conditions is met:
        Referenced EthSwtPort with the role "host port" or the role "up link port" has link down state
        All referenced EthSwtPort without a role have link down state
        Otherwise its accumulated link state is ETHTRCV_LINK_STATE_ACTIVE (link up)
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06006_PortGroup_LinkStateChg</srcid><srcstatus/><internalId>1475</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06013_MainFunctionCycleCounter</srcid><srcstatus/><internalId>1480</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06020_EthSwt_GetLinkState_MiiCheck</srcid><srcstatus/><internalId>1489</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06020_EthSwt_GetLinkState_MiiCheck_Wakeup</srcid><srcstatus/><internalId>1490</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06032_BswMPortGroup_LinkStateChg</srcid><srcstatus/><internalId>1502</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06034_BswMPortGroup_LinkStateChg_LINK_INFO</srcid><srcstatus/><internalId>1503</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.LinkStateAccSwitchPortGroup</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1118</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>612</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00260</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If the EthIfCtrl references a EthIfSwitch but no port group is configured, the EthIf shall 
        indicate the link state of the host port to the EthSM by calling EthSM_TrcvLinkStateChg for the 
        EthIfController when the link state changes.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06006_PortGroup_LinkStateChg</srcid><srcstatus/><internalId>1475</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06013_MainFunctionCycleCounter</srcid><srcstatus/><internalId>1480</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06015_UpdateRequestedPortState</srcid><srcstatus/><internalId>1482</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06016_PortGroup_LinkStateChg</srcid><srcstatus/><internalId>1483</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR403_SetControllerMode_Wakeup_Activate_Switch</srcid><srcstatus/><internalId>1560</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR403_SetControllerMode_Wakeup_Deactivate_Switch</srcid><srcstatus/><internalId>1561</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR422_SetControllerMode_Wakeup_Activate_Switch</srcid><srcstatus/><internalId>1599</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR422_SetControllerMode_Wakeup_Deactivate_Switch</srcid><srcstatus/><internalId>1600</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR430_SetControllerMode_Wakeup_Activate_Switch</srcid><srcstatus/><internalId>1647</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR430_SetControllerMode_Wakeup_Deactivate_Switch</srcid><srcstatus/><internalId>1648</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.LinkStateAccSwitchPortGroup</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1118</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>613</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00261</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        In case a EthIfSwitchPortGroup is not connected to any EthIfController, the EthIf shall 
        indicate the accumulated link state of the EthIfSwitchPortGroup to the BswM by calling 
        BswM_EthIf_PortGroupLinkStateChg for the EthIfSwitchPortGroup when the link state changes (
        refer to SWS_EthIf_00259 for link state accumulation)
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.BswMPortGroupDown.LinksStateDown</srcid><srcstatus/><internalId>1000</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.EB.SWS_EthIf_00261</srcid><srcstatus/><internalId>1129</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>614</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00262</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        In case a EthIfSwitchPortGroup is connected to a EthIfController, the EthIf shall indicate the 
        accumulated link state of the EthIfSwitchPortGroup to the EthSM by calling 
        EthSM_TrcvLinkStateChg for the EthIfController when the link state changes (refer to 
        SWS_EthIf_00259 for link state accumulation)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06006_PortGroup_LinkStateChg</srcid><srcstatus/><internalId>1475</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR403_SetControllerMode_Wakeup_Activate_SwitchPortGroup</srcid><srcstatus/><internalId>1574</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR403_SetControllerMode_Wakeup_Deactivate_SwitchPortGroup</srcid><srcstatus/><internalId>1575</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR422_SetControllerMode_Wakeup_Activate_SwitchPortGroup</srcid><srcstatus/><internalId>1613</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR422_SetControllerMode_Wakeup_Deactivate_SwitchPortGroup</srcid><srcstatus/><internalId>1614</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR430_SetControllerMode_Wakeup_Activate_SwitchPortGroup</srcid><srcstatus/><internalId>1662</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR430_SetControllerMode_Wakeup_Deactivate_SwitchPortGroup</srcid><srcstatus/><internalId>1663</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.LinkStateAccSwitchPortGroup</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1118</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>615</internalId></specobject>

    <specobject>
      <id>EthIf.SWS_EthIf_00263</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        EthIf shall call the function Eth_SetControllerMode of the corresponding Ethernet Controller 
        Driver (EthIfPhysControllerIdx) with ETH_MODE_DOWN, if EthIf_SetControllerMode has been called 
        with mode ETH_MODE_DOWN for all Ethernet Interface Controller referencing the Ethernet 
        Controller.
      </description>
      <comment>
        Note: in case of VLAN support, it means that EthIf has to store internally the state of
        each EthIfController in order to filter out the requests from upper layers and disable
        the callouts to upper layers when the EthIfController is disabled.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_T500_SetControllerMode_Concurrent</srcid><srcstatus/><internalId>1809</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00129</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>491</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>616</internalId></specobject>

    <specobject>
      <id>EthIf.SWS_EthIf_00264</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If EthIf_SetControllerMode has been called for an EthIfController with ETH_MODE_ACTIVE and this 
        EthIfController has a reference to an EthIfSwitchPortGroup of type "control", then EthIf shall 
        forward the call to the following functions in the given order for all EthSwtPorts of the 
        respective EthIfSwitchPortGroup if the mode ETH_MODE_ACTIVE has been requested for the first 
        EthIfSwitchPortGroup referencing the EthSwtPort and the current EthSwtPort mode is 
        ETH_MODE_DOWN: 1. EthSwt_SetSwitchPortMode with ETH_MODE_ACTIVE 2. EthSwt_PortLinkStateRequest 
        with ETHTRCV_LINK_STATE_ACTIVE
      </description>
      <comment>
        Note: EthIfSWitchPortGroups that shall be switched according to PNC state are
        handled by BswM with the call of API EthIf_SwitchPortGroupRequestMode. This can
        be configured within the BswM via the BswMEthIfSwitchPortGroupRequestMode
        action.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06002_SetControllerMode_PortGroup</srcid><srcstatus/><internalId>1471</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06013_MainFunctionCycleCounter</srcid><srcstatus/><internalId>1480</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06029_AllPortsNotDown_2</srcid><srcstatus/><internalId>1499</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06031_SetControllerMode_PortGroup</srcid><srcstatus/><internalId>1501</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest08002_SetControllerModeAsync_PortGroup</srcid><srcstatus/><internalId>1542</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>617</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00265</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If EthIf_SetControllerMode is called for an EthIfController with ETH_MODE_DOWN and this 
        EthIfController has a reference to an EthIfSwitchPortGroup of type "control", then EthIf shall 
        forward the call to the following functions in the given order for all EthSwtPorts of the 
        respective EthIf_SwitchPortGroup, but only for those EthSwtPorts where all referencing 
        EthIfSwitchPortGroups has been requested with ETH_MODE_DOWN and the current mode of the 
        EthSwtPort is ETH_MODE_ACTIVE:
        EthSwt_PortLinkStateRequest with ETHTRCV_LINK_STATE_DOWN
        EthSwt_SetSwitchPortMode with ETH_MODE_DOWN
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.LinkStateRequest</srcid><srcstatus/><internalId>1004</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>618</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00266</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If EthIf_SetControllerMode has been called for an EthIfController with ETH_MODE_ACTIVE and this 
        EthIfController has a reference to an EthIfTransceiver, then EthIf shall forward the call to 
        the following functions in the given order, if the current mode of the EthIfTransceiver is 
        ETH_MODE_DOWN: 1. EthTrcv_SetTransceiverMode with ETH_MODE_ACTIVE 2. 
        EthTrcv_TransceiverLinkStateRequest with ETHTRCV_LINK_STATE_ACTIVE
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest02034_CtrlModeIndication</srcid><srcstatus/><internalId>1915</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>619</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00267</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        In the context of EthIf_CtrlModeIndication the function EthSwt_SetSwitchPortMode shall be 
        called for all EthSwtPorts of a EthIfSwitchPortGroup if the EthIfController has a reference to 
        a EthIfSwitchPortGroup and the reference is of type "control". If ETH_MODE_DOWN is requested, 
        the EthIf has to ensure that only those EthSwtPorts are set to ETH_MODE_DOWN which are not 
        requested ETH_MODE_ACTIVE by another EthIfSwitchPortGroup.
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06002_SetControllerMode_PortGroup</srcid><srcstatus/><internalId>1471</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06031_SetControllerMode_PortGroup</srcid><srcstatus/><internalId>1501</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest08002_SetControllerModeAsync_PortGroup</srcid><srcstatus/><internalId>1542</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>620</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00268</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_SetTransceiverWakeupMode shall forward the call to function 
        EthTrcv_SetTransceiverWakeupMode of the corresponding Ethernet Transceiver Driver (
        EthIfTransceiverIdx) if mode ETHTRCV_WUM_DISABLE has been requested and the current state of 
        the requested Ethernet Transceiver Driver is ETHTRCV_WUM_ENABLE.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest07001_SetTransceiverWakeupMode</srcid><srcstatus/><internalId>1535</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.WakeUp</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1115</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>621</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00269</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_SetTransceiverWakeupMode shall forward the call to function 
        EthTrcv_SetTransceiverWakeupMode of the corresponding Ethernet Transceiver Driver (
        EthIfTransceiverIdx) if mode ETHTRCV_WUM_CLEAR has been requested and the current state of the 
        requested Ethernet Transceiver Driver is ETHTRCV_WUM_DISABLE.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest07001_SetTransceiverWakeupMode</srcid><srcstatus/><internalId>1535</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.WakeUp</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1115</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>622</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00270</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If EthIf_SwitchPortGroupRequestMode is called with ETH_MODE_DOWN EthIf shall start a timer with 
        EthIfSwitchOffPortTimedelay for all ports of the respective EthIf_SwitchPortGroup if the mode 
        ETH_MODE_DOWN has been requested for all EthIfSwitchPortGroups referencing the port and the 
        current mode is ETH_MODE_ACTIVE.
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06003_SwitchPortGroupRequestMode</srcid><srcstatus/><internalId>1472</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06012_SwitchPortGroup_SetSwitchPortMode_NOK</srcid><srcstatus/><internalId>1479</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>623</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00271</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If the timer to switch off ports  elapses for a port, EthIf shall call the following functions 
        in the given order for the corresponding EthSwtPort:
        EthSwt_PortLinkStateRequest with ETHTRCV_LINK_STATE_DOWN
        EthSwt_SetSwitchPortMode with ETH_MODE_DOWN
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.LinkStateRequest</srcid><srcstatus/><internalId>1004</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>624</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00272</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If EthIf_SwitchPortGroupRequestMode has been called with ETH_MODE_ACTIVE, EthIf shall forward 
        the call to the following functions in the given order for all EthSwtPorts of the respective 
        EthIfSwitchPortGroup: 1.) Call EthSwt_SetSwitchPortMode with ETH_MODE_ACTIVE, if the current 
        mode is ETH_MODE_DOWN. 2.) Call EthSwt_PortLinkStateRequest with ETHTRCV_LINK_STATE_ACTIVE, if 
        the current link state is ETHTRCV_LINK_STATE_DOWN
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.LinkStateRequest</srcid><srcstatus/><internalId>1004</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>625</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00273</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service EthIf_Init 
        was previously called. If the check fails, the function shall raise the development error 
        ETHIF_E_UNINIT and return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01085_SwitchPortGroupRequestMode_Uninit</srcid><srcstatus/><internalId>1309</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.DevelopmentErrors</srcid><srcstatus/><internalId>1003</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>626</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00274</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the provided parameter 
        PortGroupIdx addresses a port group not referenced by any EthIfController. If the check fails, 
        the function shall raise the development error ETHIF_E_INV_PORT_GROUP_IDX and return E_NOT_OK.
      </description>
      <comment>
        Rationale: Avoid that a EthIfSwitchPortGroup which shall be controlled by  EthIfController
        is incidentally called by BswM.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01087_SwitchPortGroupRequestMode_InvPortGrInd</srcid><srcstatus/><internalId>1311</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>627</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00275</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If EthIf_StartAllPorts has been called, then EthIf shall forward the call to the following 
        functions in the given order to all EthSwtPorts of the affected EthIfSwitches:
        Call EthSwt_SetSwitchPortMode with ETH_MODE_ACTIVE, if the current mode is ETH_MODE_DOWN.
        Call EthSwt_PortLinkStateRequest with ETHTRCV_LINK_STATE_ACTIVE, if the current link state is 
        ETHTRCV_LINK_STATE_DOWN
        and start a timer with EthIfPortStartupActiveTime for all these ports.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.LinkStateRequest</srcid><srcstatus/><internalId>1004</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>628</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00276</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        After EthIf_StartAllPorts has been called, EthIf shall deactivate all those ports activated due 
        to EthIf_StartAllPorts  which are not requested with ETH_MODE_ACTIVE within 
        EthIfPortStartupActiveTime by calling the following functions in the given order:
        EthSwt_PortLinkStateRequest with ETHTRCV_LINK_STATE_DOWN
        EthSwt_SetSwitchPortMode with ETH_MODE_DOWN
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.LinkStateRequest</srcid><srcstatus/><internalId>1004</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>629</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00277</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service EthIf_Init 
        was previously called. If the check fails, the function shall raise the development error 
        ETHIF_E_UNINIT and return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01086_StartAllPorts_Uninit</srcid><srcstatus/><internalId>1310</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.DevelopmentErrors</srcid><srcstatus/><internalId>1003</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>630</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00279</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function shall be pre compile time configurable ON/OFF by the configuration parameter: 
        EthIfSwitchManagementSupport.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.SwitchMgmtInfo</srcid><srcstatus/><internalId>995</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>631</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00280</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service EthIf_Init(
        was previously called. If the check fails, the function shall raise the development error 
        ETHIF_E_UNINIT.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.SwitchMgmtInfo</srcid><srcstatus/><internalId>995</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>632</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00281</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter CtrlIdx for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_INV_CTRL_IDX.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.SwitchMgmtInfo</srcid><srcstatus/><internalId>995</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>633</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00282</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter BufIdx for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_INV_PARAM.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.SwitchMgmtInfo</srcid><srcstatus/><internalId>995</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>634</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00283</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter MgmtInfoPtr 
        for being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_PARAM_POINTER.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.SwitchMgmtInfo</srcid><srcstatus/><internalId>995</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>635</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00285</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function shall be pre compile time configurable ON/OFF by the configuration parameter: 
        EthIfGlobalTimeSupport.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.SwitchEnableTimeStamping</srcid><srcstatus/><internalId>996</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>636</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00286</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service Eth_Init(
        was previously called. If the check fails, the function shall raise the development error 
        ETHIF_E_UNINIT.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.SwitchEnableTimeStamping</srcid><srcstatus/><internalId>996</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>637</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00287</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter CtrlIdx for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_INV_CTRL_IDX.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.SwitchEnableTimeStamping</srcid><srcstatus/><internalId>996</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>638</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00288</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter BufIdx for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_INV_PARAM.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.SwitchEnableTimeStamping</srcid><srcstatus/><internalId>996</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>639</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00289</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter BufIdx for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_INV_PARAM.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.SwitchEnableTimeStamping</srcid><srcstatus/><internalId>996</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>640</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00290</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter BufIdx for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_INV_PARAM.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.SwitchEnableTimeStamping</srcid><srcstatus/><internalId>996</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>641</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00298</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The optional EthIf_GetCtrlIdxList API shall return only the NumberOfCtrlIdx which are active.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.GetCtrlIdxList</srcid><srcstatus/><internalId>994</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>642</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00299</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service EthIf_Init 
        was previously called. If the check fails, the function shall raise the development error 
        ETHIF_E_UNINIT.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01063_GetCtrlIdxList_Uninit</srcid><srcstatus/><internalId>1289</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.DevelopmentErrors</srcid><srcstatus/><internalId>1003</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>643</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00300</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the OUT parameter 
        CtrlIdxListPtr for being valid only if the the OUT parameter NumberOfCtrlIdx is greater 0x00. 
        If the check fails, the function shall raise the development error ETHIF_E_PARAM_POINTER.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.GetCtrlIdxList</srcid><srcstatus/><internalId>994</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>644</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00301</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The optional EthIf_GetVlanId API shall return the VlanId of the requested CtrlIdx.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest05_SwtSupport_GetVlanId</srcid><srcstatus/><internalId>1465</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>645</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00302</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service EthIf_Init 
        was previously called. If the check fails, the function shall raise the development error 
        ETHIF_E_UNINIT.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01064_GetVlanId_Uninit</srcid><srcstatus/><internalId>1290</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.DevelopmentErrors</srcid><srcstatus/><internalId>1003</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>646</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00303</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter VlanId for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_PARAM_POINTER.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01018_EthIf_GetVlanId_InvalidPtr</srcid><srcstatus/><internalId>1277</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>647</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00304</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service EthIf_Init 
        was previously called. If the check fails, the function shall raise the development error 
        ETHIF_E_UNINIT.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01068_VerifyConfig_Uninit</srcid><srcstatus/><internalId>1292</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.DevelopmentErrors</srcid><srcstatus/><internalId>1003</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>648</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00305</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function shall be compile time configurable On/Off by the configuration parameter: 
        EthIfVerifyConfigApi.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.VerifyConfig</srcid><srcstatus/><internalId>997</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>649</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00306</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service EthIf_Init 
        was previously called. If the check fails, the function shall raise the development error 
        ETHIF_E_UNINIT.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01069_SetForwardingMode_Uninit</srcid><srcstatus/><internalId>1293</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.DevelopmentErrors</srcid><srcstatus/><internalId>1003</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>650</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00307</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function shall be compile time configurable On/Off by the configuration parameter: 
        EthIfSetForwardingModeApi.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.SetForwardingMode</srcid><srcstatus/><internalId>998</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>651</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00308</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        EthIf_GetAndResetMeasurementData shall return measurement data for selected measurement index.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_T140_01_GetAndResetMeasurementData</srcid><srcstatus/><internalId>1769</internalId></linkedfrom><linkedfrom><srcid>EthIf_T340_03_GetAndResetMeasurementData</srcid><srcstatus/><internalId>1793</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest02043_GetAndResetMeasurementData_NoVLANtagFrame</srcid><srcstatus/><internalId>1924</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest02044_GetAndResetMeasurementData_VlanNoMatch</srcid><srcstatus/><internalId>1925</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.GetAndResetMeasurementData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1121</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>652</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00309</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        For measurement index ETHIF_MEAS_DROP_CRTLIDX the function shall return the number of all 
        dropped datagrams, caused by invalid CrtlIdx/VLAN. If the VLAN is not enabled, all received 
        VLAN tagged datagrams are invalid and shall be counted also.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_T140_01_GetAndResetMeasurementData</srcid><srcstatus/><internalId>1769</internalId></linkedfrom><linkedfrom><srcid>EthIf_T340_03_GetAndResetMeasurementData</srcid><srcstatus/><internalId>1793</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest02043_GetAndResetMeasurementData_NoVLANtagFrame</srcid><srcstatus/><internalId>1924</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest02044_GetAndResetMeasurementData_VlanNoMatch</srcid><srcstatus/><internalId>1925</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.GetAndResetMeasurementData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1121</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>653</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00310</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function shall return E_NOT_OK if the requested measurement index is not supported.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_T340_03_GetAndResetMeasurementData</srcid><srcstatus/><internalId>1793</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.GetAndResetMeasurementData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1121</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>654</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00312</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function shall reset all existing measurement data to 0, if MeasurementResetNeeded is true 
        and measurement index is set to ETHIF_MEAS_ALL.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_T140_01_GetAndResetMeasurementData</srcid><srcstatus/><internalId>1769</internalId></linkedfrom><linkedfrom><srcid>EthIf_T340_03_GetAndResetMeasurementData</srcid><srcstatus/><internalId>1793</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest02043_GetAndResetMeasurementData_NoVLANtagFrame</srcid><srcstatus/><internalId>1924</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.GetAndResetMeasurementData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1121</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>655</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00313</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        All measurement data which counts data shall not overrun.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/EthIf.c.m4_7281</srcid><srcstatus/><internalId>1066</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_T140_02_DropData_MaxCounterValue</srcid><srcstatus/><internalId>1770</internalId></linkedfrom><linkedfrom><srcid>EthIf_T340_04_DropData_MaxCounterValue</srcid><srcstatus/><internalId>1794</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest02043_GetAndResetMeasurementData_NoVLANtagFrame</srcid><srcstatus/><internalId>1924</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest02045_GetAndResetMeasurementData_EthertypeNoMatch</srcid><srcstatus/><internalId>1926</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest02046_GetAndResetMeasurementData_DoubleVLANTag</srcid><srcstatus/><internalId>1927</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.GetAndResetMeasurementData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1121</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>656</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00314</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function shall accept NULL_PTR. In this case the measurement data shall not be copied.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_T340_03_GetAndResetMeasurementData</srcid><srcstatus/><internalId>1793</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.GetAndResetMeasurementData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1121</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>657</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00316</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function shall be pre compile time configurable On/Off by the configuration parameter: 
        EthIfGetAndResetMeasurementDataApi.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompileTest_01</srcid><srcstatus/><internalId>1237</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.GetAndResetMeasurementData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1121</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>658</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00317</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If the VLAN is not active the Ethernet Interface shall increment the corresponding measurement 
        data and filter the message.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_T140_01_GetAndResetMeasurementData</srcid><srcstatus/><internalId>1769</internalId></linkedfrom><linkedfrom><srcid>EthIf_T340_05_GetAndResetMeasurementData_EthIfCtrlDown</srcid><srcstatus/><internalId>1795</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.GetAndResetMeasurementData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1121</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>659</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00319</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: The function shall check that the service EthIf_Init 
        was previously called. If the check fails, the function shall raise the development error 
        ETHIF_E_NOTINIT and return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01065_GetAndResetMeasurementData_Uninit</srcid><srcstatus/><internalId>1291</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.GetAndResetMeasurementData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1121</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>660</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00324</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_SetPhyTestMode shall forward the call to function EthTrcv_SetPhyTestMode of 
        the corresponding Ethernet Transceiver Driver (EthIfTransceiverIdx)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest04056_SetPhyTestMode_Forward_Call</srcid><srcstatus/><internalId>1429</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91016</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>735</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>661</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00325</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service EthIf_Init 
        was previously called. If the check fails, the function shall raise the development error 
        ETHIF_E_UNINIT otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <comment>
        Clarification for this requirement: The check of the input parameter is only done in
        case the default error detection is enabled. In this case the function arise a default error
        and returns with E_NOT_OK. This is according to SWS_BSW_00049.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.DevelopmentErrors</srcid><srcstatus/><internalId>1003</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>662</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00326</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter TrcvIdx for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_INV_TRCV_IDX otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <comment>
        Clarification for this requirement: The check of the input parameter is only done in
        case the default error detection is enabled. In this case the function arise a default error
        and returns with E_NOT_OK. This is according to SWS_BSW_00049.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest04045_SetPhyTestMode_InvalidTrcvIdx</srcid><srcstatus/><internalId>1418</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91016</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>735</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>663</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00327</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_SetPhyLoopbackMode shall forward the call to function 
        EthTrcv_SetPhyLoopbackMode of the corresponding Ethernet Transceiver Driver (
        EthIfTransceiverIdx)
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest04057_SetPhyLoopbackMode_Forward_Call</srcid><srcstatus/><internalId>1430</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91018</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>737</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>664</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00328</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service EthIf_Init 
        was previously called. If the check fails, the function shall raise the development error 
        ETHIF_E_UNINIT otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.DevelopmentErrors</srcid><srcstatus/><internalId>1003</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>665</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00329</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter TrcvIdx for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_INV_TRCV_IDX otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest04046_SetPhyLoopbackMode_InvalidTrcvIdx</srcid><srcstatus/><internalId>1419</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91018</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>737</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>666</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00330</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_GetCableDiagnosticsResult shall forward the call to function 
        EthTrcv_GetCableDiagnosticsResult of the corresponding Ethernet Transceiver Driver (
        EthIfTransceiverIdx)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest04059_GetCableDiagnosticsResult_Forward_Call</srcid><srcstatus/><internalId>1432</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91014</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>734</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>667</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00331</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service EthIf_Init 
        was previously called. If the check fails, the function shall raise the development error 
        ETHIF_E_UNINIT otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <comment>
        Clarification for this requirement: The check of the input parameter is only done in
        case the default error detection is enabled. In this case the function arise a default error
        and returns with E_NOT_OK. This is according to SWS_BSW_00049.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.DevelopmentErrors</srcid><srcstatus/><internalId>1003</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>668</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00332</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter TrcvIdx for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_INV_TRCV_IDX otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <comment>
        Clarification for this requirement: The check of the input parameter is only done in
        case the default error detection is enabled. In this case the function arise a default error
        and returns with E_NOT_OK. This is according to SWS_BSW_00049.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest04048_GetCableDiagnosticsResult_InvalidTrcvIdx</srcid><srcstatus/><internalId>1421</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91014</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>734</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>669</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00333</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter ResultPtr for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_PARAM_POINTER otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <comment>
        Clarification for this requirement: The check of the input parameter is only done in
        case the default error detection is enabled. In this case the function arise a default error
        and returns with E_NOT_OK. This is according to SWS_BSW_00049.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest04051_GetCableDiagnosticsResult_InvalidResPtr</srcid><srcstatus/><internalId>1424</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91014</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>734</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>670</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00334</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_GetPhyIdentifier shall forward the call to function EthTrcv_GetPhyIdentifier 
        of the corresponding Ethernet Transceiver Driver (EthIfTransceiverIdx)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest04060_GetPhyIdentifier_Forward_Call</srcid><srcstatus/><internalId>1433</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91020</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>738</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>671</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00335</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service EthIf_Init 
        was previously called. If the check fails, the function shall raise the development error 
        ETHIF_E_UNINIT otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <comment>
        Clarification for this requirement: The check of the input parameter is only done in
        case the default error detection is enabled. In this case the function arise a default error
        and returns with E_NOT_OK. This is according to SWS_BSW_00049.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.DevelopmentErrors</srcid><srcstatus/><internalId>1003</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>672</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00336</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter TrcvIdx for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_INV_TRCV_IDX otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <comment>
        Clarification for this requirement: The check of the input parameter is only done in
        case the default error detection is enabled. In this case the function arise a default error
        and returns with E_NOT_OK. This is according to SWS_BSW_00049.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest04049_GetPhyIdentifier_InvalidTrcvIdx</srcid><srcstatus/><internalId>1422</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91020</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>738</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>673</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00337</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter 
        OrgUniqueIdPtr for being valid. If the check fails, the function shall raise the development 
        error ETHIF_E_PARAM_POINTER otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <comment>
        Clarification for this requirement: The check of the input parameter is only done in
        case the default error detection is enabled. In this case the function arise a default error
        and returns with E_NOT_OK. This is according to SWS_BSW_00049.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest04052_GetPhyIdentifier_InvalidOUIPtr</srcid><srcstatus/><internalId>1425</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.PointerMacroChanged</srcid><srcstatus/><internalId>1005</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91020</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>738</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>674</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00338</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter ModelNrPtr 
        for being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_PARAM_POINTER otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <comment>
        Clarification for this requirement: The check of the input parameter is only done in
        case the default error detection is enabled. In this case the function arise a default error
        and returns with E_NOT_OK. This is according to SWS_BSW_00049.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.PointerMacroChanged</srcid><srcstatus/><internalId>1005</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>675</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00339</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter RevisionNrPtr 
        for being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_PARAM_POINTER otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <comment>
        Clarification for this requirement: The check of the input parameter is only done in
        case the default error detection is enabled. In this case the function arise a default error
        and returns with E_NOT_OK. This is according to SWS_BSW_00049.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest04054_GetPhyIdentifier_InvalidRevNrPtr</srcid><srcstatus/><internalId>1427</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.PointerMacroChanged</srcid><srcstatus/><internalId>1005</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91020</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>738</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>676</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00340</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The Ethernet Interface shall support Wireless Ethernet specific functionality, depending on the 
        parameter EthIfEnableWEthApi.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>677</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00341</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_GetBufWRxParams shall forward the call to function WEth_GetBufWRxParams of 
        the respective Wireless Ethernet Controller Driver.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>678</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00342</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function shall be pre compile time configurable On/Off by the configuration parameter: 
        EthIfEnableWEthApi.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>679</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00343</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service EthIf_Init 
        was previously called. If the check fails, the function shall raise the development error 
        ETHIF_E_UNINIT.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>680</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00344</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter CtrlIdx for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_INV_CTRL_IDX otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>681</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00345</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter RxParamIds 
        for being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_PARAM_POINTER.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>682</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00346</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter ParamValues 
        for being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_PARAM_POINTER.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>683</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00347</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_GetBufWTxParams shall forward the call to function WEth_GetBufWTxParams of 
        the respective Wireless Ethernet Controller Driver.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>684</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00348</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function shall be pre compile time configurable On/Off by the configuration parameter: 
        EthIfEnableWEthApi.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>685</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00349</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service EthIf_Init 
        was previously called. If the check fails, the function shall raise the development error 
        ETHIF_E_UNINIT.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>686</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00350</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter CtrlIdx for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_INV_CTRL_IDX otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>687</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00351</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter TxParamIds 
        for being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_PARAM_POINTER.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>688</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00352</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter ParamValues 
        for being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_PARAM_POINTER.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>689</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00353</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_SetBufWTxParams shall forward the call to function WEth_SetBufWTxParams of 
        the respective Wireless Ethernet Controller Driver.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>690</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00354</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function shall be pre compile time configurable On/Off by the configuration parameter: 
        EthIfEnableWEthApi.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>691</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00355</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service EthIf_Init 
        was previously called. If the check fails, the function shall raise the development error 
        ETHIF_E_UNINIT.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>692</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00356</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter CtrlIdx for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_INV_CTRL_IDX otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>693</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00357</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter BufIdx for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_INV_PARAM otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>694</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00358</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter TxParamIds 
        for being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_PARAM_POINTER.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>695</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00359</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter ParamValues 
        for being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_PARAM_POINTER.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>696</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00360</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_SetRadioParams shall forward the call to function WEthTrcv_SetRadioParams of 
        the respective Wireless Ethernet Transceiver Driver.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>697</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00361</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function shall be pre compile time configurable On/Off by the configuration parameter: 
        EthIfEnableWEthApi.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>698</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00362</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service EthIf_Init 
        was previously called. If the check fails, the function shall raise the development error 
        ETHIF_E_UNINIT.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>699</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00363</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter TrcvIdx for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_INV_TRCV_IDX otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>700</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00364</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter ParamIds for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_PARAM_POINTER.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>701</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00365</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter ParamValues 
        for being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_PARAM_POINTER.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>702</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00366</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_SetChanRxParams shall forward the call to function WEthTrcv_SetChanRxParams 
        of the respective Wireless Ethernet Transceiver Driver.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>703</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00367</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_SetChanRxParams shall be pre compile time configurable On/Off by the 
        configuration parameter: EthIfEnableWEthApi.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>704</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00368</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service EthIf_Init 
        was previously called. If the check fails, the function shall raise the development error 
        ETHIF_E_UNINIT.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>705</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00369</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter TrcvIdx for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_INV_TRCV_IDX otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>706</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00370</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter RadioIdx for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_INV_PARAM otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>707</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00371</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter RxParamIds 
        for being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_PARAM_POINTER.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>708</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00372</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter ParamValues 
        for being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_PARAM_POINTER.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>709</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00373</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_SetChanTxParams shall forward the call to function WEthTrcv_SetChanTxParams 
        of the respective Wireless Ethernet Transceiver Driver.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>710</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00374</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function shall be pre compile time configurable On/Off by the configuration parameter: 
        EthIfEnableWEthApi.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>711</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00375</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service EthIf_Init 
        was previously called. If the check fails, the function shall raise the development error 
        ETHIF_E_UNINIT.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom><linkedfrom><srcid>dev.EthIf.DevelopmentErrors</srcid><srcstatus/><internalId>1003</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>712</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00376</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter TrcvIdx for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_INV_TRCV_IDX otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>713</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00377</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter RadioIdx for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_INV_PARAM otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>714</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00378</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter TxParamIds 
        for being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_PARAM_POINTER.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>715</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00379</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter ParamValues 
        for being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_PARAM_POINTER.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>716</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00380</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_GetChanRxParams shall forward the call to function WEthTrcv_GetChanRxParams 
        of the respective Wireless Ethernet Transceiver Driver.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>717</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00381</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function shall be pre compile time configurable On/Off by the configuration parameter: 
        EthIfEnableWEthApi.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>718</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00382</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service EthIf_Init 
        was previously called. If the check fails, the function shall raise the development error 
        ETHIF_E_UNINIT.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>719</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00383</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter TrcvIdx for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_INV_TRCV_IDX otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>720</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00384</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter RadioIdx for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_INV_PARAM otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>721</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00385</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter RxParamIds 
        for being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_PARAM_POINTER.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>722</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00386</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter ParamValues 
        for being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_PARAM_POINTER.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>723</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00387</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If EthIf_SwitchEnableTimeStamping is called, the EthIf shall call EthSwt_PortEnableTimeStamp 
        for every port in the group.
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.SwitchEnableTimeStamping</srcid><srcstatus/><internalId>996</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>724</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91002</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_GetBufWRxParams 
        Syntax 
        Std_ReturnType EthIf_GetBufWRxParams (uint8 CtrlIdx, const WEth_BufWRxParamIdType* RxParamIds, 
        uint32* ParamValues, uint8 NumParams)
        Service ID [hex] | 0x32 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | CtrlIdx | Index of the Ethernet controller within the context of the Ethernet 
        Interface 
        RxParamIds | IDs of the Parameters to read 
        NumParams | Number of Parameters 
        Parameters (inout) | None 
        Parameters (out) | ParamValues | Values of the Parameters requested 
        Return value | Std_ReturnType | E_OK: success E_NOT_OK: failed reading parameters 
        Description | Read out values related to the receive direction of the transceiver for a 
        received packet. For example, this could be RSSI or Channel belonging to one single packet.
        Available via | EthIf.h
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>725</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91003</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_SetSwitchMgmtInfo 
        Syntax 
        Std_ReturnType EthIf_SetSwitchMgmtInfo (uint8 CtrlIdx, Eth_BufIdxType BufIdx, 
        EthSwt_MgmtInfoType* MgmtInfoPtr)
        Service ID [hex] | 0x38 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | CtrlIdx | Index of an Ethernet Interface controller 
        BufIdx | Ethernet Tx Buffer index 
        MgmtInfoPtr | Pointer to the management information 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | Std_ReturnType | E_OK: Management infos successfully setE_NOT_OK: Setting of 
        management infos failed 
        Description | Provides additional management information along to an Ethernet frame that 
        requires special treatment within the Switch. It has to be called between EthIf_ProvideTxBuffer(
        and EthIf_Transmit() of the related frame.
        Available via | EthIf.h
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.SwitchMgmtInfo</srcid><srcstatus/><internalId>995</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>726</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91004</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_GetPhyWakeupReason (draft)
        Syntax 
        Std_ReturnType EthIf_GetPhyWakeupReason (uint8 TrcvIdx, EthTrcv_WakeupReasonType* 
        WakeupReasonPtr)
        Service ID [hex] | 0x69 
        Sync/Async | Synchronous 
        Reentrancy | Reentrant 
        Parameters (in) | TrcvIdx | Index of the transceiver within the context of the Ethernet 
        Interface 
        Parameters (inout) | None 
        Parameters (out) | WakeupReasonPtr | Pointer to structure of least recent wakeup event, which 
        was detected by the Ethernet PHY 
        Return value | Std_ReturnType | E_OK: PHY wake up reason request hasbeen accepted.E_NOT_OK: PHY 
        wake up reason request has not been accepted.
        Description 
        This function obtains the wake up reasons of the indexed Ethernet Transceiver (PHY) by calling 
        EthTrcv_GetBusWuReason(...) Tags:atp.Status=draft 
        Available via | EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.GetPhyWakeupReason</srcid><srcstatus/><internalId>1006</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>727</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91005</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_SetPhyTxMode (draft)
        Syntax 
        Std_ReturnType EthIf_SetPhyTxMode (uint8 TrcvIdx, EthTrcv_PhyTxModeType Mode)
        Service ID [hex] | 0x13 
        Sync/Async | Synchronous 
        Reentrancy | Reentrant for different TrcvIdx. Non reentrant for the same TrcvIdx.
        Parameters (in) | TrcvIdx | Index of the transceiver within the context of the Ethernet 
        Interface 
        Mode | Transmission mode to be activated 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | Std_ReturnType | E_OK: The request has been accepted E_NOT_OK: The request has 
        not been accepted 
        Description | Activates a given transmission mode. Tags:atp.Status=draft 
        Available via | EthIf.h
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was not changed.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ComTest02</srcid><srcstatus/><internalId>1239</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_91005.ServiceId</srcid><srcstatus/><internalId>119</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00328_SetPhyTxMode</srcid><srcstatus/><internalId>120</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00390</srcid><srcstatus/><internalId>754</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>728</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91007</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_SwitchEnableTimeStamping 
        Syntax 
        Std_ReturnType EthIf_SwitchEnableTimeStamping (uint8 CtrlIdx, Eth_BufIdxType BufIdx, 
        EthSwt_MgmtInfoType* MgmtInfo)
        Service ID [hex] | 0x39 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | CtrlIdx | Index of the Ethernet controller within the context of the Ethernet 
        Interface 
        BufIdx | Index of the message buffer, where Application expects egress time stamping 
        Parameters (inout) | None 
        Parameters (out) | MgmtInfo | Management information 
        Return value | Std_ReturnType | E_OK: Time stamping on egress successfully enabledE_NOT_OK: 
        Enabling of time stamping on egress has been failed 
        Description | Activates egress time stamping on a dedicated message object, addressed by 
        CtrlIdx and BufIdx.
        Available via | EthIf.h
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.SwitchEnableTimeStamping</srcid><srcstatus/><internalId>996</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>729</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91010</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name | EthIf_MeasurementIdxType 
        Kind | Type 
        Derived from | uint8 
        Range | ETHIF_MEAS_DROP_CRTLIDX | 0x01 | Measurement index of dropped datagrams caused by 
        invalid CrtlIdx/VLAN 
        ETHIF_MEAS_RESERVED_1 | 0x02-0x7F | reserved by AUTOSAR 
        ETHIF_MEAS_RESERVED_2 | 0x80-0xEF | Vendor specific range 
        ETHIF_MEAS_RESERVED_3 | 0xF0-0xFE | reserved by AUTOSAR (future use)
        ETHIF_MEAS_ALL | 0xFF | represents all measurement indexes 
        Description | Index to select specific measurement data 
        Available via | EthIf.h
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/EthIf_Types.h_25</srcid><srcstatus/><internalId>1057</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>730</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91011</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_GetAndResetMeasurementData 
        Syntax 
        Std_ReturnType EthIf_GetAndResetMeasurementData (EthIf_MeasurementIdxType MeasurementIdx, 
        boolean MeasurementResetNeeded, uint32* MeasurementDataPtr)
        Service ID [hex] | 0x45 
        Sync/Async | Synchronous 
        Reentrancy | Reentrant 
        Parameters (in) | MeasurementIdx | Data index of measurement data 
        MeasurementResetNeeded | Flag to trigger a reset of the measurement data 
        Parameters (inout) | None 
        Parameters (out) | MeasurementDataPtr | Reference to data buffer, where to copy measurement 
        data 
        Return value | Std_ReturnType | E_OK: successfulE_NOT_OK: failed 
        Description | Allows to read and reset detailed measurement data for diagnostic purposes. Get 
        all MeasurementIdx's at once is not supported. ETHIF_MEAS_ALL shall only be used to reset all 
        MeasurementIdx's at once. A NULL_PTR shall be provided for MeasurementDataPtr in this case.
        Available via | EthIf.h
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_T140_01_GetAndResetMeasurementData</srcid><srcstatus/><internalId>1769</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.GetAndResetMeasurementData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1121</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>731</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91012</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_VerifyConfig 
        Syntax 
        Std_ReturnType EthIf_VerifyConfig (uint8 SwitchIdx, boolean* Result)
        Service ID [hex] | 0x40 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | SwitchIdx | Index of the switch within the context of the Ethernet Switch 
        Driver 
        Parameters (inout) | None 
        Parameters (out) | Result | Result of verification, TRUE: configureation verified ok, FALSE: 
        configuraton values found corrupted 
        Return value | Std_ReturnType | E_OK: Configuration verificaton succeeded, E_NOT_OK: 
        Configuration verification not succeeded.
        Description | Forwarded to EthSwt_VerifyConfig. EthSwt_VerifyConfig verifies the Switch 
        Configuration depending on the HW-Architecture, HW-capability and the intended accuracy of this 
        verification.
        Available via | EthIf.h
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.VerifyConfig</srcid><srcstatus/><internalId>997</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>732</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91013</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_SetForwardingMode 
        Syntax 
        Std_ReturnType EthIf_SetForwardingMode (uint8 SwitchIdx, boolean mode)
        Service ID [hex] | 0x41 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | SwitchIdx | Index of the switch within the context of the Ethernet Switch 
        Driver 
        mode | True Forwarding enabled, False Forwarding disabled 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | Std_ReturnType | E_OK: stopping of frame forwarding succeeded, E_NOT_OK: 
        stopping of frame forwarding not succeeded.
        Description | Verifies the Switch Configuration. If Configuration is not valid, Switch is 
        reconfigured.
        Available via | EthIf.h
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.SetForwardingMode</srcid><srcstatus/><internalId>998</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>733</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91014</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_GetCableDiagnosticsResult 
        Syntax 
        Std_ReturnType EthIf_GetCableDiagnosticsResult (uint8 TrcvIdx, EthTrcv_CableDiagResultType* 
        ResultPtr)
        Service ID [hex] | 0x14 
        Sync/Async | Synchronous 
        Reentrancy | Reentrant for different TrcvIdx. Non reentrant for the same TrcvIdx.
        Parameters (in) | TrcvIdx | Index of the transceiver within the context of the Ethernet 
        Interface 
        Parameters (inout) | None 
        Parameters (out) | ResultPtr | Pointer to the location where the cable diagnostics result shall 
        be stored 
        Return value | Std_ReturnType | E_OK: The request has been accepted E_NOT_OK: The request has 
        not been accepted 
        Description | Retrieves the cable diagnostics result of a given transceiver.
        Available via | EthIf.h
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ComTest02</srcid><srcstatus/><internalId>1239</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00331</srcid><srcstatus/><internalId>81</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_91014.ServiceId</srcid><srcstatus/><internalId>121</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00330</srcid><srcstatus/><internalId>667</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00332</srcid><srcstatus/><internalId>669</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00333</srcid><srcstatus/><internalId>670</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>734</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91016</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_SetPhyTestMode 
        Syntax 
        Std_ReturnType EthIf_SetPhyTestMode (uint8 TrcvIdx, EthTrcv_PhyTestModeType Mode)
        Service ID [hex] | 0x17 
        Sync/Async | Synchronous 
        Reentrancy | Reentrant for different TrcvIdx. Non reentrant for the same TrcvIdx.
        Parameters (in) | TrcvIdx | Index of the transceiver within the context of the Ethernet 
        Interface 
        Mode | Test mode to be activated 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | Std_ReturnType | E_OK: The request has been accepted E_NOT_OK: The request has 
        not been accepted.
        Description | Activates a given test mode.
        Available via | EthIf.h
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ComTest02</srcid><srcstatus/><internalId>1239</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00325</srcid><srcstatus/><internalId>80</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_91016.ServiceId</srcid><srcstatus/><internalId>116</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00324</srcid><srcstatus/><internalId>661</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00326</srcid><srcstatus/><internalId>663</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>735</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91017</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_SetBufWTxParams 
        Syntax 
        Std_ReturnType EthIf_SetBufWTxParams (uint8 CtrlIdx, Eth_BufIdxType BufIdx, const 
        WEth_BufWTxParamIdType* TxParamIds, const uint32* ParamValues, uint8 NumParams)
        Service ID [hex] | 0x33 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | CtrlIdx | Index of the Ethernet controller within the context of the Ethernet 
        Interface 
        BufIdx | Index of the buffer resource 
        TxParamIds | IDs of the Parameter that are provided to the transmit radio 
        ParamValues | Values of the Parameters that are provided to the transmit radio 
        NumParams | Number of Parameters that are provided to the transmit radio 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | Std_ReturnType | E_OK: successE_NOT_OK: failed setting parameter 
        Description | Set values related to the transmit direction of the transceiver for a specific 
        buffer (packet to be sent). For example, this can be the desired transmit power or the channel 
        belonging to one single packet.
        Available via | EthIf.h
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>736</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91018</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_SetPhyLoopbackMode 
        Syntax 
        Std_ReturnType EthIf_SetPhyLoopbackMode (uint8 TrcvIdx, EthTrcv_PhyLoopbackModeType Mode)
        Service ID [hex] | 0x12 
        Sync/Async | Synchronous 
        Reentrancy | Reentrant for different TrcvIdx. Non reentrant for the same TrcvIdx.
        Parameters (in) | TrcvIdx | Index of the transceiver within the context of the Ethernet 
        Interface 
        Mode | Loopback mode to be activated 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | Std_ReturnType | E_OK: The request has been accepted E_NOT_OK: The request has 
        not been accepted.
        Description | Activates a given loopback mode.
        Available via | EthIf.h
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ComTest02</srcid><srcstatus/><internalId>1239</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_91018.ServiceId</srcid><srcstatus/><internalId>117</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00328_SetPhyLoopbackMode</srcid><srcstatus/><internalId>118</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00327</srcid><srcstatus/><internalId>664</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00329</srcid><srcstatus/><internalId>666</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>737</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91020</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_GetPhyIdentifier 
        Syntax 
        Std_ReturnType EthIf_GetPhyIdentifier (uint8 TrcvIdx, uint32* OrgUniqueIdPtr, uint8* ModelNrPtr,
        uint8* RevisionNrPtr)
        Service ID [hex] | 0x15 
        Sync/Async | Synchronous 
        Reentrancy | Reentrant for different TrcvIdx. Non reentrant for the same TrcvIdx.
        Parameters (in) | TrcvIdx | Index of the transceiver within the context of the Ethernet 
        Interface 
        Parameters (inout) | None 
        Parameters (out) | OrgUniqueIdPtr | Pointer to the memory where the Organizationally Unique 
        Identifier shall be stored.
        ModelNrPtr | Pointer to the memory where the Manufacturer's Model Number shall be stored.
        RevisionNrPtr | Pointer to the memory where the Revision Number shall be stored.
        Return value | Std_ReturnType | E_OK: The request has been accepted E_NOT_OK: The request has 
        not been accepted 
        Description | Obtains the PHY identifier of the Ethernet Interface according to IEEE 802.3-2015 
        chapter 22.2.4.3.1 PHY Identifer.
        Available via | EthIf.h
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ComTest02</srcid><srcstatus/><internalId>1239</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00335</srcid><srcstatus/><internalId>82</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00338</srcid><srcstatus/><internalId>83</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_91020.ServiceId</srcid><srcstatus/><internalId>122</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00334</srcid><srcstatus/><internalId>671</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00336</srcid><srcstatus/><internalId>673</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00337</srcid><srcstatus/><internalId>674</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00339</srcid><srcstatus/><internalId>676</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>738</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91026</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_SetRadioParams 
        Syntax 
        Std_ReturnType EthIf_SetRadioParams (uint8 TrcvId, const WEthTrcv_SetRadioParamIdType* ParamIds,
        const uint32* ParamValue, uint8 NumParams)
        Service ID [hex] | 0x34 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | TrcvId | Index of the transceiver 
        ParamIds | IDs of the Parameters to set 
        ParamValue | Values of the Parameters to set 
        NumParams | Number of Parameters to set 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | Std_ReturnType | E_OK: success E_NOT_OK: failed writing parameters 
        Description | Set values related to a transceiver's wireless radio. For example, this could be 
        the selection of the radio settings (channel,
        Available via | EthIf.h
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>739</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91034</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_SetChanRxParams 
        Syntax 
        Std_ReturnType EthIf_SetChanRxParams (uint8 TrcvId, uint8 RadioId, const 
        WEthTrcv_SetChanRxParamIdType* ParamIds, const uint32* ParamValues, uint8 NumParams)
        Service ID [hex] | 0x35 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | TrcvId | Index of the transceiver 
        RadioId | Index of the Transceiver's Radio (including channel)
        ParamIds | IDs of the Parameters to set 
        ParamValues | Values of the Parameters to set 
        NumParams | Number of Parameters to set 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | Std_ReturnType | E_OK: success E_NOT_OK: failed writing parameters 
        Description | Set values related to the receive direction of a transceiver's wireless channel. 
        For example, this could be a channel parameter like the frequency.
        Available via | EthIf.h
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>740</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91042</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_SetChanTxParams 
        Syntax 
        Std_ReturnType EthIf_SetChanTxParams (uint8 TrcvId, uint8 RadioId, const 
        WEthTrcv_SetChanTxParamIdType* TxParamIds, const uint32* ParamValues, uint8 NumParams)
        Service ID [hex] | 0x36 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | TrcvId | Index of the transceiver 
        RadioId | Index of the Transceiver's Radio (including channel)
        TxParamIds | IDs of the Parameters to set 
        ParamValues | Values of the Parameters to set 
        NumParams | Number of Parameters to set 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | Std_ReturnType | E_OK: success E_NOT_OK: failed writing parameters 
        Description | Set values related to the transmit direction of a transceiver's wireless channel.
        For example, this could be the bitrate of a channel.
        Available via | EthIf.h
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>741</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91050</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_GetChanRxParams 
        Syntax 
        Std_ReturnType EthIf_GetChanRxParams (uint8 TrcvId, uint8 RadioId, const 
        WEthTrcv_GetChanRxParamIdType* ParamIds, uint32* ParamValues, uint8 NumParams)
        Service ID [hex] | 0x37 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | TrcvId | Index of the transceiver 
        RadioId | Index of the Transceiver's Radio (including channel)
        ParamIds | IDs of the Parameters to read 
        NumParams | Number of Parameters to read 
        Parameters (inout) | None 
        Parameters (out) | ParamValues | Values of the requested Parameters 
        Return value | Std_ReturnType | E_OK: success E_NOT_OK: failed reading parameters 
        Description | Read values related to the receive direction of the transceiver. For example, 
        this could be a Channel Busy Ratio (CBR) or the average Channel Idle Time (CIT)
        Available via | EthIf.h
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>742</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91051</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_MainFunctionRx_&lt;PriorityProcessing ShortName&gt;
        Syntax 
        void EthIf_MainFunctionRx_&lt;PriorityProcessing ShortName&gt; (void)
        Service ID [hex] | 0x42 
        Description | The function checks for new received frames at the related Ethernet controller 
        and reception queue by calling Eth_Receive() with the respective FifoIdx. EthIf_MainFunctionRx 
        shall receive frames from all FIFOs that are not assigned for processing via 
        EthIfPhysCtrlRxMainFunctionPriorityProcessing.
        Available via | EthIf_SchM.h
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest05005_MainFunctionRxPrio_Polling</srcid><srcstatus/><internalId>1436</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest05006_MainFunctionRx_Polling</srcid><srcstatus/><internalId>1437</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest05007_MainFunctionRxPrio_ETH_RECEIVED</srcid><srcstatus/><internalId>1438</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>743</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91052</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_GetVlanId 
        Syntax 
        Std_ReturnType EthIf_GetVlanId (uint8 CtrlIdx, uint16* VlanIdPtr)
        Service ID [hex] | 0x43 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | CtrlIdx | Index of the Ethernet controller within the context of the Ethernet 
        Interface 
        Parameters (inout) | None 
        Parameters (out) | VlanIdPtr | Pointer to store the VLAN identifier (VID) of the Ethernet 
        controller. 0 if the the Ethernet controller represents no virtual network (VLAN)
        Return value | Std_ReturnType | E_OK: successE_NOT_OK: failure 
        Description | Returns the VLAN identifier of the requested Ethernet controller.
        Available via | EthIf.h
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest05_SwtSupport_GetVlanId</srcid><srcstatus/><internalId>1465</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/EthIf.c.m4_4076</srcid><srcstatus/><internalId>1063</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>744</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91053</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_GetCtrlIdxList 
        Syntax 
        Std_ReturnType EthIf_GetCtrlIdxList (uint8* NumberOfCtrlIdx, uint8* CtrlIdxListPtr)
        Service ID [hex] | 0x44 
        Sync/Async | Asynchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | None 
        Parameters (inout) | NumberOfCtrlIdx | in: maximum number of controllers in CtrlIdxListPtr, 0 
        to return the number of controllers but without filling CtrlIdxListPtr. out: number of active 
        controllers.
        Parameters (out) | CtrlIdxListPtr | List of active controller indexes 
        Return value | Std_ReturnType | E_OK: successE_NOT_OK: failure 
        Description | Returns the number and index of all active Ethernet controllers.
        Available via | EthIf.h
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.GetCtrlIdxList</srcid><srcstatus/><internalId>994</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>745</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91101</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name | EthIf_SwitchPortGroupIdxType 
        Kind | Type 
        Derived from | uint8 
        Range | 0..255 
        Description | Data Type that represents the Ethernet interface switch port group index. The 
        index is zero based and unique for every configured switch port group.
        Available via | EthIf.h
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/EthIf_Types.h_26</srcid><srcstatus/><internalId>1058</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.SwitchPortGroup</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1117</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>746</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91102</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_SwitchPortGroupRequestMode 
        Syntax 
        Std_ReturnType EthIf_SwitchPortGroupRequestMode (EthIf_SwitchPortGroupIdxType PortGroupIdx, 
        Eth_ModeType PortMode)
        Service ID [hex] | 0x06 
        Sync/Async | Asynchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | PortGroupIdx | Index of the port group within the context of the Ethernet 
        Interface 
        PortMode | ETH_MODE_DOWN: disable the Ethernet switch port group ETH_MODE_ACTIVE: enable the 
        Ethernet switch port group ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST: enable the port group and 
        request for a wake-up on the network 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | Std_ReturnType | E_OK: successE_NOT_OK: port group mode could not be changed 
        Description | Request a mode for the EthIfSwtPortGroup. The call shall be forwarded to EthSwt 
        by calling EthSwt_SetSwitchPortMode for all EthSwtPorts referenced by the port group.
        Available via | EthIf.h
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06003_SwitchPortGroupRequestMode</srcid><srcstatus/><internalId>1472</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06012_SwitchPortGroup_SetSwitchPortMode_NOK</srcid><srcstatus/><internalId>1479</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>747</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91103</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_StartAllPorts 
        Syntax 
        Std_ReturnType EthIf_StartAllPorts (void)
        Service ID [hex] | 0x07 
        Sync/Async | Asynchronous 
        Reentrancy | Reentrant 
        Parameters (in) | None 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | Std_ReturnType | E_OK: Request was acceptedE_NOT_OK: Request was rejected 
        Description | Request to set all configured and affected EthSwtPorts to ETH_MODE_ACTIVE 
        Available via | EthIf.h
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06004_StartAllPorts</srcid><srcstatus/><internalId>1473</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>748</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91104</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_MainFunctionState 
        Syntax 
        void EthIf_MainFunctionState (void)
        Service ID [hex] | 0x05 
        Sync/Async | Asynchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | None 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | The function is polling different communication hardware (Ethernet transceiver, 
        Ethernet switch ports) related information, e.g. link state, signal quality.
        Available via | EthIf_SchM.h
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_MainFunctionRx_PollEthTrcvLinkState</srcid><srcstatus/><internalId>129</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange</srcid><srcstatus/><internalId>130</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange_MultipleUL</srcid><srcstatus/><internalId>131</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange.NoRef</srcid><srcstatus/><internalId>379</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>749</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00076</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfEnableSignalQualityApi
        Parameter Type: Boolean
        Parent Containers: EthIfGeneral,
        Description: Enable/disable the APIs read and clear the signal quality.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.1</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>750</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00077</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfSignalQualityCheckPeriod
        Parameter Type: FloatValue
        Parent Containers: EthIfGeneral,
        Description: Specifies the period in units of seconds in which the signal quality it polled in 
        the context of EthIf_MainfunctionState. The value shall be an integral multiple of 
        EthIfMainFunctionStatePeriod.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NewConfigParam</srcid><srcstatus/><internalId>1007</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>751</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00388</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_SetPhyTxMode shall forward the call to function EthTrcv_SetPhyTxMode of the 
        corresponding Ethernet Transceiver Driver (EthIfTransceiverIdx)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest04058_SetPhyTxMode_Forward_Call</srcid><srcstatus/><internalId>1431</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>752</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00389</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service EthIf_Init 
        was previously called. If the check fails, the function shall raise the development error 
        ETHIF_E_UNINIT otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.DevelopmentErrors</srcid><srcstatus/><internalId>1003</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>753</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00390</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter TrcvIdx for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_INV_TRCV_IDX otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest04047_SetPhyTxMode_InvalidTrcvIdx</srcid><srcstatus/><internalId>1420</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>728</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>754</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00391</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_GetTrcvSignalQuality shall forward the call to function 
        EthTrcv_GetPhySignalQuality of the corresponding Ethernet Transceiver Driver (TrcvIdx)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest02038_GetTrcvSignalQuality</srcid><srcstatus/><internalId>1919</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>755</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00392</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service EthIf_Init 
        was previously called. If the check fails, the function shall raise the development error 
        ETHIF_E_UNINIT otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest04038_GetTrcvSignalQuality_Uninit</srcid><srcstatus/><internalId>1411</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91056</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>775</internalId></provcov>
        <provcov>
          <linksto>EthIf.dsn.Func.LinkQuality</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1119</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>756</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00393</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter TrcvIdx for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_INV_TRCV_IDX otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <comment>
        Clarification for this requirement: The check of the input parameter is only done in
        case the default error detection is enabled. In this case the function arise a default error
        and returns with E_NOT_OK. This is according to SWS_BSW_00049.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest04044_GetTrcvSignalQuality_InvalidTrcvIdx</srcid><srcstatus/><internalId>1417</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91056</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>775</internalId></provcov>
        <provcov>
          <linksto>EthIf.dsn.Func.LinkQuality</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1119</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>757</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00394</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter ResultPtr for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_PARAM_POINTER otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest04050_GetTrcvSignalQuality_InvalidResultPtr</srcid><srcstatus/><internalId>1423</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91056</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>775</internalId></provcov>
        <provcov>
          <linksto>EthIf.dsn.Func.LinkQuality</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1119</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>758</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00395</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_GetSwitchPortSignalQuality shall forward the call to function 
        EthSwt_GetPortSignalQuality of the corresponding Ethernet Switch Driver (SwitchIdx)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06018_PortLinkState_ModeStateNotSet</srcid><srcstatus/><internalId>1486</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06021_GetSwitchPortSignalQuality</srcid><srcstatus/><internalId>1491</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91058</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>777</internalId></provcov>
        <provcov>
          <linksto>EthIf.dsn.Func.LinkQuality</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1119</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>759</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00396</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service EthIf_Init 
        was previously called. If the check fails, the function shall raise the development error 
        ETHIF_E_UNINIT otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06000_GetSwitchPortSignalQuality_Uninit</srcid><srcstatus/><internalId>1507</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91058</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>777</internalId></provcov>
        <provcov>
          <linksto>EthIf.dsn.Func.LinkQuality</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1119</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>760</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00397</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter SwitchIdx for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_INV_SWT_IDX otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06022_GetSwitchPortSignalQuality_InvPort</srcid><srcstatus/><internalId>1492</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06000_GetSwitchPortSignalQuality_InvSwtIdx</srcid><srcstatus/><internalId>1508</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91058</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>777</internalId></provcov>
        <provcov>
          <linksto>EthIf.dsn.Func.LinkQuality</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1119</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>761</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00399</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter ResultPtr for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_PARAM_POINTER otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06000_GetSwitchPortSignalQuality_InvalidResultPtr</srcid><srcstatus/><internalId>1509</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91058</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>777</internalId></provcov>
        <provcov>
          <linksto>EthIf.dsn.Func.LinkQuality</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1119</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>762</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00400</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_ClearTrcvSignalQuality shall clear the stored signal quality values of the
        EthIfTransceiver given by TrcvIdx.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest02038_GetTrcvSignalQuality</srcid><srcstatus/><internalId>1919</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>763</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00401</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service EthIf_Init 
        was previously called. If the check fails, the function shall raise the development error 
        ETHIF_E_UNINIT otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06000_ClearTrcvSignalQuality_Uninit</srcid><srcstatus/><internalId>1512</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91059</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>778</internalId></provcov>
        <provcov>
          <linksto>EthIf.dsn.Func.LinkQuality</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1119</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>764</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00402</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter SwitchIdx for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_INV_TRCV_IDX otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06000_ClearTrcvSignalQuality_InvalidTrcvIdx</srcid><srcstatus/><internalId>1513</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest02039_GetTrcvSignalQuality_InvPort</srcid><srcstatus/><internalId>1920</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91059</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>778</internalId></provcov>
        <provcov>
          <linksto>EthIf.dsn.Func.LinkQuality</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1119</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>765</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00404</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_ClearSwitchPortSignalQuality shall clear the stored signal quality values  
        of the EthSwtPort given by SwitchIdx and SwitchPortIdx.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06021_GetSwitchPortSignalQuality</srcid><srcstatus/><internalId>1491</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>766</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00405</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service EthIf_Init 
        was previously called. If the check fails, the function shall raise the development error 
        ETHIF_E_UNINIT otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06000_ClearSwitchPortSignalQuality_Uninit</srcid><srcstatus/><internalId>1510</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91060</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>779</internalId></provcov>
        <provcov>
          <linksto>EthIf.dsn.Func.LinkQuality</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1119</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>767</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00406</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter SwitchIdx for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_INV_SWT_IDX otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06022_GetSwitchPortSignalQuality_InvPort</srcid><srcstatus/><internalId>1492</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06000_ClearSwitchPortSignalQuality_InvSwtIdx</srcid><srcstatus/><internalId>1511</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91060</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>779</internalId></provcov>
        <provcov>
          <linksto>EthIf.dsn.Func.LinkQuality</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1119</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>768</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00407</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_MainFunctionState shall poll Ethernet communication hardware related 
        information with the period of EthIfMainFunctionStatePeriod.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.MainFunctionState</srcid><srcstatus/><internalId>1008</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>769</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00408</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        For each Ethernet switch port where a link state ETHTRCV_LINK_STATE_ACTIVE is yielded and 
        references an Ethernet Transceiver the function shall poll the signal quality by calling 
        EthSwt_GetPortSignalQuality(
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.MainFunctionState</srcid><srcstatus/><internalId>1008</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>770</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00409</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        For each Ethernet transceiver where a link state of ETHTRCV_LINK_STATE_ACTIVE is yielded the 
        function shall poll the signal quality by calling EthTrcv_GetPhySignalQuality(
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.MainFunctionState</srcid><srcstatus/><internalId>1008</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>771</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00410</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The obtained signal quality value shall be stored as type of EthIf_SignalQualityResultType. The 
        value shall always be stored as ActualSignalQuality. If the obtained signal quality is higher 
        than the stored highest signal quality (HighestSignalQuality), then HighestSignalQuality shall 
        be updated with the obtained signal quality. If the obtained signal quality is lower than the 
        lowest signal quality (LowestSignalQuality), then LowestSignalQuality shall be updated with the 
        obtained signal quality.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.MainFunctionState</srcid><srcstatus/><internalId>1008</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>772</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91054</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_GetBufWTxParams 
        Syntax 
        Std_ReturnType EthIf_GetBufWTxParams (uint8 CtrlIdx, const WEth_BufWTxParamIdType* TxParamIds, 
        uint32* ParamValues, uint8 NumParams)
        Service ID [hex] | 0x31 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | CtrlIdx | Index of the Ethernet controller within the context of the Ethernet 
        Interface 
        TxParamIds | IDs of the Parameter that are requested 
        NumParams | Number of Parameters that are requested 
        Parameters (inout) | None 
        Parameters (out) | ParamValues | Values of the Parameters requested 
        Return value | Std_ReturnType | E_OK: success E_NOT_OK: failed reading parameters 
        Description | Read out values related to the transmit direction of the transceiver for a 
        transmitted packet. For example, this could be transaction ID belonging to one single packet.
        Available via | EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.WirelessEthernet</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>773</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91055</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_SwitchPortModeIndication 
        Syntax 
        void EthIf_SwitchPortModeIndication (uint8 SwitchIdx, uint8 SwitchPortIdx, Eth_ModeType 
        PortMode)
        Service ID [hex] | 0x46 
        Sync/Async | Asynchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | SwitchIdx | Index of the switch within the context of the Ethernet Switch 
        Driver 
        SwitchPortIdx | Index of the port at the addressed switch.
        PortMode | Notified Ethernet Switch port mode.
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | The EthIf shall determine the expected notifications based on the EthSwtPort 
        configuration. In case the EthSwtPort references an EthTrcv the EthIf expects a notification 
        from the EthTrcv via API EthIf_TrcvModeIndication(). Otherwise the EthIf expects a notification 
        from the EthSwt via API EthIf_SwitchPortModeIndication(
        Available via | EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SwitchPortModeIndication</srcid><srcstatus/><internalId>1009</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>774</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91056</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_GetTrcvSignalQuality 
        Syntax 
        Std_ReturnType EthIf_GetTrcvSignalQuality (uint8 TrcvIdx, EthIf_SignalQualityResultType* 
        ResultPtr)
        Service ID [hex] | 0x18 
        Sync/Async | Synchronous 
        Reentrancy | Reentrant for different TrcvIdx. Non reentrant for the same TrcvIdx.
        Parameters (in) | TrcvIdx | Index of the transceiver within the context of the Ethernet 
        Interface 
        Parameters (inout) | None 
        Parameters (out) | ResultPtr | Pointer to the memory where the signal quality in percent shall 
        be stored.
        Return value | Std_ReturnType | E_OK: The signal quality retrieved successfullyE_NOT_OK: The 
        signal quality not retrieved successfully 
        Description | Retrieves the signal quality of the link of the given Ethernet transceiver 
        Available via | EthIf.h
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompTest_05_ServiceId_ErrorId</srcid><srcstatus/><internalId>1242</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest02038_GetTrcvSignalQuality</srcid><srcstatus/><internalId>1919</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest02040_GetTrcvSignalQuality_NOK</srcid><srcstatus/><internalId>1921</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.EB.GetTrcvSignalQuality.Configurable</srcid><srcstatus/><internalId>271</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00392</srcid><srcstatus/><internalId>756</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00393</srcid><srcstatus/><internalId>757</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00394</srcid><srcstatus/><internalId>758</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.LinkQuality</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1119</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>775</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91057</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name | EthIf_SignalQualityResultType 
        Kind | Structure 
        Elements | HighestSignalQuality 
        Type | uint32 
        Comment | the highest signal quality of a link since last clear 
        LowestSignalQuality 
        Type | uint32 
        Comment | the lowest link signal quality of a link since last clear 
        ActualSignalQuality 
        Type | uint32 
        Comment | the actual signal quality 
        Description 
        Available via | EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/EthIf_Types.h_27</srcid><srcstatus/><internalId>1059</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>776</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91058</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_GetSwitchPortSignalQuality 
        Syntax 
        Std_ReturnType EthIf_GetSwitchPortSignalQuality (uint8 SwitchIdx, uint8 SwitchPortIdx, 
        EthIf_SignalQualityResultType* ResultPtr)
        Service ID [hex] | 0x1a 
        Sync/Async | Synchronous 
        Reentrancy | Reentrant for different Ethernet switch indexes and Ethernet Switch port indexes. 
        Non reentrant for the same SwitchPortIdx.
        Parameters (in) | SwitchIdx | Index of the Ethernet switch within the context of the Ethernet 
        Interface 
        SwitchPortIdx | Index of the Ethernet switch port within the context of the Ethernet Interface 
        Parameters (inout) | None 
        Parameters (out) | ResultPtr | Pointer to the memory where the signal quality in percent shall 
        be stored.
        Return value | Std_ReturnType | E_OK: The signal quality retrieved successfullyE_NOT_OK: The 
        signal quality not retrieved successfully 
        Description | Retrieves the signal quality of the link of the given Ethernet switch port 
        Available via | EthIf.h
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ComTest04</srcid><srcstatus/><internalId>1241</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06026_GetSwitchPortSignalQuality_NOK</srcid><srcstatus/><internalId>1496</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.SWS_EthIf_00395</srcid><srcstatus/><internalId>759</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00396</srcid><srcstatus/><internalId>760</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00397</srcid><srcstatus/><internalId>761</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00399</srcid><srcstatus/><internalId>762</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.LinkQuality</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1119</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>777</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91059</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_ClearTrcvSignalQuality 
        Syntax 
        Std_ReturnType EthIf_ClearTrcvSignalQuality (uint8 TrcvIdx)
        Service ID [hex] | 0x19 
        Sync/Async | Synchronous 
        Reentrancy | Reentrant for different TrcvIdx. Non reentrant for the same TrcvIdx.
        Parameters (in) | TrcvIdx | Index of the transceiver within the context of the Ethernet 
        Interface 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | Std_ReturnType | E_OK: The signal quality cleared successfullyE_NOT_OK: The 
        signal quality cleared not successfully 
        Description | Clear the stored signal quality of the link of the given Ethernet transceiver 
        Available via | EthIf.h
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest02038_GetTrcvSignalQuality</srcid><srcstatus/><internalId>1919</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.SWS_EthIf_00401</srcid><srcstatus/><internalId>764</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00402</srcid><srcstatus/><internalId>765</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.LinkQuality</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1119</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>778</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91060</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_ClearSwitchPortSignalQuality 
        Syntax 
        Std_ReturnType EthIf_ClearSwitchPortSignalQuality (uint8 SwitchIdx, uint8 SwitchPortIdx)
        Service ID [hex] | 0x1b 
        Sync/Async | Synchronous 
        Reentrancy | Reentrant for different Ethernet switch indexes and Ethernet Switch port indexes. 
        Non reentrant for the same SwitchPortIdx.
        Parameters (in) | SwitchIdx | Index of the Ethernet switch within the context of the Ethernet 
        Interface 
        SwitchPortIdx | Index of the Ethernet switch port within the context of the Ethernet Interface 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | Std_ReturnType | E_OK: The signal quality cleared successfullyE_NOT_OK: The 
        signal quality cleared not successfully 
        Description | Clear the stored signal quality of the link of the given Ethernet switch port 
        Available via | EthIf.h
      </description>
      <comment>
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ComTest04</srcid><srcstatus/><internalId>1241</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06021_GetSwitchPortSignalQuality</srcid><srcstatus/><internalId>1491</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.SWS_EthIf_00405</srcid><srcstatus/><internalId>767</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00406</srcid><srcstatus/><internalId>768</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.LinkQuality</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1119</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>779</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00411</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If EthIf_SetController is called for an EthIfController with ETH_MODE_ACTIVE and this 
        EthIfController has a reference to an EthIfSwitchPortGroup of type "control" and EthIf validate 
        to call EthSwt_SetSwitchPortMode with ETH_MODE_ACTIVE  for a Ethernet switch port, then EthIf 
        shall also call function EthSwt_PortLinkStateRequest with ETHTRCV_LINK_STATE_ACTIVE for that 
        Ethernet switch port.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.Obsolete</srcid><srcstatus/><internalId>1010</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>780</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00412</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If EthIf_SetController is called for an EthIfController with ETH_MODE_DOWN and this 
        EthIfController has a reference to an EthIfSwitchPortGroup of type "control" and EthIf validate 
        to call EthSwt_SetSwitchPortMode with ETH_MODE_DOWN  for a Ethernet switch port, then EthIf 
        shall also call function EthSwt_PortLinkStateRequest with ETHTRCV_LINK_STATE_DOWN for that 
        Ethernet switch port.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.Obsolete</srcid><srcstatus/><internalId>1010</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>781</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00413</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        In the context of EthIf_CtrlModeIndication the function EthTrcv_TransceiverLinkStateRequest 
        shall be called if the EthIfController has a reference to a EthIfTransceiver. If 
        EthIfController was called with ETH_MODE_ACTIVE, then EthTrcv_TransceiverLinkStateRequest shall 
        be called with ETHTRCV_LINK_STATE_ACTIVE. If EthIfController was called with ETH_MODE_DOWN, 
        then EthTrcv_TransceiverLinkStateRequest shall be called with ETHTRCV_LINK_STATE_DOWN.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.Obsolete</srcid><srcstatus/><internalId>1010</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>782</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91105</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_GetRxMgmtObject 
        Syntax 
        Std_ReturnType EthIf_GetRxMgmtObject (uint8 CtrlIdx, Eth_DataType* DataPtr, 
        EthSwt_MgmtObjectType **MgmtObjectPtr)
        Service ID [hex] | 0x47 
        Sync/Async | Synchronous 
        Reentrancy | Reentrant 
        Parameters (in) | CtrlIdx | Index of an Ethernet Interface controller 
        DataPtr | Ethernet data pointer 
        Parameters (inout) | None 
        Parameters (out) | **MgmtObjectPtr | MgmtObjectPtr Pointer to the management object 
        Return value | Std_ReturnType | E_OK: successE_NOT_OK: management object could not be obtained 
        Description | Request the MgmtObject of the (in this context) unique DataPtr.
        Available via | EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.GetRxMgmtObject</srcid><srcstatus/><internalId>1011</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>783</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91106</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_GetTxMgmtObject 
        Syntax 
        Std_ReturnType EthIf_GetTxMgmtObject (uint8 CtrlIdx, Eth_BufIdxType BufIdx, 
        EthSwt_MgmtObjectType **MgmtObjectPtr)
        Service ID [hex] | 0x48 
        Sync/Async | Synchronous 
        Reentrancy | Reentrant 
        Parameters (in) | CtrlIdx | Index of an Ethernet Interface controller 
        BufIdx | Ethernet Rx Buffer index 
        Parameters (inout) | None 
        Parameters (out) | **MgmtObjectPtr | Pointer to the management object 
        Return value | Std_ReturnType | E_OK: successE_NOT_OK: management object could not be obtained 
        Description | Request the MgmtObject of the (in this context) unique BufIdx.
        Available via | EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.GetTxMgmtObject</srcid><srcstatus/><internalId>1012</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>784</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00415</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_GetSwitchPortMode shall forward the call to function 
        EthSwt_GetSwitchPortMode of the corresponding Ethernet Switch Driver (EthIfSwitchIdx)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.GetSwitchPortMode</srcid><srcstatus/><internalId>1013</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>785</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00417</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_GetTransceiverMode shall forward the call to function 
        EthTrcv_GetTransceiverMode of the corresponding Ethernet Transceiver Driver (
        EthIfTransceiverIdx)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.GetTransceiverMode</srcid><srcstatus/><internalId>1014</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>786</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00419</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_SwitchPortGetLinkState shall forward the call to function 
        EthSwt_GetLinkState of the corresponding Ethernet Switch Driver (EthIfSwitchIdx)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SwitchPortGetLinkState</srcid><srcstatus/><internalId>1015</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>787</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00421</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_TransceiverGetLinkState shall forward the call to function 
        EthTrcv_GetLinkState of the corresponding Ethernet Transceiver Driver (EthIfTransceiverIdx)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.TransceiverGetLinkState</srcid><srcstatus/><internalId>1016</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>788</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00423</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_SwitchPortGetBaudRate shall forward the call to function EthSwt_GetBaudRate 
        of the corresponding Ethernet Switch Driver (EthIfSwitchIdx)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SwitchPortGetBaudRate</srcid><srcstatus/><internalId>1017</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>789</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00426</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_TransceiverGetBaudRate shall forward the call to function 
        EthTrcv_GetBaudRate of the corresponding Ethernet Transceiver Driver (EthIfTransceiverIdx)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.TransceiverGetBaudRate</srcid><srcstatus/><internalId>1018</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>790</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00428</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_SwitchPortGetDuplexMode shall forward the call to function 
        EthSwt_GetDuplexMode of the corresponding Ethernet Switch Driver (EthIfSwitchIdx)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SwitchPortGetDuplexMode</srcid><srcstatus/><internalId>1019</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>791</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00430</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_TransceiverGetDuplexMode shall forward the call to function 
        EthTrcv_GetDuplexMode of the corresponding Ethernet Transceiver Driver (EthIfTransceiverIdx)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.TransceiverGetDuplexMode</srcid><srcstatus/><internalId>1020</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>792</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00432</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_SwitchPortGetCounterValues shall forward the call to function 
        EthSwt_GetCounterValues of the corresponding Ethernet Switch Driver (EthIfSwitchIdx)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SwitchPortGetCounterValues</srcid><srcstatus/><internalId>1021</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>793</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00434</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_SwitchPortGetRxStats shall forward the call to function EthSwt_GetRxStats of 
        the corresponding Ethernet Switch Driver (EthIfSwitchIdx)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SwitchPortGetRxStats</srcid><srcstatus/><internalId>1022</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>794</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00436</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_SwitchPortGetTxStats shall forward the call to function EthSwt_GetTxStats of 
        the corresponding Ethernet Switch Driver (EthIfSwitchIdx)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SwitchPortGetTxStats</srcid><srcstatus/><internalId>1023</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>795</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00438</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_SwitchPortGetTxErrorCounterValues shall forward the call to function 
        EthSwt_GetTxErrorCounterValues of the corresponding Ethernet Switch Driver (EthIfSwitchIdx)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SwitchPortGetTxErrorCounterValues</srcid><srcstatus/><internalId>1024</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>796</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00440</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_SwitchPortGetMacLearningMode shall forward the call to function 
        EthSwt_GetMacLearningMode of the corresponding Ethernet Switch Driver (EthIfSwitchIdx)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SwitchPortGetMacLearningMode</srcid><srcstatus/><internalId>1025</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>797</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00442</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_GetSwitchPortIdentifier shall forward the call to function 
        EthSwt_GetPortIdentifier of the corresponding Ethernet Switch Driver (EthIfSwitchIdx)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.GetSwitchPortIdentifier</srcid><srcstatus/><internalId>1026</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>798</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00444</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_GetSwitchIdentifier shall forward the call to function 
        EthSwt_GetSwitchIdentifier of the corresponding Ethernet Switch Driver (EthIfSwitchIdx)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.GetSwitchIdentifier</srcid><srcstatus/><internalId>1027</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>799</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00446</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_WritePortMirrorConfiguration shall forward the call to function 
        EthSwt_WritePortMirrorConfiguration of the corresponding Ethernet Switch Driver (EthIfSwitchIdx)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.WritePortMirrorConfiguration</srcid><srcstatus/><internalId>1028</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>800</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00448</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_ReadPortMirrorConfiguration shall forward the call to function 
        EthSwt_ReadPortMirrorConfiguration of the corresponding Ethernet Switch Driver (EthIfSwitchIdx)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.ReadPortMirrrorConfiguration</srcid><srcstatus/><internalId>1029</internalId></linkedfrom><linkedfrom><srcid>dev.EthIf.DeletePortMirrorConfiguration</srcid><srcstatus/><internalId>1030</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>801</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00450</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_DeletePortMirrorConfiguration shall forward the call to function 
        EthSwt_DeletePortMirrorConfiguration of the corresponding Ethernet Switch Driver (
        EthIfSwitchIdx)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.ReadPortMirrrorConfiguration</srcid><srcstatus/><internalId>1029</internalId></linkedfrom><linkedfrom><srcid>dev.EthIf.DeletePortMirrorConfiguration</srcid><srcstatus/><internalId>1030</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>802</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00452</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_GetPortMirrorState shall forward the call to function 
        EthSwt_GetPortMirrorState of the corresponding Ethernet Switch Driver (EthIfSwitchIdx)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.GetPortMirrorState</srcid><srcstatus/><internalId>1031</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>803</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00454</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_SetPortMirrorState shall forward the call to function 
        EthSwt_SetPortMirrorState of the corresponding Ethernet Switch Driver (EthIfSwitchIdx)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SetPortMirrorState</srcid><srcstatus/><internalId>1032</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>804</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00456</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_SetPortTestMode shall forward the call to function EthSwt_SetPortTestMode of 
        the corresponding Ethernet Switch Driver (EthIfSwitchIdx)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SetPortTestMode</srcid><srcstatus/><internalId>1033</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>805</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00458</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_SetPortLoopbackMode shall forward the call to function 
        EthSwt_SetPortLoopbackMode of the corresponding Ethernet Switch Driver (EthIfSwitchIdx)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SetPortLoopbackMode</srcid><srcstatus/><internalId>1034</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>806</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00460</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_SetPortTxMode shall forward the call to function EthSwt_SetPortTxMode of the 
        corresponding Ethernet Switch Driver (EthIfSwitchIdx)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SetPortTxMode</srcid><srcstatus/><internalId>1035</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>807</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00462</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_GetPortCableDiagnosticsResult shall forward the call to function 
        EthSwt_GetPortCableDiagnosticsResult of the corresponding Ethernet Switch Driver (
        EthIfSwitchIdx)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.GetPortCableDiagnosticResult</srcid><srcstatus/><internalId>1036</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>808</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00464</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If the function EthIf_RunPortCableDiagnostic is called, EthIf shall ensure that the 
        corresponding EthIfController is in mode ETH_MODE_ACTIVE and forward the call to function 
        EthSwt_RunPortCableDiagnostic of the corresponding Ethernet Switch Driver (EthIfSwitchIdx)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.RunPortCableDiagnostic</srcid><srcstatus/><internalId>1037</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>809</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00466</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If the function EthIf_RunCableDiagnostic is called, EthIf shall ensure that the corresponding 
        EthIfController is in mode ETH_MODE_ACTIVE and forward the call to function 
        EthTrcv_RunCableDiagnostic of the corresponding Ethernet Transceiver Driver (
        EthIfTransceiverIdx)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.RunCableDiagnostic</srcid><srcstatus/><internalId>1038</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>810</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00468</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_SwitchGetCfgDataRaw shall forward the call to function EthSwt_GetCfgDataRaw 
        of the corresponding Ethernet Switch Driver (EthIfSwitchIdx)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SwitchGetCfgDataRaw</srcid><srcstatus/><internalId>1039</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>811</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00470</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_SwitchGetCfgDataInfo shall forward the call to function 
        EthSwt_GetCfgDataInfo of the corresponding Ethernet Switch Driver (EthIfSwitchIdx)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SwitchGetCfgDataInfo</srcid><srcstatus/><internalId>1040</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>812</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00472</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_SwitchPortGetMaxFIFOBufferFillLevel shall forward the call to function 
        EthSwt_GetMaxFIFOBufferFillLevel of the corresponding Ethernet Switch Driver (EthIfSwitchIdx)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SwitchPortGetMaxFIFOBufferFillLevel</srcid><srcstatus/><internalId>1041</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>813</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00473</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The EthIf module shall apply appropriate mechanisms to allow calls of EthIf_GetCurrentTime API 
        from other partitions than its main function, e.g. by providing an EthIf satellite.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.GetCurrentTimeChange</srcid><srcstatus/><internalId>1042</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>814</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91107</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_GetSwitchPortMode 
        Syntax 
        Std_ReturnType EthIf_GetSwitchPortMode (uint8 SwitchIdx, uint8 SwitchPortIdx, Eth_ModeType* 
        PortModePtr)
        Service ID [hex] | 0x49 
        Sync/Async | Synchronous /Asynchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | SwitchIdx | Index of the switch within the context of the Ethernet Switch 
        Driver 
        SwitchPortIdx | Index of the port at the addressed switch 
        Parameters (inout) | None 
        Parameters (out) | PortModePtr | ETH_MODE_DOWN: The Ethernet switch port of the given Ethernet 
        switch is disabled ETH_MODE_ACTIVE: The Ethernet switch port of the given Ethernet switch is 
        enabled 
        Return value | Std_ReturnType | E_OK: successE_NOT_OK: The mode of the indexed switch port 
        could not be obtained, or the function is called in state ETHSWT_STATE_UNINIT or 
        ETHSWT_STATE_INIT.
        Description | Obtains the mode of the indexed switch port 
        Available via | EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.GetSwitchPortMode</srcid><srcstatus/><internalId>1013</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>815</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91108</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_GetTransceiverMode 
        Syntax 
        Std_ReturnType EthIf_GetTransceiverMode (uint8 TrcvIdx, Eth_ModeType* TrcvModePtr)
        Service ID [hex] | 0x4a 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | TrcvIdx | Index of the transceiver within the context of the Ethernet 
        Transceiver Driver 
        Parameters (inout) | None 
        Parameters (out) | TrcvModePtr | ETH_MODE_DOWN: the transceiver is disabled ETH_MODE_ACTIVE: 
        the transceiver is enable 
        Return value | Std_ReturnType | E_OK: successE_NOT_OK: transceiver could not be initialized 
        Description | Obtains the state of the indexed transceiver 
        Available via | EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.GetTransceiverMode</srcid><srcstatus/><internalId>1014</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>816</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91109</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_SwitchPortGetLinkState 
        Syntax 
        Std_ReturnType EthIf_SwitchPortGetLinkState (uint8 SwitchIdx, uint8 SwitchPortIdx, 
        EthTrcv_LinkStateType* LinkStatePtr)
        Service ID [hex] | 0x4b 
        Sync/Async | Synchronous /Asynchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | SwitchIdx | Index of the switch within the context of the Ethernet Switch 
        Driver 
        SwitchPortIdx | Index of the port at the addressed switch 
        Parameters (inout) | None 
        Parameters (out) | LinkStatePtr | ETHTRCV_LINK_STATE_DOWN: Switch port is disconnected 
        ETHTRCV_LINK_STATE_ACTIVE: Switch port is connected 
        Return value | Std_ReturnType | E_OK: successE_NOT_OK: Link state of the indexed switch port 
        could not be obtained, or the function is called in state ETHSWT_STATE_UNINIT or 
        ETHSWT_STATE_INIT.
        Description | Obtains the link state of the indexed switch port 
        Available via | EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SwitchPortGetLinkState</srcid><srcstatus/><internalId>1015</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>817</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91110</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_TransceiverGetLinkState 
        Syntax 
        Std_ReturnType EthIf_TransceiverGetLinkState (uint8 TrcvIdx, EthTrcv_LinkStateType* 
        LinkStatePtr)
        Service ID [hex] | 0x4c 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | TrcvIdx | Index of the transceiver within the context of the Ethernet 
        Transceiver Driver 
        Parameters (inout) | None 
        Parameters (out) | LinkStatePtr | ETHTRCV_LINK_STATE_DOWN: transceiver is disconnected 
        ETHTRCV_LINK_STATE_ACTIVE: transceiver is connected 
        Return value | Std_ReturnType | E_OK: successE_NOT_OK: transceiver could not be initialized 
        Description | Obtains the link state of the indexed transceiver 
        Available via | EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.TransceiverGetLinkState</srcid><srcstatus/><internalId>1016</internalId></linkedfrom><linkedfrom><srcid>dev.EthIf.SwitchPortGetMaxFIFOBufferFillLevel</srcid><srcstatus/><internalId>1041</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>818</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91111</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_SwitchPortGetBaudRate 
        Syntax 
        Std_ReturnType EthIf_SwitchPortGetBaudRate (uint8 SwitchIdx, uint8 SwitchPortIdx, 
        EthTrcv_BaudRateType* BaudRatePtr)
        Service ID [hex] | 0x4d 
        Sync/Async | Synchronous /Asynchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | SwitchIdx | Index of the switch within the context of the Ethernet Switch 
        Driver 
        SwitchPortIdx | Index of the port at the addressed switch 
        Parameters (inout) | None 
        Parameters (out) | BaudRatePtr | ETHTRCV_BAUD_RATE_10MBIT: 10MBit connection 
        ETHTRCV_BAUD_RATE_100MBIT: 100MBit connection ETHTRCV_BAUD_RATE_1000MBIT: 1000MBit connection 
        ETHTRCV_BAUD_RATE_2500MBIT: 2500MBit connection 
        Return value | Std_ReturnType | E_OK: successE_NOT_OK: Baud rate of the indexed switch port 
        could not be obtained, or the function is called in state ETHSWT_STATE_UNINIT or 
        ETHSWT_STATE_INIT.
        Description | Obtains the baud rate of the indexed switch port 
        Available via | EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SwitchPortGetBaudRate</srcid><srcstatus/><internalId>1017</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>819</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91112</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_TransceiverGetBaudRate 
        Syntax 
        Std_ReturnType EthIf_TransceiverGetBaudRate (uint8 TrcvIdx, EthTrcv_BaudRateType* BaudRatePtr)
        Service ID [hex] | 0x4e 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | TrcvIdx | Index of the transceiver within the context of the Ethernet 
        Transceiver Driver 
        Parameters (inout) | None 
        Parameters (out) | BaudRatePtr | ETHTRCV_BAUD_RATE_10MBIT: 10MBit connection 
        ETHTRCV_BAUD_RATE_100MBIT: 100MBit connection ETHTRCV_BAUD_RATE_1000MBIT: 1000MBit connection 
        ETHTRCV_BAUD_RATE_2500MBIT: 2500MBit connection 
        Return value | Std_ReturnType | E_OK: successE_NOT_OK: transceiver could not be initialized 
        Description | Obtains the baud rate of the indexed transceiver 
        Available via | EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.TransceiverGetBaudRate</srcid><srcstatus/><internalId>1018</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>820</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91113</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_SwitchPortGetDuplexMode 
        Syntax 
        Std_ReturnType EthIf_SwitchPortGetDuplexMode (uint8 SwitchIdx, uint8 SwitchPortIdx, 
        EthTrcv_DuplexModeType* DuplexModePtr)
        Service ID [hex] | 0x4f 
        Sync/Async | Synchronous /Asynchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | SwitchIdx | Index of the switch within the context of the Ethernet Switch 
        Driver 
        SwitchPortIdx | Index of the port at the addressed switch 
        Parameters (inout) | None 
        Parameters (out) | DuplexModePtr | ETHTRCV_DUPLEX_MODE_HALF: half duplex connections 
        ETHTRCV_DUPLEXMODE_FULL: full duplex connection 
        Return value | Std_ReturnType | E_OK: successE_NOT_OK: duplex mode of the indexed switch port 
        could not be obtained, or the function is called in state ETHSWT_STATE_UNINIT or 
        ETHSWT_STATE_INIT.
        Description | Obtains the duplex mode of the indexed switch port 
        Available via | EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SwitchPortGetDuplexMode</srcid><srcstatus/><internalId>1019</internalId></linkedfrom><linkedfrom><srcid>dev.EthIf.SwitchPortGetMaxFIFOBufferFillLevel</srcid><srcstatus/><internalId>1041</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>821</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91114</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_TransceiverGetDuplexMode 
        Syntax 
        Std_ReturnType EthIf_TransceiverGetDuplexMode (uint8 TrcvIdx, EthTrcv_DuplexModeType* 
        DuplexModePtr)
        Service ID [hex] | 0x50 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | TrcvIdx | Index of the transceiver within the context of the Ethernet 
        Transceiver Driver 
        Parameters (inout) | None 
        Parameters (out) | DuplexModePtr | ETHTRCV_DUPLEX_MODE_HALF: half duplex connections 
        ETHTRCV_DUPLEX_MODE_FULL: full duplex connection 
        Return value | Std_ReturnType | E_OK: successE_NOT_OK: transceiver could not be initialized 
        Description | Obtains the duplex mode of the indexed transceiver 
        Available via | EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.TransceiverGetDuplexMode</srcid><srcstatus/><internalId>1020</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>822</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91115</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_SwitchPortGetCounterValues 
        Syntax 
        Std_ReturnType EthIf_SwitchPortGetCounterValues (uint8 SwitchIdx, uint8 SwitchPortIdx, 
        Eth_CounterType* CounterPtr)
        Service ID [hex] | 0x51 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | SwitchIdx | Index of the switch within the context of the Ethernet Switch 
        Driver 
        SwitchPortIdx | Index of the port at the addressed switch 
        Parameters (inout) | None 
        Parameters (out) | CounterPtr | counter values according to IETF RFC 1757, RFC 1643 and RFC 
        2233.
        Return value | Std_ReturnType | E_OK: successE_NOT_OK: counter values read failure 
        Description | Reads a list with drop counter values of the corresponding port of the switch. 
        The meaning of these values is described at Eth_CounterType.
        Available via | EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SwitchPortGetCounterValues</srcid><srcstatus/><internalId>1021</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>823</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91116</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_SwitchPortGetRxStats 
        Syntax 
        Std_ReturnType EthIf_SwitchPortGetRxStats (uint8 SwitchIdx, uint8 SwitchPortIdx, 
        Eth_RxStatsType* RxStatsPtr)
        Service ID [hex] | 0x52 
        Sync/Async | Synchronous /Asynchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | SwitchIdx | Index of the switch within the context of the Ethernet Switch 
        Driver 
        SwitchPortIdx | Index of the port at the addressed switch 
        Parameters (inout) | None 
        Parameters (out) | RxStatsPtr | List of values according to IETF RFC 2819 (Remote Network 
        Monitoring Management Information Base)
        Return value | Std_ReturnType | E_OK: successE_NOT_OK: drop counter could not be obtained 
        Description | Returns a list of statistic counters defined with Eth_RxTatsType. The majority of 
        these Counters are derived from the IETF RFC2819.
        Available via | EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SwitchPortGetRxStats</srcid><srcstatus/><internalId>1022</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>824</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91117</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_SwitchPortGetTxStats 
        Syntax 
        Std_ReturnType EthIf_SwitchPortGetTxStats (uint8 SwitchIdx, uint8 SwitchPortIdx, 
        Eth_TxStatsType* TxStatsPtr)
        Service ID [hex] | 0x53 
        Sync/Async | Asynchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | SwitchIdx 
        SwitchPortIdx | Index of the port at the addressed switch 
        Parameters (inout) | None 
        Parameters (out) | TxStatsPtr | List of values to read statistic values for transmission.
        Return value | Std_ReturnType | E_OK: successE_NOTOK: Tx-statistics could not be obtained 
        Description | Returns the list of Transmission Statistics out of IETF RFC1213 defined with 
        Eth_TxStatsType, where the maximal possible value shall denote an invalid value, e.g. this 
        counter is not available.
        Available via | EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SwitchPortGetTxStats</srcid><srcstatus/><internalId>1023</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>825</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91118</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_SwitchPortGetTxErrorCounterValues 
        Syntax 
        Std_ReturnType EthIf_SwitchPortGetTxErrorCounterValues (uint8 SwitchIdx, uint8 SwitchPortIdx, 
        Eth_TxErrorCounterValuesType* TxStatsPtr)
        Service ID [hex] | 0x54 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | SwitchIdx | Index of the switch within the context of the Ethernet Switch 
        Drive 
        SwitchPortIdx | Index of the port at the addressed switch 
        Parameters (inout) | None 
        Parameters (out) | TxStatsPtr | List of values to read statistic error counter values for 
        transmission.
        Return value | Std_ReturnType | E_OK: success,E_NOTOK: Tx-statistics could not be obtained 
        Description | Returns the list of Transmission Error Counters out of IETF RFC1213 and RFC1643 
        defined with Eth_TxErrorCounterValuesType, where the maximal possible value shall denote an 
        invalid value, e.g. this counter is not available.
        Available via | EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SwitchPortGetTxErrorCounterValues</srcid><srcstatus/><internalId>1024</internalId></linkedfrom><linkedfrom><srcid>dev.EthIf.GetPortMirrorState</srcid><srcstatus/><internalId>1031</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>826</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91119</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_SwitchPortGetMacLearningMode 
        Syntax 
        Std_ReturnType EthIf_SwitchPortGetMacLearningMode (uint8 SwitchIdx, uint8 SwitchPortIdx, 
        EthSwt_MacLearningType* MacLearningModePtr)
        Service ID [hex] | 0x55 
        Sync/Async | Synchronous /Asynchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | SwitchIdx | Index of the switch within the context of the Ethernet Switch 
        Driver 
        SwitchPortIdx | Index of the port at the addressed switch 
        Parameters (inout) | None 
        Parameters (out) | MacLearningModePtr | Defines whether MAC addresses shall be learned and if 
        they shall be learned in software or hardware.
        Return value | Std_ReturnType | E_OK: successE_NOT_OK: configuration could be persistently 
        reset 
        Description | Returns the MAC learning mode, i.e. 1.) HW learning enabled, 2.) Hardware 
        learning disabled, 3.) Software learning enabled. Note: This feature is hardware dependent, i.e.
        the switch hardware needs to support the different learning modes 
        Available via | EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SwitchPortGetMacLearningMode</srcid><srcstatus/><internalId>1025</internalId></linkedfrom><linkedfrom><srcid>dev.EthIf.SwitchPortGetMaxFIFOBufferFillLevel</srcid><srcstatus/><internalId>1041</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>827</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91120</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_GetSwitchPortIdentifier 
        Syntax 
        Std_ReturnType EthIf_GetSwitchPortIdentifier (uint8 SwitchIdx, uint8 SwitchPortIdx, uint32* 
        OrgUniqueIdPtr, uint8* ModelNrPtr, uint8* RevisionNrPtr)
        Service ID [hex] | 0x56 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | SwitchIdx | Index of the switch within the context of the Ethernet Switch 
        Driver 
        SwitchPortIdx | Index of the port at the addressed switch 
        Parameters (inout) | None 
        Parameters (out) | OrgUniqueIdPtr | Pointer to the memory where the Organizationally Unique 
        Identifier (OUI) shall be stored.
        ModelNrPtr | Pointer to the memory where the Manufacturer's Model Number shall be stored.
        RevisionNrPtr | Pointer to the memory where the Revision Number shall be stored.
        Return value | Std_ReturnType | E_OK: organizationally unique identifier of the Ethernet 
        transceiver could be read.E_NOT_OK: organizationally unique identifier of the Ethernet 
        transceiver could not be obtained (i.e. OUI is not available)
        Description | This function retrieves the OUI (24 bit) of the indexed Ethernet switch port.
        Available via | EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.GetSwitchPortIdentifier</srcid><srcstatus/><internalId>1026</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>828</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91121</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_GetSwitchIdentifier 
        Syntax 
        Std_ReturnType EthIf_GetSwitchIdentifier (uint8 SwitchIdx, uint32* OrgUniqueIdPtr)
        Service ID [hex] | 0x57 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | SwitchIdx | Index of the switch within the context of the Ethernet Switch 
        Driver 
        Parameters (inout) | None 
        Parameters (out) | OrgUniqueIdPtr | Pointer to the memory where the Organizationally Unique 
        Identifier shall be stored.
        Return value | Std_ReturnType | E_OK: organizationally unique identifier of the Ethernet switch 
        could be read.E_NOT_OK: organizationally unique identifier of the Ethernet switch could not be 
        read (i.e. no OUI is available for this Ethernet switch)
        Description | Obtain the Organizationally Unique Identifier that is given by the IEEE of the 
        indexed Ethernet switch. This function shall provide the OUI of Ethernet switch. The OUI has a 
        size of 24 bit. If a ethernet switch can provide the OUI the 8 most significant bits of the OUI 
        shall be set to 0x00xxxxxx. If a Ethernet switch can not provide the OUI the 8 most significant 
        bits of the OUI shall be set to 0xFFxxxxxx.
        Available via | EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.GetSwitchIdentifier</srcid><srcstatus/><internalId>1027</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>829</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91122</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_WritePortMirrorConfiguration 
        Syntax 
        Std_ReturnType EthIf_WritePortMirrorConfiguration (uint8 MirroredSwitchIdx, const 
        EthSwt_PortMirrorCfgType* PortMirrorConfigurationPtr)
        Service ID [hex] | 0x58 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | MirroredSwitchIdx | Index of the switch within the context of the Ethernet 
        Switch Driver, where the Ethernet switch port is located, that has to be mirrored 
        PortMirrorConfigurationPtr 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | Std_ReturnType | E_OK: the port mirror configuration for the indexed Ethernet 
        switch port was written.E_NOT_OK: the port mirror configuration for the indexed Ethernet switch 
        port was not written. (i.e. indexed ethernet switch is not available)
        ETHSWT_PORT_MIRRORING_CONFIGURATION_NOT_SUPPORTED: port mirroring configuration is not 
        supported by Ethernet switch driver or by the Ethernet switch hardware 
        Description | Store the given port mirror configuration in a shadow buffer in the Ethernet 
        switch driver for the given MirroredSwitchIdx.
        Available via | EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.WritePortMirrorConfiguration</srcid><srcstatus/><internalId>1028</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>830</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91123</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_ReadPortMirrorConfiguration 
        Syntax 
        Std_ReturnType EthIf_ReadPortMirrorConfiguration (uint8 MirroredSwitchIdx, 
        EthSwt_PortMirrorCfgType* PortMirrorConfigurationPtr)
        Service ID [hex] | 0x59 
        Sync/Async | Asynchronous Asynchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | MirroredSwitchIdx | Index of the Ethernet switch within the context of the 
        Ethernet Switch Driver, where the Ethernet switch ports are located, that have to be mirrored 
        Parameters (inout) | None 
        Parameters (out) | PortMirrorConfigurationPtr | Pointer to the memory where the port 
        configuration shall be stored.
        Return value | Std_ReturnType | E_OK: the port mirror configuration for the indexed Ethernet 
        switch port was red successfully.E_NOT_OK: the port mirror configuration for the indexed 
        Ethernet switch was not red successfully. (i.e. indexed Ethernet switch is not available)
        Description | Obtain the port mirror configuration of the given Ethernet switch.
        Available via | EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.ReadPortMirrorConfiguration</srcid><srcstatus/><internalId>1043</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>831</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91124</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_DeletePortMirrorConfiguration 
        Syntax 
        Std_ReturnType EthIf_DeletePortMirrorConfiguration (uint8 MirroredSwitchIdx)
        Service ID [hex] | 0x5a 
        Sync/Async | Synchronous 
        Reentrancy | Reentrant Reentrant for different MirroredSwitchIdx. Non reentrant for the same 
        SwitchIdx.
        Parameters (in) | MirroredSwitchIdx | Index of the switch within the context of the Ethernet 
        Switch Driver.
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | Std_ReturnType | E_OK: Port mirror configuration was deleted 
        successfullyE_NOT_OK: Port mirror configuration was not deleted successfully. (e.g. the port 
        mirroring is enabled)
        Description | Delete the stored port mirror configuration of the given MirroredSwitchIdx. If no 
        port mirror configuration was found for the given MirroredSwitchIdx, the return value shall be 
        E_OK.
        Available via | EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.GetSwitchPortMode</srcid><srcstatus/><internalId>1013</internalId></linkedfrom><linkedfrom><srcid>dev.EthIf.ReadPortMirrrorConfiguration</srcid><srcstatus/><internalId>1029</internalId></linkedfrom><linkedfrom><srcid>dev.EthIf.DeletePortMirrorConfiguration</srcid><srcstatus/><internalId>1030</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>832</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91125</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_GetPortMirrorState 
        Syntax 
        Std_ReturnType EthIf_GetPortMirrorState (uint8 SwitchIdx, uint8 PortIdx, 
        EthSwt_PortMirrorStateType* PortMirrorStatePtr)
        Service ID [hex] | 0x5b 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | SwitchIdx | Index of the switch within the context of the Ethernet Switch 
        Driver 
        PortIdx | Index of the port at the addressed switch 
        Parameters (inout) | None 
        Parameters (out) | PortMirrorStatePtr | Pointer to the memory where the port mirroring state (
        either PORT_MIRRORING_ENABLED or PORT_MIRRORING_DISABLED)of the given Ethernet switch port 
        shall be stored.
        Return value | Std_ReturnType | E_OK: the port mirroring state for the indexed Ethernet switch 
        port returned successfully.E_NOT_OK: the port mirror configuration for the indexed Ethernet 
        switch returned not successfully. (i.e. indexed ethernet switch port is not available)
        Description | Obtain the current status of the port mirroring for the indexed Ethernet switch 
        port 
        Available via | EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.GetPortMirrorState</srcid><srcstatus/><internalId>1031</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>833</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91126</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_SetPortMirrorState 
        Syntax 
        Std_ReturnType EthIf_SetPortMirrorState (uint8 MirroredSwitchIdx, uint8 PortIdx, 
        EthSwt_PortMirrorStateType PortMirrorState)
        Service ID [hex] | 0x5c 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | MirroredSwitchIdx | Index of the Ethernet switch within the context of the 
        Ethernet Switch Driver, where the port mirroring configuration is located that has to be 
        enabled and disabled, repectively.
        PortIdx | Index of the port at the addressed switch 
        PortMirrorState | Contain the requested port mirroring state either PORT_MIRRORING_ENABLED or 
        PORT_MIRRORING_DISABLED 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | Std_ReturnType | Std_ReturnType E_OK: the requested port mirroring state for the 
        indexed Ethernet switch port was set successfully.E_NOT_OK: the requested port mirroring state 
        for the indexed Ethernet switch was not set successfully. (i.e. indexed Ethernet switch is not 
        available, no port mirrior configuration is available)
        Description | Request to set the given port mirroring state of the port mirror configuration 
        for the given Ethernet switch.
        Available via | EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SetPortMirrorState</srcid><srcstatus/><internalId>1032</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>834</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91127</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_SetPortTestMode 
        Syntax 
        Std_ReturnType EthIf_SetPortTestMode (uint8 SwitchIdx, uint8 PortIdx, EthTrcv_PhyTestModeType 
        Mode)
        Service ID [hex] | 0x5d 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | SwitchIdx | Index of the switch within the context of the Ethernet Switch 
        Driver 
        PortIdx | Index of the port at the addressed switch 
        Mode | Test mode to be activated 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | Std_ReturnType | E_OK: the port test mode for the indexed Ethernet switch port 
        was set successfully.E_NOT_OK: the port test mode for the indexed Ethernet switch was not set 
        successfully. (i.e. indexed Ethernet switch port is not available)
        Description | Activates a given test mode of the indexed Ethernet switch port.
        Available via | EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SetPortTestMode</srcid><srcstatus/><internalId>1033</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>835</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91128</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_SetPortLoopbackMode 
        Syntax 
        Std_ReturnType EthIf_SetPortLoopbackMode (uint8 SwitchIdx, uint8 PortIdx, 
        EthTrcv_PhyLoopbackModeType Mode)
        Service ID [hex] | 0x5e 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | SwitchIdx | Index of the switch within the context of the Ethernet Switch 
        Driver 
        PortIdx | Index of the port at the addressed switch 
        Mode | Loop-back mode to be activated 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | Std_ReturnType | E_OK: the port mirroring loop-back back mode for the indexed 
        Ethernet switch port was activated successfully.E_NOT_OK: the port mirroring loop-back back 
        mode for the indexed Ethernet switch port was not activated successfully. (i.e. indexed 
        Ethernet switch port is not available)
        Description | Activates a given test loop-back mode of the indexed Ethernet switch port.
        Available via | EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SetPortLoopbackMode</srcid><srcstatus/><internalId>1034</internalId></linkedfrom><linkedfrom><srcid>dev.EthIf.TransceiverGetMacMethod</srcid><srcstatus/><internalId>1044</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>836</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91129</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_SetPortTxMode 
        Syntax 
        Std_ReturnType EthIf_SetPortTxMode (uint8 SwitchIdx, uint8 PortIdx, EthTrcv_PhyTxModeType Mode)
        Service ID [hex] | 0x5f 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | SwitchIdx | Index of the switch within the context of the Ethernet Switch 
        Driver 
        PortIdx | Index of the port at the addressed switch 
        Mode | Transmission mode to be activated 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | Std_ReturnType | E_OK: the port Tx mode for the indexed Ethernet switch port was 
        activated successfully.E_NOT_OK: the port Tx mode for the indexed Ethernet switch port was not 
        activated successfully. (i.e. indexed Ethernet switch port is not available)
        Description | Activates a given transmission mode of the indexed Ethernet switch port.
        Available via | EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SetPortTxMode</srcid><srcstatus/><internalId>1035</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>837</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91130</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_GetPortCableDiagnosticsResult 
        Syntax 
        Std_ReturnType EthIf_GetPortCableDiagnosticsResult (uint8 SwitchIdx, uint8 PortIdx, 
        EthTrcv_CableDiagResultType* ResultPtr)
        Service ID [hex] | 0x60 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | SwitchIdx | Index of the switch within the context of the Ethernet Switch 
        Driver 
        PortIdx | Index of the port at the addressed switch 
        Parameters (inout) | None 
        Parameters (out) | ResultPtr | Pointer to the location where the cable diagnostics result shall 
        be stored 
        Return value | Std_ReturnType | E_OK:the port cable diagnostic result for the indexed Ethernet 
        switch port was obtained successfully.E_NOT_OK: the port cable diagnostic result for the 
        indexed Ethernet switch port was not obtained successfully. (i.e. indexed Ethernet switch port 
        is not available)
        Description | Retrieves the cable diagnostics result of the indexed Ethernet switch port 
        respectively the referenced Ethernet Transceiver Driver.
        Available via | EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.GetPortCableDiagnosticResult</srcid><srcstatus/><internalId>1036</internalId></linkedfrom><linkedfrom><srcid>dev.EthIf.CheckWakeup</srcid><srcstatus/><internalId>1045</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>838</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91131</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_RunPortCableDiagnostic 
        Syntax 
        Std_ReturnType EthIf_RunPortCableDiagnostic (uint8 SwitchIdx, uint8 PortIdx)
        Service ID [hex] | 0x61 
        Sync/Async | Asynchronous Asynchronous 
        Reentrancy | Reentrant Reentrant for different SwitchIdx and PortIdx. Non reentrant for the 
        same SwitchIdx and PortIdx.
        Parameters (in) | SwitchIdx | Index of the switch within the context of the Ethernet Switch 
        Driver.
        PortIdx | Index of the port at the addressed switch.
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | Std_ReturnType | E_OK: The trigger to run the cable diagnostic has been 
        acceptedE_NOT_OK: The trigger to run the cable diagnostic has not been accepted 
        Description | Trigger the cable diagnostics of the given Ethernet Switch port (PortIdx) by 
        calling EthTrcv_RunCableDiagnostic of the referenced Ethernet transceiver.
        Available via | EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.RunPortCableDiagnostic</srcid><srcstatus/><internalId>1037</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>839</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91132</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_RunCableDiagnostic 
        Syntax 
        Std_ReturnType EthIf_RunCableDiagnostic (uint8 TrcvIdx)
        Service ID [hex] | 0x62 
        Sync/Async | Asynchronous Asynchronous 
        Reentrancy | Reentrant Reentrant for different TrcvIdx. Non reentrant for the same TrcvIdx.
        Parameters (in) | TrcvIdx | Index of the Ethernet transceiver within the context of the 
        Ethernet Transceiver Driver.
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | Std_ReturnType | E_OK: The trigger has been accepted.E_NOT_OK: The trigger has 
        not been accepted.
        Description | Trigger the cable diagnostics for the given Ethernet transceiver.
        Available via | EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.RunCableDiagnostic</srcid><srcstatus/><internalId>1038</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>840</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91133</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_SwitchGetCfgDataRaw 
        Syntax 
        Std_ReturnType EthIf_SwitchGetCfgDataRaw (uint8 SwitchIdx, uint32 Offset, uint16 Length, uint8*
        BufferPtr)
        Service ID [hex] | 0x63 
        Sync/Async | Asynchronous Asynchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | SwitchIdx | Index of the Ethernet switch within the context of the Ethernet 
        Switch Driver 
        Offset | Offset of the Ethernet switch memory from where the reading starts 
        Length | Length of data in bytes that shall be copied 
        Parameters (inout) | None 
        Parameters (out) | BufferPtr | Pointer to the location where the data shall be copied 
        Return value | Std_ReturnType | E_OK: the data read was triggered successfullyE_NOT_OK: the 
        data read was not triggered successfully (i.e. indexed Ethernet switch is not available)
        Description | Retrieves the data in memory of the indexed Ethernet switch in variable length 
        Available via | EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SwitchGetCfgDataRaw</srcid><srcstatus/><internalId>1039</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>841</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91134</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_SwitchGetCfgDataInfo 
        Syntax 
        Std_ReturnType EthIf_SwitchGetCfgDataInfo (uint8 SwitchIdx, uint32* DataSizePtr, uint32* 
        DataAdressPtr)
        Service ID [hex] | 0x64 
        Sync/Async | Asynchronous 
        Reentrancy | Reentrant 
        Parameters (in) | SwitchIdx | Index of the Ethernet switch within the context of the Ethernet 
        Switch Driver 
        Parameters (inout) | None 
        Parameters (out) | DataSizePtr | Pointer to the location where the total size of the 
        configuration data shall be copied 
        DataAdressPtr | Pointer to the location where the start address of the configuration registers 
        shall be copied 
        Return value | Std_ReturnType | E_OK: the data was obtained successfullyE_NOT_OK: the data was 
        not obtained successfully. (i.e. indexed Ethernet switch is not available)
        Description | Retrieves the total size of data and the memory start address of the indexed 
        Ethernet Switch.
        Available via | EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SwitchGetCfgDataInfo</srcid><srcstatus/><internalId>1040</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>842</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91135</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_SwitchPortGetMaxFIFOBufferFillLevel 
        Syntax 
        Std_ReturnType EthIf_SwitchPortGetMaxFIFOBufferFillLevel (uint8 SwitchPortIdx, uint8 PortIdx, 
        uint8 SwitchPortEgressFifoIdx, uint32* SwitchPortEgressFifoBufferLevelPtr)
        Service ID [hex] | 0x65 
        Sync/Async | Asynchronous 
        Reentrancy | Reentrant Reentrant for different SwitchIdx and PortIdx. Non reentrant for the 
        same SwitchIdx and PortIdx.
        Parameters (in) | SwitchPortIdx | Index of the Ethernet switch within the context of the 
        Ethernet Switch Driver.
        PortIdx | Index of the Ethernet switch egress port at the addressed Ethernet switch.
        SwitchPortEgressFifoIdx | Index of the egress FIFO of the addressed Ethernet switch port 
        Parameters (inout) | None 
        Parameters (out) | SwitchPortEgressFifoBufferLevelPtr | Pointer to a memory location, where the 
        maximum amount of allocated FIFO buffer (in bytes) since the last read out shall be stored 
        Return value | Std_ReturnType | E_OK: successE_NOT_OK: The maximal FIFO buffer level could not 
        be obtained 
        Description | The function retrieves the maximum amount of allocated FIFO buffer of the indexed 
        Ethernet switch egress port. If the Ethernet switch hardware does not support Ethernet switch 
        port based maximal FIFO buffer level, the content of SwitchPortEgressFifoBufferLevelPtr shall 
        be set to 0xFFFFFFFF. This API may be called by e.g. a CDD.
        Available via | EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SwitchPortGetMaxFIFOBufferFillLevel</srcid><srcstatus/><internalId>1041</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>843</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00079</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfEnableSecurityEventReporting
        Parameter Type: Boolean
        Parent Containers: EthIfGeneral,
        Description: Switches the reporting of security events to the IdsM: Tags: atp.Status=draft
        Introduction: - true: reporting is enabled. - false: reporting is disabled.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06035_RptSecEvToIdsM_ETHIF_SEV_DROP_INV_VLAN</srcid><srcstatus/><internalId>1516</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06036_RptSecEvToIdsM_ETHIF_SEV_DROP_VLAN_DOUBLE_TAG</srcid><srcstatus/><internalId>1517</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06037_RptSecEvToIdsM_ETHIF_SEV_DROP_UNKNOWN_ETHERTYPE</srcid><srcstatus/><internalId>1518</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06038_RptSecEvToIdsM_ETHIF_SEV_DROP_INV_VLAN_3</srcid><srcstatus/><internalId>1519</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest12000_RptSecEvToIdsM_ETHIF_SEV_DROP_INV_VLAN</srcid><srcstatus/><internalId>1723</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest12001_RptSecEvToIdsM_ETHIF_SEV_DROP_INV_VLAN_2</srcid><srcstatus/><internalId>1724</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest12002_RptSecEvToIdsM_ETHIF_SEV_DROP_VLAN_DOUBLE_TAG</srcid><srcstatus/><internalId>1725</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest12003_RptSecEvToIdsM_ETHIF_SEV_DROP_INV_VLAN_3</srcid><srcstatus/><internalId>1726</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest12004_RptSecEvToIdsM_ETHIF_SEV_DROP_UNKNOWN_ETHERTYPE</srcid><srcstatus/><internalId>1727</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func020.SecurityEventReporting</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1127</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>844</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00080</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfSecurityEventRefs
        Container Type: Sub-Container
        Parent Containers: EthIfGeneral,
        Description: Container for the references to IdsMEvent elements representing the security 
        events that the EthIf module shall report to the IdsM in case the coresponding security related 
        event occurs (and if EthIfEnableSecurityEventReporting is set to "true"). The standardized 
        security events in this container can be extended by vendor-specific security events. Tags: atp.
        Status=draft
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Post-Build-Variant-Multiplicity: false
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/EthIf.xdm.m4_1157</srcid><srcstatus/><internalId>1076</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func020.SecurityEventReporting</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1127</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>845</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00081</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: ETHIF_SEV_DROP_UNKNOWN_ETHERTYPE
        Parameter Type: Reference
        Parent Containers: EthIfSecurityEventRefs,
        Description: An Ethernet datagram was dropped due to an unknown Ethertype. Tags: atp.Status=
        draft
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: false
        Post-Build-Variant-Value: false
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Destination: /AUTOSAR/EcucDefs/IdsM/IdsMConfiguration/IdsMEvent
        Destination type: ECUC-PARAM-CONF-CONTAINER-DEF
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06037_RptSecEvToIdsM_ETHIF_SEV_DROP_UNKNOWN_ETHERTYPE</srcid><srcstatus/><internalId>1518</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest12004_RptSecEvToIdsM_ETHIF_SEV_DROP_UNKNOWN_ETHERTYPE</srcid><srcstatus/><internalId>1727</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func020.SecurityEventReporting</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1127</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00503</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>871</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>846</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00082</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: ETHIF_SEV_DROP_VLAN_DOUBLE_TAG
        Parameter Type: Reference
        Parent Containers: EthIfSecurityEventRefs,
        Description: An Ethernet datagram was dropped due to double VLAN tag. Tags: atp.Status=draft
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: false
        Post-Build-Variant-Value: false
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Destination: /AUTOSAR/EcucDefs/IdsM/IdsMConfiguration/IdsMEvent
        Destination type: ECUC-PARAM-CONF-CONTAINER-DEF
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06036_RptSecEvToIdsM_ETHIF_SEV_DROP_VLAN_DOUBLE_TAG</srcid><srcstatus/><internalId>1517</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest12002_RptSecEvToIdsM_ETHIF_SEV_DROP_VLAN_DOUBLE_TAG</srcid><srcstatus/><internalId>1725</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func020.SecurityEventReporting</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1127</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00503</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>871</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>847</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00083</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: ETHIF_SEV_DROP_INV_VLAN
        Parameter Type: Reference
        Parent Containers: EthIfSecurityEventRefs,
        Description: An Ethernet datagram was dropped due to an invalid CrtlIdx/VLAN. Tags: atp.Status=
        draft
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: false
        Post-Build-Variant-Value: false
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Destination: /AUTOSAR/EcucDefs/IdsM/IdsMConfiguration/IdsMEvent
        Destination type: ECUC-PARAM-CONF-CONTAINER-DEF
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06035_RptSecEvToIdsM_ETHIF_SEV_DROP_INV_VLAN</srcid><srcstatus/><internalId>1516</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06038_RptSecEvToIdsM_ETHIF_SEV_DROP_INV_VLAN_3</srcid><srcstatus/><internalId>1519</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest12000_RptSecEvToIdsM_ETHIF_SEV_DROP_INV_VLAN</srcid><srcstatus/><internalId>1723</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest12001_RptSecEvToIdsM_ETHIF_SEV_DROP_INV_VLAN_2</srcid><srcstatus/><internalId>1724</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest12003_RptSecEvToIdsM_ETHIF_SEV_DROP_INV_VLAN_3</srcid><srcstatus/><internalId>1726</internalId></linkedfrom><linkedfrom><srcid>EthIf_T140_01_GetAndResetMeasurementData</srcid><srcstatus/><internalId>1769</internalId></linkedfrom><linkedfrom><srcid>EthIf_T140_02_DropData_MaxCounterValue</srcid><srcstatus/><internalId>1770</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func020.SecurityEventReporting</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1127</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00503</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>871</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>848</internalId></specobject>
    <specobject>
      <id>EthIf.ECUC_EthIf_00084</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: ETHIF_SEV_DROP_ETH_MAC_COLLISION
        Parameter Type: Reference
        Parent Containers: EthIfSecurityEventRefs,
        Description: An Ethernet datagram was dropped because local MAC was same as source MAC in an 
        incoming frame. Tags: atp.Status=draft
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: false
        Post-Build-Variant-Value: false
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Destination: /AUTOSAR/EcucDefs/IdsM/IdsMConfiguration/IdsMEvent
        Destination type: ECUC-PARAM-CONF-CONTAINER-DEF
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.EthernetMACCollisionDrop</srcid><srcstatus/><internalId>1046</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>849</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00474</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_TransceiverGetMacMethod shall forward the call to function 
        EthTrcv_GetMacMethod of the corresponding Ethernet Transceiver Driver (EthIfTransceiverIdx)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.TransceiverGetMacMethod</srcid><srcstatus/><internalId>1044</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>850</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00475</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service EthIf_Init 
        was previously called. If the check fails, the function shall raise the development error 
        ETHIF_E_UNINIT.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.TransceiverGetMacMethod</srcid><srcstatus/><internalId>1044</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>851</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00476</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter CtrlIdx for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_INV_CTRL_IDX.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.TransceiverGetMacMethod</srcid><srcstatus/><internalId>1044</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>852</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00477</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter MacModePtr 
        for being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_PARAM_POINTER.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.TransceiverGetMacMethod</srcid><srcstatus/><internalId>1044</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>853</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00478</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If EthIf_SetControllerMode has been called for an EthIfController with ETH_MODE_ACTIVE and this 
        EthIfController has a reference to an EthIfSwitch, then EthIf shall forward the call to the 
        following functions in the given order for all EthSwtPorts of the referenced switch if mode 
        ETH_MODE_ACTIVE has been requested and the current EthSwtPort mode is ETH_MODE_DOWN: 1. 
        EthSwt_SetSwitchPortMode with ETH_MODE_ACTIVE 2. EthSwt_PortLinkStateRequest with 
        ETHTRCV_LINK_STATE_ACTIVE
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SetControllerModeUpdate</srcid><srcstatus/><internalId>1047</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>854</internalId></specobject>

    <specobject>
      <id>EthIf.SWS_EthIf_00484</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If EthIf_SetControllerMode is called for an EthIfController with ETH_MODE_DOWN and this 
        EthIfController has a reference to an EthIfTransceiver, then EthIf shall forward the call to 
        the following functions in the given order, if the current mode of the EthIfTransceiver is 
        ETH_MODE_ACTIVE:
        EthTrcv_SetTransceiverMode with ETH_MODE_DOWN
        EthTrcv_TransceiverLinkStateRequest with ETHTRCV_LINK_STATE_DOWN
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SetControllerModeUpdate</srcid><srcstatus/><internalId>1047</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>855</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00485</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If EthIf_SetControllerMode is called for an EthIfController with ETH_MODE_DOWN and this 
        EthIfController has a reference to an EthIfSwitch, then EthIf shall forward the call to the 
        following functions in the given order for all EthSwtPorts, where the current mode of the 
        EthSwtPort is ETH_MODE_ACTIVE:
        EthSwt_PortLinkStateRequest with ETHTRCV_LINK_STATE_DOWN
        EthSwt_SetSwitchPortMode with ETH_MODE_DOWN
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SetControllerModeUpdate</srcid><srcstatus/><internalId>1047</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>856</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00486</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_GetPhyWakeupReason shall forward the call to function EthTrcv_GetBusWuReason 
        of the corresponding Ethernet Transceiver Driver (TrcvIdx)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.GetPhyWakeupReason</srcid><srcstatus/><internalId>1006</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>857</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00487</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service EthIf_Init 
        was previously called. If the check fails, the function shall raise the development error 
        ETHIF_E_UNINIT.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.GetPhyWakeupReason</srcid><srcstatus/><internalId>1006</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>858</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00488</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter TrcvIdx for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_INV_TRCV_IDX.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.GetPhyWakeupReason</srcid><srcstatus/><internalId>1006</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>859</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00489</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter 
        WakeupReasonPtr for being valid. If the check fails, the function shall raise the development 
        error ETHIF_E_PARAM_POINTER.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.GetPhyWakeupReason</srcid><srcstatus/><internalId>1006</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>860</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00490</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function EthIf_GetSwitchPortWakeupReason shall forward the call to function 
        EthSwt_GetSwitchPortWakeupReason of the corresponding Ethernet Switch Driver (EthIfSwitchIdx)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.GetSwitchPortWakeupReason</srcid><srcstatus/><internalId>1048</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>861</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00491</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check that the service EthIf_Init 
        was previously called. If the check fails, the function shall raise the development error 
        ETHIF_E_UNINIT otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.GetSwitchPortWakeupReason</srcid><srcstatus/><internalId>1048</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>862</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00492</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter SwitchIdx for 
        being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_INV_SWT_IDX otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.GetSwitchPortWakeupReason</srcid><srcstatus/><internalId>1048</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>863</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00493</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter SwitchPortIdx 
        for being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_INV_PORT_IDX otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.GetSwitchPortWakeupReason</srcid><srcstatus/><internalId>1048</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>864</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00494</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter 
        WakeupReasonPtr for being valid. If the check fails, the function shall raise the development 
        error ETHIF_E_PARAM_POINTER.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.GetSwitchPortWakeupReason</srcid><srcstatus/><internalId>1048</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>865</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00495</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter SwitchPortIdx 
        for being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_INV_PORT_IDX otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.GetSwitchPortSignalQuality</srcid><srcstatus/><internalId>1049</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>866</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00496</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function shall check the parameter SwitchPortIdx 
        for being valid. If the check fails, the function shall raise the development error 
        ETHIF_E_INV_PORT_IDX otherwise (if DET is disabled) return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.GetSwitchPortWakeupReason</srcid><srcstatus/><internalId>1048</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>867</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00498</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        EthIf shall check its maintained Ethernet hardware (Ethernet switch port, Ethernet transceiver)
        if the Ethernet hardware has reached the requested mode and requested link state under the 
        following conditions:
        the timer to switch off the EthSwtPort  is not running AND
        the timer to keep the EthSwtPort in ETH_MODE_ACTIVE  is not running and the EthSwtPort has not 
        been requested with ETH_MODE_ACTIVE
        If EthIf detects that the requested mode and / or requested link state has not reached, EthIf 
        shall re-trigger the requested mode and link state, respectively.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.MainFunctionState</srcid><srcstatus/><internalId>1008</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>868</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00500</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        For all affected Ethernet switches (referenced by EthIfSwitch) the function EthIf_CheckWakeup 
        shall forward the call to function EthSwt_SwitchCheckWakeup of the respective Ethernet Switch 
        Driver.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.CheckWakeup</srcid><srcstatus/><internalId>1045</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>869</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00502</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        If security event reporting has been enabled for the EthIf module (
        EthIfEnableSecurityEventReporting = true) the respective security events shall be reported to 
        the IdsM via the interfaces defined in AUTOSAR_SWS_BSWGeneral.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest12002_RptSecEvToIdsM_ETHIF_SEV_DROP_VLAN_DOUBLE_TAG</srcid><srcstatus/><internalId>1725</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>870</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_00503</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name | Description | ID 
        ETHIF_SEV_DROP_UNKNOWN_ETHERTYPE | An ethernet datagram was dropped due the Ethertype in not 
        known. | 15 
        ETHIF_SEV_DROP_VLAN_DOUBLE_TAG | An ethernet datagram was dropped due to double VLAN tag. | 16 
        ETHIF_SEV_DROP_INV_VLAN | An ethernet datagram was dropped due to an invalid CrtlIdx/VLAN. | 17 
        ETHIF_SEV_DROP_ETH_MAC_COLLISION | Ethernet datagram was dropped because local MAC was same as 
        source MAC in an incoming frame. | 18
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.ECUC_EthIf_00081</srcid><srcstatus/><internalId>846</internalId></linkedfrom><linkedfrom><srcid>EthIf.ECUC_EthIf_00082</srcid><srcstatus/><internalId>847</internalId></linkedfrom><linkedfrom><srcid>EthIf.ECUC_EthIf_00083</srcid><srcstatus/><internalId>848</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func020.SecurityEventReporting</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1127</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>871</internalId></specobject>
    <specobject>
      <id>EthIf.SWS_EthIf_91021</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_TransceiverGetMacMethod (draft)
        Syntax 
        Std_ReturnType EthIf_TransceiverGetMacMethod (uint8* TrcvIdx, EthTrcv_MacMethodType* MacModePtr)
        Service ID [hex] | 0x66 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | TrcvIdx | Index of the transceiver within the context of the Ethernet 
        Transceiver Driver 
        Parameters (inout) | None 
        Parameters (out) | MacModePtr | ETHTRCV_MAC_TYPE_CSMA_CD: Carrier-sense multiple access with 
        collicion detection. ETHTRCV_MAC_TYPE_PLCA: Physical layer collision avoidance.
        Return value | Std_ReturnType | E_OK: success.E_NOT_OK: transceiver request has not been 
        accepted.
        Description | Obtains the media access mode of the transceiver. Tags:atp.Status=draft 
        Available via | EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.TransceiverGetMacMethod</srcid><srcstatus/><internalId>1044</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>872</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs">

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_00560</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        The Ethernet Interface shall support MACsec as a SW implementation as specified in [IEEE 802.1AE].
        (FO_RS_MACsec_00001)
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SwMacSec.NotSupported</srcid><srcstatus/><internalId>1050</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>873</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_00561</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        The Ethernet Interface shall support configuring which Ethernet Interface Controllers are MACsec protected.
        (FO_RS_MACsec_00004)
      </description>
      <comment>
        Since only hardware implementation of MACsec is supported, EthIf does not implement MACsec itself, but only pass-through APIs
        towards transceiver or switch.
        The only use case where EthIf must know which EthIfControllers are MACsec protected is when suppressing propagation of
        transceiver link state change to upper layers, and this is accomplished with configuration parameter EthIfPaeInstanceRef
        [ECUC_EthIf_00090].
      </comment>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.EB.ECUC_EthIf_00090</srcid><srcstatus/><internalId>938</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>874</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_00562</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        The Ethernet Interface shall support configuring per Ethernet Interface Controller the MACsec Entity to use
        (per SW or HW i.e., offloaded). (FO_RS_MACsec_00004)
        Note: This is included per configuration with the parameter EthIfMacSecSupport.
      </description>
      <comment>
        Software MACsec implementation is not supported, consequently hardware MACsec Entity (SecY) is always used when MACsec
        protection is required for Ethernet interface controller.
      </comment>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SwMacSec.NotSupported</srcid><srcstatus/><internalId>1050</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>875</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_00563</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        The MACsec Entity per SW of the Ethernet Interface shall provide a mechanism to configure rules to bypass MACsec for incoming and
        outgoing traffic based on EtherType and/or VLAN-ID. All traffic not configured as bypassed traffic shall be processed by the
        MACsec entity or dropped. This configuration shall be supported at initial configuration time of the Ports.
        (FO_RS_MACsec_00007)
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SwMacSec.NotSupported</srcid><srcstatus/><internalId>1050</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>876</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_00564</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        The MACsec entity per SW of the Ethernet Interface shall support status counters for the following information, which may be
        attached to IDSM functionality:
        - Dropped frames because of incorrect ICV per port.
        - Unsuccessful MKA sequence per peer.
        - Additionally, all the port statistics required by [IEEE 802.1AE].
        FO_RS_MACsec_00009)
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SwMacSec.NotSupported</srcid><srcstatus/><internalId>1050</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>877</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_00565</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        The MACsec entity per SW of the Ethernet Interface shall support "Integrity only" as well as "Integrity with Confidentiality"
        for all supported ciphers.
        (FO_RS_MACsec_00010)
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SwMacSec.NotSupported</srcid><srcstatus/><internalId>1050</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>878</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_00566</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        The MACsec entity per SW of the Ethernet Interface shall support MAC Security TAG (SecTAG) as defined in [IEEE 802.1AE].
        The SecTAG shall convey:
        - TAG Control Information (TCI)
        - Association Number (AN)
        - Short Length (SL)
        - Packet Number (PN)
        - Secure Channel Identifier (SCI) - Optional
        (FO_RS_MACsec_00011)
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SwMacSec.NotSupported</srcid><srcstatus/><internalId>1050</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>879</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_00567</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        The MACsec entity per SW of the Ethernet Interface shall support MACsec EtherType as defined in [IEEE 802.1AE].
        (FO_RS_MACsec_00012)
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SwMacSec.NotSupported</srcid><srcstatus/><internalId>1050</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>880</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_00568</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        The MACsec entity per SW of the Ethernet Interface shall support TAG Control Information (TCI) as defined in [IEEE 802.1AE].
        The TCI shall be encoded in the SecTAG.
        (FO_RS_MACsec_00011)
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SwMacSec.NotSupported</srcid><srcstatus/><internalId>1050</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>881</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_00569</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        The MACsec entity per SW of the Ethernet Interface shall support Association Number (AN) as defined in [IEEE 802.1AE].
        The AN shall be encoded in the SecTAG.
        (FO_RS_MACsec_00011)
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SwMacSec.NotSupported</srcid><srcstatus/><internalId>1050</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>882</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_00570</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        The MACsec entity per SW of the Ethernet Interface shall support Short Length (SL) as defined in [IEEE 802.1AE].
        The SL shall be encoded in the SecTAG.
        (FO_RS_MACsec_00011)
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SwMacSec.NotSupported</srcid><srcstatus/><internalId>1050</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>883</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_00571</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        The MACsec entity per SW of the Ethernet Interface shall support Packet Number (PN) with 32 least significant bits,
        as defined in [IEEE 802.1AE]. The PN shall be encoded in the SecTAG.
        (FO_RS_MACsec_00011)
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SwMacSec.NotSupported</srcid><srcstatus/><internalId>1050</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>884</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_00572</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        The MACsec entity per SW of the Ethernet Interface shall support Extended Packet Number (XPN) as defined in [IEEE 802.1AE].
        The XPN extends the PN to 64 bits.
        (FO_RS_MACsec_00017)
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SwMacSec.NotSupported</srcid><srcstatus/><internalId>1050</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>885</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_00573</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        The MACsec entity per SW of the Ethernet Interface shall support Secure Channel Identifier (SCI), as defined in [IEEE 802.1AE].
        The SCI may be encoded in the SecTAG if SCI is required to be sent.
        (FO_RS_MACsec_00018)
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SwMacSec.NotSupported</srcid><srcstatus/><internalId>1050</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>886</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_00574</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        The MACsec entity per SW of the Ethernet Interface shall support Secure Data as defined in [IEEE 802.1AE].
        (FO_RS_MACsec_00019)
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SwMacSec.NotSupported</srcid><srcstatus/><internalId>1050</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>887</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_00575</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        The MACsec entity per SW of the Ethernet Interface shall support Integrity check value (ICV) as defined in [IEEE 802.1AE].
        The ICV length depends on the used cipher suite but is not less than 8 octets and not more than 16 octets.
        The transmitted ICV is always 16 octets.
        (FO_RS_MACsec_00020)
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SwMacSec.NotSupported</srcid><srcstatus/><internalId>1050</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>888</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_00576</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        The MACsec entity per SW of the Ethernet Interface shall support a protect function as specified in [IEEE 802.1AE].
        (FO_RS_MACsec_00021)
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SwMacSec.NotSupported</srcid><srcstatus/><internalId>1050</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>889</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_00577</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        The MACsec entity per SW of the Ethernet Interface shall support a validation function as specified in [IEEE 802.1AE].
        (FO_RS_MACsec_00022)
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SwMacSec.NotSupported</srcid><srcstatus/><internalId>1050</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>890</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_00578</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        The MACsec entity per SW of the Ethernet Interface shall support the following ciphers suites:
        - GCM-AES-128
        - GCM-AES-256
        - GCM-AES-XPN-128
        - GCM-AES-XPN-256
        (FO_RS_MACsec_00032)
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SwMacSec.NotSupported</srcid><srcstatus/><internalId>1050</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>891</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_00579</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        The MACsec entity per SW of the Ethernet Interface shall support a validation function for MACsec ICV.
        (FO_RS_MACsec_00033)
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SwMacSec.NotSupported</srcid><srcstatus/><internalId>1050</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>892</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_00580</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        The MACsec entity per SW of the Ethernet Interface shall support a generation function for MACsec ICV.
        (FO_RS_MACsec_00034)
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.SwMacSec.NotSupported</srcid><srcstatus/><internalId>1050</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>893</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_00581</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        The Ethernet Interface Module shall share the MACsec Operational status between Ethernet Interface Controllers sharing
        a physical or virtual controlled port.
        An Ethernet Interface controller shall trigger the MKA Module to start the MKA sequence in a port with MKA_LinkStateChange
        after receiving the “Mode Indication” from the Switch or Transceiver with the corresponding function
        EthIf_SwitchPortModeIndication or EthIf_TrcvModeIndication.
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.EB.SWS_EthIf_00581.1</srcid><srcstatus/><internalId>895</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.SWS_EthIf_00581.2</srcid><srcstatus/><internalId>896</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>894</internalId></specobject>

    <specobject>
      <id>EthIf.EB.SWS_EthIf_00581.1</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        The Ethernet Interface Module shall share the MACsec Operational status between Ethernet Interface Controllers sharing
        a physical or virtual controlled port.
      </description>
      <comment>
        This requirement is not applicable: This requirement implies implicit share of MACsec Operational status between EthIfControllers
        based on shared physical port. However this is in contradiction with configuration parameter EthIfPaeInstanceRef [ECUC_EthIf_00090],
        which explicitly define list of PAEs that shall be used for MACsec Operational aggregation.
      </comment>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_00581</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>894</internalId></provcov>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>895</internalId></specobject>

    <specobject>
      <id>EthIf.EB.SWS_EthIf_00581.2</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        An Ethernet Interface shall inform MKA module with MKA_LinkStateChange() when link state of a transceiver or switch port changes
        its link state (ACTIVE / DOWN).
        The call is performed only if respective transceiver or switch port is referenced by MkaEthIfControllerRef
        (EthIfCtrlIdx -&gt; EthIfTransceiverIdx -&gt; EthTrcvIdx) or MkaSwitchPortRef configuration parameters.
      </description>
      <verifycrit>
        Test with a following test cases:
        Test case 1)
          1. Configure EthTrcv_GetLinkState stub to return that transceiver links state is ACTIVE when called.
          2. Call EthIf_SetControllerMode() to activate Ethernet interface controller, that is reference by MkaPae.
          3. Call EthIf_MainFunctionRx() to perform transceiver link state pooling.
          4. Verify that MKA_LinkStateChange() is called with ACTIVE for Pae that is referencing activated Ethernet interface controller.
          5. Call EthIf_MainFunctionRx() again and verity that MKA_LinkStateChange() was not called, since underlying transceiver link state
             has not changed.
          6. Configure EthTrcv_GetLinkState stub to return that transceiver links state is DOWN when called.
          7. Call EthIf_MainFunctionRx() to perform transceiver link state pooling.
          8. Verify that MKA_LinkStateChange() is called with DOWN.
        Test case 2)
          Repeat steps 1..8 from above, but activate Ethernet interface controller, that is is not referenced by MkaPae, but has a link to
          the same transceiver (EthIfEthTrcvRef) as the one that is reference by PAE.
        Test case 3)
          Repeat steps 1..3 from above, but activate Ethernet interface controller that is referencing a transceiver (EthIfEthTrcvRef)
          not used by any of MkaPae.
          Verify that MKA_LinkStateChange() is not called in this case.
      </verifycrit>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/EthIf.c.m4_5068</srcid><srcstatus/><internalId>1064</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01301_MacSec_MKAStateChange</srcid><srcstatus/><internalId>1731</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest01302_MacSec_MKAStateChange_NoCall</srcid><srcstatus/><internalId>1732</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest01317_MacSec_MKAStateChange_E_NOT_OK</srcid><srcstatus/><internalId>1747</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_00581</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>894</internalId></provcov>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>896</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_00582</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        Once the physical or virtual port can generate and validate MACsec traffic (signalled by EthIf_MacSecOperational),
        all Controllers using the virtual or physical port shall immediately communicate the MacSecOperational status to
        the upper layers with EthSM_TrcvLinkStateChg.
        (FO_RS_MACsec_00002)
      </description>
      <comment>
        The process of calculating and reporting of MACsec operational is not described detail enough and without taking into account
        MACsec Operational aggregation when multiple PaeInstances are configured in EthIfPaeInstanceRef.
      </comment>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.EB.SWS_EthIf_00582.1</srcid><srcstatus/><internalId>898</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.SWS_EthIf_00582.2</srcid><srcstatus/><internalId>899</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>897</internalId></specobject>

    <specobject>
      <id>EthIf.EB.SWS_EthIf_00582.1</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Mka reports MACsec Operational state change of underlying transceiver or switch port by calling EthIf_MacSecOperational().
        MACsec Operational TRUE indicates that physical or virtual port can generate and validate MACsec traffic.
        MACsec operational shall be calculated for each EthIf controller which has configured non-empty list EthIfPaeInstanceRef.
        This process is described in [EthIf.EB.SWS_EthIf_00582.2].
        Only EthIf controllers that need to calculate MACsec Operational shall use this value together with transceiver link state of
        underlying link (transceiver / switch port / port group) in the following way:
        - EthSM_TrcvLinkStateChg() is reported ACTIVE only if transceiver link state is ACTIVE and MACsec Operational is TRUE.
      </description>
      <verifycrit>
        Use case 1:
        1) Activate all EthIf controllers
        2) Bring link state of all underlying transceivers to ACTIVE
        3) Configure EthTrcv_GetLinkState stub to return ACTIVE for all configured transceivers.
        4) Verify that only those EthIf controller with empty EthIfPaeInstanceRef shall report transceiver link state to UL.
        5) Report MACsec Operational of MkaPaeInstance_0 to TRUE
        6) Verify that EthIf controllers that have MkaPaeInstance_0 configured in EthIfPaeInstanceRef reported EthSM_TrcvLinkStateChg(ACTIVE).
        7) Report MACsec Operational of MkaPaeInstance_1 to TRUE
        8) Verify that EthIf controllers that have MkaPaeInstance_1 configured in EthIfPaeInstanceRef reported EthSM_TrcvLinkStateChg(ACTIVE).
        9) Report MACsec Operational of MkaPaeInstance_0 to FALSE
       10) Verify that EthIf controllers that have only MkaPaeInstance_0 configured in EthIfPaeInstanceRef reported EthSM_TrcvLinkStateChg(DOWN).
       11) Report MACsec Operational of MkaPaeInstance_1 to FALSE
       12) Verify that EthIf controllers that have only MkaPaeInstance_0 and MkaPaeInstance_1 configured in EthIfPaeInstanceRef
           reported EthSM_TrcvLinkStateChg(DOWN).
        Use case 2:
        1) Perform steps 1), 2), 3), 5) and 7) from previous use case
        2) Bring link state of underlying transceivers to DOWN, one by one
        3) Verify that EthSM_TrcvLinkStateChg(DOWN) was called for all EthIf controllers that reference transceiver being shut-down.
      </verifycrit>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01303_MacSec_MacSecOperational_1</srcid><srcstatus/><internalId>1733</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest01304_MacSec_MacSecOperational_2</srcid><srcstatus/><internalId>1734</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest01318_MacSec_MacSecOperational_3</srcid><srcstatus/><internalId>1748</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_00582</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>897</internalId></provcov>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>898</internalId></specobject>

    <specobject>
      <id>EthIf.EB.SWS_EthIf_00582.2</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        MACsec Operational of EthIf controller is calculated in the following way:
        - MACsec Operational is FALSE only if MACsec Operational of all listed PaeInstances in EthIfPaeInstanceRef are FALSE.
        In other words, if any of listed PaeInstances from EthIfPaeInstanceRef has reported MACsec Operational TRUE,
        then MACsec Operational of EthIf controller is also TRUE.
      </description>
      <verifycrit>
        Please use the same test configuration for verifying aggregation process.
      </verifycrit>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01303_MacSec_MacSecOperational_1</srcid><srcstatus/><internalId>1733</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest01318_MacSec_MacSecOperational_3</srcid><srcstatus/><internalId>1748</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_00582</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>897</internalId></provcov>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>899</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_00583</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        The Ethernet Interface module shall support the MKA related EtherTypes as defined in [IEEE 802.1AE].
        (FO_RS_MACsec_00023)
      </description>
      <comment>
        This requirement is informational only.
        Rationale:
        The integrator has to configure EAP over LAN EtherType in EthIfFrameOwnerConfig.
      </comment>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>900</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_00584</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        The Ethernet Interface module shall allow forwarding the received Ethernet frames of a specific EtherType to multiple frame
        owners if configured.
      </description>
      <verifycrit>
        - Configure UL_X_RxIndication() function to be assigned to a single Ethernet type (EthIfFrameOwnerConfig)
        - Configure two UL_Y_RxIndication() and UL_Z_RxIndication() functions share common Ethernet frame type.
        - Verify that UL_X_RxIndication() function is called only once when associated frame is received.
        - Verify that both UL_Y_RxIndication() and UL_Z_RxIndication() function are called when associated frame is received.
      </verifycrit>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/EthIf.c.m4_6269</srcid><srcstatus/><internalId>1065</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest03013_MultipleFrameOwners</srcid><srcstatus/><internalId>1394</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>901</internalId></specobject>

<!-- ===================================[Function definitions]================================== -->
    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_91215</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        Service Name:       EthIf_MacSecUpdateSecY
        Syntax:             Std_ReturnType EthIf_MacSecUpdateSecY(
                                                                    uint8 CtrlIdx,
                                                                    const Mka_MacSecConfigType* MACsecCfgPtr,
                                                                    uint64 TxSci
                                                                  );
        Service ID [hex]:   0x88
        Sync/Async:         Asynchronous
        Reentrancy:         Reentrant for different CtrlIdx.
                            Non-reentrant for the same CtrlIdx.
        Parameters (in):    CtrlIdx             Index of the Ethernet controller within the context of the Ethernet Interface.
                            MACsecCfgPtr        Pointer to the structure to configure a MACsec Entity (SecY).
                            TxSci               Secure Channel Identifier for the MACsec’s Transmission Secure channel.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       Std_ReturnType      E_OK:     The request has been accepted.
                                                E_NOT_OK: The request has not been accepted.
        Description:        Requests the Ethernet Interface (MACsec per SW) or the Ethernet Transceiver to update the SecY/PAC of the PHY
                            with the provided parameters. A Transmission Secure Channel with the provided SCI shall be configured during
                            the first call. A pointer to a MACsec Basic Parameters Configuration file shall be provided to create the
                            Secure Channel.
        Available via:      EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01300_MacSec_BasicTest_1</srcid><srcstatus/><internalId>1728</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>902</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_91217</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        Service Name:       EthIf_SwitchMacSecUpdateSecYNotification
        Syntax:             void EthIf_SwitchMacSecUpdateSecYNotification(
                                                                            const EthSwt_MgmtInfoType* MgmtInfoPtr
                                                                         );
        Service ID [hex]:   0x6B
        Sync/Async:         Synchronous
        Reentrancy:         Reentrant for different MgmtInfoPtr.
                            Non-reentrant for the same MgmtInfoPtr.
        Parameters (in):    MgmtInfoPtr         Pointer to the management information within the context of an Ethernet Switch Driver.
                                                SwitchIdx in context of EthIf, PortIdx in context of EthSwt.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       Std_ReturnType      E_OK:     The request has been accepted.
                                                E_NOT_OK: The request has not been accepted.
        Description:        Callback to notify that EhtIf_SwitchMacSecUpdateSecY finished.
        Available via:      EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.SwitchMacSec</srcid><srcstatus/><internalId>1052</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>903</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_91218</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        Service Name:       EthIf_MacSecUpdateSecYNotification
        Syntax:             void EthIf_MacSecUpdateSecYNotification(
                                                                      uint8 CtrlIdx
                                                                   );
        Service ID [hex]:   0x6C
        Sync/Async:         Synchronous
        Reentrancy:         Reentrant for different CtrlIdx.
                            Non-reentrant for the same CtrlIdx.
        Parameters (in):    CtrlIdx             Index of the Ethernet controller within the context of the Ethernet Interface.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       None
        Description:        Callback to notify that EhtIf_SwitchMacSecUpdateSecY finished.
        Available via:      EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01300_MacSec_BasicTest_3</srcid><srcstatus/><internalId>1730</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>904</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_91220</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        Service Name:       EthIf_SwitchMacSecInitRxSc
        Syntax:             Std_ReturnType EthIf_SwitchMacSecInitRxSc(
                                                                        const EthSwt_MgmtInfoType* MgmtInfoPtr,
                                                                        uint64 Sci
                                                                     );
        Service ID [hex]:   0x6E
        Sync/Async:         Synchronous
        Reentrancy:         Reentrant for different MgmtInfoPtr.
                            Non-reentrant for the same MgmtInfoPtr.
        Parameters (in):    MgmtInfoPtr         Pointer to the management information within the context of an Ethernet Switch Driver.
                                                SwitchIdx in context of EthIf, PortIdx in context of EthSwt.
                            Sci                 Secure Channel Identifier for the MACsec’s Reception Secure channel.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       Std_ReturnType      E_OK:     The request has been accepted.
                                                E_NOT_OK: The request has not been accepted.
        Description:        Requests the Ethernet Switch Driver to configure a Reception Secure Channel for the given Secure Channel Identifier.
        Available via:      EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.SwitchMacSec</srcid><srcstatus/><internalId>1052</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>905</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_91211</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        Service Name:       EthIf_MacSecInitRxSc
        Syntax:             Std_ReturnType EthIf_MacSecInitRxSc(
                                                                  uint8 CtrlIdx,
                                                                  uint64 Sci
                                                               );
        Service ID [hex]:   0x87
        Sync/Async:         Synchronous
        Reentrancy:         Reentrant for different CtrlIdx.
                            Non-reentrant for the same CtrlIdx.
        Parameters (in):    CtrlIdx             Index of the Ethernet controller within the context of the Ethernet Interface.
                            Sci                 Secure Channel Identifier for the MACsec’s Reception Secure channel.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       Std_ReturnType      E_OK:     The request has been accepted.
                                                E_NOT_OK: The request has not been accepted.
        Description:        Requests the Ethernet Interface (MACsec per SW) or the Ethernet Transceiver Driver to configure a Reception
                            Secure Channel for the given Secure Channel Identifier.
        Available via:      EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01300_MacSec_BasicTest_1</srcid><srcstatus/><internalId>1728</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>906</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_91221</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        Service Name:       EthIf_SwitchMacSecResetRxSc
        Syntax:             Std_ReturnType EthIf_SwitchMacSecResetRxSc(
                                                                         const EthSwt_MgmtInfoType* MgmtInfoPtr,
                                                                         uint64 Sci
                                                                      );
        Service ID [hex]:   0x6F
        Sync/Async:         Synchronous
        Reentrancy:         Reentrant for different CtrlIdx.
                            Non-reentrant for the same CtrlIdx.
        Parameters (in):    MgmtInfoPtr         Pointer to the management information within the context of an Ethernet Switch Driver.
                                                SwitchIdx in context of EthIf, PortIdx in context of EthSwt.
                            Sci                 Secure Channel Identifier for the MACsec’s Reception Secure channel.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       Std_ReturnType      E_OK:     The request has been accepted.
                                                E_NOT_OK: The request has not been accepted.
        Description:        Requests the Ethernet Switch Driver to reset to default the MACsec values of the Reception Secure Channel
                            for the given Secure Channel Identifier.
        Available via:      EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.SwitchMacSec</srcid><srcstatus/><internalId>1052</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>907</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_91213</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        Service Name:       EthIf_MacSecResetRxSc
        Syntax:             Std_ReturnType EthIf_MacSecResetRxSc(
                                                                   uint8 CtrlIdx,
                                                                   uint64 Sci
                                                                );
        Service ID [hex]:   0x86
        Sync/Async:         Synchronous
        Reentrancy:         Reentrant for different CtrlIdx.
                            Non-reentrant for the same CtrlIdx.
        Parameters (in):    CtrlIdx             Index of the Ethernet controller within the context of the Ethernet Interface.
                            Sci                 Secure Channel Identifier for the MACsec’s Reception Secure channel.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       Std_ReturnType      E_OK:     The request has been accepted.
                                                E_NOT_OK: The request has not been accepted.
        Description:        Requests the Ethernet Interface (MACsec per SW) or the Ethernet Transceiver Driver to reset to default the
                            MACsec values of the Reception Secure Channel for the given Secure Channel Identifier.
        Available via:      EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01300_MacSec_BasicTest_2</srcid><srcstatus/><internalId>1729</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>908</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_91222</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        Service Name:       EthIf_SwitchMacSecAddTxSa
        Syntax:             Std_ReturnType EthIf_SwitchMacSecAddTxSa(
                                                                       const EthSwt_MgmtInfoType* MgmtInfoPtr,
                                                                       uint8 An,
                                                                       uint64 NextPn,
                                                                       uint32 Ssci,
                                                                       const Mka_SakKeyPtrType* KeysPtr,
                                                                       boolean Active
                                                                    );
        Service ID [hex]:   0x70
        Sync/Async:         Asynchronous
        Reentrancy:         Reentrant for different MgmtInfoPtr.
                            Non-reentrant for the same MgmtInfoPtr.
        Parameters (in):    MgmtInfoPtr         Pointer to the management information within the context of an Ethernet Switch Driver.
                                                SwitchIdx in context of EthIf, PortIdx in context of EthSwt.
                            An                  Association Number to use in the MACsec’s transmission secure association.
                            NextPn              Next acceptable Packet Number in the MACsec’s transmission secure association.
                            Ssci                Short Secure Channel Identifier used in the MACsec’s transmission secure association.
                            KeysPtr             Pointer to the Keys (SAK, Hash and Salt key) to use in the MACsec’s transmission
                                                secure association.
                            Active              Boolean to enable/disable the MACsec’s transmission secure association.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       Std_ReturnType      E_OK:     The request has been accepted.
                                                E_NOT_OK: The request has not been accepted.
        Description:        Requests the Ethernet Switch Driver to create a Transmission Secure Association in the provided port.
                            The Short Secure Channel Identifier is included to support XPN configurations.
        Available via:      EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.SwitchMacSec</srcid><srcstatus/><internalId>1052</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>909</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_91206</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        Service Name:       EthIf_MacSecAddTxSa
        Syntax:             Std_ReturnType EthIf_MacSecAddTxSa(
                                                                 uint8 CtrlIdx,
                                                                 uint8 An,
                                                                 uint64 NextPn,
                                                                 uint32 Ssci,
                                                                 const Mka_SakKeyPtrType* KeysPtr,
                                                                 boolean Active
                                                              );
        Service ID [hex]:   0x85
        Sync/Async:         Asynchronous
        Reentrancy:         Reentrant for different CtrlIdx.
                            Non-reentrant for the same CtrlIdx.
        Parameters (in):    CtrlIdx             Index of the Ethernet controller within the context of the Ethernet Interface.
                            An                  Association Number to use in the MACsec’s transmission secure association.
                            NextPn              Next acceptable Packet Number in the MACsec’s transmission secure association.
                            Ssci                Short Secure Channel Identifier used in the MACsec’s transmission secure association.
                            KeysPtr             Pointer to the Keys (SAK, Hash and Salt key) to use in the MACsec’s transmission
                                                secure association.
                            Active              Boolean to enable/disable the MACsec’s transmission secure association.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       Std_ReturnType      E_OK:     The request has been accepted.
                                                E_NOT_OK: The request has not been accepted.
        Description:        Requests the Ethernet Interface (MACsec per SW) or the Ethernet Transceiver Driver to create a Transmission
                            Secure Association in the Transceiver. The Short Secure Channel Identifier is included to support XPN
                            configurations.
        Available via:      EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01300_MacSec_BasicTest_1</srcid><srcstatus/><internalId>1728</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>910</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_91223</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        Service Name:       EthIf_SwitchMacSecAddTxSaNotification
        Syntax:             void EthIf_SwitchMacSecAddTxSaNotification(
                                                                         const EthSwt_MgmtInfoType* MgmtInfoPtr
                                                                      );
        Service ID [hex]:   0x71
        Sync/Async:         Synchronous
        Reentrancy:         Reentrant for different MgmtInfoPtr.
                            Non-reentrant for the same MgmtInfoPtr.
        Parameters (in):    MgmtInfoPtr         Pointer to the management information within the context of an Ethernet Switch Driver.
                                                SwitchIdx in context of EthIf, PortIdx in context of EthSwt.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       None
        Description:        Callback to notify that EthIf_SwitchMacSecAddTxSa finished.
        Available via:      EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.SwitchMacSec</srcid><srcstatus/><internalId>1052</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>911</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_91224</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        Service Name:       EthIf_MacSecAddTxSaNotification
        Syntax:             void EthIf_MacSecAddTxSaNotification(
                                                                   uint8 CtrlIdx
                                                                );
        Service ID [hex]:   0x72
        Sync/Async:         Synchronous
        Reentrancy:         Reentrant for different CtrlIdx.
                            Non-reentrant for the same CtrlIdx.
        Parameters (in):    CtrlIdx             Index of the Ethernet controller within the context of the Ethernet Interface.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       None
        Description:        Callback to notify that EthIf_MacSecAddTxSa finished.
        Available via:      EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01300_MacSec_BasicTest_3</srcid><srcstatus/><internalId>1730</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>912</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_91225</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        Service Name:       EthIf_SwitchMacSecUpdateTxSa
        Syntax:             Std_ReturnType EthIf_SwitchMacSecUpdateTxSa(
                                                                          const EthSwt_MgmtInfoType* MgmtInfoPtr,
                                                                          uint8 An,
                                                                          uint64 NextPn,
                                                                          boolean Active
                                                                       );
        Service ID [hex]:   0x73
        Sync/Async:         Synchronous
        Reentrancy:         Reentrant for different MgmtInfoPtr.
                            Non-reentrant for the same MgmtInfoPtr.
        Parameters (in):    MgmtInfoPtr         Pointer to the management information within the context of an Ethernet Switch Driver.
                                                SwitchIdx in context of EthIf, PortIdx in context of EthSwt.
                            An                  Association Number to use in the MACsec’s transmission secure association.
                            NextPn              Next acceptable Packet Number in the MACsec’s transmission secure association.
                            Active              Boolean to enable/disable the MACsec’s transmission secure association.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       Std_ReturnType      E_OK:     The request has been accepted.
                                                E_NOT_OK: The request has not been accepted.
        Description:        Requests the Ethernet Switch Driver to update the Transmission Secure Association with the
                            given Packet Number. The Active parameter is included to change the specified AN status.
        Available via:      EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.SwitchMacSec</srcid><srcstatus/><internalId>1052</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>913</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_91216</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        Service Name:       EthIf_MacSecUpdateTxSa
        Syntax:             Std_ReturnType EthIf_MacSecUpdateTxSa(
                                                                    uint8 CtrlIdx,
                                                                    uint8 An,
                                                                    uint64 NextPn,
                                                                    boolean Active
                                                                 );
        Service ID [hex]:   0x84
        Sync/Async:         Synchronous
        Reentrancy:         Reentrant for different CtrlIdx.
                            Non-reentrant for the same CtrlIdx.
        Parameters (in):    CtrlIdx             Index of the Ethernet controller within the context of the Ethernet Interface.
                            An                  Association Number to use in the MACsec’s transmission secure association.
                            NextPn              Next acceptable Packet Number in the MACsec’s transmission secure association.
                            Active              Boolean to enable/disable the MACsec’s transmission secure association.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       Std_ReturnType      E_OK:     The request has been accepted.
                                                E_NOT_OK: The request has not been accepted.
        Description:        Requests the Ethernet Interface (MACsec per SW) or the Ethernet Transceiver Driver to update the Transmission
                            Secure Association with the given Packet Number. The Active parameter is included to change the specified AN status.
        Available via:      EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01300_MacSec_BasicTest_2</srcid><srcstatus/><internalId>1729</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>914</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_91226</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        Service Name:       EthIf_SwitchMacSecDeleteTxSa
        Syntax:             Std_ReturnType EthIf_SwitchMacSecDeleteTxSa(
                                                                          const EthSwt_MgmtInfoType* MgmtInfoPtr,
                                                                          uint8 An
                                                                       );
        Service ID [hex]:   0x74
        Sync/Async:         Synchronous
        Reentrancy:         Reentrant for different MgmtInfoPtr.
                            Non-reentrant for the same MgmtInfoPtr.
        Parameters (in):    MgmtInfoPtr         Pointer to the management information within the context of an Ethernet Switch Driver.
                                                SwitchIdx in context of EthIf, PortIdx in context of EthSwt.
                            An                  Association Number to use in the MACsec’s transmission secure association.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       Std_ReturnType      E_OK:     The request has been accepted.
                                                E_NOT_OK: The request has not been accepted.
        Description:        Request the Ethernet Switch Driver to remove the Transmission Secure Association identified by
                            the provided Association Number.
        Available via:      EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.SwitchMacSec</srcid><srcstatus/><internalId>1052</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>915</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_91208</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        Service Name:       EthIf_MacSecDeleteTxSa
        Syntax:             Std_ReturnType EthIf_MacSecDeleteTxSa(
                                                                    uint8 CtrlIdx,
                                                                    uint8 An
                                                                 );
        Service ID [hex]:   0x16
        Sync/Async:         Synchronous
        Reentrancy:         Reentrant for different CtrlIdx.
                            Non-reentrant for the same CtrlIdx.
        Parameters (in):    CtrlIdx             Index of the Ethernet controller within the context of the Ethernet Interface.
                            An                  Association Number to use in the MACsec’s transmission secure association.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       Std_ReturnType      E_OK:     The request has been accepted.
                                                E_NOT_OK: The request has not been accepted.
        Description:        Request the Ethernet Interface (MACsec per SW) or the Ethernet Transceiver Driver to remove the Transmission
                            Secure Association identified by the provided Association Number.
        Available via:      EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01300_MacSec_BasicTest_2</srcid><srcstatus/><internalId>1729</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>916</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_91227</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        Service Name:       EthIf_SwitchMacSecAddRxSa
        Syntax:             Std_ReturnType EthIf_SwitchMacSecAddRxSa(
                                                                       const EthSwt_MgmtInfoType* MgmtInfoPtr,
                                                                       uint8 An,
                                                                       uint64 LowestPn,
                                                                       uint32 Ssci,
                                                                       const Mka_SakKeyPtrType* KeysPtr,
                                                                       boolean Active
                                                                    );
        Service ID [hex]:   0x75
        Sync/Async:         Asynchronous
        Reentrancy:         Reentrant for different MgmtInfoPtr.
                            Non-reentrant for the same MgmtInfoPtr.
        Parameters (in):    MgmtInfoPtr         Pointer to the management information within the context of an Ethernet Switch Driver.
                                                SwitchIdx in context of EthIf, PortIdx in context of EthSwt.
                            An                  Association Number to use in the MACsec’s transmission secure association.
                            LowestPn            Lowest acceptable Packet Number in the MACsec’s reception secure association.
                            Ssci                Short Secure Channel Identifier used in the MACsec’s transmission secure association.
                            KeysPtr             Pointer to the Keys (SAK, Hash and Salt key) to use in the MACsec’s transmission
                                                secure association.
                            Active              Boolean to enable/disable the MACsec’s transmission secure association.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       Std_ReturnType      E_OK:     The request has been accepted.
                                                E_NOT_OK: The request has not been accepted.
        Description:        Request the Ethernet Switch Driver to create a Reception Secure Association in the provided Port.
                            The Short Secure Channel Identifier is included to support XPN configurations.
        Available via:      EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.SwitchMacSec</srcid><srcstatus/><internalId>1052</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>917</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_91205</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        Service Name:       EthIf_MacSecAddRxSa
        Syntax:             Std_ReturnType EthIf_MacSecAddRxSa(
                                                                 uint8 CtrlIdx,
                                                                 uint8 An,
                                                                 uint64 LowestPn,
                                                                 uint32 Ssci,
                                                                 const Mka_SakKeyPtrType* KeysPtr,
                                                                 boolean Active
                                                              );
        Service ID [hex]:   0x83
        Sync/Async:         Asynchronous
        Reentrancy:         Reentrant for different CtrlIdx.
                            Non-reentrant for the same CtrlIdx.
        Parameters (in):    CtrlIdx             Index of the Ethernet controller within the context of the Ethernet Interface.
                            An                  Association Number to use in the MACsec’s transmission secure association.
                            LowestPn            Lowest acceptable Packet Number in the MACsec’s reception secure association.
                            Ssci                Short Secure Channel Identifier used in the MACsec’s transmission secure association.
                            KeysPtr             Pointer to the Keys (SAK, Hash and Salt key) to use in the MACsec’s transmission
                                                secure association.
                            Active              Boolean to enable/disable the MACsec’s transmission secure association.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       Std_ReturnType      E_OK:     The request has been accepted.
                                                E_NOT_OK: The request has not been accepted.
        Description:        Request the Ethernet Interface (MACsec per SW) or the Ethernet Transceiver Driver to create a Reception Secure
                            Association in the Transceiver. The Short Secure Channel Identifier is included to support XPN configurations.
        Available via:      EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01300_MacSec_BasicTest_1</srcid><srcstatus/><internalId>1728</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>918</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_91228</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        Service Name:       EthIf_SwitchMacSecAddRxSaNotification
        Syntax:             void EthIf_SwitchMacSecAddRxSaNotification(
                                                                         const EthSwt_MgmtInfoType* MgmtInfoPtr
                                                                      );
        Service ID [hex]:   0x76
        Sync/Async:         Synchronous
        Reentrancy:         Reentrant for different MgmtInfoPtr.
                            Non-reentrant for the same MgmtInfoPtr.
        Parameters (in):    MgmtInfoPtr         Pointer to the management information within the context of an Ethernet Switch Driver.
                                                SwitchIdx in context of EthIf, PortIdx in context of EthSwt.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       None
        Description:        Callback to notify that EthIf_SwitchMacSecAddRxSa finished.
        Available via:      EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.SwitchMacSec</srcid><srcstatus/><internalId>1052</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>919</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_91229</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        Service Name:       EthIf_MacSecAddRxSaNotification
        Syntax:             void EthIf_MacSecAddRxSaNotification(
                                                                   uint8 CtrlIdx
                                                                );
        Service ID [hex]:   0x77
        Sync/Async:         Synchronous
        Reentrancy:         Reentrant for different CtrlIdx.
                            Non-reentrant for the same CtrlIdx.
        Parameters (in):    CtrlIdx             Index of the Ethernet controller within the context of the Ethernet Interface.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       None
        Description:        Callback to notify that EthIf_MacSecAddRxSa finished.
        Available via:      EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01300_MacSec_BasicTest_3</srcid><srcstatus/><internalId>1730</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>920</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_91230</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        Service Name:       EthIf_SwitchMacSecUpdateRxSa
        Syntax:             Std_ReturnType EthIf_SwitchMacSecUpdateRxSa(
                                                                          const EthSwt_MgmtInfoType* MgmtInfoPtr,
                                                                          uint8 An,
                                                                          uint64 LowestPn,
                                                                          boolean Active
                                                                       );
        Service ID [hex]:   0x78
        Sync/Async:         Synchronous
        Reentrancy:         Reentrant for different MgmtInfoPtr.
                            Non-reentrant for the same MgmtInfoPtr.
        Parameters (in):    MgmtInfoPtr         Pointer to the management information within the context of an Ethernet Switch Driver.
                                                SwitchIdx in context of EthIf, PortIdx in context of EthSwt.
                            An                  Association Number to use in the MACsec’s transmission secure association.
                            LowestPn            Lowest acceptable Packet Number in the MACsec’s reception secure association.
                            Active              Boolean to enable/disable the MACsec’s transmission secure association.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       Std_ReturnType      E_OK:     The request has been accepted.
                                                E_NOT_OK: The request has not been accepted.
        Description:        Request the Ethernet Switch Driver to update the Reception Secure Association with the given Packet Number.
                            The Active parameter is included to change the specified AN status.
        Available via:      EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.SwitchMacSec</srcid><srcstatus/><internalId>1052</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>921</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_91214</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        Service Name:       EthIf_MacSecUpdateRxSa
        Syntax:             Std_ReturnType EthIf_MacSecUpdateRxSa(
                                                                    uint8 CtrlIdx,
                                                                    uint8 An,
                                                                    uint64 LowestPn,
                                                                    boolean Active
                                                                 );
        Service ID [hex]:   0x82
        Sync/Async:         Synchronous
        Reentrancy:         Reentrant for different CtrlIdx.
                            Non-reentrant for the same CtrlIdx.
        Parameters (in):    CtrlIdx             Index of the Ethernet controller within the context of the Ethernet Interface.
                            An                  Association Number to use in the MACsec’s transmission secure association.
                            LowestPn            Lowest acceptable Packet Number in the MACsec’s reception secure association.
                            Active              Boolean to enable/disable the MACsec’s transmission secure association.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       Std_ReturnType      E_OK:     The request has been accepted.
                                                E_NOT_OK: The request has not been accepted.
        Description:        Request the Ethernet Interface (MACsec per SW) or the Ethernet Transceiver Driver to update the Reception
                            Secure Association with the given Packet Number. The Active parameter is included to change the specified AN status.
        Available via:      EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01300_MacSec_BasicTest_2</srcid><srcstatus/><internalId>1729</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>922</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_91231</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        Service Name:       EthIf_SwitchMacSecDeleteRxSa
        Syntax:             Std_ReturnType EthIf_SwitchMacSecDeleteRxSa(
                                                                          const EthSwt_MgmtInfoType* MgmtInfoPtr,
                                                                          uint8 An
                                                                       );
        Service ID [hex]:   0x79
        Sync/Async:         Synchronous
        Reentrancy:         Reentrant for different MgmtInfoPtr.
                            Non-reentrant for the same MgmtInfoPtr.
        Parameters (in):    MgmtInfoPtr         Pointer to the management information within the context of an Ethernet Switch Driver.
                                                SwitchIdx in context of EthIf, PortIdx in context of EthSwt.
                            An                  Association Number to use in the MACsec’s transmission secure association.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       Std_ReturnType      E_OK:     The request has been accepted.
                                                E_NOT_OK: The request has not been accepted.
        Description:        Request the Ethernet Switch Driver to remove the Reception Secure Association identified by
                            the provided Association Number.
        Available via:      EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.SwitchMacSec</srcid><srcstatus/><internalId>1052</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>923</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_91207</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        Service Name:       EthIf_MacSecDeleteRxSa
        Syntax:             Std_ReturnType EthIf_MacSecDeleteRxSa(
                                                                    uint8 CtrlIdx,
                                                                    uint8 An
                                                                 );
        Service ID [hex]:   0x81
        Sync/Async:         Synchronous
        Reentrancy:         Reentrant for different CtrlIdx.
                            Non-reentrant for the same CtrlIdx.
        Parameters (in):    CtrlIdx             Index of the Ethernet controller within the context of the Ethernet Interface.
                            An                  Association Number to use in the MACsec’s transmission secure association.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       Std_ReturnType      E_OK:     The request has been accepted.
                                                E_NOT_OK: The request has not been accepted.
        Description:        Request the Ethernet Interface (MACsec per SW) or the Ethernet Transceiver Driver to remove the Reception
                            Secure Association identified by the provided Association Number.
        Available via:      EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01300_MacSec_BasicTest_2</srcid><srcstatus/><internalId>1729</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>924</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_91232</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        Service Name:       EthIf_SwitchMacSecGetTxSaNextPn
        Syntax:             Std_ReturnType EthIf_SwitchMacSecGetTxSaNextPn(
                                                                             const EthSwt_MgmtInfoType* MgmtInfoPtr,
                                                                             uint8 An,
                                                                             uint64* NextPnPtr
                                                                          );
        Service ID [hex]:   0x7A
        Sync/Async:         Synchronous
        Reentrancy:         Reentrant for different MgmtInfoPtr.
                            Non-reentrant for the same MgmtInfoPtr.
        Parameters (in):    MgmtInfoPtr         Pointer to the management information within the context of an Ethernet Switch Driver.
                                                SwitchIdx in context of EthIf, PortIdx in context of EthSwt.
                            An                  Association Number to use in the MACsec’s transmission secure association.
        Parameters (inout): None
        Parameters (out):   NextPnPtr           Pointer to the Next Packet Number read out from the MACsec Entity (SecY).
        Return value:       Std_ReturnType      E_OK:     The request has been accepted.
                                                E_NOT_OK: The request has not been accepted.
        Description:        Request the Ethernet Switch Driver to return the Packet Number that is used for the next packet in the
                            given Transmission Secure Association.
        Available via:      EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.SwitchMacSec</srcid><srcstatus/><internalId>1052</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>925</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_91210</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        Service Name:       EthIf_MacSecGetTxSaNextPn
        Syntax:             Std_ReturnType EthIf_MacSecGetTxSaNextPn(
                                                                       uint8 CtrlIdx,
                                                                       uint8 An,
                                                                       uint64* NextPnPtr
                                                                    );
        Service ID [hex]:   0x90
        Sync/Async:         Synchronous
        Reentrancy:         Reentrant for different CtrlIdx.
                            Non-reentrant for the same CtrlIdx.
        Parameters (in):    CtrlIdx             Index of the Ethernet controller within the context of the Ethernet Interface.
                            An                  Association Number to use in the MACsec’s transmission secure association.
        Parameters (inout): None
        Parameters (out):   NextPnPtr           Pointer to the Next Packet Number read out from the MACsec Entity (SecY).
        Return value:       Std_ReturnType      E_OK:     The request has been accepted.
                                                E_NOT_OK: The request has not been accepted.
        Description:        Request the Ethernet Interface (MACsec per SW) or the Ethernet Transceiver Driver to return the Packet Number
                            that is used for the next packet in the given Transmission Secure Association.
        Available via:      EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01300_MacSec_BasicTest_2</srcid><srcstatus/><internalId>1729</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>926</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_91233</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        Service Name:       EthIf_SwitchMacSecGetMacSecStats
        Syntax:             Std_ReturnType EthIf_SwitchMacSecGetMacSecStats(
                                                                              const EthSwt_MgmtInfoType* MgmtInfoPtr
                                                                           );
        Service ID [hex]:   0x7B
        Sync/Async:         Asynchronous
        Reentrancy:         Reentrant for different MgmtInfoPtr.
                            Non-reentrant for the same MgmtInfoPtr.
        Parameters (in):    MgmtInfoPtr         Pointer to the management information within the context of an Ethernet Switch Driver.
                                                SwitchIdx in context of EthIf, PortIdx in context of EthSwt.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       Std_ReturnType      E_OK:     The request has been accepted.
                                                E_NOT_OK: The request has not been accepted.
        Description:        Request the Ethernet switch Driver to provide MACsec statistics.
                            The result is returned through EthIf_SwitchMacSecGetMacSecStatsNotification.
        Available via:      EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.SwitchMacSec</srcid><srcstatus/><internalId>1052</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>927</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_91209</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        Service Name:       EthIf_MacSecGetMacSecStats
        Syntax:             Std_ReturnType EthIf_MacSecGetMacSecStats(
                                                                        uint8 CtrlIdx
                                                                     );
        Service ID [hex]:   0x89
        Sync/Async:         Asynchronous
        Reentrancy:         Reentrant for different CtrlIdx.
                            Non-reentrant for the same CtrlIdx.
        Parameters (in):    CtrlIdx             Index of the Ethernet controller within the context of the Ethernet Interface.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       Std_ReturnType      E_OK:     The request has been accepted.
                                                E_NOT_OK: The request has not been accepted.
        Description:        Request the Ethernet Interface (MACsec per SW) or the Ethernet Transceiver Driver to provide MACsec statistics.
                            The result is returned through EthIf_MacSecGetMacSecStatsNotification.
        Available via:      EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01300_MacSec_BasicTest_1</srcid><srcstatus/><internalId>1728</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>928</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_91234</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        Service Name:       EthIf_SwitchMacSecGetMacSecStatsNotification
        Syntax:             void EthIf_SwitchMacSecGetMacSecStatsNotification(
                                                                                const EthSwt_MgmtInfoType* MgmtInfoPtr,
                                                                                const Mka_Stats_SecYType*  MacSecStatsPtr
                                                                             );
        Service ID [hex]:   0x7C
        Sync/Async:         Synchronous
        Reentrancy:         Reentrant for different MgmtInfoPtr.
                            Non-reentrant for the same MgmtInfoPtr.
        Parameters (in):    MgmtInfoPtr         Pointer to the management information within the context of an Ethernet Switch Driver.
                                                SwitchIdx in context of EthIf, PortIdx in context of EthSwt.
                            MacSecStatsPtr      Pointer to a structure including the MACsec statistics of an MKA participant.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       None
        Description:        Callback to notify that EthIf_SwitchMacSecGetMacSecStats finished and provide the requested statistics.
        Available via:      EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.SwitchMacSec</srcid><srcstatus/><internalId>1052</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>929</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_91235</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        Service Name:       EthIf_MacSecGetMacSecStatsNotification
        Syntax:             void EthIf_MacSecGetMacSecStatsNotification(
                                                                          uint8 CtrlIdx,
                                                                          const Mka_Stats_SecYType* MacSecStatsPtr
                                                                       );
        Service ID [hex]:   0x7D
        Sync/Async:         Synchronous
        Reentrancy:         Reentrant for different CtrlIdx.
                            Non-reentrant for the same CtrlIdx.
        Parameters (in):    CtrlIdx             Index of the Ethernet controller within the context of the Ethernet Interface.
                            MacSecStatsPtr      Pointer to a structure including the MACsec statistics of an MKA participant.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       None
        Description:        Callback to notify that EthIf_MacSecGetMacSecStats finished and provide the requested statistics.
        Available via:      EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01300_MacSec_BasicTest_3</srcid><srcstatus/><internalId>1730</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>930</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_91236</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        Service Name:       EthIf_SwitchMacSecOperational
        Syntax:             Std_ReturnType EthIf_SwitchMacSecOperational(
                                                                           const EthSwt_MgmtInfoType* MgmtInfoPtr,
                                                                           boolean MacSecOperational
                                                                        );
        Service ID [hex]:   0x7E
        Sync/Async:         Synchronous
        Reentrancy:         Reentrant
        Parameters (in):    MgmtInfoPtr         Pointer to the management information within the context of an Ethernet Switch Driver.
                                                SwitchIdx in context of EthIf, PortIdx in context of EthSwt.
                            MacSecOperational   Boolean to notify if MACsec is operational.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       Std_ReturnType      E_OK:     The request has been accepted.
                                                E_NOT_OK: The request has not been accepted.
        Description:        To inform EthIf that MacSec is operational and that EthSM can be notified. (Switch case)
        Available via:      EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.SwitchMacSec</srcid><srcstatus/><internalId>1052</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>931</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_91212</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        Service Name:       EthIf_MacSecOperational
        Syntax:             Std_ReturnType EthIf_MacSecOperational(
                                                                     uint8 CtrlIdx,
                                                                     boolean MacSecOperational
                                                                  );
        Service ID [hex]:   0x1C
        Sync/Async:         Synchronous
        Reentrancy:         Reentrant
        Parameters (in):    CtrlIdx             Index of the Ethernet controller within the context of the Ethernet Interface.
                            MacSecOperational   Boolean to notify if MACsec is operational.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       Std_ReturnType      E_OK:     The request has been accepted.
                                                E_NOT_OK: The request has not been accepted.
        Description:        To inform EthIf that MacSec is operational and that EthSM can be informed. (Ethernet Interface (MACsec per SW) or
                            the Ethernet Transceiver Driver).
        Available via:      EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01300_MacSec_BasicTest_3</srcid><srcstatus/><internalId>1730</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>932</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_91237</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        Service Name:       EthIf_SwitchMacSecSetControlledPortEnabled
        Syntax:             Std_ReturnType EthIf_SwitchMacSecSetControlledPortEnabled(
                                                                                        const EthSwt_MgmtInfoType* MgmtInfoPtr,
                                                                                        boolean ControlledPortEnabled
                                                                                     );
        Service ID [hex]:   0x7F
        Sync/Async:         Synchronous
        Reentrancy:         Reentrant for different MgmtInfoPtr.
                            Non-reentrant for the same MgmtInfoPtr.
        Parameters (in):    MgmtInfoPtr         Pointer to the management information within the context of an Ethernet Switch Driver.
                                                SwitchIdx in context of EthIf, PortIdx in context of EthSwt.
                            ControlledPortEnabled Boolean to activate the Controlled Port of the PAE.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       Std_ReturnType        E_OK:     The request has been accepted.
                                                  E_NOT_OK: The request has not been accepted.
        Description:        Requests to set the Controlled Port enabled parameter of a PAE.
        Available via:      EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.NotSupported.SwitchMacSec</srcid><srcstatus/><internalId>1052</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>933</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.SWS_EthIf_91238</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthernetInterface_R22-11.pdf</source>
      <version>1</version>
      <description>
        Service Name:       EthIf_MacSecSetControlledPortEnabled
        Syntax:             Std_ReturnType EthIf_MacSecSetControlledPortEnabled(
                                                                                  uint8 CtrlIdx,
                                                                                  boolean ControlledPortEnabled
                                                                               );
        Service ID [hex]:   0x80
        Sync/Async:         Synchronous
        Reentrancy:         Reentrant for different CtrlIdx.
                            Non-reentrant for the same CtrlIdx.
        Parameters (in):    CtrlIdx               Index of the Ethernet controller within the context of the Ethernet Interface.
                            ControlledPortEnabled Boolean to activate the Controlled Port of the PAE.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       Std_ReturnType        E_OK:     The request has been accepted.
                                                  E_NOT_OK: The request has not been accepted.
        Description:        Requests to set the Controlled Port enabled parameter of a PAE.
        Available via:      EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest01300_MacSec_BasicTest_3</srcid><srcstatus/><internalId>1730</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>934</internalId></specobject>

<!-- ===============================[Configuration specification]=============================== -->
    <specobject>
      <id>EthIf.ASR_R22-11.ECUC_EthIf_00089</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name:               EthIfMacSecSupport
        Parameter Type:     EcucEnumerationParamDef
        Range:              NO_MACSEC - MACsec is not enabled for parent EthIfController.
                            HW_MACSEC - MACsec is supported by hardware for parent EthIfController.
                            SW_MACSEC - MACsec is supported by software for parent EthIfController.
        Parent Containers:  EthIfController
        Description:        MACsec support of the Ethernet interface controller.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Scope: LOCAL
        Default value:      NO_MACSEC
        Dependency:         Enabled if EthIfMacSecSupportEnable == TRUE.
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.MacSec.ConfigParamChanged</srcid><srcstatus/><internalId>1051</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.EB.ECUC_EthIf_00089</srcid><srcstatus/><internalId>936</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>935</internalId></specobject>

    <specobject>
      <id>EthIf.EB.ECUC_EthIf_00089</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               EthIfMacSecSupport
        Parameter Type:     EcucEnumerationParamDef
        Range:              NO_MACSEC - MACsec is not enabled for parent EthIfController.
                            HW_MACSEC - MACsec is supported by hardware for parent EthIfController.
        Parent Containers:  EthIfGeneral
        Description:        MACsec support of the Ethernet interface controller.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Post-Build-Variant-Value: true
        Value-Configuration Class: PRE-COMPILE, ALL VARIANTS
        Symbolic-Name-Value: false
        Scope: LOCAL
        Default value:      NO_MACSEC
        Dependency:
      </description>
      <comment>
        The following changes have been made:
        - Parameter moved from EthIfController to EthIfGeneral container.
        - Lower Multiplicity changed to 1.
        - Value configuration class changed to pre-compile only.
        - SW MACsec is not supported.
      </comment>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/EthIf.xdm.m4_1128</srcid><srcstatus/><internalId>1075</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR_R22-11.ECUC_EthIf_00089</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>935</internalId></provcov>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>936</internalId></specobject>

    <specobject>
      <id>EthIf.ASR_R22-11.ECUC_EthIf_00090</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name:               EthIfPaeInstanceRef
        Parameter Type:     Symbolic name reference to [ EthIfPaeInstanceRef ]
        Parent Containers:  EthIfController
        Description:        Reference to the PAE that provides MACsec protection.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Default value:      -
        Dependency:         Enabled if EthIfMacSecSupportEnable == TRUE and EthIfMacSecSupport
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.MacSec.ConfigParamChanged</srcid><srcstatus/><internalId>1051</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.EB.ECUC_EthIf_00090</srcid><srcstatus/><internalId>938</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>937</internalId></specobject>

    <specobject>
      <id>EthIf.EB.ECUC_EthIf_00090</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               EthIfPaeInstanceRef
        Parameter Type:     Symbolic name reference to [ MkaPaeInstance ]
        Parent Containers:  EthIfController
        Description:        Reference to the PAE that provides MACsec protection.
        Lower Multiplicity: 0
        Upper Multiplicity: 254
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Default value:      -
        Dependency:         Enabled if EthIfMacSecSupportEnable == TRUE.
      </description>
      <comment>
        Upper multiplicity changed from 1 to 254 in order to support aggregation of MAC operational from multiple PAEs.
      </comment>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/EthIf.xdm.m4_196</srcid><srcstatus/><internalId>1069</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/config/EthIf_Extension.xdm.m4_209</srcid><srcstatus/><internalId>1095</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR_R22-11.ECUC_EthIf_00090</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>937</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_00561</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>874</internalId></provcov>
        <provcov>
          <linksto>EthIf.dsn.Func021.MacSecSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>938</internalId></specobject>

    <specobject>
      <id>EthIf.SWS_EthIf_00068</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R22-11.arxml</source>
      <version>2</version>
      <description>
        If the latest accepted controller mode is equal to ETH_MODE_ACTIVE or ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST
        for the given EthIfController, then the function EthIf_ProvideTxBuffer shall forward the call to the
        respective Ethernet Controller Driver or CanXL Controller Driver. Otherwise the function shall
        reject the request for a transmission buffer and return with E_NOT_OK.
      </description>
      <comment>
        Arguments of Eth_ProvideTxBuffer:
      - CtrlIdx: search for the EthIfCtrl with EthIfCtrlIdx==CtrlIdx, follow reference to EthCtrlConfig, pass on EthCtrlIdx
      - BufIdxPtr: just passed on
      - BufPtr: if VLAN is not configured: just passed on, else see EthIf.ASR40.SWS_EthIf_00147
      - LenBytePtr: if VLAN is not configured: just passed on, else see EthIf.ASR40.SWS_EthIf_00147
      - return value: just passed on
      </comment>
      <releases>
        <release>AUTOSAR R22-11</release>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.SWS_EthIf_00068.1</srcid><srcstatus/><internalId>940</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00068.2</srcid><srcstatus/><internalId>941</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00068.3</srcid><srcstatus/><internalId>942</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>408</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>939</internalId></specobject>

    <specobject>
      <id>EthIf.SWS_EthIf_00068.1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R22-11.arxml</source>
      <version>1</version>
      <description>
        If the latest accepted controller mode is equal to ETH_MODE_ACTIVE for the given EthIfController,
        then the function EthIf_ProvideTxBuffer shall forward the call to the respective
        Ethernet Controller Driver or CanXL Controller Driver.
      </description>
      <comment>
        Arguments of Eth_ProvideTxBuffer:
      - CtrlIdx: search for the EthIfCtrl with EthIfCtrlIdx==CtrlIdx, follow reference to EthCtrlConfig, pass on EthCtrlIdx
      - BufIdxPtr: just passed on
      - BufPtr: if VLAN is not configured: just passed on, else see EthIf.ASR40.SWS_EthIf_00147
      - LenBytePtr: if VLAN is not configured: just passed on, else see EthIf.ASR40.SWS_EthIf_00147
      - return value: just passed on
      </comment>
      <releases>
        <release>AUTOSAR R22-11</release>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest05008_BufReq_OK</srcid><srcstatus/><internalId>1439</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest05009_ProvideTxBuffer_Disabled_VlanId</srcid><srcstatus/><internalId>1440</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest11022_Transmit_NoVendor</srcid><srcstatus/><internalId>1721</internalId></linkedfrom><linkedfrom><srcid>EthIf_T150_00_ProvideTxBuffer_ValidParameters</srcid><srcstatus/><internalId>1776</internalId></linkedfrom><linkedfrom><srcid>EthIf_T350_00_ProvideTxBuffer_VLanControllers</srcid><srcstatus/><internalId>1801</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest02022_ProvideTxBuffer_Disabled_VlanId</srcid><srcstatus/><internalId>1906</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>408</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00068</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>939</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>940</internalId></specobject>

    <specobject>
      <id>EthIf.SWS_EthIf_00068.2</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R22-11.arxml</source>
      <version>1</version>
      <description>
        If the latest accepted controller mode is equal to ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST
        for the given EthIfController, then the function EthIf_ProvideTxBuffer shall forward
        the call to the respective Ethernet Controller Driver or CanXL Controller Driver.
      </description>
      <comment>
        Arguments of Eth_ProvideTxBuffer:
      - CtrlIdx: search for the EthIfCtrl with EthIfCtrlIdx==CtrlIdx, follow reference to EthCtrlConfig, pass on EthCtrlIdx
      - BufIdxPtr: just passed on
      - BufPtr: if VLAN is not configured: just passed on, else see EthIf.ASR40.SWS_EthIf_00147
      - LenBytePtr: if VLAN is not configured: just passed on, else see EthIf.ASR40.SWS_EthIf_00147
      - return value: just passed on
      </comment>
      <releases>
        <release>AUTOSAR R22-11</release>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest05012_BufReq_OK</srcid><srcstatus/><internalId>1443</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest05013_ProvideTxBuffer_Disabled_VlanId</srcid><srcstatus/><internalId>1444</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest11023_Transmit_NoVendor</srcid><srcstatus/><internalId>1722</internalId></linkedfrom><linkedfrom><srcid>EthIf_T150_01_ProvideTxBuffer_ValidParameters</srcid><srcstatus/><internalId>1777</internalId></linkedfrom><linkedfrom><srcid>EthIf_T350_01_ProvideTxBuffer_VLanControllers</srcid><srcstatus/><internalId>1802</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest02047_ProvideTxBuffer_Disabled_VlanId</srcid><srcstatus/><internalId>1928</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>408</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00068</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>939</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>941</internalId></specobject>

    <specobject>
      <id>EthIf.SWS_EthIf_00068.3</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R22-11.arxml</source>
      <version>1</version>
      <description>
        If the latest accepted controller mode is equal neither to ETH_MODE_ACTIVE nor
        ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST for the given EthIfController, then the function
        EthIf_ProvideTxBuffer shall reject the request for a transmission buffer and return with E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest05011_MODE_DOWN_ProvideTxBuffer_E_NOT_OK</srcid><srcstatus/><internalId>1442</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06039_MODE_DOWN_ProvideTxBuffer_E_NOT_OK</srcid><srcstatus/><internalId>1520</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>408</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00068</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>939</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>942</internalId></specobject>

    <specobject>
      <id>EthIf.SWS_EthIf_00076</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R22-11.arxml</source>
      <version>2</version>
      <description>
        If the latest accepted controller mode is equal to ETH_MODE_ACTIVE or ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST
        for the given EthIfController, then the function EthIf_Transmit shall forward the call to the respective Ethernet
        Controller Driver. Otherwise the function shall reject the request for a transmission and return with E_NOT_OK.
      </description>
      <comment>
        Arguments of Eth_Transmit:
        - CtrlIdx: search for the EthIfCtrl with EthIfCtrlIdx==CtrlIdx, follow reference to EthCtrlConfig, pass on EthCtrlIdx
        - BufIdx: just passed on
        - TxConfirmation: just passed on
        - FrameType: if VLAN is not configured: just passed on, else see EthIf.ASR43.SWS_EthIf_00148
        - LenByte: if VLAN is not configured: just passed on, else: LenByte+4
        - return value: just passed on
      </comment>
      <releases>
        <release>AUTOSAR R22-11</release>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.SWS_EthIf_00076.1</srcid><srcstatus/><internalId>944</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00076.2</srcid><srcstatus/><internalId>945</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00076.3</srcid><srcstatus/><internalId>946</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>408</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>943</internalId></specobject>

    <specobject>
      <id>EthIf.SWS_EthIf_00076.1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R22-11.arxml</source>
      <version>1</version>
      <description>
        If the latest accepted controller mode is equal to ETH_MODE_ACTIVE for the given EthIfController,
        then the function EthIf_Transmit shall forward the call to the respective Ethernet Controller Driver.
      </description>
      <comment>
        Arguments of Eth_Transmit:
        - CtrlIdx: search for the EthIfCtrl with EthIfCtrlIdx==CtrlIdx, follow reference to EthCtrlConfig, pass on EthCtrlIdx
        - BufIdx: just passed on
        - TxConfirmation: just passed on
        - FrameType: if VLAN is not configured: just passed on, else see EthIf.ASR43.SWS_EthIf_00148
        - LenByte: if VLAN is not configured: just passed on, else: LenByte+4
        - return value: just passed on
      </comment>
      <releases>
        <release>AUTOSAR R22-11</release>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest11022_Transmit_NoVendor</srcid><srcstatus/><internalId>1721</internalId></linkedfrom><linkedfrom><srcid>EthIf_T130_00_Transmit_ValidParameters</srcid><srcstatus/><internalId>1762</internalId></linkedfrom><linkedfrom><srcid>EthIf_T330_00_Transmit_ValidParameters</srcid><srcstatus/><internalId>1785</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>408</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00076</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>943</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>944</internalId></specobject>

    <specobject>
      <id>EthIf.SWS_EthIf_00076.2</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R22-11.arxml</source>
      <version>1</version>
      <description>
        If the latest accepted controller mode is equal to ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST for the given EthIfController,
        then the function EthIf_Transmit shall forward the call to the respective Ethernet Controller Driver.
      </description>
      <comment>
        Arguments of Eth_Transmit:
        - CtrlIdx: search for the EthIfCtrl with EthIfCtrlIdx==CtrlIdx, follow reference to EthCtrlConfig, pass on EthCtrlIdx
        - BufIdx: just passed on
        - TxConfirmation: just passed on
        - FrameType: if VLAN is not configured: just passed on, else see EthIf.ASR43.SWS_EthIf_00148
        - LenByte: if VLAN is not configured: just passed on, else: LenByte+4
        - return value: just passed on
      </comment>
      <releases>
        <release>AUTOSAR R22-11</release>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest11023_Transmit_NoVendor</srcid><srcstatus/><internalId>1722</internalId></linkedfrom><linkedfrom><srcid>EthIf_T130_02_Transmit_ValidParameters</srcid><srcstatus/><internalId>1764</internalId></linkedfrom><linkedfrom><srcid>EthIf_T330_01_Transmit_ValidParameters</srcid><srcstatus/><internalId>1786</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>408</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00076</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>943</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>945</internalId></specobject>

    <specobject>
      <id>EthIf.SWS_EthIf_00076.3</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R22-11.arxml</source>
      <version>1</version>
      <description>
        If the latest accepted controller mode is equal neither to ETH_MODE_ACTIVE nor ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST
        for the given EthIfController, then the function EthIf_Transmit shall reject the request for a
        transmission and return with E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06040_MODE_DOWN_Transmit_E_NOT_OK</srcid><srcstatus/><internalId>1521</internalId></linkedfrom><linkedfrom><srcid>EthIf_T130_01_MODE_DOWN_Transmit_E_NOT_OK</srcid><srcstatus/><internalId>1763</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>408</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00076</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>943</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>946</internalId></specobject>

    <specobject>
      <id>EthIf.SWS_EthIf_91006</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R22-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | EthIf_SleepIndication
        Syntax
        void EthIf_SleepIndication (uint8 TrcvIdx)
        Service ID [hex] | 0x68
        Sync/Async | Synchronous
        Reentrancy | Reentrant
        Parameters (in) | TrcvIdx | Index of the Ethernet transceiver within the context of the
        Ethernet Interface
        Parameters (inout) | None
        Parameters (out) | None
        Return value | None
        Description | This API is called by the corresponding EthTrcv, if a sleep indication was detected on the
        network. This could be used e.g. for Ethernet hardware which is compliant to the OA TC10. In
        this case the Ethernet hardware (PHY) detect an Sleep.Indication which was triggered by a
        Sleep.Request of the connected link partner.
        Available via | EthIf.h
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ASR430_SleepIndication</srcid><srcstatus/><internalId>1626</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.EB.SWS_EthIf_91006.E_NOT_INITIALIZED</srcid><srcstatus/><internalId>370</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.SWS_EthIf_91006.INV_TRCV_IDX.1</srcid><srcstatus/><internalId>371</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.SWS_EthIf_91006.INV_TRCV_IDX.2</srcid><srcstatus/><internalId>372</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_91006.ServiceId</srcid><srcstatus/><internalId>948</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00497</srcid><srcstatus/><internalId>949</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00499.4</srcid><srcstatus/><internalId>954</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>947</internalId></specobject>
    
    <specobject>
      <id>EthIf.SWS_EthIf_91006.ServiceId</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The macro ETHIF_SLEEPINDICATION_SVCID shall have the value:
        Service ID[hex]: 0x68
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_CompTest_05_ServiceId_ErrorId</srcid><srcstatus/><internalId>1242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91006</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>947</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>948</internalId></specobject>

    <specobject>
      <id>EthIf.SWS_EthIf_00497</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R22-11.arxml</source>
      <version>1</version>
      <description>
        The function shall call EthSM_SleepIndication with
        the corresponding EthIfCtrl.
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ASR430_SleepIndication</srcid><srcstatus/><internalId>1626</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91006</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>947</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>949</internalId></specobject>

    <specobject>
      <id>EthIf.SWS_EthIf_00499</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R22-11.arxml</source>
      <version>1</version>
      <description>
        For EthIfTransceiver where the referenced EthTrcv is
        acting as a passive communication slave (EthTrcvActAsSlavePassiveEnabled set to
        TRUE), EthIf shall check for unexpected link down. If an unexpected link down (link
        state is requested with ETHTRCV_LINK_STATE_ACTIVE, but current link state is
        ETHTRCV_LINK_STATE_DOWN) lasts as long as specified in EthIfQualifiedUnexptecedLinkDownTime,
        EthIf shall trigger to release the affected communication channel by calling EthSM_SleepIndication.
        If an unexpected link down was detected, the EthSM shall immediately be indicated via
        EthSM_TrcvLinkStateChg without considering EthIfQualifiedUnexpectedLinkDownTime.
      </description>
      <comment>
        Note:  This requirement should grant that a communication channel that act as an passive communication
        channel will shutdown even though the communication master could not transmit a sleep over the network
        (e.g. hardware failure, unexpected shutdown of the ECU that act as communication master, a.s.o).
      </comment>
      <releases>
        <release>AUTOSAR R22-11</release>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.SWS_EthIf_00499.1</srcid><srcstatus/><internalId>951</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00499.2</srcid><srcstatus/><internalId>952</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00499.3</srcid><srcstatus/><internalId>953</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00499.4</srcid><srcstatus/><internalId>954</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>950</internalId></specobject>

    <specobject>
      <id>EthIf.SWS_EthIf_00499.1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R22-11.arxml</source>
      <version>1</version>
      <description>
        For EthIfTransceiver where the referenced EthTrcv is
        acting as a passive communication slave (EthTrcvActAsSlavePassiveEnabled set to
        TRUE), EthIf shall check for unexpected link down. If an unexpected link down (link
        state is requested with ETHTRCV_LINK_STATE_ACTIVE, but current link state is
        ETHTRCV_LINK_STATE_DOWN) lasts as long as specified in EthIfQualifiedUnexptecedLinkDownTime,
        EthIf shall trigger to release the affected communication channel by calling EthSM_SleepIndication.
      </description>
      <comment>
        Unexpected link down means that link went from ETHTRCV_LINK_STATE_ACTIVE to ETHTRCV_LINK_STATE_DOWN
        without calling EthIf_SleepIndication.
      </comment>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ASR430_UnexpectedLinkDownTime_Timer</srcid><srcstatus/><internalId>1625</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00499</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>950</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>951</internalId></specobject>

    <specobject>
      <id>EthIf.SWS_EthIf_00499.2</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R22-11.arxml</source>
      <version>1</version>
      <description>
        For EthIfTransceiver where the referenced EthTrcv is
        acting as a passive communication slave (EthTrcvActAsSlavePassiveEnabled set to
        TRUE), EthIf shall check for unexpected link down. If an unexpected link down (link
        state is requested with ETHTRCV_LINK_STATE_ACTIVE, but current link state is
        ETHTRCV_LINK_STATE_DOWN) lasts as long as specified in EthIfQualifiedUnexptecedLinkDownTime,
        EthIf shall trigger to release the affected communication channel by calling EthSM_SleepIndication.
        If EthIfQualifiedUnexptecedLinkDownTime is set to 0 then EthSM_SleepIndication will be called immediately.
      </description>
      <comment>
        Unexpected link down detected means that link went from ETHTRCV_LINK_STATE_ACTIVE to ETHTRCV_LINK_STATE_DOWN
        without calling EthIf_SleepIndication.
      </comment>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ASR430_UnexpectedLinkDownTime_Zero</srcid><srcstatus/><internalId>1624</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00499</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>950</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>952</internalId></specobject>

    <specobject>
      <id>EthIf.SWS_EthIf_00499.3</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R22-11.arxml</source>
      <version>1</version>
      <description>
        For EthIfTransceiver where the referenced EthTrcv is
        acting as a passive communication slave (EthTrcvActAsSlavePassiveEnabled set to
        TRUE), EthIf shall check for unexpected link down. If an unexpected link down was detected,
        the EthSM shall immediately be indicated via EthSM_TrcvLinkStateChg without considering
        EthIfQualifiedUnexpectedLinkDownTime.
      </description>
      <comment>
        Unexpected link down detected means that link went from ETHTRCV_LINK_STATE_ACTIVE to ETHTRCV_LINK_STATE_DOWN
        without calling EthIf_SleepIndication.
      </comment>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ASR430_TrcvLinkStateChg</srcid><srcstatus/><internalId>1623</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00499</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>950</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>953</internalId></specobject>

    <specobject>
      <id>EthIf.SWS_EthIf_00499.4</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R22-11.arxml</source>
      <version>1</version>
      <description>
        For EthIfTransceiver where the referenced EthTrcv is
        acting as a passive communication slave (EthTrcvActAsSlavePassiveEnabled set to
        TRUE), EthIf shall check for unexpected link down. If an expected link down was detected,
        the EthSM shall not be indicated via EthSM_SleepIndication after
        EthIfQualifiedUnexpectedLinkDownTime.
      </description>
      <comment>
        Expected link down detected means that link went from ETHTRCV_LINK_STATE_ACTIVE to ETHTRCV_LINK_STATE_DOWN
        with calling EthIf_SleepIndication.
      </comment>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ASR430_SleepIndication_UnexpectedLinkDownTime_Zero</srcid><srcstatus/><internalId>1627</internalId></linkedfrom><linkedfrom><srcid>EthIf_ASR430_SleepIndication_UnexpectedLinkDownTime_Timer</srcid><srcstatus/><internalId>1628</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91006</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>947</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00499</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>950</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>954</internalId></specobject>
    
    <specobject>
      <id>EthIf.ECUC_EthIf_00078</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: EthIfQualifiedUnexpectedLinkDownTime
        Parameter Type: FloatValue
        Parent Containers: EthIfTransceiver,
        Description: Specifies the time in seconds an unexpected link down is qualified. This parameter 
        is only used for those Ethernet channels where the ECU act as a passive communication slave (
        referenced EthTrcv set EthTrcvActAsSlavePassiveEnabled = TRUE). Tags: atp.Status=draft
        Introduction: The value shall be a multiple integral of EthIf_MainFunctionState.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: INF (Type: OPEN)
        Min-Value: 0 (Type: OPEN)
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/EthIf_Extension.xdm.m4_728</srcid><srcstatus/><internalId>1102</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>955</internalId></specobject>

    <specobject>
      <id>EthIf.SWS_EthIf_00479</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R22-11.arxml</source>
      <version>1</version>
      <description>
        Everytime EthIf_SetControllerMode has been called for an EthIfController with 
        ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST and this EthIfController has a reference to an 
        EthIfTransceiver, then EthIf shall forward the call to the following functions in the given 
        order, independent of the current mode:
        EthTrcv_SetTransceiverMode with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST
        EthTrcv_TransceiverLinkStateRequest with ETHTRCV_LINK_STATE_ACTIVE, only if the current state 
        is ETHTRCV_LINK_STATE_DOWN
      </description>
      <comment>
        Requirement is partly deviated. EthIf does not call EthTrcv_TransceiverLinkStateRequest.
      </comment>
      <releases>
        <release>AUTOSAR R22-11</release>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.LinkStateRequest</srcid><srcstatus/><internalId>1004</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>956</internalId></specobject>

    <specobject>
      <id>EthIf.SWS_EthIf_00480</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R22-11.arxml</source>
      <version>1</version>
      <description>
        Everytime EthIf_SetControllerMode has been called for an EthIfController with 
        ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST and this EthIfController has a reference to an EthIfSwitch,
        then EthIf shall forward the call to the following functions in the given order for all 
        EthSwtPorts of the respective EthIfSwitchPortGroup, independ of the current mode:
        EthSwt_SetSwitchPortMode with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST
        EthSwt_PortLinkStateRequest with ETHTRCV_LINK_STATE_ACTIVE, if the current mode is 
        ETHTRCV_LINK_STATE_DOWN
      </description>
      <comment>
        Requirement is partly deviated. EthIf does not call EthSwt_PortLinkStateRequest.
      </comment>
      <releases>
        <release>AUTOSAR R22-11</release>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.LinkStateRequest</srcid><srcstatus/><internalId>1004</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>957</internalId></specobject>

    <specobject>
      <id>EthIf.SWS_EthIf_00481</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R22-11.arxml</source>
      <version>1</version>
      <description>
        Everytime EthIf_SetControllerMode has been called for an EthIfController with 
        ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST and this EthIfController has a reference to an 
        EthIfSwitchPortGroup of type "control", then EthIf shall forward the call to the following 
        functions in the given order for all EthSwtPorts of the respective EthIfSwitchPortGroup, 
        independent of the current mode:
        EthSwt_SetSwitchPortMode with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST
        EthSwt_PortLinkStateRequest with ETHTRCV_LINK_STATE_ACTIVE, if the current mode is 
        ETHTRCV_LINK_STATE_DOWN
      </description>
      <comment>
        Requirement is partly deviated. EthIf does not call EthSwt_PortLinkStateRequest.
      </comment>
      <releases>
        <release>AUTOSAR R22-11</release>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.LinkStateRequest</srcid><srcstatus/><internalId>1004</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>958</internalId></specobject>

    <specobject>
      <id>EthIf.SWS_EthIf_00482</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R20-11.arxml</source>
      <version>1</version>
      <description>
        Everytime EthIf_SwitchPortGroupRequestMode has been called with 
        ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST, EthIf shall forward the call for all EthSwtPorts of the 
        respective EthIfSwitchPortGroup to the following functions in the given order independent of 
        the current EthSwtPort mode:
        EthSwt_SetSwitchPortMode with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST
        EthSwt_PortLinkStateRequest with ETHTRCV_LINK_STATE_ACTIVE, only if current link state is 
        ETHTRCV_LINK_STATE_DOWN
      </description>
      <comment>
        Requirement is partly deviated. EthIf does not call EthSwt_PortLinkStateRequest.
      </comment>
      <releases>
        <release>AUTOSAR R22-11</release>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.EthIf.LinkStateRequest</srcid><srcstatus/><internalId>1004</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>959</internalId></specobject>

    <specobject>
      <id>EthIf.SWS_EthIf_00483</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EthIf_R22-11.arxml</source>
      <version>1</version>
      <description>
        If EthIf_SwitchPortGroupRequestMode is called with ETH_MODE_ACTIVE or 
        ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST, then a running timer to delay the switch off all ports of 
        the respective EthIfSwitchPortGroup (PortGroupIdx) shall be canceled.
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06041_SwitchPortGroupRequestMode_Timer</srcid><srcstatus/><internalId>1522</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>960</internalId></specobject>

  </specobjects>
    <specobjects doctype="swurs">
    <specobject>
      <id>EthIf.SWS_BSW_00212.NullPointerChecking</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_BSWGeneral.pdf, v4.3.0</source>
      <version>1</version>
      <description>
        According to SWS_BSW_00212 when the detection of Development errors is active, then pointer
        parameters shall be checked against NULL_PTR unless NULL_PTR is explicitly allowed as a
        valid pointer address value in the API parameter specification.
        The same also applies in case a structure address is passed for the structure's field(s).
        If such a violation is detected a development error shall be raised.
      </description>
      <releases>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.EB.RxIndication.PhysAddrPtr</srcid><srcstatus/><internalId>386</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>961</internalId></specobject>

  </specobjects>
    <specobjects doctype="swurs">

    <specobject>
      <id>EthIf.EB.DBGINST001</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Every public API of the module shall have debug instrumentation.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EthIf_DBGINST_001</srcid><srcstatus/><internalId>1231</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>962</internalId></specobject>

    <specobject>
      <id>EthIf.EB.DBGINST002</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The parameter of a API shall be available in the entry instrumentation.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EthIf_DBGINST_001</srcid><srcstatus/><internalId>1231</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>963</internalId></specobject>

    <specobject>
      <id>EthIf.EB.DBGINST003</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The parameter of a API shall be available in the exit instrumentation.
        If the API has a return value, the very first parameter of the macro shall contain the expected return value.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EthIf_DBGINST_001</srcid><srcstatus/><internalId>1231</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>964</internalId></specobject>

    <specobject>
      <id>EthIf.EB.DBGINST004</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The default implementation of the debug instrumentation shall be an empty macro.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EthIf_DBGINST_001</srcid><srcstatus/><internalId>1231</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>965</internalId></specobject>

    <specobject>
      <id>EthIf.EB.DBGINST005</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The module shall include the header files Base_Dbg.h in order to allow changing the default implementation of the debug instrumentation.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EthIf_DBGINST_001</srcid><srcstatus/><internalId>1231</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>966</internalId></specobject>

  </specobjects>
    <specobjects doctype="swurs">

    <specobject>
      <id>EthIf.EB.PBCFGM101</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Service name: EthIf_IsValidConfig
        Syntax: Std_ReturnType EthIf_IsValidConfig( void* ConfigPtr )
        Sync/Async: Synchronous
        Reentrancy: Reentrant
        Parameters (in): ConfigPtr, post build configuration manager
        configuration.
        Parameters (inout): None
        Parameters (out): None
        Return value: Returns E_OK if the EthIf configuration is valid otherwise E_NOT_OK. A
        null pointer is interpreted as invalid configuration.
        Description: This function determines if the EthIf configuration is valid. This
        function can be called also before the EthIf is initialized. No error reporting
        is necessary within this function.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_Test_IsValidConfig</srcid><srcstatus/><internalId>1232</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>967</internalId></specobject>

    <specobject>
      <id>EthIf.EB.PBCFGM102</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        A configuration is valid
        - if the platform signature in the post build configuration equals the value
          determined by the macro TS_PlatformSigIsValid.
        - if the link time signature in the post build configuration equals the link time
          signature in the link time configuration file.
        - if the compile time signature in the post build configuration equals the value of
          the macro ETHIF_CFG_SIGNATURE.
        - if the compile time signature of Published information in the post build configuration
          equals the value of the macro ETHIF_PUBLIC_INFO_SIGNATURE.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_Test_IsValidConfig</srcid><srcstatus/><internalId>1232</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>968</internalId></specobject>

    <specobject>
      <id>EthIf.EB.PBCFGM104</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For generalized consistency of the post build configuration versus the compile time
        configuration:
        - the post build configuration structure shall contain the uint32 value
          CfgSignature.
        - the EthIf_Cfg.h file shall contain the macro
          ETHIF_CFG_SIGNATURE.
        - the MCG shall generate this signature value of compile time parameters. The x-path
          function asc:getConfigSignature(nodeset) shall be used to determine the signature out
          of a list of parameters. The list of compile time parameters shall determined with the
          function asc:getConfigClassNodeList(cassString).
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_Test_IsValidConfig</srcid><srcstatus/><internalId>1232</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>969</internalId></specobject>

    <specobject>
      <id>EthIf.EB.PBCFGM104_1</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For generalized consistency of the post build configuration versus the compile time
        configuration:
        - the post build configuration structure shall contain the uint32 value
          PublicInfoSignature.
        - the EthIf_Cfg.h file shall contain the macro
          ETHIF_PUBLIC_INFO_SIGNATURE.
        - The MCG shall generate this signature value from the list of parameters of
          configuration class 'PublishedInformation' except 'Release'. The XPath function
          asc:getConfigSignature(nodeset) shall be used to determine the signature out of the
          list of parameters. The list of parameters shall be determined with the function
          asc:getConfigClassNodeList(cassString).
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_Test_IsValidConfig</srcid><srcstatus/><internalId>1232</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>970</internalId></specobject>

    <specobject>
      <id>EthIf.EB.PBCFGM105</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For generalized consistency of the post build configuration versus the link time
        configuration:
        - the post build configuration structure shall contain the uint32 value
          LcfgSignature.
        - the link time configuration shall contain the uint32 value
          EthIf_LcfgSignature.
        - the MCG shall generate this signature value of link time parameters. The x-path
          function asc:getConfigSignature(nodeset) shall be used to determine the signature out
          of a list of parameters. The list of link time parameters shall determined with the
          function asc:getConfigClassNodeList(cassString).
      </description>
      <comment>
        See also:
        https://infohub.automotive.elektrobit.com/display/PRJEBTRESOS/PostBuild#PostBuild-Consistencypostbuildconfig
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_Test_IsValidConfig</srcid><srcstatus/><internalId>1232</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>971</internalId></specobject>

    <specobject>
      <id>EthIf.EB.PBCFGM106</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For Platform verification:
        - the EthIf post build configuration structure shall contain the value
          uint32 PlatformSignature. This uint32 must be the first value of the post build
          configuration structure to guarantee the correct access not disturbed by any padding
          bytes.
        - the MCG shall generate this signature for the selected target. The generator shall
          use the x-path function asc:getPlatformSignature() to determine this value.
      </description>
      <comment>
        See also:
        https://infohub.automotive.elektrobit.com/display/PRJEBTRESOS/PostBuild#PostBuild-Consistencypostbuildconfig
        https://issue.ebgroup.elektrobit.com/browse/ASCBASE-1485
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_Test_IsValidConfig</srcid><srcstatus/><internalId>1232</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>972</internalId></specobject>

    <specobject>
      <id>EthIf.EB.PBCFGM107</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The PbcfgM support shall be enabled or disabled via the macro
        ETHIF_PBCFGM_SUPPORT_ENABLED defined in the file
        EthIf_Cfg.h.
        If the PbcfgM configuration references the EthIf configuration
        the macro is set to STD_ON otherwise, or if no PbcfgM configuration is
        available it is set to STD_OFF.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_Test_IsValidConfig</srcid><srcstatus/><internalId>1232</internalId></linkedfrom><linkedfrom><srcid>EthIf_Test_PBcfgM_Off</srcid><srcstatus/><internalId>1234</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>973</internalId></specobject>

    <specobject>
      <id>EthIf.EB.PBCFGM108</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If the EthIf is referenced by the PbcfgM, the parameter regarding the
        relocatable feature, shall not be editable and the MCG shall use the configuration of
        the PbcfgM.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_Test_PBcfgM_Off</srcid><srcstatus/><internalId>1234</internalId></linkedfrom><linkedfrom><srcid>EthIf_Test_PBcfgM_On</srcid><srcstatus/><internalId>1235</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/EthIf_EBParameters.xdm.m4_301</srcid><srcstatus/><internalId>1081</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>974</internalId></specobject>

    <specobject>
      <id>EthIf.EB.PBCFGM110</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The EthIf_Init() function must be extended to enable the PbcgfM
        features.
        The initialization function shall obtain the EthIf configuration
        from the PbcfgM if the PbcfgM support is enabled within this EthIf
        and the initialization function is called with a null pointer.
        The validity of the configuration shall be checked by the function
        EthIf_IsValidConfig(). The validity shall be check regardless the PbcfgM
        support is enabled or not.
        If no valid configuration can be obtained the initialization function shall
        return, leaving the EthIf uninitialized.
        In the case error reporting is enabled and no valid configuration can be obtained
        an erroneous parameter shall be indicated.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_Test_VerifyInitWithPcfgM</srcid><srcstatus/><internalId>1233</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>975</internalId></specobject>

    <specobject>
      <id>EthIf.EB.PostBuild_1</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The EthIf module shall compile and build an executable even in the absence
        of a post build configuration, i.e. without any post build generated .c and .h files
        available.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ComTest_NoPBCfg</srcid><srcstatus/><internalId>1248</internalId></linkedfrom><linkedfrom><srcid>TS_ETHIF_Gen_00000_OnlyPbCfg</srcid><srcstatus/><internalId>1813</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>976</internalId></specobject>

    <specobject>
      <id>EthIf.EB.PbcfgM_General_3</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The EthIf shall provide the following macros in the header file
        EthIf_Cfg.h:
        - ETHIF_RELOCATABLE_CFG_ENABLE which is set to STD_ON
          if relocatable config shall be enabled, otherwise it's set to STD_OFF.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_Test_PBcfgM_On</srcid><srcstatus/><internalId>1235</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>977</internalId></specobject>

    <specobject>
      <id>EthIf.EB.PbcfgM_General_6</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If PbcfgM support is enabled EthIf shall define the following macros in
        EthIf_PBCfg.c:
        - TS_PB_CFG_LAYOUT_TYPE: Shall expand to the type definition of the Postbuild
          configuration layout type (e.g. EthIf_ConstConfigLayoutType)
        - TS_PB_CFG_NAME: Shall expand to the name of the structure defining the Postbuild
          configuration layout (e.g. EthIf_ConfigLayout)
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_Test_PBcfgM_Off</srcid><srcstatus/><internalId>1234</internalId></linkedfrom><linkedfrom><srcid>EthIf_Test_PBcfgM_On</srcid><srcstatus/><internalId>1235</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>978</internalId></specobject>

  </specobjects>
    <specobjects doctype="swurs">

    <specobject>
      <id>EthIf.EB.PBSelectable.FileName</id>
       <status>approved</status>
       <source>EB</source>
       <version>1</version>
       <description>
        If postBuildVariant returns a non-empty string, the module's post-build-time
        configuration file names shall be changed in the following way:
        &lt;Mod&gt;[_*]_PBcfg.* to &lt;Mod&gt;_&lt;postBuildVariant&gt;[_*]_PBcfg.*
       </description>
       <needscoverage>
          <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06001_SetControllerMode_Switch</srcid><srcstatus/><internalId>1470</internalId></linkedfrom></coveredby></needscov>
       <containerCovstatus>covered</containerCovstatus></needscoverage>
       
    <incomingFfbLinks><incomingFfbLink><ffbSrcId>EthIf.dsn.Func.PostBuildSelectable</ffbSrcId><ffbSrcType>swurs</ffbSrcType><ffbSrcVersion>1</ffbSrcVersion><internalId>1126</internalId></incomingFfbLink></incomingFfbLinks><violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>979</internalId></specobject>

    <specobject>
       <id>EthIf.EB.PBSelectable.TypeName</id>
       <status>approved</status>
       <source>EB</source>
       <version>1</version>
       <description>
        If postBuildVariant returns a non-empty string, the module's post-build-time
        configuration type/variable names shall be changed in the following way:
        - EthIf_[Const]ConfigLayoutType to EthIf_&lt;postBuildVariant&gt;_[Const]ConfigLayoutType
       </description>
       <needscoverage>
          <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06001_SetControllerMode_Switch</srcid><srcstatus/><internalId>1470</internalId></linkedfrom></coveredby></needscov>
       <containerCovstatus>covered</containerCovstatus></needscoverage>
       
    <incomingFfbLinks><incomingFfbLink><ffbSrcId>EthIf.dsn.Func.PostBuildSelectable</ffbSrcId><ffbSrcType>swurs</ffbSrcType><ffbSrcVersion>1</ffbSrcVersion><internalId>1126</internalId></incomingFfbLink></incomingFfbLinks><violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>980</internalId></specobject>

    <specobject>
       <id>EthIf.EB.PBSelectable.Master</id>
       <status>approved</status>
       <source>EB</source>
       <version>1</version>
       <description>
        If postBuildVariant returns a non-empty string, the module shall generate a post-build-time
        configuration file EthIf_PBcfg.h/c which includes all the variants specific 
        post-build-time configurations (EthIf_&lt;postBuildVariant&gt;[_*]_PBcfg.h/c).
       </description>
       <needscoverage>
          <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06001_SetControllerMode_Switch</srcid><srcstatus/><internalId>1470</internalId></linkedfrom></coveredby></needscov>
       <containerCovstatus>covered</containerCovstatus></needscoverage>
       
    <incomingFfbLinks><incomingFfbLink><ffbSrcId>EthIf.dsn.Func.PostBuildSelectable</ffbSrcId><ffbSrcType>swurs</ffbSrcType><ffbSrcVersion>1</ffbSrcVersion><internalId>1126</internalId></incomingFfbLink></incomingFfbLinks><violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>981</internalId></specobject>

  </specobjects>
    <specobjects doctype="swurs">

    <specobject>
      <id>EthIf.EB.Interface.Consistency</id>
       <status>approved</status>
       <source>EB</source>
       <version>1</version>
       <description>
        The module shall provide a mechanism to guarantee consistency of interfaces and
        types between its implementation and its code stub.
       </description>
       <comment>
        The code stub of a module shall provide the same external view than the module itself.
        This is mandatory because unit test of modules test against the code stubs of
        adjacent modules. Inconsistent stubs may result in the situation that incompatible
        interfaces are not detected as unit test stage.
       </comment>
       <verifycrit>
        Create a compile test with two permutations that call all interfaces of a module
        (in both permutations).
        p0: Behave like a regular compile test; call the module generator and compile against
        the implementation of the module.
        p1: Do not generate module code and do not compile the implementation of the module.
        Instead the module shall be replaced with its own code stub.
       </verifycrit>
       <needscoverage>
          <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EthIf_VerifyCodeStub</srcid><srcstatus/><internalId>1236</internalId></linkedfrom></coveredby></needscov>
       <containerCovstatus>covered</containerCovstatus></needscoverage>
       
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>982</internalId></specobject>

  </specobjects>
    <specobjects doctype="dev">
    <specobject>
      <id>dev.EthIf.InterruptMode</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>25</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>391</internalId></provcov>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00006</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>392</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00099</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>458</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00100</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>459</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>983</internalId></specobject>
    <specobject>
      <id>dev.EthIf.TrcvLinkStateChgPolling</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>47</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00009</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>395</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00101</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>460</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>984</internalId></specobject>
    <specobject>
      <id>dev.EthIf.GetVersionApiMacro</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>66</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>394</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>985</internalId></specobject>
    <specobject>
      <id>dev.EthIf.PostbuildSupport</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>83</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>410</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>986</internalId></specobject>
    <specobject>
      <id>dev.EthIf.ConsChck</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>116</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00007</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>412</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>987</internalId></specobject>
    <specobject>
      <id>dev.EthIf.EthIfMaxTxBufsTotal</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>138</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>388</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00079</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>446</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00094</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>456</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>988</internalId></specobject>
    <specobject>
      <id>dev.EthIf.OptAPIs</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>164</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00033</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>487</internalId></provcov>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00034</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>488</internalId></provcov>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00035</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>489</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>989</internalId></specobject>
    <specobject>
      <id>dev.EthIf.ConfigClassGenUL</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>227</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00012</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>398</internalId></provcov>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00013</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>399</internalId></provcov>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00015</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>401</internalId></provcov>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00017</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>403</internalId></provcov>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00019</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>405</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>990</internalId></specobject>
    <specobject>
      <id>dev.EthIf.NotSupported.WirelessEthernet</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>261</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00340</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>677</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>725</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00341</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>678</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00342</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>679</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00343</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>680</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00344</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>681</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00345</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>682</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00346</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>683</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00347</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>684</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00348</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>685</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00349</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>686</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00350</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>687</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00351</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>688</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00352</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>689</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91017</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>736</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00353</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>690</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00354</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>691</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00355</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>692</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00356</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>693</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00357</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>694</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00358</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>695</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00359</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>696</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91026</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>739</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00360</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>697</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00361</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>698</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00362</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>699</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00363</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>700</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00364</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>701</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00365</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>702</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91034</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>740</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00366</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>703</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00367</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>704</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00368</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>705</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00369</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>706</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00370</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>707</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00371</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>708</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00372</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>709</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91042</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>741</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00373</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>710</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00374</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>711</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00375</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>712</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00376</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>713</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00377</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>714</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00378</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>715</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00379</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>716</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91050</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>742</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00380</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>717</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00381</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>718</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00382</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>719</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00383</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>720</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00384</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>721</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00385</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>722</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00386</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>723</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91054</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>773</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>991</internalId></specobject>
    <specobject>
      <id>dev.EthIf.EthIf_CheckWakeup</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>312</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00245</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>570</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>992</internalId></specobject>
    <specobject>
      <id>dev.EthIf.NotSupported.GetPortMacAddr</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>327</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00191</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>535</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>993</internalId></specobject>
    <specobject>
      <id>dev.EthIf.NotSupported.GetCtrlIdxList</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>341</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91053</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>745</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00298</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>642</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00300</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>644</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>994</internalId></specobject>
    <specobject>
      <id>dev.EthIf.NotSupported.SwitchMgmtInfo</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>361</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>726</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00279</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>631</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00280</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>632</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00281</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>633</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00282</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>634</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00283</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>635</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>995</internalId></specobject>
    <specobject>
      <id>dev.EthIf.NotSupported.SwitchEnableTimeStamping</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>378</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91007</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>729</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00387</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>724</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00285</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>636</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00286</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>637</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00287</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>638</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00288</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>639</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00289</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>640</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00290</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>641</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>996</internalId></specobject>
    <specobject>
      <id>dev.EthIf.NotSupported.VerifyConfig</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>395</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91012</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>732</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00305</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>649</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>997</internalId></specobject>
    <specobject>
      <id>dev.EthIf.NotSupported.SetForwardingMode</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>409</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91013</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>733</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00307</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>651</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>998</internalId></specobject>
    <specobject>
      <id>dev.EthIf.NotSupported.TxConfirmation_Result</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>425</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00255</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>608</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00106</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>465</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>999</internalId></specobject>
    <specobject>
      <id>dev.EthIf.BswMPortGroupDown.LinksStateDown</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>452</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00261</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>614</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1000</internalId></specobject>
    <specobject>
      <id>dev.EthIf.PostBuildSelectable</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>480</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00037</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>510</internalId></provcov>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00058</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>590</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1001</internalId></specobject>
    <specobject>
      <id>dev.EthIf.PostBuild.EthIfCtrlIdx</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>505</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00026</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>481</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1002</internalId></specobject>
    <specobject>
      <id>dev.EthIf.DevelopmentErrors</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>527</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00306</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>650</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00328</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>665</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00235</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>560</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00036</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>425</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00135</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>495</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00277</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>630</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00299</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>643</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00155</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>516</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00199</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>542</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00331</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>668</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00375</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>712</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00217</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>547</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00335</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>672</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00193</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>537</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00092</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>454</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00077</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>444</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00273</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>626</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00173</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>530</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00246</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>571</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00069</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>438</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00167</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>525</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00222</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>551</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00304</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>648</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00325</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>662</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00302</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>646</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00161</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>521</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00086</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>450</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00141</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>500</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00240</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>565</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00041</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>429</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00063</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>434</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00389</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>753</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00017</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>419</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1003</internalId></specobject>
    <specobject>
      <id>dev.EthIf.LinkStateRequest</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>574</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00265</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>618</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00276</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>629</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00271</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>624</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00275</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>628</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00272</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>625</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00479</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>956</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00480</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>957</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00481</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>958</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00482</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>959</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1004</internalId></specobject>
    <specobject>
      <id>dev.EthIf.PointerMacroChanged</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>595</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00337</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>674</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00339</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>676</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00242</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>567</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00338</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>675</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1005</internalId></specobject>
    <specobject>
      <id>dev.EthIf.GetPhyWakeupReason</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>610</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00488</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>859</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00487</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>858</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00486</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>857</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00489</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>860</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>727</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1006</internalId></specobject>
    <specobject>
      <id>dev.EthIf.NewConfigParam</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>626</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00077</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>751</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1007</internalId></specobject>
    <specobject>
      <id>dev.EthIf.MainFunctionState</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>638</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00410</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>772</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00498</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>868</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00408</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>770</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00407</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>769</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00409</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>771</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1008</internalId></specobject>
    <specobject>
      <id>dev.EthIf.SwitchPortModeIndication</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>654</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91055</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>774</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1009</internalId></specobject>
    <specobject>
      <id>dev.EthIf.Obsolete</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>666</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00413</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>782</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00411</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>780</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00412</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>781</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1010</internalId></specobject>
    <specobject>
      <id>dev.EthIf.GetRxMgmtObject</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>680</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91105</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>783</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1011</internalId></specobject>
    <specobject>
      <id>dev.EthIf.GetTxMgmtObject</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>692</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91106</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>784</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1012</internalId></specobject>
    <specobject>
      <id>dev.EthIf.GetSwitchPortMode</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>704</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00415</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>785</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91124</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>832</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91107</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>815</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1013</internalId></specobject>
    <specobject>
      <id>dev.EthIf.GetTransceiverMode</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>718</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91108</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>816</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00417</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>786</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1014</internalId></specobject>
    <specobject>
      <id>dev.EthIf.SwitchPortGetLinkState</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>731</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91109</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>817</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00419</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>787</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1015</internalId></specobject>
    <specobject>
      <id>dev.EthIf.TransceiverGetLinkState</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>744</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00421</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>788</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91110</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>818</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1016</internalId></specobject>
    <specobject>
      <id>dev.EthIf.SwitchPortGetBaudRate</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>757</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00423</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>789</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91111</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>819</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1017</internalId></specobject>
    <specobject>
      <id>dev.EthIf.TransceiverGetBaudRate</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>770</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00426</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>790</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91112</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>820</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1018</internalId></specobject>
    <specobject>
      <id>dev.EthIf.SwitchPortGetDuplexMode</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>783</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91113</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>821</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00428</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>791</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1019</internalId></specobject>
    <specobject>
      <id>dev.EthIf.TransceiverGetDuplexMode</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>796</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00430</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>792</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91114</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>822</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1020</internalId></specobject>
    <specobject>
      <id>dev.EthIf.SwitchPortGetCounterValues</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>809</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00432</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>793</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91115</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>823</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1021</internalId></specobject>
    <specobject>
      <id>dev.EthIf.SwitchPortGetRxStats</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>822</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00434</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>794</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91116</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>824</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1022</internalId></specobject>
    <specobject>
      <id>dev.EthIf.SwitchPortGetTxStats</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>835</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00436</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>795</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91117</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>825</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1023</internalId></specobject>
    <specobject>
      <id>dev.EthIf.SwitchPortGetTxErrorCounterValues</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>848</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00438</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>796</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>826</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1024</internalId></specobject>
    <specobject>
      <id>dev.EthIf.SwitchPortGetMacLearningMode</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>861</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91119</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>827</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00440</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>797</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1025</internalId></specobject>
    <specobject>
      <id>dev.EthIf.GetSwitchPortIdentifier</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>874</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00442</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>798</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91120</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>828</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1026</internalId></specobject>
    <specobject>
      <id>dev.EthIf.GetSwitchIdentifier</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>887</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00444</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>799</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91121</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>829</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1027</internalId></specobject>
    <specobject>
      <id>dev.EthIf.WritePortMirrorConfiguration</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>900</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00446</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>800</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91122</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>830</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1028</internalId></specobject>
    <specobject>
      <id>dev.EthIf.ReadPortMirrrorConfiguration</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>913</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00448</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>801</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91124</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>832</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00450</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>802</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1029</internalId></specobject>
    <specobject>
      <id>dev.EthIf.DeletePortMirrorConfiguration</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>927</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00448</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>801</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91124</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>832</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00450</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>802</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1030</internalId></specobject>
    <specobject>
      <id>dev.EthIf.GetPortMirrorState</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>941</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00452</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>803</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91125</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>833</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>826</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1031</internalId></specobject>
    <specobject>
      <id>dev.EthIf.SetPortMirrorState</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>955</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00454</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>804</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91126</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>834</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1032</internalId></specobject>
    <specobject>
      <id>dev.EthIf.SetPortTestMode</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>968</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00456</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>805</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91127</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>835</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1033</internalId></specobject>
    <specobject>
      <id>dev.EthIf.SetPortLoopbackMode</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>981</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00458</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>806</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91128</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>836</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1034</internalId></specobject>
    <specobject>
      <id>dev.EthIf.SetPortTxMode</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>994</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91129</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>837</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00460</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>807</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1035</internalId></specobject>
    <specobject>
      <id>dev.EthIf.GetPortCableDiagnosticResult</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>1007</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91130</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>838</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00462</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>808</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1036</internalId></specobject>
    <specobject>
      <id>dev.EthIf.RunPortCableDiagnostic</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>1020</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00464</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>809</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91131</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>839</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1037</internalId></specobject>
    <specobject>
      <id>dev.EthIf.RunCableDiagnostic</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>1033</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00466</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>810</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91132</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>840</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1038</internalId></specobject>
    <specobject>
      <id>dev.EthIf.SwitchGetCfgDataRaw</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>1046</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00468</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>811</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91133</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>841</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1039</internalId></specobject>
    <specobject>
      <id>dev.EthIf.SwitchGetCfgDataInfo</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>1059</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91134</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>842</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00470</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>812</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1040</internalId></specobject>
    <specobject>
      <id>dev.EthIf.SwitchPortGetMaxFIFOBufferFillLevel</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>1072</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91119</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>827</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91110</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>818</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91113</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>821</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91135</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>843</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00472</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>813</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1041</internalId></specobject>
    <specobject>
      <id>dev.EthIf.GetCurrentTimeChange</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>1088</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00473</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>814</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1042</internalId></specobject>
    <specobject>
      <id>dev.EthIf.ReadPortMirrorConfiguration</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>1100</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91123</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>831</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1043</internalId></specobject>
    <specobject>
      <id>dev.EthIf.TransceiverGetMacMethod</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>1112</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00477</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>853</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00476</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>852</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00475</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>851</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00474</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>850</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91021</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>872</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91128</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>836</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1044</internalId></specobject>
    <specobject>
      <id>dev.EthIf.CheckWakeup</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>1129</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91130</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>838</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00500</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>869</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1045</internalId></specobject>
    <specobject>
      <id>dev.EthIf.EthernetMACCollisionDrop</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>1143</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00084</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>849</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1046</internalId></specobject>
    <specobject>
      <id>dev.EthIf.SetControllerModeUpdate</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>1155</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00485</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>856</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00478</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>854</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00484</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>855</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1047</internalId></specobject>
    <specobject>
      <id>dev.EthIf.GetSwitchPortWakeupReason</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>1169</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00491</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>862</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00490</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>861</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00494</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>865</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00493</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>864</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00492</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>863</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00496</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>867</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1048</internalId></specobject>
    <specobject>
      <id>dev.EthIf.GetSwitchPortSignalQuality</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>1186</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00495</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>866</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1049</internalId></specobject>
    <specobject>
      <id>dev.EthIf.SwMacSec.NotSupported</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>1214</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_00560</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>873</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_00562</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>875</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_00563</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>876</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_00564</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>877</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_00565</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>878</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_00566</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>879</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_00567</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>880</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_00568</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>881</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_00569</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>882</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_00570</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>883</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_00571</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>884</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_00572</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>885</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_00573</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>886</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_00574</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>887</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_00575</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>888</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_00576</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>889</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_00577</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>890</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_00578</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>891</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_00579</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>892</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_00580</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>893</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1050</internalId></specobject>
    <specobject>
      <id>dev.EthIf.MacSec.ConfigParamChanged</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>1260</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR_R22-11.ECUC_EthIf_00089</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>935</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR_R22-11.ECUC_EthIf_00090</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>937</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1051</internalId></specobject>
    <specobject>
      <id>dev.EthIf.NotSupported.SwitchMacSec</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>1279</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_91217</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>903</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_91220</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>905</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_91221</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>907</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_91222</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>909</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_91223</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>911</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_91225</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>913</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_91226</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>915</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_91227</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>917</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_91228</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>919</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_91230</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>921</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_91231</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>923</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_91232</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>925</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_91233</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>927</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_91234</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>929</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_91236</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>931</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_91237</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>933</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1052</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/include/EthIf.h_58</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/include/EthIf.h</sourcefile>
      <sourceline>58</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00006</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>411</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1053</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/EthIf.h_60</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/include/EthIf.h</sourcefile>
      <sourceline>60</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00152</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>48</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1054</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/include/EthIf_Types.h_23</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/include/EthIf_Types.h</sourcefile>
      <sourceline>23</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00152</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>48</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1055</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/EthIf_Types.h_24</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/include/EthIf_Types.h</sourcefile>
      <sourceline>24</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00153</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>49</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1056</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/EthIf_Types.h_25</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/include/EthIf_Types.h</sourcefile>
      <sourceline>25</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91010</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>730</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1057</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/EthIf_Types.h_26</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/include/EthIf_Types.h</sourcefile>
      <sourceline>26</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91101</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>746</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1058</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/EthIf_Types.h_27</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/include/EthIf_Types.h</sourcefile>
      <sourceline>27</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91057</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>776</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1059</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/include/EthIf_Version.h.m4_2</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/include/EthIf_Version.h.m4</sourcefile>
      <sourceline>2</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00006</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>411</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1060</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/src/EthIf.c.m4_2543</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/src/EthIf.c.m4</sourcefile>
      <sourceline>2543</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00091</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>453</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1061</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/EthIf.c.m4_2587</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/src/EthIf.c.m4</sourcefile>
      <sourceline>2587</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR42.SWS_EthIf_00091</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>15</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1062</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/EthIf.c.m4_4076</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/src/EthIf.c.m4</sourcefile>
      <sourceline>4076</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91052</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>744</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1063</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/EthIf.c.m4_5068</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/src/EthIf.c.m4</sourcefile>
      <sourceline>5068</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00581.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>896</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1064</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/EthIf.c.m4_6269</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/src/EthIf.c.m4</sourcefile>
      <sourceline>6269</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_00584</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>901</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1065</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/EthIf.c.m4_7281</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/src/EthIf.c.m4</sourcefile>
      <sourceline>7281</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00313</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>656</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1066</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/config/EthIf.xdm.m4_121</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/config/EthIf.xdm.m4</sourcefile>
      <sourceline>121</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.ECUC_EthIf_00029_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>94</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1067</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/EthIf.xdm.m4_184</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/config/EthIf.xdm.m4</sourcefile>
      <sourceline>184</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.PostBuildSelectable.EthIfSwitchRefOrPortGroupRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1148</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1068</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/EthIf.xdm.m4_196</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/config/EthIf.xdm.m4</sourcefile>
      <sourceline>196</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.ECUC_EthIf_00090</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>938</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1069</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/EthIf.xdm.m4_425</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/config/EthIf.xdm.m4</sourcefile>
      <sourceline>425</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.PostBuildSelectable.EthIfSwitchIdx</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1149</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1070</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/EthIf.xdm.m4_446</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/config/EthIf.xdm.m4</sourcefile>
      <sourceline>446</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.PostBuildSelectable.EthIfSwitchRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1150</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1071</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/EthIf.xdm.m4_498</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/config/EthIf.xdm.m4</sourcefile>
      <sourceline>498</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.PostBuildSelectable.EthIfSwitchPortGroupIdx</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1151</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1072</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/EthIf.xdm.m4_516</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/config/EthIf.xdm.m4</sourcefile>
      <sourceline>516</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.PostBuildSelectable.EthIfSwitchPortGroupRefSemantics</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1152</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1073</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/EthIf.xdm.m4_537</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/config/EthIf.xdm.m4</sourcefile>
      <sourceline>537</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.PostBuildSelectable.EthIfPortRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1153</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1074</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/EthIf.xdm.m4_1128</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/config/EthIf.xdm.m4</sourcefile>
      <sourceline>1128</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.ECUC_EthIf_00089</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>936</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1075</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/EthIf.xdm.m4_1157</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/config/EthIf.xdm.m4</sourcefile>
      <sourceline>1157</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00080</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>845</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1076</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/EthIf.xdm.m4_1172</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/config/EthIf.xdm.m4</sourcefile>
      <sourceline>1172</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>dsn.Func020.EB.PostBuildSelectable.EthIfSecurityEventRefs</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1156</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1077</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/EthIf.xdm.m4_1192</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/config/EthIf.xdm.m4</sourcefile>
      <sourceline>1192</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>dsn.Func020.EB.PostBuildSelectable.EthIfSecurityEventRefs</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1156</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1078</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/EthIf.xdm.m4_1212</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/config/EthIf.xdm.m4</sourcefile>
      <sourceline>1212</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>dsn.Func020.EB.PostBuildSelectable.EthIfSecurityEventRefs</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1156</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1079</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/config/EthIf_EBParameters.xdm.m4_278</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/config/EthIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>278</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.RelocatablePBCfg</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>283</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1080</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/EthIf_EBParameters.xdm.m4_301</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/config/EthIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>301</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.PBCFGM108</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>974</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1081</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/EthIf_EBParameters.xdm.m4_864</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/config/EthIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>864</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.DriverVendorInfo.EthIfEthControllerType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1134</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1082</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/EthIf_EBParameters.xdm.m4_870</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/config/EthIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>870</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.DriverVendorInfo.EthIfEthControllerBswmdImplementationRefs</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1135</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1083</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/EthIf_EBParameters.xdm.m4_887</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/config/EthIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>887</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfEthControllerBswmdImplementationRefs.Valid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1212</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1084</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/EthIf_EBParameters.xdm.m4_900</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/config/EthIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>900</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.DriverVendorInfo.EthIfEthCtrlTypeRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1136</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1085</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/EthIf_EBParameters.xdm.m4_925</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/config/EthIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>925</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.DriverVendorInfo.EthIfEthTrcvType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1137</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1086</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/EthIf_EBParameters.xdm.m4_931</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/config/EthIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>931</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.DriverVendorInfo.EthIfEthTrcvBswmdImplementationRefs</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1138</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1087</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/EthIf_EBParameters.xdm.m4_948</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/config/EthIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>948</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfEthTrcvBswmdImplementationRefs.Valid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1216</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1088</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/EthIf_EBParameters.xdm.m4_961</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/config/EthIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>961</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.DriverVendorInfo.EthIfEthTrcvTypeRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1139</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1089</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/EthIf_EBParameters.xdm.m4_984</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/config/EthIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>984</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.DriverVendorInfo.EthIfEthSwtType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1140</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1090</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/EthIf_EBParameters.xdm.m4_992</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/config/EthIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>992</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.DriverVendorInfo.EthIfEthSwtBswmdImplementationRefs</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1142</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1091</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/EthIf_EBParameters.xdm.m4_1008</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/config/EthIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>1008</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfEthSwtBswmdImplementationRefs.Valid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1220</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1092</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/EthIf_EBParameters.xdm.m4_1016</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/config/EthIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>1016</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.DriverVendorInfo.EthIfEthSwtTypeRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1141</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1093</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/config/EthIf_Extension.xdm.m4_42</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/config/EthIf_Extension.xdm.m4</sourcefile>
      <sourceline>42</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00026</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>481</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1094</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/EthIf_Extension.xdm.m4_209</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/config/EthIf_Extension.xdm.m4</sourcefile>
      <sourceline>209</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.ECUC_EthIf_00090</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>938</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1095</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/EthIf_Extension.xdm.m4_330</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/config/EthIf_Extension.xdm.m4</sourcefile>
      <sourceline>330</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00046</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>580</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1096</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/EthIf_Extension.xdm.m4_346</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/config/EthIf_Extension.xdm.m4</sourcefile>
      <sourceline>346</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00047</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>581</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1097</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/EthIf_Extension.xdm.m4_367</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/config/EthIf_Extension.xdm.m4</sourcefile>
      <sourceline>367</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfSupportEthAPI.EthCompatible</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1203</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1098</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/EthIf_Extension.xdm.m4_411</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/config/EthIf_Extension.xdm.m4</sourcefile>
      <sourceline>411</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00052</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>584</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1099</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/EthIf_Extension.xdm.m4_426</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/config/EthIf_Extension.xdm.m4</sourcefile>
      <sourceline>426</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00051</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>583</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1100</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/EthIf_Extension.xdm.m4_444</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/config/EthIf_Extension.xdm.m4</sourcefile>
      <sourceline>444</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00053</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>585</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1101</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/EthIf_Extension.xdm.m4_728</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/config/EthIf_Extension.xdm.m4</sourcefile>
      <sourceline>728</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00078</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>955</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1102</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/EthIf_Extension.xdm.m4_763</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/config/EthIf_Extension.xdm.m4</sourcefile>
      <sourceline>763</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00043</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>577</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1103</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/EthIf_Extension.xdm.m4_779</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/config/EthIf_Extension.xdm.m4</sourcefile>
      <sourceline>779</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00044</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>578</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1104</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/EthIf_Extension.xdm.m4_1081</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/config/EthIf_Extension.xdm.m4</sourcefile>
      <sourceline>1081</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00056</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>588</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1105</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/EthIf_Extension.xdm.m4_1363</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/config/EthIf_Extension.xdm.m4</sourcefile>
      <sourceline>1363</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>dsn.Func020.EB.PostBuildSelectable.EthIfSecurityEventRefs</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1156</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1106</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/EthIf_Extension.xdm.m4_1383</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/config/EthIf_Extension.xdm.m4</sourcefile>
      <sourceline>1383</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>dsn.Func020.EB.PostBuildSelectable.EthIfSecurityEventRefs</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1156</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1107</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/EthIf_Extension.xdm.m4_1403</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/config/EthIf_Extension.xdm.m4</sourcefile>
      <sourceline>1403</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>dsn.Func020.EB.PostBuildSelectable.EthIfSecurityEventRefs</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1156</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1108</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/generate_macros/EthIf_PreCompileConfig.m_21</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/generate_macros/EthIf_PreCompileConfig.m</sourcefile>
      <sourceline>21</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00149</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>506</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1109</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/generate_swcd/swcd/EthIf_Bswmd.arxml.m4_124</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/generate_swcd/swcd/EthIf_Bswmd.arxml.m4</sourcefile>
      <sourceline>124</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00023</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>406</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1110</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate_swcd/swcd/EthIf_Bswmd.arxml.m4_136</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/generate_swcd/swcd/EthIf_Bswmd.arxml.m4</sourcefile>
      <sourceline>136</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00023</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>406</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1111</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate_swcd/swcd/EthIf_Bswmd.arxml.m4_314</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/generate_swcd/swcd/EthIf_Bswmd.arxml.m4</sourcefile>
      <sourceline>314</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00012</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>416</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1112</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/generate_var/xgen/EthIf.xgen_67</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/src/Autosar/generate_var/xgen/EthIf.xgen</sourcefile>
      <sourceline>67</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.EthIf_00005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>136</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1113</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="VLAN support">
    <specobject>
      <id>EthIf.dsn.Func.VLAN</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>1093</sourceline>
      <version>1</version>
      <description>
          Ethernet Interface shall support Virtual Local Area Networks (VLAN).
        </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.EB.Transmit_EthSwtVLAN</srcid><srcstatus/><internalId>279</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00128</srcid><srcstatus/><internalId>490</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00129</srcid><srcstatus/><internalId>491</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00130</srcid><srcstatus/><internalId>492</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1114</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="Wake up support">
    <specobject>
      <id>EthIf.dsn.Func.WakeUp</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>1108</sourceline>
      <version>1</version>
      <description>
          Ethernet Interface supports wake up depending on the parameter EthIfWakeUpSupport.
        </description>
      <furtherinfo>
          WRN.swurs.needscoverage.count - Linking all relevant requirements to the single top-level
          requirement brings clear benefits and splitting them up would only increase complexity
          without any real benefit.
        </furtherinfo>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00235</srcid><srcstatus/><internalId>69</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00240</srcid><srcstatus/><internalId>70</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00242</srcid><srcstatus/><internalId>71</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00246</srcid><srcstatus/><internalId>72</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00249</srcid><srcstatus/><internalId>73</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00233.ServiceId</srcid><srcstatus/><internalId>97</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00238.ServiceId</srcid><srcstatus/><internalId>98</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00244.ServiceId</srcid><srcstatus/><internalId>99</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00233</srcid><srcstatus/><internalId>558</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00234</srcid><srcstatus/><internalId>559</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00236</srcid><srcstatus/><internalId>561</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00237</srcid><srcstatus/><internalId>562</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00238</srcid><srcstatus/><internalId>563</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00239</srcid><srcstatus/><internalId>564</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00241</srcid><srcstatus/><internalId>566</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00243</srcid><srcstatus/><internalId>568</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00244</srcid><srcstatus/><internalId>569</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00248</srcid><srcstatus/><internalId>573</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00268</srcid><srcstatus/><internalId>621</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00269</srcid><srcstatus/><internalId>622</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1115</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="Global Time support">
    <specobject>
      <id>EthIf.dsn.Func.GlobalTime</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>1128</sourceline>
      <version>1</version>
      <description>
          Ethernet Interface supports time measurement with Switches.
        </description>
      <furtherinfo>
          WRN.swurs.needscoverage.count - Linking all relevant requirements to the single top-level
          requirement brings clear benefits and splitting them up would only increase complexity
          without any real benefit.
        </furtherinfo>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00155</srcid><srcstatus/><internalId>50</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00159</srcid><srcstatus/><internalId>51</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00161</srcid><srcstatus/><internalId>52</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00165</srcid><srcstatus/><internalId>53</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00167</srcid><srcstatus/><internalId>54</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00171</srcid><srcstatus/><internalId>55</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00173</srcid><srcstatus/><internalId>56</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00177</srcid><srcstatus/><internalId>57</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00154.ServiceId</srcid><srcstatus/><internalId>108</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00154.GetCurrentTime.ForwardCall</srcid><srcstatus/><internalId>109</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00160.ServiceId</srcid><srcstatus/><internalId>110</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00160.EnableEgressTimeStamp.ForwardCall</srcid><srcstatus/><internalId>111</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00166.ServiceId</srcid><srcstatus/><internalId>112</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00166.GetEgressTimeStamp.ForwardCall</srcid><srcstatus/><internalId>113</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00172.ServiceId</srcid><srcstatus/><internalId>114</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR43.SWS_EthIf_00172.GetIngressTimeStamp.ForwardCall</srcid><srcstatus/><internalId>115</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00154</srcid><srcstatus/><internalId>515</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00156</srcid><srcstatus/><internalId>517</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00157</srcid><srcstatus/><internalId>518</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00158</srcid><srcstatus/><internalId>519</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00160</srcid><srcstatus/><internalId>520</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00162</srcid><srcstatus/><internalId>522</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00164</srcid><srcstatus/><internalId>523</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00166</srcid><srcstatus/><internalId>524</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00168</srcid><srcstatus/><internalId>526</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00169</srcid><srcstatus/><internalId>527</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00170</srcid><srcstatus/><internalId>528</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00172</srcid><srcstatus/><internalId>529</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00174</srcid><srcstatus/><internalId>531</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00175</srcid><srcstatus/><internalId>532</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00176</srcid><srcstatus/><internalId>533</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.RxIndication.EthSwt_EthIfPreProcessRxFrame.OK</srcid><srcstatus/><internalId>1130</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.RxIndication.EthSwt_EthIfPreProcessRxFrame.NOK</srcid><srcstatus/><internalId>1131</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1116</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="Switching of EthIfSwitchPortGroup">
    <specobject>
      <id>EthIf.dsn.Func.SwitchPortGroup</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>1148</sourceline>
      <version>1</version>
      <description>
          Ethernet Interface supports switching of EthIfSwitchPortGroup.
        </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.SWS_EthIf_00256</srcid><srcstatus/><internalId>609</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00257</srcid><srcstatus/><internalId>610</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00258</srcid><srcstatus/><internalId>611</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_91101</srcid><srcstatus/><internalId>746</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.SetControllerModeDown.EthSM_CtrlModeIndication</srcid><srcstatus/><internalId>1132</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1117</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="Link state accumulation of EthIfSwitchPortGroup">
    <specobject>
      <id>EthIf.dsn.Func.LinkStateAccSwitchPortGroup</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>1163</sourceline>
      <version>1</version>
      <description>
          Ethernet Interface uses the accumulated link state of the EthIfSwitchPortGroup as
          the actual state of the EthIfSwitchPortGroup.
        </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.SWS_EthIf_00259</srcid><srcstatus/><internalId>612</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00260</srcid><srcstatus/><internalId>613</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00262</srcid><srcstatus/><internalId>615</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.SWS_EthIf_00261</srcid><srcstatus/><internalId>1129</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1118</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="Link quality monitoring">
    <specobject>
      <id>EthIf.dsn.Func.LinkQuality</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>1179</sourceline>
      <version>1</version>
      <description>
          Ethernet Interface supports monitoring of Link quality.
        </description>
      <furtherinfo>
          WRN.swurs.needscoverage.count - Linking all relevant requirements to the single top-level
          requirement brings clear benefits and splitting them up would only increase complexity
          without any real benefit.
        </furtherinfo>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.EB.GetTrcvSignalQuality.Configurable</srcid><srcstatus/><internalId>271</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.GetSwitchPortSignalQuality.Configurable</srcid><srcstatus/><internalId>272</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.ClearTrcvSignalQuality.Configurable</srcid><srcstatus/><internalId>273</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.ClearSwitchPortSignalQuality.Configurable</srcid><srcstatus/><internalId>274</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.GetTrcvSignalQuality_00320</srcid><srcstatus/><internalId>275</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00392</srcid><srcstatus/><internalId>756</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00393</srcid><srcstatus/><internalId>757</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00394</srcid><srcstatus/><internalId>758</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00395</srcid><srcstatus/><internalId>759</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00396</srcid><srcstatus/><internalId>760</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00397</srcid><srcstatus/><internalId>761</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00399</srcid><srcstatus/><internalId>762</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00401</srcid><srcstatus/><internalId>764</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00402</srcid><srcstatus/><internalId>765</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00405</srcid><srcstatus/><internalId>767</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00406</srcid><srcstatus/><internalId>768</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_91056</srcid><srcstatus/><internalId>775</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_91058</srcid><srcstatus/><internalId>777</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_91059</srcid><srcstatus/><internalId>778</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_91060</srcid><srcstatus/><internalId>779</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1119</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="Async Handling">
    <specobject>
      <id>EthIf.dsn.Func.AsyncHandling</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>1199</sourceline>
      <version>1</version>
      <description>
          Ethernet Interface supports async handling of transceiver/controller mode API.
        </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.EB.AsyncEthTrcvMode_Extension.ApiSupport_Conf</srcid><srcstatus/><internalId>281</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.AsyncEthCtrlMode_Extension.ApiSupport_Conf</srcid><srcstatus/><internalId>282</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfAsyncEthTrcvModeSupport</srcid><srcstatus/><internalId>1211</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1120</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="Measurement Data support">
    <specobject>
      <id>EthIf.dsn.Func.GetAndResetMeasurementData</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>1215</sourceline>
      <version>1</version>
      <description>
          EthIf shall support reading and reseting of measurement data for diagnostic purposes.
        </description>
      <furtherinfo>
          WRN.swurs.needscoverage.count - Linking all relevant requirements to the single top-level
          requirement brings clear benefits and splitting them up would only increase complexity
          without any real benefit.
        </furtherinfo>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.ECUC_EthIf_00072</srcid><srcstatus/><internalId>603</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00308</srcid><srcstatus/><internalId>652</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00309</srcid><srcstatus/><internalId>653</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00310</srcid><srcstatus/><internalId>654</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00312</srcid><srcstatus/><internalId>655</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00313</srcid><srcstatus/><internalId>656</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00314</srcid><srcstatus/><internalId>657</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00316</srcid><srcstatus/><internalId>658</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00317</srcid><srcstatus/><internalId>659</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00319</srcid><srcstatus/><internalId>660</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_91011</srcid><srcstatus/><internalId>731</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.EthIf_GetAndResetMeasurementData.Unknown_EtherType</srcid><srcstatus/><internalId>1154</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.EthIf_GetAndResetMeasurementData.Double_VLANTag</srcid><srcstatus/><internalId>1155</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1121</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="Device Authentication Support">
    <specobject>
      <id>EthIf.dsn.Func.DeviceAuthenticationSupport</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>1235</sourceline>
      <version>1</version>
      <description>
          Ethernet interface shall support Device Authentication.
        </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.EB.DevAuthExtension.ApiSupport</srcid><srcstatus/><internalId>284</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.DevAuthExtension.EnableRelatedEthIfCtrls.ApiSignature</srcid><srcstatus/><internalId>285</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.DevAuthExtension.EnableRelatedEthIfCtrls.ServiceId</srcid><srcstatus/><internalId>286</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.DevAuthExtension.DisableRelatedEthIfCtrls.ApiSignature</srcid><srcstatus/><internalId>287</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.DevAuthExtension.DisableRelatedEthIfCtrls.ServiceId</srcid><srcstatus/><internalId>288</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1122</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="Retransmit Support">
    <specobject>
      <id>EthIf.dsn.Func.RetransmitSupport</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>1250</sourceline>
      <version>1</version>
      <description>
          Ethernet interface shall support Retransmit functionality.
        </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.EB.RetransmitExtension.ApiSupport</srcid><srcstatus/><internalId>297</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.RetransmitExtension.Retransmit.ApiSignature</srcid><srcstatus/><internalId>298</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.RetransmitExtension.Retransmit.ServiceId</srcid><srcstatus/><internalId>299</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.RetransmitExtension.Retransmit.Behaviour</srcid><srcstatus/><internalId>300</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.RetransmitExtension.Retransmit.InvCtrlIndexes</srcid><srcstatus/><internalId>301</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.RetransmitExtension.Retransmit.DetCheck.NotInit</srcid><srcstatus/><internalId>302</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.RetransmitExtension.Retransmit.DetCheck.InvCtrlIdx</srcid><srcstatus/><internalId>303</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.RetransmitExtension.Retransmit.DetCheck.InvBufIdxPtr</srcid><srcstatus/><internalId>304</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.RetransmitExtension.Retransmit.DetCheck.InvRetransmitInfoPtr</srcid><srcstatus/><internalId>305</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.RetransmitExtension.Retransmit.DetCheck.InvDataPtr</srcid><srcstatus/><internalId>306</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1123</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="Support of drivers that contain vendorId and vendorApiInfix">
    <specobject>
      <id>EthIf.dsn.Func.DriverVendorInfoSupport</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>1265</sourceline>
      <version>1</version>
      <description>
          Ethernet interface shall support drivers that contain vendorId and vendorApiInfix
          according to following naming convention:
          &amp;lt;Eth driver Abbreviation&amp;gt;_&amp;lt;vendorID&amp;gt;_&amp;lt;Vendor specificname&amp;gt;_&amp;lt;
          API Service name&amp;gt;
        </description>
      <furtherinfo>
          WRN.swurs.needscoverage.count - Linking all relevant requirements to the single top-level
          requirement brings clear benefits and splitting them up would only increase complexity
          without any real benefit.
        </furtherinfo>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.EB.DriverVendorInfo.EthIfEthControllerType</srcid><srcstatus/><internalId>1134</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.DriverVendorInfo.EthIfEthControllerBswmdImplementationRefs</srcid><srcstatus/><internalId>1135</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.DriverVendorInfo.EthIfEthCtrlTypeRef</srcid><srcstatus/><internalId>1136</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.DriverVendorInfo.EthIfEthTrcvType</srcid><srcstatus/><internalId>1137</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.DriverVendorInfo.EthIfEthTrcvBswmdImplementationRefs</srcid><srcstatus/><internalId>1138</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.DriverVendorInfo.EthIfEthTrcvTypeRef</srcid><srcstatus/><internalId>1139</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.DriverVendorInfo.EthIfEthSwtType</srcid><srcstatus/><internalId>1140</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.DriverVendorInfo.EthIfEthSwtTypeRef</srcid><srcstatus/><internalId>1141</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.DriverVendorInfo.EthIfEthSwtBswmdImplementationRefs</srcid><srcstatus/><internalId>1142</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.DriverVendorInfo.EthController_FuncNameMangling</srcid><srcstatus/><internalId>1143</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.DriverVendorInfo.EthTrcv_FuncNameMangling</srcid><srcstatus/><internalId>1144</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.DriverVendorInfo.EthSwt_FuncNameMangling</srcid><srcstatus/><internalId>1145</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1124</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="Support of multiple Ethernet Controller and Ethernet Transceiver modules">
    <specobject>
      <id>EthIf.dsn.Func.MultipleEthCtrlTrcvSupport</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>1288</sourceline>
      <version>1</version>
      <description>
          Ethernet interface shall support multiple Ethernet Controller and Ethernet Transceiver
          modules.
        </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.EB.DriverVendorInfo.EthIfEthControllerType</srcid><srcstatus/><internalId>1134</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.DriverVendorInfo.EthIfEthControllerBswmdImplementationRefs</srcid><srcstatus/><internalId>1135</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.DriverVendorInfo.EthIfEthCtrlTypeRef</srcid><srcstatus/><internalId>1136</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.DriverVendorInfo.EthIfEthTrcvType</srcid><srcstatus/><internalId>1137</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.DriverVendorInfo.EthIfEthTrcvBswmdImplementationRefs</srcid><srcstatus/><internalId>1138</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.DriverVendorInfo.EthIfEthTrcvTypeRef</srcid><srcstatus/><internalId>1139</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.DriverVendorInfo.EthIfEthSwtType</srcid><srcstatus/><internalId>1140</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.DriverVendorInfo.EthIfEthSwtTypeRef</srcid><srcstatus/><internalId>1141</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.MultipleEthCtrlTrcv.MultipleEthControllers</srcid><srcstatus/><internalId>1146</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.MultipleEthCtrlTrcv.MultipleEthTransceivers</srcid><srcstatus/><internalId>1147</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1125</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="Post-build selectable variant handling">
    <specobject>
      <id>EthIf.dsn.Func.PostBuildSelectable</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>1304</sourceline>
      <version>1</version>
      <description>
          EthIf shall support post-build configuration of multiple variants.
        </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.dsn.Func.PostBuildSelectable.EthIfSwitchRefOrPortGroupRef</srcid><srcstatus/><internalId>1148</internalId></linkedfrom><linkedfrom><srcid>EthIf.dsn.Func.PostBuildSelectable.EthIfSwitchIdx</srcid><srcstatus/><internalId>1149</internalId></linkedfrom><linkedfrom><srcid>EthIf.dsn.Func.PostBuildSelectable.EthIfSwitchRef</srcid><srcstatus/><internalId>1150</internalId></linkedfrom><linkedfrom><srcid>EthIf.dsn.Func.PostBuildSelectable.EthIfSwitchPortGroupIdx</srcid><srcstatus/><internalId>1151</internalId></linkedfrom><linkedfrom><srcid>EthIf.dsn.Func.PostBuildSelectable.EthIfSwitchPortGroupRefSemantics</srcid><srcstatus/><internalId>1152</internalId></linkedfrom><linkedfrom><srcid>EthIf.dsn.Func.PostBuildSelectable.EthIfPortRef</srcid><srcstatus/><internalId>1153</internalId></linkedfrom><linkedfrom><srcid>dsn.Func020.EB.PostBuildSelectable.EthIfSecurityEventRefs</srcid><srcstatus/><internalId>1156</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <fulfilledby>
        <ffbObj>
          <ffbId>EthIf.EB.PBSelectable.FileName</ffbId>
          <ffbType>swurs</ffbType>
          <ffbVersion>1</ffbVersion>
        <ffbLinkstatus>linked</ffbLinkstatus><ffbLinkerror/><ffbObjcovstatus>covered</ffbObjcovstatus><internalId>979</internalId></ffbObj>
        <ffbObj>
          <ffbId>EthIf.EB.PBSelectable.TypeName</ffbId>
          <ffbType>swurs</ffbType>
          <ffbVersion>1</ffbVersion>
        <ffbLinkstatus>linked</ffbLinkstatus><ffbLinkerror/><ffbObjcovstatus>covered</ffbObjcovstatus><internalId>980</internalId></ffbObj>
        <ffbObj>
          <ffbId>EthIf.EB.PBSelectable.Master</ffbId>
          <ffbType>swurs</ffbType>
          <ffbVersion>1</ffbVersion>
        <ffbLinkstatus>linked</ffbLinkstatus><ffbLinkerror/><ffbObjcovstatus>covered</ffbObjcovstatus><internalId>981</internalId></ffbObj>
      <containerCovstatus>covered</containerCovstatus></fulfilledby>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1126</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="Support for reporting security events to IdsM">
    <specobject>
      <id>EthIf.dsn.Func020.SecurityEventReporting</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>1336</sourceline>
      <version>1</version>
      <description>
          Ethernet interface shall report to the IdsM respective security events via the defined interface.
        </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.ECUC_EthIf_00079</srcid><srcstatus/><internalId>844</internalId></linkedfrom><linkedfrom><srcid>EthIf.ECUC_EthIf_00080</srcid><srcstatus/><internalId>845</internalId></linkedfrom><linkedfrom><srcid>EthIf.ECUC_EthIf_00081</srcid><srcstatus/><internalId>846</internalId></linkedfrom><linkedfrom><srcid>EthIf.ECUC_EthIf_00082</srcid><srcstatus/><internalId>847</internalId></linkedfrom><linkedfrom><srcid>EthIf.ECUC_EthIf_00083</srcid><srcstatus/><internalId>848</internalId></linkedfrom><linkedfrom><srcid>EthIf.SWS_EthIf_00503</srcid><srcstatus/><internalId>871</internalId></linkedfrom><linkedfrom><srcid>dsn.Func020.EB.PostBuildSelectable.EthIfSecurityEventRefs</srcid><srcstatus/><internalId>1156</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfSecurityEventRefs.Added</srcid><srcstatus/><internalId>1223</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfSecurityEventRefs.Valid</srcid><srcstatus/><internalId>1224</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.XdmCheck.EthIfSecurityEventRefs.Unique</srcid><srcstatus/><internalId>1225</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1127</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="Support for MACsec">
    <specobject>
      <id>EthIf.dsn.Func021.MacSecSupport</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>1351</sourceline>
      <version>1</version>
      <description>
          Ethernet interface shall support MACsec and MKA protocols.
        </description>
      <furtherinfo>
          WRN.swurs.needscoverage.count - Linking all relevant requirements to the single top-level
          requirement brings clear benefits and splitting them up would only increase complexity
          without any real benefit.
        </furtherinfo>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_00560</srcid><srcstatus/><internalId>873</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_00561</srcid><srcstatus/><internalId>874</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_00562</srcid><srcstatus/><internalId>875</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_00563</srcid><srcstatus/><internalId>876</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_00564</srcid><srcstatus/><internalId>877</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_00565</srcid><srcstatus/><internalId>878</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_00566</srcid><srcstatus/><internalId>879</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_00567</srcid><srcstatus/><internalId>880</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_00568</srcid><srcstatus/><internalId>881</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_00569</srcid><srcstatus/><internalId>882</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_00570</srcid><srcstatus/><internalId>883</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_00571</srcid><srcstatus/><internalId>884</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_00572</srcid><srcstatus/><internalId>885</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_00573</srcid><srcstatus/><internalId>886</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_00574</srcid><srcstatus/><internalId>887</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_00575</srcid><srcstatus/><internalId>888</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_00576</srcid><srcstatus/><internalId>889</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_00577</srcid><srcstatus/><internalId>890</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_00578</srcid><srcstatus/><internalId>891</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_00579</srcid><srcstatus/><internalId>892</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_00580</srcid><srcstatus/><internalId>893</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_00581</srcid><srcstatus/><internalId>894</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.SWS_EthIf_00581.1</srcid><srcstatus/><internalId>895</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.SWS_EthIf_00581.2</srcid><srcstatus/><internalId>896</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_00582</srcid><srcstatus/><internalId>897</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.SWS_EthIf_00582.1</srcid><srcstatus/><internalId>898</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.SWS_EthIf_00582.2</srcid><srcstatus/><internalId>899</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_00583</srcid><srcstatus/><internalId>900</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_00584</srcid><srcstatus/><internalId>901</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_91215</srcid><srcstatus/><internalId>902</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_91217</srcid><srcstatus/><internalId>903</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_91218</srcid><srcstatus/><internalId>904</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_91220</srcid><srcstatus/><internalId>905</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_91211</srcid><srcstatus/><internalId>906</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_91221</srcid><srcstatus/><internalId>907</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_91213</srcid><srcstatus/><internalId>908</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_91222</srcid><srcstatus/><internalId>909</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_91206</srcid><srcstatus/><internalId>910</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_91223</srcid><srcstatus/><internalId>911</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_91224</srcid><srcstatus/><internalId>912</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_91225</srcid><srcstatus/><internalId>913</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_91216</srcid><srcstatus/><internalId>914</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_91226</srcid><srcstatus/><internalId>915</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_91208</srcid><srcstatus/><internalId>916</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_91227</srcid><srcstatus/><internalId>917</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_91205</srcid><srcstatus/><internalId>918</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_91228</srcid><srcstatus/><internalId>919</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_91229</srcid><srcstatus/><internalId>920</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_91230</srcid><srcstatus/><internalId>921</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_91214</srcid><srcstatus/><internalId>922</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_91231</srcid><srcstatus/><internalId>923</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_91207</srcid><srcstatus/><internalId>924</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_91232</srcid><srcstatus/><internalId>925</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_91210</srcid><srcstatus/><internalId>926</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_91233</srcid><srcstatus/><internalId>927</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_91209</srcid><srcstatus/><internalId>928</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_91234</srcid><srcstatus/><internalId>929</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_91235</srcid><srcstatus/><internalId>930</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_91236</srcid><srcstatus/><internalId>931</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_91212</srcid><srcstatus/><internalId>932</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_91237</srcid><srcstatus/><internalId>933</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.SWS_EthIf_91238</srcid><srcstatus/><internalId>934</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.ECUC_EthIf_00089</srcid><srcstatus/><internalId>935</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.ECUC_EthIf_00089</srcid><srcstatus/><internalId>936</internalId></linkedfrom><linkedfrom><srcid>EthIf.ASR_R22-11.ECUC_EthIf_00090</srcid><srcstatus/><internalId>937</internalId></linkedfrom><linkedfrom><srcid>EthIf.EB.ECUC_EthIf_00090</srcid><srcstatus/><internalId>938</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1128</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs">
    <specobject>
      <id>EthIf.EB.SWS_EthIf_00261</id>
      <status>approved</status>
      <source>design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>4447</sourceline>
      <version>1</version>
      <description>
        In case a EthIfSwitchPortGroup is not connected to any EthIfController, the EthIf
        shall indicate the accumulated link state of the EthIfSwitchPortGroup to the BswM by
        calling BswM_EthIf_PortGroupLinkStateChg for the EthIfSwitchPortGroup when the
        link state changes (refer to [SWS_EthIf_00259] for link state accumulation).

        As stated in [SWS_EthIf_00270] and [SWS_EthIf_00271] shut-down of ports when port group
        is under control of BswM shall be delayed for the time period specified in
        EthIfSwitchOffPortTimeDelay.

        During the delay time period, EthIf shall accumulate and report the actual port group link
        state. When delay timer expires EthIf shall report port group link state LINK_STATE_DOWN
        even though ports could still be active and accumulated link state LINK_STATE_ACTIVE.
        Note: This can happen if ports cannot be shut-down because they are used by other active
        port group.
      </description>
      <comment>
        Rationale: Reporting port group link state LINK_STATE_DOWN before switch off delay timer
        expires could trigger TcpIp_RequestComMode(TCPIP_STATE_ONHOLD) resulting in traffic
        interruption of UdpNm request.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06006_PortGroup_LinkStateChg</srcid><srcstatus/><internalId>1475</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06020_EthSwt_GetLinkState_MiiCheck</srcid><srcstatus/><internalId>1489</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06020_EthSwt_GetLinkState_MiiCheck_Wakeup</srcid><srcstatus/><internalId>1490</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06032_BswMPortGroup_LinkStateChg</srcid><srcstatus/><internalId>1502</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06034_BswMPortGroup_LinkStateChg_LINK_INFO</srcid><srcstatus/><internalId>1503</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.LinkStateAccSwitchPortGroup</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1118</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00261</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>614</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1129</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="Requirements:">
    <specobject>
      <id>EthIf.EB.RxIndication.EthSwt_EthIfPreProcessRxFrame.OK</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>5293</sourceline>
      <version>1</version>
      <description>
            If EthIf_RxIndication() is called for the controller that references an Ethernet switch,
            function EthSwt_EthIfPreProcessRxFrame() shall be called to perform Ethernet switch delays
            compensation and if the result of this operation is OK frame will be processed.
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06023_RxIndication_EthIfPreProcessRxFrame_OK</srcid><srcstatus/><internalId>1493</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.GlobalTime</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1116</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1130</internalId></specobject>
    <specobject>
      <id>EthIf.EB.RxIndication.EthSwt_EthIfPreProcessRxFrame.NOK</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>5314</sourceline>
      <version>1</version>
      <description>
            If EthIf_RxIndication() is called for the controller that references an Ethernet switch,
            function EthSwt_EthIfPreProcessRxFrame() shall be called to perform Ethernet switch delays
            compensation and if the result of this operation is false frame will be discarded.
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06024_RxIndication_EthIfPreProcessRxFrame_NOK</srcid><srcstatus/><internalId>1494</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.GlobalTime</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1116</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1131</internalId></specobject>
    <specobject>
      <id>EthIf.EB.SetControllerModeDown.EthSM_CtrlModeIndication</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>5334</sourceline>
      <version>1</version>
      <description>
            If EthIf_SetControllerMode() is called with CtrlMode ETH_MODE_DOWN for an active Virtual
            EthIf Controller which references valid EthIfSwitchPortGroup, where at least one port is
            common (shared among port groups) EthIf shall call  EthSM_CtrlModeIndication() to indicate
            CtrlMode change to ETH_MODE_DOWN to EthSM module.
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06009_PortGroup_AllPortsNotDown</srcid><srcstatus/><internalId>1476</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06013_MainFunctionCycleCounter</srcid><srcstatus/><internalId>1480</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06029_AllPortsNotDown_2</srcid><srcstatus/><internalId>1499</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06031_SetControllerMode_PortGroup</srcid><srcstatus/><internalId>1501</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.SwitchPortGroup</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1117</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1132</internalId></specobject>
    <specobject>
      <id>EthIf.EB.RxIndication.EthIf_Up_RxIndicationDummy</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>5356</sourceline>
      <version>1</version>
      <description>
            In case UL_RxIndication shall not be called for a specific EthIfFrameType, the user shall configure EthIf_Up_RxIndicationDummy
            in a respective EthIfRxIndicationFunction field.
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest03014_RxIndicationDummy</srcid><srcstatus/><internalId>1395</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1133</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="Support for drivers that contain vendorId and vendorApiInfix">
    <specobject>
      <id>EthIf.EB.DriverVendorInfo.EthIfEthControllerType</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>5373</sourceline>
      <version>1</version>
      <description>
            Container Name: EthIfEthControllerType.
            Description: Contains Eth Controller data used for support of Eth Controller that
                         contains vendorId and vendorApiInfix.
            Multiplicity 0 - 255.
            Type IDENTIFIABLE.
            Range --.
          </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/EthIf_EBParameters.xdm.m4_864</srcid><srcstatus/><internalId>1082</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.DriverVendorInfoSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1124</internalId></provcov>
        <provcov>
          <linksto>EthIf.dsn.Func.MultipleEthCtrlTrcvSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1125</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1134</internalId></specobject>
    <specobject>
      <id>EthIf.EB.DriverVendorInfo.EthIfEthControllerBswmdImplementationRefs</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>5403</sourceline>
      <version>1</version>
      <description>
            Name EthIfEthControllerBswmdImplementationRefs.
            Description: Reference to an Eth Controller that shall indicate the vendorId and
                         vendorApiInfix from its BSWMD. To be configured only when support of Eth
                         Controller that contains vendorId and vendorApiInfix is used.
            ConfigurationClass Pre-compile time X All variants.
                               Link time -.
                               Post-build time -.
            Scope / Dependency scope: Module.
          </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/EthIf_EBParameters.xdm.m4_870</srcid><srcstatus/><internalId>1083</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.DriverVendorInfoSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1124</internalId></provcov>
        <provcov>
          <linksto>EthIf.dsn.Func.MultipleEthCtrlTrcvSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1125</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1135</internalId></specobject>
    <specobject>
      <id>EthIf.EB.DriverVendorInfo.EthIfEthCtrlTypeRef</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>5435</sourceline>
      <version>1</version>
      <description>
            Name EthIfEthCtrlTypeRef.
            Description: Reference to the Ethernet Controller.
            ConfigurationClass Pre-compile time X All variants.
                               Link time -.
                               Post-build time -.
            Scope / Dependency scope: Module.
          </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/EthIf_EBParameters.xdm.m4_900</srcid><srcstatus/><internalId>1085</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.DriverVendorInfoSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1124</internalId></provcov>
        <provcov>
          <linksto>EthIf.dsn.Func.MultipleEthCtrlTrcvSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1125</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1136</internalId></specobject>
    <specobject>
      <id>EthIf.EB.DriverVendorInfo.EthIfEthTrcvType</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>5465</sourceline>
      <version>1</version>
      <description>
            Container Name: EthIfEthTrcvType.
            Description: Contains Eth Transceiver data used for support of EthTrcv that contains
                         vendorId and vendorApiInfix.
            Multiplicity 0 - 255.
            Type IDENTIFIABLE.
            Range --.
          </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/EthIf_EBParameters.xdm.m4_925</srcid><srcstatus/><internalId>1086</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.DriverVendorInfoSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1124</internalId></provcov>
        <provcov>
          <linksto>EthIf.dsn.Func.MultipleEthCtrlTrcvSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1125</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1137</internalId></specobject>
    <specobject>
      <id>EthIf.EB.DriverVendorInfo.EthIfEthTrcvBswmdImplementationRefs</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>5495</sourceline>
      <version>1</version>
      <description>
            Name EthIfEthTrcvBswmdImplementationRefs.
            Description: Reference to an Eth Transceiver that shall indicate the vendorId and
                         vendorApiInfix from its BSWMD. To be configured only when support of Eth
                         Transceiver that contains vendorId and vendorApiInfix is used.
            ConfigurationClass Pre-compile time X All variants.
                               Link time -.
                               Post-build time -.
            Scope / Dependency scope: Module.
          </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/EthIf_EBParameters.xdm.m4_931</srcid><srcstatus/><internalId>1087</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.DriverVendorInfoSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1124</internalId></provcov>
        <provcov>
          <linksto>EthIf.dsn.Func.MultipleEthCtrlTrcvSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1125</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1138</internalId></specobject>
    <specobject>
      <id>EthIf.EB.DriverVendorInfo.EthIfEthTrcvTypeRef</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>5527</sourceline>
      <version>1</version>
      <description>
            Name EthIfEthTrcvTypeRef.
            Description: Reference to the Ethernet transceiver.
            ConfigurationClass Pre-compile time X All variants.
                               Link time -.
                               Post-build time -.
            Scope / Dependency scope: Module.
          </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/EthIf_EBParameters.xdm.m4_961</srcid><srcstatus/><internalId>1089</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.DriverVendorInfoSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1124</internalId></provcov>
        <provcov>
          <linksto>EthIf.dsn.Func.MultipleEthCtrlTrcvSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1125</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1139</internalId></specobject>
    <specobject>
      <id>EthIf.EB.DriverVendorInfo.EthIfEthSwtType</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>5557</sourceline>
      <version>1</version>
      <description>
            Container Name: EthIfEthSwtType.
            Description: Contains Eth Switch data used for support of EthSwt that contains
                         vendorId and vendorApiInfix.
            Multiplicity 0 - 1.
            Type IDENTIFIABLE.
            Range --.
          </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/EthIf_EBParameters.xdm.m4_984</srcid><srcstatus/><internalId>1090</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.DriverVendorInfoSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1124</internalId></provcov>
        <provcov>
          <linksto>EthIf.dsn.Func.MultipleEthCtrlTrcvSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1125</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1140</internalId></specobject>
    <specobject>
      <id>EthIf.EB.DriverVendorInfo.EthIfEthSwtTypeRef</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>5587</sourceline>
      <version>1</version>
      <description>
            Name EthIfEthSwtTypeRef.
            Description: Reference to the Ethernet switch.
            ConfigurationClass Pre-compile time X All variants.
                               Link time -.
                               Post-build time -.
            Scope / Dependency scope: Module.
          </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/EthIf_EBParameters.xdm.m4_1016</srcid><srcstatus/><internalId>1093</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.DriverVendorInfoSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1124</internalId></provcov>
        <provcov>
          <linksto>EthIf.dsn.Func.MultipleEthCtrlTrcvSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1125</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1141</internalId></specobject>
    <specobject>
      <id>EthIf.EB.DriverVendorInfo.EthIfEthSwtBswmdImplementationRefs</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>5617</sourceline>
      <version>1</version>
      <description>
            Name EthIfEthSwtBswmdImplementationRefs.
            Description: Reference to an Eth Switch that shall indicate the vendorId and
                         vendorApiInfix from its BSWMD. To be configured only when support of Eth
                         Switch that contains vendorId and vendorApiInfix is used.
            ConfigurationClass Pre-compile time X All variants.
                               Link time -.
                               Post-build time -.
            Scope / Dependency scope: Module.
          </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/EthIf_EBParameters.xdm.m4_992</srcid><srcstatus/><internalId>1091</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.DriverVendorInfoSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1124</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1142</internalId></specobject>
    <specobject>
      <id>EthIf.EB.DriverVendorInfo.EthController_FuncNameMangling</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>5643</sourceline>
      <version>1</version>
      <description>
            If valid reference to Eth Controller indicating the vendorId and vendorApiInfix from
            its BSWMD is configured, then all Eth Controller functions called by EthIf have to
            follow the naming convention specified in BSW00347.
            The naming convention is as follows: &amp;lt;Eth&amp;gt;_&amp;lt;vendorID&amp;gt;_&amp;lt;Vendor specific
            name&amp;gt;_&amp;lt;API Service name&amp;gt;().
          </description>
      <verifycrit>
            This requirement shall be tested with a configuration that contains single Eth driver
            with a configured reference into EthIfEthControllerBswmdImplementationRefs, i.e. using
            mangled API names.
            Within this test configuration create test cases that reach all Eth driver APIs:
              Eth_[VendorId]_[VendorName]_GetControllerMode()
              Eth_[VendorId]_[VendorName]_GetPhysAddr()
              Eth_[VendorId]_[VendorName]_ProvideTxBuffer()
              Eth_[VendorId]_[VendorName]_ReadMii()
              Eth_[VendorId]_[VendorName]_WriteMii()
              Eth_[VendorId]_[VendorName]_Receive()
              Eth_[VendorId]_[VendorName]_SetControllerMode()
              Eth_[VendorId]_[VendorName]_Transmit()
              Eth_[VendorId]_[VendorName]_TxConfirmation()
              Eth_[VendorId]_[VendorName]_SetPhysAddr()
              Eth_[VendorId]_[VendorName]_UpdatePhysAddrFilter()
              Eth_[VendorId]_[VendorName]_GetCurrentTime()
              Eth_[VendorId]_[VendorName]_EnableEgressTimeStamp()
              Eth_[VendorId]_[VendorName]_GetEgressTimeStamp()
              Eth_[VendorId]_[VendorName]_GetIngressTimeStamp()
              Eth_[VendorId]_[VendorName]_Retransmit().
            EthIfSupportEthAPI shall be set to ASR430.
          </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest10000_SetSwitchPortMode</srcid><srcstatus/><internalId>1671</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest10002_Transmit</srcid><srcstatus/><internalId>1673</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest10003_GetIngressTimeStamp</srcid><srcstatus/><internalId>1674</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest10020_GetPhysAddr</srcid><srcstatus/><internalId>1690</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest10021_ReadWriteMii</srcid><srcstatus/><internalId>1691</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest10022_EthPhysAddr</srcid><srcstatus/><internalId>1692</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest10023_EthTimeFunctions</srcid><srcstatus/><internalId>1693</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest10024_SetGetControllerMode</srcid><srcstatus/><internalId>1694</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.DriverVendorInfoSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1124</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1143</internalId></specobject>
    <specobject>
      <id>EthIf.EB.DriverVendorInfo.EthTrcv_FuncNameMangling</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>5689</sourceline>
      <version>1</version>
      <description>
            If valid reference to Eth Transceiver indicating the vendorId and vendorApiInfix from
            its BSWMD is configured, then all Eth Transceiver functions called by EthIf have to
            follow the naming convention specified in BSW00347.
            The naming convention is as follows:&amp;lt;EthTrcv&amp;gt;_&amp;lt;vendorID&amp;gt;_&amp;lt;Vendor specific
            name&amp;gt;_&amp;lt;API Service name&amp;gt;().
          </description>
      <furtherinfo>
            WRN.swuts.needscoverage.count - Linking all relevant test cases to the single requirement brings clear benefits and
            splitting them up would only increase complexity without any real improvements.
          </furtherinfo>
      <verifycrit>
            Use case 1 (single transceiver used):
            This requirement shall be tested with a configuration that contains single EthTrcv
            driver with a configured reference into EthIfEthTrcvBswmdImplementationRefs, i.e. using
            mangled API names.
            Within this test configuration create test cases that reach all EthTrcv driver APIs:
              EthTrcv_[VendorId]_[VendorName]_SetPhyLoopbackMode()
              EthTrcv_[VendorId]_[VendorName]_SetPhyTxMode()
              EthTrcv_[VendorId]_[VendorName]_GetPhySignalQuality()
              EthTrcv_[VendorId]_[VendorName]_GetCableDiagnosticsResult()
              EthTrcv_[VendorId]_[VendorName]_GetPhyIdentifier()
              EthTrcv_[VendorId]_[VendorName]_SetPhyTestMode()
              EthTrcv_[VendorId]_[VendorName]_SetTransceiverWakeupMode()
              EthTrcv_[VendorId]_[VendorName]_GetTransceiverWakeupMode()
              EthTrcv_[VendorId]_[VendorName]_CheckWakeup()
              EthTrcv_[VendorId]_[VendorName]_SetTransceiverMode()
              EthTrcv_[VendorId]_[VendorName]_GetTransceiverMode()
              EthTrcv_[VendorId]_[VendorName]_GetLinkState()
              EthTrcv_[VendorId]_[VendorName]_RunCableDiagnostic()
            EthIfSupportEthAPI shall be set to ASR430.
          </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest10011_SetPhyLoopbackMode</srcid><srcstatus/><internalId>1681</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest10012_SetPhyTxMode</srcid><srcstatus/><internalId>1682</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest10013_GetPhySignalQuality</srcid><srcstatus/><internalId>1683</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest10014_GetPhyIdentifier</srcid><srcstatus/><internalId>1684</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest10015_SetPhyTestMode</srcid><srcstatus/><internalId>1685</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest10016_SetTransceiverWakeupMode</srcid><srcstatus/><internalId>1686</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest10017_GetTransceiverWakeupMode</srcid><srcstatus/><internalId>1687</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest10018_CheckWakeup</srcid><srcstatus/><internalId>1688</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest10019_TrcvPortCableDiagnostic</srcid><srcstatus/><internalId>1689</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest10025_MacSecAddDeleteTxSa</srcid><srcstatus/><internalId>1695</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest10026_MacSecUpdateSecY</srcid><srcstatus/><internalId>1696</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest10027_MacSecInitResetRxSc</srcid><srcstatus/><internalId>1697</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest10028_MacSecAddDeleteRxSa</srcid><srcstatus/><internalId>1698</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest10029_EthIf_MacSecUpdateTxRxSa</srcid><srcstatus/><internalId>1699</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.DriverVendorInfoSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1124</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1144</internalId></specobject>
    <specobject>
      <id>EthIf.EB.DriverVendorInfo.EthSwt_FuncNameMangling</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>5737</sourceline>
      <version>1</version>
      <description>
            If valid reference to Eth Switch indicating the vendorId and vendorApiInfix from its
            BSWMD is configured, then all Eth Switch functions called by EthIf have to follow the
            naming convention specified in BSW00347. (BSW00347)
            The naming convention is as follows: &amp;lt;EthSwt&amp;gt;_&amp;lt;vendorID&amp;gt;_&amp;lt;Vendor specific
            name&amp;gt;_&amp;lt;API Service name&amp;gt;().
          </description>
      <verifycrit>
            This requirement shall be tested with a configuration that contains single EthSwt driver
            with a configured reference into EthIfEthSwtBswmdImplementationRefs, i.e. using mangled API
            names.
            Within this test configuration create test cases that reach all EthSwt driver APIs:
              EthSwt_[VendorId]_[VendorName]_EthIfTxAdaptFrameTypeBufferLength()
              EthSwt_[VendorId]_[VendorName]_EthIfPreProcessTxFrame()
              EthSwt_[VendorId]_[VendorName]_EthIfPreProcessRxFrame()
              EthSwt_[VendorId]_[VendorName]_GetPortSignalQuality()
              EthSwt_[VendorId]_[VendorName]_GetArlTable()
              EthSwt_[VendorId]_[VendorName]_GetBufferLevel()
              EthSwt_[VendorId]_[VendorName]_GetCounterValues()
              EthSwt_[VendorId]_[VendorName]_StoreConfiguration()
              EthSwt_[VendorId]_[VendorName]_ResetConfiguration()
              EthSwt_[VendorId]_[VendorName]_SetSwitchPortMode()
              EthSwt_[VendorId]_[VendorName]_GetLinkState()
              EthSwt_[VendorId]_[VendorName]_PortRunCableDiagnostic()
              EthSwt_[VendorId]_[VendorName]_GetPortCableDiagnosticsResult().
            EthIfSupportEthAPI shall be set to ASR430.
          </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest10000_SetSwitchPortMode</srcid><srcstatus/><internalId>1671</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest10001_PreProcessRxFrame</srcid><srcstatus/><internalId>1672</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest10002_Transmit</srcid><srcstatus/><internalId>1673</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest10004_GetPortSignalQuality</srcid><srcstatus/><internalId>1675</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest10005_GetArlTable</srcid><srcstatus/><internalId>1676</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest10006_GetBufferLevel</srcid><srcstatus/><internalId>1677</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest10007_SwtGetCounterValues</srcid><srcstatus/><internalId>1678</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest10008_StoreConfiguration</srcid><srcstatus/><internalId>1679</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest10009_ResetConfiguration</srcid><srcstatus/><internalId>1680</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.DriverVendorInfoSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1124</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1145</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="Support of multiple Eth controller and Eth transceiver">
    <specobject>
      <id>EthIf.EB.MultipleEthCtrlTrcv.MultipleEthControllers</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>5782</sourceline>
      <version>1</version>
      <description>
            If multiple Eth Controller BSWMD references are configured in
            EthIfEthControllerBswmdImplementationRefs list, then EthIf shall call a separate set of
            functions for each configured Eth Controller where the function names have to follow the
            naming convention specified in BSW00347.
            The naming convention is as follows: &amp;lt;Eth&amp;gt;_&amp;lt;vendorID&amp;gt;_&amp;lt;
            Vendor specific name&amp;gt;_&amp;lt;API Service name&amp;gt;().
          </description>
      <verifycrit>
            This requirement shall be tested with a configuration that contains two Ethernet
            controllers with a configured references into EthIfEthControllerBswmdImplementationRefs,
            i.e. using two sets of mangled API names.
          </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest11001_Transmit_Vendor1</srcid><srcstatus/><internalId>1700</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest11002_Transmit_Vendor2</srcid><srcstatus/><internalId>1701</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest11003_GetIngressTimeStamp</srcid><srcstatus/><internalId>1702</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest11014_GetPhysAddr</srcid><srcstatus/><internalId>1713</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest11015_ReadWriteMii</srcid><srcstatus/><internalId>1714</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest11016_EthPhysAddr</srcid><srcstatus/><internalId>1715</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest11017_EthTimeFunctions</srcid><srcstatus/><internalId>1716</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest11018_SetGetControllerMode</srcid><srcstatus/><internalId>1717</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.MultipleEthCtrlTrcvSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1125</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1146</internalId></specobject>
    <specobject>
      <id>EthIf.EB.MultipleEthCtrlTrcv.MultipleEthTransceivers</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>5811</sourceline>
      <version>1</version>
      <description>
            If multiple Eth Transceiver BSWMD references are configured in
            EthIfEthTrcvBswmdImplementationRefs list, then EthIf shall call a separate set of
            functions for each configured Eth Transceiver where the function names have to follow
            the naming convention specified in BSW00347.
            The naming convention is as follows: &amp;lt;EthTrcv&amp;gt;_&amp;lt;vendorID&amp;gt;_&amp;lt;
            Vendor specific name&amp;gt;_&amp;lt;API Service name&amp;gt;().
          </description>
      <furtherinfo>
            WRN.swuts.needscoverage.count - Linking all relevant test cases to the single requirement brings clear benefits and
            splitting them up would only increase complexity without any real improvements.
          </furtherinfo>
      <verifycrit>
            This requirement shall be tested with a configuration that contains two EthTrcv
            drivers with a configured references into EthIfEthTrcvBswmdImplementationRefs, i.e. using
            two sets of mangled API names.
          </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest11004_SetPhyLoopbackMode</srcid><srcstatus/><internalId>1703</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest11005_SetPhyTxMode</srcid><srcstatus/><internalId>1704</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest11006_GetPhySignalQuality</srcid><srcstatus/><internalId>1705</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest11007_GetPhyIdentifier</srcid><srcstatus/><internalId>1706</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest11008_SetPhyTestMode</srcid><srcstatus/><internalId>1707</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest11009_SetTransceiverWakeupMode</srcid><srcstatus/><internalId>1708</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest11010_GetTransceiverWakeupMode</srcid><srcstatus/><internalId>1709</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest11011_CheckWakeup</srcid><srcstatus/><internalId>1710</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest11012_TrcvPortCableDiagnostic_Vendor1</srcid><srcstatus/><internalId>1711</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest11013_TrcvPortCableDiagnostic_Vendor2</srcid><srcstatus/><internalId>1712</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest11019_MacSecGetTxSaNextPn</srcid><srcstatus/><internalId>1718</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest11020_MacSecGetMacSecStats</srcid><srcstatus/><internalId>1719</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest11021_MacSecSetControlledPortEnabled</srcid><srcstatus/><internalId>1720</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.MultipleEthCtrlTrcvSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1125</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1147</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="Post-build selectable support">
    <specobject>
      <id>EthIf.dsn.Func.PostBuildSelectable.EthIfSwitchRefOrPortGroupRef</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>5846</sourceline>
      <version>1</version>
      <description>
            Configuration parameter EthIfController/EthIfSwitchRefOrPortGroupRef shall support
            multiple selectable variants for both multiplicity and the value.
          </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/EthIf.xdm.m4_184</srcid><srcstatus/><internalId>1068</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06001_SetControllerMode_Switch</srcid><srcstatus/><internalId>1470</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06016_PortGroup_LinkStateChg</srcid><srcstatus/><internalId>1483</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.PostBuildSelectable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1126</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1148</internalId></specobject>
    <specobject>
      <id>EthIf.dsn.Func.PostBuildSelectable.EthIfSwitchIdx</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>5867</sourceline>
      <version>1</version>
      <description>
            Configuration parameter EthIfSwitch/EthIfSwitchIdx shall support
            multiple selectable variants.
          </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/EthIf.xdm.m4_425</srcid><srcstatus/><internalId>1070</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06001_SetControllerMode_Switch</srcid><srcstatus/><internalId>1470</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.PostBuildSelectable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1126</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1149</internalId></specobject>
    <specobject>
      <id>EthIf.dsn.Func.PostBuildSelectable.EthIfSwitchRef</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>5888</sourceline>
      <version>1</version>
      <description>
            Configuration parameter EthIfSwitch/EthIfSwitchRef shall support
            multiple selectable variants.
          </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/EthIf.xdm.m4_446</srcid><srcstatus/><internalId>1071</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06001_SetControllerMode_Switch</srcid><srcstatus/><internalId>1470</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.PostBuildSelectable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1126</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1150</internalId></specobject>
    <specobject>
      <id>EthIf.dsn.Func.PostBuildSelectable.EthIfSwitchPortGroupIdx</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>5909</sourceline>
      <version>1</version>
      <description>
            Configuration parameter EthIfSwitchPortGroup/EthIfSwitchPortGroupIdx shall support
            multiple selectable variants.
          </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/EthIf.xdm.m4_498</srcid><srcstatus/><internalId>1072</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06033_SetControllerMode_PortGroup_Variants</srcid><srcstatus/><internalId>1504</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.PostBuildSelectable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1126</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1151</internalId></specobject>
    <specobject>
      <id>EthIf.dsn.Func.PostBuildSelectable.EthIfSwitchPortGroupRefSemantics</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>5930</sourceline>
      <version>1</version>
      <description>
            Configuration parameter EthIfSwitchPortGroup/EthIfSwitchPortGroupRefSemantics shall
            support multiple selectable variants.
          </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/EthIf.xdm.m4_516</srcid><srcstatus/><internalId>1073</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06031_SetControllerMode_PortGroup</srcid><srcstatus/><internalId>1501</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.PostBuildSelectable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1126</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1152</internalId></specobject>
    <specobject>
      <id>EthIf.dsn.Func.PostBuildSelectable.EthIfPortRef</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>5951</sourceline>
      <version>1</version>
      <description>
            Configuration parameter EthIfSwitchPortGroup/EthIfPortRef shall support
            multiple selectable variants.
          </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/EthIf.xdm.m4_537</srcid><srcstatus/><internalId>1074</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06033_SetControllerMode_PortGroup_Variants</srcid><srcstatus/><internalId>1504</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.PostBuildSelectable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1126</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1153</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="Measurement data support">
    <specobject>
      <id>EthIf.EB.EthIf_GetAndResetMeasurementData.Unknown_EtherType</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>5974</sourceline>
      <version>1</version>
      <description>
            For measurement index ETHIF_MEAS_DROP_UNKNOWN_ETHERTYPE the function shall return the
            number of all dropped datagrams caused by unknown EtherType i.e. received FrameType was
            not found in module configuration.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest02045_GetAndResetMeasurementData_EthertypeNoMatch</srcid><srcstatus/><internalId>1926</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.GetAndResetMeasurementData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1121</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1154</internalId></specobject>
    <specobject>
      <id>EthIf.EB.EthIf_GetAndResetMeasurementData.Double_VLANTag</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>5996</sourceline>
      <version>1</version>
      <description>
            For measurement index ETHIF_MEAS_DROP_DOUBLE_VLANTAG the function shall return the
            number of all dropped datagrams due to double VLAN tag i.e. two 802.1Q headers with
            TPID = 0x8100.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest02046_GetAndResetMeasurementData_DoubleVLANTag</srcid><srcstatus/><internalId>1927</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.GetAndResetMeasurementData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1121</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1155</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="Support for reporting security events to IdsM">
    <specobject>
      <id>dsn.Func020.EB.PostBuildSelectable.EthIfSecurityEventRefs</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>6020</sourceline>
      <version>1</version>
      <description>
            Configuration parameters in EthIfSecurityEventRefs container shall support multiple
            selectable variants.
          </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/EthIf.xdm.m4_1172</srcid><srcstatus/><internalId>1077</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/config/EthIf.xdm.m4_1192</srcid><srcstatus/><internalId>1078</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/config/EthIf.xdm.m4_1212</srcid><srcstatus/><internalId>1079</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/config/EthIf_Extension.xdm.m4_1363</srcid><srcstatus/><internalId>1106</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/config/EthIf_Extension.xdm.m4_1383</srcid><srcstatus/><internalId>1107</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/config/EthIf_Extension.xdm.m4_1403</srcid><srcstatus/><internalId>1108</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_ConTest06035_RptSecEvToIdsM_ETHIF_SEV_DROP_INV_VLAN</srcid><srcstatus/><internalId>1516</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06036_RptSecEvToIdsM_ETHIF_SEV_DROP_VLAN_DOUBLE_TAG</srcid><srcstatus/><internalId>1517</internalId></linkedfrom><linkedfrom><srcid>EthIf_ConTest06037_RptSecEvToIdsM_ETHIF_SEV_DROP_UNKNOWN_ETHERTYPE</srcid><srcstatus/><internalId>1518</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func020.SecurityEventReporting</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1127</internalId></provcov>
        <provcov>
          <linksto>EthIf.dsn.Func.PostBuildSelectable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1126</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1156</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="Tresos XDM checks">
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfOwner.ZeroBasedConsecutive</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>8389</sourceline>
      <version>1</version>
      <description>
        If configuration parameter EthIfOwner is not zero based and consecutive, the generator shall
        raise an error message.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest01001_Err_Owner_Not_Consecutive</srcid><srcstatus/><internalId>1814</internalId></linkedfrom><linkedfrom><srcid>EthIf_GenTest01002_Err_Owner_Not_ZeroBased</srcid><srcstatus/><internalId>1815</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1157</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfPhysControllerIdx.ZeroBased</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>8409</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if not all EthIfPhysControllerIdx are zero based.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest01003_Err_EthIfPhysControllerIdx_NotZeroBased</srcid><srcstatus/><internalId>1816</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1158</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfPhysControllerIdx.Consecutive</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>8428</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if not all EthIfPhysControllerIdx are consecutive.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest01004_Err_EthIfPhysControllerIdx_NotConsecuitve</srcid><srcstatus/><internalId>1817</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1159</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfPhysControllerRef.Valid</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>8447</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if EthIfPhysControllerRef does not contain a
        valid reference.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest01005_Err_EthIfPhysController_NotConfigured</srcid><srcstatus/><internalId>1818</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1160</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfEthCtrlRef.Valid</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>8467</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if EthIfEthCtrlRef does not contain a valid
        reference.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest01006_Err_EthIfEthCtrlRef_NotConfigured</srcid><srcstatus/><internalId>1819</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1161</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfEthTrcvRef.Valid</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>8487</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if EthIfEthTrcvRef does not contain a valid
        reference.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest01007_Err_EthIfEthTrcvRef_NotConfigured</srcid><srcstatus/><internalId>1820</internalId></linkedfrom><linkedfrom><srcid>EthIf_GenTest01015_Err_EthIfEthTrcvRef_NotConfigured</srcid><srcstatus/><internalId>1828</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1162</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfTransceiverIdx.ZeroBased</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>8507</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if not all EthIfTransceiverIdx are zero based.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest01013_Err_EthIfTransceiverIdx_NotZeroBased</srcid><srcstatus/><internalId>1826</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1163</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfTransceiverIdx.Consecutive</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>8526</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if not all EthIfTransceiverIdx are consecutive.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest01014_Err_EthIfTransceiverIdx_NotConsecuitve</srcid><srcstatus/><internalId>1827</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1164</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfCtrlIdx.ZeroBased</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>8545</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if not all EthIfCtrlIdx are zero based.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest01008_Err_EthIfCtrlIdx_NotZeroBased</srcid><srcstatus/><internalId>1821</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1165</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfCtrlIdx.Consecutive</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>8564</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if not all EthIfCtrlIdx are consecutive.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest01009_Err_EthIfCtrlIdx_NotConsecutive</srcid><srcstatus/><internalId>1822</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1166</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfSwitchRef.Valid</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>8583</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if EthIfSwitchRef does not contain a valid
        reference.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest01010_Err_EthIfSwitchRef_NotConfigured</srcid><srcstatus/><internalId>1823</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1167</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfSwitch.ZeroBased</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>8603</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if not all referenced EthIfSwitch are zero based.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest01011_Err_EthIfSwitchIdx_NotZeroBased</srcid><srcstatus/><internalId>1824</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1168</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfSwitch.Consecutive</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>8622</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if not all EthIfSwitch are consecutive.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest01012_Err_EthIfSwitchIdx_NotConsecutive</srcid><srcstatus/><internalId>1825</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1169</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfCtrlIdx.NoVlanGroupedFirst</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>8641</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if EthIfCtrlIdx of controllers without VLAN
        are not grouped before controllers using VLAN.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest02003_Err_EthIfCtrlIdx_NoVlanGroupedFirst</srcid><srcstatus/><internalId>1842</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1170</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfMaxCtrl</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>8661</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if the number of EthIfController containers
        exceedes the parameter EthIfMaxCtrl.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest02004_Err_EthIfMaxCtrl_Exceeded</srcid><srcstatus/><internalId>1843</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1171</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfVirtualCtrlSupportEnable</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>8681</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if EthIfVirtualCtrlSupportEnable is disabled
        and at least one Eth controller is referenced by more than one EthIf controller.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest02006_Err_EthIfVirtualCtrlSupportEnable_DisabledWhenVlanUsed</srcid><srcstatus/><internalId>1844</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1172</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfVlanId.MultipleControllersNotConfigured</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>8701</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if more then one EthIf controller referencing
        the same Eth controller does not have a valid VLAN identifier.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest02007_Err_EthIfVlanId_MultipleControllersNotConfigured</srcid><srcstatus/><internalId>1845</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1173</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfController.SameEthController.DiffEthTrcv</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>8721</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if any of EthIf controllers referencing the
        same Eth controller do not reference the same EthTrcv.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest02008_Err_EthIfController_SameEthController_DiffEthTrcv</srcid><srcstatus/><internalId>1846</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1174</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthTrcv.MultipleEthControllers</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>8741</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if EthTrcv is not referenced by only one
        Eth controller.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest02009_Err_EthTrcv_MultipleEthControllers</srcid><srcstatus/><internalId>1847</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1175</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfVlanId.Unique</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>8761</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if VLAN identifiers are not unique for
        EthIf controllers referencing the same Eth controller.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest02010_Err_EthIfVlanId_NotUnique</srcid><srcstatus/><internalId>1848</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1176</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfOwner.Range</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>8781</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if EthIfOwner is not within a range [0, 254].
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest02011_Err_EthIfOwner_OutOfRange1</srcid><srcstatus/><internalId>1849</internalId></linkedfrom><linkedfrom><srcid>EthIf_GenTest02012_Err_EthIfOwner_OutOfRange2</srcid><srcstatus/><internalId>1850</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1177</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfMaxPhyCtrl</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>8800</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if the number of physical eth controllers
        (EthIfPhysController) exceeds value of parameter EthIfMaxPhyCtrl.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest02013_Err_EthIfMaxPhyCtrl_Exceeded</srcid><srcstatus/><internalId>1851</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1178</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthCtrl.NotReferenced</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>8820</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if EthIfPhysController is not referenced
        by at least one EthIfController.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest02015_Err_EthCtrl_NotReferenced</srcid><srcstatus/><internalId>1852</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1179</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfTransciever.BothReferencesDisabled</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>8840</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if EthIfTransciever have both EthIfEthTrcvRef
        and EthIfWEthTrcvRef disabled.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest02016_Err_EthIfTransciever_BothReferencesDisabled</srcid><srcstatus/><internalId>1853</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1180</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfTransciever.NotReferenced</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>8860</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if EthIfTransciever is not referenced by
        at least one EthIfController.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest02017_Err_EthIfTransciever_NotReferenced</srcid><srcstatus/><internalId>1854</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1181</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthCtrlEnableRxInterrupt.Enabled</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>8880</sourceline>
      <version>1</version>
      <description>
        The generator shall raise a warning message if at least one Eth controller is configured
        with "EthCtrlEnableRxInterrupt = true" - since EthIf does not support receive interrupts.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest02018_Warn_EthCtrlEnableRxInterrupt_Enabled</srcid><srcstatus/><internalId>1855</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1182</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthCtrlEnableTxInterrupt.Enabled</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>8900</sourceline>
      <version>1</version>
      <description>
        The generator shall raise a warning message if at least one Eth controller is configured
        with "EthCtrlEnableTxInterrupt = true" - since EthIf does not support transmit interrupts.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest02019_Warn_EthCtrlEnableTxInterrupt_Enabled</srcid><srcstatus/><internalId>1856</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1183</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfMainFunctionPeriod.Range</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>8920</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if EthIfMainFunctionPeriod is not
        within a range [0, 65535].
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest02020_Err_EthIfMainFunctionPeriod_OutOfRange1</srcid><srcstatus/><internalId>1857</internalId></linkedfrom><linkedfrom><srcid>EthIf_GenTest02021_Err_EthIfMainFunctionPeriod_OutOfRange2</srcid><srcstatus/><internalId>1858</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1184</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfRxIndicationIterations.Range</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>8940</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if EthIfRxIndicationIterations is not
        within a range [1, 65535].
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest02022_Err_EthIfRxIndicationIterations_OutOfRange1</srcid><srcstatus/><internalId>1859</internalId></linkedfrom><linkedfrom><srcid>EthIf_GenTest02023_Err_EthIfRxIndicationIterations_OutOfRange2</srcid><srcstatus/><internalId>1860</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1185</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfPhysCtrlRxMainFuncPrioProces.EthIfEthCtrlRef.Invalid</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>8960</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if EthIfEthCtrlRef in
        EthIfPhysCtrlRxMainFunctionPriorityProcessing is not valid.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest02024_Err_EthIfPhysCtrlRxMainFuncPrioProces_EthIfEthCtrlRef_Invalid</srcid><srcstatus/><internalId>1861</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1186</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfPhysCtrlRxMainFuncPrioProces.FifoAlreadyMapped</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>8980</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if EthIfEthCtrlRef in
        EthIfPhysCtrlRxMainFunctionPriorityProcessing is already used.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest02025_Err_EthIfPhysCtrlRxMainFuncPrioProces_FifoAlreadyMapped</srcid><srcstatus/><internalId>1862</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1187</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfPhysCtrlRxIndicationIterations.Range</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>9000</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if EthIfPhysCtrlRxIndicationIterations is not
        within a range [1, 65535].
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest02026_Err_EthIfPhysCtrlRxIndicationIterations_OutOfRange1</srcid><srcstatus/><internalId>1863</internalId></linkedfrom><linkedfrom><srcid>EthIf_GenTest02027_Err_EthIfPhysCtrlRxIndicationIterations_OutOfRange2</srcid><srcstatus/><internalId>1864</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1188</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfPhysCtrlRxMainFunctionPeriod.Range</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>9020</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if EthIfPhysCtrlRxMainFunctionPeriod is not
        within a range [0, 65535].
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest02001_Err_EthIfPhysCtrlRxMainFunctionPeriod_OutOfRange1</srcid><srcstatus/><internalId>1840</internalId></linkedfrom><linkedfrom><srcid>EthIf_GenTest02002_Err_EthIfPhysCtrlRxMainFunctionPeriod_OutOfRange2</srcid><srcstatus/><internalId>1841</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1189</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfMaxSwtPorts</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>9040</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if total number of switch ports
        exceeds value of parameter EthIfMaxSwtPorts
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest03010_Err_EthIfMaxSwtPorts_Exceeded</srcid><srcstatus/><internalId>1874</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1190</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfSwitchPortGroupIdx.ZeroBased</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>9060</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if not all EthIfSwitchPortGroupIdx are zero based.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest03002_Err_EthIfSwitchPortGroupIdx_NotZeroBased</srcid><srcstatus/><internalId>1866</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1191</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfSwitchPortGroupIdx.Consecutive</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>9079</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if not all EthIfSwitchPortGroupIdx are consecutive.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest03003_Err_EthIfSwitchPortGroupIdx_NotConsecutive</srcid><srcstatus/><internalId>1867</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1192</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfSwitchIdx.ZeroBased</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>9098</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if not all EthIfSwitchIdx are zero based.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest03004_Err_EthIfSwitchIdx_NotZeroBased</srcid><srcstatus/><internalId>1868</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1193</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfSwitchIdx.Consecutive</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>9117</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if not all EthIfSwitchIdx are consecutive.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest03005_Err_EthIfSwitchIdx_NotConsecutive</srcid><srcstatus/><internalId>1869</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1194</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfMaxSwtPortGroups</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>9136</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if total number of switch ports groups
        exceeds the value of parameter EthIfMaxSwtPortGroups.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest03006_Err_EthIfMaxSwtPortGroups_Exceeded</srcid><srcstatus/><internalId>1870</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1195</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.Trcv.PortGroup.InvalidReference</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>9156</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if a single EthIfController references both
        Ethernet transceived and port group.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest03007_Err_Trcv_PortGroup_InvalidReference</srcid><srcstatus/><internalId>1871</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1196</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfSwitchRefOrPortGroupRef.InvalidReference</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>9176</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if EthIfSwitchRefOrPortGroupRef is enabled
        but does not reference a valid port group or switch.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest03008_Err_EthIfSwitchRefOrPortGroupRef_InvalidReference</srcid><srcstatus/><internalId>1872</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1197</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.PortGroupRefByIfCtrl.PortSemanticsNotSet</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>9196</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if port group referenced by EthIf controller
        does not have EthIfSwitchPortGroupRefSemantics set.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest03009_Err_PortGroupRefByIfCtrl_PortSemanticsNotSet</srcid><srcstatus/><internalId>1873</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1198</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.PortsInPortGroup.Unique</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>9216</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if ports in port group are duplicated.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest03001_Err_PortsInPortGroup_Unique</srcid><srcstatus/><internalId>1865</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1199</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfSwitchingPortGroupSupport</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>9235</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message reportring that when switching of port groups
        feature is enabled and at least one EthIfSwitchPortGroup or EthIfSwitch must be defined.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest01018_Err_EthIfSwitchingPortGroupSupport</srcid><srcstatus/><internalId>1831</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1200</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfSwitchPortGroup.EthIfPortRef.Invalid</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>9255</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if EthIfPortRef contains invalid reference.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest03011_Err_EthIfSwitchPortGroup_EthIfPortRef_Invalid</srcid><srcstatus/><internalId>1875</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1201</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfSwitchPortGroup.EthIfPortRef.SwitchUndefined</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>9274</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message for a port referenced in a port group,
        that does not have switch defined in EthIfSwitch container.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest03012_Err_EthIfSwitchPortGroup_EthIfPortRef_SwitchUndefined</srcid><srcstatus/><internalId>1876</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1202</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfSupportEthAPI.EthCompatible</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>9294</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if Eth Controller version is not 4.3.0,
        but EthIfSupportEthAPI is set to ASR430 or ASR430_EB.
      </description>
      <comment>
        This requirement is tested manually since generic test would require an older
        version of Eth config stub which is currently not available.
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/EthIf_Extension.xdm.m4_367</srcid><srcstatus/><internalId>1098</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1203</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfSwitch.GetBufferLevelApiSupport</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>9318</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if config parameter EthIfGetBufferLevelApi
        is set, but related config parameter in EthSwt - EthSwtGetBufferLevelApi is not set.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest03013_Err_EthIfGetBufferLevelApi_EthSwtGetBufferLevelApi_False</srcid><srcstatus/><internalId>1877</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1204</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfSwitch.GetArlTableApiSupport</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>9338</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if config parameter EthIfGetArlTableApi is set,
        but related config parameter in EthSwt - EthSwtGetArlTableApi is not set.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest03014_Err_EthIfGetArlTableApi_EthSwtGetArlTableApi_False</srcid><srcstatus/><internalId>1878</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1205</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfSwitch.GetCounterValuesApiSupport</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>9358</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if config parameter EthIfSwtGetCounterValuesApi
        is set, but related config parameter in EthSwt - EthSwtGetDropCountApi is not set.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest03015_Err_EthIfSwtGetCounterValuesApi_EthSwtGetDropCountApi_False</srcid><srcstatus/><internalId>1879</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1206</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfSwitch.StoreConfigurationApiSupport</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>9378</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if config parameter EthIfStoreConfigurationApi is
        set, but related config parameter in EthSwt - EthSwtStoreConfigurationApi is not set.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest03016_Err_EthIfStoreConfigurationApi_EthSwtStoreConfigurationApi_False</srcid><srcstatus/><internalId>1880</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1207</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfSwitch.ResetConfigurationApiSupport</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>9398</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if config parameter EthIfResetConfigurationApi is
        set, but related config parameter in EthSwt - EthSwtResetConfigurationApi is not set.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest03017_Err_EthIfResetConfigurationApi_EthSwtResetConfigurationApi_False</srcid><srcstatus/><internalId>1881</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1208</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.SetModeTimeout.NotMultipleValue</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>9418</sourceline>
      <version>1</version>
      <description>
        A warning shall be reported if configuration parameter EthIfSetModeTimeout is enabled and
        set to a value which is not a multiple of the configured EthIfMainFunctionPeriod.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest01016_War_SetModeTimeout_NotDivisible_ByMF</srcid><srcstatus/><internalId>1829</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SetModeTimeout_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>256</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1209</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.SetModeTimeout.MaxValue</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>9444</sourceline>
      <version>1</version>
      <description>
        A warning shall be reported if a configuration parameter EthIfSetModeTimeout is enabled and
        the result of the calculation (EthIfSetModeTimeout/EthIfMainFunctionPeriod) is greater than
        65535.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest01017_War_SetModeTimeout_MaxValue</srcid><srcstatus/><internalId>1830</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SetModeTimeout_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>256</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1210</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfAsyncEthTrcvModeSupport</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>9471</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message reportring that when async EthTrcv support is
        enabled Eth Trcv support i.e. flag EthIfTrcvSupportEnable must be enabled as well.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest01019_Err_EthIfAsyncEthTrcvModeSupport</srcid><srcstatus/><internalId>1832</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.AsyncHandling</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1120</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1211</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfEthControllerBswmdImplementationRefs.Valid</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>9497</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if EthIfEthControllerBswmdImplementationRefs does
        not contain a valid reference.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/EthIf_EBParameters.xdm.m4_887</srcid><srcstatus/><internalId>1084</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1212</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfEthControllerBswmdImplementationRefs.Unique</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>9517</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if EthIfEthControllerBswmdImplementationRefs is not
        unique.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest04001_Err_EthIfEthControllerBswmdImplementationRefs_NotUnique</srcid><srcstatus/><internalId>1882</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1213</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfEthControllerBswmdImplementationRefs.WrongASRVers</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>9537</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if config parameter EthIfSupportEthAPI is set to
        ASR version below ASR430 when EthIfEthControllerBswmdImplementationRefs is used.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest04003_Err_BswmdImplementationRefs_WrongASRVers</srcid><srcstatus/><internalId>1884</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1214</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfEthControllerBswmdImplementationRefs.InitCtrlTrcvSet</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>9557</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if config parameter
        EthIfInitControllersTransceivers is set when EthIfEthControllerBswmdImplementationRefs is used.
      </description>
      <comment>
        Rationale:
        APIs Eth_ControllerInit and EthTrcv_TransceiverInit which are enabled with this config
        parameter are not available in ASR4.3.0.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest04004_Err_BswmdImplementationRefs_InitCtrlTrcvSet</srcid><srcstatus/><internalId>1885</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1215</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfEthTrcvBswmdImplementationRefs.Valid</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>9582</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if EthIfEthTrcvBswmdImplementationRefs does
        not contain a valid reference.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/EthIf_EBParameters.xdm.m4_948</srcid><srcstatus/><internalId>1088</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1216</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfEthTrcvBswmdImplementationRefs.Unique</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>9602</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if EthIfEthTrcvBswmdImplementationRefs is not
        unique.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest04002_Err_EthIfEthTrcvBswmdImplementationRefs_NotUnique</srcid><srcstatus/><internalId>1883</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1217</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfEthTrcvBswmdImplementationRefs.WrongASRVers</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>9622</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if config parameter EthIfSupportEthAPI is set to
        ASR version below ASR430 when EthIfEthTrcvBswmdImplementationRefs is used.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest04003_Err_BswmdImplementationRefs_WrongASRVers</srcid><srcstatus/><internalId>1884</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1218</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfEthTrcvBswmdImplementationRefs.InitCtrlTrcvSet</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>9642</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if config parameter
        EthIfInitControllersTransceivers is set when EthIfEthTrcvBswmdImplementationRefs is used.
      </description>
      <comment>
        Rationale:
        APIs Eth_ControllerInit and EthTrcv_TransceiverInit which are enabled with this config
        parameter are not available in ASR4.3.0.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest04004_Err_BswmdImplementationRefs_InitCtrlTrcvSet</srcid><srcstatus/><internalId>1885</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1219</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfEthSwtBswmdImplementationRefs.Valid</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>9667</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if EthIfEthSwtBswmdImplementationRefs does
        not contain a valid reference.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/EthIf_EBParameters.xdm.m4_1008</srcid><srcstatus/><internalId>1092</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1220</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfEthSwtBswmdImplementationRefs.WrongASRVers</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>9687</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if config parameter EthIfSupportEthAPI is set to
        ASR version below ASR430 when EthIfEthSwtBswmdImplementationRefs is used.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest04003_Err_BswmdImplementationRefs_WrongASRVers</srcid><srcstatus/><internalId>1884</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1221</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfFrameOwnerConfig.EthIfRxIndicationConfig.NumberOfElementsMatch</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>9707</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if the number of elements in 
        EthIfFrameOwnerConfig and EthIfRxIndicationConfig do not match.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest01025_Err_EthIfRxInd_NumberOfElements1</srcid><srcstatus/><internalId>1838</internalId></linkedfrom><linkedfrom><srcid>EthIf_GenTest01026_Err_EthIfRxInd_NumberOfElements2</srcid><srcstatus/><internalId>1839</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1222</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfSecurityEventRefs.Added</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>9727</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if EthIfEnableSecurityEventReporting is enabled,
        but no EthIfSecurityEventRefs are defined.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest01024_Err_EthIfSecurityEventRefs_Added</srcid><srcstatus/><internalId>1837</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func020.SecurityEventReporting</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1127</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1223</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfSecurityEventRefs.Valid</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>9747</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if a reference contained in EthIfSecurityEventRefs
        container is not valid.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest01023_Err_EthIfSecurityEventRefs_Invalid</srcid><srcstatus/><internalId>1836</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func020.SecurityEventReporting</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1127</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1224</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfSecurityEventRefs.Unique</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>9767</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if a reference contained in EthIfSecurityEventRefs
        is not unique.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest01020_Err_EthIfSecurityEventRefs_Not_Unique_1</srcid><srcstatus/><internalId>1833</internalId></linkedfrom><linkedfrom><srcid>EthIf_GenTest01021_Err_EthIfSecurityEventRefs_Not_Unique_2</srcid><srcstatus/><internalId>1834</internalId></linkedfrom><linkedfrom><srcid>EthIf_GenTest01022_Err_EthIfSecurityEventRefs_Not_Unique_3</srcid><srcstatus/><internalId>1835</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func020.SecurityEventReporting</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1127</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1225</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfQualifiedUnexpectedLinkDownTime.PassiveSlave</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>9787</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if EthIfQualifiedUnexpectedLinkDownTime is enabled
        on one of the EthIf transceivers and referenced EthTrcv is not acting as passive slave,
        EthTrcvActAsSlavePassiveEnabled is set to FALSE.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest05001_Err_EthIfQualifiedUnexpectedLinkDownTime_PassiveSlave</srcid><srcstatus/><internalId>1886</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1226</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfQualifiedUnexpectedLinkDownTime.StatePeriod</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>9802</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if EthIfQualifiedUnexpectedLinkDownTime is enabled
        on one of the EthIf transceivers and EthIfMainFunctionStatePeriod is not available.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest05002_Err_EthIfQualifiedUnexpectedLinkDownTime_StatePeriod</srcid><srcstatus/><internalId>1887</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1227</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfQualifiedUnexpectedLinkDownTime.WakeupSupport</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>9816</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if EthIfQualifiedUnexpectedLinkDownTime is enabled
        on one of the EthIf transceivers and EthIfWakeupSleepOnDatalineSupportEnabled is disabled.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest05003_Err_EthIfQualifiedUnexpectedLinkDownTime_WakeupSupport</srcid><srcstatus/><internalId>1888</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1228</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfQualifiedUnexpectedLinkDownTime.StatePeriodMultiple</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>9830</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if EthIfQualifiedUnexpectedLinkDownTime is enabled
        on one of the EthIf transceivers and the value is not multiple of EthIfMainFunctionStatePeriod.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest05004_Err_EthIfQualifiedUnexpectedLinkDownTime_StatePeriodMultiple</srcid><srcstatus/><internalId>1889</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1229</internalId></specobject>
    <specobject>
      <id>EthIf.EB.XdmCheck.EthIfQualifiedUnexpectedLinkDownTime.Range</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/doc/project/design/pdf/EthIf_Design-profiled.xml</sourcefile>
      <sourceline>9844</sourceline>
      <version>1</version>
      <description>
        The generator shall raise an error message if EthIfQualifiedUnexpectedLinkDownTime is enabled
        on one of the EthIf transceivers and the value is neither Infinity nor in the range between 0 and 65534.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EthIf_GenTest05005_Err_EthIfQualifiedUnexpectedLinkDownTime_Range</srcid><srcstatus/><internalId>1890</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1230</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_EthIf_DBGINST_001</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/build/reqm/common_req/EthIf_DbgInst_Trace_APIs.c</sourcefile>
      <sourceline>40</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
   Test Dbg
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
  VP: Successful compilation test.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.DBGINST001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>962</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.DBGINST002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>963</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.DBGINST003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>964</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.DBGINST004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>965</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.DBGINST005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>966</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1231</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EthIf_Test_IsValidConfig</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/build/reqm/common_req/EthIf_PbcfgM_Main_Impl_Test.c</sourcefile>
      <sourceline>71</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the function EthIf_IsValidConfig() is implemented as specified.
  
Test Object: 
    EthIf_IsValidConfig()
  
Test Precondition: 
    The EthIf module is not initialized.
  
Test Execution: 
    01: Call the function EthIf_IsValidConfig() with an NULL_PTR.
    02: VP:
        The function must have returned with E_NOT_OK.
    03: Create an invalid configuration regarding the endianness and alignment.
    04: Call the function EthIf_IsValidConfig() with this invalid configuration.
    05: VP(EthIf.EB.PBCFGM106):
        The function must have returned with E_NOT_OK.
    The following 3 steps are only executed if the module has a link-time configuration:
        06: Create an invalid configuration regarding the link time configuration.
        07: Call the function EthIf_IsValidConfig() with this invalid configuration.
        08: VP(EthIf.EB.PBCFGM105):
                The function must have returned with E_NOT_OK.
    09: Create an invalid configuration regarding the compile time configuration.
    10: Call the function EthIf_IsValidConfig() with this invalid configuration.
    11: VP(EthIf.EB.PBCFGM104):
        The function must have returned with E_NOT_OK.
    12: Create an invalid configuration regarding the published information configuration.
    13: Call the function EthIf_IsValidConfig() with this invalid configuration.
    14: VP(EthIf.EB.PBCFGM104_1):
        The function must have returned with E_NOT_OK.
    15: Call the function EthIf_IsValidConfig() with a valid configuration.
    16: VP:
        The function must have returned with E_OK.
    17: VP(EthIf.EB.PBCFGM107):
        Check if ETHIF_PBCFGM_SUPPORT_ENABLED is set to STD_ON.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.PBCFGM101</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>967</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.PBCFGM102</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>968</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.PBCFGM104</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>969</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.PBCFGM104_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>970</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.PBCFGM105</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>971</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.PBCFGM106</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>972</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.PBCFGM107</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>973</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1232</internalId></specobject>
    <specobject>
      <id>EthIf_Test_VerifyInitWithPcfgM</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/build/reqm/common_req/EthIf_PbcfgM_Main_Impl_Test.c</sourcefile>
      <sourceline>225</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the EthIf can be initialized via the PbcfgM.
  
Test Object: 
    EthIf_IsValidConfig()
  
Test Precondition: 
    The EthIf module must not have been initialized.
  
Test Execution: 
    01: Create an invalid configuration regarding the endianness and alignment.
    02: Call the function EthIf_Init() with this invalid configuration.
    03: VP:
        A Det call must have been performed correctly.
    04: Create an invalid configuration regarding the compile time configuration.
    05: Call the function EthIf_Init() with this invalid configuration.
    06: VP:
        A Det call must have been performed correctly.
    The following 3 steps are only executed if the module has a link-time configuration:
        07: Create an invalid configuration regarding the link time configuration.
        08: Call the function EthIf_Init() with this invalid configuration.
        09: VP:
            A Det call must have been performed correctly.
    10: Create an invalid configuration regarding the published information configuration.
    11: Call the function EthIf_Init() with this invalid configuration.
    12: VP:
        A Det call must have been performed correctly.
    13: Initialize the PbcfgM_GetConfig() stub that way that it can return a valid function.
    14: Call the function EthIf_Init() with a null pointer.
    15: VP:
        The function PbcfgM_GetConfig() must have been called once.
    16: VP:
        No Det call must have been performed.
    17: VP:
        The module internal configuration pointer EthIf_RootPtr must equal
        the pointer supplied to the initialization function
    18: PbcfgM_GetConfig shall return E_NOT_OK.
        set the configuration pointer which is returned to NULL_PTR
    19: Call EthIf_Init with NULL_PTR.
    20: VP(EthIf.EB.PBCFGM110):
        Check if Det error is reported.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.PBCFGM110</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>975</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1233</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EthIf_Test_PBcfgM_Off</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/build/reqm/common_req/EthIf_PbcfgM_Off_Compile_Test.c</sourcefile>
      <sourceline>26</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
      Verify that if PbcfgM support is disabled then EthIf_PBCfg.c shall define
      TS_PB_CFG_LAYOUT_TYPE and TS_PB_CFG_NAME.
      ETHIF_PBCFGM_SUPPORT_ENABLED shall be set to STD_OFF.
      ETHIF_RELOCATABLE_CFG_ENABLE shall be set to STD_OFF.
    
Test Object: None.
Test Precondition: 
      - PbcfgM configuration does not refer to module EthIf (or no config exists)
      - Include EthIf_PBcfg.c only for step 01 and 02.
      - Include EthIf_Cfg.h for step 03.
    
Test Execution: 
        01: VP(EthIf.EB.PbcfgM_General_6):
            Check that symbols TS_PB_CFG_LAYOUT_TYPE and TS_PB_CFG_NAME exists.
        02: VP(EthIf.EB.PbcfgM_General_6):
            Check that symbols TS_PB_CFG_LAYOUT_TYPE and TS_PB_CFG_NAME has the value
            EthIf_ConfigLayoutType and ETHIF_CONFIG_NAME respectively.
        03: VP (EthIf.EB.PBCFGM107):
            Verify that ETHIF_PBCFGM_SUPPORT_ENABLED is set to STD_OFF.
        04: VP(EthIf.EB.PBCFGM108, EthIf.EB.RelocatablePBCfg):
            ETHIF_RELOCATABLE_CFG_ENABLE shall be STD_OFF
    
Test Input: 
    
Test Output: 
    &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.PbcfgM_General_6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>978</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.PBCFGM107</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>973</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.PBCFGM108</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>974</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.RelocatablePBCfg</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>283</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1234</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EthIf_Test_PBcfgM_On</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/build/reqm/common_req/EthIf_PbcfgM_On_Compile_Test.c</sourcefile>
      <sourceline>24</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
      1.)
      Verify that ETHIF_RELOCATABLE_CFG_ENABLE is defined
      in the header file EthIf_Cfg.h.
      2.)
      Verify that if PbcfgM support is enabled then EthIf_PBCfg.c shall NOT define
      TS_PB_CFG_LAYOUT_TYPE and TS_PB_CFG_NAME.
    
Test Object: None.
Test Precondition: 
        - ETHIF_PBCFGM_SUPPORT_ENABLED = STD_ON
    
Test Execution: 
        ------------------------ 1.) ---------------------
        01: VP (EthIf.EB.PbcfgM_General_3,
                EthIf.EB.PBCFGM108,
                EthIf.EB.RelocatablePBCfg):
            Verify that ETHIF_RELOCATABLE_CFG_ENABLE is set to STD_ON.
        ------------------------ 2.) ---------------------
        02: Include EthIf_PBcfg.c.
        03: VP(EthIf.EB.PbcfgM_General_6):
            Check that symbols TS_PB_CFG_LAYOUT_TYPE and TS_PB_CFG_NAME exist.
    
Test Input: 
        None.
    
Test Output: 
        Binary file.
    &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.PbcfgM_General_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>977</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.PbcfgM_General_6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>978</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.PBCFGM108</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>974</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.RelocatablePBCfg</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>283</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1235</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_EthIf_VerifyCodeStub</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/build/reqm/common_req/EthIf_VerifyStub_testspec.h</sourcefile>
      <sourceline>7</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that the code stub of the module is consistent with the
    implementation.
  
Test Object: 
    Relocatable post-build configuration macros generation.
  
Test Precondition: 
    Permutation [VerifyStub == true]:
      - Unit test contains its own code stub
      - Module is excluded from generation and compilation
    Permutation [VerifyStub == false]:
      - unit test excludes its own code stub
  
Test Execution: 
    01: Invoke all module APIs
    02: VP(EthIf.EB.Interface.Consistency):
        Unit test compiles (implicitly tested)
  
Test Input: 
  
Test Output: 
    Test is correctly generated and compiled.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Interface.Consistency</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>982</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1236</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EthIf_CompileTest_01</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Compile/IN/EthIf_ComTest_01/source/application/test_config.h</sourcefile>
      <sourceline>10</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Test to compile the module for the following configuration
      - All features enabled / optimizations (maximum pre-compile-setting)
      - EthIfGlobalTimeSupport = FALSE
      - EthIfWakeUpSupport = FALSE
      - EthIfGetTransceiverWakeupModeApi = FALSE.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: None.
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00024</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>421</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00034</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>423</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00039</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>427</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00061</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>432</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00067</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>437</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00082</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>448</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00113</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>471</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00132</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>493</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00139</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>498</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.ETHIF085</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>141</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.VLAN_Support</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>164</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00085</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>449</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00075</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>443</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00091</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>453</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00158</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>519</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00164</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>523</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00170</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>528</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00176</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>533</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.EthIfSupportEthAPI</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>244</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00231</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>556</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00232</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>557</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00237</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>562</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00243</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>568</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00248</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>573</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00316</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>658</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.DevAuthExtension.ApiSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>284</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.RetransmitExtension.ApiSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>297</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.GetTrcvSignalQuality.Configurable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>271</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.GetSwitchPortSignalQuality.Configurable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>272</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.ClearTrcvSignalQuality.Configurable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>273</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.ClearSwitchPortSignalQuality.Configurable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>274</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1237</internalId></specobject>
    <specobject>
      <id>EthIf_CompileTest_SetModeTimeout</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Compile/IN/EthIf_ComTest_01/source/application/test_config.h</sourcefile>
      <sourceline>76</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    It shall be verified that macro ETHIF_SET_MODE_TIMEOUT is limited to the maximum value.
  
Test Object: 
    ModeRequestRepetitionTime
  
Test Precondition: 
    - EthIfSetModeTimeout = 660
    - EthIfMainFunctionPeriod = 0,01
  
Test Execution: 
    VP(EthIf.EB.SetModeTimeout.Maximum): Verify that ETHIF_SET_MODE_TIMEOUT is limited
    to 65535 even though EthIfSetModeTimeout/EthIfMainFunctionPeriod = 66000 would be
    limited to 65536 in normal case.
  
Test Input: None.
Test Output: 
    The module compiles without any error.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SetModeTimeout.Maximum</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>257</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1238</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EthIf_ComTest02</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Compile/IN/EthIf_ComTest_02/source/application/EthIf_ComTest02.c</sourcefile>
      <sourceline>39</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Test to compile the module for the following configuration
      - VLAN enabled, global time sync enabled, all other features enabled / optimizations disabled
      - EthIfGlobalTimeSupport = TRUE.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: None.
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00024</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>421</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00034</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>423</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00039</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>427</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00061</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>432</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00067</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>437</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00082</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>448</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.ETHIF085</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>141</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00154</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>515</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00160</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>520</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00166</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>524</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00172</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>529</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00158</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>519</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00164</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>523</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00170</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>528</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00176</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>533</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00097</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>457</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00075</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>443</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00132</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>493</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00139</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>498</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00085</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>449</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.ETHIF091</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00091</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>453</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00113</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>471</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.EthIfSupportEthAPI</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>244</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00231</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>556</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00232</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>557</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00233</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>558</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00238</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>563</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00244</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>569</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91016</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>735</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91018</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>737</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>728</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91014</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>734</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91020</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>738</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1239</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EthIf_CompileTest_03</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Compile/IN/EthIf_ComTest_03/source/application/Appl.c</sourcefile>
      <sourceline>48</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Test to compile the module for the following configuration
      - VLAN disabled, all other features enabled / optimizations enabled
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: None.
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00024</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>421</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00034</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>423</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00039</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>427</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00061</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>432</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00067</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>437</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00082</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>448</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.ETHIF085</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>141</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.VLAN_Support</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>164</internalId></provcov>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00007</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>393</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.EthIfSupportEthAPI</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>244</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00231</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>556</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00232</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>557</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1240</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EthIf_ComTest04</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Compile/IN/EthIf_ComTest_04/source/application/Appl.c</sourcefile>
      <sourceline>52</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Test to compile the module for the following configuration
      - VLAN disabled, all other features disabled / optimizations enabled
      - EthIfTrcvSupportEnable = TRUE.
      - EthIfMiiApiEnable = TRUE.
      - EthSwt APIs are disabled
      - EthIfSupportEthAPI = ASR422
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: None.
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00024</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>421</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00034</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>423</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00039</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>427</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00061</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>432</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00067</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>437</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00082</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>448</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.ETHIF085</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>141</internalId></provcov>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00007</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>393</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.ReadMii.ApiSignature</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>201</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.WriteMii.ApiSignature</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>203</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.ApiSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>200</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.EthIfSupportEthAPI</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>244</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91058</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>777</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91060</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>779</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00231</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>556</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00232</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>557</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1241</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EthIf_CompTest_05_ServiceId_ErrorId</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Compile/IN/EthIf_ComTest_05_ServiceId_ErrorId/source/application/test_config.h</sourcefile>
      <sourceline>10</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Test to compile the module for the following configuration
      - VLAN disabled, all other features disabled / optimizations enabled
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: None.
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00017.ValueCheck.ETHIF_E_INV_CTRL_IDX</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>86</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00017.ValueCheck.ETHIF_E_INV_TRCV_IDX</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>87</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00017.ValueCheck.ETHIF_E_INV_PORT_GROUP_IDX</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>88</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00017.ValueCheck.ETHIF_E_NOT_INITIALIZED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>89</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00017.ValueCheck.ETHIF_E_PARAM_POINTER</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>90</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00017.ValueCheck.ETHIF_E_INV_PARAM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>91</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00017.ValueCheck.ETHIF_E_INIT_FAILED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00017.ValueCheck.ETHIF_E_INV_SWT_IDX</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>137</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00024.ServiceId</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>93</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00034.ServiceId</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>95</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00039.ServiceId</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>96</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00061.ServiceId</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>100</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00132.ServiceId</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>101</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00139.ServiceId</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>102</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00067.ServiceId</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00075.ServiceId</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>124</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00082.ServiceId</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>125</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00085.ServiceId</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>126</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00091.ServiceId</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>127</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00097.ServiceId</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>128</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00113.ServiceId</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>135</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.ValueCheck.ETHIF_E_HW_NOT_INITIALIZED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>165</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00154.ServiceId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>108</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00160.ServiceId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>110</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00166.ServiceId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>112</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00172.ServiceId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>114</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.ReadMii.ServiceId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>202</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.WriteMii.ServiceId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>204</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR42.EthIf_SwtGetCounterValues.ServiceId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>38</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00190.ServiceId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>103</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00196.ServiceId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>104</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00202.ServiceId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00214.ServiceId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>106</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00219.ServiceId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>107</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91056</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>775</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_91016.ServiceId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>116</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_91018.ServiceId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>117</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_91005.ServiceId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>119</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_91014.ServiceId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_91020.ServiceId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>122</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00231</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>556</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00232</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>557</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00233.ServiceId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>97</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00238.ServiceId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>98</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00244.ServiceId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>99</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.DevAuthExtension.EnableRelatedEthIfCtrls.ServiceId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>286</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.DevAuthExtension.DisableRelatedEthIfCtrls.ServiceId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>288</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.RetransmitExtension.Retransmit.ServiceId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>299</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91006.ServiceId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>948</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1242</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EthIf_ComTest_06_Swt_support</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Compile/IN/EthIf_ComTest_06_Swt_support/source/application/Appl.c</sourcefile>
      <sourceline>41</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Test to compile the module for the following configuration
      - One EthSwt element configured and all SwtAPIs enabled
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: None.
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00007</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>393</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00190</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>534</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00196</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>539</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00192</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>536</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00198</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>541</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00202</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>60</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00204</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>62</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR42.EthIf_SwtGetCounterValues</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>33</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR42.EthIf_SwtGetCounterValues.Api_parameter</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>35</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00214</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>544</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00216</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>546</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00219</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>548</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00221</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>550</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1243</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EthIf_ComTest_07_HandleId_Gen</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Compile/IN/EthIf_ComTest_07_HandleId_Gen/source/application/Application.c</sourcefile>
      <sourceline>41</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies the correct generate process.
  
Test Object: 
  
Test Precondition: 
  
Test Execution: 
        Ts5 build environment steps:
        The handle ID wizard is started by command line via the Merged_Makefile.mak.
        The module configuration generator provides the missing generated handle ids, thus
        enabling successful module generation.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.HandleIDWizard.EthIfTransceiverIdx</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>252</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.HandleIDWizard.EthIfPhysControllerIdx</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>253</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.HandleIDWizard.EthIfSwitchIdx</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>254</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.HandleIDWizard.EthIfSwitchPortGroupIdx</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>255</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1244</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EthIf_ComTest_08_SwcdCheck_CheckExclusiveArea</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Compile/IN/EthIf_ComTest_08_SwcdCheck/source/application/EthIf_ComTest_08_SwcdCheck.c</sourcefile>
      <sourceline>32</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test shall prove that the EthIf generates exclusive areas in EthIf_Bswmd.arxml file.
  
Test Object: 
  
Test Precondition: 
  
Test Execution: 
    Compare the generated files EthIf_Bswmd.arxml with the one from reference folder.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SchedulerExclusiveArea</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>232</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1245</internalId></specobject>
    <specobject>
      <id>EthIf_ComTest_08_SwcdCheck_CheckScheduleMainFuctionState</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Compile/IN/EthIf_ComTest_08_SwcdCheck/source/application/EthIf_ComTest_08_SwcdCheck.c</sourcefile>
      <sourceline>61</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test shall prove that the EthIf generates schedule information of EthIf_MainFunctionState()
    in EthIf_Bswmd.arxml file if EthIfMainFunctionStatePeriod is enabled.
  
Test Object: 
  
Test Precondition: 
    EthIfMainFunctionStatePeriod is enabled
  
Test Execution: 
    Compare the generated files EthIf_Bswmd.arxml with the one from reference folder.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.ScheduleMainFuctionState</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>233</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1246</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EthIf_ComTest_10_TC10_support</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Compile/IN/EthIf_ComTest_10_TC10/source/application/Appl.c</sourcefile>
      <sourceline>42</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Test to compile the module for the following configuration
      - One EthTrcv element configured
      - Support for wakeup and sleep on data line enabled per permutation
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: None.
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.EthIfWakeupSleepOnDatalineSupportEnabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>373</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1247</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EthIf_ComTest_NoPBCfg</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Compile/IN/EthIf_ComTest_NoPBCfg/source/application/EthIf_ComTest_NoPBCfg.c</sourcefile>
      <sourceline>20</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test shall prove that that EthIf can compile without any post build information.
  
Test Object: 
    Compile test
  
Test Precondition: 
    * Set TS_ETHIF_COMPILE_WITH_POSTBUILD to FALSE in the merged make file to prevent the
      compilation of the post build C file.
    * The merged make file holds a rule which removes all post build files after generation.
  
Test Execution: 
    The test run is successful when the EthIf compiles under sticking to the precondition.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.PostBuild_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>976</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1248</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EthIf_CompileTest_SchM</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Compile/IN/EthIf_ComTest_SchM/source/application/test_config.h</sourcefile>
      <sourceline>10</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
   This test checks that the EthIf module's generator generates a
   syntactically and semantically valid basic software module
   description (BSWMD) when the generator mode "generate_swcd" is
   invoked. It further tests that the SchM exclusive area API is
   correctly generated by the RTE generator based on the EthIf module's
   generated BSWMD.

Test Object: 

Test Precondition: 

Test Execution: 
  Ts5 build environment steps:
    The module configuration generator produces the BSWMD containing
    the information on the required exclusive areas.  This information
    is then used by the RTE generator to create the required SchM API
    for these exclusive areas. This implicitly verifies that the BSWMD
    is syntactically and semantically correct.  EthIf's static code
    makes use of this API (and the respective #defines) thus causing
    compile/link errors if the BSWMD does not contain the correct
    information.

Test Input: 
  Usage of a common ASR configuration having all adjacent ASR modules
  configured.

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00024</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>421</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00034</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>423</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00039</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>427</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00061</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>432</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00067</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>437</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00082</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>448</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.ETHIF085</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>141</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1249</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EthIf_ConTest01000_SetPhysAddr_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>83</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_SetPhysAddr() is called when the module is not initialized,
    ETHIF_E_NOT_INITIALIZED will be reported to DET.
  
Test Object: 
    EthIf_SetPhysAddr()
  
Test Precondition: 
  
Test Execution: 
    01: Call EthIf_SetPhysAddr() in UNINIT state.
    02: VP(EthIf.ASR43.SWS_EthIf_00135): Verify that DET was called with ETHIF_E_NOT_INITIALIZED.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00135</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>46</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1250</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01001_UpdatePhysAddrFilter_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>131</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_UpdatePhysAddrFilter() is called when the module is not
    initialized, ETHIF_E_NOT_INITIALIZED will be reported to DET.
  
Test Object: 
    EthIf_UpdatePhysAddrFilter()
  
Test Precondition: 
  
Test Execution: 
    01: Call EthIf_UpdatePhysAddrFilter() in UNINIT state.
    02: VP(EthIf.ASR43.SWS_EthIf_00141): Verify that DET was called with ETHIF_E_NOT_INITIALIZED.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00141</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>47</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1251</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01002_Cbk_RxIndication_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>179</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_Cbk_RxIndication() is called when the module is not
    initialized, ETHIF_E_NOT_INITIALIZED will be reported to DET.
  
Test Object: 
    EthIf_Cbk_RxIndication()
  
Test Precondition: 
  
Test Execution: 
    01: Call EthIf_Cbk_RxIndication() in UNINIT state.
    02: VP(ETHIF085_3a): Verify that DET was called with ETHIF_E_NOT_INITIALIZED.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.ETHIF085_3a</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>143</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1252</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01003_EthIf_RxIndication_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>227</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_RxIndication() is called in uninit state,
    ETHIF_E_NOT_INITIALIZED will be reported to DET.
  
Test Object: 
    EthIf_RxIndication().
  
Test Precondition: 
    EthIf uninitialized.
  
Test Execution: 
    01: Call EthIf_RxIndication() in uninit state.
    02: VP(): Verify that DET was called with ETHIF_E_NOT_INITIALIZED.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00086</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>44</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1253</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01004_EthIf_GetCurrentTime_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>283</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_GetCurrentTime() is called in uninit state,
    ETHIF_E_NOT_INITIALIZED will be reported to DET.
  
Test Object: 
    EthIf_GetCurrentTime().
  
Test Precondition: 
    EthIf uninitialized.
  
Test Execution: 
    01: Call EthIf_GetCurrentTime() in uninit state.
    02: VP(): Verify that DET was called with ETHIF_E_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00155</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>50</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1254</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01005_EthIf_EnableEgressTimeStamp_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>335</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_EnableEgressTimeStamp() is called in uninit state,
    ETHIF_E_NOT_INITIALIZED will be reported to DET.
  
Test Object: 
    EthIf_EnableEgressTimeStamp().
  
Test Precondition: 
    EthIf uninitialized.
  
Test Execution: 
    01: Call EthIf_EnableEgressTimeStamp() in uninit state.
    02: VP(): Verify that DET was called with ETHIF_E_NOT_INITIALIZED.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00161</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>52</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1255</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01006_EthIf_GetEgressTimeStamp_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>384</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_GetEgressTimeStamp() is called in uninit state,
    ETHIF_E_NOT_INITIALIZED will be reported to DET.
  
Test Object: 
    EthIf_GetEgressTimeStamp().
  
Test Precondition: 
    EthIf uninitialized.
  
Test Execution: 
    01: Call EthIf_GetEgressTimeStamp() in uninit state.
    02: VP(): Verify that DET was called with ETHIF_E_NOT_INITIALIZED.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00167</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>54</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1256</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01007_EthIf_GetIngressTimeStamp_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>436</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_GetIngressTimeStamp() is called in uninit state,
    ETHIF_E_NOT_INITIALIZED will be reported to DET.
  
Test Object: 
    EthIf_GetIngressTimeStamp().
  
Test Precondition: 
    EthIf uninitialized.
  
Test Execution: 
    01: Call EthIf_GetIngressTimeStamp() in uninit state.
    02: VP(): Verify that DET was called with ETHIF_E_NOT_INITIALIZED.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00173</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>56</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1257</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01009_1_EthIf_ReadMii_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>487</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_ReadMii() is called when the module is not initialized,
    ETHIF_E_NOT_INITIALIZED will be reported to DET.
  
Test Object: 
    EthIf_ReadMii()
  
Test Precondition: 
  
Test Execution: 
    01: Call EthIf_ReadMii() in UNINIT state.
    02: VP(EthIf.EB.MiiExtension.ReadMii.DetCheck.NotInit):
        Verify that DET was called with ETHIF_E_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.ReadMii.DetCheck.NotInit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>207</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1258</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01009_2_EthIf_WriteMii_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>541</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_WriteMii() is called when the module is not initialized,
    ETHIF_E_NOT_INITIALIZED will be reported to DET.
  
Test Object: 
    EthIf_WriteMii()
  
Test Precondition: 
  
Test Execution: 
    01: Call EthIf_WriteMii() in UNINIT state.
    02: VP(EthIf.EB.MIIExtension.WriteMii.DetCheck.NotInit):
        Verify that DET was called with ETHIF_E_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.WriteMii.DetCheck.NotInit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>208</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1259</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01072_SetControllerMode_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>596</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_SetControllerMode() is called when the module is not
    initialized, ETHIF_E_NOT_INITIALIZED will be reported to DET.
  
Test Object: 
    EthIf_SetControllerMode()
  
Test Precondition: 
  
Test Execution: 
    01: Call EthIf_SetControllerMode() in UNINIT state.
    02: VP(EthIf.ASR43.SWS_EthIf_00036):
        Verify that DET was called with ETHIF_E_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00036</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>40</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1260</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01073_GetControllerMode_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>649</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_GetControllerMode() is called when the module is not
    initialized, ETHIF_E_NOT_INITIALIZED will be reported to DET.
  
Test Object: 
    EthIf_GetControllerMode()
  
Test Precondition: 
  
Test Execution: 
    01: Call EthIf_GetControllerMode() in UNINIT state.
    02: VP(EthIf.ASR43.SWS_EthIf_00041):
        Verify that DET was called with ETHIF_E_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00041</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>41</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1261</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01080_GetPhysAddr_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>703</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_GetPhysAddr() is called when the module is not
    initialized, ETHIF_E_NOT_INITIALIZED will be reported to DET.
  
Test Object: 
    EthIf_GetPhysAddr()
  
Test Precondition: 
  
Test Execution: 
    01: Call EthIf_GetPhysAddr() in UNINIT state.
    02: VP(EthIf.ASR43.SWS_EthIf_00063):
        Verify that DET was called with ETHIF_E_NOT_INITIALIZED.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00063</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>42</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1262</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01081_TxConfirmation_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>755</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_TxConfirmation() is called when the module is not
    initialized, ETHIF_E_NOT_INITIALIZED will be reported to DET.
  
Test Object: 
    EthIf_TxConfirmation()
  
Test Precondition: 
  
Test Execution: 
    01: Call EthIf_TxConfirmation() in UNINIT state.
    02: VP(EthIf.ASR43.SWS_EthIf_00092):
        Verify that DET was called with ETHIF_E_NOT_INITIALIZED.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00092</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>45</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1263</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01082_EnableRelatedEthIfCtrls_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>807</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_EnableRelatedEthIfCtrls() is called when the module
    is not initialized, ETHIF_E_NOT_INITIALIZED will be reported to DET.
  
Test Object: 
    EthIf_EnableRelatedEthIfCtrls()
  
Test Precondition: 
  
Test Execution: 
    01: Call EthIf_EnableRelatedEthIfCtrls() in UNINIT state.
    02: VP(): Verify that DET was called with ETHIF_E_NOT_INITIALIZED.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.DevAuthExtension.EnableRelatedEthIfCtrls.DetCheck.NotInit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>291</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1264</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01083_DisableRelatedEthIfCtrls_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>858</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_DisableRelatedEthIfCtrls() is called when the module
    is not initialized, ETHIF_E_NOT_INITIALIZED will be reported to DET.
  
Test Object: 
    EthIf_DisableRelatedEthIfCtrls()
  
Test Precondition: 
  
Test Execution: 
    01: Call EthIf_DisableRelatedEthIfCtrls() in UNINIT state.
    02: VP(): Verify that DET was called with ETHIF_E_NOT_INITIALIZED.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.DevAuthExtension.DisableRelatedEthIfCtrls.DetCheck.NotInit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>292</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1265</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01010_InvalidCfgPtr</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>909</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_Init() is called with invalid CfgPrt, ETHIF_E_INIT_FAILED
    will be reported to DET.
  
Test Object: 
    EthIf_Init()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize module using an invalid CfgPtr(NULL_PTR).
    02: VP(EthIf.SWS_EthIf_00116): Verify that DET was called with ETHIF_E_INIT_FAILED.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00116</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>474</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1266</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01011_SetPhysAddr_InvalidCtrlIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>955</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_SetPhysAddr() is called with invalid CtrlIdx,
    ETHIF_E_INV_CTRL_IDX will be reported to DET.
  
Test Object: 
    EthIf_SetPhysAddr()
  
Test Precondition: 
    EthIf is initialized.
  
Test Execution: 
    01: Call EthIf_SetPhysAddr() using an invalid CtrlIdx.
    02: VP(EthIf.SWS_EthIf_00136): Verify that DET was called with ETHIF_E_INV_CTRL_IDX.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00136</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>496</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1267</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01012_1_EthIf_ReadMii_InvalidCtrlIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>1005</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_ReadMii() is called using an invalid CtrlIdx
    ETHIF_E_INV_CTRL_IDX will be reported to DET.
  
Test Object: 
    EthIf_ReadMii()
  
Test Precondition: None.
Test Execution: 
    01: Call EthIf_ReadMii() using invalid CtrlIdx.
    02: VP(EthIf.EB.MIIExtension.ReadMii.DetCheck.InvalidCtrlId):
        Verify that DET was called with ETHIF_E_INV_CTRL_IDX and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.ReadMii.DetCheck.InvalidCtrlId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>209</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1268</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01012_2_EthIf_WriteMii_InvalidCtrlIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>1062</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_WriteMii() is called using an invalid CtrlIdx
    ETHIF_E_INV_CTRL_IDX will be reported to DET.
  
Test Object: 
    EthIf_WriteMii()
  
Test Precondition: 
    EthIf is initialized.
  
Test Execution: 
    01: Call EthIf_WriteMii() using invalid CtrlIdx.
    02: VP(EthIf.EB.MIIExtension.WriteMii.DetCheck.InvalidCtrlIdx):
        Verify that DET was called with ETHIF_E_INV_CTRL_IDX and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.WriteMii.DetCheck.InvalidCtrlIdx</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>210</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1269</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01012_Cbk_RxIndication_InvalidCtrlIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>1119</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_Cbk_RxIndication() is called with invalid CtrlIdx,
    ETHIF_E_INV_CTRL_IDX will be reported to DET.
  
Test Object: 
    EthIf_Cbk_RxIndication()
  
Test Precondition: 
    EthIf is initialized.
  
Test Execution: 
    01: Call EthIf_Cbk_RxIndication() using an invalid CtrlIdx.
    02: VP(ETHIF085_3b): Verify that DET was called with ETHIF_E_INV_CTRL_IDX.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.ETHIF085_3b</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>144</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1270</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01013_1_Cbk_RxIndication_InvalidDataPtr</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>1170</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_Cbk_RxIndication() is called with invalid DataPtr,
    ETHIF_E_PARAM_POINTER will be reported to DET.
  
Test Object: 
    EthIf_Cbk_RxIndication()
  
Test Precondition: 
    EthIf is initialized.
  
Test Execution: 
    01: Call EthIf_Cbk_RxIndication() using an invalid DataPtr.
    02: VP(ETHIF085_3c): Verify that DET was called with ETHIF_E_PARAM_POINTER.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.ETHIF085_3c</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>145</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1271</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01013_2_Cbk_RxIndication_InvalidLenByte</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>1220</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_Cbk_RxIndication() is called with
    LenByte &lt; ETHIF_ETH_HEADER_LENGTH, ETHIF_E_INV_PARAM will be reported to DET.
  
Test Object: 
    EthIf_Cbk_RxIndication()
  
Test Precondition: 
    EthIf is initialized.
  
Test Execution: 
    01: Call EthIf_Cbk_RxIndication() with LenByte &lt; ETHIF_ETH_HEADER_LENGTH.
    02: VP(ETHIF085_3d): Verify that DET was called with ETHIF_E_INV_PARAM.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.ETHIF085_3d</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>146</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1272</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01014_UpdatePhysAddrFilter_InvalidCtrlIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>1271</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_UpdatePhysAddrFilter() is called using an invalid CtrlIdx
    ETHIF_E_INV_CTRL_IDX will be reported to DET.
  
Test Object: 
    EthIf_UpdatePhysAddrFilter()
  
Test Precondition: 
    EthIf initialized
  
Test Execution: 
    01: Call EthIf_UpdatePhysAddrFilter() using an invalid CtrlIdx.
    02: VP(EthIf.SWS_EthIf_00142): Verify that DET was called with ETHIF_E_INV_CTRL_IDX.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00142</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>501</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1273</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01015_UpdatePhysAddrFilter_InvPhysAddrPtr</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>1322</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_UpdatePhysAddrFilter() is called using an invalid PhysAddrPtr,
    ETHIF_E_PARAM_POINTER will be reported to DET.
  
Test Object: 
    EthIf_UpdatePhysAddrFilter()
  
Test Precondition: 
    EthIf initialized
  
Test Execution: 
    01: Call EthIf_UpdatePhysAddrFilter() using an invalid PhysAddrPtr.
    02: VP(EthIf.SWS_EthIf_00143): Verify that DET was called with ETHIF_E_PARAM_POINTER.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00143</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>502</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1274</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01016_SetPhysAddr_InvalidPhysAddrPtr</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>1371</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_SetPhysAddr() is called with invalid PhysAddrPtr invalid,
    ETHIF_E_PARAM_POINTER will be reported to DET.
  
Test Object: 
    EthIf_SetPhysAddr()
  
Test Precondition: 
    EthIf initialized
  
Test Execution: 
    01: Call EthIf_SetPhysAddr() using invalid PhysAddrPtr.
    02: VP(EthIf.SWS_EthIf_00137): Verify that DET was called with ETHIF_E_PARAM_POINTER.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00137</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>497</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1275</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01017_EthIf_ProvideTxBuffer_InvalidPriority</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>1420</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_SetPhysAddr() is called with invalid PhysAddrPtr invalid,
    ETHIF_E_PARAM_POINTER will be reported to DET.
  
Test Object: 
    EthIf_ProvideTxBuffer()
  
Test Precondition: 
    EthIf initialized
  
Test Execution: 
    01: Call EthIf_ProvideTxBuffer() using an invalid priority( &gt;=8U ).
    02: VP(SWS_EthIf_00073_2): Verify that EthIf_ProvideTxBuffer() returns BUFREQ_E_NOT_OK.
    03: VP(SWS_EthIf_00073_2): Verify that DET was called with ETHIF_E_INV_PARAM.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00073_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>139</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1276</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01018_EthIf_GetVlanId_InvalidPtr</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>1483</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_GetVlanId() is called with invalid VlanIdPtr,
    ETHIF_E_PARAM_POINTER will be reported to DET.
  
Test Object: 
    EthIf_GetVlanId()
  
Test Precondition: 
    EthIf is initialized.
  
Test Execution: 
    01: Call EthIf_GetVlanId() using an invalid VlanIdPtr.
    02: VP(): Verify that DET was called with ETHIF_E_PARAM_POINTER.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00303</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>647</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1277</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01022_SetControllerMode_InvalidCtrlMode</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>1533</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_SetControllerMode() is called using an invalid ModeType
    ETHIF_E_INV_PARAM will be reported to DET.
  
Test Object: 
    EthIf_SetControllerMode()
  
Test Precondition: 
    EthIf initialized.
    Controllers initialized.
  
Test Execution: 
    01: Call EthIf_SetControllerMode() using an invalid ModeType.
    02: VP(SetController_InvCtrlMode): Verify that EthIf_SetControllerMode() returns E_NOT_OK.
    03: VP(SetController_InvCtrlMode):
        Verify that DET was called with ETHIF_E_INV_PARAM.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.SetController_InvCtrlMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>171</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1278</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01024_EthIf_RxIndication_InvalidCtrlIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>1593</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_RxIndication() is called with invalid CtrlIdx,
    ETHIF_E_INV_CTRL_IDX will be reported to DET.
  
Test Object: 
    EthIf_RxIndication().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_RxIndication() using an invalid CtrlIdx.
    02: VP(): Verify that DET was called with ETHIF_E_INV_CTRL_IDX.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00087</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>451</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1279</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01025_EthIf_RxIndication_InvalidDataPtr</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>1652</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_RxIndication() is called with invalid DataPtr,
    ETHIF_E_PARAM_POINTER will be reported to DET.
  
Test Object: 
    EthIf_RxIndication().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_RxIndication() using an invalid DataPtr.
    02: VP(): Verify that DET was called with ETHIF_E_PARAM_POINTER.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00088</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>452</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1280</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01026_EthIf_GetCurrentTime_Invalid_Param</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>1706</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_GetCurrentTime() is called with invalid CtrlIdx, timeQualPtr
    and timeStampPtr a DET will be reported.
  
Test Object: 
    EthIf_GetCurrentTime().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_GetCurrentTime() using an invalid CtrlIdx.
    02: VP(EthIf.ASR43.SWS_EthIf_00156): Verify that DET was called with ETHIF_E_INV_CTRL_IDX.
    03: Call EthIf_GetCurrentTime() using an invalid  timeQualPtr.
    04: VP(EthIf.ASR43.SWS_EthIf_00157): Verify that DET was called with ETHIF_E_PARAM_POINTER.
    05: Call EthIf_GetCurrentTime() using an invalid timeStampPtr.
    06: VP(EthIf.ASR43.SWS_EthIf_00157): Verify that DET was called with ETHIF_E_PARAM_POINTER.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00156</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>517</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00157</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>518</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1281</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01027_EthIf_EnableEgressTimeStamp_Inv_Param</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>1796</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_EnableEgressTimeStamp() is called with invalid CtrlIdx a DET
    will be reported.
  
Test Object: 
    EthIf_EnableEgressTimeStamp().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_EnableEgressTimeStamp() using an invalid CtrlIdx.
    02: VP(EthIf.SWS_EthIf_001692): Verify that DET was called with ETHIF_E_INV_CTRL_IDX.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00162</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>522</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1282</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01028_EthIf_GetEgressTimeStamp_Invalid_Param</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>1848</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_GetEgressTimeStamp() is called with invalid CtrlIdx,
    timeQualPtr and timeStampPtr a DET will be reported.
  
Test Object: 
    EthIf_GetEgressTimeStamp().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_GetEgressTimeStamp() using an invalid CtrlIdx.
    02: VP(EthIf.SWS_EthIf_00168): Verify that DET was called with ETHIF_E_INV_CTRL_IDX.
    03: Call EthIf_GetEgressTimeStamp() using an invalid  timeQualPtr.
    04: VP(EthIf.SWS_EthIf_001699): Verify that DET was called with ETHIF_E_PARAM_POINTER.
    05: Call EthIf_GetEgressTimeStamp() using an invalid timeStampPtr.
    06: VP(EthIf.SWS_EthIf_001699): Verify that DET was called with ETHIF_E_PARAM_POINTER.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00168</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>526</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00169</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>527</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1283</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01029_EthIf_GetIngressTimeStamp_Inv_Param</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>1930</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_GetIngressTimeStamp() is called with invalid CtrlIdx,
    DataPtr, timeQualPtr and timeStampPtr a DET will be reported.
  
Test Object: 
    EthIf_GetIngressTimeStamp().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_GetIngressTimeStamp() using an invalid CtrlIdx.
    02: VP(EEthIf.SWS_EthIf_00174): Verify that DET was called with ETHIF_E_INV_CTRL_IDX.
    03: Call EthIf_GetIngressTimeStamp() using an invalid  DataPtr.
    04: VP(EthIf.SWS_EthIf_00175): Verify that DET was called with ETHIF_E_PARAM_POINTER.
    05: Call EthIf_GetIngressTimeStamp() using an invalid timeQualPtr.
    06: VP(EthIf.SWS_EthIf_00175): Verify that DET was called with ETHIF_E_PARAM_POINTER.
    07: Call EthIf_GetIngressTimeStamp() using an invalid timeStampPtr.
    08: VP(EthIf.SWS_EthIf_00175): Verify that DET was called with ETHIF_E_PARAM_POINTER.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00174</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>531</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00175</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>532</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1284</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01032_EthIf_GetCurrentTime_Forward_Call</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>2027</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_GetCurrentTime() is called with valid parameters, the call
    will be forwarded to Eth_GetCurrentTime().
  
Test Object: 
    EthIf_GetCurrentTime().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_GetCurrentTime().
    02: VP(): Verify that Eth_GetCurrentTime() was called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00154.GetCurrentTime.ForwardCall</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>109</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1285</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01033_EthIf_EnableEgressTimeStamp_Forw_Call</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>2093</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_EnableEgressTimeStamp() is called with valid parameters, the
    call will be forwarded to Eth_EnableEgressTimeStamp().
  
Test Object: 
    EthIf_EnableEgressTimeStamp().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_EnableEgressTimeStamp().
    02: VP(): Verify that Eth_EnableEgressTimeStamp() was called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00160.EnableEgressTimeStamp.ForwardCall</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>111</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1286</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01034_EthIf_GetEgressTimeStamp_Forward_Call</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>2145</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_GetEgressTimeStamp() is called with valid parameters, the call
    will be forwarded to Eth_GetEgressTimeStamp().
  
Test Object: 
    EthIf_GetEgressTimeStamp().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_GetEgressTimeStamp().
    02: VP(): Verify that Eth_GetEgressTimeStamp() was called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00166.GetEgressTimeStamp.ForwardCall</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>113</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1287</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01035_EthIf_GetIngressTimeStamp_Forward_Call</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>2211</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_GetIngressTimeStamp() is called with valid parameters, the
    call will be forwarded to Eth_GetIngressTimeStamp().
  
Test Object: 
    EthIf_GetIngressTimeStamp().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_GetIngressTimeStamp().
    02: VP(): Verify that Eth_GetIngressTimeStamp() was called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00172.GetIngressTimeStamp.ForwardCall</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>115</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1288</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01063_GetCtrlIdxList_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>2278</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_GetCtrlIdxList() is called when the module is not
    initialized, ETHIF_E_NOT_INITIALIZED will be reported to DET and E_NOT_OK returned.
  
Test Object: 
    EthIf_GetCtrlIdxList()
  
Test Precondition: 
    EthIf uninitialized.
  
Test Execution: 
    01: Call EthIf_GetCtrlIdxList() in UNINIT state.
    02: VP(): Verify that DET was called with ETHIF_E_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00299</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>643</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1289</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01064_GetVlanId_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>2332</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_GetVlanId() is called when the module is not initialized,
    ETHIF_E_NOT_INITIALIZED will be reported to DET and E_NOT_OK returned.
  
Test Object: 
    EthIf_GetVlanId()
  
Test Precondition: 
    EthIf uninitialized.
  
Test Execution: 
    01: Call EthIf_GetVlanId() in UNINIT state.
    02: VP(): Verify that DET was called with ETHIF_E_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00302</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>646</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1290</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01065_GetAndResetMeasurementData_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>2386</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_GetAndResetMeasurementData() is called when the module is not
    initialized, ETHIF_E_NOT_INITIALIZED will be reported to DET and E_NOT_OK returned.
  
Test Object: 
    EthIf_GetAndResetMeasurementData()
  
Test Precondition: 
    EthIf uninitialized.
  
Test Execution: 
    01: Call EthIf_GetAndResetMeasurementData() in UNINIT state.
    02: VP(): Verify that DET was called with ETHIF_E_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00319</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>660</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1291</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01068_VerifyConfig_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>2443</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_VerifyConfig() is called when the module is not
    initialized, ETHIF_E_NOT_INITIALIZED will be reported to DET and E_NOT_OK returned.
  
Test Object: 
    EthIf_VerifyConfig()
  
Test Precondition: 
    EthIf uninitialized.
  
Test Execution: 
    01: Call EthIf_VerifyConfig() in UNINIT state.
    02: VP(): Verify that DET was called with ETHIF_E_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00304</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>648</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1292</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01069_SetForwardingMode_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>2496</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_SetForwardingMode() is called when the module is not
    initialized, ETHIF_E_NOT_INITIALIZED will be reported to DET and E_NOT_OK returned.
  
Test Object: 
    EthIf_SetForwardingMode()
  
Test Precondition: 
    EthIf uninitialized.
  
Test Execution: 
    01: Call EthIf_SetForwardingMode() in UNINIT state.
    02: VP(): Verify that DET was called with ETHIF_E_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00306</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>650</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1293</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01070_SwitchMgmtInfoIndication_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>2548</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_SwitchMgmtInfoIndication() is called when the module is not
    initialized, ETHIF_E_NOT_INITIALIZED will be reported to DET.
  
Test Object: 
    EthIf_SwitchMgmtInfoIndication()
  
Test Precondition: 
    EthIf uninitialized.
  
Test Execution: 
    01: Call EthIf_SwitchMgmtInfoIndication() in UNINIT state.
    02: VP(): Verify that DET was called with ETHIF_E_NOT_INITIALIZED.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00292</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>79</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1294</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest010072_CallDummyFunctions</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>2600</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test calls AUTOSAR 4.3.0 functions that are not yet implemented (dummy) and verify
    they return E_NOT_OK (if not void).
  
Test Object: 
  
Test Precondition: 
  
Test Execution: 
    01: Call EthIf_GetCtrlIdxList().
    02: VP(): Verify E_NOT_OK was returned as the function is not implemented (dummy).
    03: Call EthIf_VerifyConfig().
    04: VP(): Verify E_NOT_OK was returned as the function is not implemented (dummy).
    05: Call EthIf_SetForwardingMode().
    06: VP(): Verify E_NOT_OK was returned as the function is not implemented (dummy).
    07: Call EthIf_SwitchMgmtInfoIndication().
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00103</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>462</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1295</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01074_EthIf_GetVersionInfo_ParamPtr</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>2661</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_GetVersionInfo() is called with invalid DataPtr,
    ETHIF_E_PARAM_POINTER will be reported to DET.
  
Test Object: 
    EthIf_GetVersionInfo()
  
Test Precondition: 
    EthIf is initialized.
  
Test Execution: 
    01: Call EthIf_GetVersionInfo() using an invalid DataPtr.
    02: VP(EthIf.SWS_EthIf_00127): Verify that DET was called with ETHIF_E_PARAM_POINTER.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00127</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>479</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1296</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01075_SetControllerMode_InvalidParam</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>2711</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_SetControllerMode() is called with invalid CtrlIdx,
    ETHIF_E_INV_CTRL_IDX will be reported to DET and if it is called with invalid Controler mode,
    ETHIF_E_INV_PARAM will be reported to DET.
  
Test Object: 
    EthIf_SetControllerMode()
  
Test Precondition: 
    EthIf is initialized.
  
Test Execution: 
    01: Call EthIf_SetControllerMode() using an invalid CtrlIdx.
    02: VP(EthIf.SWS_EthIf_00037):
        Verify that DET was called with ETHIF_E_INV_CTRL_IDX and E_NOT_OK was returned.
    03: Call EthIf_SetControllerMode() using an invalid CtrlMode.
    04: VP(EthIf.EB.Det.SetController_InvCtrlMode):
        Verify that DET was called with ETHIF_E_INV_PARAM and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00037</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>426</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.Det.SetController_InvCtrlMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>171</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1297</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01076_SetControllerMode_HardwareUninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>2781</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_SetControllerMode() is called while the controller is not
    initialized, ETHIF_E_HW_NOT_INITIALIZED will be reported to DET.
  
Test Object: 
    EthIf_SetControllerMode()
  
Test Precondition: 
    EthIf is initialized, but controller is not initialized.
  
Test Execution: 
    01: Call EthIf_SetControllerMode() for a controler that was not initialized.
    02: VP(EthIf.EB.Det.SetController_HardwareUninit):
        Verify that DET was called with ETHIF_E_HW_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.SetController_HardwareUninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>166</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1298</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01077_GetControllerMode_InvalidParam</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>2839</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_GetControllerMode() is called with invalid CtrlIdx,
    ETHIF_E_INV_CTRL_IDX will be reported to DET and if it is called with invalid CtrlModePtr,
    ETHIF_E_PARAM_POINTER will be reported to DET.
  
Test Object: 
    EthIf_SetControllerMode()
  
Test Precondition: 
    EthIf is initialized.
  
Test Execution: 
    01: Call EthIf_GetControllerMode() using an invalid CtrlIdx.
    02: VP(EthIf.SWS_EthIf_00042):
        Verify that DET was called with ETHIF_E_INV_CTRL_IDX and E_NOT_OK was returned.
    03: Call EthIf_GetControllerMode() using an invalid CtrlModePtr.
    04: VP(EthIf.SWS_EthIf_00043):
        Verify that DET was called with ETHIF_E_PARAM_POINTER and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00042</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>430</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00043</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>431</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1299</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01078_GetControllerMode_HardwareUninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>2910</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_GetControllerMode() is called while the controller is not
    initialized, ETHIF_E_HW_NOT_INITIALIZED will be reported to DET.
  
Test Object: 
    EthIf_SetControllerMode()
  
Test Precondition: 
    EthIf is initialized, but controller is not initialized.
  
Test Execution: 
    01: Call EthIf_GetControllerMode() for a controler that was not initialized.
    02: VP(EthIf.EB.Det.GetController_HardwareUninit):
        Verify that DET was called with ETHIF_E_HW_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.GetController_HardwareUninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>167</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1300</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01079_GetPhysAddr_InvalidParam</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>2969</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_GetPhysAddr() is called with invalid CtrlIdx,
    ETHIF_E_INV_CTRL_IDX will be reported to DET and if it is called with invalid PhysAddrPtr,
    ETHIF_E_PARAM_POINTER will be reported to DET.
  
Test Object: 
    EthIf_GetPhysAddr()
  
Test Precondition: 
    EthIf is initialized.
  
Test Execution: 
    01: Call EthIf_GetPhysAddr() using an invalid CtrlIdx.
    02: VP(EthIf.SWS_EthIf_00064):
        Verify that DET was called with ETHIF_E_INV_CTRL_IDX.
    03: Call EthIf_GetControllerMode() using an invalid CtrlModePtr.
    04: VP(EthIf.SWS_EthIf_00065):
        Verify that DET was called with ETHIF_E_PARAM_POINTER.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00064</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>435</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00065</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>436</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1301</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01080_EnableRelatedEthIfCtrls_InvalidCtrlIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>3037</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_EnableRelatedEthIfCtrls() is called using an invalid
    CtrlIdx ETHIF_E_INV_CTRL_IDX will be reported to DET.
  
Test Object: 
    EthIf_EnableRelatedEthIfCtrls()
  
Test Precondition: None.
Test Execution: 
    01: Call EthIf_EnableRelatedEthIfCtrls() using invalid CtrlIdx.
    02: VP(): Verify that DET was called with ETHIF_E_INV_CTRL_IDX.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.DevAuthExtension.EnableRelatedEthIfCtrls.DetCheck.InvalidCtrlIdx</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>293</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1302</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01081_DisableRelatedEthIfCtrls_InvalidCtrlIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>3090</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_DisableRelatedEthIfCtrls() is called using an invalid
    CtrlIdx ETHIF_E_INV_CTRL_IDX will be reported to DET.
  
Test Object: 
    EthIf_DisableRelatedEthIfCtrls()
  
Test Precondition: None.
Test Execution: 
    01: Call EthIf_DisableRelatedEthIfCtrls() using invalid CtrlIdx.
    02: VP(): Verify that DET was called with ETHIF_E_INV_CTRL_IDX.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.DevAuthExtension.DisableRelatedEthIfCtrls.DetCheck.InvalidCtrlIdx</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>294</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1303</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01082_TxConfirmation_InvalidCtrlIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>3143</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_TxConfirmation() is called using an invalid CtrlIdx
    ETHIF_E_INV_CTRL_IDX will be reported to DET.
  
Test Object: 
    EthIf_TxConfirmation()
  
Test Precondition: None.
Test Execution: 
    01: Call EthIf_TxConfirmation() using invalid CtrlIdx.
    02: VP(EthIf.SWS_EthIf_00093):
        Verify that DET was called with ETHIF_E_INV_CTRL_IDX.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00093</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>455</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1304</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01083_WriteMii_HardwareUninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>3195</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_WriteMii() is called while the controller is not
    initialized, ETHIF_E_HW_NOT_INITIALIZED will be reported to DET.
  
Test Object: 
    EthIf_WriteMii()
  
Test Precondition: 
    EthIf is initialized, but controller is not initialized.
  
Test Execution: 
    01: Call EthIf_WriteMii() for a controler that was not initialized.
    02: VP(EthIf.EB.MIIExtension.WriteMii.DetCheck.CtrlNotInit):
        Verify that DET was called with ETHIF_E_HW_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.WriteMii.DetCheck.CtrlNotInit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>212</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1305</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01084_ReadMii_HardwareUninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>3255</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_ReadMii() is called while the controller is not
    initialized, ETHIF_E_HW_NOT_INITIALIZED will be reported to DET.
  
Test Object: 
    EthIf_ReadMii()
  
Test Precondition: 
    EthIf is initialized, but controller is not initialized.
  
Test Execution: 
    01: Call EthIf_ReadMii() for a controler that was not initialized.
    02: VP(EthIf.EB.MIIExtension.ReadMii.DetCheck.CtrlNotInit):
        Verify that DET was called with ETHIF_E_HW_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.ReadMii.DetCheck.CtrlNotInit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>211</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1306</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01085_EnableRelatedEthIfCtrls_HardwareUninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>3314</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_EnableRelatedEthIfCtrls() is called while the controller
    is not initialized, ETHIF_E_HW_NOT_INITIALIZED will be reported to DET.
  
Test Object: 
    EthIf_EnableRelatedEthIfCtrls()
  
Test Precondition: 
    EthIf is initialized, but controller is not initialized.
  
Test Execution: 
    01: Call EthIf_EnableRelatedEthIfCtrls() for a controler that was not initialized.
    02: VP(): Verify that DET was called with ETHIF_E_HW_NOT_INITIALIZED and E_NOT_OK
        was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.DevAuthExtension.EnableRelatedEthIfCtrls.DetCheck.HwNotInit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>295</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1307</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01086_DisableRelatedEthIfCtrls_HardwareUninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>3374</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_DisableRelatedEthIfCtrls() is called while the controller
    is not initialized, ETHIF_E_HW_NOT_INITIALIZED will be reported to DET.
  
Test Object: 
    EthIf_DisableRelatedEthIfCtrls()
  
Test Precondition: 
    EthIf is initialized, but controller is not initialized.
  
Test Execution: 
    01: Call EthIf_DisableRelatedEthIfCtrls() for a controler that was not initialized.
    02: VP(): Verify that DET was called with ETHIF_E_HW_NOT_INITIALIZED and E_NOT_OK
        was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.DevAuthExtension.DisableRelatedEthIfCtrls.DetCheck.HwNotInit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>296</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1308</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01085_SwitchPortGroupRequestMode_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>3434</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_SwitchPortGroupRequestMode() is called when the module is not
    initialized, ETHIF_E_NOT_INITIALIZED will be reported to DET and E_NOT_OK returned.
  
Test Object: 
    EthIf_SwitchPortGroupRequestMode()
  
Test Precondition: 
    EthIf uninitialized.
  
Test Execution: 
    01: Call EthIf_SwitchPortGroupRequestMode() in UNINIT state.
    02: VP(): Verify that DET was called with ETHIF_E_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00273</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>626</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1309</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01086_StartAllPorts_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>3487</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_StartAllPorts() is called when the module is not
    initialized, ETHIF_E_NOT_INITIALIZED will be reported to DET and E_NOT_OK returned.
  
Test Object: 
    EthIf_StartAllPorts()
  
Test Precondition: 
    EthIf uninitialized.
  
Test Execution: 
    01: Call EthIf_StartAllPorts() in UNINIT state.
    02: VP(): Verify that DET was called with ETHIF_E_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00277</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>630</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1310</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01087_SwitchPortGroupRequestMode_InvPortGrInd</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>3539</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_SwitchPortGroupRequestMode() is called with PortGroupIdx
    which addresses a port group referenced by an EthIfController, ETHIF_E_INV_PORT_GROUP_IDX will
    be reported to DET and E_NOT_OK returned.
  
Test Object: 
    EthIf_SwitchPortGroupRequestMode()
  
Test Precondition: 
    EthIf is initialized.
  
Test Execution: 
    01: Call EthIf_SwitchPortGroupRequestMode() with PortGroupIdx referenced by EthIfController.
    02: VP(): Verify that DET was called with ETHIF_E_INV_PORT_GROUP_IDX and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00274</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>627</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1311</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01088_SwitchPortGroupRequestMode_InvPortMode</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>3595</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_SwitchPortGroupRequestMode() is called with PortMode
    other then ETHTRCV_MODE_DOWN or ETHTRCV_MODE_ACTIVE, ETHIF_E_INV_PARAM will be reported
    to DET and E_NOT_OK returned.
  
Test Object: 
    EthIf_SwitchPortGroupRequestMode()
  
Test Precondition: 
    EthIf is initialized.
  
Test Execution: 
    01: Call EthIf_SwitchPortGroupRequestMode() with PortGroupIdx referenced by EthIfController.
    02: VP(): Verify that DET was called with ETHIF_E_INV_PORT_GROUP_IDX and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.SwitchPortGroupRequest_InvPortMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>168</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1312</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01089_SwitchPortGroupRequestMode_LogPortGrInd</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>3651</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_SwitchPortGroupRequestMode() is called with PortGroupIdx
    which addresses a Logical PortGroup which is not accessible from BswM,
    ETHIF_E_INV_PORT_GROUP_IDX will be reported to DET and E_NOT_OK returned.
  
Test Object: 
    EthIf_SwitchPortGroupRequestMode()
  
Test Precondition: 
    EthIf is initialized.
  
Test Execution: 
    01: Call EthIf_SwitchPortGroupRequestMode() with PortGroupIdx referenced by EthIfController.
    02: VP(): Verify that DET was called with ETHIF_E_INV_PORT_GROUP_IDX and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.SwitchPortGroupRequest_InvPortGroupIdx</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>170</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1313</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01100_Retransmit_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>3708</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_Retransmit() is called when the module is not
    initialized, ETHIF_E_NOT_INITIALIZED will be reported to DET and E_NOT_OK returned.
  
Test Object: 
    EthIf_Retransmit()
  
Test Precondition: 
    EthIf uninitialized.
  
Test Execution: 
    01: Call EthIf_Retransmit() in UNINIT state.
    02: VP(): Verify that DET was called with ETHIF_E_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.RetransmitExtension.Retransmit.DetCheck.NotInit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>302</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1314</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01101_Retransmit_InvalidCtrlIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>3775</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_Retransmit() is called with invalid parameters CtrlIdx or
    OrigCtrlIdx, ETHIF_E_INV_CTRL_IDX will be reported to DET and E_NOT_OK returned.
  
Test Object: 
    EthIf_Retransmit()
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_Retransmit() with invalid CtrlIdx.
    02: VP(): Verify that DET was called with ETHIF_E_NOT_INITIALIZED and E_NOT_OK was returned.
    03: Call EthIf_Retransmit() with invalid OrigCtrlIdx.
    04: VP(): Verify that DET was called with ETHIF_E_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.RetransmitExtension.Retransmit.DetCheck.InvCtrlIdx</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>303</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1315</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01102_Retransmit_InvalidRetInfoPtr</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>3861</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_Retransmit() is called with invalid RetransmitInfoPtr,
    ETHIF_E_PARAM_POINTER will be reported to DET and E_NOT_OK returned.
  
Test Object: 
    EthIf_Retransmit()
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_Retransmit() with invalid RetransmitInfoPtr.
    02: VP(): Verify that DET was called with ETHIF_E_PARAM_POINTER and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.RetransmitExtension.Retransmit.DetCheck.InvRetransmitInfoPtr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>305</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1316</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01103_Retransmit_InvalidBufIdxPtr</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>3926</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_Retransmit() is called with invalid BufIdxPtr,
    ETHIF_E_PARAM_POINTER will be reported to DET and E_NOT_OK returned.
  
Test Object: 
    EthIf_Retransmit()
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_Retransmit() with invalid BufIdxPtr.
    02: VP(): Verify that DET was called with ETHIF_E_PARAM_POINTER and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.RetransmitExtension.Retransmit.DetCheck.InvBufIdxPtr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>304</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1317</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01104_Retransmit_InvalidDataPtr</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>3992</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_Retransmit() is called with invalid DataPtr,
    ETHIF_E_PARAM_POINTER will be reported to DET and E_NOT_OK returned.
  
Test Object: 
    EthIf_Retransmit()
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_Retransmit() with invalid DataPtr.
    02: VP(): Verify that DET was called with ETHIF_E_PARAM_POINTER and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.RetransmitExtension.Retransmit.DetCheck.InvDataPtr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>306</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1318</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01105_MacSecUpdateSecY_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>4058</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecUpdateSecY() is called before EthIf module was
    initialized, an error shall be reported to Det with error code ETHIF_E_NOT_INITIALIZED.
  
Test Object: 
    EthIf_MacSecUpdateSecY()
  
Test Precondition: 
    EthIf uninitialized.
  
Test Execution: 
    01: Call EthIf_MacSecUpdateSecY().
    02: VP(): Verify that DET was called with ETHIF_E_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecUpdateSecY.Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>309</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1319</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01106_MacSecUpdateSecY_HwUninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>4110</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecUpdateSecY() is called with controller not
    initialized, an error will be reported to DET with error code ETHIF_E_HW_NOT_INITIALIZED.
  
Test Object: 
    EthIf_MacSecUpdateSecY()
  
Test Precondition: 
    Hw Controller Stub set to E_NOT_OK.
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_MacSecUpdateSecY().
    02: VP(): Verify that DET was called with ETHIF_E_HW_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecUpdateSecY.HwUninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>310</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1320</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01107_MacSecUpdateSecY_InvalidCtrlIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>4173</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecUpdateSecY() is called with invalid parameter
    CtrlIdx, an error will be reported to DET with error code ETHIF_E_INV_CTRL_IDX.
  
Test Object: 
    EthIf_MacSecUpdateSecY()
  
Test Precondition: 
    Hw Controller Stub set to E_OK.
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_MacSecUpdateSecY().
    02: VP(): Verify that DET was called with ETHIF_E_INV_CTRL_IDX and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecUpdateSecY.InvalidCtrlIdx</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>311</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1321</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01108_MacSecUpdateSecY_InvalidPtr</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>4233</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecUpdateSecY() is called with invalid parameter
    MACsecCfgPtr, an error will be reported to DET with error code ETHIF_E_HW_NOT_INITIALIZED.
  
Test Object: 
    EthIf_MacSecUpdateSecY()
  
Test Precondition: 
    Hw Controller Stub set to E_OK.
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_MacSecUpdateSecY().
    02: VP(): Verify that DET was called with ETHIF_E_PARAM_POINTER and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecUpdateSecY.InvalidPointer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>312</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1322</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01109_MacSecUpdateSecY_InvalidValidateFrames</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>4294</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecUpdateSecY() is called with invalid parameter
    MACsecCfgPtr-&gt;ValidateFrames, an error will be reported to DET with error code ETHIF_E_INV_PARAM.
  
Test Object: 
    EthIf_MacSecUpdateSecY()
  
Test Precondition: 
    Hw Controller Stub set to E_OK.
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_MacSecUpdateSecY().
    02: VP(): Verify that DET was called with ETHIF_E_INV_PARAM and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecUpdateSecY.InvalidValidateFrames</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>313</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1323</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01110_MacSecUpdateSecY_InvalidConfidentialOffset</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>4366</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecUpdateSecY() is called with invalid parameter
    MACsecCfgPtr-&gt;ConfidentialityOffset, an error will be reported to DET with error code ETHIF_E_INV_PARAM.
  
Test Object: 
    EthIf_MacSecUpdateSecY()
  
Test Precondition: 
    Hw Controller Stub set to E_OK.
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_MacSecUpdateSecY().
    02: VP(): Verify that DET was called with ETHIF_E_INV_PARAM and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecUpdateSecY.InvalidConfidentialityOffset</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>314</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1324</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01111_MacSecAddTxSa_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>4438</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecAddTxSa() is called with module not
    initialized, an error will be reported to DET with error code ETHIF_E_NOT_INITIALIZED.
  
Test Object: 
    EthIf_MacSecAddTxSa()
  
Test Precondition: 
    Hw Controller Stub set to E_OK.
    EthIf Uninitialized.
  
Test Execution: 
    01: Call EthIf_MacSecAddTxSa().
    02: VP(): Verify that DET was called with ETHIF_E_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecAddTxSa.Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>315</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1325</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01112_MacSecAddTxSa_HwUninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>4503</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecAddTxSa() is called with HW module not
    initialized, an error will be reported to DET with error code ETHIF_E_HW_NOT_INITIALIZED.
  
Test Object: 
    EthIf_MacSecAddTxSa()
  
Test Precondition: 
    Hw Controller Stub set to E_NOT_OK.
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_MacSecAddTxSa().
    02: VP(): Verify that DET was called with ETHIF_E_HW_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecAddTxSa.HwUninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>316</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1326</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01113_MacSecAddTxSa_InvalidCtrlIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>4567</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecAddTxSa() is called with invalid parameter
    CtrlIdx, an error will be reported to DET with error code ETHIF_E_INV_CTRL_IDX.
  
Test Object: 
    EthIf_MacSecAddTxSa()
  
Test Precondition: 
    Hw Controller Stub set to E_OK.
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_MacSecAddTxSa().
    02: VP(): Verify that DET was called with ETHIF_E_INV_CTRL_IDX and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecAddTxSa.InvalidCtrlIdx</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>317</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1327</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01114_MacSecAddTxSa_InvalidPtr</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>4638</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecAddTxSa() is called with invalid parameter
    KeysPtr, an error will be reported to DET with error code ETHIF_E_PARAM_POINTER.
  
Test Object: 
    EthIf_MacSecAddTxSa()
  
Test Precondition: 
    Hw Controller Stub set to E_OK.
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_MacSecAddTxSa().
    02: VP(): Verify that DET was called with ETHIF_E_PARAM_POINTER and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecAddTxSa.InvalidPointer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>318</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1328</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01115_MacSecAddTxSa_InvalidAn</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>4705</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecAddTxSa() is called with invalid parameter
    An, an error will be reported to DET with error code ETHIF_E_INV_PARAM.
  
Test Object: 
    EthIf_MacSecAddTxSa()
  
Test Precondition: 
    Hw Controller Stub set to E_OK.
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_MacSecAddTxSa().
    02: VP(): Verify that DET was called with ETHIF_E_INV_PARAM and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecAddTxSa.InvalidAn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>319</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1329</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01116_MacSecAddRxSa_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>4776</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecAddRxSa() is called with module not
    initialized, an error will be reported to DET with error code ETHIF_E_NOT_INITIALIZED.
  
Test Object: 
    EthIf_MacSecAddRxSa()
  
Test Precondition: 
    Hw Controller Stub set to E_OK.
    EthIf Uninitialized.
  
Test Execution: 
    01: Call EthIf_MacSecAddRxSa().
    02: VP(): Verify that DET was called with ETHIF_E_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecAddRxSa.Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>320</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1330</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01117_MacSecAddRxSa_HwUninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>4841</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecAddRxSa() is called with HW module not
    initialized, an error will be reported to DET with error code ETHIF_E_HW_NOT_INITIALIZED.
  
Test Object: 
    EthIf_MacSecAddRxSa()
  
Test Precondition: 
    Hw Controller Stub set to E_NOT_OK.
    EthIf Initialized.
  
Test Execution: 
    01: Call EthIf_MacSecAddRxSa().
    02: VP(): Verify that DET was called with ETHIF_E_HW_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecAddRxSa.HwUninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>321</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1331</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01118_MacSecAddRxSa_InvalidCtrlIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>4905</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecAddRxSa() is called with invalid parameter
    CtrlIdx, an error will be reported to DET with error code ETHIF_E_INV_CTRL_IDX.
  
Test Object: 
    EthIf_MacSecAddRxSa()
  
Test Precondition: 
    Hw Controller Stub set to E_OK.
    EthIf Initialized.
  
Test Execution: 
    01: Call EthIf_MacSecAddRxSa().
    02: VP(): Verify that DET was called with ETHIF_E_INV_CTRL_IDX and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecAddRxSa.InvalidCtrlIdx</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>322</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1332</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01119_MacSecAddRxSa_InvalidPtr</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>4976</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecAddRxSa() is called with invalid parameter
    KeysPtr, an error will be reported to DET with error code ETHIF_E_PARAM_POINTER.
  
Test Object: 
    EthIf_MacSecAddRxSa()
  
Test Precondition: 
    Hw Controller Stub set to E_OK.
    EthIf Initialized.
  
Test Execution: 
    01: Call EthIf_MacSecAddRxSa().
    02: VP(): Verify that DET was called with ETHIF_E_PARAM_POINTER and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecAddRxSa.InvalidPointer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>323</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1333</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01120_MacSecAddRxSa_InvalidAn</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>5043</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecAddRxSa() is called with invalid parameter
    An, an error will be reported to DET with error code ETHIF_E_INV_PARAM.
  
Test Object: 
    EthIf_MacSecAddRxSa()
  
Test Precondition: 
    Hw Controller Stub set to E_OK.
    EthIf Initialized.
  
Test Execution: 
    01: Call EthIf_MacSecAddRxSa().
    02: VP(): Verify that DET was called with ETHIF_E_INV_PARAM and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecAddRxSa.InvalidAn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>324</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1334</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01121_MacSecGetMacSecStats_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>5113</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecGetMacSecStats() is called with module not
    initialized, an error will be reported to DET with error code ETHIF_E_NOT_INITIALIZED.
  
Test Object: 
    EthIf_MacSecGetMacSecStats()
  
Test Precondition: 
    Hw Controller set to E_OK
    EthIf Uninitialized.
  
Test Execution: 
    01: Call EthIf_MacSecGetMacSecStats().
    02: VP(): Verify that DET was called with ETHIF_E_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecGetMacSecStats.Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>325</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1335</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01122_MacSecGetMacSecStats_HwUninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>5169</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecGetMacSecStats() is called with HW module not
    initialized, an error will be reported to DET with error code ETHIF_E_HW_NOT_INITIALIZED.
  
Test Object: 
    EthIf_MacSecGetMacSecStats()
  
Test Precondition: 
    HW controller stub set to E_NOT_OK.
    EthIf Initialized.
  
Test Execution: 
    01: Call EthIf_MacSecGetMacSecStats().
    02: VP(): Verify that DET was called with ETHIF_E_HW_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecGetMacSecStats.HwUninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>326</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1336</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01123_MacSecGetMacSecStats_InvalidCtrlIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>5227</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecGetMacSecStats() is called with invalid parameter
    CtrlIdx, an error will be reported to DET with error code ETHIF_E_INV_CTRL_IDX.
  
Test Object: 
    EthIf_MacSecGetMacSecStats()
  
Test Precondition: 
    HW controller stub set to E_OK.
    EthIf Initialized.
  
Test Execution: 
    01: Call EthIf_MacSecGetMacSecStats().
    02: VP(): Verify that DET was called with ETHIF_E_INV_CTRL_IDX and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecGetMacSecStats.InvalidCtrlIdx</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>327</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1337</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01124_MacSecInitRxSc_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>5285</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecInitRxSc() is called with module not
    initialized, an error will be reported to DET with error code ETHIF_E_NOT_INITIALIZED.
  
Test Object: 
    EthIf_MacSecInitRxSc()
  
Test Precondition: 
    HW controller stub set to E_OK.
    EthIf Uninitialized.
  
Test Execution: 
    01: Call EthIf_MacSecInitRxSc().
    02: VP(): Verify that DET was called with ETHIF_E_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecInitRxSc.Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>328</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1338</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01125_MacSecInitRxSc_HwUninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>5343</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecInitRxSc() is called with HW module not
    initialized, an error will be reported to DET with error code ETHIF_E_HW_NOT_INITIALIZED.
  
Test Object: 
    EthIf_MacSecInitRxSc()
  
Test Precondition: 
    HW controller stub set to E_NOT_OK.
    EthIf Initialized.
  
Test Execution: 
    01: Call EthIf_MacSecGetMacSecStats().
    02: VP(): Verify that DET was called with ETHIF_E_HW_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecInitRxSc.HwUninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>329</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1339</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01126_MacSecInitRxSc_InvalidCtrlIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>5401</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecInitRxSc() is called with invalid parameter
    CtrlIdx, an error will be reported to DET with error code ETHIF_E_INV_CTRL_IDX.
  
Test Object: 
    EthIf_MacSecInitRxSc()
  
Test Precondition: 
    HW controller stub set to E_OK.
    EthIf Initialized.
  
Test Execution: 
    01: Call EthIf_MacSecInitRxSc().
    02: VP(): Verify that DET was called with ETHIF_E_INV_CTRL_IDX and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecInitRxSc.InvalidCtrlIdx</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>330</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1340</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01127_MacSecResetRxSc_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>5461</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecResetRxSc() is called with module not
    initialized, an error will be reported to DET with error code ETHIF_E_NOT_INITIALIZED.
  
Test Object: 
    EthIf_MacSecResetRxSc()
  
Test Precondition: 
    HW controller stub set to E_OK.
    EthIf Uninitialized.
  
Test Execution: 
    01: Call EthIf_MacSecResetRxSc().
    02: VP(): Verify that DET was called with ETHIF_E_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecResetRxSc.Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>331</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1341</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01128_MacSecResetRxSc_HwUninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>5519</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecResetRxSc() is called with HW module not
    initialized, an error will be reported to DET with error code ETHIF_E_HW_NOT_INITIALIZED.
  
Test Object: 
    EthIf_MacSecResetRxSc()
  
Test Precondition: 
    HW controller stub set to E_NOT_OK.
    EthIf Initialized.
  
Test Execution: 
    01: Call EthIf_MacSecResetRxSc().
    02: VP(): Verify that DET was called with ETHIF_E_HW_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecResetRxSc.HwUninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>332</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1342</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01129_MacSecResetRxSc_InvalidCtrlIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>5579</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecResetRxSc() is called with invalid parameter
    CtrlIdx, an error will be reported to DET with error code ETHIF_E_INV_CTRL_IDX.
  
Test Object: 
    EthIf_MacSecResetRxSc()
  
Test Precondition: 
    HW controller stub set to E_OK.
    EthIf Initialized.
  
Test Execution: 
    01: Call EthIf_MacSecResetRxSc().
    02: VP(): Verify that DET was called with ETHIF_E_INV_CTRL_IDX and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecResetRxSc.InvalidCtrlIdx</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>333</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1343</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01130_MacSecUpdateTxSa_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>5639</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecUpdateTxSa() is called with module not
    initialized, an error will be reported to DET with error code ETHIF_E_NOT_INITIALIZED.
  
Test Object: 
    EthIf_MacSecUpdateTxSa()
  
Test Precondition: 
    HW controller stub set to E_OK.
    EthIf Uninitialized.
  
Test Execution: 
    01: Call EthIf_MacSecUpdateTxSa().
    02: VP(): Verify that DET was called with ETHIF_E_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecUpdateTxSa.Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>334</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1344</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01131_MacSecUpdateTxSa_HwUninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>5701</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecUpdateTxSa() is called with HW module not
    initialized, an error will be reported to DET with error code ETHIF_E_HW_NOT_INITIALIZED.
  
Test Object: 
    EthIf_MacSecUpdateTxSa()
  
Test Precondition: 
    HW controller stub set to E_NOT_OK.
    EthIf Initialized.
  
Test Execution: 
    01: Call EthIf_MacSecUpdateTxSa().
    02: VP(): Verify that DET was called with ETHIF_E_HW_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecUpdateTxSa.HwUninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>335</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1345</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01132_MacSecUpdateTxSa_InvalidCtrlIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>5765</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecUpdateTxSa() is called with invalid parameter
    CtrlIdx, an error will be reported to DET with error code ETHIF_E_INV_CTRL_IDX.
  
Test Object: 
    EthIf_MacSecUpdateTxSa()
  
Test Precondition: 
    HW controller stub set to E_OK.
    EthIf Initialized.
  
Test Execution: 
    01: Call EthIf_MacSecUpdateTxSa().
    02: VP(): Verify that DET was called with ETHIF_E_INV_CTRL_IDX and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecUpdateTxSa.InvalidCtrlIdx</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>336</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1346</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01133_MacSecUpdateTxSa_InvalidAn</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>5829</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecUpdateTxSa() is called with invalid parameter
    An, an error will be reported to DET with error code ETHIF_E_INV_PARAM.
  
Test Object: 
    EthIf_MacSecUpdateTxSa()
  
Test Precondition: 
    HW controller stub set to E_OK.
    EthIf Initialized.
  
Test Execution: 
    01: Call EthIf_MacSecUpdateTxSa().
    02: VP(): Verify that DET was called with ETHIF_E_INV_PARAM and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecUpdateTxSa.InvalidAn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>337</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1347</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01134_MacSecDeleteTxSa_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>5893</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecDeleteTxSa() is called with module not
    initialized, an error will be reported to DET with error code ETHIF_E_NOT_INITIALIZED.
  
Test Object: 
    EthIf_MacSecDeleteTxSa()
  
Test Precondition: 
    HW controller stub set to E_OK.
    EthIf Uninitialized.
  
Test Execution: 
    01: Call EthIf_MacSecDeleteTxSa().
    02: VP(): Verify that DET was called with ETHIF_E_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecDeleteTxSa.Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>338</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1348</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01135_MacSecDeleteTxSa_HwUninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>5951</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecDeleteTxSa() is called with HW module not
    initialized, an error will be reported to DET with error code ETHIF_E_HW_NOT_INITIALIZED.
  
Test Object: 
    EthIf_MacSecDeleteTxSa()
  
Test Precondition: 
    HW controller stub set to E_NOT_OK.
    EthIf Initialized.
  
Test Execution: 
    01: Call EthIf_MacSecDeleteTxSa().
    02: VP(): Verify that DET was called with ETHIF_E_HW_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecDeleteTxSa.HwUninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>339</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1349</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01136_MacSecDeleteTxSa_InvalidCtrlIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>6009</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecDeleteTxSa() is called with invalid parameter
    CtrlIdx, an error will be reported to DET with error code ETHIF_E_INV_CTRL_IDX.
  
Test Object: 
    EthIf_MacSecDeleteTxSa()
  
Test Precondition: 
    HW controller stub set to E_OK.
    EthIf Initialized.
  
Test Execution: 
    01: Call EthIf_MacSecDeleteTxSa().
    02: VP(): Verify that DET was called with ETHIF_E_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecDeleteTxSa.InvalidCtrlIdx</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>340</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1350</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01137_MacSecDeleteTxSa_InvalidAn</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>6069</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecDeleteTxSa() is called with invalid parameter
    An, an error will be reported to DET with error code ETHIF_E_INV_PARAM.
  
Test Object: 
    EthIf_MacSecDeleteTxSa()
  
Test Precondition: 
    HW controller stub set to E_OK.
    EthIf Initialized.
  
Test Execution: 
    01: Call EthIf_MacSecDeleteTxSa().
    02: VP(): Verify that DET was called with ETHIF_E_INV_PARAM and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecDeleteTxSa.InvalidAn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>341</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1351</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01138_MacSecUpdateRxSa_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>6129</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecUpdateRxSa() is called with module not
    initialized, an error will be reported to DET with error code ETHIF_E_NOT_INITIALIZED.
  
Test Object: 
    EthIf_MacSecUpdateRxSa()
  
Test Precondition: 
    HW controller stub set to E_OK.
    EthIf Uninitialized.
  
Test Execution: 
    01: Call EthIf_MacSecUpdateRxSa().
    02: VP(): Verify that DET was called with ETHIF_E_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecUpdateRxSa.Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>342</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1352</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01139_MacSecUpdateRxSa_HwUninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>6191</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecUpdateRxSa() is called with HW module not
    initialized, an error will be reported to DET with error code ETHIF_E_HW_NOT_INITIALIZED.
  
Test Object: 
    EthIf_MacSecUpdateRxSa()
  
Test Precondition: 
    HW controller stub set to E_NOT_OK.
    EthIf Initialized.
  
Test Execution: 
    01: Call EthIf_MacSecUpdateRxSa().
    02: VP(): Verify that DET was called with ETHIF_E_HW_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecUpdateRxSa.HwUninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>343</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1353</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01140_MacSecUpdateRxSa_InvalidCtrlIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>6255</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecUpdateRxSa() is called with invalid parameter
    CtrlIdx, an error will be reported to DET with error code ETHIF_E_INV_CTRL_IDX.
  
Test Object: 
    EthIf_MacSecUpdateRxSa()
  
Test Precondition: 
    HW controller stub set to E_OK.
    EthIf Initialized.
  
Test Execution: 
    01: Call EthIf_MacSecUpdateRxSa().
    02: VP(): Verify that DET was called with ETHIF_E_INV_CTRL_IDX and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecUpdateRxSa.InvalidCtrlIdx</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>344</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1354</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01141_MacSecUpdateRxSa_InvalidAn</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>6319</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecUpdateRxSa() is called with invalid parameter
    An, an error will be reported to DET with error code ETHIF_E_INV_PARAM.
  
Test Object: 
    EthIf_MacSecUpdateRxSa()
  
Test Precondition: 
    HW controller stub set to E_OK.
    EthIf Initialized.
  
Test Execution: 
    01: Call EthIf_MacSecUpdateRxSa().
    02: VP(): Verify that DET was called with ETHIF_E_INV_PARAM and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecUpdateRxSa.InvalidAn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>345</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1355</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01142_MacSecDeleteRxSa_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>6383</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecDeleteRxSa() is called with module not
    initialized, an error will be reported to DET with error code ETHIF_E_NOT_INITIALIZED.
  
Test Object: 
    EthIf_MacSecDeleteRxSa()
  
Test Precondition: 
    HW controller stub set to E_OK.
    EthIf Uninitialized.
  
Test Execution: 
    01: Call EthIf_MacSecDeleteRxSa().
    02: VP(): Verify that DET was called with ETHIF_E_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecDeleteRxSa.Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>346</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1356</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01143_MacSecDeleteRxSa_HwUninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>6441</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecDeleteRxSa() is called with HW module not
    initialized, an error will be reported to DET with error code ETHIF_E_HW_NOT_INITIALIZED.
  
Test Object: 
    EthIf_MacSecDeleteRxSa()
  
Test Precondition: 
    HW controller stub set to E_NOT_OK.
    EthIf Initialized.
  
Test Execution: 
    01: Call EthIf_MacSecDeleteRxSa().
    02: VP(): Verify that DET was called with ETHIF_E_HW_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecDeleteRxSa.HwUninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>347</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1357</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01144_MacSecDeleteRxSa_InvalidCtrlIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>6501</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecDeleteRxSa() is called with invalid parameter
    CtrlIdx, an error will be reported to DET with error code ETHIF_E_INV_CTRL_IDX.
  
Test Object: 
    EthIf_MacSecDeleteRxSa()
  
Test Precondition: 
    HW controller stub set to E_OK.
    EthIf Initialized.
  
Test Execution: 
    01: Call EthIf_MacSecDeleteRxSa().
    02: VP(): Verify that DET was called with ETHIF_E_INV_CTRL_IDX and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecDeleteRxSa.InvalidCtrlIdx</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>348</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1358</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01145_MacSecDeleteRxSa_InvalidAn</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>6561</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecDeleteRxSa() is called with invalid parameter
    An, an error will be reported to DET with error code ETHIF_E_INV_PARAM.
  
Test Object: 
    EthIf_MacSecDeleteRxSa()
  
Test Precondition: 
    HW controller stub set to E_OK.
    EthIf Initialized.
  
Test Execution: 
    01: Call EthIf_MacSecDeleteRxSa().
    02: VP(): Verify that DET was called with ETHIF_E_INV_PARAM and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecDeleteRxSa.InvalidAn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>349</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1359</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01146_MacSecGetTxNextPn_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>6621</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecGetTxSaNextPn() is called with module not
    initialized, an error will be reported to DET with error code ETHIF_E_NOT_INITIALIZED.
  
Test Object: 
    EthIf_MacSecGetTxSaNextPn()
  
Test Precondition: 
    HW controller stub set to E_OK.
    EthIf Uninitialized.
  
Test Execution: 
    01: Call EthIf_MacSecGetTxSaNextPn().
    02: VP(): Verify that DET was called with ETHIF_E_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecGetTxSaNextPn.Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>350</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1360</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01147_MacSecGetTxNextPn_HwUninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>6680</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecGetTxSaNextPn() is called with  HW module not
    initialized, an error will be reported to DET with error code ETHIF_E_HW_NOT_INITIALIZED.
  
Test Object: 
    EthIf_MacSecGetTxSaNextPn()
  
Test Precondition: 
    HW controller stub set to E_NOT_OK.
    EthIf Initialized.
  
Test Execution: 
    01: Call EthIf_MacSecGetTxSaNextPn().
    02: VP(): Verify that DET was called with ETHIF_E_HW_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecGetTxSaNextPn.HwUninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>351</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1361</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01148_MacSecGetTxNextPn_InvalidCtrlIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>6741</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecGetTxSaNextPn() is called with invalid parameter
    CtrlIdx, an error will be reported to DET with error code ETHIF_E_INV_CTRL_IDX.
  
Test Object: 
    EthIf_MacSecGetTxSaNextPn()
  
Test Precondition: 
    HW controller stub set to E_OK.
    EthIf Initialized.
  
Test Execution: 
    01: Call EthIf_MacSecGetTxSaNextPn().
    02: VP(): Verify that DET was called with ETHIF_E_INV_CTRL_IDX and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecGetTxSaNextPn.InvalidCtrlIdx</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>352</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1362</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01149_MacSecGetTxNextPn_InvalidPointer</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>6803</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecGetTxSaNextPn() is called with invalid parameter
    NextPnPtr, an error will be reported to DET with error code ETHIF_E_PARAM_POINTER.
  
Test Object: 
    EthIf_MacSecGetTxSaNextPn()
  
Test Precondition: 
    HW controller stub set to E_OK.
    EthIf Initialized.
  
Test Execution: 
    01: Call EthIf_MacSecGetTxSaNextPn().
    02: VP(): Verify that DET was called with ETHIF_E_PARAM_POINTER and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecGetTxSaNextPn.InvalidPointer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>353</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1363</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01150_MacSecGetTxNextPn_InvalidAn</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>6864</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecGetTxSaNextPn() is called with invalid parameter
    An, an error will be reported to DET with error code ETHIF_E_INV_PARAM.
  
Test Object: 
    EthIf_MacSecGetTxSaNextPn()
  
Test Precondition: 
    HW controller stub set to E_OK.
    EthIf Initialized.
  
Test Execution: 
    01: Call EthIf_MacSecGetTxSaNextPn().
    02: VP(): Verify that DET was called with ETHIF_E_INV_PARAM and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecGetTxSaNextPn.InvalidAn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>354</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1364</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01151_MacSecStatsNotification_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>6926</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecGetMacSecStatsNotification() is called with module
    not initalized, an error will be reported to DET with error code ETHIF_E_NOT_INITIALIZED.
  
Test Object: 
    EthIf_MacSecGetMacSecStatsNotification()
  
Test Precondition: 
    HW controller stub set to E_OK.
    EthIf Uninitialized.
  
Test Execution: 
    01: Call EthIf_MacSecGetMacSecStatsNotification().
    02: VP(): Verify that DET was called with ETHIF_E_NOT_INITIALIZED.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecGetMacSecStatsNotification.Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>355</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1365</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01152_MacSecStatsNotification_InvalidCtrlIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>6981</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecGetMacSecStatsNotification() is called with invalid
    parameter CtrlIdx, an error will be reported to DET with error code ETHIF_E_INV_CTRL_IDX.
  
Test Object: 
    EthIf_MacSecGetMacSecStatsNotification()
  
Test Precondition: 
    HW controller stub set to E_OK.
    EthIf Initialized.
  
Test Execution: 
    01: Call EthIf_MacSecGetMacSecStatsNotification().
    02: VP(): Verify that DET was called with ETHIF_E_INV_CTRL_IDX.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecGetMacSecStatsNotification.InvalidCtrlIdx</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>356</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1366</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01153_MacSecStatsNotification_InvalidPointer</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>7039</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecGetMacSecStatsNotification() is called with invalid
    parameter MacSecStatsPtr, an error will be reported to DET with error code ETHIF_E_PARAM_POINTER.
  
Test Object: 
    EthIf_MacSecGetMacSecStatsNotification()
  
Test Precondition: 
    HW controller stub set to E_OK.
    EthIf Initialized.
  
Test Execution: 
    01: Call EthIf_MacSecGetMacSecStatsNotification().
    02: VP(): Verify that DET was called with ETHIF_E_PARAM_POINTER.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecGetMacSecStatsNotification.InvalidPointer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>357</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1367</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01154_MacSecOperational_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>7096</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecOperational() is called with module not
    initialized, an error will be reported to DET with error code ETHIF_E_NOT_INITIALIZED.
  
Test Object: 
    EthIf_MacSecOperational()
  
Test Precondition: 
    HW controller stub set to E_OK.
    EthIf Uninitialized.
  
Test Execution: 
    01: Call EthIf_MacSecOperational().
    02: VP(): Verify that DET was called with ETHIF_E_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecOperational.Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>358</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1368</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01155_MacSecOperational_HwUninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>7154</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecOperational() is called with HW module not
    initialized, an error will be reported to DET with error code ETHIF_E_HW_NOT_INITIALIZED.
  
Test Object: 
    EthIf_MacSecOperational()
  
Test Precondition: 
    HW controller stub set to E_NOT_OK.
    EthIf Initialized.
  
Test Execution: 
    01: Call EthIf_MacSecOperational().
    02: VP(): Verify that DET was called with ETHIF_E_HW_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecOperational.HwUninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>359</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1369</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01156_MacSecOperational_InvalidCtrlIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>7214</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecOperational() is called with invalid parameter
    CtrlIdx, an error will be reported to DET with error code ETHIF_E_INV_CTRL_IDX.
  
Test Object: 
    EthIf_MacSecOperational()
  
Test Precondition: 
    HW controller stub set to E_OK.
    EthIf Initialized.
  
Test Execution: 
    01: Call EthIf_MacSecOperational().
    02: VP(): Verify that DET was called with ETHIF_E_INV_CTRL_IDX and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecOperational.InvalidCtrlIdx</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>360</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1370</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01157_MacSecControlledPortEnabled_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>7274</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecSetControlledPortEnabled() is called with
    module not initialized, an error will be reported to DET with error code ETHIF_E_NOT_INITIALIZED.
  
Test Object: 
    EthIf_MacSecSetControlledPortEnabled()
  
Test Precondition: 
    HW controller stub set to E_OK.
    EthIf Uninitialized.
  
Test Execution: 
    01: Call EthIf_MacSecSetControlledPortEnabled().
    02: VP(): Verify that DET was called with ETHIF_E_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecSetControlledPortEnabled.Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>361</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1371</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01158_MacSecControlledPortEnabled_HwUninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>7332</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecSetControlledPortEnabled() is called with HW
    module not initialized, an error will be reported to DET with error code ETHIF_E_NOT_INITIALIZED.
  
Test Object: 
    EthIf_MacSecSetControlledPortEnabled()
  
Test Precondition: 
    HW controller stub set to E_NOT_OK.
    EthIf Initialized.
  
Test Execution: 
    01: Call EthIf_MacSecSetControlledPortEnabled().
    02: VP(): Verify that DET was called with ETHIF_E_HW_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecSetControlledPortEnabled.HwUninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>362</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1372</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01159_MacSecControlledPortEnabled_InvalidCtrlIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>7392</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecSetControlledPortEnabled() is called with
    invalid parameter CtrlIdx, an error will be reported to DET with error code ETHIF_E_INV_CTRL_IDX.
  
Test Object: 
    EthIf_MacSecSetControlledPortEnabled()
  
Test Precondition: 
    HW controller stub set to E_OK.
    EthIf Initialized.
  
Test Execution: 
    01: Call EthIf_MacSecSetControlledPortEnabled().
    02: VP(): Verify that DET was called with ETHIF_E_INV_CTRL_IDX and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecSetControlledPortEnabled.InvalidCtrlIdx</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>363</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1373</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01160_MacSecUpdateSecYNotification_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>7452</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecUpdateSecYNotification() is called with module not
    initialized, an error will be reported to DET with error code ETHIF_E_NOT_INITIALIZED.
  
Test Object: 
    EthIf_MacSecUpdateSecYNotification()
  
Test Precondition: 
    HW controller stub set to E_OK.
    EthIf Uninitialized.
  
Test Execution: 
    01: Call EthIf_MacSecUpdateSecYNotification().
    02: VP(): Verify that DET was called with ETHIF_E_NOT_INITIALIZED.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecUpdateSecYNotification.Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>364</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1374</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01161_MacSecUpdateSecYNotification_InvalidCtrlIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>7506</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecUpdateSecYNotification() is called with invalid
    parameter CtrlIdx, an error will be reported to DET with error code ETHIF_E_INV_CTRL_IDX.
  
Test Object: 
    EthIf_MacSecUpdateSecYNotification()
  
Test Precondition: 
    HW controller stub set to E_OK.
    EthIf Initialized.
  
Test Execution: 
    01: Call EthIf_MacSecUpdateSecYNotification().
    02: VP(): Verify that DET was called with ETHIF_E_INV_CTRL_IDX.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecUpdateSecYNotification.InvalidCtrlIdx</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>365</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1375</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01162_MacSecAddTxSaNotification_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>7562</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecAddTxSaNotification() is called with module not
    initialized, an error will be reported to DET with error code ETHIF_E_NOT_INITIALIZED.
  
Test Object: 
    EthIf_MacSecAddTxSaNotification()
  
Test Precondition: 
    HW controller stub set to E_OK.
    EthIf Uninitialized.
  
Test Execution: 
    01: Call EthIf_MacSecAddTxSaNotification().
    02: VP(): Verify that DET was called with ETHIF_E_NOT_INITIALIZED.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecAddTxSaNotification.Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>366</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1376</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01163_MacSecAddTxSaNotification_InvalidCtrlIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>7616</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecAddTxSaNotification() is called with invalid parameter
    CtrlIdx, an error will be reported to DET with error code ETHIF_E_INV_CTRL_IDX.
  
Test Object: 
    EthIf_MacSecAddTxSaNotification()
  
Test Precondition: 
    HW controller stub set to E_OK.
    EthIf Initialized.
  
Test Execution: 
    01: Call EthIf_MacSecAddTxSaNotification().
    02: VP(): Verify that DET was called with ETHIF_E_INV_CTRL_IDX.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecAddTxSaNotification.InvalidCtrlIdx</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>367</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1377</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01164_MacSecAddRxSaNotification_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>7672</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecAddRxSaNotification() is called with module not
    initialized, an error will be reported to DET with error code ETHIF_E_NOT_INITIALIZED.
  
Test Object: 
    EthIf_MacSecAddRxSaNotification()
  
Test Precondition: 
    HW controller stub set to E_OK.
    EthIf Uninitialized.
  
Test Execution: 
    01: Call EthIf_MacSecAddRxSaNotification().
    02: VP(): Verify that DET was called with ETHIF_E_NOT_INITIALIZED.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecAddRxSaNotification.Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>368</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1378</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01165_MacSecAddRxSaNotification_InvalidCtrlIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>7726</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_MacSecAddRxSaNotification() is called with invalid parameter
    CtrlIdx, an error will be reported to DET with error code ETHIF_E_INV_CTRL_IDX.
  
Test Object: 
    EthIf_MacSecAddRxSaNotification()
  
Test Precondition: 
    HW controller stub set to E_OK.
    EthIf Initialized.
  
Test Execution: 
    01: Call EthIf_MacSecAddRxSaNotification().
    02: VP(): Verify that DET was called with ETHIF_E_INV_CTRL_IDX.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.MacSecAddRxSaNotification.InvalidCtrlIdx</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>369</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1379</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01166_EthIf_RxIndication_InvalidPhysAddrPtr</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest01_DetChecks/source/application/EthIf_ConTest01_DetChecks.c</sourcefile>
      <sourceline>7782</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_RxIndication() is called with invalid PhysAddrPtr,
    ETHIF_E_PARAM_POINTER will be reported to DET.
  
Test Object: 
    EthIf_RxIndication().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_RxIndication() using an invalid PhysAddrPtr.
    02: VP(): Verify that DET was called with ETHIF_E_PARAM_POINTER.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.RxIndication.PhysAddrPtr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>386</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1380</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EthIf_ConTest03000_TxConfirmation_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest03_UL/source/application/EthIf_ConTest03_UL.c</sourcefile>
      <sourceline>45</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_TxConfirmation() is called when the module is not
    initialized, ETHIF_E_NOT_INITIALIZED will be reported to DET.
  
Test Object: 
    EthIf_TxConfirmation()
  
Test Precondition: 
  
Test Execution: 
    01: Call EthIf_TxConfirmation() in UNINIT state.
    02: VP(EthIf.ASR43.SWS_EthIf_00092):
        Verify that DET was called with ETHIF_E_NOT_INITIALIZED.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00092</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>45</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1381</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest03001_TxConfirmation_InvalidCtrlIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest03_UL/source/application/EthIf_ConTest03_UL.c</sourcefile>
      <sourceline>96</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_TxConfirmation() is called using an invalid CtrlIdx
    ETHIF_E_INV_CTRL_IDX will be reported to DET.
  
Test Object: 
    EthIf_TxConfirmation()
  
Test Precondition: None.
Test Execution: 
    01: Call EthIf_TxConfirmation() using invalid CtrlIdx.
    02: VP(EthIf.ASR43.SWS_EthIf_00093):
        Verify that DET was called with ETHIF_E_INV_CTRL_IDX.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00093</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>455</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1382</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest03002_Multiple_UL_RX_TrcvLinkStateChg</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest03_UL/source/application/EthIf_ConTest03_UL.c</sourcefile>
      <sourceline>149</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that EthIf_MainFunctionRx() polls EthTrcv_GetLinkState() and detects a state
    change for a certain transceiver, all UL_TrcvLinkStateChg() will be called to notify the state
    change for all EthIfCtrlIdx configured to that transceiver.
  
Test Object: 
    EthIf_MainFunctionRx().
  
Test Precondition: 
    EthIfVLANSupportEnable = STD_ON.
    EthIfTrcvSupportEnable = STD_ON.
    EthIf_Init is called.
    Set EthTrcv_GetLinkState_Stub.LinkStatePtr_Out to ETHTRCV_LINK_STATE_ACTIVE;
  
Test Execution: 
    01: Call EthIf_SetControllerMode() to set the controller and transceiver mode to ACTIVE so the
        link state change can be checked.
    02: Call EthIf_MainFunctionRx().
    03: Verify that EthTrcv_GetLinkState() &amp; EthTrcv_GetPhySignalQualit() were called.
    04: VP(EthIf.ASR43.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange_MultipleUL):
        Verify that UL_TrcvLinkStateChg() was called for all EthIfCtrlIdx configured to the
        respective transceiver.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange_MultipleUL</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1383</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest03003_Multiple_UL_RxIndication_NotVLAN</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest03_UL/source/application/EthIf_ConTest03_UL.c</sourcefile>
      <sourceline>240</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_RxIndication() is called and frame is not VLAN, it shall call
    corresponding configured User_RxIndication() and pass the arguments.
  
Test Object: 
    EthIf_RxIndication().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_RxIndication().
    02: VP(): Verify that User_RxIndication() was called with expected parameters.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.User_RxIndication_MultipleUL</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>191</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1384</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest03004_Multiple_UL_RxIndication_VLAN</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest03_UL/source/application/EthIf_ConTest03_UL.c</sourcefile>
      <sourceline>303</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_RxIndication() is called and frame is VLAN, it shall call
    corresponding configured User_RxIndication() and pass the arguments.
  
Test Object: 
    EthIf_RxIndication().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_RxIndication().
    02: VP(): Verify that User_RxIndication() was called with expected parameters.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.User_RxIndication.VLAN_MultipleUL</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1385</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest03005_UL_RX_TrcvLinkStateChg</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest03_UL/source/application/EthIf_ConTest03_UL.c</sourcefile>
      <sourceline>377</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that EthIf_MainFunctionRx() polls EthTrcv_GetLinkState() and detects a state
    change for a certain transceiver, UL_TrcvLinkStateChg() will be called to notify the state
    change for all EthIfCtrlIdx configured to that transceiver.
  
Test Object: 
    EthIf_MainFunctionTx().
  
Test Precondition: 
    EthIfVLANSupportEnable = STD_ON.
    EthIfTrcvSupportEnable = STD_ON.
    EthIf_Init is called.
    Set stub APIs to return mode = active for controller and transceiver.
    Set EthTrcv_GetLinkState_Stub.LinkStatePtr_Out to ETHTRCV_LINK_STATE_ACTIVE;
  
Test Execution: 
    01: Call EthIf_SetControllerMode() to set the controller and transceiver mode to ACTIVE.
    02: Call EthIf_MainFunctionTx().
    03: Verify that EthTrcv_GetLinkState() &amp; EthTrcv_GetPhySignalQuality() were called.
    04: VP(EthIf.ASR43.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange):
        Verify that  UL_TrcvLinkStateChg() was called for all EthIfCtrlIdx configured to the
        respective transceiver.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>130</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1386</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest03006_User_TxConfirmation</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest03_UL/source/application/EthIf_ConTest03_UL.c</sourcefile>
      <sourceline>468</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that EthIf_TxConfirmation() will call User_TxConfirmation and
  
Test Object: 
    EthIf_TxConfirmation().
  
Test Precondition: 
    EthIfVLANSupportEnable = STD_ON.
    EthIfTrcvSupportEnable = STD_ON.
    EthIf_Init is called.
  
Test Execution: 
    01: Call EthIf_TxConfirmation().
    02: VP(): Verify that UL1_TxConfirmation() and UL2_TxConfirmation() were called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00125</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>478</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1387</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest03007_UL_TrcvLinkStateChg_TrcvRef_False</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest03_UL/source/application/EthIf_ConTest03_UL.c</sourcefile>
      <sourceline>526</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that EthIf_MainFunctionRx() will not poll EthTrcv_GetLinkState() for a
    channel that has EthIfEthTrcvRef false, and will directly call the UL.
  
Test Object: 
    EthIf_MainFunctionRx().
  
Test Precondition: 
    - EthIfEthTrcvRef false.
    - Controller under test is initialized and active.
  
Test Execution: 
    01: Call EthIf_SetControllerMode() to set the controller and transceiver mode to ACTIVE.
    02: Call EthIf_MainFunctionRx().
    03: VP():
        Verify that UL_TrcvLinkStateChg() was called for all EthIfCtrlIdx configured to the
        respective transceiver.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.EthIf_MainFunctionRx.NoEthTrcv</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>198</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1388</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest03008_UL_TrcvLinkStateChg_GetLinkState_NOTOK</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest03_UL/source/application/EthIf_ConTest03_UL.c</sourcefile>
      <sourceline>604</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthTrcv_GetLinkState returns E_NOT_OK, EthIf_MainFunctionRx() will
    poll EthTrcv_GetLinkState() but UL_TrcvLinkStateChg() will not be called.
  
Test Object: 
    EthIf_MainFunctionRx().
  
Test Precondition: 
    - EthTrcv_GetLinkState returns E_NOT_OK.
  
Test Execution: 
    01: Call EthIf_SetControllerMode() to set the controller and transceiver mode to ACTIVE.
    02: Set EthTrcv_GetLinkState_Stub.RetVal to E_NOT_OK.
    03: Call EthIf_MainFunctionRx().
    04: VP(EthIf.EB.EthIf_MainFunctionRx.EthTrcvGetLinkStateError): Verify that
        EthTrcv_GetLinkState() was called.
    05: VP(EthIf.EB.EthIf_MainFunctionRx.EthTrcvGetLinkStateError): Verify that
        UL_TrcvLinkStateChg() was not called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.EthIf_MainFunctionRx.EthTrcvGetLinkStateError</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>197</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1389</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest03009_UL_Cbk_TxConfirmation</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest03_UL/source/application/EthIf_ConTest03_UL.c</sourcefile>
      <sourceline>693</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that EthIf_Cbk_TxConfirmation() will call all configured UL.
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01: Call EthIf_Cbk_TxConfirmation().
    02: VP(): Verify that UL1_TxConfirmation() and UL2_TxConfirmation() were called with
        correct parameters.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.ETHIF091_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>148</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1390</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest03010_RxIndication_NotConf_FrameType</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest03_UL/source/application/EthIf_ConTest03_UL.c</sourcefile>
      <sourceline>757</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that calling EthIf_RxIndication() with a FrameType that is not configured it
    won't call UL.
  
Test Object: 
    EthIf_RxIndication().
  
Test Precondition: 
    EthIf initialized.
    Use a frame type that is not configured in EthIfFrameOwnerConfig.
  
Test Execution: 
    01: Set the frame to have an invalid frame type: 0x0801U- not configured in
        EthIfFrameOwnerConfig.
    02: Call EthIf_RxIndication() using the frame set in step 1.
    03: VP(): Verify that UL was not called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.EthIf_RxIndication.NotConfiguredFrameType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>193</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1391</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest03011_MainFunctionRx_HW_GetsDown</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest03_UL/source/application/EthIf_ConTest03_UL.c</sourcefile>
      <sourceline>827</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if both controller and transceiver
    are set to mode DOWN. The next main function call will inform all upper layer by calling
    UL_TrcvLinkStateChg(ETHTRCV_LINK_STATE_DOWN).
  
Test Object: 
    - EthIf_MainFunctionRx()
  
Test Precondition: 
    - EthIf initialized.
    - Controller and transceiver under test initialized.
    - Controller and transceiver is set to active.
    - Call any main function to set the controller and transceiver internally active.
  
Test Execution: 
    01: Call EthIf_SetControllerMode(ETH_MODE_DOWN).
    03: Call EthIf_MainFunctionRx().
    04: VP: Verify that UL_TrcvLinkStateChg(ETHTRCV_LINK_STATE_DOWN) is called for all configured
        upper layers.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MainFunctionRx.HW_GetsDown</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>181</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1392</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest03012_User_TxConfirmation_NOK</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest03_UL/source/application/EthIf_ConTest03_UL.c</sourcefile>
      <sourceline>914</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that EthIf_TxConfirmation() is called with Result E_NOT_OK, it will
    not call User_TxConfirmation.
  
Test Object: 
    EthIf_TxConfirmation().
  
Test Precondition: 
    EthIf_Init is called.
  
Test Execution: 
    01: Call EthIf_TxConfirmation() with Result E_NOT_OK.
    02: VP(): Verify that UL is not informed as Result of EthIf_TxConfirmation() is not E_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00125.Result_E_NOT_OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>195</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1393</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest03013_MultipleFrameOwners</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest03_UL/source/application/EthIf_ConTest03_UL.c</sourcefile>
      <sourceline>961</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_RxIndication() is called with frame type that is assigned
    only to the one User_RxIndication(), User_RxIndication will be called only once. If frame type
    is configured on two or more User_RxIndication(), when received such frame type, all
    User_RxIndication() functions will be called.
  
Test Object: 
    EthIf_RxIndication().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_RxIndication() with frame type that has only one User_RxIndication().
    02: VP(): Verify that User_RxIndication() was called with expected parameters.
    03: Call EthIf_RxIndication() with frame type that has multiple User_RxIndication().
    04: VP(): Verify that all User_RxIndication() were called with expected parameters.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_00584</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>901</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1394</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest03014_RxIndicationDummy</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest03_UL/source/application/EthIf_ConTest03_UL.c</sourcefile>
      <sourceline>1052</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_RxIndication() is called with frame type that is assigned
    to the EthIf_Up_RxIndicationDummy(),nothing will happen.
  
Test Object: 
    EthIf_RxIndication().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_RxIndication() with frame type that has User_RxIndication().
    02: VP(): Verify that User_RxIndication() was called with expected parameters.
    03: Call EthIf_RxIndication() with frame type that has EthIf_Up_RxIndicationDummy().
    04: VP(): Verify that when EthIf_Up_RxIndicationDummy() is called, nothing happened.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.RxIndication.EthIf_Up_RxIndicationDummy</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1133</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1395</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EthIf_ConTest04001_WriteMii_MiiIsFree</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest04_MIIExtension/source/application/EthIf_ConTest04_MIIextension.c</sourcefile>
      <sourceline>149</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that EthIf_WriteMii() calls Eth_WriteMii() if no other API
    access the MII interface of the same Ethernet transceiver.
  
Test Object: 
     * EthIf_WriteMii
  
Test Precondition: 
    EthIfTrcvSupportEnable = STD_ON.
    EthIfMiiApiEnable = STD_ON.
    EthIf_Init is called.
  
Test Execution: 
    01: Call EthIf_WriteMii() with CtrlIdx = 0 and RegIdx = 0
    02: Verify that EthIf_WriteMii() returns E_OK
    03: Verify that Eth_WriteMii() was called with the correct Ids
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.WriteMii.Behaviour</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>206</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1396</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest04002_ReadMii_MiiIsFree</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest04_MIIExtension/source/application/EthIf_ConTest04_MIIextension.c</sourcefile>
      <sourceline>212</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that EthIf_ReadMii() calls Eth_ReadMii() if no other API
    access the MII interface of the same Ethernet transceiver.
  
Test Object: 
     * EthIf_ReadMii
  
Test Precondition: 
    EthIfTrcvSupportEnable = STD_ON.
    EthIfMiiApiEnable = STD_ON.
    EthIf_Init is called.
  
Test Execution: 
    01: Call EthIf_ReadMii() with CtrlIdx = 0 and RegIdx = 0
    02: Verify that EthIf_ReadMii() returns E_OK
    03: Verify that EthIf_ReadMii() was called with the correct Ids
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.ReadMii.Behaviour</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>205</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1397</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest04003_ReadMii_vs_GetTransceiverMode</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest04_MIIExtension/source/application/EthIf_ConTest04_MIIextension.c</sourcefile>
      <sourceline>275</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that EthIf_ReadMii() is not interrupted by the the call to
    EthTrcv_GetTransceiverMode() in the same context.
  
Test Object: 
     * EthIf_ReadMii
     * EthTrcv_GetTransceiverMode
  
Test Precondition: 
    EthIfTrcvSupportEnable = STD_ON.
    EthIfMiiApiEnable = STD_ON.
    EthIf_Init is called.
    Respective Ethernet controller is active.
  
Test Execution: 
    01: Set Callout of Eth_ReadMii_Stub.Callout to Tst_ReadMiiCallout_GetTransceiverMode
        to simulate an interruption of EthIf_ReadMii by EthTrcv_GetTransceiverMode during
        Eth_ReadMii.
    02: Call EthIf_ReadMii() with CtrlIdx = 0 and RegIdx = 0
    03: VP(EthIf.EB.MIIExtension.ReadMii.Behaviour)
        Verify that Eth_ReadMii() was called with the correct Ids
    04: VP(EthIf.EB.MIIExtension.GetTransceiverMode.CheckMiiAccessFlag.Active)
        Verify that EthTrcv_GetTransceiverMode() was not called via EthIf_MainFunctionState().
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.ReadMii.Behaviour</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>205</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.GetTransceiverMode.CheckMiiAccessFlag.Active</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>216</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1398</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest04004_WriteMii_vs_SetTransceiverMode</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest04_MIIExtension/source/application/EthIf_ConTest04_MIIextension.c</sourcefile>
      <sourceline>364</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that EthIf_WriteMii() is not interrupted by the function
    EthTrcv_SetTransceiverMode() in the same context.
  
Test Object: 
     * EthIf_WriteMii
     * EthTrcv_SetTransceiverMode
  
Test Precondition: 
    EthIfTrcvSupportEnable = STD_ON.
    EthIfMiiApiEnable = STD_ON.
    EthIf_Init is called.
  
Test Execution: 
    01: Set Callout of Eth_WriteMii_Stub.Callout to Tst_WriteMiiCallout_SetTransceiverMode
        to simulate an interruption of EthIf_WriteMii by EthIf_SetTransceiverMode during
        Eth_WriteMii.
    02: Call EthIf_WriteMii() with CtrlIdx = 0 and RegIdx = 0
    03: VP(EthIf.EB.MIIExtension.WriteMii.Behaviour)
        Verify that Eth_WriteMii() was called with the correct Ids.
    04: VP(EthIf.EB.MIIExtension.SetTransceiverMode.CheckMiiAccessFlag.Active)
        Verify that EthTrcv_SetTransceiverMode() was not called via
        EthIf_SetControllerMode().
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.WriteMii.Behaviour</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>206</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.SetTransceiverMode.CheckMiiAccessFlag.Active</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>214</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1399</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest04005_SetTransceiverMode_vs_WriteMii</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest04_MIIExtension/source/application/EthIf_ConTest04_MIIextension.c</sourcefile>
      <sourceline>442</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that EthTrcv_SetTransceiverMode() is not interrupted by the function
    EthIf_WriteMii() in the same context.
  
Test Object: 
     * EthTrcv_SetTransceiverMode
     * EthIf_WriteMii
  
Test Precondition: 
    EthIfTrcvSupportEnable = STD_ON.
    EthIfMiiApiEnable = STD_ON.
    EthIf_Init is called.
  
Test Execution: 
    01: Set Callout of EthTrcv_SetTransceiverMode_Stub.Callout to Tst_SetTransceiverMode_Callout_WriteMii
        to simulate an interruption of EthTrcv_SetTransceiverMode by EthIf_WriteMii during
        EthIf_SetControllerMode.
    02: Call EthIf_SetTransceiverMode() with CtrlIdx = 0 and ETHTRCV_MODE_ACTIVE
    03: VP(EthIf.EB.MIIExtension.SetTransceiverMode.CheckMiiAccessFlag.Not_Active)
        Verify that EthTrcv_SetTransceiverMode() was called the correct Ids
    04: VP(EthIf.EB.MIIExtension.WriteMii.Behaviour)
        Verify that Eth_WriteMii() was not called via EthIf_WriteMii()
        and EthIf_WriteMii() returns E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.SetTransceiverMode.CheckMiiAccessFlag.Not_Active</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>213</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.WriteMii.Behaviour</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>206</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1400</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest04006_GetTransceiverMode_vs_ReadMii</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest04_MIIExtension/source/application/EthIf_ConTest04_MIIextension.c</sourcefile>
      <sourceline>521</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that the call to EthTrcv_GetTransceiverMode() will not be interrupted by
    the call to EthIf_ReadMii() in the same context.
  
Test Object: 
     * EthTrcv_GetTransceiverMode
     * EthIf_ReadMii
  
Test Precondition: 
    EthIfTrcvSupportEnable = STD_ON.
    EthIfMiiApiEnable = STD_ON.
    EthIf_Init is called.
  
Test Execution: 
    01: Set Callout of EthTrcv_GetTransceiverMode_Stub.Callout to Tst_GetTransceiverMode_Callout_ReadMii
        to simulate an interruption of EthTrcv_GetTransceiverMode by EthIf_ReadMii during
        EthIf_SetControllerMode.
    02: Call EthIf_SetControllerMode() with CtrlIdx = 0
    03: VP(EthIf.EB.MIIExtension.GetTransceiverMode.CheckMiiAccessFlag.Not_Active)
        Verify that EthTrcv_GetTransceiverMode() was called the correct Ids.
    04: VP(EthIf.EB.MIIExtension.ReadMii.Behaviour)
        Verify that Eth_ReadMii() was not called via
        EthIf_ReadMii() and EthIf_ReadMii returns E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.GetTransceiverMode.CheckMiiAccessFlag.Not_Active</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>215</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.ReadMii.Behaviour</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>205</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1401</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest04009_MainFunctionRx_InactiveMiiAccessFlag</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest04_MIIExtension/source/application/EthIf_ConTest04_MIIextension.c</sourcefile>
      <sourceline>603</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that EthIf_MainFunctionRx() shall perform API calls to EthTrcv module if
    the Mii access flag is not active. Functions EthTrcv_GetTransceiverMode and EthTrcv_GetLinkState
    shall be called only once.
  
Test Object: 
     * EthIf_MainFunctionRx
     * EthTrcv_GetTransceiverMode
     * EthTrcv_GetLinkState
  
Test Precondition: 
    EthIfTrcvSupportEnable = STD_ON.
    EthIfMiiApiEnable = STD_ON.
    EthIf_Init is called
    EthIf_SetControllerMode is called
  
Test Execution: 
    01: Call EthIf_MainFunctionRx() with Mii access flag set to inactive
    02: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag)
         Check that APIs were called with correct IDs
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>218</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1402</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest04011_MainFunctionRx_ActiveMiiAccessFlag</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest04_MIIExtension/source/application/EthIf_ConTest04_MIIextension.c</sourcefile>
      <sourceline>671</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that EthIf_MainFunctionRx() shall not perform any API calls to EthTrcv
    module if the Mii access flag is active. Functions EthTrcv_GetTransceiverMode and
    EthTrcv_GetLinkState shall be called only once because of the active Mii flag.
  
Test Object: 
     * EthIf_MainFunctionRx
     * EthTrcv_GetTransceiverMode
     * EthTrcv_GetLinkState
  
Test Precondition: 
    EthIfTrcvSupportEnable = STD_ON.
    EthIfMiiApiEnable = STD_ON.
    EthIf_Init is called
    EthIf_SetControllerMode is called
  
Test Execution: 
    01: Set the Callout functions for EthTrcv_GetTransceiverMode_Stub and EthTrcv_GetLinkState_Stub
        to function to call MainFunction_Rx again during execution of EthIf_GetTransceiverMode and
        EthIfGetLinkState to simulate an second access during an ongoing access to the same Mii
        interface(Mii flags shall be set to active in second MII access)
    02: Call EthIf_MainFunctionRx() with Mii access flag set to active
    03: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag)
         Check that APIs were called with correct IDs
         Verify that functions EthTrcv_GetTransceiverMode and EthTrcv_GetLinkState were called once
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>218</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1403</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest04013_SetPhyLoopbackMode_ActiveMiiAccessFlag</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest04_MIIExtension/source/application/EthIf_ConTest04_MIIextension.c</sourcefile>
      <sourceline>747</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that EthIf_SetPhyLoopbackMode() shall not forward the call to function
    EthTrcv_SetPhyLoopbackMode if the Mii access flag is active and the function shall return E_NOT_OK.
    It also checks if correct Eth controller idx is locked.
  
Test Object: 
     EthIf_SetPhyLoopbackMode
  
Test Precondition: 
    EthIfTrcvSupportEnable = STD_ON.
    EthIf initialised.
  
Test Execution: 
    01: Set Callout of Eth_ReadMii_Stub.Callout to EthIf_SetPhyLoopbackMode
        to call of EthIf_SetPhyLoopbackMode while Mii access flag is active for given controller.
    02: Call EthIf_ReadMii() with EthIfCtrl_6 (EthIdx=2).
    03: VP(EthIf.EB.MIIExtension.EthIf_SetPhyLoopbackMode.CheckMiiAccessFlag.Active)
        Verify that EthTrcv_SetPhyLoopbackMode() was not called
        Verify that call of EthIf_SetPhyLoopbackMode() returned E_NOT_OK. Return code of the
        EthIf_SetPhyLoopbackMode is returned through a global variable MiiAccessFlagRetCode_Callout.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.EthIf_SetPhyLoopbackMode.CheckMiiAccessFlag.Active</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>245</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1404</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest04014_SetPhyTxMode_ActiveMiiAccessFlag</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest04_MIIExtension/source/application/EthIf_ConTest04_MIIextension.c</sourcefile>
      <sourceline>818</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that EthIf_SetPhyTxMode() shall not forward the call to function
    EthTrcv_SetPhyTxMode if the Mii access flag is active and the function shall return E_NOT_OK.
    It also checks if correct Eth controller idx is locked.
  
Test Object: 
     EthIf_SetPhyTxMode
  
Test Precondition: 
    EthIfTrcvSupportEnable = STD_ON.
    EthIf initialised.
  
Test Execution: 
    01: Set Callout of Eth_ReadMii_Stub.Callout to EthIf_SetPhyTxMode
        to call of EthIf_SetPhyTxMode while Mii access flag is active for given controller.
    02: Call EthIf_ReadMii() with EthIfCtrl_6 (EthIdx=2).
    03: VP(EthIf.EB.MIIExtension.EthIf_SetPhyTxMode.CheckMiiAccessFlag.Active)
        Verify that EthTrcv_SetPhyTxMode() was not called
        Verify that call of EthIf_SetPhyTxMode() returned E_NOT_OK. Return code of the
        EthIf_SetPhyTxMode is returned through a global variable MiiAccessFlagRetCode_Callout.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.EthIf_SetPhyTxMode.CheckMiiAccessFlag.Active</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>246</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1405</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest04015_GetCableDiagnosticsResult_ActiveMiiAccessFlag</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest04_MIIExtension/source/application/EthIf_ConTest04_MIIextension.c</sourcefile>
      <sourceline>889</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that EthIf_GetCableDiagnosticsResult() shall not forward the call to function
    EthTrcv_GetCableDiagnosticsResult if the Mii access flag is active and the function shall return
    E_NOT_OK. It also checks if correct Eth controller idx is locked.
  
Test Object: 
     EthIf_GetCableDiagnosticsResult
  
Test Precondition: 
    EthIfTrcvSupportEnable = STD_ON.
    EthIf initialised.
  
Test Execution: 
    01: Set Callout of Eth_ReadMii_Stub.Callout to EthIf_GetCableDiagnosticsResult
        to call of EthIf_GetCableDiagnosticsResult while Mii access flag is active for given controller.
    02: Call EthIf_ReadMii() with EthIfCtrl_6 (EthIdx=2).
    03: VP(EthIf.EB.MIIExtension.EthIf_GetCableDiagnosticsResult.CheckMiiAccessFlag.Active)
        Verify that EthTrcv_GetCableDiagnosticsResult() was not called
        Verify that call of EthIf_GetCableDiagnosticsResult() returned E_NOT_OK. Return code of the
        EthIf_GetCableDiagnosticsResult is returned through a global variable MiiAccessFlagRetCode_Callout.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.EthIf_GetCableDiagnosticsResult.CheckMiiAccessFlag.Active</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>247</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1406</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest04016_GetPhyIdentifier_ActiveMiiAccessFlag</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest04_MIIExtension/source/application/EthIf_ConTest04_MIIextension.c</sourcefile>
      <sourceline>960</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that EthIf_GetPhyIdentifier() shall not forward the call to function
    EthTrcv_GetPhyIdentifier if the Mii access flag is active and the function shall return
    E_NOT_OK. It also checks if correct Eth controller idx is locked.
  
Test Object: 
     EthIf_GetPhyIdentifier
  
Test Precondition: 
    EthIfTrcvSupportEnable = STD_ON.
    EthIf initialised.
  
Test Execution: 
    01: Set Callout of Eth_ReadMii_Stub.Callout to EthIf_GetPhyIdentifier
        to call of EthIf_GetPhyIdentifier while Mii access flag is active for given controller.
    02: Call EthIf_ReadMii() with EthIfCtrl_6 (EthIdx=2).
    03: VP(EthIf.EB.MIIExtension.EthIf_GetPhyIdentifier.CheckMiiAccessFlag.Active)
        Verify that EthTrcv_GetPhyIdentifier() was not called
        Verify that call of EthIf_GetPhyIdentifier() returned E_NOT_OK. Return code of the
        EthIf_GetPhyIdentifier is returned through a global variable MiiAccessFlagRetCode_Callout.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.EthIf_GetPhyIdentifier.CheckMiiAccessFlag.Active</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>248</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1407</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest04017_GetTrcvSignalQuality_ActiveMiiAccessFlag</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest04_MIIExtension/source/application/EthIf_ConTest04_MIIextension.c</sourcefile>
      <sourceline>1031</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that EthIf_GetTrcvSignalQuality() shall not forward the call to function
    EthTrcv_GetPhySignalQuality if the Mii access flag is active and the function shall return
    E_NOT_OK. It also checks if correct Eth controller idx is locked.
  
Test Object: 
     EthIf_GetTrcvSignalQuality
  
Test Precondition: 
    EthIfTrcvSupportEnable = STD_ON.
    EthIf initialised.
  
Test Execution: 
    01: Set Callout of Eth_ReadMii_Stub.Callout to EthIf_GetTrcvSignalQuality
        to call of EthIf_GetTrcvSignalQuality while Mii access flag is active for given controller.
    02: Call EthIf_ReadMii() with EthIfCtrl_6 (EthIdx=2).
    03: VP(EthIf.EB.MIIExtension.EthIf_GetTrcvSignalQuality.CheckMiiAccessFlag.Active)
        Verify that EthTrcv_GetPhySignalQuality() was not called
        Verify that call of EthIf_GetTrcvSignalQuality() returned E_NOT_OK. Return code of the
        EthIf_GetTrcvSignalQuality is returned through a global variable MiiAccessFlagRetCode_Callout.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.EthIf_GetTrcvSignalQuality.CheckMiiAccessFlag.Active</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>249</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1408</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest04018_SetPhyTestMode_ActiveMiiAccessFlag</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest04_MIIExtension/source/application/EthIf_ConTest04_MIIextension.c</sourcefile>
      <sourceline>1102</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that EthIf_SetPhyTestMode() shall not forward the call to function
    EthTrcv_SetPhyTestMode if the Mii access flag is active and the function shall return
    E_NOT_OK. It also checks if correct Eth controller idx is locked.
  
Test Object: 
     EthIf_SetPhyTestMode
  
Test Precondition: 
    EthIfTrcvSupportEnable = STD_ON.
    EthIf initialised.
  
Test Execution: 
    01: Set Callout of Eth_ReadMii_Stub.Callout to EthIf_SetPhyTestMode
        to call of EthIf_SetPhyTestMode while Mii access flag is active for given controller.
    02: Call EthIf_ReadMii() with EthIfCtrl_6 (EthIdx=2).
    03: VP(EthIf.EB.MIIExtension.EthIf_SetPhyTestMode.CheckMiiAccessFlag.Active)
        Verify that EthTrcv_SetPhyTestMode() was not called
        Verify that call of EthIf_SetPhyTestMode() returned E_NOT_OK. Return code of the
        EthIf_SetPhyTestMode is returned through a global variable MiiAccessFlagRetCode_Callout.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.EthIf_SetPhyTestMode.CheckMiiAccessFlag.Active</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>250</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1409</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest04019_Mii_Blocked</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest04_MIIExtension/source/application/EthIf_ConTest04_MIIextension.c</sourcefile>
      <sourceline>1173</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that EthIf shall not set the link state to down if Mii can not be accessed.
  
Test Object: 
     EthIf_GetLinkState_Internal
  
Test Precondition: 
    EthIfTrcvSupportEnable = STD_ON.
    EthIfMiiApiEnable = STD_ON.
    EthIf_Init is called
    Link state is active
  
Test Execution: 
    01: Call EthIf_ReadMii() with CtrlIdx = 0 and RegIdx = 0.
    02: VP(EthIf.EB.MIIExtension.ReadMii.Behaviour) Verify that EthIf_ReadMii() returns E_OK.
    03: VP(EthIf.EB.MIIExtension.ReadMii.Behaviour) Verify that EthIf_ReadMii() was called with
        the correct Ids.
    04: VP(EthIf.EB.No_MIIExtension) Verify that no functions were called since Mii is not
        available.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.No_MIIExtension</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>231</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1410</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest04038_GetTrcvSignalQuality_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest04_MIIExtension/source/application/EthIf_ConTest04_MIIextension.c</sourcefile>
      <sourceline>1262</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_GetTrcvSignalQuality() is called when the module is not
    initialized, ETHIF_E_NOT_INITIALIZED will be reported to DET and E_NOT_OK will be returned.
  
Test Object: 
    EthIf_GetTrcvSignalQuality()
  
Test Precondition: 
  
Test Execution: 
    01: Call EthIf_GetTrcvSignalQuality() in UNINIT state.
    02: VP(EthIf.ASR431.SWS_EthIf_00392): Verify that DET was called with ETHIF_E_NOT_INITIALIZED
        and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00392</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>756</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1411</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest04039_SetPhyTestMode_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest04_MIIExtension/source/application/EthIf_ConTest04_MIIextension.c</sourcefile>
      <sourceline>1314</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_SetPhyTestMode() is called when the module is not
    initialized, ETHIF_E_NOT_INITIALIZED will be reported to DET and E_NOT_OK will be returned.
  
Test Object: 
    EthIf_SetPhyTestMode()
  
Test Precondition: 
  
Test Execution: 
    01: Call EthIf_SetPhyTestMode() in UNINIT state.
    02: VP(EthIf.ASR43.SWS_EthIf_00325): Verify that DET was called with ETHIF_E_NOT_INITIALIZED and
        E_NOT_OK was returned
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00325</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>80</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1412</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest04040_SetPhyLoopbackMode_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest04_MIIExtension/source/application/EthIf_ConTest04_MIIextension.c</sourcefile>
      <sourceline>1365</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_SetPhyLoopbackMode() is called when the module is not
    initialized, ETHIF_E_NOT_INITIALIZED will be reported to DET and E_NOT_OK will be returned.
  
Test Object: 
    EthIf_SetPhyLoopbackMode()
  
Test Precondition: 
  
Test Execution: 
    01: Call EthIf_SetPhyLoopbackMode() in UNINIT state.
    02: VP(EthIf.ASR43.SWS_EthIf_00328_SetPhyLoopbackMode): Verify that DET was called with
        ETHIF_E_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00328_SetPhyLoopbackMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>118</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1413</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest04041_SetPhyTxMode_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest04_MIIExtension/source/application/EthIf_ConTest04_MIIextension.c</sourcefile>
      <sourceline>1418</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_SetPhyTxMode() is called when the module is not
    initialized, ETHIF_E_NOT_INITIALIZED will be reported to DET and E_NOT_OK will be returned.
  
Test Object: 
    EthIf_SetPhyTxMode()
  
Test Precondition: 
  
Test Execution: 
    01: Call EthIf_SetPhyTxMode() in UNINIT state.
    02: VP(EthIf.ASR43.SWS_EthIf_00328_SetPhyTxMode): Verify that DET was called with
        ETHIF_E_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00328_SetPhyTxMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1414</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest04042_GetCableDiagnosticsResult_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest04_MIIExtension/source/application/EthIf_ConTest04_MIIextension.c</sourcefile>
      <sourceline>1469</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_GetCableDiagnosticsResult() is called when the module is not
    initialized, ETHIF_E_NOT_INITIALIZED will be reported to DET and E_NOT_OK will be returned.
  
Test Object: 
    EthIf_GetCableDiagnosticsResult()
  
Test Precondition: 
  
Test Execution: 
    01: Call EthIf_GetCableDiagnosticsResult() in UNINIT state.
    02: VP(EthIf.ASR43.SWS_EthIf_00331): Verify that DET was called with ETHIF_E_NOT_INITIALIZED and
        E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00331</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>81</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1415</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest04043_GetPhyIdentifier_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest04_MIIExtension/source/application/EthIf_ConTest04_MIIextension.c</sourcefile>
      <sourceline>1520</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_GetPhyIdentifier() is called when the module is not
    initialized, ETHIF_E_NOT_INITIALIZED will be reported to DET and E_NOT_OK will be returned.
  
Test Object: 
    EthIf_GetPhyIdentifier()
  
Test Precondition: 
  
Test Execution: 
    01: Call EthIf_GetPhyIdentifier() in UNINIT state.
    02: VP(EthIf.ASR43.SWS_EthIf_00335): Verify that DET was called with ETHIF_E_NOT_INITIALIZED and
        E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00335</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>82</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1416</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest04044_GetTrcvSignalQuality_InvalidTrcvIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest04_MIIExtension/source/application/EthIf_ConTest04_MIIextension.c</sourcefile>
      <sourceline>1574</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_GetTrcvSignalQuality() is called with invalid TrcvIdx,
    ETHIF_E_INV_TRCV_IDX will be reported to DET and E_NOT_OK will be returned.
  
Test Object: 
    EthIf_GetTrcvSignalQuality()
  
Test Precondition: 
    EthIf is initialized.
  
Test Execution: 
    01: Call EthIf_GetTrcvSignalQuality() with invalid TrcvIdx.
    02: VP(EthIf.ASR431.SWS_EthIf_00393): Verify that DET was called with
        ETHIF_E_INV_TRCV_IDX and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00393</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>757</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1417</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest04045_SetPhyTestMode_InvalidTrcvIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest04_MIIExtension/source/application/EthIf_ConTest04_MIIextension.c</sourcefile>
      <sourceline>1629</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_SetPhyTestMode() is called with invalid TrcvIdx,
    ETHIF_E_INV_TRCV_IDX will be reported to DET and E_NOT_OK will be returned.
  
Test Object: 
    EthIf_SetPhyTestMode()
  
Test Precondition: 
    EthIf is initialized.
  
Test Execution: 
    01: Call EthIf_SetPhyTestMode() with invalid TrcvIdx.
    02: VP(EthIf.ASR43.SWS_EthIf_00326): Verify that DET was called with ETHIF_E_INV_TRCV_IDX and
        E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00326</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>663</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1418</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest04046_SetPhyLoopbackMode_InvalidTrcvIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest04_MIIExtension/source/application/EthIf_ConTest04_MIIextension.c</sourcefile>
      <sourceline>1684</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_SetPhyLoopbackMode() is called with invalid TrcvIdx,
    ETHIF_E_INV_TRCV_IDX will be reported to DET and E_NOT_OK will be returned.
  
Test Object: 
    EthIf_SetPhyLoopbackMode()
  
Test Precondition: 
    EthIf is initialized.
  
Test Execution: 
    01: Call EthIf_SetPhyLoopbackMode() with invalid TrcvIdx.
    02: VP(EthIf.SWS_EthIf_00329): Verify that DET was called with
        ETHIF_E_INV_TRCV_IDX and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00329</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>666</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1419</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest04047_SetPhyTxMode_InvalidTrcvIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest04_MIIExtension/source/application/EthIf_ConTest04_MIIextension.c</sourcefile>
      <sourceline>1741</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_SetPhyTxMode() is called with invalid TrcvIdx,
    ETHIF_E_INV_TRCV_IDX will be reported to DET and E_NOT_OK will be returned.
  
Test Object: 
    EthIf_SetPhyTxMode()
  
Test Precondition: 
    EthIf is initialized.
  
Test Execution: 
    01: Call EthIf_SetPhyTxMode() with invalid TrcvIdx.
    02: VP(EthIf.SWS_EthIf_00390): Verify that DET was called with
        ETHIF_E_INV_TRCV_IDX and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00390</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>754</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1420</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest04048_GetCableDiagnosticsResult_InvalidTrcvIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest04_MIIExtension/source/application/EthIf_ConTest04_MIIextension.c</sourcefile>
      <sourceline>1796</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_GetCableDiagnosticsResult() is called with invalid TrcvIdx,
    ETHIF_E_INV_TRCV_IDX will be reported to DET and E_NOT_OK will be returned.
  
Test Object: 
    EthIf_GetCableDiagnosticsResult()
  
Test Precondition: 
    EthIf is initialized.
  
Test Execution: 
    01: Call EthIf_GetCableDiagnosticsResult() with invalid TrcvIdx.
    02: VP(EthIf.ASR43.SWS_EthIf_00332): Verify that DET was called with ETHIF_E_INV_TRCV_IDX and
        E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00332</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>669</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1421</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest04049_GetPhyIdentifier_InvalidTrcvIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest04_MIIExtension/source/application/EthIf_ConTest04_MIIextension.c</sourcefile>
      <sourceline>1851</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_GetPhyIdentifier() is called with invalid TrcvIdx,
    ETHIF_E_INV_TRCV_IDX will be reported to DET and E_NOT_OK will be returned.
  
Test Object: 
    EthIf_GetPhyIdentifier()
  
Test Precondition: 
    EthIf is initialized.
  
Test Execution: 
    01: Call EthIf_GetPhyIdentifier() with invalid TrcvIdx.
    02: VP(EthIf.ASR43.SWS_EthIf_00336): Verify that DET was called with ETHIF_E_INV_TRCV_IDX and
        E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00336</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>673</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1422</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest04050_GetTrcvSignalQuality_InvalidResultPtr</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest04_MIIExtension/source/application/EthIf_ConTest04_MIIextension.c</sourcefile>
      <sourceline>1911</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_GetTrcvSignalQuality() is called with invalid ResultPtr,
    ETHIF_E_PARAM_POINTER will be reported to DET and E_NOT_OK will be returned.
  
Test Object: 
    EthIf_GetTrcvSignalQuality()
  
Test Precondition: 
    EthIf is initialized.
  
Test Execution: 
    01: Call EthIf_GetTrcvSignalQuality() with invalid ResultPtr.
    02: VP(EthIf.ASR431.SWS_EthIf_00394): Verify that DET was called with
        ETHIF_E_PARAM_POINTER and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00394</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>758</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1423</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest04051_GetCableDiagnosticsResult_InvalidResPtr</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest04_MIIExtension/source/application/EthIf_ConTest04_MIIextension.c</sourcefile>
      <sourceline>1964</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_GetCableDiagnosticsResult() is called with invalid ResultPtr,
    ETHIF_E_PARAM_POINTER will be reported to DET and E_NOT_OK will be returned.
  
Test Object: 
    EthIf_GetCableDiagnosticsResult()
  
Test Precondition: 
    EthIf is initialized.
  
Test Execution: 
    01: Call EthIf_GetCableDiagnosticsResult() with invalid ResultPtr.
    02: VP(EthIf.ASR43.SWS_EthIf_00333): Verify that DET was called with ETHIF_E_PARAM_POINTER and
        E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00333</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>670</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1424</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest04052_GetPhyIdentifier_InvalidOUIPtr</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest04_MIIExtension/source/application/EthIf_ConTest04_MIIextension.c</sourcefile>
      <sourceline>2018</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_GetPhyIdentifier() is called with invalid OrgUniqueIdPtr,
    ETHIF_E_PARAM_POINTER will be reported to DET and E_NOT_OK will be returned.
  
Test Object: 
    EthIf_GetPhyIdentifier()
  
Test Precondition: 
    EthIf is initialized.
  
Test Execution: 
    01: Call EthIf_GetPhyIdentifier() with invalid OrgUniqueIdPtr.
    02: VP(EthIf.ASR43.SWS_EthIf_00337): Verify that DET was called with ETHIF_E_PARAM_POINTER and
        E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00337</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>674</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1425</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest04053_GetPhyIdentifier_InvalidModNrPtr</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest04_MIIExtension/source/application/EthIf_ConTest04_MIIextension.c</sourcefile>
      <sourceline>2074</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_GetPhyIdentifier() is called with invalid ModelNrPtr,
    ETHIF_E_PARAM_POINTER will be reported to DET and E_NOT_OK will be returned.
  
Test Object: 
    EthIf_GetPhyIdentifier()
  
Test Precondition: 
    EthIf is initialized.
  
Test Execution: 
    01: Call EthIf_GetPhyIdentifier() in with invalid ModelNrPtr.
    02: VP(EthIf.ASR43.SWS_EthIf_00338): Verify that DET was called with ETHIF_E_PARAM_POINTER and
        E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00338</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>83</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1426</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest04054_GetPhyIdentifier_InvalidRevNrPtr</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest04_MIIExtension/source/application/EthIf_ConTest04_MIIextension.c</sourcefile>
      <sourceline>2130</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_GetPhyIdentifier() is called with invalid RevisionNrPtr,
    ETHIF_E_PARAM_POINTER will be reported to DET and E_NOT_OK will be returned.
  
Test Object: 
    EthIf_GetPhyIdentifier()
  
Test Precondition: 
    EthIf is initialized.
  
Test Execution: 
    01: Call EthIf_GetPhyIdentifier() in with invalid RevisionNrPtr.
    02: VP(EthIf.ASR43.SWS_EthIf_00339): Verify that DET was called with ETHIF_E_PARAM_POINTER and
        E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00339</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>676</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1427</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest04055_GetTrcvSignalQuality_Forward_Call</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest04_MIIExtension/source/application/EthIf_ConTest04_MIIextension.c</sourcefile>
      <sourceline>2186</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_GetTrcvSignalQuality() is called with valid parameters, the call
    will be forwarded to EthTrcv_GetPhySignalQuality().
  
Test Object: 
    EthIf_GetTrcvSignalQuality()
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_GetTrcvSignalQuality().
    02: VP(EthIf.EB.GetTrcvSignalQuality_00320): Verify that EthTrcv_GetPhySignalQuality was called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.GetTrcvSignalQuality_00320</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>275</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1428</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest04056_SetPhyTestMode_Forward_Call</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest04_MIIExtension/source/application/EthIf_ConTest04_MIIextension.c</sourcefile>
      <sourceline>2251</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_SetPhyTestMode() is called with valid parameters, the call
    will be forwarded to EthTrcv_SetPhyTestMode().
  
Test Object: 
    EthIf_SetPhyTestMode()
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_SetPhyTestMode().
    02: VP(EthIf.ASR43.SWS_EthIf_00324): Verify that EthTrcv_SetPhyTestMode was called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00324</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>661</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1429</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest04057_SetPhyLoopbackMode_Forward_Call</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest04_MIIExtension/source/application/EthIf_ConTest04_MIIextension.c</sourcefile>
      <sourceline>2316</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_SetPhyLoopbackMode() is called with valid parameters, the call
    will be forwarded to EthTrcv_SetPhyLoopbackMode().
  
Test Object: 
    EthIf_SetPhyLoopbackMode()
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_GetTrcvSignalQuality().
    02: VP(EthIf.SWS_EthIf_00327, EthIf.ASR43.SWS_EthIf_00123):
        Verify that Ethernet transceiver driver function EthTrcv_SetPhyLoopbackMode() was called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00327</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>664</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00123</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>477</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1430</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest04058_SetPhyTxMode_Forward_Call</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest04_MIIExtension/source/application/EthIf_ConTest04_MIIextension.c</sourcefile>
      <sourceline>2383</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_SetPhyTxMode() is called with valid parameters, the call
    will be forwarded to EthTrcv_SetPhyTxMode().
  
Test Object: 
    EthIf_SetPhyTxMode()
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_SetPhyTxMode().
    02: VP(EthIf.SWS_EthIf_00388): Verify that EthTrcv_SetPhyTxMode was called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00388</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>752</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1431</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest04059_GetCableDiagnosticsResult_Forward_Call</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest04_MIIExtension/source/application/EthIf_ConTest04_MIIextension.c</sourcefile>
      <sourceline>2448</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_GetCableDiagnosticsResult() is called with valid parameters,
    the call will be forwarded to EthTrcv_GetCableDiagnosticsResult().
  
Test Object: 
    EthIf_GetCableDiagnosticsResult()
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_GetCableDiagnosticsResult().
    02: VP(EthIf.ASR43.SWS_EthIf_00330): Verify that EthTrcv_GetCableDiagnosticsResult was called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00330</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>667</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1432</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest04060_GetPhyIdentifier_Forward_Call</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest04_MIIExtension/source/application/EthIf_ConTest04_MIIextension.c</sourcefile>
      <sourceline>2513</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_GetPhyIdentifier() is called with valid parameters, the call
    will be forwarded to EthTrcv_GetPhyIdentifier().
  
Test Object: 
    EthIf_GetPhyIdentifier()
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_GetPhyIdentifier().
    02: VP(EthIf.ASR43.SWS_EthIf_00334): Verify that EthTrcv_GetPhyIdentifier was called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00334</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>671</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1433</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EthIf_ConTest05000_MainFunction_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest05_FunctionChecks_QoS/source/application/EthIf_ConTest05_FunctionCheck_QoS.c</sourcefile>
      <sourceline>112</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that calling EthIf_MainFunctionRxPrio() while the
    module is not initialized, the functions will return without taking any action.
  
Test Object: 
    EthIf_MainFunctionRxPrio().
  
Test Precondition: 
    EthIf uninitialized.
  
Test Execution: 
    01: Call EthIf_MainFunctionRxPrio() for all controllers.
    02: VP(EthIf.EB.QoSExtension.MainFunctionRxPrio.Uninit): Verify that no action was taken.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.QoSExtension.MainFunctionRxPrio.Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>240</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1434</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest05001_MainFunction_NotInit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest05_FunctionChecks_QoS/source/application/EthIf_ConTest05_FunctionCheck_QoS.c</sourcefile>
      <sourceline>160</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that calling EthIf_MainFunctionRxPrio() will check the EthCtrlIdx if the
    controller is initialized and perform no API call to other modules if controller is not
    initialized.
  
Test Object: 
    EthIf_MainFunctionRx().
  
Test Precondition: 
    No Eth controller is initialized.
  
Test Execution: 
    01: Call EthIf_MainFunctionRxPrio() for all controllers.
    02: VP(EthIf.EB.QoSExtension.MainFunctionRxPrio.CtrlNotInit): Since no controller is
        initialized, verify that no API call is performed.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.QoSExtension.MainFunctionRxPrio.CtrlNotInit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>241</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1435</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest05005_MainFunctionRxPrio_Polling</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest05_FunctionChecks_QoS/source/application/EthIf_ConTest05_FunctionCheck_QoS.c</sourcefile>
      <sourceline>214</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that EthIf_MainFunctionRxPrio() function shall poll Eth_PriorityReceive
    until more data is available for related controller.
  
Test Object: 
    - EthIf_MainFunctionRxPrio()
  
Test Precondition: 
    - EthIf initialized.
    - Controller and transceiver under test initialized.
    - Controller and transceiver is set to active.
  
Test Execution: 
    01: Call EthIf_MainFunctionRxPrio().
    02: VP(EthIf.EB.QoSExtension.MainFunctionRxPrio_PollEthReceiveMax): Verify that
        Eth_Receive() is called same number of times as configuration parameter
        ETHIF_CTR_RX_INDICATION_ITERATIONS.
    03: VP(EthIf.EB.QoSExtension.MainFunctionRxPrio_PollEthReceiveMax): Verify that no further
        Eth_Receive calls have been made.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.QoSExtension.MainFunctionRxPrio_PollEthReceiveMax</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>242</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91051</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>743</internalId></provcov>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00052</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>584</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1436</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest05006_MainFunctionRx_Polling</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest05_FunctionChecks_QoS/source/application/EthIf_ConTest05_FunctionCheck_QoS.c</sourcefile>
      <sourceline>294</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that EthIf_MainFunctionRx() function shall poll unmapped ingress FIFOs
    with Eth_Receive until more data is available for related controller.
  
Test Object: 
    - EthIf_MainFunctionRx()
  
Test Precondition: 
    - EthIf initialized.
    - Controller and transceiver under test initialized.
    - Controller and transceiver is set to active.
  
Test Execution: 
    01: Call EthIf_MainFunctionRx().
    02: VP(EthIf.EB.QoSExtension.MainFunctionRxPrio_PollEthReceiveMax): Verify that
        Eth_Receive() is called same number of times as configuration parameter
        EthIfRxIndications for each ingress fifo that is not mapped with
        EthIfPhysCtrlRxMainFunctionPriorityProcessing.
    03: VP(): Verify EthIf_MainFunctionState has been called and no DET was reported.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.QoSExtension.MainFunctionRxPrio_PollEthReceiveMax</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>242</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91051</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>743</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1437</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest05007_MainFunctionRxPrio_ETH_RECEIVED</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest05_FunctionChecks_QoS/source/application/EthIf_ConTest05_FunctionCheck_QoS.c</sourcefile>
      <sourceline>423</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that EthIf_MainFunctionRxPrio() function shall not poll Eth_Receive
    if RxStatus output parameter from Eth_PriorityReceive() function is ETH_RECEIVED.
  
Test Object: 
    - EthIf_MainFunctionRxPrio()
  
Test Precondition: 
    - EthIf initialized.
    - Controller and transceiver under test initialized.
    - Controller and transceiver is set to active.
  
Test Execution: 
    01: Call EthIf_MainFunctionRxPrio().
    02: VP(EthIf.EB.QoSExtension.MainFunctionRxPrio_PollEthReceiveNoData): Verify that
        Eth_PriorityReceive() is called once
    03: VP(EthIf.EB.QoSExtension.MainFunctionRxPrio_PollEthReceiveNoData): Verify that no further
        Eth_PriorityReceive calls have been made.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.QoSExtension.MainFunctionRxPrio_PollEthReceiveNoData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>243</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91051</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>743</internalId></provcov>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00028</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>483</internalId></provcov>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00046</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>580</internalId></provcov>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00047</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>581</internalId></provcov>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00053</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>585</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1438</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest05008_BufReq_OK</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest05_FunctionChecks_QoS/source/application/EthIf_ConTest05_FunctionCheck_QoS.c</sourcefile>
      <sourceline>501</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if Eth_ProvideTxBuffer returns BUFREQ_OK,
    EthIf_ProvideTxBuffer will return also BUFREQ_OK with correct parameters.
  
Test Object: None.
Test Precondition: 
    A controller is in state ACTIVE.
  
Test Execution: 
    01: Set Eth_ProvidePriorityTxBuffer to return BUFREQ_OK.
    02: Call EthIf_ProvideTxBuffer with the parameter(s) defined in the input section.
    03: VP: Verify that Eth_ProvidePriorityTxBuffer was called and EthIf_ProvideTxBuffer returned
        BUFREQ_OK with correct parameters.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00068.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>940</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1439</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest05009_ProvideTxBuffer_Disabled_VlanId</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest05_FunctionChecks_QoS/source/application/EthIf_ConTest05_FunctionCheck_QoS.c</sourcefile>
      <sourceline>587</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Call EthIf_ProvideTxBuffer() using a CtrlIdx that has EthIfVlanId disabled.
  
Test Object: None.
Test Precondition: 
    EthIfVlanId is false.
    A controller is in state ACTIVE.
  
Test Execution: 
    01: Call EthIf_ProvideTxBuffer() using a CtrlIdx that has EthIfVlanId disabled.
    02: EthIf_ProvideTxBuffer() shall return BUFREQ_E_OK.
    03: VP: Eth_ProvideTxBuffer() shall be called with the expected parameter(s).
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00068.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>940</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1440</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest05010_SetControllerMode_Active</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest05_FunctionChecks_QoS/source/application/EthIf_ConTest05_FunctionCheck_QoS.c</sourcefile>
      <sourceline>667</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that EthIf_SetControllerMode() shall not forward the call to function
    Eth_SetControllerMode of the corresponding Ethernet Controller Driver (EthIfPhysControllerIdx)
    if mode ETH_MODE_ACTIVE has already been requested for the Ethernet Interface Controller
    referencing the Ethernet Controller.
  
Test Object: None.
Test Precondition: 
    EthIf_SetControllerMode() has been called with mode ETH_MODE_ACTIVE
  
Test Execution: 
    01: Call EthIf_SetControllerMode() with ETH_MODE_ACTIVE when it has already been requested.
    02: VP(EthIf.SWS_EthIf_00035): Verify that no functions were called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00035</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>424</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1441</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest05011_MODE_DOWN_ProvideTxBuffer_E_NOT_OK</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest05_FunctionChecks_QoS/source/application/EthIf_ConTest05_FunctionCheck_QoS.c</sourcefile>
      <sourceline>717</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_ProvideTxBuffer() is called while
    controller mode is ETH_MODE_DOWN, the request will be rejected and the
    function will will return E_NOT_OK.
  
Test Object: None.
Test Precondition: 
    A controller is in state DOWN.
  
Test Execution: 
    01: Set Eth_ProvidePriorityTxBuffer to return BUFREQ_OK.
    02: Call EthIf_ProvideTxBuffer with the parameter(s) defined in the input section.
    03: VP(EthIf.SWS_EthIf_00068.3):
        Verify that the request is rejected and thatEthIf_ProvideTxBuffer returned E_NOT_OK.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00068.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>942</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1442</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest05012_BufReq_OK</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest05_FunctionChecks_QoS/source/application/EthIf_ConTest05_FunctionCheck_QoS.c</sourcefile>
      <sourceline>788</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if Eth_ProvideTxBuffer returns BUFREQ_OK,
    EthIf_ProvideTxBuffer will return also BUFREQ_OK with correct parameters.
  
Test Object: None.
Test Precondition: 
    A controller is in state ACTIVE_WITH_WAKEUP_REQUEST.
  
Test Execution: 
    01: Set Eth_ProvidePriorityTxBuffer to return BUFREQ_OK.
    02: Call EthIf_ProvideTxBuffer with the parameter(s) defined in the input section.
    03: VP: Verify that Eth_ProvidePriorityTxBuffer was called and EthIf_ProvideTxBuffer returned
        BUFREQ_OK with correct parameters.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00068.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>941</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1443</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest05013_ProvideTxBuffer_Disabled_VlanId</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest05_FunctionChecks_QoS/source/application/EthIf_ConTest05_FunctionCheck_QoS.c</sourcefile>
      <sourceline>874</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Call EthIf_ProvideTxBuffer() using a CtrlIdx that has EthIfVlanId disabled.
  
Test Object: None.
Test Precondition: 
    EthIfVlanId is false.
    A controller is in state ACTIVE_WITH_WAKEUP_REQUEST.
  
Test Execution: 
    01: Call EthIf_ProvideTxBuffer() using a CtrlIdx that has EthIfVlanId disabled.
    02: EthIf_ProvideTxBuffer() shall return BUFREQ_E_OK.
    03: VP: Eth_ProvideTxBuffer() shall be called with the expected parameter(s).
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00068.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>941</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1444</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EthIf_ConTest05_SwtSupport_GetPortMacAddr_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest05_SwtSupport/source/application/EthIf_ConTest05_SwtSupport.c</sourcefile>
      <sourceline>42</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_GetPortMacAddr() is called when the module is not initialized,
    ETHIF_E_NOT_INITIALIZED will be reported to DET.
  
Test Object: 
     EthIf_GetPortMacAddr()
  
Test Precondition: 
  
Test Execution: 
    01: Call EthIf_GetPortMacAddr() in UNINIT state.
    02: VP(EthIf.ASR43.SWS_EthIf_00193): Verify that DET was called with ETHIF_E_NOT_INITIALIZED.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00193</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>58</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1445</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest05_SwtSupport_GetArlTable_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest05_SwtSupport/source/application/EthIf_ConTest05_SwtSupport.c</sourcefile>
      <sourceline>95</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_GetArlTable() is called when the module is not initialized,
    ETHIF_E_NOT_INITIALIZED will be reported to DET.
  
Test Object: 
     EthIf_GetArlTable()
  
Test Precondition: 
  
Test Execution: 
    01: Call EthIf_GetArlTable() in UNINIT state.
    02: VP(EthIf.ASR43.SWS_EthIf_00199): Verify that DET was called with ETHIF_E_NOT_INITIALIZED.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00199</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1446</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest05_SwtSupport_GetBufferLevel_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest05_SwtSupport/source/application/EthIf_ConTest05_SwtSupport.c</sourcefile>
      <sourceline>148</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_GetBufferLevel() is called when the module is not initialized,
    ETHIF_E_NOT_INITIALIZED will be reported to DET.
  
Test Object: 
     EthIf_GetBufferLevel()
  
Test Precondition: 
  
Test Execution: 
    01: Call EthIf_GetBufferLevel() in UNINIT state.
    02: VP(EthIf.ASR43.SWS_EthIf_00205): Verify that DET was called with ETHIF_E_NOT_INITIALIZED.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00205</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>63</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1447</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest05_SwtSupport_SwtGetCounterValue_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest05_SwtSupport/source/application/EthIf_ConTest05_SwtSupport.c</sourcefile>
      <sourceline>200</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_SwtGetCounterValues() is called when the module is not initialized,
    ETHIF_E_NOT_INITIALIZED will be reported to DET.
  
Test Object: 
     EthIf_SwtGetCounterValues()
  
Test Precondition: 
  
Test Execution: 
    01: Call EthIf_SwtGetCounterValues() in UNINIT state.
    02: VP(EthIf.ASR42.EthIf_SwtGetCounterValues.NOT_INIT):
        Verify that DET was called with ETHIF_E_NOT_INITIALIZED.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR42.EthIf_SwtGetCounterValues.NOT_INIT</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>36</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1448</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest05_SwtSupport_StoreConfiguration_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest05_SwtSupport/source/application/EthIf_ConTest05_SwtSupport.c</sourcefile>
      <sourceline>253</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_StoreConfiguration() is called when the module is not initialized,
    ETHIF_E_NOT_INITIALIZED will be reported to DET.
  
Test Object: 
     EthIf_StoreConfiguration()
  
Test Precondition: 
  
Test Execution: 
    01: Call EthIf_StoreConfiguration() in UNINIT state.
    02: VP(EthIf.ASR43.SWS_EthIf_00217):
        Verify that DET was called with ETHIF_E_NOT_INITIALIZED.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00217</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>65</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1449</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest05_SwtSupport_ResetConfiguration_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest05_SwtSupport/source/application/EthIf_ConTest05_SwtSupport.c</sourcefile>
      <sourceline>305</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_ResetConfiguration() is called when the module is not initialized,
    ETHIF_E_NOT_INITIALIZED will be reported to DET.
  
Test Object: 
     EthIf_ResetConfiguration()
  
Test Precondition: 
  
Test Execution: 
    01: Call EthIf_ResetConfiguration() in UNINIT state.
    02: VP(EthIf.ASR43.SWS_EthIf_00222):
        Verify that DET was called with ETHIF_E_NOT_INITIALIZED.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00222</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>66</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1450</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest05_SwtSupport_GetPortMacAddr_InvPointer</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest05_SwtSupport/source/application/EthIf_ConTest05_SwtSupport.c</sourcefile>
      <sourceline>357</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_GetPortMacAddr() is called with invalid pointer,
    ETHIF_E_PARAM_POINTER will be reported to DET and E_NOT_OK will be returned.
  
Test Object: 
    EthIf_GetPortMacAddr().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_GetPortMacAddr() with parameter MacAddrPtr as NULL_PTR.
    02: VP(EthIf.ASR43.SWS_EthIf_00194):
        Verify that DET was called with ETHIF_E_PARAM_POINTER.
    03: Call EthIf_GetPortMacAddr() with parameter PortIdxPtr as NULL_PTR.
    04: VP(EthIf.ASR43.SWS_EthIf_00194):
        Verify that DET was called with ETHIF_E_PARAM_POINTER.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00194</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>538</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1451</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest05_SwtSupport_GetBufferLevel_InvPointer</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest05_SwtSupport/source/application/EthIf_ConTest05_SwtSupport.c</sourcefile>
      <sourceline>430</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_GetBufferLevel() is called with invalid pointer,
    ETHIF_E_PARAM_POINTER will be reported to DET and E_NOT_OK will be returned.
  
Test Object: 
    EthIf_GetBufferLevel().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_GetBufferLevel() with parameter Counter as NULL_PTR.
    02: VP(EthIf.ASR43.SWS_EthIf_00206):
        Verify that DET was called with ETHIF_E_PARAM_POINTER.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00206</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>64</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1452</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest05_SwtSupport_GetArlTable_InvPointer</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest05_SwtSupport/source/application/EthIf_ConTest05_SwtSupport.c</sourcefile>
      <sourceline>486</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_GetArlTable() is called with invalid pointer,
    ETHIF_E_PARAM_POINTER will be reported to DET and E_NOT_OK will be returned.
  
Test Object: 
    EthIf_GetArlTable().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_GetArlTable() with parameter ArlTable as NULL_PTR.
    02: VP(EthIf.ASR43.SWS_EthIf_00200):
        Verify that DET was called with ETHIF_E_PARAM_POINTER.
    03: Call EthIf_GetArlTable() with parameter numOfelements as NULL_PTR.
    04: VP(EthIf.ASR43.SWS_EthIf_00200):
        Verify that DET was called with ETHIF_E_PARAM_POINTER.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00200</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>543</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1453</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest05_SwtSupport_SwtGetCounterValues_InvPointer</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest05_SwtSupport/source/application/EthIf_ConTest05_SwtSupport.c</sourcefile>
      <sourceline>559</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_SwtGetCounterValues() is called with invalid pointer,
    ETHIF_E_PARAM_POINTER will be reported to DET and E_NOT_OK will be returned.
  
Test Object: 
    EthIf_SwtGetCounterValues().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_SwtGetCounterValues() with parameter Counter as NULL_PTR.
    02: VP(EthIf.ASR42.EthIf_SwtGetCounterValues.INV_POINTER):
        Verify that DET was called with ETHIF_E_PARAM_POINTER.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR42.EthIf_SwtGetCounterValues.INV_POINTER</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>37</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1454</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest05_SwtSupport_GetPortMacAddr_InvSwtIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest05_SwtSupport/source/application/EthIf_ConTest05_SwtSupport.c</sourcefile>
      <sourceline>616</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_GetPortMacAddr() is called with invalid switch index,
    ETHIF_E_INV_SWT_IDX will be reported to DET.
  
Test Object: 
     EthIf_GetPortMacAddr()
  
Test Precondition: 
  
Test Execution: 
    01: Call EthIf_GetPortMacAddr() with invalid SwitchIdx.
    02: VP(EthIf.EB.EthSwtSupport.SWS_EthIf_00190.INV_SWT_IDX):
        Verify that DET was called with ETHIF_E_INV_SWT_IDX.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.EthSwtSupport.SWS_EthIf_00190.INV_SWT_IDX</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>234</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1455</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest05_SwtSupport_GetArlTable_InvSwtIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest05_SwtSupport/source/application/EthIf_ConTest05_SwtSupport.c</sourcefile>
      <sourceline>670</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_GetArlTable() is called with invalid switch index,
    ETHIF_E_INV_SWT_IDX will be reported to DET.
  
Test Object: 
     EthIf_GetArlTable()
  
Test Precondition: 
  
Test Execution: 
    01: Call EthIf_GetArlTable() with invalid SwitchIdx.
    02: VP(EthIf.EB.EthSwtSupport.SWS_EthIf_00196.INV_SWT_IDX):
        Verify that DET was called with ETHIF_E_INV_SWT_IDX.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.EthSwtSupport.SWS_EthIf_00196.INV_SWT_IDX</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>235</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1456</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest05_SwtSupport_GetBufferLevel_InvSwtIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest05_SwtSupport/source/application/EthIf_ConTest05_SwtSupport.c</sourcefile>
      <sourceline>724</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_GetBufferLevel() is called with invalid switch index,
    ETHIF_E_INV_SWT_IDX will be reported to DET.
  
Test Object: 
     EthIf_GetBufferLevel()
  
Test Precondition: 
  
Test Execution: 
    01: Call EthIf_GetBufferLevel() with invalid SwitchIdx.
    02: VP(EthIf.EB.EthSwtSupport.SWS_EthIf_00202.INV_SWT_IDX):
        Verify that DET was called with ETHIF_E_INV_SWT_IDX.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.EthSwtSupport.SWS_EthIf_00202.INV_SWT_IDX</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>236</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1457</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest05_SwtSupport_SwtGetCounterValue_InvSwtIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest05_SwtSupport/source/application/EthIf_ConTest05_SwtSupport.c</sourcefile>
      <sourceline>777</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_SwtGetCounterValues() is called with invalid switch index,
    ETHIF_E_INV_SWT_IDX will be reported to DET.
  
Test Object: 
     EthIf_SwtGetCounterValues()
  
Test Precondition: 
  
Test Execution: 
    01: Call EthIf_SwtGetCounterValues() with invalid SwitchIdx.
    02: VP(EthIf.EB.EthSwtSupport.EthIf_SwtGetCounterValues.INV_SWT_IDX):
        Verify that DET was called with ETHIF_E_INV_SWT_IDX.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.EthSwtSupport.EthIf_SwtGetCounterValues.INV_SWT_IDX</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>237</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1458</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest05_SwtSupport_StoreConfiguration_InvSwtIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest05_SwtSupport/source/application/EthIf_ConTest05_SwtSupport.c</sourcefile>
      <sourceline>830</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_StoreConfiguration() is called with invalid switch index,
    ETHIF_E_INV_SWT_IDX will be reported to DET.
  
Test Object: 
     EthIf_StoreConfiguration()
  
Test Precondition: 
  
Test Execution: 
    01: Call EthIf_StoreConfiguration() with invalid SwitchIdx.
    02: VP(EthIf.EB.EthSwtSupport.SWS_EthIf_00214.INV_SWT_IDX):
        Verify that DET was called with ETHIF_E_INV_SWT_IDX.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.EthSwtSupport.SWS_EthIf_00214.INV_SWT_IDX</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>238</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1459</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest05_SwtSupport_ResetConfiguration_InvSwtIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest05_SwtSupport/source/application/EthIf_ConTest05_SwtSupport.c</sourcefile>
      <sourceline>882</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_ResetConfiguration() is called with invalid switch index,
    ETHIF_E_INV_SWT_IDX will be reported to DET.
  
Test Object: 
     EthIf_ResetConfiguration()
  
Test Precondition: 
  
Test Execution: 
    01: Call EthIf_ResetConfiguration() with invalid SwitchIdx.
    02: VP(EthIf.EB.EthSwtSupport.SWS_EthIf_00219.INV_SWT_IDX):
        Verify that DET was called with ETHIF_E_INV_SWT_IDX.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.EthSwtSupport.SWS_EthIf_00219.INV_SWT_IDX</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>239</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1460</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest05_SwtSupport_GetPortMacAddr</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest05_SwtSupport/source/application/EthIf_ConTest05_SwtSupport.c</sourcefile>
      <sourceline>934</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that EthIf_GetPortMacAddr() will return E_NOT_OK, since the function
    forwarding to Ethernet Switch Driver is not yet implemented.
  
Test Object: 
    EthIf_GetPortMacAddr()
  
Test Precondition: 
      ports configured:
      SwitchPortIdx 0U; MAC addr 1U
  
Test Execution: 
    01: Call EthIf_GetPortMacAddr().
    02: VP(EthIf.ASR43.SWS_EthIf_00190):
        Verify that the function has been called and returns E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00190</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>534</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1461</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest05_SwtSupport_GetArlTable</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest05_SwtSupport/source/application/EthIf_ConTest05_SwtSupport.c</sourcefile>
      <sourceline>988</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that EthIf_GetArlTable() will obtain the address resolution table
    of a switch, and return E_OK.
  
Test Object: 
    EthIf_GetArlTable()
  
Test Precondition: 
    EthIf is initialized
    Values MacAddr, SwitchPort and VlanId are set to invalid values.
    Stub values for parameters are set to 0U.
  
Test Execution: 
    01: Call EthIf_GetArlTable() with SwitchIdx = 0 to obtain ArlTable.
    02: VP(EthIf.ASR43.SWS_EthIf_00197, EthIf.ASR43.SWS_EthIf_00228):
        Verify that Ethernet switch driver function EthSwt_GetArlTable() was called.
        Verify that parameters are correct after a function call, E_OK was returned, and that
        forwarded parameters are correct.
    03: Set local variables to incorrect values to verify that the values changed after
        calling EthIf_GetArlTable.
        Call EthIf_GetArlTable() with SwitchIdx = 1 to obtain ArlTable.
    04: VP(EthIf.ASR43.SWS_EthIf_00197):
        Verify that parameters are correct after a function call, E_OK was returned, and that
        forwarded parameters are correct.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00197</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>540</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00254</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>607</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00228</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>553</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1462</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest05_SwtSupport_GetBufferLevel</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest05_SwtSupport/source/application/EthIf_ConTest05_SwtSupport.c</sourcefile>
      <sourceline>1081</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that EthIf_GetBufferLevel() will obtain the buffer level of
    the indexed switch, and return E_OK.
  
Test Object: 
    EthIf_GetBufferLevel()
  
Test Precondition: 
    EthIf is initialized
    Stub output is set to test buffer level.
  
Test Execution: 
    01: Call EthIf_GetBufferLevel() with SwitchIdx = 0 to read the buffer level.
    02: VP(EthIf.ASR43.SWS_EthIf_00203):
        Verify that E_OK was returned, and that buffer level value is equal to the
        stub value. Verify that forwarded values are correct.
    03: Call EthIf_GetBufferLevel() with SwitchIdx = 1 to read the buffer level.
    04: VP(EthIf.ASR43.SWS_EthIf_00203):
        Verify that E_OK was returned, and that buffer level value is equal to the
        stub value. Verify that forwarded values are correct.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00203</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>61</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1463</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest05_SwtSupport_SwtGetCounterValues</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest05_SwtSupport/source/application/EthIf_ConTest05_SwtSupport.c</sourcefile>
      <sourceline>1153</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that EthIf_SwtGetCounterValues() will obtain the list of values level of
    the indexed switch, and return E_OK.
  
Test Object: 
    EthIf_SwtGetCounterValues()
  
Test Precondition: 
    EthIf is initialized.
    Output stub variables are set to testing values.
  
Test Execution: 
    01: Call EthIf_SwtGetCounterValues() with SwitchIdx = 0 to obtain the list of values.
    02: VP(EthIf.ASR42.EthIf_SwtGetCounterValues.detailed):
        Verify that E_OK was returned, values that function provided are same as the values set
        in stub, and that forwarded values are correct.
    03: Call EthIf_SwtGetCounterValues() with SwitchIdx = 1 to obtain the list of values.
    04: VP(EthIf.ASR42.EthIf_SwtGetCounterValues.detailed):
        Verify that E_OK was returned, values that function provided are same as the values set
        in stub, and that forwarded values are correct.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR42.EthIf_SwtGetCounterValues.detailed</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>34</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1464</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest05_SwtSupport_GetVlanId</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest05_SwtSupport/source/application/EthIf_ConTest05_SwtSupport.c</sourcefile>
      <sourceline>1262</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that EthIf_GetVlanId() will return the VlanId of the requested
    CtrlIdx or 0 if requested Ethernet controller represents no virtual network.
  
Test Object: 
    EthIf_GetVlanId()
  
Test Precondition: 
      ports configured:
      SwitchPortIdx 0U; MAC addr 1U
  
Test Execution: 
    01: Call EthIf_GetVlanId() for an Ethernet controller without VLAN defined.
    02: VP(EthIf.ASR43.SWS_EthIf_91052, SWS_EthIf_00301):
        Verify that the returned VlanId is set to 0.
    03: Call EthIf_GetVlanId() for an Ethernet controller with defined VLAN.
    04: VP(EthIf.ASR43.SWS_EthIf_91052, SWS_EthIf_00301):
        Verify that VlanId of the requested CtrlIdx is returned in VlanIdPtr.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91052</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>744</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00301</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>645</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1465</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest05_SwtSupport_StoreConfiguration</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest05_SwtSupport/source/application/EthIf_ConTest05_SwtSupport.c</sourcefile>
      <sourceline>1325</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that EthIf_StoreConfiguration() will forward a call to
    API EthSwt_StoreConfiguration, and return E_OK.
  
Test Object: 
    EthIf_StoreConfiguration()
  
Test Precondition: 
    EthIf is initialized.
  
Test Execution: 
    01: Call EthIf_StoreConfiguration() with SwitchIdx = 0.
    02: VP(EthIf.ASR43.SWS_EthIf_00215): Verify that returned and forwarded
        values are correct.
    03: Call EthIf_StoreConfiguration() with SwitchIdx = 1.
    04: VP(EthIf.ASR43.SWS_EthIf_00215):Verify that returned and forwarded
        values are correct.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00215</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>545</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1466</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest05_SwtSupport_ResetConfiguration</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest05_SwtSupport/source/application/EthIf_ConTest05_SwtSupport.c</sourcefile>
      <sourceline>1389</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that EthIf_ResetConfiguration() will forward a call to
    API EthSwt_ResetConfiguration, and return E_OK.
  
Test Object: 
    EthIf_ResetConfiguration()
  
Test Precondition: 
    EthIf is initialized
  
Test Execution: 
    01: Call EthIf_ResetConfiguration() with SwitchIdx = 0.
    02: VP(EthIf.ASR43.SWS_EthIf_00220): Verify that returned and forwarded
        values are correct.
    03: Call EthIf_ResetConfiguration() with SwitchIdx = 1.
    04: VP(EthIf.ASR43.SWS_EthIf_00220): Verify that returned and forwarded
        values are correct.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00220</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>549</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1467</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EthIf_ConTest06043_SetTransceiverMode_NOT_OK</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/TestSpec_Generated.h</sourcefile>
      <sourceline>9</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that if a call to EthSwt_SetTransceiverMode() fails, the call will be repeated in the following EthIf_MainFunction() call. In this case call fails immediatelly.
Test Object: EthSwt_SetTransceiverMode retry
Test Precondition: 
    -   Transceiver support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set return value of EthTrcv_SetTransceiverMode to E_NOT_OK.
    02: Set Ethernet interface controller and switch port mode to ACTIVE.
    03: Call EthIf_MainFunctionRx to retry informing transceiver.
    04: VP(EthIf.EB.Repeat.SetTransceiverMode.HwNotOk,1) Verify that calling EthTrcv_SetTransceiverMode was retried.
    05: Call EthIf_MainFunctionRx to retry informing transceiver.
    06: VP(EthIf.EB.Repeat.SetTransceiverMode.HwNotOk,1) Verify that calling EthTrcv_SetTransceiverMode was retried.
    07: Set return value of EthTrcv_SetTransceiverMode to E_OK.
    08: Call EthIf_MainFunctionRx to retry informing transceiver.
    09: VP(EthIf.EB.Repeat.SetTransceiverMode.HwNotOk,1) Verify that calling EthTrcv_SetTransceiverMode was retried.
    10: Call EthIf_MainFunctionRx to change link state to ACTIVE.
    11: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Repeat.SetTransceiverMode.HwNotOk</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>261</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1468</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06044_SetTransceiverMode_NOT_OK_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/TestSpec_Generated.h</sourcefile>
      <sourceline>38</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that if a call to EthSwt_SetTransceiverMode() fails, the call will be repeated in the following EthIf_MainFunction() call. In this case call fails after the recall and ETHIF_SET_MODE_TIMEOUT.
Test Object: EthSwt_SetTransceiverMode retry
Test Precondition: 
    -   Transceiver support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller and switch port mode to ACTIVE.
    02: Call EthIf_MainFunctionRx so that transceiver mode will be set as ACTIVE.
    03: Set return value of EthTrcv_SetTransceiverMode to E_NOT_OK.
    04: Call EthIf_MainFunctionRx to timeout repeat timer and call EthTrcv_SetTransceiverMode while mode obtained from transceiver is DOWN.
    05: Call EthIf_MainFunctionRx to retry informing transceiver.
    06: VP(EthIf.EB.Repeat.SetTransceiverMode.HwNotOk,1) Verify that calling EthTrcv_SetTransceiverMode was retried.
    07: Set return value of EthTrcv_SetTransceiverMode to E_OK.
    08: Call EthIf_MainFunctionRx to retry informing transceiver.
    09: VP(EthIf.EB.Repeat.SetTransceiverMode.HwNotOk,1) Verify that calling EthTrcv_SetTransceiverMode was retried.
    10: Call EthIf_MainFunctionRx to change link state to ACTIVE.
    11: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Repeat.SetTransceiverMode.HwNotOk</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>261</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1469</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EthIf_ConTest06001_SetControllerMode_Switch</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>133</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies support of post-build selectable feature by initializing EthIf with two
    different variants and testing that when EthIfController which references a switch (and not a
    port group) is set to ACTIVE, then all EthSwtPorts of referenced switch shall be switched on.
    And vice versa when all EthIfControllers that reference a switch are set to DOWN, then all ports
    of a switch will be switched off for variant V1. In variant V2 EthIfCtrl_0 has a different
    EthIfSwitchRefOrPortGroupRef and referenced EthIfSwitch has different EthIfSwitchIdx and
    EthIfSwitchRef.
  
Test Object: 
    EthIf_SetControllerMode().
    Post-build selectable support.
  
Test Precondition: 
    Two post-build variants configured.
    V1: - EthIfCtrl_0/EthIfSwitchRefOrPortGroupRef: EthIfSwitch_0
        - EthIfSwitch_0:
          - EthIfSwitchIdx: 0
          - EthIfSwitchRef: /EthSwt/EthSwt/EthSwtConfig_1
    V2: - EthIfCtrl_0/EthIfSwitchRefOrPortGroupRef: EthIfSwitch_2
        - EthIfSwitch_2:
          - EthIfSwitchIdx: 1
          - EthIfSwitchRef: /EthSwt/EthSwt/EthSwtConfig_1
  
Test Execution: 
    01: VP(EthIf.EB.PBSelectable.Master): Check that EthIf_PBcfg.h exists and can be included.
    02: VP(EthIf.EB.PBSelectable.FileName): Verify that files EthIf_V1_PBcfg.h and EthIf_V2_PBcfg.h
        exist and are included.
    03: VP(EthIf.EB.PBSelectable.TypeName): Verify that types EthIf_V1_ConstConfigLayoutType,
        EthIf_V2_ConstConfigLayoutType, EthIf_V1_ConfigLayoutType and EthIf_V2_ConfigLayoutType exist.
    04: Call EthIf_Init() with EthIf_Config_V1 to initialize EthIf with V1 configuration.
    05: Call EthIf_SetControllerMode() to set Ethernet interface controller mode to ACTIVE.
        The controller references an Ethernet switch EthIfSwitch_2 in variant V1.
    06: VP(SWS_EthIf_00257): Verify that all ports of a referenced switch are set to ACTIVE.
    07: Call EthIf_SetControllerMode() to set Ethernet interface controller mode to DOWN.
    08: VP(SWS_EthIf_00258): Verify that all ports of a referenced switch are set to DOWN.
    09: Call EthIf_Init() with EthIf_Config_V2 to initialize EthIf with V2 configuration.
    10: Call EthIf_SetControllerMode() to set Ethernet interface controller mode to ACTIVE.
        Controller references EthIfSwitch_2 in variant V2.
    11: VP(PostBuildSelectable.EthIfSwitchRefOrPortGroupRef, PostBuildSelectable.EthIfSwitchRef,
        PostBuildSelectable.EthIfSwitchIdx): Verify that selectable variants are supported for
        configuration parameters EthIfSwitchRef and EthIfSwitchRefOrPortGroupRef.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00257</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>610</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00258</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>611</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.PBSelectable.Master</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>981</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.PBSelectable.FileName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>979</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.PBSelectable.TypeName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>980</internalId></provcov>
        <provcov>
          <linksto>EthIf.dsn.Func.PostBuildSelectable.EthIfSwitchRefOrPortGroupRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1148</internalId></provcov>
        <provcov>
          <linksto>EthIf.dsn.Func.PostBuildSelectable.EthIfSwitchIdx</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1149</internalId></provcov>
        <provcov>
          <linksto>EthIf.dsn.Func.PostBuildSelectable.EthIfSwitchRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1150</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1470</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06002_SetControllerMode_PortGroup</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>331</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that when EthIfController which references a port group is set to ACTIVE,
    then all EthSwtPorts of referenced port group shall be switched on.
    And vice versa when all EthIfControllers that reference a port group are set to DOWN, then all
    ports of a port group will be switched off.
  
Test Object: 
    EthIf_SetControllerMode().
  
Test Precondition: 
    - EthIf initialized.
  
Test Execution: 
    01: Call EthIf_SetControllerMode() to set Ethernet interface controller mode to ACTIVE.
        The controller references a port group.
    02: VP(SWS_EthIf_00264, SWS_EthIf_00267): Verify that all ports of a referenced port group are
        set to ACTIVE. Port activation happens in the context of EthIf_CtrlModeIndication(), after
        EthSM_CtrlModeIndication() is called.
    03: Call EthIf_SetControllerMode() to set Ethernet interface controller mode to DOWN.
    04: VP(EthIf.ASR43.SWS_EthIf_00265): Verify that all ports of a referenced port group are set to DOWN.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00264</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>617</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00265</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00267</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>620</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1471</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06003_SwitchPortGroupRequestMode</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>453</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that when EthIf_SwitchPortGroupRequestMode() is called with mode ACTIVE,
    EthIf shall forward the call to the function EthSwt_SetSwitchPortMode() for all EthSwtPorts
    of the respective EthIfSwitchPortGroup, if ports are not already active.
    When EthIf_SwitchPortGroupRequestMode is called with  mode DOWN, EthIf shall start a switch-off
    timer for the respective port group. When this timer elapses, and no other port group holds
    the port, EthIf shall call EthSwt_SetSwitchPortMode() with mode DOWN for the corresponding
    EthSwtPort.
  
Test Object: 
    EthIf_SwitchPortGroupRequestMode().
  
Test Precondition: 
    - EthIf initialized.
    - EthIfController that does not reference any port group set to ACTIVE
  
Test Execution: 
    01: VP(SWS_EthIf_91102) Call EthIf_SwitchPortGroupRequestMode() to set port group under control
        of BswM to mode ACTIVE.
    02: VP(EthIf.ASR43.SWS_EthIf_00272): Verify that for all ports of a referenced port group
        EthSwt_SetSwitchPortMode() is called to set port mode to ACTIVE.
    03: Call EthIf_SwitchPortGroupRequestMode() to set port group to mode DOWN.
    04: VP(SWS_EthIf_00270) Verify that switch-off timer is started to delay port shut-down, i.e.
        EthSwt_SetSwitchPortMode() is not yet called.
    05: Call EthIf_SwitchPortGroupRequestMode() to set port group to mode ACTIVE.
    06: VP(EthIf.ASR43.SWS_EthIf_00272): Verify that EthSwt_SetSwitchPortMode() was not called since the
        requested mode and the current mode are the same. This is because the first DOWN request
        was delayed and was not propagated to switch ports, i.e. they remained active.
    07: Call EthIf_SwitchPortGroupRequestMode() to set port group to mode DOWN.
    08: Call EthIf_MainFunctionRx() to tick switch-off timer ETHIF_SWITCH_OFF_PORT_TIMEDELAY times.
    09: Call EthIf_MainFunctionRx() one more time to reach timer threshold.
    10: VP(EthIf.ASR43.SWS_EthIf_00271): Verify that after switch-off timer elapses, for all ports
        of a referenced port group EthSwt_SetSwitchPortMode() is called to set the port mode to DOWN.
    11: Call EthIf_SwitchPortGroupRequestMode() with no mode change.
    12: VP(SWS_EthIf_00270): Verify that Mode request is ignored if the mode does not change.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91102</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>747</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00272</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>76</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00270</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>623</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00271</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>75</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1472</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06004_StartAllPorts</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>623</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that when EthIf_StartAllPorts() is called, EthIf shall set the mode to ACTIVE
    of all ports which are not in a port group referenced and controlled by EthIfController and
    start a timer with EthIfPortStartupActiveTime for all this ports.
    When the timer to switch off all ports elapses EthIf shall call EthSwt_SetSwitchPortMode() with
    mode  DOWN for all ports which are not requested with mode ACTIVE via
    EthIf_SwitchPortGroupRequestMode().
  
Test Object: 
    EthIf_StartAllPorts().
  
Test Precondition: 
    - EthIf initialized.
  
Test Execution: 
    01: VP(SWS_EthIf_91103) Call EthIf_StartAllPorts() to set port mode to ACTIVE for all port
        groups that not under control of EthIfControllers(s).
    02: VP(SWS_EthIf_00275): Verify that for all ports of all port groups not controlled by
        EthIfController, EthSwt_SetSwitchPortMode() is called to set port mode to ACTIVE.
    03: VP(SWS_EthIf_00276) Verify that switch-off timer is started to delay port shut-down, i.e.
        EthSwt_SetSwitchPortMode() is not yet called.
    04: Call EthIf_MainFunctionRx() to tick shut-off timer ETHIF_PORT_STARTUP_ACTIVE_TIME - 1 times.
    05: Call EthIf_MainFunctionRx() one more time to reach timer threshold.
    06: VP(SWS_EthIf_00276): Verify that after switch-off timer elapses, for all ports from step 2,
        EthSwt_SetSwitchPortMode() is called to set the port mode to DOWN.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91103</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>748</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00275</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>77</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00276</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>78</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1473</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06005_StartAllPorts_PortGroupRequestMode</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>739</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that when the timer to switch off ports elapses (result of a call to
    EthIf_StartAllPorts()) EthSwt_SetSwitchPortMode() will be called only for those ports that
    are not in the meantime set to ACTIVE with EthIf_SwitchPortGroupRequestMode().
  
Test Object: 
    EthIf_StartAllPorts().
  
Test Precondition: 
    - EthIf initialized.
  
Test Execution: 
    01: Call EthIf_StartAllPorts() to set port mode to ACTIVE for all port groups that are not
        under control of EthIfControllers.
    02: Call EthIf_MainFunctionRx().
    03: VP(SWS_EthIf_00276): Verify that switch-off timer is started to delay port shut-down, i.e.
        EthSwt_SetSwitchPortMode() is not yet called.
    04: Call EthIf_SwitchPortGroupRequestMode() to set port group 3 (PortGroupIdx = 1) to ACTIVE.
    05: VP(EthIf.ASR43.SWS_EthIf_00272): Verify that for all ports of a referenced port group
        EthSwt_SetSwitchPortMode() is called to set port mode to ACTIVE.
    06: Call EthIf_MainFunctionRx() to tick switch-off timer ETHIF_PORT_STARTUP_ACTIVE_TIME - 1
        times.
    07: Call EthIf_MainFunctionRx() one more time to reach timer threshold.
    08: VP(SWS_EthIf_00276): Verify that after switch-off timer elapses, only for ports from a port
        group 0 (PortGroupIdx = 2), which are not part of a port group 3, EthSwt_SetSwitchPortMode()
        is called to set the port mode to DOWN.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00276</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>78</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00272</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>76</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1474</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06006_PortGroup_LinkStateChg</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>887</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies the process of reporting port group link state to SM and BswM.
  
Test Object: None.
Test Precondition: 
    - EthIfController_8 (EthIfControllerIdx = 8) is ACTIVE. It references a  switch, i.e. logical
      port group with Idx = 7. All ports are activated.
    - EthIfController_5 (EthIfControllerIdx = 6) is ACTIVE. It references a port group with Idx = 1,
      with a reference type = LINK_INFO (i.e. not controling ports)
    - PortGroup_3 (PortGroupIdx = 1) is ACTIVE. It is under control of BswM. All ports are active.
    - PortGroup_0 (PortGroupIdx = 2) is ACTIVE. It is under control of BswM. All ports are active.

     EthIfControllerIdx = 2 -&gt; EthIfPortGroupIdx = 5
     BswM                   -&gt; EthIfPortGroupIdx = 2
     EthIfControllerIdx = 6 -&gt; EthIfPortGroupIdx = 1

    PORTS(EthIf)  PORTS(ETHSWITCH)
    ------------------------------------------------
    EthIfPortGroupIdx: 1
    2, 1, 9       HOST(0,2) (0,1) (1,3)                   ACTIVATED SECOND
    EthIfPortGroupIdx: 2
    8, 7, 6, 9    UPLINK(1,2) HOST(1,1) (1,0) (1,3)       ACTIVATED THIRD
    EthIfPortGroupIdx(logical): 5
    6, 7, 8, 9    (1,0) HOST(1,1) UPLINK (1,2) (1,3)      ACTIVATED FIRST

  
Test Execution: 

    01: Call EthIf_MainFunctionRx(). Verify that relevant ports are polled, and that there is
        no change in a link state of a port group / EthIfController.
        PortGroupIdx_1(DOWN)
        PortGroupIdx_2(DOWN)
        PortGroupIdx_5(DOWN)

    02: Set link state as described below, call MainFunctionRx() and verify link state report:
        Port 7 - HOST(1,1): ACTIVE
        PortGroupIdx_1(DOWN)
        PortGroupIdx_2(DOWN): VP(SWS_EthIf_00259): Host port is ACTIVE, but UPLINK is still DOWN.
        PortGroupIdx_5(ACTIVE): VP(SWS_EthIf_00260, SWS_EthIf_00262) Port group 5 is a switch
                                (logical port group) -&gt;port group link state = host port link state.

    03: Set link state as described below, call MainFunctionRx() and verify link state report:
        Port 7 - HOST(1,1): ACTIVE, Port 8 - UPLINK(1,2): ACTIVE.
        PortGroupIdx_1(DOWN):
        PortGroupIdx_2(DOWN): VP(SWS_EthIf_00259) Port group 1 has both HOST and UPLINK ACTIVE,
                              but all STANDARD ports are DOWN -&gt; port group link state is DOWN.
        PortGroupIdx_5(ACTIVE):

    04: Set link state as described below, call MainFunctionRx() and verify link state report:
        Port 7 - HOST(1,1): ACTIVE, Port 8 - UPLINK(1,2): ACTIVE, Port 9 - ST(1,3): ACTIVE
        PortGroupIdx_1(DOWN):
        PortGroupIdx_2(ACTIVE): VP(SWS_EthIf_00259, EthIf.EB.SWS_EthIf_00261) Port group 1 has both
                                HOST and UPLINK ACTIVE, and one STANDARD port ACTIVE -&gt; port group
                                link state is ACTIVE.
        PortGroupIdx_5(ACTIVE):
    05: Set link state as described below, call MainFunctionRx() and verify link state report:
        PortGroupIdx_1(DOWN): VP(SWS_EthIf_00259, SWS_EthIf_00262)
        PortGroupIdx_2(DOWN): VP(SWS_EthIf_00259, EthIf.EB.SWS_EthIf_00261)
        PortGroupIdx_5(DOWN): VP(SWS_EthIf_00260, SWS_EthIf_00262)
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00259</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>612</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00260</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>613</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00261</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1129</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00262</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>615</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1475</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06009_PortGroup_AllPortsNotDown</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>1151</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that EthIf shall delay the shutdown of an EthIfPhysController referencing a
    EthIfSwitch (PortGroup) until all EthSwtPorts of the referenced switch are in state DOWN.
  
Test Object: 
    EthIf_SetControllerMode().
  
Test Precondition: 
    - EthIf initialized and controller which references a port group set to ACTIVE.
  
Test Execution: 
    01: Set EthSwt_SetSwitchPortMode_Stub for the first call to return E_NOT_OK.
    02: Call EthIf_SetControllerMode() to set Ethernet interface controller mode to DOWN.
    03: VP(EthIf.ASR43.SWS_EthIf_00265): Verify that all ports of a referenced switch are requested
        to go DOWN.
    04: VP((EthIf.EB.SetControllerModeDown.EthSM_CtrlModeIndication): Verify that
        EthSM_CtrlModeIndication() is called for this EthIfCtrl with mode DOWN.
    05: VP(SWS_EthIf_00256): Verify that physical controller was not shut down, i.e. no call
        to Eth_SetControllerMode().
    06: Call EthIf_MainFunctionRx().
    07: Reset EthSwt_SetSwitchPortMode_Stub for the first call to return E_OK and
        Eth_SetControllerMode_Stub to return E_NOT_OK.
    08: Call EthIf_MainFunctionRx() to repeat set operation for port that did not shut down.
    09: VP(SWS_EthIf_00256): Verify that Eth_SetControllerMode() is called.
    10: Set Eth_SetControllerMode_Stub to return E_OK.
    11: Call EthIf_MainFunctionRx() to repeat set operation for port that did not shut down.
    12: VP(SWS_EthIf_00256): Verify that since all ports are DOWN, physical controller is shut down
        too with Eth_SetControllerMode(), and SM is notified about it with
        EthSM_CtrlModeIndication().
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00256</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>609</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00265</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.SetControllerModeDown.EthSM_CtrlModeIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1132</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1476</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06011_SetModeTimeout_EthSwtGetLinkStateDown</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>1327</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that when a switch port (as a part of an active switch port group) is ACTIVE,
    and call to EthSwt_GetLinkState() returns ETHTRCV_LINK_STATE_DOWN for ETHIF_SET_MODE_TIMEOUT
    times, EthIf module shall repeat a call to EthSwt_SetSwitchPortMode().
  
Test Object: 
    EthIfSetModeTimeout
  
Test Precondition: 
    - EthIf initialized.
  
Test Execution: 
    01: Call EthIf_SetControllerMode() to set Ethernet interface controller mode to ACTIVE.
        Controller references PortGroup_3 (PortGoupIdx = 1).
    02: Call EthIf_MainFunctionRx() ETHIF_SET_MODE_TIMEOUT - 1 number of times.
    03: Call EthIf_MainFunctionRx() one more time to reach timeout threshold.
    04: VP(): Verify that EthSwt_SetSwitchPortMode() is called again after exactly
        ETHIF_SET_MODE_TIMEOUT cycles port link state is DOWN.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SetModeTimeout.RepeatRequest.EthSwtGetLinkStateDown</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>259</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1477</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06010_StartAllPorts_SetPortMode_NOK</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>1428</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that when EthIf_StartAllPorts() is called but at least one configured port
    can not be put to ACTIVE, function shall return E_NOT_OK.
  
Test Object: 
    EthIf_StartAllPorts().
  
Test Precondition: 
    - EthIf initialized.
  
Test Execution: 
    01: Set EthSwt_SetSwitchPortMode_Stub for one port to return E_NOT_OK.
    02: Call EthIf_StartAllPorts() to set port mode to ACTIVE for all port
        groups that not under control of EthIfControllers(s).
    03: VP(): Verify that E_NOT_OK is returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.StartAllPorts_SetPortMode_NOK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>262</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1478</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06012_SwitchPortGroup_SetSwitchPortMode_NOK</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>1508</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that when EthIf_SwitchPortGroupRequestMode is called with  mode DOWN,
    EthIf shall start a switch-off timer for all ports of the respective port group. When this
    timer elapses, and no other port group holds the port, EthIf shall call
    EthSwt_SetSwitchPortMode() with mode DOWN for the corresponding EthSwtPort. In case that not
    all ports of a port group can be set to DOWN, check will be repeated in the next
    MainFunction cycle.
  
Test Object: 
    EthIf_SwitchPortGroupRequestMode().
  
Test Precondition: 
    - EthIf initialized.
  
Test Execution: 
    01: VP(SWS_EthIf_91102) Call EthIf_SwitchPortGroupRequestMode() to set port group under control
        of BswM to mode ACTIVE.
    02: VP(EthIf.ASR43.SWS_EthIf_00272): Verify that for all ports of a referenced port group
        EthSwt_SetSwitchPortMode() is called to set port mode to ACTIVE.
    03: Call EthIf_MainFunctionRx().
    04: Call EthIf_SwitchPortGroupRequestMode() to set port group to mode DOWN.
    05: VP(SWS_EthIf_00270) Verify that switch-off timer is started to delay port shut-down, i.e.
        EthSwt_SetSwitchPortMode() is not yet called.
    06: Call EthIf_MainFunctionRx() to tick shut-off timer ETHIF_SWITCH_OFF_PORT_TIMEDELAY times.
    07: Set EthSwt_SetSwitchPortMode_Stub for one port to return E_NOT_OK.
    08: Call EthIf_MainFunctionRx() one more time to reach timer threshold.
    09: VP(EthIf.ASR43.SWS_EthIf_00271): Verify that after switch-off timer elapses, for all ports
        of a referenced port group EthSwt_SetSwitchPortMode() is called to set the port mode to DOWN.
    10: Set EthSwt_SetSwitchPortMode_Stub for one port to return E_OK.
    11: Call EthIf_MainFunctionRx() to repeat failed EthSwt_SetSwitchPortMode() operation.
    12: VP(EthIf.ASR43.SWS_EthIf_00271): Verify that EthSwt_SetSwitchPortMode() is called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91102</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>747</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00272</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>76</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00270</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>623</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00271</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>75</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1479</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06013_MainFunctionCycleCounter</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>1653</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies how EthIf handles activation/deactivation and link state computation in case
    two interface controllers reference the same port group.
  
Test Object: 
    EthIfSetModeTimeout
  
Test Precondition: 
    - EthIf initialized.
  
Test Execution: 
    01: Call EthIf_SetControllerMode() to set EthIfController_6 mode to ACTIVE.
        The controller references PortGroup_2 (PortGroupIdx = 3).
    02: VP(SWS_EthIf_00264): Verify that all port of a respective port group are requested to
        mode ACTIVE with a call EthSwt_SetSwitchPortMode().
    03: Call EthIf_SetControllerMode() to set EthIfController_3 mode to ACTIVE, which references
        the same port group as EthIfController_6.
    04: VP(SWS_EthIf_00264): Verify that no call to EthSwt_SetSwitchPortMode() is made because port
        group is already activated.
    05: Set EthSwt_GetLinkState stub to return link state ACTIVE for the first two calls
    06: Call EthIf_MainFunctionRx()
    07: VP(SWS_EthIf_00259): Verify that port group ports are polled with EthSwt_GetLinkState().
        First Two ports of a port group (1, 1) and (1, 0) are polled. Since both are polled as
        ACTIVE, the first one is HOST port and the second one is STANDARD, this information is
        sufficient to calculate link state of a port group to ACTIVE.
    08: VP(SWS_EthIf_00260): Verify that SM is notified about EthIfController link state change.
        Both interface controllers are notified because they share a common port group.
    09: VP(EthIf.EB.MainFunctionCycleCounter): Verify that port group link accumulation is done
        only once for the group, i.e. no duplicated calls to EthSwt_GetLinkState() were necessary.
    10: Call EthIf_MainFunctionRx() 512 times to update MainFunction cycle counter. This way we
        verify the case when cycle counter overflows 2 times.
    11: Call EthIf_SetControllerMode() to set EthIfController_6 mode to DOWN.
    12: VP(EthIf.EB.SetControllerModeDown.EthSM_CtrlModeIndication): Verify that
        EthSM_CtrlModeIndication() is called.
    13: VP(SWS_EthIf_00258): Verify that no port is switched off with EthSwt_SetSwitchPortMode()
        because there is another active interface controller that holds the port group.
    14: Call EthIf_SetControllerMode() to set EthIfController_3 mode to DOWN.
    15: VP(SWS_EthIf_00258): Verify that EthSwt_SetSwitchPortMode() is called to shut-down all ports
        of a group - since now both controller that reference the group are set to DOWN.
    16: VP(EthIf.EB.SetControllerModeDown.EthSM_CtrlModeIndication): Verify that
        EthSM_CtrlModeIndication() is called with mode DOWN.
    17: Call EthIf_MainFunctionRx()
    18: VP(SWS_EthIf_00256): Verify that shut down of EthIfController_6 was delayed until all ports
        of a port group are set to DOWN.
    19: VP(EthIf.EB.SetControllerModeDown.EthSM_CtrlModeIndication): Verify that
        EthSM_CtrlModeIndication() is called with mode DOWN.
    20: VP(EthIf.EB.MainFunctionRx.HW_GetsDown) Verify that link state of both EthIfControllers is
        reported DOWN because controller mode is set to DOWN.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00264</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>617</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00259</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>612</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00260</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>613</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00258</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>611</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00256</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>609</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.MainFunctionCycleCounter</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>265</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.MainFunctionRx.HW_GetsDown</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>181</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.SetControllerModeDown.EthSM_CtrlModeIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1132</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1480</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06014_PhyEthCtrlState_NotInitialized</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>1901</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that if PhyEthCtrls are not initialized, then their state can not be updated.
  
Test Object: 
    EthIf_MainFunctionRx().
  
Test Precondition: 
  
Test Execution: 
    01: Set Eth_ControllerInit_Stub to return E_NOT_OK.
    02: Call EthIf_Init().
    03: Call EthIf_MainFunctionRx().
    03: VP(): Verify that no futher actions are taken.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.PhyEthCtrlState_NotInit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>263</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1481</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06015_UpdateRequestedPortState</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>1955</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the functionality of EthIf_SetControllerMode function in case when
    EthSwt_SetSwitchPortMode_Stub returns E_NOT_OK.
  
Test Object: 
    EthIf_SetControllerMode().
  
Test Precondition: 
    - EthIf initialized.
  
Test Execution: 
    01: Set EthSwt_SetSwitchPortMode_Stub to return E_NOT_OK.
    02: Call EthIf_SetControllerMode() to set Ethernet interface controller mode to ACTIVE.
        The controller references an Ethernet switch.
    03: VP(SWS_EthIf_00257): Verify that all ports of a referenced switch are set to ACTIVE.
    04: Call EthIf_MainFunctionRx().
    05: VP(SWS_EthIf_00260): Verify that SM is notified about EthIfController link state change.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00257</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>610</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00260</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>613</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1482</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06016_PortGroup_LinkStateChg</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>2054</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies support of post-build selectable feature by initializing EthIf with two
    different variants and testing the functionality of EthIf_MainFunctionRx function in case when
    EthSwt_GetLinkState_Stub returns E_NOT_OK for variant V1 in which EthIfCtrl_1 has a
    EthIfSwitchRef. In variant V2 EthIfCtrl_1 has no EthIfSwitchRef.
  
Test Object: 
    EthIf_MainFunctionRx().
    Post-build selectable support.
  
Test Precondition: 
    Two post-build variants configured.
    V1: - EthIfCtrl_1/EthIfSwitchRefOrPortGroupRef: EthIfSwitch_1
    V2: - EthIfCtrl_/EthIfSwitchRefOrPortGroupRef: no ref
  
Test Execution: 
    01: Call EthIf_Init() with EthIf_Config_V1 to initialize EthIf with V1 configuration.
    02: Call EthIf_SetControllerMode() for EthIfCtrl_1 which has a EthIfSwitchRef.
    03: Set EthSwt_GetLinkState_Stub to return E_NOT_OK.
    04: Call EthIf_MainFunctionRx().
    05: VP(SWS_EthIf_00257): Verify that EthSwt_GetLinkState() is called.
    06: Set EthSwt_GetLinkState_Stub to return E_OK.
    07: Call EthIf_MainFunctionRx() again.
    08: VP(SWS_EthIf_00260): Verify that SM is notified about EthIfController link state change.
    09: Call EthIf_Init() with EthIf_Config_V2 to initialize EthIf with V2 configuration.
    10: Call EthIf_SetControllerMode() for EthIfCtrl_1 which now has no EthIfSwitchRef.
    11: VP(PostBuildSelectable.EthIfSwitchRefOrPortGroupRef): Verify that configuration parameter
        EthIfController/EthIfSwitchRefOrPortGroupRef supports multiple selectable variants for
        multiplicity i.e. EthIfSwitchRefOrPortGroupRef is removed in variant V2.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00257</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>610</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00260</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>613</internalId></provcov>
        <provcov>
          <linksto>EthIf.dsn.Func.PostBuildSelectable.EthIfSwitchRefOrPortGroupRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1148</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1483</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06017_MainFunction_SwitchPortMiiCheck</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>2212</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that prior accessing a port that is connected to a transceiver
    EthIf_MainFunction() will check if the respective port is locked. In that case access to a
    port will be skipped for subsequent MainFunction() invocation.
  
Test Object: 
    SetSwitchPortMode MII protection.
  
Test Precondition: 
    - EthIf initialized.
  
Test Execution: 
    01: Configure EthSwt_SetSwitchPortMode stub to return E_NOT_OK for the third invocation, i.e.
        for port (1,3) of a port group 3 (PortGroupIdx = 1), which is connected to the transceiver
        TrcvIdx = 0.
    02: Call EthIf_SwitchPortGroupRequestMode() to activate port group 3.
    03: VP(SWS_EthIf_00257): Verify that all ports of a referenced port group are requested to go
        to ACTIVE by calling EthSwt_SetSwitchPortMode().
    04: Reset EthSwt_SetSwitchPortMode stub counter and set it to return E_NOT_OK for the first
        following invocation.
    05: Call EthIf_MainFunctionRx().
    06: VP(EthIf.EB.Repeat.SetSwitchPortMode.HwNotOk): Verify that EthSwt_SetSwitchPortMode()
        is called again for the port (1,3) since it's last set mode operation returned E_NOT_OK.
    07: Reset EthSwt_SetSwitchPortMode_Stub, and configure its callout to call
        EthIf_MainFunctionRx().
    08: Call EthIf_SwitchPortGroupRequestMode() to activate port group 0 (PortGroupIdx=2).
        Port group 3 and 0 share once common port - (1,3), which is connected to transceiver 0.
    09: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag):
        Verify that during EthIf_MainFunctionRx() call, no call to EthSwt_SetSwitchPortMode()
        for port (1,3) is made. This is because a call to EthIf_SwitchPortGroupRequestMode() for
        port group 0 has locked all relevant transceivers of this port group, i.e. transceiver 0.
        Thus a call to EthSwt_SetSwitchPortMode() was skipped for this port.
    10: Call EthIf_MainFunctionRx().
    11: VP(EthIf.EB.Repeat.SetSwitchPortMode.HwNotOk): Verify that EthSwt_SetSwitchPortMode() is
        called again for the port (1,3) since it's previous set mode operation returned E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00257</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>610</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.Repeat.SetSwitchPortMode.HwNotOk</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>264</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>218</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1484</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06017_MainFunction_SwitchPortMiiCheck_Wakeup</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>2379</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that prior accessing a port that is connected to a transceiver
    EthIf_MainFunction() will check if the respective port is locked. In that case access to a
    port will not be skipped for subsequent MainFunction() invocation because
    EthIf_SwitchPortGroupRequestMode was called with ETHTRCV_MODE_ACTIVE_WITH_WAKEUP_REQUEST.
  
Test Object: 
    SetSwitchPortMode MII protection.
  
Test Precondition: 
    - EthIf initialized.
    - Wakeup and sleep on data line support is enabled
  
Test Execution: 
    01: Configure EthSwt_SetSwitchPortMode stub to return E_NOT_OK for the third invocation, i.e.
        for port (1,3) of a port group 3 (PortGroupIdx = 1), which is connected to the transceiver
        TrcvIdx = 0.
    02: Call EthIf_SwitchPortGroupRequestMode() to activate with wakeup request port group 3.
    03: VP(SWS_EthIf_00257): Verify that all ports of a referenced port group are requested to go
        to ACTIVE_WITH_WAKEUP_REQUEST by calling EthSwt_SetSwitchPortMode().
    04: Reset EthSwt_SetSwitchPortMode stub counter and set it to return E_NOT_OK for the first
        following invocation.
    05: Call EthIf_MainFunctionRx().
    06: VP(EthIf.EB.Repeat.SetSwitchPortMode.HwNotOk): Verify that EthSwt_SetSwitchPortMode()
        is called again for the port (1,3) since it's last set mode operation returned E_NOT_OK.
    07: Reset EthSwt_SetSwitchPortMode_Stub, and configure its callout to call
        EthIf_MainFunctionRx().
    08: Call EthIf_SwitchPortGroupRequestMode() to activate with wakeup request port group 0 (PortGroupIdx=2).
        Port group 3 and 0 share once common port - (1,3), which is connected to transceiver 0.
    09: VP(EthIf.EB.SWS_EthIf_00482):
        Verify that during EthIf_MainFunctionRx() call, call to all EthSwt_SetSwitchPortMode()
        was made.
    10: Call EthIf_MainFunctionRx().
    11: VP(EthIf.EB.Repeat.SetSwitchPortMode.HwNotOk): Verify that EthSwt_SetSwitchPortMode() is
        called again for the port (1,3) since it's previous set mode operation returned E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00257</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>610</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.Repeat.SetSwitchPortMode.HwNotOk</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>264</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00482</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>377</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1485</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06018_PortLinkState_ModeStateNotSet</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>2533</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the functionality of EthIf_MainFunctionRx function in case when
    EthSwt_SetSwitchPortMode_Stub returns E_NOT_OK.
  
Test Object: 
    EthIf_MainFunctionRx().
  
Test Precondition: 
    - EthIf initialized.
  
Test Execution: 
    01: Set EthSwt_SetSwitchPortMode_Stub to return E_NOT_OK.
    02: Call EthIf_SetControllerMode() to set Ethernet interface controller mode to ACTIVE.
    03: Call EthIf_MainFunctionRx().
    04: VP(SEthIf.ASR431.SWS_EthIf_00395, WS_EthIf_00271):
        Verify that EthSwt_GetPortSignalQuality and EthSwt_SetSwitchPortMode() are called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00271</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>75</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00395</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>759</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1486</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06019_SetSwitchPortMode_MiiCheck</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>2624</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that prior accessing a port that is connected to a transceiver
    EthIf_MainFunction() will check if the respective port is locked. In that case access to a
    port will be skipped for subsequent MainFunction() invocation.
  
Test Object: 
    SetSwitchPortMode MII protection.
  
Test Precondition: 
    - EthIf initialized.
  
Test Execution: 
    01: Configure EthSwt_SetSwitchPortMode stub call-out function to activate port group 0 with
        PortGroupIdx = 2 during first invocation.
    02: VP(): Verify that EthSwt_SetSwitchPortMode() is not called for the port (1,3).
        Port (1,3) is shared among port groups 3 and 0 and is connected to transceiver TrcvIdx = 0.
        When port group 3 is being activated, transceiver referenced by that port group is locked.
        So when port group 0 activation is requested it is executed for all ports accept for
        the port (1,3), because this port is already locked.
    03: Call EthIf_MainFunctionRx().
    04: VP(): Verify that EthSwt_SetSwitchPortMode() is called again for the port (1,3) since it's
        previous set mode operation returned E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.SetSwitchPortMode.CheckMiiAccessFlag</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>217</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1487</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06019_SetSwitchPortMode_MiiCheck_Wakeup</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>2725</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that prior accessing a port that is connected to a transceiver
    EthIf_MainFunction() will check if the respective port is locked. In that case access to a
    port will not be skipped for subsequent MainFunction() invocation because
    EthIf_SwitchPortGroupRequestMode was called with ETHTRCV_MODE_ACTIVE_WITH_WAKEUP_REQUEST.
  
Test Object: 
    SetSwitchPortMode MII protection.
  
Test Precondition: 
    - EthIf initialized.
    - Wakeup and sleep on data line support is enabled
  
Test Execution: 
    01: Configure EthSwt_SetSwitchPortMode stub call-out function to activate with wakeup request
        port group 0 with PortGroupIdx = 2 during first invocation.
    02: VP(EthIf.EB.SWS_EthIf_00482): Verify that EthSwt_SetSwitchPortMode() is called for all ports.
    03: Call EthIf_MainFunctionRx().
    04: VP(EthIf.EB.MIIExtension.SetSwitchPortMode.CheckMiiAccessFlag):
        Verify that EthSwt_SetSwitchPortMode() is called again for the port (1,3) since it's
        previous set mode operation returned E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00482</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>377</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.SetSwitchPortMode.CheckMiiAccessFlag</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>217</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1488</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06020_EthSwt_GetLinkState_MiiCheck</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>2896</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that prior accessing a port that is connected to a transceiver
    EthIf_MainFunction() will check if the respective port is locked. In that case access to a
    port will be skipped for subsequent MainFunction() invocation.
  
Test Object: 
    SetSwitchPortMode MII protection.
  
Test Precondition: 
    - EthIf initialized.
  
Test Execution: 
    01: Configure EthSwt_GetLinkState stub stub to return ACTIVE for the first and third invocation,
        i.e. for ports H(0,2) T1(0,1) T2(1,3). H is a HOST port, and Tx are ports connected to
        transceivers.
    02: Call EthIf_SwitchPortGroupRequestMode() to activate port group 3.
    03: Call EthIf_MainFunctionRx().
    04: VP(SWS_EthIf_00259, EthIf.EB.SWS_EthIf_00261): Verify that EthSwt_GetLinkState() is called for
        all ports of port group 3 and that accumulated link state is reported to BswM.
    05: Reset EthSwt_SetSwitchPortMode_Stub, and configure its call-out function to call
        EthIf_MainFunctionRx().
    06: Call EthIf_SwitchPortGroupRequestMode() to activate port group 0 (PortGroupIdx=2).
        Port group 3 and 0 share once common port - (1,3), which is connected to transceiver 0.
    07: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag):
        Verify that during EthIf_MainFunctionRx() call, no call to EthSwt_GetLinkStat()
        for port (1,3) is made. This is because a call to EthIf_SwitchPortGroupRequestMode() for
        port group 0 has locked all relevant transceivers of this port group, i.e. transceiver 0.
        Thus a call to EthSwt_GetLinkStat() was skipped for this port.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00259</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>612</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00261</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1129</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>218</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1489</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06020_EthSwt_GetLinkState_MiiCheck_Wakeup</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>3033</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that prior accessing a port that is connected to a transceiver
    EthIf_MainFunction() will check if the respective port is locked. In that case access to a
    port will be skipped for subsequent MainFunction() invocation.
    In this case EthIf_SwitchPortGroupRequestMode was called with ETHTRCV_MODE_ACTIVE_WITH_WAKEUP_REQUEST.
  
Test Object: 
    SetSwitchPortMode MII protection.
  
Test Precondition: 
    - EthIf initialized.
    - Wakeup and sleep on data line support is enabled
  
Test Execution: 
    01: Configure EthSwt_GetLinkState stub stub to return ACTIVE for the first and third invocation,
        i.e. for ports H(0,2) T1(0,1) T2(1,3). H is a HOST port, and Tx are ports connected to
        transceivers.
    02: Call EthIf_SwitchPortGroupRequestMode() to activate with wakeup request port group 3.
    03: Call EthIf_MainFunctionRx().
    04: VP(SWS_EthIf_00259, EthIf.EB.SWS_EthIf_00261): Verify that EthSwt_GetLinkState() is called for
        all ports of port group 3 and that accumulated link state is reported to BswM.
    05: Reset EthSwt_SetSwitchPortMode_Stub, and configure its call-out function to call
        EthIf_MainFunctionRx().
    06: Call EthIf_SwitchPortGroupRequestMode() to activate with wakeup request port group 0 (PortGroupIdx=2).
        Port group 3 and 0 share once common port - (1,3), which is connected to transceiver 0.
    07: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag):
        Verify that during EthIf_MainFunctionRx() call, no call to EthSwt_GetLinkStat()
        for port (1,3) is made. This is because a call to EthIf_SwitchPortGroupRequestMode() for
        port group 0 has locked all relevant transceivers of this port group, i.e. transceiver 0.
        Thus a call to EthSwt_GetLinkStat() was skipped for this port.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00259</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>612</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00261</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1129</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>218</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1490</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06021_GetSwitchPortSignalQuality</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>3173</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the functionality of EthIf_GetSwitchPortSignalQuality and
    EthIf_ClearSwitchPortSignalQuality functions.
  
Test Object: 
    EthIf_GetSwitchPortSignalQuality()
    EthIf_ClearSwitchPortSignalQuality().
  
Test Precondition: 
    - EthIf initialized.
  
Test Execution: 
    01: Call EthIf_SetControllerMode() to set Ethernet interface controller mode to ACTIVE.
        The controller references an Ethernet switch.
    02: Call EthIf_MainFunctionRx().
    03: Call EthIf_GetSwitchPortSignalQuality().
    04: VP(SWS_EthIf_00395): Verify that EthSwt_GetPortSignalQuality() is
        called with configured signal quality parameter.
    05: Call EthIf_ClearSwitchPortSignalQuality().
    06: VP(SWS_EthIf_91060, SWS_EthIf_00404): Verify that E_OK is returned.
    07: Call EthIf_MainFunctionRx().
    08: Call EthIf_GetSwitchPortSignalQuality().
    09: VP(SWS_EthIf_00395): Verify that EthSwt_GetPortSignalQuality() is
        called with configured signal quality parameter and that ActualSignalQuality,
        LowestSignalQuality and HighestSignalQuality have the same signal quality value due to the
        previous call of EthIf_ClearSwitchPortSignalQuality.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00395</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>759</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91060</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>779</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00404</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>766</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1491</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06022_GetSwitchPortSignalQuality_InvPort</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>3308</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the functionality of EthIf_GetSwitchPortSignalQuality and
    EthIf_ClearSwitchPortSignalQuality functions in case when invalid switch port index is used.
  
Test Object: 
    EthIf_GetSwitchPortSignalQuality()
    EthIf_ClearSwitchPortSignalQuality().
  
Test Precondition: 
    - EthIf initialized.
  
Test Execution: 
    01: Call EthIf_SetControllerMode() to set Ethernet interface controller mode to ACTIVE.
        The controller references an Ethernet switch.
    02: Call EthIf_MainFunctionRx().
    03: Call EthIf_GetSwitchPortSignalQuality() with invalid SwitchPortIdx.
    04: VP(EthIf.ASR431.SWS_EthIf_00397): Verify that E_NOT_OK is returned.
    05: Call EthIf_ClearSwitchPortSignalQuality() with invalid SwitchPortIdx.
    06: VP(EthIf.ASR431.SWS_EthIf_00406): Verify that E_NOT_OK is returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00397</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>761</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00406</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>768</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1492</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06023_RxIndication_EthIfPreProcessRxFrame_OK</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>3395</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_RxIndication() is called for the controller that references an
    Ethernet switch, function EthSwt_EthIfPreProcessRxFrame() shall be called to perform Ethernet
    switch delays compensation and if the result of this operation is OK frame will be processed.
  
Test Object: 
    EthIf_RxIndication().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Set EthSwt_EthIfPreProcessRxFrame_Stub to return TRUE.
    02: Call EthIf_RxIndication().
    03: VP(): Verify that EthSwt_EthIfPreProcessRxFrame() was called and returned TRUE.
    04: VP(): Verify that TcpIp_RxIndication() was called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.RxIndication.EthSwt_EthIfPreProcessRxFrame.OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1130</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1493</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06024_RxIndication_EthIfPreProcessRxFrame_NOK</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>3468</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_RxIndication() is called for the controller that references an
    Ethernet switch, function EthSwt_EthIfPreProcessRxFrame() shall be called to perform Ethernet
    switch delays compensation and if the result of this operation is false frame will be discarded.
  
Test Object: 
    EthIf_RxIndication().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Set EthSwt_EthIfPreProcessRxFrame_Stub to return FALSE.
    02: Call EthIf_RxIndication().
    03: VP(): Verify that EthSwt_EthIfPreProcessRxFrame() was called and returned FALSE.
    04: VP(): Verify that TcpIp_RxIndication() was not called as frame was discarded.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.RxIndication.EthSwt_EthIfPreProcessRxFrame.NOK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1131</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1494</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06025_ProvideTxBuffer_Enabled_Vlan</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>3542</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_ProvideTxBuffer() is called for the controller that references
    an Ethernet switch and has VLAN and EthIfSwtAdpatTxFrame enabled, functions
    EthSwt_EthIfTxAdaptFrameTypeBufferLength(), Eth_ProvideTxBuffer() &amp;
    EthSwt_EthIfTxPreProcessFrame() will be called and if EthIf_Transmit() is called for the same
    controller, functions EthSwt_EthIfTxAdaptFrameTypeBufferLength() &amp; Eth_Transmit() will be called.
    It also verifies the EthIf Retransmit functionality for the received and transmitted buffer.
  
Test Object: 
    EthIf_ProvideTxBuffer().
    EthIf_Retransmit().
  
Test Precondition: 
    EthIf initialized.
    switch EthIfSwtAdpatTxFrame enabled.
    A controller is in state ACTIVE.
  
Test Execution: 
    01: Call EthIf_ProvideTxBuffer() using a CtrlIdx that has EthIfVlanId enabled.
    02: Copy payload to Tx Buffer.
    03: VP(EthIf.EB.ProvideTxBuffer_EthSwtVLAN): Verify that BUFREQ_OK was returned.
    04: VP(EthIf.EB.ProvideTxBuffer_EthSwtVLAN): Verify that
        EthSwt_EthIfTxAdaptFrameTypeBufferLength() was called and that buffer length was increased
        for VLAN header length.
    05: VP(EthIf.EB.ProvideTxBuffer_EthSwtVLAN): Verify that Eth_ProvideTxBuffer() was called.
    06: VP(EthIf.EB.ProvideTxBuffer_EthSwt_EthIf): Verify that EthSwt_EthIfPreProcessTxFrame() was
        called and that buffer length is as in 03.
    07: VP(EthIf.EB.ProvideTxBuffer_BufferContent): Verify that Tx was copied correctly.
    08: Call EthIf_Transmit() using a CtrlIdx that has EthIfVlanId enabled.
    09: VP(EthIf.EB.Transmit_EthSwtVLAN): Verify that BUFREQ_OK was returned.
    10: VP(EthIf.EB.Transmit_EthSwtVLAN): Verify that EthSwt_EthIfTxAdaptFrameTypeBufferLength()
        was called and that buffer length was increased for both EthSwt and VLAN header lengths.
    11: VP(EthIf.EB.Transmit_EthSwtVLAN): Verify that Eth_Transmit() was called and that buffer
        length was increased for both EthSwt and VLAN header lengths.
    12: VP(EthIf.EB.Transmit_EthSwtVLAN): Verify that frame type contains first 2 bytes from EthSwt
        header bytes.
    13: Call EthIf_Retransmit() using a CtrlIdx &amp; OrigCtrlIdx that has EthIfVlanId enabled.
    14: VP(EthIf.EB.RetransmitExtension.Retransmit.Behaviour): Verify that Eth_Retransmit() has been
        called, parameters CtrlIdx &amp; OrigCtrlIdx have been passed correctly and E_OK has been returned.
    15: Set Priority member of RetransmitInfoPtr parameter to 0xFF.
    16: Call EthIf_Retransmit() to retransmitted an already transmitted buffer.
    17: VP(EthIf.EB.RetransmitExtension.Retransmit.Behaviour): Verify that Eth_Retransmit() has been
        called, parameters CtrlIdx &amp; OrigCtrlIdx have been passed correctly and E_OK has been returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.ProvideTxBuffer_EthSwtVLAN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>276</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.ProvideTxBuffer_EthSwt_EthIf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>278</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.ProvideTxBuffer_BufferContent</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>277</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.Transmit_EthSwtVLAN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>279</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.RetransmitExtension.Retransmit.Behaviour</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>300</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1495</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06026_GetSwitchPortSignalQuality_NOK</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>3775</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the functionality of EthIf_GetSwitchPortSignalQuality() in case when called function
    EthSwt_GetPortSignalQuality() returns E_NOT_OK.
  
Test Object: 
    EthIf_GetSwitchPortSignalQuality()
  
Test Precondition: 
    - EthIf initialized.
  
Test Execution: 
    01: Call EthIf_SetControllerMode() to set Ethernet interface controller mode to ACTIVE.
        The controller references an Ethernet switch.
    02: Set EthSwt_GetPortSignalQuality_Stub to return E_NOT_OK.
    03: Call EthIf_MainFunctionRx().
    04: Call EthIf_GetSwitchPortSignalQuality().
    05: VP(EthIf.ASR431.SWS_EthIf_91058): Verify that E_NOT_OK is returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91058</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>777</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1496</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06027_EthIf_GetIngressTimeStamp_VLAN</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>3893</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_GetIngressTimeStamp() is called for the controller that has
    VLAN enabled, passed data will be moved for the size of ethernet header length with VLAN tagging
    inserted, before the call of Eth_GetIngressTimeStamp().
  
Test Object: 
    EthIf_GetIngressTimeStamp().
  
Test Precondition: 
    EthIf initialized.
    VLAN support &amp; GlobalTimeSupport enabled.
  
Test Execution: 
    01: Call EthIf_GetIngressTimeStamp().
    02: VP(): Verify that Eth_GetIngressTimeStamp() was called with valid parameters.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.GetIngressTimeStamp_EthVLAN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>280</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1497</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06028_EthIf_PortGroup_Inv</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>3964</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies the functionality of EthIf_MainFunctionRx when
    Eth_SetControllerMode function returns E_NOT_OK.
  
Test Object: 
    EthIf_MainFunctionRx().
  
Test Precondition: 
    EthIf initialized.
    EthIfSwitchRefOrPortGroupRef not defined.
  
Test Execution: 
    01: Set Eth_SetControllerMode stub to return E_NOT_OK.
    02: Call EthIf_SetControllerMode() with ETH_MODE_ACTIVE.
    03: VP(EthIf.EB.SetCtrlMode.HwNotOk): Verify that EthIf_SetControllerMode()
        returns E_NOT_OK.
    04: Call EthIf_MainFunctionRx().
    05: VP(EthIf.EB.VirtCtrlAccess.RepeatSetCtrlModeActive.HwNotOk):
        Verify that Eth_SetControllerMode() is called.
    06: Set Eth_SetControllerMode stub to return E_OK.
    07: Call EthIf_MainFunctionRx() again.
    08: VP(EthIf.EB.VirtCtrlAccess.RepeatSetCtrlModeActive.HwNotOk):
        Verify that Eth_SetControllerMode() is called.
    09: VP(SWS_EthIf_00252): Verify that EthSM_CtrlModeIndication() is called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SetCtrlMode.HwNotOk</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>159</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.VirtCtrlAccess.RepeatSetCtrlModeActive.HwNotOk</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>161</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00252</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>575</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1498</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06029_AllPortsNotDown_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>4058</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that EthIf shall delay the shutdown of an EthIfPhysController referencing a
    EthIfSwitch (PortGroup) until all EthSwtPorts of the referenced switch are in state DOWN.
  
Test Object: 
    EthIfSetModeTimeout
  
Test Precondition: 
    - EthIf initialized.
  
Test Execution: 
    01: Call EthIf_SetControllerMode() to set EthIfController_0 mode to ACTIVE.
        The controller references EthIfPhysController_0 and EthIfSwitch_0.
    02: VP(SWS_EthIf_00264): Verify that all port of a referenced switch are requested to
        go ACTIVE with a call EthSwt_SetSwitchPortMode().
    03: Call EthIf_SetControllerMode() to set EthIfController_2 mode to ACTIVE.
        The controller references the same physical controller (EthIfPhysController_0) as
        EthIfController_0 and EthIfSwitchPortGroup_1, which references all ports of EthIfSwitch_0.
    04: VP(SWS_EthIf_00264): Verify that no call to EthSwt_SetSwitchPortMode() is made because port
        group is already activated.
    05: Call EthIf_SetControllerMode() to set EthIfController_2 mode to DOWN.
    06: VP(EthIf.EB.SetControllerModeDown.EthSM_CtrlModeIndication): Verify that
        EthSM_CtrlModeIndication() is called for this EthIfCtrl with mode DOWN.
    07: VP(SWS_EthIf_00258): Verify that no port is switched off with EthSwt_SetSwitchPortMode()
        because there is another active interface controller that holds the same ports.
    08: Call EthIf_SetControllerMode() to set EthIfController_0 mode to DOWN.
    09: VP(SWS_EthIf_00258): Verify that EthSwt_SetSwitchPortMode() is called to shut-down all ports
        of a group - since now both controllers that reference the same ports are set to DOWN.
    10: VP(EthIf.EB.SetControllerModeDown.EthSM_CtrlModeIndication): Verify that
        EthSM_CtrlModeIndication() is called for this EthIfCtrl with mode DOWN.
    11: Call EthIf_MainFunctionRx().
    12: VP(SWS_EthIf_00256): Verify that shut down of EthIfPhysController_0 was delayed until all
        ports of switch and port group are set to DOWN.
    13: VP(EthIf.EB.SetControllerModeDown.EthSM_CtrlModeIndication): Verify that
        EthSM_CtrlModeIndication() is called for this EthIfCtrl with mode DOWN.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00264</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>617</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00258</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>611</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00256</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>609</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.SetControllerModeDown.EthSM_CtrlModeIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1132</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1499</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06030_Retransmit_NonVlanCtrl</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>4226</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_Retransmit() is called with non compatible EthIf
    controllers i.e. original EthIf controller uses VLAN and EthIf controller uses no
    VLAN or vice versa) E_NOT_OK will be returned.
  
Test Object: 
    EthIf_Retransmit().
  
Test Precondition: 
    EthIf initialized.
    VLAN support &amp; RetransmitApi enabled.
  
Test Execution: 
    01: Call EthIf_Retransmit() with non-VLAN CtrlIdx and VLAN OrigCtrlIdx.
    02: VP(EthIf.EB.RetransmitExtension.Retransmit.InvCtrlIndexes): Verify that
        E_NOT_OK is returned.
    03: Call EthIf_Retransmit() with VLAN CtrlIdx and non-VLAN OrigCtrlIdx.
    04: VP(EthIf.EB.RetransmitExtension.Retransmit.InvCtrlIndexes)): Verify that
        E_NOT_OK is returned.
    03: Call EthIf_Retransmit() with both non-VLAN Controllers.
    04: VP(EthIf.EB.RetransmitExtension.Retransmit.ApiSignature,
           EthIf.EB.RetransmitExtension.Retransmit.Behaviour): Verify that Eth_Retransmit()
           has been called and E_OK is returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.RetransmitExtension.Retransmit.InvCtrlIndexes</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>301</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.RetransmitExtension.Retransmit.ApiSignature</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>298</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1500</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06031_SetControllerMode_PortGroup</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>4349</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies support of post-build selectable feature by initializing EthIf with two
    different variants and testing that when EthIfController which references a SwitchPortGroup
    of type "control" in variant V1 is set to ACTIVE, then all EthSwtPorts of referenced port group
    shall be switched on. And vice versa if EthIf_SetController is called for an EthIfController with
    ETH_MODE_DOWN and this EthIfController has a reference to an EthIfSwitchPortGroup of type
    "control" then EthIf shall forward the call to function EthSwt_SetSwitchPortMode for all ports
    of the respective EthIf_SwitchPortGroup. In variant V2 referenced SwitchPortGroup is of type
    "Link_Info", so its ports shall not be switched on when EthIfController is set to ACTIVE.
  
Test Object: 
    EthIf_SetControllerMode().
    Post-build selectable support.
  
Test Precondition: 
    Two post-build variants configured.
    V1: - EthIfSwitchPortGroup_2/EthIfSwitchPortGroupRefSemantics: ETHIF_SWITCH_PORT_GROUP_CONTROL
    V2: - EthIfSwitchPortGroup_2/EthIfSwitchPortGroupRefSemantics: ETHIF_SWITCH_PORT_GROUP_LINK_INFO
  
Test Execution: 
    01: Call EthIf_Init() with EthIf_Config_V1 to initialize EthIf with V1 configuration.
    02: Call EthIf_SetControllerMode() to set Ethernet interface controller mode to ACTIVE.
        The controller references a Switch port group of type "control".
    03: VP(SWS_EthIf_00264, SWS_EthIf_00267): Verify that all ports of a referenced port group are
        set to ACTIVE. Port activation happens in the context of EthIf_CtrlModeIndication(), after
        EthSM_CtrlModeIndication() is called.
    04: Call EthIf_SetControllerMode() to set 2nd Virtual Ethernet interface controller that belongs
        to the same Physical Controler to ACTIVE.
    05: Call EthIf_SetControllerMode() to set 3rd Virtual Ethernet interface controller that belongs
        to the same Physical Controler to ACTIVE.
    06: Call EthIf_SetControllerMode() to set last Virtual Ethernet interface controller that belongs
        to the same Physical Controler to ACTIVE.
    07: Reset EthSwt stub.
    08: Call EthIf_SetControllerMode() to set Ethernet interface controller mode to DOWN.
        The controller references a Switch port group of type "control".
    09: VP(EthIf.ASR43.SWS_EthIf_00265): Verify that all ports of a referenced port group are set to
        DOWN.
    10: VP(EthIf.EB.SetControllerModeDown.EthSM_CtrlModeIndication): Verify that
        EthSM_CtrlModeIndication() is called for this EthIfCtrl with mode DOWN.
    11: Call EthIf_SetControllerMode() to set 3rd Virtual Ethernet interface controller that belongs
        to the same Physical Controler to DOWN.
    12: VP(EthIf.EB.SetControllerModeDown.EthSM_CtrlModeIndication): Verify that
        EthSM_CtrlModeIndication() is called for this EthIfCtrl with mode DOWN.
    13: Call EthIf_SetControllerMode() to set last Virtual Ethernet interface controller that belongs
        to the same Physical Controler to DOWN.
    14: VP(EthIf.EB.SetControllerModeDown.EthSM_CtrlModeIndication): Verify that
        EthSM_CtrlModeIndication() is called for this EthIfCtrl with mode DOWN.
    15: Reset EthSwt stub.
    16: Call EthIf_SetControllerMode() to set Ethernet interface controller mode to ACTIVE again.
        The controller references a Switch port group of type "control".
    17: VP(SWS_EthIf_00264, SWS_EthIf_00267): Verify that all ports of a referenced port group are
        set to ACTIVE.
    18: Call EthIf_Init() with EthIf_Config_V2 to initialize EthIf with V2 configuration.
    19: Call EthIf_SetControllerMode() to set Ethernet interface controller mode to ACTIVE.
        The controller now references a Switch port group of type "link_info".
    20: VP(PostBuildSelectable.EthIfSwitchPortGroupRefSemantics): Verify that selectable variants
        are supported for configuration parameter EthIfSwitchPortGroupRefSemantics as ports of a
        referenced port group are not set to ACTIVE.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00264</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>617</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00265</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00267</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>620</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.SetControllerModeDown.EthSM_CtrlModeIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1132</internalId></provcov>
        <provcov>
          <linksto>EthIf.dsn.Func.PostBuildSelectable.EthIfSwitchPortGroupRefSemantics</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1152</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1501</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06032_BswMPortGroup_LinkStateChg</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>4629</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies the process of reporting port group link state to BswM.
  
Test Object: None.
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_SetControllerMode() to activate EthIfController_3 (EthIfCtrlIdx = 4), which
        references PortGroup_2 (PortGroupIdx = 3). This activates all related ports: (1,1),
        (1,0) and (0,3).
    02: Call EthIf_SwitchPortGroupRequestMode() to activate PortGroup_0 (PortGroupIdx = 2) as it
        is controlled by BswM. This activates only group ports that are not yet activated: (1,2)
        and (1,3).
    03: Call EthIf_MainFunctionRx().
    04: VP(EthIf.ASR43.SWS_EthIf_00259, EthIf.EB.SWS_EthIf_00261):
        Verify that link state of all relevant ports is polled, and that there is no change in a
        link state of a port groups, i.e. PortGroupIdx_3(DOWN) and PortGroupIdx_2(DOWN).
    05: Set link state of ports (1,2) and (1,1) and (1,0) to active and call MainFunctionRx()
        to process the change.
    06: VP(EthIf.ASR43.SWS_EthIf_00259, EthIf.EB.SWS_EthIf_00261):
        Verify that that port group link state has changed and reported as follows:
        PortGroupIdx_3(ACTIVE) - reported by BswM_EthIf_PortGroupLinkStateChg()
        PortGroupIdx_2(ACTIVE) - reported by EthSM_TrcvLinkStateChg().
    07: Call EthIf_SwitchPortGroupRequestMode() to deactivate PortGroup_0 (PortGroupIdx = 2).
    08: Call EthIf_MainFunctionRx() to tick shut-off timer ETHIF_SWITCH_OFF_PORT_TIMEDELAY times.
    09: VP(EthIf.EB.SWS_EthIf_00261): Verify that link state of all relevant ports is polled
        during shut-down delay period.
    10: Call EthIf_MainFunctionRx() one more times to expire shut-off delay timer.
    11: VP(EthIf.ASR43.SWS_EthIf_00271): Verify that two ports of PortGroup_0 that are not shared
        with PortGroup_2 - (1, 2), (1, 3) are deactivated by the call EthSwt_SetSwitchPortMode().
    12: VP(EthIf.EB.SWS_EthIf_00261): Verify that BswM_EthIf_PortGroupLinkStateChg() is called
        to report port group link state DOWN although accumulated port group link state is
        still active.
    13: Call EthIf_MainFunctionRx().
    14: Call EthIf_SwitchPortGroupRequestMode() to activate PortGroup_0 (PortGroupIdx = 2).
    15: Call EthIf_MainFunctionRx().
    16: VP(EthIf.ASR43.SWS_EthIf_00259, EthIf.EB.SWS_EthIf_00261):
        Verify that that port group link state has changed for a PortGroup_0 and reported with
        BswM_EthIf_PortGroupLinkStateChg(ACTIVE).
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00259</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>612</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00261</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1129</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00271</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>75</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1502</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06034_BswMPortGroup_LinkStateChg_LINK_INFO</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>4928</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies the process of reporting port group link state to BswM and EthSM
    for a port group that is under control of BswM but has LINK_INFO port group semantics.
    It verifies that during the shut-down period port group link state reports the actual
    accumulated link state.
  
Test Object: None.
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_SetControllerMode() to activate EthIfController_5 (EthIfCtrlIdx = 6), which
        references PortGroup_3 (PortGroupIdx = 1). This will not activate port group ports since
        this port group is under the control of BswM, i.e. EthIfSwitchPortGroupRefSemantics ==
        ETHIF_SWITCH_PORT_GROUP_LINK_INFO.
    02: Call EthIf_SwitchPortGroupRequestMode() to activate PortGroup_3. This activates all group
        ports: (0,2) (0,1) (1,3).
    03: VP(EthIf.ASR43.SWS_EthIf_00259): Call EthIf_MainFunctionRx() and verify that link state is
        polled only for the first port in the group, since it is a host port and it is DOWN.
        Consequently accumulated link state of a port group is DOWN, no need to report the change
        to BswM / EthSM.
    04: Set EthSwt_GetLinkState stub to report link state ACTIVE for all 3 ports: (0,2) (0,1) (1,3)
        and call EthIf_MainFunctionRx().
    05: VP(EthIf.ASR43.SWS_EthIf_00259, EthIf.EB.SWS_EthIf_00261):
        Verify that that port group link state has changed and reported as ACTIVE to
        BswM_EthIf_PortGroupLinkStateChg() and EthSM_TrcvLinkStateChg().
    06: Call EthIf_SwitchPortGroupRequestMode() to deactivate PortGroup_3.
    07: VP(EthIf.EB.SWS_EthIf_00261): Call EthIf_MainFunctionRx() and verify that no link state
        change has been reported since port-shut down was delayed.
    08: Set EthSwt_GetLinkState stub to report link state DOWN for the host port port: (0,2).
    09: VP(EthIf.ASR43.SWS_EthIf_00259, EthIf.EB.SWS_EthIf_00261):
        Call EthIf_MainFunctionRx() and verify that port group link state has changed and reported
        as DOWN to BswM_EthIf_PortGroupLinkStateChg() and EthSM_TrcvLinkStateChg().
    10: Set EthSwt_GetLinkState stub to report link state ACTIVE for the host port port: (0,2).
    11: VP(EthIf.ASR43.SWS_EthIf_00259, EthIf.EB.SWS_EthIf_00261):
        Call EthIf_MainFunctionRx() and verify that port group link state has changed and reported
        as ACTIVE to BswM_EthIf_PortGroupLinkStateChg() and EthSM_TrcvLinkStateChg().
    12: Call EthIf_MainFunctionRx() to tick shut-off timer ETHIF_SWITCH_OFF_PORT_TIMEDELAY times.
    13: VP(EthIf.EB.SWS_EthIf_00261): Verify that link state of all relevant ports is polled during
        shut-down delay period.
    14: Call EthIf_MainFunctionRx() one more times to expire shut-off delay timer.
    15: VP(EthIf.ASR43.SWS_EthIf_00271): Verify that all ports of PortGroup_3 are deactivated by
        the call EthSwt_SetSwitchPortMode().
    16: VP(EthIf.EB.SWS_EthIf_00261): Verify that port group link state has changed and reported
        as DOWN to BswM_EthIf_PortGroupLinkStateChg() and EthSM_TrcvLinkStateChg().
    17: Call EthIf_SwitchPortGroupRequestMode() to activate PortGroup_3. This activates all group
        ports: (0,2) (0,1) (1,3).
    18: VP(EthIf.ASR43.SWS_EthIf_00259): Call EthIf_MainFunctionRx() and verify that port group
        link state has changed and reported as ACTIVE to BswM_EthIf_PortGroupLinkStateChg()
        and EthSM_TrcvLinkStateChg() since link state stubs are set to return ACTIVE.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00259</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>612</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00261</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1129</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00271</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>75</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1503</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06033_SetControllerMode_PortGroup_Variants</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>5254</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies support of post-build selectable feature by initializing EthIf with
    two different variants and testing verifies that all EthSwtPorts of referenced port
    group shall be switched on when EthIfController which references a SwitchPortGroup is set to
    ACTIVE. Variants V1 &amp; V2 have different number and values of EthIfPortRefs as well as different
    PortGroupIdx.
  
Test Object: 
    Post-build selectable support.
  
Test Precondition: 
    Two post-build variants configured.
    V1: - PortGroupIdx: 24
        - number of ports in PortGroup:4
    V2: - PortGroupIdx: 23
        - number of ports in PortGroup:2 and 1st EthIfPortRef different than in V1
  
Test Execution: 
    01: Call EthIf_Init() with EthIf_Config_V1 to initialize EthIf with V1 configuration.
    02: Call EthIf_SetControllerMode() for EthIfCtrl_1 which references a PortGroup with
        EthIfSwitchPortGroupIdx = 24.
    03: VP(PostBuildSelectable.EthIfPortRef): Verify that EthSwt_SetSwitchPortMode is called for all
        the switch ports configured in V1.
    04: Call EthIf_Init() with EthIf_Config_V2 to initialize EthIf with V2 configuration.
    05: Call EthIf_SetControllerMode() for EthIfCtrl_1 which references a PortGroup with
        EthIfSwitchPortGroupIdx = 23.
    06: VP(PostBuildSelectable.EthIfSwitchPortGroupIdx, PostBuildSelectable.EthIfPortRef): Verify
        that EthSwt_SetSwitchPortMode is called for all the switch ports configured in V2.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.dsn.Func.PostBuildSelectable.EthIfSwitchPortGroupIdx</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1151</internalId></provcov>
        <provcov>
          <linksto>EthIf.dsn.Func.PostBuildSelectable.EthIfPortRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1153</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1504</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06000_Cbk_RxIndication_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>5390</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_Cbk_RxIndication() is called when the module is not
    initialized, ETHIF_E_NOT_INITIALIZED will be reported to DET.
  
Test Object: 
    EthIf_Cbk_RxIndication()
  
Test Precondition: 
  
Test Execution: 
    01: Call EthIf_Cbk_RxIndication() in UNINIT state.
    02: VP(ETHIF085_3a): Verify that DET was called with ETHIF_E_NOT_INITIALIZED.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.ETHIF085_3a</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>143</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1505</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06000_Cbk_RxIndication_InvCtrlIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>5439</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_Cbk_RxIndication() is called with invalid CtrlIdx,
    ETHIF_E_INV_CTRL_IDX will be reported to DET.
  
Test Object: 
    EthIf_Cbk_RxIndication()
  
Test Precondition: 
    EthIf is initialized.
  
Test Execution: 
    01: Call EthIf_Cbk_RxIndication() using an invalid CtrlIdx.
    02: VP(ETHIF085_3b): Verify that DET was called with ETHIF_E_INV_CTRL_IDX.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.ETHIF085_3b</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>144</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1506</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06000_GetSwitchPortSignalQuality_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>5493</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_GetSwitchPortSignalQuality() is called when the module is not
    initialized, ETHIF_E_NOT_INITIALIZED will be reported to DET and E_NOT_OK will be returned.
  
Test Object: 
    EthIf_GetSwitchPortSignalQuality()
  
Test Precondition: 
  
Test Execution: 
    01: Call EthIf_GetSwitchPortSignalQuality() in UNINIT state.
    02: VP(EthIf.ASR431.SWS_EthIf_00396): Verify that DET was called with
        ETHIF_E_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00396</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>760</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1507</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06000_GetSwitchPortSignalQuality_InvSwtIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>5544</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_GetSwitchPortSignalQuality() is called with invalid SwtIdx,
    ETHIF_E_INV_SWT_IDX will be reported to DET and E_NOT_OK will be returned.
  
Test Object: 
    EthIf_GetSwitchPortSignalQuality()
  
Test Precondition: 
  
Test Execution: 
    01: Call EthIf_GetSwitchPortSignalQuality() in UNINIT state.
    02: VP(EthIf.ASR431.SWS_EthIf_00397): Verify that DET was called with
        ETHIF_E_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00397</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>761</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1508</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06000_GetSwitchPortSignalQuality_InvalidResultPtr</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>5598</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_GetSwitchPortSignalQuality() is called with invalid ResultPtr,
    ETHIF_E_PARAM_POINTER will be reported to DET and E_NOT_OK will be returned.
  
Test Object: 
    EthIf_GetSwitchPortSignalQuality()
  
Test Precondition: 
  
Test Execution: 
    01: Call EthIf_GetSwitchPortSignalQuality() in UNINIT state.
    02: VP(EthIf.ASR431.SWS_EthIf_00399): Verify that DET was called with
        ETHIF_E_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00399</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>762</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1509</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06000_ClearSwitchPortSignalQuality_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>5651</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_ClearSwitchPortSignalQuality() is called when the module is not
    initialized, ETHIF_E_NOT_INITIALIZED will be reported to DET and E_NOT_OK will be returned.
  
Test Object: 
    EthIf_ClearSwitchPortSignalQuality()
  
Test Precondition: 
  
Test Execution: 
    01: Call EthIf_ClearSwitchPortSignalQuality() in UNINIT state.
    02: VP(EthIf.ASR431.SWS_EthIf_00405): Verify that DET was called with
        ETHIF_E_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00405</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>767</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1510</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06000_ClearSwitchPortSignalQuality_InvSwtIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>5702</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_ClearSwitchPortSignalQuality() is called with invalid SwtIdx,
    ETHIF_E_INV_SWT_IDX will be reported to DET and E_NOT_OK will be returned.
  
Test Object: 
    EthIf_ClearSwitchPortSignalQuality()
  
Test Precondition: 
  
Test Execution: 
    01: Call () in UNINIT state.
    02: VP(EthIf.ASR431.SWS_EthIf_00406): Verify that DET was called with
        ETHIF_E_INV_SWT_IDX and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00406</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>768</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1511</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06000_ClearTrcvSignalQuality_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>5755</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_ClearTrcvSignalQuality() is called when the module is not
    initialized, ETHIF_E_NOT_INITIALIZED will be reported to DET and E_NOT_OK will be returned.
  
Test Object: 
    EthIf_ClearTrcvSignalQuality()
  
Test Precondition: 
  
Test Execution: 
    01: Call EthIf_ClearTrcvSignalQuality() in UNINIT state.
    02: VP(EthIf.ASR431.SWS_EthIf_00401): Verify that DET was called with
        ETHIF_E_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00401</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>764</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1512</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06000_ClearTrcvSignalQuality_InvalidTrcvIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>5806</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_ClearTrcvSignalQuality() is called with invalid TrcvIdx,
    ETHIF_E_INV_TRCV_IDX will be reported to DET and E_NOT_OK will be returned.
  
Test Object: 
    EthIf_ClearTrcvSignalQuality()
  
Test Precondition: 
    EthIf is initialized.
  
Test Execution: 
    01: Call EthIf_ClearTrcvSignalQuality() with invalid TrcvIdx.
    02: VP(EthIf.ASR431.SWS_EthIf_00402): Verify that DET was called with
        ETHIF_E_INV_TRCV_IDX and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00402</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>765</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1513</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06000_CtrlModeIndication_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>5861</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_CtrlModeIndication() is called when the module is not
    initialized, ETHIF_E_NOT_INITIALIZED will be reported to DET and E_NOT_OK will be returned.
  
Test Object: 
    EthIf_CtrlModeIndication()
  
Test Precondition: 
  
Test Execution: 
    01: Call EthIf_CtrlModeIndication() in UNINIT state.
    02: VP(EthIf.EB.CtrlModeIndication.DetCheck.NotInit): Verify that DET was called with
        ETHIF_E_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.CtrlModeIndication.DetCheck.NotInit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>307</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1514</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06000_TrcvModeIndication_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>5908</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_TrcvModeIndication() is called when the module is not
    initialized, ETHIF_E_NOT_INITIALIZED will be reported to DET and E_NOT_OK will be returned.
  
Test Object: 
    EthIf_TrcvModeIndication()
  
Test Precondition: 
  
Test Execution: 
    01: Call EthIf_TrcvModeIndication() in UNINIT state.
    02: VP(EthIf.EB.TrcvModeIndication.DetCheck.NotInit): Verify that DET was called with
        ETHIF_E_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.TrcvModeIndication.DetCheck.NotInit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>308</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1515</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06035_RptSecEvToIdsM_ETHIF_SEV_DROP_INV_VLAN</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>5987</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if reporting security events to IdsM is enabled and EthIf_RxIndication()
    is called with invalid CrtlIdx, EthIf module shall report event (ETHIF_SEV_DROP_INV_VLAN) to
    the IdsM via the IdsM_SetSecurityEvent interface. Test also verifies that
    securityEventId=ETHIF_SEV_DROP_INV_VLAN is post-build selectable.
  
Test Object: 
    IdsM reporting feature.
  
Test Precondition: 
  
Test Execution: 
    01: Call EthIf_Init() with EthIf_Config_V1 to initialize EthIf with V1 configuration.
    02: Call EthIf_SetControllerMode() to set Ethernet interface controller mode to ACTIVE.
    03: Call EthIf_RxIndication() with invalid CrtlIdx.
    04: VP(ECUC_EthIf_00083, ECUC_EthIf_00079): If reporting events to
        IdsM is enabled, verify that IdsM_SetSecurityEvent() was called with value from V1
        configuration securityEventId = ETHIF_SEV_DROP_INV_VLAN. If reporting is not enabled
        verify that IdsM_SetSecurityEvent() was not called.
    05: Call EthIf_Init() with EthIf_Config_V2 to initialize EthIf with V2 configuration.
    06: Call EthIf_SetControllerMode() to set Ethernet interface controller mode to ACTIVE.
    07: Call EthIf_RxIndication() with invalid CrtlIdx.
    08: VP(dsn.Func020.EB.PostBuildLoadable.ETHIF_SEV_DROP_INV_VLAN,ECUC_EthIf_00079): If reporting
        events to IdsM is enabled, verify that IdsM_SetSecurityEvent() was called with value form V2
        configuration securityEventId = ETHIF_SEV_DROP_INV_VLAN_V2. If reporting is not enabled
        verify that IdsM_SetSecurityEvent() was not called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00083</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>848</internalId></provcov>
        <provcov>
          <linksto>dsn.Func020.EB.PostBuildSelectable.EthIfSecurityEventRefs</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1156</internalId></provcov>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00079</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>844</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1516</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06036_RptSecEvToIdsM_ETHIF_SEV_DROP_VLAN_DOUBLE_TAG</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>6103</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if reporting security events to IdsM is enabled and EthIf_RxIndication()
    is called and Ethernet datagram was dropped due to double VLAN tag EthIf module shall report
    event (ETHIF_SEV_DROP_VLAN_DOUBLE_TAG) to the IdsM via the IdsM_SetSecurityEvent interface.
    Test also verifies that securityEventId=ETHIF_SEV_DROP_VLAN_DOUBLE_TAG is post-build selectable.
  
Test Object: 
    IdsM reporting feature.
  
Test Precondition: 
  
Test Execution: 
    01: Call EthIf_Init() with EthIf_Config_V1 to initialize EthIf with V1 configuration.
    02: Call EthIf_SetControllerMode() to set Ethernet interface controller mode to ACTIVE.
    03: Call EthIf_RxIndication() with double VLAN frame type.
    04: VP(ECUC_EthIf_00082, ECUC_EthIf_00079): If reporting
        events to IdsM is enabled,verify that IdsM_SetSecurityEvent() was called with value from
        V1 configuration securityEventId = ETHIF_SEV_DROP_VLAN_DOUBLE_TAG. If reporting is not
        enabled verify that IdsM_SetSecurityEvent() was not called.
    05: Call EthIf_Init() with EthIf_Config_V2 to initialize EthIf with V2 configuration.
    06: Call EthIf_SetControllerMode() to set Ethernet interface controller mode to ACTIVE.
    07: Call EthIf_RxIndication() with double VLAN frame type.
    08: VP(dsn.Func020.EB.PostBuildLoadable.ETHIF_SEV_DROP_VLAN_DOUBLE_TAG,ECUC_EthIf_00079): If
        reporting events to IdsM is enabled, Verify that IdsM_SetSecurityEvent() was called with
        value form V2 configuration securityEventId = ETHIF_SEV_DROP_VLAN_DOUBLE_TAG_V2. If
        reporting is not enabled verify that IdsM_SetSecurityEvent() was not called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00082</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>847</internalId></provcov>
        <provcov>
          <linksto>dsn.Func020.EB.PostBuildSelectable.EthIfSecurityEventRefs</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1156</internalId></provcov>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00079</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>844</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1517</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06037_RptSecEvToIdsM_ETHIF_SEV_DROP_UNKNOWN_ETHERTYPE</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>6226</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if reporting security events to IdsM is enabled and EthIf_RxIndication()
    is called and Ethernet datagram was dropped due to the unknown Ethernet type EthIf module
    shall report event (ETHIF_SEV_DROP_UNKNOWN_ETHERTYPE) to the IdsM via the IdsM_SetSecurityEvent
    interface. Test also verifies that securityEventId=ETHIF_SEV_DROP_UNKNOWN_ETHERTYPE is
    post-build selectable.
  
Test Object: 
    IdsM reporting feature.
  
Test Precondition: 
  
Test Execution: 
    01: Call EthIf_Init() with EthIf_Config_V1 to initialize EthIf with V1 configuration.
    02: Call EthIf_SetControllerMode() to set Ethernet interface controller mode to ACTIVE.
    03: Setup EthSwt_EthIfPreProcessRxFrame_Stub to return TRUE and correct data.
    04: Call EthIf_RxIndication() with invalid frame type.
    05: VP(ECUC_EthIf_00081,ECUC_EthIf_00079): If reporting
        events to IdsM is enabled, verify that IdsM_SetSecurityEvent() was called with value from V1
        configuration securityEventId = ETHIF_SEV_DROP_UNKNOWN_ETHERTYPE. If reporting is not
        enabled verify that IdsM_SetSecurityEvent() was not called.
    06: Call EthIf_Init() with EthIf_Config_V2 to initialize EthIf with V2 configuration.
    07: Call EthIf_SetControllerMode() to set Ethernet interface controller mode to ACTIVE.
    08: Call EthIf_RxIndication() with invalid frame type.
    09: VP(dsn.Func020.EB.PostBuildLoadable.ETHIF_SEV_DROP_UNKNOWN_ETHERTYPE,ECUC_EthIf_00079): If
        reporting events to IdsM is enabled, verify that IdsM_SetSecurityEvent() was called with
        value form V2 configuration securityEventId = ETHIF_SEV_DROP_UNKNOWN_ETHERTYPE_V2.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00081</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>846</internalId></provcov>
        <provcov>
          <linksto>dsn.Func020.EB.PostBuildSelectable.EthIfSecurityEventRefs</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1156</internalId></provcov>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00079</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>844</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1518</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06038_RptSecEvToIdsM_ETHIF_SEV_DROP_INV_VLAN_3</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>6363</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if reporting security events to IdsM is enabled and EthIf_RxIndication()
    is called and frame is not VLAN, and if CtrlIdx does not match to any EthIfCtrlIdx with disabled
    config parameter EthIfVlanId, EthIf module shall report event (ETHIF_SEV_DROP_INV_VLAN) to the
    IdsM via the IdsM_SetSecurityEvent interface.
  
Test Object: 
    IdsM reporting feature.
  
Test Precondition: 
    EthIf is initialized.
  
Test Execution: 
    01: Setup EthSwt_EthIfPreProcessRxFrame_Stub to return correct data.
    02: Call EthIf_RxIndication() using an CtrlIdx which has EthIfVlanId enabled.
    03: VP(EthIf.ECUC_EthIf_00083,ECUC_EthIf_00079): If reporting events to
        IdsM is enabled, verify that IdsM_SetSecurityEvent() was called with value from V1
        configuration securityEventId = ETHIF_SEV_DROP_INV_VLAN. If reporting is not enabled
        verify that IdsM_SetSecurityEvent() was not called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00083</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>848</internalId></provcov>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00079</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>844</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1519</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06039_MODE_DOWN_ProvideTxBuffer_E_NOT_OK</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>6449</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_ProvideTxBuffer() is called while
    controller mode is ETH_MODE_DOWN and physical controller mode is ETH_MODE_ACTIVE, the
    request will be rejected and the function will will return E_NOT_OK.
  
Test Object: None.
Test Precondition: 
    Port state management is enabled.
    EthIf module is initialized.
    Controler and physical controler mode is set to ACTIVE.
  
Test Execution: 
    01: Move only controller to mode DOWN because switch ports are still ON.
    02: Call EthIf_ProvideTxBuffer() to obtain a buffer.
    03: VP(EthIf.SWS_EthIf_00068.3):
        Verify that the call was not forwarded and that EthIf_ProvideTxBuffer() returned E_NOT_OK.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00068.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>942</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1520</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06040_MODE_DOWN_Transmit_E_NOT_OK</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>6535</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_Transmit() is called while
    controller mode is ETH_MODE_DOWN and physical controller mode is ETH_MODE_ACTIVE, the
    request will be rejected and the function will will return E_NOT_OK.
  
Test Object: None.
Test Precondition: 
    Port state management is enabled.
    EthIf module is initialized.
    Controler and physical controler mode is set to ACTIVE.
  
Test Execution: 
    01: Move only controller to mode DOWN because switch ports are still ON.
    02: Call EthIf_Transmit() to transmit data.
    03: VP(EthIf.SWS_EthIf_00076.3):
        Verify that the call was not forwarded and that EthIf_Transmit() returned E_NOT_OK.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00076.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>946</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1521</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06041_SwitchPortGroupRequestMode_Timer</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>6623</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify if EthIf_SwitchPortGroupRequestMode is called with ETH_MODE_ACTIVE or
    ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST, then a running timer to delay the switch off all ports of
    the respective EthIfSwitchPortGroup (PortGroupIdx) shall be canceled.
  
Test Object: 
    EthIf_SwitchPortGroupRequestMode().
  
Test Precondition: 
    - EthIf initialized.
    - EthIfController that does not reference any port group set to ACTIVE
  
Test Execution: 
    01: Call EthIf_SwitchPortGroupRequestMode() to set port group under control of BswM to mode
        ACTIVE/ACTIVE_WITH_WAKEUP_REQUEST.
    02: Check that for all ports of a referenced port group EthSwt_SetSwitchPortMode() is called
        to set port mode to ACTIVE/ACTIVE_WITH_WAKEUP_REQUEST.
    03: Call EthIf_SwitchPortGroupRequestMode() to set port group to mode DOWN and check that
        switch-off timer is started to delay port shut-down, i.e. EthSwt_SetSwitchPortMode() is
        not yet called.
    04: Call EthIf_SwitchPortGroupRequestMode() to set port group to mode
        ACTIVE/ACTIVE_WITH_WAKEUP_REQUEST and check that EthSwt_SetSwitchPortMode() was not called
        since the requested mode and the current mode are the same. This is because the first DOWN
        request was delayed and was not propagated to switch ports, i.e. they remained active.
    05: Call EthIf_SwitchPortGroupRequestMode() to set port group to mode DOWN.
    06: Call EthIf_MainFunctionRx() two times.
    07: Call EthIf_SwitchPortGroupRequestMode() to set port group to mode
        ACTIVE/ACTIVE_WITH_WAKEUP_REQUEST and to cancel switch off timer.
    08: VP(EthIf.SWS_EthIf_00483): Call EthIf_MainFunctionRx() more times than needed to tick switch-off
        timer ETHIF_SWITCH_OFF_PORT_TIMEDELAY times and verify that the timer was canceled because
        EthSwt_SetSwitchPortMode wasn't called.
    09: Call EthIf_SwitchPortGroupRequestMode() to set port group to mode DOWN.
    10: Call EthIf_MainFunctionRx() to tick switch-off timer ETHIF_SWITCH_OFF_PORT_TIMEDELAY times.
    11: Call EthIf_MainFunctionRx() one more time to reach timer threshold.
    12: Check that after switch-off timer elapses, for all ports of a referenced port group
        EthSwt_SetSwitchPortMode() is called to set the port mode to DOWN.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00483</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>960</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1522</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest06042_SwitchPortGroupRequestMode_Det_Wodl_InvalidPortMode</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest06_SwitchingSwtPorts/source/application/EthIf_ConTest06_SwitchingSwtPorts.c</sourcefile>
      <sourceline>6797</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that when EthIf_SwitchPortGroupRequestMode() is called with port mode other than
    ETHTRCV_MODE_DOWN, ETHTRCV_MODE_ACTIVE or ETHTRCV_MODE_ACTIVE
    EthIf shall report Det error.
  
Test Object: 
    EthIf_SwitchPortGroupRequestMode().
  
Test Precondition: 
    - EthIf initialized.
    - WakeUpOnDatLine is enabled.
  
Test Execution: 
    01: Call EthIf_SetControllerMode
    02: Call EthIf_SwitchPortGroupRequestMode() with invalid port mode.
    03: VP(EthIf.EB.Det.SwitchPortGroupRequest_InvPortMode.WakeUpOnDataLine): Verify E_NOT_OK was
        returned and ETHIF_E_INV_PARAM DET error was reported for ETHIF_SWITCHPORTGROUPREQUESTMODE_SVCID.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.SwitchPortGroupRequest_InvPortMode.WakeUpOnDataLine</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>169</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1523</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EthIf_ConTest07007_SetControllerMode_Wakeup_Inv_Param</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest07_WakeupSupport/TestSpec_Generated.h</sourcefile>
      <sourceline>9</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that if development error detection is enabled and wakuep and sleep on data line suport is disabled, the service EthIf_SetControllerMode() shall return E_NOT_OK and raise the development error ETHIF_E_INV_PARAM if invoked with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST.
Test Object: EthIf_SetControllerMode
Test Precondition: 
    -   Wakeup and sleep on data line support is disabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Call EthIf_SetControllerMode with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST.
    02: VP(EthIf.EB.Det.SetController_InvCtrlMode_2,1) Verify that development error ETHIF_E_INV_PARAM was raised and E_NOT_OK returned.
    03: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.SetController_InvCtrlMode_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>172</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1524</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest07008_SetControllerMode_Wakeup_Inv_Param_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest07_WakeupSupport/TestSpec_Generated.h</sourcefile>
      <sourceline>31</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that if development error detection is enabled and wakuep and sleep on data line suport is disabled, the service EthIf_SetControllerMode() shall return E_NOT_OK and raise the development error ETHIF_E_INV_PARAM if invoked with invalid mode.
Test Object: EthIf_SetControllerMode
Test Precondition: 
    -   Wakeup and sleep on data line support is disabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Call EthIf_SetControllerMode with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST.
    02: VP(EthIf.EB.Det.SetController_InvCtrlMode_3,1) Verify that development error ETHIF_E_INV_PARAM was raised and E_NOT_OK returned.
    03: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.SetController_InvCtrlMode_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>173</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1525</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest07009_SetControllerMode_Wakeup_Activate</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest07_WakeupSupport/TestSpec_Generated.h</sourcefile>
      <sourceline>53</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that transceiver link was correctly changed from DOWN to ACIVE when EthIf_SetControllerMode was called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST.
Test Object: Activation with wakeup request
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   Switch and switch group support is disabled
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller and transceiver mode to ACTIVE_WITH_WAKEUP_REQUEST.
    02: Call EthIf_MainFunctionRx to change link state to ACTIVE.
    03: VP(EthIf.ASR43.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange,1) Verify that the link was changed to ACTIVE.
    04: Sanity check - Call EthIf_MainFunctionRx and check that none of the setting APIs were called.
    05: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>130</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1526</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest07010_SetControllerMode_Wakeup_Deactivate</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest07_WakeupSupport/TestSpec_Generated.h</sourcefile>
      <sourceline>78</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that transceiver link was correctly changed from ACIVE to DOWN when EthIf_SetControllerMode was activated with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST.
Test Object: Deactivation with wakeup request
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   Switch and switch group support is disabled
    -   EthIf and test setup is initialized
    -   Activate link state of the transceiver
  
Test Execution: 
    01: Set Ethernet interface controller and transceiver mode to DOWN.
    02: Call EthIf_MainFunctionRx to change link state to DOWN.
    03: VP(EthIf.ASR43.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange,1) Verify that the link was changed to DOWN.
    04: Sanity check - Call EthIf_MainFunctionRx and check that nothing was called.
    05: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>130</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1527</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EthIf_ConTest07000_SetTransceiverWakeupMode_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest07_WakeupSupport/source/application/EthIf_ConTest07_WakeupSupport.c</sourcefile>
      <sourceline>46</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_SetTransceiverWakeupMode() is called when the module is not
    initialized, ETHIF_E_NOT_INITIALIZED will be reported to DET and E_NOT_OK returned.
  
Test Object: 
    EthIf_SetTransceiverWakeupMode()
  
Test Precondition: 
    EthIf uninitialized.
  
Test Execution: 
    01: Call EthIf_SetTransceiverWakeupMode() in UNINIT state.
    02: VP(): Verify that DET was called with ETHIF_E_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00235</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>69</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1528</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest07000_GetTransceiverWakeupMode_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest07_WakeupSupport/source/application/EthIf_ConTest07_WakeupSupport.c</sourcefile>
      <sourceline>97</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_GetTransceiverWakeupMode() is called when the module is not
    initialized, ETHIF_E_NOT_INITIALIZED will be reported to DET and E_NOT_OK returned.
  
Test Object: 
    EthIf_GetTransceiverWakeupMode()
  
Test Precondition: 
    EthIf uninitialized.
  
Test Execution: 
    01: Call EthIf_GetTransceiverWakeupMode() in UNINIT state.
    02: VP(): Verify that DET was called with ETHIF_E_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00240</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>70</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1529</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest07000_CheckWakeup_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest07_WakeupSupport/source/application/EthIf_ConTest07_WakeupSupport.c</sourcefile>
      <sourceline>149</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_CheckWakeup() is called when the module is not
    initialized, ETHIF_E_NOT_INITIALIZED will be reported to DET.
  
Test Object: 
    EthIf_CheckWakeup()
  
Test Precondition: 
    EthIf uninitialized.
  
Test Execution: 
    01: Call EthIf_CheckWakeup() in UNINIT state.
    02: VP(): Verify that DET was called with ETHIF_E_NOT_INITIALIZED and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00246</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00249</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>73</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1530</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest07000_SetTransceiverWakeupMode_InvTrcvIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest07_WakeupSupport/source/application/EthIf_ConTest07_WakeupSupport.c</sourcefile>
      <sourceline>201</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that when EthIf_SetTransceiverWakeupMode() is called when an invalid TrcvIdx,
    ETHIF_E_INV_TRCV_IDX will be reported to DET and E_NOT_OK returned.
  
Test Object: 
    EthIf_SetTransceiverWakeupMode()
  
Test Precondition: 
    EthIf is initialized.
  
Test Execution: 
    01: Call EthIf_SetTransceiverWakeupMode() with an invalid TrcvIdx.
    02: VP(): Verify that DET was called with ETHIF_E_INV_TRCV_IDX and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00236</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>561</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1531</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest07000_SetTransceiverWakeupMode_InvWakeupMode</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest07_WakeupSupport/source/application/EthIf_ConTest07_WakeupSupport.c</sourcefile>
      <sourceline>254</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that when EthIf_SetTransceiverWakeupMode() is called when an invalid wake-up
    mode, ETHIF_E_INV_PARAM will be reported to DET and E_NOT_OK returned.
  
Test Object: 
    EthIf_SetTransceiverWakeupMode()
  
Test Precondition: 
    EthIf is initialized.
  
Test Execution: 
    01: Call EthIf_SetTransceiverWakeupMode() with an invalid wake-up mode.
    02: VP(): Verify that DET was called with ETHIF_E_INV_PARAM and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Det.SetTransceiverWakeupMode_InvTrcvWakeupMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>174</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1532</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest07000_GetTransceiverWakeupMode_InvTrcvIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest07_WakeupSupport/source/application/EthIf_ConTest07_WakeupSupport.c</sourcefile>
      <sourceline>309</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that when EthIf_GetTransceiverWakeupMode() is called when an invalid TrcvIdx,
    ETHIF_E_INV_TRCV_IDX will be reported to DET and E_NOT_OK returned.
  
Test Object: 
    EthIf_GetTransceiverWakeupMode()
  
Test Precondition: 
    EthIf is initialized.
  
Test Execution: 
    01: Call EthIf_GetTransceiverWakeupMode() with an invalid TrcvIdx.
    02: VP(): Verify that DET was called with ETHIF_E_INV_TRCV_IDX and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00241</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>566</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1533</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest07000_GetTransceiverWakeupMode_InvPtr</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest07_WakeupSupport/source/application/EthIf_ConTest07_WakeupSupport.c</sourcefile>
      <sourceline>363</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that when EthIf_GetTransceiverWakeupMode() is called when an invalid (NULL)
    TrcvWakeupModePtr, ETHIF_E_PARAM_POINTER will be reported to DET and E_NOT_OK returned.
  
Test Object: 
    EthIf_GetTransceiverWakeupMode()
  
Test Precondition: 
    EthIf is initialized.
  
Test Execution: 
    01: Call EthIf_GetTransceiverWakeupMode() with an invalid TrcvWakeupModePtr.
    02: VP(): Verify that DET was called with ETHIF_E_PARAM_POINTER and E_NOT_OK was returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00242</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>71</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1534</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest07001_SetTransceiverWakeupMode</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest07_WakeupSupport/source/application/EthIf_ConTest07_WakeupSupport.c</sourcefile>
      <sourceline>417</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies propagation of EthIf_SetTransceiverWakeupMode() to EthTrcv driver call
    EthTrcv_SetTransceiverWakeupMode() by the following table:

    Requested Mode       Current Mode          Action
    ----------------------------------------------------------------------------------------------
    ETHTRCV_WUM_DISABLE  ETHTRCV_WUM_DISABLE   no action
    ETHTRCV_WUM_ENABLE   ETHTRCV_WUM_ENABLE    no action
    ETHTRCV_WUM_ENABLE   ETHTRCV_WUM_DISABLE   EthTrcv_SetTransceiverWakeupMode(ETHTRCV_WUM_ENABLE)
    ETHTRCV_WUM_DISABLE  ETHTRCV_WUM_ENABLE    EthTrcv_SetTransceiverWakeupMode(ETHTRCV_WUM_DISABLE)
    ETHTRCV_WUM_CLEAR    ETHTRCV_WUM_DISABLE   EthTrcv_SetTransceiverWakeupMode(ETHTRCV_WUM_CLEAR)
    ETHTRCV_WUM_CLEAR    ETHTRCV_WUM_ENABLE    DET error

  
Test Object: 
    EthIf_SetTransceiverWakeupMode()
  
Test Precondition: 
    - EthIf initialized.
  
Test Execution: 
    01: Call EthIf_SetTransceiverWakeupMode() to set trcv. wake-up mode to ETHTRCV_WUM_DISABLE.
    02: VP(EthIf.EB.SetTransceiverWakeupMode_NoChange): Verify that the call is not forwarded to
        EthTrcv driver since the mode is already ETHTRCV_WUM_DISABLE and E_OK is returned.
    03: Call EthIf_SetTransceiverWakeupMode() to set trcv. wake-up mode to ETHTRCV_WUM_ENABLE.
    04: VP(SWS_EthIf_00234): Verify EthTrcv_SetTransceiverWakeupMode() is called for correct
        TrcxIdx and wake-up mode ETHTRCV_WUM_ENABLE.
    05: Repeat the call to EthIf_SetTransceiverWakeupMode() with ETHTRCV_WUM_ENABLE.
    06: VP(EthIf.EB.SetTransceiverWakeupMode_NoChange): Verify that the call is not forwarded
        EthTrcv driver since the mode is already ETHTRCV_WUM_ENABLE and E_OK is returned.
    07: Call EthIf_SetTransceiverWakeupMode() to set trcv. wake-up mode to ETHTRCV_WUM_DISABLE.
    08: VP(SWS_EthIf_00268): Verify EthTrcv_SetTransceiverWakeupMode() is called for correct
        TrcxIdx and wake-up mode ETHTRCV_WUM_DISABLE.
    09: Call EthIf_SetTransceiverWakeupMode() to set trcv. wake-up mode to ETHTRCV_WUM_CLEAR.
    10: VP(SWS_EthIf_00269): Verify EthTrcv_SetTransceiverWakeupMode() is called for correct
        TrcxIdx and wake-up mode ETHTRCV_WUM_CLEAR.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00234</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>559</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00268</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>621</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00269</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>622</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.SetTransceiverWakeupMode_NoChange</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>266</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1535</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest07002_GetTransceiverWakeupMode</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest07_WakeupSupport/source/application/EthIf_ConTest07_WakeupSupport.c</sourcefile>
      <sourceline>537</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that EthIf_GetTransceiverWakeupMode() shall forward the call to
    EthTrcv_GetTransceiverWakeupMode() of the corresponding Ethernet Transceiver Driver.
  
Test Object: 
    EthIf_GetTransceiverWakeupMode()
  
Test Precondition: 
    - EthIf initialized.
    - EthTrcv_GetTransceiverWakeupMode_Stub set to return ETHTRCV_WUM_ENABLE.
  
Test Execution: 
    01: Call EthIf_GetTransceiverWakeupMode() to retrieve wake-up mode of transceiver with
        EthIfTransceiverIdx = 1.
    02: VP(SWS_EthIf_00239): Verify that the call is forwarded to EthTrcv_GetTransceiverWakeupMode()
        for the respective TrcvIdx in the context of Ethernet Transceiver Driver, and that the
        set value of wake-up mode is retrieved.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00239</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>564</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1536</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest07003_SetTransceiverWakeupMode_NotOk</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest07_WakeupSupport/source/application/EthIf_ConTest07_WakeupSupport.c</sourcefile>
      <sourceline>598</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that when EthIf_SetTransceiverWakeupMode() is propagated to
    EthTrcv_SetTransceiverWakeupMode() it's return value is also propagated to
    EthIf_SetTransceiverWakeupMode() caller.
  
Test Object: 
    EthIf_SetTransceiverWakeupMode()
  
Test Precondition: 
    - EthIf initialized.
  
Test Execution: 
    01: Configure EthTrcv_SetTransceiverWakeupMode stub to return E_NOT_OK.
    02: Call EthIf_SetTransceiverWakeupMode() to set trcv. wake-up mode to ETHTRCV_WUM_ENABLE.
    03: VP(SWS_EthIf_00234): Verify EthTrcv_SetTransceiverWakeupMode() is called for correct
        TrcxIdx and wake-up mode ETHTRCV_WUM_ENABLE and it return E_NOT_OK. Also verify that
        return value is propagated to EthIf_SetTransceiverWakeupMode() caller.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00234</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>559</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1537</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest07004_CheckWakeup_Ok</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest07_WakeupSupport/source/application/EthIf_ConTest07_WakeupSupport.c</sourcefile>
      <sourceline>659</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that EthIf_CheckWakeup() is propagated to all configured EthIfTransceivers.
    It is also verified that if EthTrcv_CheckWakeup() returns E_OK for all transceivers
    EthIf_CheckWakeup() returns E_OK too.
  
Test Object: 
    EthIf_CheckWakeup()
  
Test Precondition: 
    - EthIf initialized.
  
Test Execution: 
    01: Configure EthTrcv_CheckWakeup_Stub to return E_OK.
    02: Call EthIf_CheckWakeup() with a random parameter WakeupSource (as it is not used).
    03: VP(EthIf.EB.CheckWakeup_RetVal): Verify that EthIf_CheckWakeup() returned E_OK since all
        calls to EthTrcv_CheckWakeup() returned E_OK.
    04: VP(EthIf.EB.SWS_EthIf_00245_PoolAllTrcvs): Verify that EthTrcv_CheckWakeup() is called
        for all configured EthIfTransceivers.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00245_PoolAllTrcvs</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>268</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.CheckWakeup_RetVal</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>269</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1538</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest07005_CheckWakeup_NotOk</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest07_WakeupSupport/source/application/EthIf_ConTest07_WakeupSupport.c</sourcefile>
      <sourceline>727</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that if a single call to EthTrcv_CheckWakeup() returns E_NOT_OK
    EthIf_CheckWakeup() will return E_NOT_OK too.
  
Test Object: 
    EthIf_CheckWakeup()
  
Test Precondition: 
    - EthIf initialized.
  
Test Execution: 
    01: Configure EthTrcv_CheckWakeup_Stub to return E_NOT_OK for a single transceiver.
    02: Call EthIf_CheckWakeup() with a random parameter WakeupSource (as it is not used).
    03: VP(EthIf.EB.CheckWakeup_RetVal): Verify that EthIf_CheckWakeup() returned E_NOT_OK since
        a single call to EthTrcv_CheckWakeupreturned E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.CheckWakeup_RetVal</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>269</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1539</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest07006_SetTransceiverWakeupMode_ClearEnabled</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest07_WakeupSupport/source/application/EthIf_ConTest07_WakeupSupport.c</sourcefile>
      <sourceline>792</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that when EthIf_SetTransceiverWakeupMode() is called with ETHTRCV_WUM_CLEAR
    and the current state of the requested transceiver is ETHTRCV_WUM_ENABLE,
    call shall not be forwarded to EthTrcv and E_NOT_OK shall be returned.
  
Test Object: 
    EthIf_SetTransceiverWakeupMode()
  
Test Precondition: 
    EthIf is initialized.
  
Test Execution: 
    01: Call EthIf_SetTransceiverWakeupMode() to set the transceiver wake-up state to
        ETHTRCV_WUM_ENABLE.
    02: Call EthIf_SetTransceiverWakeupMode() with wake-up mode ETHTRCV_WUM_CLEAR.
    03: VP(): Verify that the call is not forwarded to EthTrcv and E_NOT_OK
        is returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SetTransceiverWakeupMode_ClearEnabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>267</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1540</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EthIf_ConTest08001_SetControllerModeAsync_Switch</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest08_AsyncDrvComm/source/application/EthIf_ConTest08_AsyncDrvComm.c</sourcefile>
      <sourceline>31</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that when EthIfController which references a switch (and not a port group)
    is set to ACTIVE, then all EthSwtPorts of referenced switch shall be switched on.
    And vice versa when all EthIfControllers that reference a switch are set to DOWN, then all ports
    of a switch will be switched off.
  
Test Object: 
    EthIf_SetControllerMode().
  
Test Precondition: 
    - EthIf initialized.
  
Test Execution: 
    01: Call EthIf_SetControllerMode() to set Ethernet interface controller mode to ACTIVE.
        The controller references an Ethernet switch.
    02: Call EthIf_CtrlModeIndication() with mode set to ACTIVE.
    03: VP(SWS_EthIf_00257): Verify that all ports of a referenced switch are set to ACTIVE.
    04: Call EthIf_SetControllerMode() to set Ethernet interface controller mode to DOWN.
    05: VP(SWS_EthIf_00258): Verify that all ports of a referenced switch are set to DOWN.
    06: Call EthIf_CtrlModeIndication() with mode set to DOWN.

  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00257</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>610</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00258</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>611</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1541</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest08002_SetControllerModeAsync_PortGroup</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest08_AsyncDrvComm/source/application/EthIf_ConTest08_AsyncDrvComm.c</sourcefile>
      <sourceline>161</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that when EthIfController which references a port group is set to ACTIVE,
    then all EthSwtPorts of referenced port group shall be switched on.
    And vice versa when all EthIfControllers that reference a port group are set to DOWN, then all
    ports of a port group will be switched off.
  
Test Object: 
    EthIf_SetControllerMode().
  
Test Precondition: 
    - EthIf initialized.
  
Test Execution: 
    01: Call EthIf_SetControllerMode() to set Ethernet interface controller mode to ACTIVE.
        The controller references a port group.
    02: Call EthIf_CtrlModeIndication() with mode set ACTIVE.
    03: VP(SWS_EthIf_00264, SWS_EthIf_00267): Verify that all ports of a referenced port group are
        set to ACTIVE. Port activation happens in the context of EthIf_CtrlModeIndication().
    04: Call EthIf_SetControllerMode() to set Ethernet interface controller mode to DOWN.
    05: Call EthIf_CtrlModeIndication() with mode set to DOWN.
    06: VP(EthIf.ASR43.SWS_EthIf_00265): Verify that all ports of a referenced port group are set to DOWN.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00264</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>617</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00265</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00267</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>620</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1542</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest08000_MainFunctionState_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest08_AsyncDrvComm/source/application/EthIf_ConTest08_AsyncDrvComm.c</sourcefile>
      <sourceline>292</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that when calling EthIf_MainFunctionState() while the module is not
    initialized, the functions will return without taking any action.
  
Test Object: 
    EthIf_MainFunctionState().
  
Test Precondition: 
    EthIf uninitialized.
  
Test Execution: 
    01: Call EthIf_MainFunctionState().
    02: VP(): Verify that no action was taken.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00278</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>151</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1543</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EthIf_ASR403_SetControllerMode_Wakeup_Transceiver</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR403/TestSpec_Generated.h</sourcefile>
      <sourceline>9</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that when called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST, EthIf_SetControllerMode shall forward the call to Eth_SetControllerMode with ETH_MODE_ACTIVE if not already indicated. In this test case transceiver is referenced.
Test Object: EthIf_SetControllerMode
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller mode to ACTIVE.
    02: VP(EthIf.SWS_EthIf_00035,1) Verify that Eth_SetControllerMode was called with ETH_MODE_ACTIVE.
    03: VP(EthIf.EB.SWS_EthIf_00479,1) Verify that EthTrcv_SetTransceiverMode was called with ETHTRCV_MODE_ACTIVE_WITH_WAKEUP_REQUEST.
    04: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00035</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>424</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00479</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>374</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1544</internalId></specobject>
    <specobject>
      <id>EthIf_ASR403_SetControllerMode_Wakeup_Second_Transceiver</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR403/TestSpec_Generated.h</sourcefile>
      <sourceline>36</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that when called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST, EthIf_SetControllerMode shall not forward the call to Eth_SetControllerMode and EthSM_CtrlModeIndication with ETH_MODE_ACTIVE if already indicated and that it will always forward the call to EthTrcv_SetTransceiverMode with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST. In this test case transceiver is referenced.
Test Object: EthIf_SetControllerMode
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller mode to ACTIVE or ACTIVE_WITH_WAKEUP_REQUEST and indicate it to Eth.
    02: Request Ethernet interface controller mode to ACTIVE or ACTIVE_WITH_WAKEUP_REQUEST.
    03: VP(EthIf.SWS_EthIf_00035,1) Verify that Eth_SetControllerMode and EthSM_CtrlModeIndication were not called.
    04: Request Ethernet interface controller mode to ACTIVE.
    05: VP(EthIf.SWS_EthIf_00035,1) Verify that Eth_SetControllerMode and EthSM_CtrlModeIndication were not called.
    06: Request Ethernet interface controller mode to ACTIVE_WITH_WAKEUP_REQUEST.
    07: VP(EthIf.EB.SWS_EthIf_00479,1) Verify that EthTrcv_SetTransceiverMode is called whenever EthIf_SetControllerMode is called with ACTIVE_WITH_WAKEUP_REQUEST.
    08: VP(EthIf.SWS_EthIf_00035,1) Verify that Eth_SetControllerMode and EthSM_CtrlModeIndication were not called.
    09: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00035</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>424</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00479</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>374</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1545</internalId></specobject>
    <specobject>
      <id>EthIf_ASR403_SetControllerMode_Wakeup_Second_Transceiver_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR403/TestSpec_Generated.h</sourcefile>
      <sourceline>68</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that when called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST, EthIf_SetControllerMode shall forward the call to EthTrcv_SetTransceiverMode with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST. In this case EthIf_CtrlModeIndication was called for the first time after calling EthIf_SetControllerMode twice. In this test case transceiver is referenced.
Test Object: EthIf_SetControllerMode
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Request Ethernet interface controller mode to ACTIVE or ACTIVE_WITH_WAKEUP_REQUEST and indicate it to Eth.
    02: Request Ethernet interface controller mode to ACTIVE_WITH_WAKEUP_REQUEST.
    03: Receive callout to set Ethernet interface controller mode to ACTIVE.
    04: VP(EthIf.EB.SWS_EthIf_00479,1)
        VP(EthIf.EB.EthTrcv_SetTransceiverMode.Async.CtrlModeIndication,1) Verify that EthTrcv_SetTransceiverMode is called whenever EthIf_SetControllerMode is called with ACTIVE_WITH_WAKEUP_REQUEST.
    05: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00479</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>374</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.EthTrcv_SetTransceiverMode.Async.CtrlModeIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>380</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1546</internalId></specobject>
    <specobject>
      <id>EthIf_ASR403_SetControllerMode_Wakeup_Activate_Transceiver</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR403/TestSpec_Generated.h</sourcefile>
      <sourceline>97</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that transceiver link was correctly changed from DOWN to ACIVE when EthIf_SetControllerMode was called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST and transceiver was referenced.
Test Object: Activation with wakeup request
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller and transceiver mode to ACTIVE_WITH_WAKEUP_REQUEST.
    02: Call EthIf_MainFunctionState to change link state to ACTIVE.
    03: VP(EthIf.ASR43.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange,1) Verify that the link was changed to ACTIVE.
    04: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>130</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1547</internalId></specobject>
    <specobject>
      <id>EthIf_ASR403_SetControllerMode_Wakeup_Deactivate_Transceiver</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR403/TestSpec_Generated.h</sourcefile>
      <sourceline>120</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that transceiver link was correctly changed from ACIVE to DOWN when EthIf_SetControllerMode was activated with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST and transceiver was referenced.
Test Object: Deactivation with wakeup request
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
    -   Activate link state of the transceiver
  
Test Execution: 
    01: Set Ethernet interface controller and transceiver mode to DOWN.
    02: Call EthIf_MainFunctionState to change link state to DOWN.
    03: VP(EthIf.ASR43.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange,1) Verify that the link was changed to DOWN.
    04: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>130</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1548</internalId></specobject>
    <specobject>
      <id>EthIf_ASR403_CtrlModeIndication_Wakeup_Mix_Transceiver</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR403/TestSpec_Generated.h</sourcefile>
      <sourceline>144</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that when called with ETH_MODE_ACTIVE or ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST, EthIf_CtrlModeIndication shall forward the call to EthTrcv_SetTransceiverMode with initially requested state regardless if EthIf_SetControllerMode already informed EthTrcv_SetTransceiverMode about ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST.
Test Object: EthIf_CtrlModeIndication
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller mode to ACTIVE or ACTIVE_WITH_WAKEUP_REQUEST and indicate it to Eth.
    02: VP(EthIf.EB.SWS_EthIf_00479,1) Verify that EthTrcv_SetTransceiverMode is called is called with initially requested state.
    03: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00479</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>374</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1549</internalId></specobject>
    <specobject>
      <id>EthIf_ASR403_SetControllerMode_Wakeup_Repeat_Transceiver</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR403/TestSpec_Generated.h</sourcefile>
      <sourceline>166</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that EthTrcv_SetTransceiverMode will be recalled with ACTIVE_WITH_WAKEUP_REQUEST when repeat timer expires.
Test Object: Repeat timer for transceiver
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller and transceiver mode to ACTIVE_WITH_WAKEUP_REQUEST.
    02: Call EthIf_MainFunctionState to timeout the repeat timer without changing the link state.
    03: VP(EthIf.EB.SetModeTimeout.RepeatRequest.ReadFail,1) Verify that EthTrcv_SetTransceiverMode was called because the link wasn't changed to ACTIVE.
    04: Call EthIf_MainFunctionState to change link state to ACTIVE.
    05: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SetModeTimeout.RepeatRequest.ReadFail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>260</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1550</internalId></specobject>
    <specobject>
      <id>EthIf_ASR403_SetControllerMode_Wakeup_Repeat_Next_Transceiver</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR403/TestSpec_Generated.h</sourcefile>
      <sourceline>190</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that EthTrcv_SetTransceiverMode will be recalled with ACTIVE_WITH_WAKEUP_REQUEST in the next mainfunction if the first call fails.
Test Object: Repeat timer for transceiver
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set return value of EthTrcv_SetTransceiverMode to E_NOT_OK.
    02: Set Ethernet interface controller and transceiver mode to ACTIVE_WITH_WAKEUP_REQUEST.
    03: Revert return value of EthTrcv_SetTransceiverMode to E_OK.
    04: Call EthIf_MainFunctionState to retry informing transceiver.
    05: VP(EthIf.EB.SetModeTimeout.RepeatRequest.ReadFail,1) Verify that EthTrcv_SetTransceiverMode was called in the next mainfunction.
    06: Call EthIf_MainFunctionState to change link state to ACTIVE.
    07: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SetModeTimeout.RepeatRequest.ReadFail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>260</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1551</internalId></specobject>
    <specobject>
      <id>EthIf_ASR403_SetControllerMode_Wakeup_Preemption_Transceiver</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR403/TestSpec_Generated.h</sourcefile>
      <sourceline>216</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that EthIf_SetControllerMode will not pass the call to the EthTrcv_SetTransceiverMode for locked transceiver because EthIf_MainFunctionState processing was preempted. In this case E_OK was set for EthTrcv_SetTransceiverMode in the first EthIf_MainFunctionState call.
Test Object: EthIf_SetControllerMode preemption of EthIf_MainFunctionState
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set return value of EthTrcv_SetTransceiverMode to E_NOT_OK.
    02: Set Ethernet interface controller and switch port mode to ACTIVE_WITH_WAKEUP_REQUEST.
    03: Set return value of EthTrcv_SetTransceiverMode to E_OK.
    04: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthTrcv_SetTransceiverMode.
    05: Call EthIf_MainFunctionState to retry informing transceiver.
    06: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthTrcv_SetTransceiverMode was not called from EthIf_SetControllerMode because the transceiver was already locked.
    07: Call EthIf_MainFunctionState to change link state to ACTIVE.
    08: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>218</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1552</internalId></specobject>
    <specobject>
      <id>EthIf_ASR403_SetControllerMode_Wakeup_Preemption_Transceiver_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR403/TestSpec_Generated.h</sourcefile>
      <sourceline>243</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that EthIf_SetControllerMode will not pass the call to the EthTrcv_SetTransceiverMode for locked transceiver because EthIf_MainFunctionState processing was preempted. In this case E_OK was set for EthTrcv_SetTransceiverMode in the second EthIf_MainFunctionState call.
Test Object: EthIf_SetControllerMode preemption of EthIf_MainFunctionState
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set return value of EthTrcv_SetTransceiverMode to E_NOT_OK.
    02: Set Ethernet interface controller and switch port mode to ACTIVE_WITH_WAKEUP_REQUEST.
    03: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthTrcv_SetTransceiverMode.
    04: Call EthIf_MainFunctionState to retry informing transceiver.
    05: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthTrcv_SetTransceiverMode was not called from EthIf_SetControllerMode because the transceiver was already locked.
    06: Set return value of EthTrcv_SetTransceiverMode to E_OK.
    07: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthTrcv_SetTransceiverMode.
    08: Call EthIf_MainFunctionState to retry informing transceiver.
    09: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthTrcv_SetTransceiverMode was not called from EthIf_SetControllerMode because the transceiver was already locked.
    10: Call EthIf_MainFunctionState to change link state to ACTIVE.
    11: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>218</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1553</internalId></specobject>
    <specobject>
      <id>EthIf_ASR403_SetControllerMode_Wakeup_Preemption_Transceiver_3</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR403/TestSpec_Generated.h</sourcefile>
      <sourceline>273</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that EthIf_SetControllerMode will not pass the call to the EthTrcv_SetTransceiverMode for locked transceiver because EthIf_MainFunctionState processing was preempted. In this case E_OK was set for EthTrcv_SetTransceiverMode in the third EthIf_MainFunctionState call.
Test Object: EthIf_SetControllerMode preemption of EthIf_MainFunctionState
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set return value of EthTrcv_SetTransceiverMode to E_NOT_OK.
    02: Set Ethernet interface controller and switch port mode to ACTIVE_WITH_WAKEUP_REQUEST.
    03: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthTrcv_SetTransceiverMode.
    04: Call EthIf_MainFunctionState to retry informing transceiver.
    05: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthTrcv_SetTransceiverMode was not called from EthIf_SetControllerMode because the transceiver was already locked.
    06: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthTrcv_SetTransceiverMode.
    07: Call EthIf_MainFunctionState to retry informing transceiver.
    08: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthTrcv_SetTransceiverMode was not called from EthIf_SetControllerMode because the transceiver was already locked.
    09: Set return value of EthTrcv_SetTransceiverMode to E_OK.
    10: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthTrcv_SetTransceiverMode.
    11: Call EthIf_MainFunctionState to retry informing transceiver.
    12: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthTrcv_SetTransceiverMode was not called from EthIf_SetControllerMode because the transceiver was already locked.
    13: Call EthIf_MainFunctionState to change link state to ACTIVE.
    14: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>218</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1554</internalId></specobject>
    <specobject>
      <id>EthIf_ASR403_SetControllerMode_Wakeup_Preemption_Transceiver_4</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR403/TestSpec_Generated.h</sourcefile>
      <sourceline>306</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that EthIf_SetControllerMode will not pass the call to the EthTrcv_SetTransceiverMode for locked transceiver because EthIf_MainFunctionState processing was preempted. In this case E_OK was set for EthTrcv_SetTransceiverMode between the second EthIf_MainFunctionState call and EthIf_SetControllerMode.
Test Object: EthIf_SetControllerMode preemption of EthIf_MainFunctionState
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set return value of EthTrcv_SetTransceiverMode to E_NOT_OK.
    02: Set Ethernet interface controller and switch port mode to ACTIVE_WITH_WAKEUP_REQUEST.
    03: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthSwt_SetSwitchPortMode.
    04: Call EthIf_MainFunctionState to retry informing transceiver.
    05: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthTrcv_SetTransceiverMode was not called from EthIf_SetControllerMode because the transceiver was already locked.
    06: Set return value of EthTrcv_SetTransceiverMode to E_OK.
    07: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthSwt_SetSwitchPortMode.
    08: Call EthIf_MainFunctionState to retry informing transceiver.
    09: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthTrcv_SetTransceiverMode was not called from EthIf_SetControllerMode because the transceiver was already locked.
    10: Call EthIf_SetControllerMode to inform transceiver.
    11: Call EthIf_MainFunctionState to change link state to ACTIVE.
    12: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>218</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1555</internalId></specobject>
    <specobject>
      <id>EthIf_ASR403_SetControllerMode_Wakeup_Switch</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR403/TestSpec_Generated.h</sourcefile>
      <sourceline>337</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that when called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST, EthIf_SetControllerMode shall forward the call to Eth_SetControllerMode with ETH_MODE_ACTIVE if not already indicated. In this test case switch is referenced.
Test Object: EthIf_SetControllerMode
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller mode to ACTIVE by calling with ACTIVE_WITH_WAKEUP_REQUEST.
    02: VP(EthIf.SWS_EthIf_00035,1) Verify that Eth_SetControllerMode was called with ETH_MODE_ACTIVE.
    03: VP(EthIf.EB.SWS_EthIf_00480,1) Verify that EthSwt_SetSwitchPortMode was called with ETHTRCV_MODE_ACTIVE_WITH_WAKEUP_REQUEST for every port in the given switch.
    04: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00035</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>424</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00480</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>375</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1556</internalId></specobject>
    <specobject>
      <id>EthIf_ASR403_SetControllerMode_Wakeup_Second_Switch</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR403/TestSpec_Generated.h</sourcefile>
      <sourceline>364</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that when called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST, EthIf_SetControllerMode shall not forward the call to Eth_SetControllerMode and EthSM_CtrlModeIndication with ETH_MODE_ACTIVE if already indicated and that it will always forward the call to EthSwt_SetSwitchPortMode with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST. In this test case switch is referenced.
Test Object: EthIf_SetControllerMode
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller mode to ACTIVE or ACTIVE_WITH_WAKEUP_REQUEST and indicate it to Eth.
    02: Request Ethernet interface controller mode to ACTIVE or ACTIVE_WITH_WAKEUP_REQUEST.
    03: VP(EthIf.SWS_EthIf_00035,1) Verify that Eth_SetControllerMode and EthSM_CtrlModeIndication were not called.
    04: Request Ethernet interface controller mode to ACTIVE.
    05: VP(EthIf.SWS_EthIf_00035,1) Verify that Eth_SetControllerMode and EthSM_CtrlModeIndication were not called.
    06: Request Ethernet interface controller mode to ACTIVE_WITH_WAKEUP_REQUEST.
    07: VP(EthIf.EB.SWS_EthIf_00480,1) Verify that EthSwt_SetSwitchPortMode is called whenever EthIf_SetControllerMode is called with ACTIVE_WITH_WAKEUP_REQUEST.
    08: VP(EthIf.SWS_EthIf_00035,1) Verify that Eth_SetControllerMode and EthSM_CtrlModeIndication were not called.
    09: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00035</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>424</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00480</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>375</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1557</internalId></specobject>
    <specobject>
      <id>EthIf_ASR403_SetControllerMode_Wakeup_Second_Switch_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR403/TestSpec_Generated.h</sourcefile>
      <sourceline>396</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that when called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST, EthIf_SetControllerMode shall forward the call to EthSwt_SetSwitchPortMode with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST. In this case EthIf_CtrlModeIndication was called for the first time after calling EthIf_SetControllerMode twice. In this test case switch is referenced.
Test Object: EthIf_SetControllerMode
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Request Ethernet interface controller mode to ACTIVE or ACTIVE_WITH_WAKEUP_REQUEST and indicate it to Eth.
    02: Request Ethernet interface controller mode to ACTIVE_WITH_WAKEUP_REQUEST.
    03: Receive callout to set Ethernet interface controller mode to ACTIVE.
    04: VP(EthIf.EB.SWS_EthIf_00480,1)
        VP(EthIf.EB.EthSwt_SetSwitchPortMode.Async.CtrlModeIndication,1) Verify that EthSwt_SetSwitchPortMode is called whenever EthIf_SetControllerMode is called with ACTIVE_WITH_WAKEUP_REQUEST.
    05: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00480</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>375</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.EthSwt_SetSwitchPortMode.Async.CtrlModeIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>381</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1558</internalId></specobject>
    <specobject>
      <id>EthIf_ASR403_SetControllerMode_Wakeup_Second_Switch_PortGroup_NoControl</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR403/TestSpec_Generated.h</sourcefile>
      <sourceline>425</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that when called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST when last requested communication mode is ETH_MODE_ACTIVE or ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST, EthIf_SetControllerMode shall not forward the call to EthSwt_SetSwitchPortMode.
Test Object: EthIf_SetControllerMode
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   EthIf controller is not in control of port groups.
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller mode to ACTIVE or ACTIVE_WITH_WAKEUP_REQUEST and indicate it to Eth.
    02: Request Ethernet interface controller mode to ACTIVE.
    03: VP(EthIf.EB.SWS_EthIf_00479_00481,1) Verify that EthSwt_SetSwitchPortMode is not called.
    04: Request Ethernet interface controller mode to ACTIVE_WITH_WAKEUP_REQUEST.
    05: VP(EthIf.EB.SWS_EthIf_00479_00481,1) Verify that EthSwt_SetSwitchPortMode is not called.
    06: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00479_00481</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>378</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1559</internalId></specobject>
    <specobject>
      <id>EthIf_ASR403_SetControllerMode_Wakeup_Activate_Switch</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR403/TestSpec_Generated.h</sourcefile>
      <sourceline>450</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that transceiver link was correctly changed from DOWN to ACIVE when EthIf_SetControllerMode was called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST and switch was referenced.
Test Object: Activation with wakeup request
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller and transceiver mode to ACTIVE_WITH_WAKEUP_REQUEST.
    02: Call EthIf_MainFunctionState to change link state to ACTIVE.
    03: VP(EthIf.SWS_EthIf_00260,1) Verify that the link was changed to ACTIVE.
    04: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00260</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>613</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1560</internalId></specobject>
    <specobject>
      <id>EthIf_ASR403_SetControllerMode_Wakeup_Deactivate_Switch</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR403/TestSpec_Generated.h</sourcefile>
      <sourceline>473</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that transceiver link was correctly changed from ACIVE to DOWN when EthIf_SetControllerMode was activated with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST and switch was referenced.
Test Object: Deactivation with wakeup request
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
    -   Activate link state of the transceiver
  
Test Execution: 
    01: Set Ethernet interface controller and transceiver mode to DOWN.
    02: Call EthIf_MainFunctionState to change link state to DOWN.
    03: VP(EthIf.SWS_EthIf_00260,1) Verify that the link was changed to DOWN.
    04: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00260</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>613</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1561</internalId></specobject>
    <specobject>
      <id>EthIf_ASR403_SetControllerMode_Wakeup_Repeat_Switch</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR403/TestSpec_Generated.h</sourcefile>
      <sourceline>497</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that EthSwt_SetSwitchPortMode will be recalled with ACTIVE_WITH_WAKEUP_REQUEST when repeat timer expires.
Test Object: Repeat timer for switch
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller and switch port mode to ACTIVE_WITH_WAKEUP_REQUEST.
    02: Call EthIf_MainFunctionState to timeout the repeat timer without changing the link state.
    03: VP(EthIf.EB.SetModeTimeout.RepeatRequest.EthSwtGetLinkStateDown,1) Verify that EthSwt_SetSwitchPortMode was called because the link wasn't changed to ACTIVE.
    04: Call EthIf_MainFunctionState to change link state to ACTIVE.
    05: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SetModeTimeout.RepeatRequest.EthSwtGetLinkStateDown</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>259</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1562</internalId></specobject>
    <specobject>
      <id>EthIf_ASR403_SetControllerMode_Wakeup_Repeat_Next_Switch</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR403/TestSpec_Generated.h</sourcefile>
      <sourceline>521</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that EthSwt_SetSwitchPortMode will be recalled with ACTIVE_WITH_WAKEUP_REQUEST in the next mainfunction if the first call fails.
Test Object: Repeat timer for switch
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set return value of EthSwt_SetSwitchPortMode for first two ports to E_NOT_OK.
    02: Set Ethernet interface controller and switch port mode to ACTIVE_WITH_WAKEUP_REQUEST.
    03: Revert return value of EthSwt_SetSwitchPortMode for first two ports to E_OK.
    04: Call EthIf_MainFunctionState to retry informing switch.
    05: VP(EthIf.EB.Repeat.SetSwitchPortMode.HwNotOk,1) Verify that EthSwt_SetSwitchPortMode was called in the next mainfunction.
    06: Call EthIf_MainFunctionState to change link state to ACTIVE.
    07: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Repeat.SetSwitchPortMode.HwNotOk</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>264</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1563</internalId></specobject>
    <specobject>
      <id>EthIf_ASR403_SetControllerMode_Wakeup_Preemption_Switch</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR403/TestSpec_Generated.h</sourcefile>
      <sourceline>547</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that EthIf_SetControllerMode will not pass the call to the EthSwt_SetSwitchPortMode for those ports in switch that are locked because EthIf_MainFunctionState processing was preempted. In this case E_OK was set for EthSwt_SetSwitchPortMode in the first EthIf_MainFunctionState call.
Test Object: EthIf_SetControllerMode preemption of EthIf_MainFunctionState
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set return value of EthSwt_SetSwitchPortMode for first two ports to E_NOT_OK.
    02: Set Ethernet interface controller and switch port mode to ACTIVE_WITH_WAKEUP_REQUEST.
    03: Revert return value of EthSwt_SetSwitchPortMode for first two ports to E_OK.
    04: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthSwt_SetSwitchPortMode.
    05: Call EthIf_MainFunctionState to retry informing switch.
    06: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthSwt_SetSwitchPortMode was called from EthIf_SetControllerMode for the ports that don't reference a transceiver because others are locked.
    07: Call EthIf_MainFunctionState to change link state to ACTIVE.
    08: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>218</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1564</internalId></specobject>
    <specobject>
      <id>EthIf_ASR403_SetControllerMode_Wakeup_Preemption_Switch_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR403/TestSpec_Generated.h</sourcefile>
      <sourceline>574</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that EthIf_SetControllerMode will not pass the call to the EthSwt_SetSwitchPortMode for those ports in switch that are locked because EthIf_MainFunctionState processing was preempted. In this case E_OK was set for EthSwt_SetSwitchPortMode in the second EthIf_MainFunctionState call.
Test Object: EthIf_SetControllerMode preemption of EthIf_MainFunctionState
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set return value of EthSwt_SetSwitchPortMode for first two ports to E_NOT_OK.
    02: Set Ethernet interface controller and switch port mode to ACTIVE_WITH_WAKEUP_REQUEST.
    03: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthSwt_SetSwitchPortMode.
    04: Call EthIf_MainFunctionState to retry informing switch.
    05: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthSwt_SetSwitchPortMode was called from EthIf_SetControllerMode for the ports that don't reference a transceiver because others are locked.
    06: Revert return value of EthSwt_SetSwitchPortMode for first two ports to E_OK.
    07: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthSwt_SetSwitchPortMode.
    08: Call EthIf_MainFunctionState to retry informing switch.
    09: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthSwt_SetSwitchPortMode was called from EthIf_SetControllerMode for the ports that don't reference a transceiver because others are locked.
    10: Call EthIf_MainFunctionState to change link state to ACTIVE.
    11: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>218</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1565</internalId></specobject>
    <specobject>
      <id>EthIf_ASR403_SetControllerMode_Wakeup_Preemption_Switch_3</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR403/TestSpec_Generated.h</sourcefile>
      <sourceline>604</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that EthIf_SetControllerMode will not pass the call to the EthSwt_SetSwitchPortMode for those ports in switch that are locked because EthIf_MainFunctionState processing was preempted. In this case E_OK was set for EthSwt_SetSwitchPortMode in the third EthIf_MainFunctionState call.
Test Object: EthIf_SetControllerMode preemption of EthIf_MainFunctionState
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set return value of EthSwt_SetSwitchPortMode for first two ports to E_NOT_OK.
    02: Set Ethernet interface controller and switch port mode to ACTIVE_WITH_WAKEUP_REQUEST.
    03: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthSwt_SetSwitchPortMode.
    04: Call EthIf_MainFunctionState to retry informing switch.
    05: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthSwt_SetSwitchPortMode was called from EthIf_SetControllerMode for the ports that don't reference a transceiver because others are locked.
    06: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthSwt_SetSwitchPortMode.
    07: Call EthIf_MainFunctionState to retry informing switch.
    08: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthSwt_SetSwitchPortMode was called from EthIf_SetControllerMode for the ports that don't reference a transceiver because others are locked.
    09: Revert return value of EthSwt_SetSwitchPortMode for first two ports to E_OK.
    10: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthSwt_SetSwitchPortMode.
    11: Call EthIf_MainFunctionState to retry informing switch.
    12: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthSwt_SetSwitchPortMode was called from EthIf_SetControllerMode for the ports that don't reference a transceiver because others are locked.
    13: Call EthIf_MainFunctionState to change link state to ACTIVE.
    14: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>218</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1566</internalId></specobject>
    <specobject>
      <id>EthIf_ASR403_SetControllerMode_Wakeup_NoRef</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR403/TestSpec_Generated.h</sourcefile>
      <sourceline>637</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that when called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST, EthIf_SetControllerMode shall forward the call to Eth_SetControllerMode with ETH_MODE_ACTIVE if not already indicated. In this test case there is no reference to neither transceiver, switch nor port group.
Test Object: EthIf_SetControllerMode
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   There is no reference to neither transceiver, switch nor port group
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller mode to ACTIVE.
    02: VP(EthIf.SWS_EthIf_00035,1) Verify that Eth_SetControllerMode was called with ETH_MODE_ACTIVE.
    03: VP(EthIf.EB.SWS_EthIf_00479_00481,1) Verify that set mode was not called because there is no reference to neither the transceiver, switch nor port group.
    04: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00035</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>424</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00479_00481</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>378</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1567</internalId></specobject>
    <specobject>
      <id>EthIf_ASR403_SetControllerMode_Wakeup_Second_NoRef</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR403/TestSpec_Generated.h</sourcefile>
      <sourceline>664</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that when called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST, EthIf_SetControllerMode shall not forward the call to Eth_SetControllerMode and EthSM_CtrlModeIndication with ETH_MODE_ACTIVE if already indicated. In this test case there is no reference to neither transceiver, switch nor port group.
Test Object: EthIf_SetControllerMode
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   There is no reference to neither transceiver, switch nor port group
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller mode to ACTIVE or ACTIVE_WITH_WAKEUP_REQUEST and indicate it to Eth.
    02: Request Ethernet interface controller mode to ACTIVE or ACTIVE_WITH_WAKEUP_REQUEST.
    03: VP(EthIf.SWS_EthIf_00035,1) Verify that Eth_SetControllerMode and EthSM_CtrlModeIndication were not called.
    04: Request Ethernet interface controller mode to ACTIVE.
    05: VP(EthIf.SWS_EthIf_00035,1) Verify that EthSM_CtrlModeIndication was not called.
    06: Request Ethernet interface controller mode to ACTIVE_WITH_WAKEUP_REQUEST.
    07: VP(EthIf.SWS_EthIf_00035,1) Verify that EthSM_CtrlModeIndication was not called.
    08: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00035</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>424</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1568</internalId></specobject>
    <specobject>
      <id>EthIf_ASR403_SetControllerMode_Wakeup_Activate_NoRef</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR403/TestSpec_Generated.h</sourcefile>
      <sourceline>691</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that transceiver link was correctly changed from DOWN to ACIVE when EthIf_SetControllerMode was called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST and there is no reference to neither transceiver, switch nor port group.
Test Object: Activation with wakeup request
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   There is no reference to neither transceiver, switch nor port group
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller and transceiver mode to ACTIVE_WITH_WAKEUP_REQUEST.
    02: Call EthIf_MainFunctionState to change link state to ACTIVE.
    03: VP(EthIf.EB.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange.NoRef,1) Verify that the link was changed to ACTIVE.
    04: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange.NoRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>379</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1569</internalId></specobject>
    <specobject>
      <id>EthIf_ASR403_SetControllerMode_Wakeup_Deactivate_NoRef</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR403/TestSpec_Generated.h</sourcefile>
      <sourceline>714</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that transceiver link was correctly changed from ACIVE to DOWN when EthIf_SetControllerMode was activated with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST and there is no reference to neither transceiver, switch nor port group.
Test Object: Deactivation with wakeup request
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   There is no reference to neither transceiver, switch nor port group
    -   EthIf and test setup is initialized
    -   Activate link state of the transceiver
  
Test Execution: 
    01: Set Ethernet interface controller and transceiver mode to DOWN.
    02: Call EthIf_MainFunctionState to change link state to DOWN.
    03: VP(EthIf.ASR43.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange,1) Verify that the link was changed to DOWN.
    04: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>130</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1570</internalId></specobject>
    <specobject>
      <id>EthIf_ASR403_SetControllerMode_Wakeup_SwitchPortGroup</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR403/TestSpec_Generated.h</sourcefile>
      <sourceline>738</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that when called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST, EthIf_SetControllerMode shall forward the call to Eth_SetControllerMode with ETH_MODE_ACTIVE if not already indicated. In this test case switch port group is referenced.
Test Object: EthIf_SetControllerMode
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch port group support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller mode to ACTIVE.
    02: VP(EthIf.SWS_EthIf_00035,1) Verify that Eth_SetControllerMode was called with ETH_MODE_ACTIVE.
    03: VP(EthIf.EB.SWS_EthIf_00481,1) Verify that EthSwt_SetSwitchPortMode was called with ETHTRCV_MODE_ACTIVE_WITH_WAKEUP_REQUEST for every port in the given port group.
    04: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00035</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>424</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00481</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>376</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1571</internalId></specobject>
    <specobject>
      <id>EthIf_ASR403_SetControllerMode_Wakeup_Second_SwitchPortGroup</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR403/TestSpec_Generated.h</sourcefile>
      <sourceline>765</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that when called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST, EthIf_SetControllerMode shall not forward the call to Eth_SetControllerMode and EthSM_CtrlModeIndication with ETH_MODE_ACTIVE if already indicated and that it will always forward the call to EthSwt_SetSwitchPortMode with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST. In this test case switch port group is referenced.
Test Object: EthIf_SetControllerMode
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch port group support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller mode to ACTIVE or ACTIVE_WITH_WAKEUP_REQUEST and indicate it to Eth.
    02: Request Ethernet interface controller mode to ACTIVE or ACTIVE_WITH_WAKEUP_REQUEST.
    03: VP(EthIf.SWS_EthIf_00035,1) Verify that Eth_SetControllerMode and EthSM_CtrlModeIndication were not called.
    04: Request Ethernet interface controller mode to ACTIVE.
    05: VP(EthIf.SWS_EthIf_00035,1) Verify that Eth_SetControllerMode and EthSM_CtrlModeIndication were not called.
    06: Request Ethernet interface controller mode to ACTIVE_WITH_WAKEUP_REQUEST.
    07: VP(EthIf.EB.SWS_EthIf_00481,1) Verify that EthSwt_SetSwitchPortMode is called whenever EthIf_SetControllerMode is called with ACTIVE_WITH_WAKEUP_REQUEST.
    08: VP(EthIf.SWS_EthIf_00035,1) Verify that Eth_SetControllerMode and EthSM_CtrlModeIndication were not called.
    09: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00035</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>424</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00481</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>376</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1572</internalId></specobject>
    <specobject>
      <id>EthIf_ASR403_SetControllerMode_Wakeup_Second_SwitchPortGroup_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR403/TestSpec_Generated.h</sourcefile>
      <sourceline>797</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that when called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST, EthIf_SetControllerMode shall forward the call to EthSwt_SetSwitchPortMode with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST. In this case EthIf_CtrlModeIndication was called for the first time after calling EthIf_SetControllerMode twice. In this test case switch port group is referenced.
Test Object: EthIf_SetControllerMode
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch port group support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Request Ethernet interface controller mode to ACTIVE or ACTIVE_WITH_WAKEUP_REQUEST and indicate it to Eth.
    02: Request Ethernet interface controller mode to ACTIVE_WITH_WAKEUP_REQUEST.
    03: Receive callout to set Ethernet interface controller mode to ACTIVE.
    04: VP(EthIf.EB.SWS_EthIf_00481,1)
        VP(EthIf.EB.EthSwt_SetSwitchPortMode.Async.CtrlModeIndication,1) Verify that EthSwt_SetSwitchPortMode is called whenever EthIf_SetControllerMode is called with ACTIVE_WITH_WAKEUP_REQUEST.
    05: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00481</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>376</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.EthSwt_SetSwitchPortMode.Async.CtrlModeIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>381</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1573</internalId></specobject>
    <specobject>
      <id>EthIf_ASR403_SetControllerMode_Wakeup_Activate_SwitchPortGroup</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR403/TestSpec_Generated.h</sourcefile>
      <sourceline>826</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that transceiver link was correctly changed from DOWN to ACIVE when EthIf_SetControllerMode was called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST and switch port group was referenced.
Test Object: Activation with wakeup request
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch port group support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller and transceiver mode to ACTIVE_WITH_WAKEUP_REQUEST.
    02: Call EthIf_MainFunctionState to change link state to ACTIVE.
    03: VP(EthIf.SWS_EthIf_00262,1) Verify that the link was changed to ACTIVE.
    04: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00262</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>615</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1574</internalId></specobject>
    <specobject>
      <id>EthIf_ASR403_SetControllerMode_Wakeup_Deactivate_SwitchPortGroup</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR403/TestSpec_Generated.h</sourcefile>
      <sourceline>849</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that transceiver link was correctly changed from ACIVE to DOWN when EthIf_SetControllerMode was activated with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST and switch port group was referenced.
Test Object: Deactivation with wakeup request
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch port group support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
    -   Activate link state of the transceiver
  
Test Execution: 
    01: Set Ethernet interface controller and transceiver mode to DOWN.
    02: Call EthIf_MainFunctionState to change link state to DOWN.
    03: VP(EthIf.SWS_EthIf_00262,1) Verify that the link was changed to DOWN.
    04: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00262</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>615</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1575</internalId></specobject>
    <specobject>
      <id>EthIf_ASR403_SwitchPortGroupRequestMode_Wakeup_Second_SwitchPortGroup</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR403/TestSpec_Generated.h</sourcefile>
      <sourceline>873</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that when called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST, EthIf_SwitchPortGroupRequestMode shall always forward the call to EthSwt_SetSwitchPortMode.
Test Object: EthIf_SwitchPortGroupRequestMode
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch port group support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller mode to ACTIVE or ACTIVE_WITH_WAKEUP_REQUEST and indicate it to Eth.
    02: Request port group mode ACTIVE or ACTIVE_WITH_WAKEUP_REQUEST and indicate it to EthSwt.
    03: Request port group mode ACTIVE or ACTIVE_WITH_WAKEUP_REQUEST.
    04: VP(EthIf.EB.SWS_EthIf_00482,1) Verify that EthSwt_SetSwitchPortMode was called only for ACTIVE_WITH_WAKEUP_REQUEST.
    05: Request port group mode ACTIVE and check that nothing was called.
    06: Request port group mode ACTIVE_WITH_WAKEUP_REQUEST.
    07: VP(EthIf.EB.SWS_EthIf_00482,1) Verify that EthSwt_SetSwitchPortMode is called whenever EthIf_SwitchPortGroupRequestMode is called with ACTIVE_WITH_WAKEUP_REQUEST.
    08: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00482</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>377</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1576</internalId></specobject>
    <specobject>
      <id>EthIf_ASR403_SetControllerMode_Wakeup_Repeat_SwitchPortGroup</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR403/TestSpec_Generated.h</sourcefile>
      <sourceline>900</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that EthSwt_SetSwitchPortMode will be recalled with ACTIVE_WITH_WAKEUP_REQUEST when repeat timer expires.
Test Object: Repeat timer for switch port group
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch port group support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller and switch port mode to ACTIVE_WITH_WAKEUP_REQUEST.
    02: Call EthIf_MainFunctionState to timeout the repeat timer without changing the link state.
    03: VP(EthIf.EB.SetModeTimeout.RepeatRequest.EthSwtGetLinkStateDown,1) Verify that EthSwt_SetSwitchPortMode was called because the link wasn't changed to ACTIVE.
    04: Call EthIf_MainFunctionState to change link state to ACTIVE.
    05: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SetModeTimeout.RepeatRequest.EthSwtGetLinkStateDown</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>259</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1577</internalId></specobject>
    <specobject>
      <id>EthIf_ASR403_SetControllerMode_Wakeup_Repeat_Next_SwitchPortGroup</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR403/TestSpec_Generated.h</sourcefile>
      <sourceline>924</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that EthSwt_SetSwitchPortMode will be recalled with ACTIVE_WITH_WAKEUP_REQUEST in the next mainfunction if the first call fails.
Test Object: Repeat timer for switch port group
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch port group support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set return value of EthSwt_SetSwitchPortMode for first two ports to E_NOT_OK.
    02: Set Ethernet interface controller and switch port mode to ACTIVE_WITH_WAKEUP_REQUEST.
    03: Revert return value of EthSwt_SetSwitchPortMode for first two ports to E_OK.
    04: Call EthIf_MainFunctionState to retry informing switch.
    05: VP(EthIf.EB.Repeat.SetSwitchPortMode.HwNotOk,1) Verify that EthSwt_SetSwitchPortMode was called in the next mainfunction.
    06: Call EthIf_MainFunctionState to change link state to ACTIVE.
    07: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Repeat.SetSwitchPortMode.HwNotOk</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>264</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1578</internalId></specobject>
    <specobject>
      <id>EthIf_ASR403_SetControllerMode_Wakeup_Preemption_SwitchPortGroup</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR403/TestSpec_Generated.h</sourcefile>
      <sourceline>950</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that EthIf_SetControllerMode will not pass the call to the EthSwt_SetSwitchPortMode for those ports in switch port group that are locked because EthIf_MainFunctionState processing was preempted. In this case E_OK was set for EthSwt_SetSwitchPortMode in the first EthIf_MainFunctionState call.
Test Object: EthIf_SetControllerMode preemption of EthIf_MainFunctionState
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch port group support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set return value of EthSwt_SetSwitchPortMode for first two ports to E_NOT_OK.
    02: Set Ethernet interface controller and switch port mode to ACTIVE_WITH_WAKEUP_REQUEST.
    03: Revert return value of EthSwt_SetSwitchPortMode for first two ports to E_OK.
    04: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthSwt_SetSwitchPortMode.
    05: Call EthIf_MainFunctionState to retry informing switch.
    06: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthSwt_SetSwitchPortMode was called from EthIf_SetControllerMode for the ports that don't reference a transceiver because others are locked.
    07: Call EthIf_MainFunctionState to change link state to ACTIVE.
    08: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>218</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1579</internalId></specobject>
    <specobject>
      <id>EthIf_ASR403_SetControllerMode_Wakeup_Preemption_SwitchPortGroup_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR403/TestSpec_Generated.h</sourcefile>
      <sourceline>977</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that EthIf_SetControllerMode will not pass the call to the EthSwt_SetSwitchPortMode for those ports in switch port group that are locked because EthIf_MainFunctionState processing was preempted. In this case E_OK was set for EthSwt_SetSwitchPortMode in the second EthIf_MainFunctionState call.
Test Object: EthIf_SetControllerMode preemption of EthIf_MainFunctionState
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch port group support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set return value of EthSwt_SetSwitchPortMode for first two ports to E_NOT_OK.
    02: Set Ethernet interface controller and switch port mode to ACTIVE_WITH_WAKEUP_REQUEST.
    03: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthSwt_SetSwitchPortMode.
    04: Call EthIf_MainFunctionState to retry informing switch.
    05: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthSwt_SetSwitchPortMode was called from EthIf_SetControllerMode for the ports that don't reference a transceiver because others are locked.
    06: Revert return value of EthSwt_SetSwitchPortMode for first two ports to E_OK.
    07: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthSwt_SetSwitchPortMode.
    08: Call EthIf_MainFunctionState to retry informing switch.
    09: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthSwt_SetSwitchPortMode was called from EthIf_SetControllerMode for the ports that don't reference a transceiver because others are locked.
    10: Call EthIf_MainFunctionState to change link state to ACTIVE.
    11: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>218</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1580</internalId></specobject>
    <specobject>
      <id>EthIf_ASR403_SetControllerMode_Wakeup_Preemption_SwitchPortGroup_3</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR403/TestSpec_Generated.h</sourcefile>
      <sourceline>1007</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that EthIf_SetControllerMode will not pass the call to the EthSwt_SetSwitchPortMode for those ports in switch port group that are locked because EthIf_MainFunctionState processing was preempted. In this case E_OK was set for EthSwt_SetSwitchPortMode in the third EthIf_MainFunctionState call.
Test Object: EthIf_SetControllerMode preemption of EthIf_MainFunctionState
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch port group support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set return value of EthSwt_SetSwitchPortMode for first two ports to E_NOT_OK.
    02: Set Ethernet interface controller and switch port mode to ACTIVE_WITH_WAKEUP_REQUEST.
    03: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthSwt_SetSwitchPortMode.
    04: Call EthIf_MainFunctionState to retry informing switch.
    05: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthSwt_SetSwitchPortMode was called from EthIf_SetControllerMode for the ports that don't reference a transceiver because others are locked.
    06: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthSwt_SetSwitchPortMode.
    07: Call EthIf_MainFunctionState to retry informing switch.
    08: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthSwt_SetSwitchPortMode was called from EthIf_SetControllerMode for the ports that don't reference a transceiver because others are locked.
    09: Revert return value of EthSwt_SetSwitchPortMode for first two ports to E_OK.
    10: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthSwt_SetSwitchPortMode.
    11: Call EthIf_MainFunctionState to retry informing switch.
    12: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthSwt_SetSwitchPortMode was called from EthIf_SetControllerMode for the ports that don't reference a transceiver because others are locked.
    13: Call EthIf_MainFunctionState to change link state to ACTIVE.
    14: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>218</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1581</internalId></specobject>
    <specobject>
      <id>EthIf_ASR403_EthIf_TrcvModeIndication_Wodl_UnexpectedMode</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR403/TestSpec_Generated.h</sourcefile>
      <sourceline>1040</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that EthIf does not check the state of transceiver link if transceiver reports mode down when ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST had been requested.
Test Object: Activation with wakeup request
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
    -   Asynchronous mode is configured.
  
Test Execution: 
    01: Set Ethernet interface controller and transceiver mode to ACTIVE_WITH_WAKEUP_REQUEST.
    02: Call EthIf_MainFunctionState.
    03: VP(EthIf.SWS_EthIf_00232, 1) Verify EthTrcv_GetLinkState was not called.
    04: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00232</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>557</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1582</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EthIf_ASR422_SetControllerMode_Wakeup_Transceiver</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR422/TestSpec_Generated.h</sourcefile>
      <sourceline>9</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that when called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST, EthIf_SetControllerMode shall forward the call to Eth_SetControllerMode with ETH_MODE_ACTIVE if not already indicated. In this test case transceiver is referenced.
Test Object: EthIf_SetControllerMode
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller mode to ACTIVE.
    02: VP(EthIf.SWS_EthIf_00035,1) Verify that Eth_SetControllerMode was called with ETH_MODE_ACTIVE.
    03: VP(EthIf.EB.SWS_EthIf_00479,1) Verify that EthTrcv_SetTransceiverMode was called with ETHTRCV_MODE_ACTIVE_WITH_WAKEUP_REQUEST.
    04: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00035</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>424</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00479</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>374</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1583</internalId></specobject>
    <specobject>
      <id>EthIf_ASR422_SetControllerMode_Wakeup_Second_Transceiver</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR422/TestSpec_Generated.h</sourcefile>
      <sourceline>36</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that when called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST, EthIf_SetControllerMode shall not forward the call to Eth_SetControllerMode and EthSM_CtrlModeIndication with ETH_MODE_ACTIVE if already indicated and that it will always forward the call to EthTrcv_SetTransceiverMode with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST. In this test case transceiver is referenced.
Test Object: EthIf_SetControllerMode
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller mode to ACTIVE or ACTIVE_WITH_WAKEUP_REQUEST and indicate it to Eth.
    02: Request Ethernet interface controller mode to ACTIVE or ACTIVE_WITH_WAKEUP_REQUEST.
    03: VP(EthIf.SWS_EthIf_00035,1) Verify that Eth_SetControllerMode and EthSM_CtrlModeIndication were not called.
    04: Request Ethernet interface controller mode to ACTIVE.
    05: VP(EthIf.SWS_EthIf_00035,1) Verify that Eth_SetControllerMode and EthSM_CtrlModeIndication were not called.
    06: Request Ethernet interface controller mode to ACTIVE_WITH_WAKEUP_REQUEST.
    07: VP(EthIf.EB.SWS_EthIf_00479,1) Verify that EthTrcv_SetTransceiverMode is called whenever EthIf_SetControllerMode is called with ACTIVE_WITH_WAKEUP_REQUEST.
    08: VP(EthIf.SWS_EthIf_00035,1) Verify that Eth_SetControllerMode and EthSM_CtrlModeIndication were not called.
    09: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00035</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>424</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00479</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>374</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1584</internalId></specobject>
    <specobject>
      <id>EthIf_ASR422_SetControllerMode_Wakeup_Second_Transceiver_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR422/TestSpec_Generated.h</sourcefile>
      <sourceline>68</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that when called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST, EthIf_SetControllerMode shall forward the call to EthTrcv_SetTransceiverMode with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST. In this case EthIf_CtrlModeIndication was called for the first time after calling EthIf_SetControllerMode twice. In this test case transceiver is referenced.
Test Object: EthIf_SetControllerMode
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Request Ethernet interface controller mode to ACTIVE or ACTIVE_WITH_WAKEUP_REQUEST and indicate it to Eth.
    02: Request Ethernet interface controller mode to ACTIVE_WITH_WAKEUP_REQUEST.
    03: Receive callout to set Ethernet interface controller mode to ACTIVE.
    04: VP(EthIf.EB.SWS_EthIf_00479,1)
        VP(EthIf.EB.EthTrcv_SetTransceiverMode.Async.CtrlModeIndication,1) Verify that EthTrcv_SetTransceiverMode is called whenever EthIf_SetControllerMode is called with ACTIVE_WITH_WAKEUP_REQUEST.
    05: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00479</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>374</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.EthTrcv_SetTransceiverMode.Async.CtrlModeIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>380</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1585</internalId></specobject>
    <specobject>
      <id>EthIf_ASR422_SetControllerMode_Wakeup_Activate_Transceiver</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR422/TestSpec_Generated.h</sourcefile>
      <sourceline>97</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that transceiver link was correctly changed from DOWN to ACIVE when EthIf_SetControllerMode was called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST and transceiver was referenced.
Test Object: Activation with wakeup request
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller and transceiver mode to ACTIVE_WITH_WAKEUP_REQUEST.
    02: Call EthIf_MainFunctionState to change link state to ACTIVE.
    03: VP(EthIf.ASR43.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange,1) Verify that the link was changed to ACTIVE.
    04: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>130</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1586</internalId></specobject>
    <specobject>
      <id>EthIf_ASR422_SetControllerMode_Wakeup_Deactivate_Transceiver</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR422/TestSpec_Generated.h</sourcefile>
      <sourceline>120</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that transceiver link was correctly changed from ACIVE to DOWN when EthIf_SetControllerMode was activated with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST and transceiver was referenced.
Test Object: Deactivation with wakeup request
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
    -   Activate link state of the transceiver
  
Test Execution: 
    01: Set Ethernet interface controller and transceiver mode to DOWN.
    02: Call EthIf_MainFunctionState to change link state to DOWN.
    03: VP(EthIf.ASR43.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange,1) Verify that the link was changed to DOWN.
    04: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>130</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1587</internalId></specobject>
    <specobject>
      <id>EthIf_ASR422_CtrlModeIndication_Wakeup_Mix_Transceiver</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR422/TestSpec_Generated.h</sourcefile>
      <sourceline>144</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that when called with ETH_MODE_ACTIVE or ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST, EthIf_CtrlModeIndication shall forward the call to EthTrcv_SetTransceiverMode with initially requested state regardless if EthIf_SetControllerMode already informed EthTrcv_SetTransceiverMode about ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST.
Test Object: EthIf_CtrlModeIndication
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller mode to ACTIVE or ACTIVE_WITH_WAKEUP_REQUEST and indicate it to Eth.
    02: VP(EthIf.EB.SWS_EthIf_00479,1) Verify that EthTrcv_SetTransceiverMode is called is called with initially requested state.
    03: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00479</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>374</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1588</internalId></specobject>
    <specobject>
      <id>EthIf_ASR422_SetControllerMode_Wakeup_Repeat_Transceiver</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR422/TestSpec_Generated.h</sourcefile>
      <sourceline>166</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that EthTrcv_SetTransceiverMode will be recalled with ACTIVE_WITH_WAKEUP_REQUEST when repeat timer expires.
Test Object: Repeat timer for transceiver
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller and transceiver mode to ACTIVE_WITH_WAKEUP_REQUEST.
    02: Call EthIf_MainFunctionState to timeout the repeat timer without changing the link state.
    03: VP(EthIf.EB.SetModeTimeout.RepeatRequest.ReadFail,1) Verify that EthTrcv_SetTransceiverMode was called because the link wasn't changed to ACTIVE.
    04: Call EthIf_MainFunctionState to change link state to ACTIVE.
    05: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SetModeTimeout.RepeatRequest.ReadFail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>260</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1589</internalId></specobject>
    <specobject>
      <id>EthIf_ASR422_SetControllerMode_Wakeup_Repeat_Next_Transceiver</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR422/TestSpec_Generated.h</sourcefile>
      <sourceline>190</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that EthTrcv_SetTransceiverMode will be recalled with ACTIVE_WITH_WAKEUP_REQUEST in the next mainfunction if the first call fails.
Test Object: Repeat timer for transceiver
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set return value of EthTrcv_SetTransceiverMode to E_NOT_OK.
    02: Set Ethernet interface controller and transceiver mode to ACTIVE_WITH_WAKEUP_REQUEST.
    03: Revert return value of EthTrcv_SetTransceiverMode to E_OK.
    04: Call EthIf_MainFunctionState to retry informing transceiver.
    05: VP(EthIf.EB.SetModeTimeout.RepeatRequest.ReadFail,1) Verify that EthTrcv_SetTransceiverMode was called in the next mainfunction.
    06: Call EthIf_MainFunctionState to change link state to ACTIVE.
    07: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SetModeTimeout.RepeatRequest.ReadFail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>260</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1590</internalId></specobject>
    <specobject>
      <id>EthIf_ASR422_SetControllerMode_Wakeup_Preemption_Transceiver</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR422/TestSpec_Generated.h</sourcefile>
      <sourceline>216</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that EthIf_SetControllerMode will not pass the call to the EthTrcv_SetTransceiverMode for locked transceiver because EthIf_MainFunctionState processing was preempted. In this case E_OK was set for EthTrcv_SetTransceiverMode in the first EthIf_MainFunctionState call.
Test Object: EthIf_SetControllerMode preemption of EthIf_MainFunctionState
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set return value of EthTrcv_SetTransceiverMode to E_NOT_OK.
    02: Set Ethernet interface controller and switch port mode to ACTIVE_WITH_WAKEUP_REQUEST.
    03: Set return value of EthTrcv_SetTransceiverMode to E_OK.
    04: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthTrcv_SetTransceiverMode.
    05: Call EthIf_MainFunctionState to retry informing transceiver.
    06: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthTrcv_SetTransceiverMode was not called from EthIf_SetControllerMode because the transceiver was already locked.
    07: Call EthIf_MainFunctionState to change link state to ACTIVE.
    08: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>218</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1591</internalId></specobject>
    <specobject>
      <id>EthIf_ASR422_SetControllerMode_Wakeup_Preemption_Transceiver_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR422/TestSpec_Generated.h</sourcefile>
      <sourceline>243</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that EthIf_SetControllerMode will not pass the call to the EthTrcv_SetTransceiverMode for locked transceiver because EthIf_MainFunctionState processing was preempted. In this case E_OK was set for EthTrcv_SetTransceiverMode in the second EthIf_MainFunctionState call.
Test Object: EthIf_SetControllerMode preemption of EthIf_MainFunctionState
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set return value of EthTrcv_SetTransceiverMode to E_NOT_OK.
    02: Set Ethernet interface controller and switch port mode to ACTIVE_WITH_WAKEUP_REQUEST.
    03: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthTrcv_SetTransceiverMode.
    04: Call EthIf_MainFunctionState to retry informing transceiver.
    05: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthTrcv_SetTransceiverMode was not called from EthIf_SetControllerMode because the transceiver was already locked.
    06: Set return value of EthTrcv_SetTransceiverMode to E_OK.
    07: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthTrcv_SetTransceiverMode.
    08: Call EthIf_MainFunctionState to retry informing transceiver.
    09: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthTrcv_SetTransceiverMode was not called from EthIf_SetControllerMode because the transceiver was already locked.
    10: Call EthIf_MainFunctionState to change link state to ACTIVE.
    11: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>218</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1592</internalId></specobject>
    <specobject>
      <id>EthIf_ASR422_SetControllerMode_Wakeup_Preemption_Transceiver_3</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR422/TestSpec_Generated.h</sourcefile>
      <sourceline>273</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that EthIf_SetControllerMode will not pass the call to the EthTrcv_SetTransceiverMode for locked transceiver because EthIf_MainFunctionState processing was preempted. In this case E_OK was set for EthTrcv_SetTransceiverMode in the third EthIf_MainFunctionState call.
Test Object: EthIf_SetControllerMode preemption of EthIf_MainFunctionState
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set return value of EthTrcv_SetTransceiverMode to E_NOT_OK.
    02: Set Ethernet interface controller and switch port mode to ACTIVE_WITH_WAKEUP_REQUEST.
    03: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthTrcv_SetTransceiverMode.
    04: Call EthIf_MainFunctionState to retry informing transceiver.
    05: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthTrcv_SetTransceiverMode was not called from EthIf_SetControllerMode because the transceiver was already locked.
    06: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthTrcv_SetTransceiverMode.
    07: Call EthIf_MainFunctionState to retry informing transceiver.
    08: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthTrcv_SetTransceiverMode was not called from EthIf_SetControllerMode because the transceiver was already locked.
    09: Set return value of EthTrcv_SetTransceiverMode to E_OK.
    10: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthTrcv_SetTransceiverMode.
    11: Call EthIf_MainFunctionState to retry informing transceiver.
    12: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthTrcv_SetTransceiverMode was not called from EthIf_SetControllerMode because the transceiver was already locked.
    13: Call EthIf_MainFunctionState to change link state to ACTIVE.
    14: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>218</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1593</internalId></specobject>
    <specobject>
      <id>EthIf_ASR422_SetControllerMode_Wakeup_Preemption_Transceiver_4</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR422/TestSpec_Generated.h</sourcefile>
      <sourceline>306</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that EthIf_SetControllerMode will not pass the call to the EthTrcv_SetTransceiverMode for locked transceiver because EthIf_MainFunctionState processing was preempted. In this case E_OK was set for EthTrcv_SetTransceiverMode between the second EthIf_MainFunctionState call and EthIf_SetControllerMode.
Test Object: EthIf_SetControllerMode preemption of EthIf_MainFunctionState
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set return value of EthTrcv_SetTransceiverMode to E_NOT_OK.
    02: Set Ethernet interface controller and switch port mode to ACTIVE_WITH_WAKEUP_REQUEST.
    03: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthSwt_SetSwitchPortMode.
    04: Call EthIf_MainFunctionState to retry informing transceiver.
    05: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthTrcv_SetTransceiverMode was not called from EthIf_SetControllerMode because the transceiver was already locked.
    06: Set return value of EthTrcv_SetTransceiverMode to E_OK.
    07: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthSwt_SetSwitchPortMode.
    08: Call EthIf_MainFunctionState to retry informing transceiver.
    09: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthTrcv_SetTransceiverMode was not called from EthIf_SetControllerMode because the transceiver was already locked.
    10: Call EthIf_SetControllerMode to inform transceiver.
    11: Call EthIf_MainFunctionState to change link state to ACTIVE.
    12: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>218</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1594</internalId></specobject>
    <specobject>
      <id>EthIf_ASR422_SetControllerMode_Wakeup_Switch</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR422/TestSpec_Generated.h</sourcefile>
      <sourceline>337</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that when called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST, EthIf_SetControllerMode shall forward the call to Eth_SetControllerMode with ETH_MODE_ACTIVE if not already indicated. In this test case switch is referenced.
Test Object: EthIf_SetControllerMode
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller mode to ACTIVE by calling with ACTIVE_WITH_WAKEUP_REQUEST.
    02: VP(EthIf.SWS_EthIf_00035,1) Verify that Eth_SetControllerMode was called with ETH_MODE_ACTIVE.
    03: VP(EthIf.EB.SWS_EthIf_00480,1) Verify that EthSwt_SetSwitchPortMode was called with ETHTRCV_MODE_ACTIVE_WITH_WAKEUP_REQUEST for every port in the given switch.
    04: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00035</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>424</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00480</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>375</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1595</internalId></specobject>
    <specobject>
      <id>EthIf_ASR422_SetControllerMode_Wakeup_Second_Switch</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR422/TestSpec_Generated.h</sourcefile>
      <sourceline>364</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that when called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST, EthIf_SetControllerMode shall not forward the call to Eth_SetControllerMode and EthSM_CtrlModeIndication with ETH_MODE_ACTIVE if already indicated and that it will always forward the call to EthSwt_SetSwitchPortMode with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST. In this test case switch is referenced.
Test Object: EthIf_SetControllerMode
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller mode to ACTIVE or ACTIVE_WITH_WAKEUP_REQUEST and indicate it to Eth.
    02: Request Ethernet interface controller mode to ACTIVE or ACTIVE_WITH_WAKEUP_REQUEST.
    03: VP(EthIf.SWS_EthIf_00035,1) Verify that Eth_SetControllerMode and EthSM_CtrlModeIndication were not called.
    04: Request Ethernet interface controller mode to ACTIVE.
    05: VP(EthIf.SWS_EthIf_00035,1) Verify that Eth_SetControllerMode and EthSM_CtrlModeIndication were not called.
    06: Request Ethernet interface controller mode to ACTIVE_WITH_WAKEUP_REQUEST.
    07: VP(EthIf.EB.SWS_EthIf_00480,1) Verify that EthSwt_SetSwitchPortMode is called whenever EthIf_SetControllerMode is called with ACTIVE_WITH_WAKEUP_REQUEST.
    08: VP(EthIf.SWS_EthIf_00035,1) Verify that Eth_SetControllerMode and EthSM_CtrlModeIndication were not called.
    09: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00035</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>424</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00480</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>375</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1596</internalId></specobject>
    <specobject>
      <id>EthIf_ASR422_SetControllerMode_Wakeup_Second_Switch_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR422/TestSpec_Generated.h</sourcefile>
      <sourceline>396</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that when called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST, EthIf_SetControllerMode shall forward the call to EthSwt_SetSwitchPortMode with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST. In this case EthIf_CtrlModeIndication was called for the first time after calling EthIf_SetControllerMode twice. In this test case switch is referenced.
Test Object: EthIf_SetControllerMode
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Request Ethernet interface controller mode to ACTIVE or ACTIVE_WITH_WAKEUP_REQUEST and indicate it to Eth.
    02: Request Ethernet interface controller mode to ACTIVE_WITH_WAKEUP_REQUEST.
    03: Receive callout to set Ethernet interface controller mode to ACTIVE.
    04: VP(EthIf.EB.SWS_EthIf_00480,1)
        VP(EthIf.EB.EthSwt_SetSwitchPortMode.Async.CtrlModeIndication,1) Verify that EthSwt_SetSwitchPortMode is called whenever EthIf_SetControllerMode is called with ACTIVE_WITH_WAKEUP_REQUEST.
    05: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00480</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>375</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.EthSwt_SetSwitchPortMode.Async.CtrlModeIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>381</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1597</internalId></specobject>
    <specobject>
      <id>EthIf_ASR422_SetControllerMode_Wakeup_Second_Switch_PortGroup_NoControl</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR422/TestSpec_Generated.h</sourcefile>
      <sourceline>425</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that when called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST when last requested communication mode is ETH_MODE_ACTIVE or ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST, EthIf_SetControllerMode shall not forward the call to EthSwt_SetSwitchPortMode.
Test Object: EthIf_SetControllerMode
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   EthIf controller is not in control of port groups.
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller mode to ACTIVE or ACTIVE_WITH_WAKEUP_REQUEST and indicate it to Eth.
    02: Request Ethernet interface controller mode to ACTIVE.
    03: VP(EthIf.EB.SWS_EthIf_00479_00481,1) Verify that EthSwt_SetSwitchPortMode is not called.
    04: Request Ethernet interface controller mode to ACTIVE_WITH_WAKEUP_REQUEST.
    05: VP(EthIf.EB.SWS_EthIf_00479_00481,1) Verify that EthSwt_SetSwitchPortMode is not called.
    06: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00479_00481</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>378</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1598</internalId></specobject>
    <specobject>
      <id>EthIf_ASR422_SetControllerMode_Wakeup_Activate_Switch</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR422/TestSpec_Generated.h</sourcefile>
      <sourceline>450</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that transceiver link was correctly changed from DOWN to ACIVE when EthIf_SetControllerMode was called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST and switch was referenced.
Test Object: Activation with wakeup request
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller and transceiver mode to ACTIVE_WITH_WAKEUP_REQUEST.
    02: Call EthIf_MainFunctionState to change link state to ACTIVE.
    03: VP(EthIf.SWS_EthIf_00260,1) Verify that the link was changed to ACTIVE.
    04: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00260</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>613</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1599</internalId></specobject>
    <specobject>
      <id>EthIf_ASR422_SetControllerMode_Wakeup_Deactivate_Switch</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR422/TestSpec_Generated.h</sourcefile>
      <sourceline>473</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that transceiver link was correctly changed from ACIVE to DOWN when EthIf_SetControllerMode was activated with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST and switch was referenced.
Test Object: Deactivation with wakeup request
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
    -   Activate link state of the transceiver
  
Test Execution: 
    01: Set Ethernet interface controller and transceiver mode to DOWN.
    02: Call EthIf_MainFunctionState to change link state to DOWN.
    03: VP(EthIf.SWS_EthIf_00260,1) Verify that the link was changed to DOWN.
    04: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00260</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>613</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1600</internalId></specobject>
    <specobject>
      <id>EthIf_ASR422_SetControllerMode_Wakeup_Repeat_Switch</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR422/TestSpec_Generated.h</sourcefile>
      <sourceline>497</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that EthSwt_SetSwitchPortMode will be recalled with ACTIVE_WITH_WAKEUP_REQUEST when repeat timer expires.
Test Object: Repeat timer for switch
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller and switch port mode to ACTIVE_WITH_WAKEUP_REQUEST.
    02: Call EthIf_MainFunctionState to timeout the repeat timer without changing the link state.
    03: VP(EthIf.EB.SetModeTimeout.RepeatRequest.EthSwtGetLinkStateDown,1) Verify that EthSwt_SetSwitchPortMode was called because the link wasn't changed to ACTIVE.
    04: Call EthIf_MainFunctionState to change link state to ACTIVE.
    05: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SetModeTimeout.RepeatRequest.EthSwtGetLinkStateDown</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>259</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1601</internalId></specobject>
    <specobject>
      <id>EthIf_ASR422_SetControllerMode_Wakeup_Repeat_Next_Switch</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR422/TestSpec_Generated.h</sourcefile>
      <sourceline>521</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that EthSwt_SetSwitchPortMode will be recalled with ACTIVE_WITH_WAKEUP_REQUEST in the next mainfunction if the first call fails.
Test Object: Repeat timer for switch
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set return value of EthSwt_SetSwitchPortMode for first two ports to E_NOT_OK.
    02: Set Ethernet interface controller and switch port mode to ACTIVE_WITH_WAKEUP_REQUEST.
    03: Revert return value of EthSwt_SetSwitchPortMode for first two ports to E_OK.
    04: Call EthIf_MainFunctionState to retry informing switch.
    05: VP(EthIf.EB.Repeat.SetSwitchPortMode.HwNotOk,1) Verify that EthSwt_SetSwitchPortMode was called in the next mainfunction.
    06: Call EthIf_MainFunctionState to change link state to ACTIVE.
    07: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Repeat.SetSwitchPortMode.HwNotOk</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>264</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1602</internalId></specobject>
    <specobject>
      <id>EthIf_ASR422_SetControllerMode_Wakeup_Preemption_Switch</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR422/TestSpec_Generated.h</sourcefile>
      <sourceline>547</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that EthIf_SetControllerMode will not pass the call to the EthSwt_SetSwitchPortMode for those ports in switch that are locked because EthIf_MainFunctionState processing was preempted. In this case E_OK was set for EthSwt_SetSwitchPortMode in the first EthIf_MainFunctionState call.
Test Object: EthIf_SetControllerMode preemption of EthIf_MainFunctionState
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set return value of EthSwt_SetSwitchPortMode for first two ports to E_NOT_OK.
    02: Set Ethernet interface controller and switch port mode to ACTIVE_WITH_WAKEUP_REQUEST.
    03: Revert return value of EthSwt_SetSwitchPortMode for first two ports to E_OK.
    04: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthSwt_SetSwitchPortMode.
    05: Call EthIf_MainFunctionState to retry informing switch.
    06: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthSwt_SetSwitchPortMode was called from EthIf_SetControllerMode for the ports that don't reference a transceiver because others are locked.
    07: Call EthIf_MainFunctionState to change link state to ACTIVE.
    08: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>218</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1603</internalId></specobject>
    <specobject>
      <id>EthIf_ASR422_SetControllerMode_Wakeup_Preemption_Switch_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR422/TestSpec_Generated.h</sourcefile>
      <sourceline>574</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that EthIf_SetControllerMode will not pass the call to the EthSwt_SetSwitchPortMode for those ports in switch that are locked because EthIf_MainFunctionState processing was preempted. In this case E_OK was set for EthSwt_SetSwitchPortMode in the second EthIf_MainFunctionState call.
Test Object: EthIf_SetControllerMode preemption of EthIf_MainFunctionState
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set return value of EthSwt_SetSwitchPortMode for first two ports to E_NOT_OK.
    02: Set Ethernet interface controller and switch port mode to ACTIVE_WITH_WAKEUP_REQUEST.
    03: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthSwt_SetSwitchPortMode.
    04: Call EthIf_MainFunctionState to retry informing switch.
    05: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthSwt_SetSwitchPortMode was called from EthIf_SetControllerMode for the ports that don't reference a transceiver because others are locked.
    06: Revert return value of EthSwt_SetSwitchPortMode for first two ports to E_OK.
    07: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthSwt_SetSwitchPortMode.
    08: Call EthIf_MainFunctionState to retry informing switch.
    09: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthSwt_SetSwitchPortMode was called from EthIf_SetControllerMode for the ports that don't reference a transceiver because others are locked.
    10: Call EthIf_MainFunctionState to change link state to ACTIVE.
    11: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>218</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1604</internalId></specobject>
    <specobject>
      <id>EthIf_ASR422_SetControllerMode_Wakeup_Preemption_Switch_3</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR422/TestSpec_Generated.h</sourcefile>
      <sourceline>604</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that EthIf_SetControllerMode will not pass the call to the EthSwt_SetSwitchPortMode for those ports in switch that are locked because EthIf_MainFunctionState processing was preempted. In this case E_OK was set for EthSwt_SetSwitchPortMode in the third EthIf_MainFunctionState call.
Test Object: EthIf_SetControllerMode preemption of EthIf_MainFunctionState
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set return value of EthSwt_SetSwitchPortMode for first two ports to E_NOT_OK.
    02: Set Ethernet interface controller and switch port mode to ACTIVE_WITH_WAKEUP_REQUEST.
    03: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthSwt_SetSwitchPortMode.
    04: Call EthIf_MainFunctionState to retry informing switch.
    05: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthSwt_SetSwitchPortMode was called from EthIf_SetControllerMode for the ports that don't reference a transceiver because others are locked.
    06: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthSwt_SetSwitchPortMode.
    07: Call EthIf_MainFunctionState to retry informing switch.
    08: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthSwt_SetSwitchPortMode was called from EthIf_SetControllerMode for the ports that don't reference a transceiver because others are locked.
    09: Revert return value of EthSwt_SetSwitchPortMode for first two ports to E_OK.
    10: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthSwt_SetSwitchPortMode.
    11: Call EthIf_MainFunctionState to retry informing switch.
    12: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthSwt_SetSwitchPortMode was called from EthIf_SetControllerMode for the ports that don't reference a transceiver because others are locked.
    13: Call EthIf_MainFunctionState to change link state to ACTIVE.
    14: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>218</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1605</internalId></specobject>
    <specobject>
      <id>EthIf_ASR422_SetControllerMode_Wakeup_NoRef</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR422/TestSpec_Generated.h</sourcefile>
      <sourceline>637</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that when called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST, EthIf_SetControllerMode shall forward the call to Eth_SetControllerMode with ETH_MODE_ACTIVE if not already indicated. In this test case there is no reference to neither transceiver, switch nor port group.
Test Object: EthIf_SetControllerMode
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   There is no reference to neither transceiver, switch nor port group
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller mode to ACTIVE.
    02: VP(EthIf.SWS_EthIf_00035,1) Verify that Eth_SetControllerMode was called with ETH_MODE_ACTIVE.
    03: VP(EthIf.EB.SWS_EthIf_00479_00481,1) Verify that set mode was not called because there is no reference to neither the transceiver, switch nor port group.
    04: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00035</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>424</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00479_00481</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>378</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1606</internalId></specobject>
    <specobject>
      <id>EthIf_ASR422_SetControllerMode_Wakeup_Second_NoRef</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR422/TestSpec_Generated.h</sourcefile>
      <sourceline>664</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that when called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST, EthIf_SetControllerMode shall not forward the call to Eth_SetControllerMode and EthSM_CtrlModeIndication with ETH_MODE_ACTIVE if already indicated. In this test case there is no reference to neither transceiver, switch nor port group.
Test Object: EthIf_SetControllerMode
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   There is no reference to neither transceiver, switch nor port group
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller mode to ACTIVE or ACTIVE_WITH_WAKEUP_REQUEST and indicate it to Eth.
    02: Request Ethernet interface controller mode to ACTIVE or ACTIVE_WITH_WAKEUP_REQUEST.
    03: VP(EthIf.SWS_EthIf_00035,1) Verify that Eth_SetControllerMode and EthSM_CtrlModeIndication were not called.
    04: Request Ethernet interface controller mode to ACTIVE.
    05: VP(EthIf.SWS_EthIf_00035,1) Verify that EthSM_CtrlModeIndication was not called.
    06: Request Ethernet interface controller mode to ACTIVE_WITH_WAKEUP_REQUEST.
    07: VP(EthIf.SWS_EthIf_00035,1) Verify that EthSM_CtrlModeIndication was not called.
    08: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00035</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>424</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1607</internalId></specobject>
    <specobject>
      <id>EthIf_ASR422_SetControllerMode_Wakeup_Activate_NoRef</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR422/TestSpec_Generated.h</sourcefile>
      <sourceline>691</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that transceiver link was correctly changed from DOWN to ACIVE when EthIf_SetControllerMode was called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST and there is no reference to neither transceiver, switch nor port group.
Test Object: Activation with wakeup request
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   There is no reference to neither transceiver, switch nor port group
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller and transceiver mode to ACTIVE_WITH_WAKEUP_REQUEST.
    02: Call EthIf_MainFunctionState to change link state to ACTIVE.
    03: VP(EthIf.EB.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange.NoRef,1) Verify that the link was changed to ACTIVE.
    04: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange.NoRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>379</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1608</internalId></specobject>
    <specobject>
      <id>EthIf_ASR422_SetControllerMode_Wakeup_Deactivate_NoRef</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR422/TestSpec_Generated.h</sourcefile>
      <sourceline>714</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that transceiver link was correctly changed from ACIVE to DOWN when EthIf_SetControllerMode was activated with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST and there is no reference to neither transceiver, switch nor port group.
Test Object: Deactivation with wakeup request
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   There is no reference to neither transceiver, switch nor port group
    -   EthIf and test setup is initialized
    -   Activate link state of the transceiver
  
Test Execution: 
    01: Set Ethernet interface controller and transceiver mode to DOWN.
    02: Call EthIf_MainFunctionState to change link state to DOWN.
    03: VP(EthIf.ASR43.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange,1) Verify that the link was changed to DOWN.
    04: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>130</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1609</internalId></specobject>
    <specobject>
      <id>EthIf_ASR422_SetControllerMode_Wakeup_SwitchPortGroup</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR422/TestSpec_Generated.h</sourcefile>
      <sourceline>738</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that when called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST, EthIf_SetControllerMode shall forward the call to Eth_SetControllerMode with ETH_MODE_ACTIVE if not already indicated. In this test case switch port group is referenced.
Test Object: EthIf_SetControllerMode
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch port group support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller mode to ACTIVE.
    02: VP(EthIf.SWS_EthIf_00035,1) Verify that Eth_SetControllerMode was called with ETH_MODE_ACTIVE.
    03: VP(EthIf.EB.SWS_EthIf_00481,1) Verify that EthSwt_SetSwitchPortMode was called with ETHTRCV_MODE_ACTIVE_WITH_WAKEUP_REQUEST for every port in the given port group.
    04: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00035</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>424</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00481</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>376</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1610</internalId></specobject>
    <specobject>
      <id>EthIf_ASR422_SetControllerMode_Wakeup_Second_SwitchPortGroup</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR422/TestSpec_Generated.h</sourcefile>
      <sourceline>765</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that when called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST, EthIf_SetControllerMode shall not forward the call to Eth_SetControllerMode and EthSM_CtrlModeIndication with ETH_MODE_ACTIVE if already indicated and that it will always forward the call to EthSwt_SetSwitchPortMode with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST. In this test case switch port group is referenced.
Test Object: EthIf_SetControllerMode
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch port group support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller mode to ACTIVE or ACTIVE_WITH_WAKEUP_REQUEST and indicate it to Eth.
    02: Request Ethernet interface controller mode to ACTIVE or ACTIVE_WITH_WAKEUP_REQUEST.
    03: VP(EthIf.SWS_EthIf_00035,1) Verify that Eth_SetControllerMode and EthSM_CtrlModeIndication were not called.
    04: Request Ethernet interface controller mode to ACTIVE.
    05: VP(EthIf.SWS_EthIf_00035,1) Verify that Eth_SetControllerMode and EthSM_CtrlModeIndication were not called.
    06: Request Ethernet interface controller mode to ACTIVE_WITH_WAKEUP_REQUEST.
    07: VP(EthIf.EB.SWS_EthIf_00481,1) Verify that EthSwt_SetSwitchPortMode is called whenever EthIf_SetControllerMode is called with ACTIVE_WITH_WAKEUP_REQUEST.
    08: VP(EthIf.SWS_EthIf_00035,1) Verify that Eth_SetControllerMode and EthSM_CtrlModeIndication were not called.
    09: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00035</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>424</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00481</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>376</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1611</internalId></specobject>
    <specobject>
      <id>EthIf_ASR422_SetControllerMode_Wakeup_Second_SwitchPortGroup_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR422/TestSpec_Generated.h</sourcefile>
      <sourceline>797</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that when called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST, EthIf_SetControllerMode shall forward the call to EthSwt_SetSwitchPortMode with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST. In this case EthIf_CtrlModeIndication was called for the first time after calling EthIf_SetControllerMode twice. In this test case switch port group is referenced.
Test Object: EthIf_SetControllerMode
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch port group support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Request Ethernet interface controller mode to ACTIVE or ACTIVE_WITH_WAKEUP_REQUEST and indicate it to Eth.
    02: Request Ethernet interface controller mode to ACTIVE_WITH_WAKEUP_REQUEST.
    03: Receive callout to set Ethernet interface controller mode to ACTIVE.
    04: VP(EthIf.EB.SWS_EthIf_00481,1)
        VP(EthIf.EB.EthSwt_SetSwitchPortMode.Async.CtrlModeIndication,1) Verify that EthSwt_SetSwitchPortMode is called whenever EthIf_SetControllerMode is called with ACTIVE_WITH_WAKEUP_REQUEST.
    05: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00481</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>376</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.EthSwt_SetSwitchPortMode.Async.CtrlModeIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>381</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1612</internalId></specobject>
    <specobject>
      <id>EthIf_ASR422_SetControllerMode_Wakeup_Activate_SwitchPortGroup</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR422/TestSpec_Generated.h</sourcefile>
      <sourceline>826</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that transceiver link was correctly changed from DOWN to ACIVE when EthIf_SetControllerMode was called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST and switch port group was referenced.
Test Object: Activation with wakeup request
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch port group support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller and transceiver mode to ACTIVE_WITH_WAKEUP_REQUEST.
    02: Call EthIf_MainFunctionState to change link state to ACTIVE.
    03: VP(EthIf.SWS_EthIf_00262,1) Verify that the link was changed to ACTIVE.
    04: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00262</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>615</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1613</internalId></specobject>
    <specobject>
      <id>EthIf_ASR422_SetControllerMode_Wakeup_Deactivate_SwitchPortGroup</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR422/TestSpec_Generated.h</sourcefile>
      <sourceline>849</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that transceiver link was correctly changed from ACIVE to DOWN when EthIf_SetControllerMode was activated with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST and switch port group was referenced.
Test Object: Deactivation with wakeup request
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch port group support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
    -   Activate link state of the transceiver
  
Test Execution: 
    01: Set Ethernet interface controller and transceiver mode to DOWN.
    02: Call EthIf_MainFunctionState to change link state to DOWN.
    03: VP(EthIf.SWS_EthIf_00262,1) Verify that the link was changed to DOWN.
    04: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00262</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>615</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1614</internalId></specobject>
    <specobject>
      <id>EthIf_ASR422_SwitchPortGroupRequestMode_Wakeup_Second_SwitchPortGroup</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR422/TestSpec_Generated.h</sourcefile>
      <sourceline>873</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that when called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST, EthIf_SwitchPortGroupRequestMode shall always forward the call to EthSwt_SetSwitchPortMode.
Test Object: EthIf_SwitchPortGroupRequestMode
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch port group support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller mode to ACTIVE or ACTIVE_WITH_WAKEUP_REQUEST and indicate it to Eth.
    02: Request port group mode ACTIVE or ACTIVE_WITH_WAKEUP_REQUEST and indicate it to EthSwt.
    03: Request port group mode ACTIVE or ACTIVE_WITH_WAKEUP_REQUEST.
    04: VP(EthIf.EB.SWS_EthIf_00482,1) Verify that EthSwt_SetSwitchPortMode was called only for ACTIVE_WITH_WAKEUP_REQUEST.
    05: Request port group mode ACTIVE and check that nothing was called.
    06: Request port group mode ACTIVE_WITH_WAKEUP_REQUEST.
    07: VP(EthIf.EB.SWS_EthIf_00482,1) Verify that EthSwt_SetSwitchPortMode is called whenever EthIf_SwitchPortGroupRequestMode is called with ACTIVE_WITH_WAKEUP_REQUEST.
    08: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00482</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>377</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1615</internalId></specobject>
    <specobject>
      <id>EthIf_ASR422_SetControllerMode_Wakeup_Repeat_SwitchPortGroup</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR422/TestSpec_Generated.h</sourcefile>
      <sourceline>900</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that EthSwt_SetSwitchPortMode will be recalled with ACTIVE_WITH_WAKEUP_REQUEST when repeat timer expires.
Test Object: Repeat timer for switch port group
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch port group support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller and switch port mode to ACTIVE_WITH_WAKEUP_REQUEST.
    02: Call EthIf_MainFunctionState to timeout the repeat timer without changing the link state.
    03: VP(EthIf.EB.SetModeTimeout.RepeatRequest.EthSwtGetLinkStateDown,1) Verify that EthSwt_SetSwitchPortMode was called because the link wasn't changed to ACTIVE.
    04: Call EthIf_MainFunctionState to change link state to ACTIVE.
    05: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SetModeTimeout.RepeatRequest.EthSwtGetLinkStateDown</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>259</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1616</internalId></specobject>
    <specobject>
      <id>EthIf_ASR422_SetControllerMode_Wakeup_Repeat_Next_SwitchPortGroup</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR422/TestSpec_Generated.h</sourcefile>
      <sourceline>924</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that EthSwt_SetSwitchPortMode will be recalled with ACTIVE_WITH_WAKEUP_REQUEST in the next mainfunction if the first call fails.
Test Object: Repeat timer for switch port group
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch port group support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set return value of EthSwt_SetSwitchPortMode for first two ports to E_NOT_OK.
    02: Set Ethernet interface controller and switch port mode to ACTIVE_WITH_WAKEUP_REQUEST.
    03: Revert return value of EthSwt_SetSwitchPortMode for first two ports to E_OK.
    04: Call EthIf_MainFunctionState to retry informing switch.
    05: VP(EthIf.EB.Repeat.SetSwitchPortMode.HwNotOk,1) Verify that EthSwt_SetSwitchPortMode was called in the next mainfunction.
    06: Call EthIf_MainFunctionState to change link state to ACTIVE.
    07: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Repeat.SetSwitchPortMode.HwNotOk</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>264</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1617</internalId></specobject>
    <specobject>
      <id>EthIf_ASR422_SetControllerMode_Wakeup_Preemption_SwitchPortGroup</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR422/TestSpec_Generated.h</sourcefile>
      <sourceline>950</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that EthIf_SetControllerMode will not pass the call to the EthSwt_SetSwitchPortMode for those ports in switch port group that are locked because EthIf_MainFunctionState processing was preempted. In this case E_OK was set for EthSwt_SetSwitchPortMode in the first EthIf_MainFunctionState call.
Test Object: EthIf_SetControllerMode preemption of EthIf_MainFunctionState
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch port group support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set return value of EthSwt_SetSwitchPortMode for first two ports to E_NOT_OK.
    02: Set Ethernet interface controller and switch port mode to ACTIVE_WITH_WAKEUP_REQUEST.
    03: Revert return value of EthSwt_SetSwitchPortMode for first two ports to E_OK.
    04: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthSwt_SetSwitchPortMode.
    05: Call EthIf_MainFunctionState to retry informing switch.
    06: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthSwt_SetSwitchPortMode was called from EthIf_SetControllerMode for the ports that don't reference a transceiver because others are locked.
    07: Call EthIf_MainFunctionState to change link state to ACTIVE.
    08: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>218</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1618</internalId></specobject>
    <specobject>
      <id>EthIf_ASR422_SetControllerMode_Wakeup_Preemption_SwitchPortGroup_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR422/TestSpec_Generated.h</sourcefile>
      <sourceline>977</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that EthIf_SetControllerMode will not pass the call to the EthSwt_SetSwitchPortMode for those ports in switch port group that are locked because EthIf_MainFunctionState processing was preempted. In this case E_OK was set for EthSwt_SetSwitchPortMode in the second EthIf_MainFunctionState call.
Test Object: EthIf_SetControllerMode preemption of EthIf_MainFunctionState
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch port group support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set return value of EthSwt_SetSwitchPortMode for first two ports to E_NOT_OK.
    02: Set Ethernet interface controller and switch port mode to ACTIVE_WITH_WAKEUP_REQUEST.
    03: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthSwt_SetSwitchPortMode.
    04: Call EthIf_MainFunctionState to retry informing switch.
    05: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthSwt_SetSwitchPortMode was called from EthIf_SetControllerMode for the ports that don't reference a transceiver because others are locked.
    06: Revert return value of EthSwt_SetSwitchPortMode for first two ports to E_OK.
    07: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthSwt_SetSwitchPortMode.
    08: Call EthIf_MainFunctionState to retry informing switch.
    09: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthSwt_SetSwitchPortMode was called from EthIf_SetControllerMode for the ports that don't reference a transceiver because others are locked.
    10: Call EthIf_MainFunctionState to change link state to ACTIVE.
    11: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>218</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1619</internalId></specobject>
    <specobject>
      <id>EthIf_ASR422_SetControllerMode_Wakeup_Preemption_SwitchPortGroup_3</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR422/TestSpec_Generated.h</sourcefile>
      <sourceline>1007</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that EthIf_SetControllerMode will not pass the call to the EthSwt_SetSwitchPortMode for those ports in switch port group that are locked because EthIf_MainFunctionState processing was preempted. In this case E_OK was set for EthSwt_SetSwitchPortMode in the third EthIf_MainFunctionState call.
Test Object: EthIf_SetControllerMode preemption of EthIf_MainFunctionState
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch port group support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set return value of EthSwt_SetSwitchPortMode for first two ports to E_NOT_OK.
    02: Set Ethernet interface controller and switch port mode to ACTIVE_WITH_WAKEUP_REQUEST.
    03: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthSwt_SetSwitchPortMode.
    04: Call EthIf_MainFunctionState to retry informing switch.
    05: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthSwt_SetSwitchPortMode was called from EthIf_SetControllerMode for the ports that don't reference a transceiver because others are locked.
    06: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthSwt_SetSwitchPortMode.
    07: Call EthIf_MainFunctionState to retry informing switch.
    08: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthSwt_SetSwitchPortMode was called from EthIf_SetControllerMode for the ports that don't reference a transceiver because others are locked.
    09: Revert return value of EthSwt_SetSwitchPortMode for first two ports to E_OK.
    10: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthSwt_SetSwitchPortMode.
    11: Call EthIf_MainFunctionState to retry informing switch.
    12: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthSwt_SetSwitchPortMode was called from EthIf_SetControllerMode for the ports that don't reference a transceiver because others are locked.
    13: Call EthIf_MainFunctionState to change link state to ACTIVE.
    14: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>218</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1620</internalId></specobject>
    <specobject>
      <id>EthIf_ASR422_EthIf_TrcvModeIndication_Wodl_UnexpectedMode</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR422/TestSpec_Generated.h</sourcefile>
      <sourceline>1040</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that EthIf does not check the state of transceiver link if transceiver reports mode down when ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST had been requested.
Test Object: Activation with wakeup request
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
    -   Asynchronous mode is configured.
  
Test Execution: 
    01: Set Ethernet interface controller and transceiver mode to ACTIVE_WITH_WAKEUP_REQUEST.
    02: Call EthIf_MainFunctionState.
    03: VP(EthIf.SWS_EthIf_00232, 1) Verify EthTrcv_GetLinkState was not called.
    04: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00232</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>557</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1621</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EthIf_ASR430_SleepIndication_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR430/TestSpec_Generated.h</sourcefile>
      <sourceline>9</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that if development error detection is enabled, the service EthIf_SleepIndication() shall raise the development error ETHIF_E_NOT_INITIALIZED if invoked uninitialized.
Test Object: EthIf_SleepIndication()
Test Precondition: 
    -   EthIf and test setup is not initialized
  
Test Execution: 
    01: Call EthIf_SleepIndication uninitialized.
    02: VP(EthIf.EB.SWS_EthIf_91006.E_NOT_INITIALIZED,1) Verify that development error ETHIF_E_NOT_INITIALIZED was raised.
    03: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_91006.E_NOT_INITIALIZED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>370</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1622</internalId></specobject>
    <specobject>
      <id>EthIf_ASR430_TrcvLinkStateChg</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR430/TestSpec_Generated.h</sourcefile>
      <sourceline>29</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that if an unexpected link down was detected, the EthSM shall immediately be indicated via EthSM_TrcvLinkStateChg without considering EthIfQualifiedUnexpectedLinkDownTime.
Test Object: Wakeup and sleep on data line
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   EthIfQualifiedUnexpectedLinkDownTime is set to value different from 0
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller and transceiver mode to ACTIVE.
    02: Set Ethernet interface controller mode to DOWN.
    03: Call EthIf_MainFunctionState to change link state to DOWN.
    04: VP(EthIf.SWS_EthIf_00499.3,1) Verify that EthSM was immediately informed about link down state.
    05: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00499.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>953</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1623</internalId></specobject>
    <specobject>
      <id>EthIf_ASR430_UnexpectedLinkDownTime_Zero</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR430/TestSpec_Generated.h</sourcefile>
      <sourceline>54</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that if an unexpected link down was detected, EthIf_SleepIndication wasn't called and EthIfQualifiedUnexptecedLinkDownTime is set to value 0 then EthSM_SleepIndication will be called immediately.
Test Object: Wakeup and sleep on data line
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   EthIfQualifiedUnexpectedLinkDownTime is set to value 0
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller and transceiver mode to ACTIVE.
    02: Set Ethernet interface controller mode to DOWN.
    03: Call EthIf_MainFunctionState to change link state to DOWN.
    04: VP(EthIf.SWS_EthIf_00499.2,1) Verify that EthSM was immediately informed with sleep indication because unexpected link down time was set to 0.
    05: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00499.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1624</internalId></specobject>
    <specobject>
      <id>EthIf_ASR430_UnexpectedLinkDownTime_Timer</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR430/TestSpec_Generated.h</sourcefile>
      <sourceline>79</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that if an unexpected link down was detected, EthIf_SleepIndication wasn't called and EthIfQualifiedUnexptecedLinkDownTime is set to value different than 0 then EthSM_SleepIndication will be called after the EthIfQualifiedUnexptecedLinkDownTime expires.
Test Object: Wakeup and sleep on data line
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   EthIfQualifiedUnexpectedLinkDownTime is set to value different from 0
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller and transceiver mode to ACTIVE.
    02: Set Ethernet interface controller and transceiver mode to DOWN without calling EthIf_SleepIndication.
    03: Timeout EthIfQualifiedUnexptecedLinkDownTime timer.
    04: VP(EthIf.SWS_EthIf_00499.1,1) Verify that EthSM was informed after EthIfQualifiedUnexptecedLinkDownTime with sleep indication.
    05: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00499.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>951</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1625</internalId></specobject>
    <specobject>
      <id>EthIf_ASR430_SleepIndication</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR430/TestSpec_Generated.h</sourcefile>
      <sourceline>104</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that if EthIf_SleepIndication is called, it shall immediately pass the call to EthSM_SleepIndication.
Test Object: Wakeup and sleep on data line
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   EthIfQualifiedUnexpectedLinkDownTime is set to value different from 0
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller and transceiver mode to ACTIVE.
    02: VP(EthIf.SWS_EthIf_91006,1) Call EthIf_SleepIndication to inform EthSM_SleepIndication about sleep indication.
    03: VP(EthIf.SWS_EthIf_00497,1) Verify that EthSM was informed about sleep indication.
    04: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91006</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>947</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00497</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>949</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1626</internalId></specobject>
    <specobject>
      <id>EthIf_ASR430_SleepIndication_UnexpectedLinkDownTime_Zero</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR430/TestSpec_Generated.h</sourcefile>
      <sourceline>132</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that if EthIf_SleepIndication is called and link down was detected, the EthSM shall not be indicated via EthSM_SleepIndication after EthIfQualifiedUnexpectedLinkDownTime. In this test, EthIfQualifiedUnexpectedLinkDownTime is set to value 0.
Test Object: Wakeup and sleep on data line
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   EthIfQualifiedUnexpectedLinkDownTime is set to value 0
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller and transceiver mode to ACTIVE.
    02: Call EthIf_SleepIndication to inform EthSM_SleepIndication about sleep indication.
    03: Set Ethernet interface controller and transceiver mode to DOWN without calling EthIf_SleepIndication.
    04: Timeout EthIfQualifiedUnexptecedLinkDownTime timer.
    05: VP(EthIf.SWS_EthIf_00499.4,1) Verify that EthSM was not informed about sleep indication.
    06: Pass a bit more time.
    07: VP(EthIf.SWS_EthIf_00499.4,1) Verify that EthSM was not informed about sleep indication.
    08: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00499.4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>954</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1627</internalId></specobject>
    <specobject>
      <id>EthIf_ASR430_SleepIndication_UnexpectedLinkDownTime_Timer</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR430/TestSpec_Generated.h</sourcefile>
      <sourceline>160</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that if EthIf_SleepIndication is called and link down was detected, the EthSM shall not be indicated via EthSM_SleepIndication after EthIfQualifiedUnexpectedLinkDownTime. In this test, EthIfQualifiedUnexpectedLinkDownTime is seto to value different than 0.
Test Object: Wakeup and sleep on data line
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   EthIfQualifiedUnexpectedLinkDownTime is set to value different from 0
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller and transceiver mode to ACTIVE.
    02: Call EthIf_SleepIndication to inform EthSM_SleepIndication about sleep indication.
    03: Set Ethernet interface controller and transceiver mode to DOWN without calling EthIf_SleepIndication.
    04: Timeout EthIfQualifiedUnexptecedLinkDownTime timer.
    05: VP(EthIf.SWS_EthIf_00499.4,1) Verify that EthSM was not informed about sleep indication.
    06: Pass a bit more time.
    07: VP(EthIf.SWS_EthIf_00499.4,1) Verify that EthSM was not informed about sleep indication.
    08: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00499.4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>954</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1628</internalId></specobject>
    <specobject>
      <id>EthIf_ASR430_SleepIndication_Trcv_Idx_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR430/TestSpec_Generated.h</sourcefile>
      <sourceline>188</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that if development error detection is enabled, the service EthIf_SleepIndication() shall raise the development error ETHIF_E_INV_TRCV_IDX if invoked with an invalid value for TrcvIdx.
Test Object: EthIf_SleepIndication
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   EthIfQualifiedUnexpectedLinkDownTime is set to value different from 0
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller and transceiver mode to ACTIVE.
    02: Call EthIf_SleepIndication with invalid TrcvIdx.
    03: VP(EthIf.EB.SWS_EthIf_91006.INV_TRCV_IDX.1,1) Verify that development error ETHIF_E_INV_TRCV_IDX was raised.
    04: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_91006.INV_TRCV_IDX.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>371</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1629</internalId></specobject>
    <specobject>
      <id>EthIf_ASR430_SleepIndication_Trcv_Idx_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR430/TestSpec_Generated.h</sourcefile>
      <sourceline>212</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that if development error detection is enabled, the service EthIf_SleepIndication() shall raise the development error ETHIF_E_INV_TRCV_IDX if invoked with an TrcvIdx which isn't referencing transceiver with EthTrcvActAsSlavePassiveEnabled set to TRUE.
Test Object: EthIf_SleepIndication
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   EthTrcvActAsSlavePassiveEnabled is set to false
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller and transceiver mode to ACTIVE.
    02: Call EthIf_SleepIndication with TrcvIdx referencing Eth with EthTrcvActAsSlavePassiveEnabled set to false.
    03: VP(EthIf.EB.SWS_EthIf_91006.INV_TRCV_IDX.2,1) Verify that development error ETHIF_E_INV_TRCV_IDX was raised.
    04: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_91006.INV_TRCV_IDX.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>372</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1630</internalId></specobject>
    <specobject>
      <id>EthIf_ASR430_SetControllerMode_Wakeup_Transceiver</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR430/TestSpec_Generated.h</sourcefile>
      <sourceline>236</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that when called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST, EthIf_SetControllerMode shall forward the call to Eth_SetControllerMode with ETH_MODE_ACTIVE if not already indicated. In this test case transceiver is referenced.
Test Object: EthIf_SetControllerMode
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller mode to ACTIVE.
    02: VP(EthIf.SWS_EthIf_00035,1) Verify that Eth_SetControllerMode was called with ETH_MODE_ACTIVE.
    03: VP(EthIf.EB.SWS_EthIf_00479,1) Verify that EthTrcv_SetTransceiverMode was called with ETHTRCV_MODE_ACTIVE_WITH_WAKEUP_REQUEST.
    04: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00035</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>424</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00479</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>374</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1631</internalId></specobject>
    <specobject>
      <id>EthIf_ASR430_SetControllerMode_Wakeup_Second_Transceiver</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR430/TestSpec_Generated.h</sourcefile>
      <sourceline>263</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that when called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST, EthIf_SetControllerMode shall not forward the call to Eth_SetControllerMode and EthSM_CtrlModeIndication with ETH_MODE_ACTIVE if already indicated and that it will always forward the call to EthTrcv_SetTransceiverMode with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST. In this test case transceiver is referenced.
Test Object: EthIf_SetControllerMode
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller mode to ACTIVE or ACTIVE_WITH_WAKEUP_REQUEST and indicate it to Eth.
    02: Request Ethernet interface controller mode to ACTIVE or ACTIVE_WITH_WAKEUP_REQUEST.
    03: VP(EthIf.SWS_EthIf_00035,1) Verify that Eth_SetControllerMode and EthSM_CtrlModeIndication were not called.
    04: Request Ethernet interface controller mode to ACTIVE.
    05: VP(EthIf.SWS_EthIf_00035,1) Verify that Eth_SetControllerMode and EthSM_CtrlModeIndication were not called.
    06: Request Ethernet interface controller mode to ACTIVE_WITH_WAKEUP_REQUEST.
    07: VP(EthIf.EB.SWS_EthIf_00479,1) Verify that EthTrcv_SetTransceiverMode is called whenever EthIf_SetControllerMode is called with ACTIVE_WITH_WAKEUP_REQUEST.
    08: VP(EthIf.SWS_EthIf_00035,1) Verify that Eth_SetControllerMode and EthSM_CtrlModeIndication were not called.
    09: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00035</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>424</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00479</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>374</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1632</internalId></specobject>
    <specobject>
      <id>EthIf_ASR430_SetControllerMode_Wakeup_Second_Transceiver_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR430/TestSpec_Generated.h</sourcefile>
      <sourceline>295</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that when called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST, EthIf_SetControllerMode shall forward the call to EthTrcv_SetTransceiverMode with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST. In this case EthIf_CtrlModeIndication was called for the first time after calling EthIf_SetControllerMode twice. In this test case transceiver is referenced.
Test Object: EthIf_SetControllerMode
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Request Ethernet interface controller mode to ACTIVE or ACTIVE_WITH_WAKEUP_REQUEST and indicate it to Eth.
    02: Request Ethernet interface controller mode to ACTIVE_WITH_WAKEUP_REQUEST.
    03: Receive callout to set Ethernet interface controller mode to ACTIVE.
    04: VP(EthIf.EB.SWS_EthIf_00479,1)
        VP(EthIf.EB.EthTrcv_SetTransceiverMode.Async.CtrlModeIndication,1) Verify that EthTrcv_SetTransceiverMode is called whenever EthIf_SetControllerMode is called with ACTIVE_WITH_WAKEUP_REQUEST.
    05: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00479</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>374</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.EthTrcv_SetTransceiverMode.Async.CtrlModeIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>380</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1633</internalId></specobject>
    <specobject>
      <id>EthIf_ASR430_SetControllerMode_Wakeup_Activate_Transceiver</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR430/TestSpec_Generated.h</sourcefile>
      <sourceline>324</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that transceiver link was correctly changed from DOWN to ACIVE when EthIf_SetControllerMode was called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST and transceiver was referenced.
Test Object: Activation with wakeup request
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller and transceiver mode to ACTIVE_WITH_WAKEUP_REQUEST.
    02: Call EthIf_MainFunctionState to change link state to ACTIVE.
    03: VP(EthIf.ASR43.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange,1) Verify that the link was changed to ACTIVE.
    04: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>130</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1634</internalId></specobject>
    <specobject>
      <id>EthIf_ASR430_SetControllerMode_Wakeup_Deactivate_Transceiver</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR430/TestSpec_Generated.h</sourcefile>
      <sourceline>347</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that transceiver link was correctly changed from ACIVE to DOWN when EthIf_SetControllerMode was activated with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST and transceiver was referenced.
Test Object: Deactivation with wakeup request
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
    -   Activate link state of the transceiver
  
Test Execution: 
    01: Set Ethernet interface controller and transceiver mode to DOWN.
    02: Call EthIf_MainFunctionState to change link state to DOWN.
    03: VP(EthIf.ASR43.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange,1) Verify that the link was changed to DOWN.
    04: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>130</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1635</internalId></specobject>
    <specobject>
      <id>EthIf_ASR430_CtrlModeIndication_Wakeup_Mix_Transceiver</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR430/TestSpec_Generated.h</sourcefile>
      <sourceline>371</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that when called with ETH_MODE_ACTIVE or ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST, EthIf_CtrlModeIndication shall forward the call to EthTrcv_SetTransceiverMode with initially requested state regardless if EthIf_SetControllerMode already informed EthTrcv_SetTransceiverMode about ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST.
Test Object: EthIf_CtrlModeIndication
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller mode to ACTIVE or ACTIVE_WITH_WAKEUP_REQUEST and indicate it to Eth.
    02: VP(EthIf.EB.SWS_EthIf_00479,1) Verify that EthTrcv_SetTransceiverMode is called is called with initially requested state.
    03: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00479</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>374</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1636</internalId></specobject>
    <specobject>
      <id>EthIf_ASR430_SetControllerMode_Wakeup_Repeat_Transceiver</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR430/TestSpec_Generated.h</sourcefile>
      <sourceline>393</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that EthTrcv_SetTransceiverMode will be recalled with ACTIVE_WITH_WAKEUP_REQUEST when repeat timer expires.
Test Object: Repeat timer for transceiver
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller and transceiver mode to ACTIVE_WITH_WAKEUP_REQUEST.
    02: Call EthIf_MainFunctionState to timeout the repeat timer without changing the link state.
    03: VP(EthIf.EB.SetModeTimeout.RepeatRequest.ReadFail,1) Verify that EthTrcv_SetTransceiverMode was called because the link wasn't changed to ACTIVE.
    04: Call EthIf_MainFunctionState to change link state to ACTIVE.
    05: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SetModeTimeout.RepeatRequest.ReadFail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>260</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1637</internalId></specobject>
    <specobject>
      <id>EthIf_ASR430_SetControllerMode_Wakeup_Repeat_Next_Transceiver</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR430/TestSpec_Generated.h</sourcefile>
      <sourceline>417</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that EthTrcv_SetTransceiverMode will be recalled with ACTIVE_WITH_WAKEUP_REQUEST in the next mainfunction if the first call fails.
Test Object: Repeat timer for transceiver
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set return value of EthTrcv_SetTransceiverMode to E_NOT_OK.
    02: Set Ethernet interface controller and transceiver mode to ACTIVE_WITH_WAKEUP_REQUEST.
    03: Revert return value of EthTrcv_SetTransceiverMode to E_OK.
    04: Call EthIf_MainFunctionState to retry informing transceiver.
    05: VP(EthIf.EB.SetModeTimeout.RepeatRequest.ReadFail,1) Verify that EthTrcv_SetTransceiverMode was called in the next mainfunction.
    06: Call EthIf_MainFunctionState to change link state to ACTIVE.
    07: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SetModeTimeout.RepeatRequest.ReadFail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>260</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1638</internalId></specobject>
    <specobject>
      <id>EthIf_ASR430_SetControllerMode_Wakeup_Preemption_Transceiver</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR430/TestSpec_Generated.h</sourcefile>
      <sourceline>443</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that EthIf_SetControllerMode will not pass the call to the EthTrcv_SetTransceiverMode for locked transceiver because EthIf_MainFunctionState processing was preempted. In this case E_OK was set for EthTrcv_SetTransceiverMode in the first EthIf_MainFunctionState call.
Test Object: EthIf_SetControllerMode preemption of EthIf_MainFunctionState
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set return value of EthTrcv_SetTransceiverMode to E_NOT_OK.
    02: Set Ethernet interface controller and switch port mode to ACTIVE_WITH_WAKEUP_REQUEST.
    03: Set return value of EthTrcv_SetTransceiverMode to E_OK.
    04: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthTrcv_SetTransceiverMode.
    05: Call EthIf_MainFunctionState to retry informing transceiver.
    06: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthTrcv_SetTransceiverMode was not called from EthIf_SetControllerMode because the transceiver was already locked.
    07: Call EthIf_MainFunctionState to change link state to ACTIVE.
    08: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>218</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1639</internalId></specobject>
    <specobject>
      <id>EthIf_ASR430_SetControllerMode_Wakeup_Preemption_Transceiver_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR430/TestSpec_Generated.h</sourcefile>
      <sourceline>470</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that EthIf_SetControllerMode will not pass the call to the EthTrcv_SetTransceiverMode for locked transceiver because EthIf_MainFunctionState processing was preempted. In this case E_OK was set for EthTrcv_SetTransceiverMode in the second EthIf_MainFunctionState call.
Test Object: EthIf_SetControllerMode preemption of EthIf_MainFunctionState
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set return value of EthTrcv_SetTransceiverMode to E_NOT_OK.
    02: Set Ethernet interface controller and switch port mode to ACTIVE_WITH_WAKEUP_REQUEST.
    03: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthTrcv_SetTransceiverMode.
    04: Call EthIf_MainFunctionState to retry informing transceiver.
    05: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthTrcv_SetTransceiverMode was not called from EthIf_SetControllerMode because the transceiver was already locked.
    06: Set return value of EthTrcv_SetTransceiverMode to E_OK.
    07: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthTrcv_SetTransceiverMode.
    08: Call EthIf_MainFunctionState to retry informing transceiver.
    09: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthTrcv_SetTransceiverMode was not called from EthIf_SetControllerMode because the transceiver was already locked.
    10: Call EthIf_MainFunctionState to change link state to ACTIVE.
    11: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>218</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1640</internalId></specobject>
    <specobject>
      <id>EthIf_ASR430_SetControllerMode_Wakeup_Preemption_Transceiver_3</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR430/TestSpec_Generated.h</sourcefile>
      <sourceline>500</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that EthIf_SetControllerMode will not pass the call to the EthTrcv_SetTransceiverMode for locked transceiver because EthIf_MainFunctionState processing was preempted. In this case E_OK was set for EthTrcv_SetTransceiverMode in the third EthIf_MainFunctionState call.
Test Object: EthIf_SetControllerMode preemption of EthIf_MainFunctionState
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set return value of EthTrcv_SetTransceiverMode to E_NOT_OK.
    02: Set Ethernet interface controller and switch port mode to ACTIVE_WITH_WAKEUP_REQUEST.
    03: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthTrcv_SetTransceiverMode.
    04: Call EthIf_MainFunctionState to retry informing transceiver.
    05: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthTrcv_SetTransceiverMode was not called from EthIf_SetControllerMode because the transceiver was already locked.
    06: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthTrcv_SetTransceiverMode.
    07: Call EthIf_MainFunctionState to retry informing transceiver.
    08: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthTrcv_SetTransceiverMode was not called from EthIf_SetControllerMode because the transceiver was already locked.
    09: Set return value of EthTrcv_SetTransceiverMode to E_OK.
    10: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthTrcv_SetTransceiverMode.
    11: Call EthIf_MainFunctionState to retry informing transceiver.
    12: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthTrcv_SetTransceiverMode was not called from EthIf_SetControllerMode because the transceiver was already locked.
    13: Call EthIf_MainFunctionState to change link state to ACTIVE.
    14: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>218</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1641</internalId></specobject>
    <specobject>
      <id>EthIf_ASR430_SetControllerMode_Wakeup_Preemption_Transceiver_4</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR430/TestSpec_Generated.h</sourcefile>
      <sourceline>533</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that EthIf_SetControllerMode will not pass the call to the EthTrcv_SetTransceiverMode for locked transceiver because EthIf_MainFunctionState processing was preempted. In this case E_OK was set for EthTrcv_SetTransceiverMode between the second EthIf_MainFunctionState call and EthIf_SetControllerMode.
Test Object: EthIf_SetControllerMode preemption of EthIf_MainFunctionState
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set return value of EthTrcv_SetTransceiverMode to E_NOT_OK.
    02: Set Ethernet interface controller and switch port mode to ACTIVE_WITH_WAKEUP_REQUEST.
    03: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthSwt_SetSwitchPortMode.
    04: Call EthIf_MainFunctionState to retry informing transceiver.
    05: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthTrcv_SetTransceiverMode was not called from EthIf_SetControllerMode because the transceiver was already locked.
    06: Set return value of EthTrcv_SetTransceiverMode to E_OK.
    07: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthSwt_SetSwitchPortMode.
    08: Call EthIf_MainFunctionState to retry informing transceiver.
    09: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthTrcv_SetTransceiverMode was not called from EthIf_SetControllerMode because the transceiver was already locked.
    10: Call EthIf_SetControllerMode to inform transceiver.
    11: Call EthIf_MainFunctionState to change link state to ACTIVE.
    12: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>218</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1642</internalId></specobject>
    <specobject>
      <id>EthIf_ASR430_SetControllerMode_Wakeup_Switch</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR430/TestSpec_Generated.h</sourcefile>
      <sourceline>564</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that when called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST, EthIf_SetControllerMode shall forward the call to Eth_SetControllerMode with ETH_MODE_ACTIVE if not already indicated. In this test case switch is referenced.
Test Object: EthIf_SetControllerMode
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller mode to ACTIVE by calling with ACTIVE_WITH_WAKEUP_REQUEST.
    02: VP(EthIf.SWS_EthIf_00035,1) Verify that Eth_SetControllerMode was called with ETH_MODE_ACTIVE.
    03: VP(EthIf.EB.SWS_EthIf_00480,1) Verify that EthSwt_SetSwitchPortMode was called with ETHTRCV_MODE_ACTIVE_WITH_WAKEUP_REQUEST for every port in the given switch.
    04: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00035</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>424</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00480</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>375</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1643</internalId></specobject>
    <specobject>
      <id>EthIf_ASR430_SetControllerMode_Wakeup_Second_Switch</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR430/TestSpec_Generated.h</sourcefile>
      <sourceline>591</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that when called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST, EthIf_SetControllerMode shall not forward the call to Eth_SetControllerMode and EthSM_CtrlModeIndication with ETH_MODE_ACTIVE if already indicated and that it will always forward the call to EthSwt_SetSwitchPortMode with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST. In this test case switch is referenced.
Test Object: EthIf_SetControllerMode
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller mode to ACTIVE or ACTIVE_WITH_WAKEUP_REQUEST and indicate it to Eth.
    02: Request Ethernet interface controller mode to ACTIVE or ACTIVE_WITH_WAKEUP_REQUEST.
    03: VP(EthIf.SWS_EthIf_00035,1) Verify that Eth_SetControllerMode and EthSM_CtrlModeIndication were not called.
    04: Request Ethernet interface controller mode to ACTIVE.
    05: VP(EthIf.SWS_EthIf_00035,1) Verify that Eth_SetControllerMode and EthSM_CtrlModeIndication were not called.
    06: Request Ethernet interface controller mode to ACTIVE_WITH_WAKEUP_REQUEST.
    07: VP(EthIf.EB.SWS_EthIf_00480,1) Verify that EthSwt_SetSwitchPortMode is called whenever EthIf_SetControllerMode is called with ACTIVE_WITH_WAKEUP_REQUEST.
    08: VP(EthIf.SWS_EthIf_00035,1) Verify that Eth_SetControllerMode and EthSM_CtrlModeIndication were not called.
    09: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00035</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>424</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00480</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>375</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1644</internalId></specobject>
    <specobject>
      <id>EthIf_ASR430_SetControllerMode_Wakeup_Second_Switch_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR430/TestSpec_Generated.h</sourcefile>
      <sourceline>623</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that when called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST, EthIf_SetControllerMode shall forward the call to EthSwt_SetSwitchPortMode with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST. In this case EthIf_CtrlModeIndication was called for the first time after calling EthIf_SetControllerMode twice. In this test case switch is referenced.
Test Object: EthIf_SetControllerMode
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Request Ethernet interface controller mode to ACTIVE or ACTIVE_WITH_WAKEUP_REQUEST and indicate it to Eth.
    02: Request Ethernet interface controller mode to ACTIVE_WITH_WAKEUP_REQUEST.
    03: Receive callout to set Ethernet interface controller mode to ACTIVE.
    04: VP(EthIf.EB.SWS_EthIf_00480,1)
        VP(EthIf.EB.EthSwt_SetSwitchPortMode.Async.CtrlModeIndication,1) Verify that EthSwt_SetSwitchPortMode is called whenever EthIf_SetControllerMode is called with ACTIVE_WITH_WAKEUP_REQUEST.
    05: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00480</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>375</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.EthSwt_SetSwitchPortMode.Async.CtrlModeIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>381</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1645</internalId></specobject>
    <specobject>
      <id>EthIf_ASR430_SetControllerMode_Wakeup_Second_Switch_PortGroup_NoControl</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR430/TestSpec_Generated.h</sourcefile>
      <sourceline>652</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that when called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST when last requested communication mode is ETH_MODE_ACTIVE or ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST, EthIf_SetControllerMode shall not forward the call to EthSwt_SetSwitchPortMode.
Test Object: EthIf_SetControllerMode
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   EthIf controller is not in control of port groups.
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller mode to ACTIVE or ACTIVE_WITH_WAKEUP_REQUEST and indicate it to Eth.
    02: Request Ethernet interface controller mode to ACTIVE.
    03: VP(EthIf.EB.SWS_EthIf_00479_00481,1) Verify that EthSwt_SetSwitchPortMode is not called.
    04: Request Ethernet interface controller mode to ACTIVE_WITH_WAKEUP_REQUEST.
    05: VP(EthIf.EB.SWS_EthIf_00479_00481,1) Verify that EthSwt_SetSwitchPortMode is not called.
    06: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00479_00481</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>378</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1646</internalId></specobject>
    <specobject>
      <id>EthIf_ASR430_SetControllerMode_Wakeup_Activate_Switch</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR430/TestSpec_Generated.h</sourcefile>
      <sourceline>677</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that transceiver link was correctly changed from DOWN to ACIVE when EthIf_SetControllerMode was called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST and switch was referenced.
Test Object: Activation with wakeup request
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller and transceiver mode to ACTIVE_WITH_WAKEUP_REQUEST.
    02: Call EthIf_MainFunctionState to change link state to ACTIVE.
    03: VP(EthIf.SWS_EthIf_00260,1) Verify that the link was changed to ACTIVE.
    04: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00260</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>613</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1647</internalId></specobject>
    <specobject>
      <id>EthIf_ASR430_SetControllerMode_Wakeup_Deactivate_Switch</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR430/TestSpec_Generated.h</sourcefile>
      <sourceline>700</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that transceiver link was correctly changed from ACIVE to DOWN when EthIf_SetControllerMode was activated with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST and switch was referenced.
Test Object: Deactivation with wakeup request
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
    -   Activate link state of the transceiver
  
Test Execution: 
    01: Set Ethernet interface controller and transceiver mode to DOWN.
    02: Call EthIf_MainFunctionState to change link state to DOWN.
    03: VP(EthIf.SWS_EthIf_00260,1) Verify that the link was changed to DOWN.
    04: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00260</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>613</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1648</internalId></specobject>
    <specobject>
      <id>EthIf_ASR430_SetControllerMode_Wakeup_Repeat_Switch</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR430/TestSpec_Generated.h</sourcefile>
      <sourceline>724</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that EthSwt_SetSwitchPortMode will be recalled with ACTIVE_WITH_WAKEUP_REQUEST when repeat timer expires.
Test Object: Repeat timer for switch
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller and switch port mode to ACTIVE_WITH_WAKEUP_REQUEST.
    02: Call EthIf_MainFunctionState to timeout the repeat timer without changing the link state.
    03: VP(EthIf.EB.SetModeTimeout.RepeatRequest.EthSwtGetLinkStateDown,1) Verify that EthSwt_SetSwitchPortMode was called because the link wasn't changed to ACTIVE.
    04: Call EthIf_MainFunctionState to change link state to ACTIVE.
    05: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SetModeTimeout.RepeatRequest.EthSwtGetLinkStateDown</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>259</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1649</internalId></specobject>
    <specobject>
      <id>EthIf_ASR430_SetControllerMode_Wakeup_Repeat_Next_Switch</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR430/TestSpec_Generated.h</sourcefile>
      <sourceline>748</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that EthSwt_SetSwitchPortMode will be recalled with ACTIVE_WITH_WAKEUP_REQUEST in the next mainfunction if the first call fails.
Test Object: Repeat timer for switch
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set return value of EthSwt_SetSwitchPortMode for first two ports to E_NOT_OK.
    02: Set Ethernet interface controller and switch port mode to ACTIVE_WITH_WAKEUP_REQUEST.
    03: Revert return value of EthSwt_SetSwitchPortMode for first two ports to E_OK.
    04: Call EthIf_MainFunctionState to retry informing switch.
    05: VP(EthIf.EB.Repeat.SetSwitchPortMode.HwNotOk,1) Verify that EthSwt_SetSwitchPortMode was called in the next mainfunction.
    06: Call EthIf_MainFunctionState to change link state to ACTIVE.
    07: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Repeat.SetSwitchPortMode.HwNotOk</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>264</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1650</internalId></specobject>
    <specobject>
      <id>EthIf_ASR430_SetControllerMode_Wakeup_Preemption_Switch</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR430/TestSpec_Generated.h</sourcefile>
      <sourceline>774</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that EthIf_SetControllerMode will not pass the call to the EthSwt_SetSwitchPortMode for those ports in switch that are locked because EthIf_MainFunctionState processing was preempted. In this case E_OK was set for EthSwt_SetSwitchPortMode in the first EthIf_MainFunctionState call.
Test Object: EthIf_SetControllerMode preemption of EthIf_MainFunctionState
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set return value of EthSwt_SetSwitchPortMode for first two ports to E_NOT_OK.
    02: Set Ethernet interface controller and switch port mode to ACTIVE_WITH_WAKEUP_REQUEST.
    03: Revert return value of EthSwt_SetSwitchPortMode for first two ports to E_OK.
    04: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthSwt_SetSwitchPortMode.
    05: Call EthIf_MainFunctionState to retry informing switch.
    06: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthSwt_SetSwitchPortMode was called from EthIf_SetControllerMode for the ports that don't reference a transceiver because others are locked.
    07: Call EthIf_MainFunctionState to change link state to ACTIVE.
    08: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>218</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1651</internalId></specobject>
    <specobject>
      <id>EthIf_ASR430_SetControllerMode_Wakeup_Preemption_Switch_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR430/TestSpec_Generated.h</sourcefile>
      <sourceline>801</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that EthIf_SetControllerMode will not pass the call to the EthSwt_SetSwitchPortMode for those ports in switch that are locked because EthIf_MainFunctionState processing was preempted. In this case E_OK was set for EthSwt_SetSwitchPortMode in the second EthIf_MainFunctionState call.
Test Object: EthIf_SetControllerMode preemption of EthIf_MainFunctionState
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set return value of EthSwt_SetSwitchPortMode for first two ports to E_NOT_OK.
    02: Set Ethernet interface controller and switch port mode to ACTIVE_WITH_WAKEUP_REQUEST.
    03: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthSwt_SetSwitchPortMode.
    04: Call EthIf_MainFunctionState to retry informing switch.
    05: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthSwt_SetSwitchPortMode was called from EthIf_SetControllerMode for the ports that don't reference a transceiver because others are locked.
    06: Revert return value of EthSwt_SetSwitchPortMode for first two ports to E_OK.
    07: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthSwt_SetSwitchPortMode.
    08: Call EthIf_MainFunctionState to retry informing switch.
    09: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthSwt_SetSwitchPortMode was called from EthIf_SetControllerMode for the ports that don't reference a transceiver because others are locked.
    10: Call EthIf_MainFunctionState to change link state to ACTIVE.
    11: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>218</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1652</internalId></specobject>
    <specobject>
      <id>EthIf_ASR430_SetControllerMode_Wakeup_Preemption_Switch_3</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR430/TestSpec_Generated.h</sourcefile>
      <sourceline>831</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that EthIf_SetControllerMode will not pass the call to the EthSwt_SetSwitchPortMode for those ports in switch that are locked because EthIf_MainFunctionState processing was preempted. In this case E_OK was set for EthSwt_SetSwitchPortMode in the third EthIf_MainFunctionState call.
Test Object: EthIf_SetControllerMode preemption of EthIf_MainFunctionState
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set return value of EthSwt_SetSwitchPortMode for first two ports to E_NOT_OK.
    02: Set Ethernet interface controller and switch port mode to ACTIVE_WITH_WAKEUP_REQUEST.
    03: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthSwt_SetSwitchPortMode.
    04: Call EthIf_MainFunctionState to retry informing switch.
    05: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthSwt_SetSwitchPortMode was called from EthIf_SetControllerMode for the ports that don't reference a transceiver because others are locked.
    06: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthSwt_SetSwitchPortMode.
    07: Call EthIf_MainFunctionState to retry informing switch.
    08: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthSwt_SetSwitchPortMode was called from EthIf_SetControllerMode for the ports that don't reference a transceiver because others are locked.
    09: Revert return value of EthSwt_SetSwitchPortMode for first two ports to E_OK.
    10: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthSwt_SetSwitchPortMode.
    11: Call EthIf_MainFunctionState to retry informing switch.
    12: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthSwt_SetSwitchPortMode was called from EthIf_SetControllerMode for the ports that don't reference a transceiver because others are locked.
    13: Call EthIf_MainFunctionState to change link state to ACTIVE.
    14: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>218</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1653</internalId></specobject>
    <specobject>
      <id>EthIf_ASR430_SetControllerMode_Wakeup_Preemption_Switch_4</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR430/TestSpec_Generated.h</sourcefile>
      <sourceline>864</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that EthIf_MainFunctionState will not pass the call to the EthSwt_SetSwitchPortMode for those ports in switch that are locked and for which wake up on data line is pending because EthIf_SetControllerMode processing was preempted.
Test Object: EthIf_MainFunctionState preemption of EthIf_SetControllerMode
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set return value of EthSwt_SetSwitchPortMode for first two ports to E_NOT_OK.
    02: Request Ethernet interface controller with MODE_ACTIVE
    03: Revert return value of EthSwt_SetSwitchPortMode for first two ports to E_OK.
    04: Call EthIf_MainFunctionState and preempt it with a EthIf_SetControllerMode(ACTIVE_WITH_WAKEUP_REQUEST) so a wake up is pending for the blocked ports.
    05: Call EthIf_SetControllerMode and preempt it with EthIf_MainFunctionState(ACTIVE_WITH_WAKEUP_REQUEST) call.
    06: VP(EthIf.EB.MIIExtension.SetSwitchPortMode.CheckMiiAccessFlag,1) Verify EthSwt_SetSwitchPortMode was called once for each port by EthIf_SetControllerMode and EthIf_MainFunctionState was unable to.
    07: Sanity check - Call EthIf_MainFunctionState and verify EthSwt_SetSwitchPortMode was not called.
    08: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.SetSwitchPortMode.CheckMiiAccessFlag</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>217</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1654</internalId></specobject>
    <specobject>
      <id>EthIf_ASR430_SetControllerMode_Wakeup_NoRef</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR430/TestSpec_Generated.h</sourcefile>
      <sourceline>891</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that when called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST, EthIf_SetControllerMode shall forward the call to Eth_SetControllerMode with ETH_MODE_ACTIVE if not already indicated. In this test case there is no reference to neither transceiver, switch nor port group.
Test Object: EthIf_SetControllerMode
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   There is no reference to neither transceiver, switch nor port group
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller mode to ACTIVE.
    02: VP(EthIf.SWS_EthIf_00035,1) Verify that Eth_SetControllerMode was called with ETH_MODE_ACTIVE.
    03: VP(EthIf.EB.SWS_EthIf_00479_00481,1) Verify that set mode was not called because there is no reference to neither the transceiver, switch nor port group.
    04: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00035</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>424</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00479_00481</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>378</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1655</internalId></specobject>
    <specobject>
      <id>EthIf_ASR430_SetControllerMode_Wakeup_Second_NoRef</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR430/TestSpec_Generated.h</sourcefile>
      <sourceline>918</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that when called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST, EthIf_SetControllerMode shall not forward the call to Eth_SetControllerMode and EthSM_CtrlModeIndication with ETH_MODE_ACTIVE if already indicated. In this test case there is no reference to neither transceiver, switch nor port group.
Test Object: EthIf_SetControllerMode
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   There is no reference to neither transceiver, switch nor port group
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller mode to ACTIVE or ACTIVE_WITH_WAKEUP_REQUEST and indicate it to Eth.
    02: Request Ethernet interface controller mode to ACTIVE or ACTIVE_WITH_WAKEUP_REQUEST.
    03: VP(EthIf.SWS_EthIf_00035,1) Verify that Eth_SetControllerMode and EthSM_CtrlModeIndication were not called.
    04: Request Ethernet interface controller mode to ACTIVE.
    05: VP(EthIf.SWS_EthIf_00035,1) Verify that EthSM_CtrlModeIndication was not called.
    06: Request Ethernet interface controller mode to ACTIVE_WITH_WAKEUP_REQUEST.
    07: VP(EthIf.SWS_EthIf_00035,1) Verify that EthSM_CtrlModeIndication was not called.
    08: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00035</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>424</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1656</internalId></specobject>
    <specobject>
      <id>EthIf_ASR430_SetControllerMode_Wakeup_Activate_NoRef</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR430/TestSpec_Generated.h</sourcefile>
      <sourceline>945</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that transceiver link was correctly changed from DOWN to ACIVE when EthIf_SetControllerMode was called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST and there is no reference to neither transceiver, switch nor port group.
Test Object: Activation with wakeup request
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   There is no reference to neither transceiver, switch nor port group
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller and transceiver mode to ACTIVE_WITH_WAKEUP_REQUEST.
    02: Call EthIf_MainFunctionState to change link state to ACTIVE.
    03: VP(EthIf.EB.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange.NoRef,1) Verify that the link was changed to ACTIVE.
    04: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange.NoRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>379</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1657</internalId></specobject>
    <specobject>
      <id>EthIf_ASR430_SetControllerMode_Wakeup_Deactivate_NoRef</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR430/TestSpec_Generated.h</sourcefile>
      <sourceline>968</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that transceiver link was correctly changed from ACIVE to DOWN when EthIf_SetControllerMode was activated with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST and there is no reference to neither transceiver, switch nor port group.
Test Object: Deactivation with wakeup request
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   There is no reference to neither transceiver, switch nor port group
    -   EthIf and test setup is initialized
    -   Activate link state of the transceiver
  
Test Execution: 
    01: Set Ethernet interface controller and transceiver mode to DOWN.
    02: Call EthIf_MainFunctionState to change link state to DOWN.
    03: VP(EthIf.ASR43.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange,1) Verify that the link was changed to DOWN.
    04: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>130</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1658</internalId></specobject>
    <specobject>
      <id>EthIf_ASR430_SetControllerMode_Wakeup_SwitchPortGroup</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR430/TestSpec_Generated.h</sourcefile>
      <sourceline>992</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that when called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST, EthIf_SetControllerMode shall forward the call to Eth_SetControllerMode with ETH_MODE_ACTIVE if not already indicated. In this test case switch port group is referenced.
Test Object: EthIf_SetControllerMode
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch port group support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller mode to ACTIVE.
    02: VP(EthIf.SWS_EthIf_00035,1) Verify that Eth_SetControllerMode was called with ETH_MODE_ACTIVE.
    03: VP(EthIf.EB.SWS_EthIf_00481,1) Verify that EthSwt_SetSwitchPortMode was called with ETHTRCV_MODE_ACTIVE_WITH_WAKEUP_REQUEST for every port in the given port group.
    04: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00035</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>424</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00481</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>376</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1659</internalId></specobject>
    <specobject>
      <id>EthIf_ASR430_SetControllerMode_Wakeup_Second_SwitchPortGroup</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR430/TestSpec_Generated.h</sourcefile>
      <sourceline>1019</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that when called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST, EthIf_SetControllerMode shall not forward the call to Eth_SetControllerMode and EthSM_CtrlModeIndication with ETH_MODE_ACTIVE if already indicated and that it will always forward the call to EthSwt_SetSwitchPortMode with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST. In this test case switch port group is referenced.
Test Object: EthIf_SetControllerMode
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch port group support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller mode to ACTIVE or ACTIVE_WITH_WAKEUP_REQUEST and indicate it to Eth.
    02: Request Ethernet interface controller mode to ACTIVE or ACTIVE_WITH_WAKEUP_REQUEST.
    03: VP(EthIf.SWS_EthIf_00035,1) Verify that Eth_SetControllerMode and EthSM_CtrlModeIndication were not called.
    04: Request Ethernet interface controller mode to ACTIVE.
    05: VP(EthIf.SWS_EthIf_00035,1) Verify that Eth_SetControllerMode and EthSM_CtrlModeIndication were not called.
    06: Request Ethernet interface controller mode to ACTIVE_WITH_WAKEUP_REQUEST.
    07: VP(EthIf.EB.SWS_EthIf_00481,1) Verify that EthSwt_SetSwitchPortMode is called whenever EthIf_SetControllerMode is called with ACTIVE_WITH_WAKEUP_REQUEST.
    08: VP(EthIf.SWS_EthIf_00035,1) Verify that Eth_SetControllerMode and EthSM_CtrlModeIndication were not called.
    09: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00035</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>424</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00481</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>376</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1660</internalId></specobject>
    <specobject>
      <id>EthIf_ASR430_SetControllerMode_Wakeup_Second_SwitchPortGroup_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR430/TestSpec_Generated.h</sourcefile>
      <sourceline>1051</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that when called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST, EthIf_SetControllerMode shall forward the call to EthSwt_SetSwitchPortMode with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST. In this case EthIf_CtrlModeIndication was called for the first time after calling EthIf_SetControllerMode twice. In this test case switch port group is referenced.
Test Object: EthIf_SetControllerMode
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch port group support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Request Ethernet interface controller mode to ACTIVE or ACTIVE_WITH_WAKEUP_REQUEST and indicate it to Eth.
    02: Request Ethernet interface controller mode to ACTIVE_WITH_WAKEUP_REQUEST.
    03: Receive callout to set Ethernet interface controller mode to ACTIVE.
    04: VP(EthIf.EB.SWS_EthIf_00481,1)
        VP(EthIf.EB.EthSwt_SetSwitchPortMode.Async.CtrlModeIndication,1) Verify that EthSwt_SetSwitchPortMode is called whenever EthIf_SetControllerMode is called with ACTIVE_WITH_WAKEUP_REQUEST.
    05: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00481</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>376</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.EthSwt_SetSwitchPortMode.Async.CtrlModeIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>381</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1661</internalId></specobject>
    <specobject>
      <id>EthIf_ASR430_SetControllerMode_Wakeup_Activate_SwitchPortGroup</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR430/TestSpec_Generated.h</sourcefile>
      <sourceline>1080</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that transceiver link was correctly changed from DOWN to ACIVE when EthIf_SetControllerMode was called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST and switch port group was referenced.
Test Object: Activation with wakeup request
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch port group support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller and transceiver mode to ACTIVE_WITH_WAKEUP_REQUEST.
    02: Call EthIf_MainFunctionState to change link state to ACTIVE.
    03: VP(EthIf.SWS_EthIf_00262,1) Verify that the link was changed to ACTIVE.
    04: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00262</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>615</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1662</internalId></specobject>
    <specobject>
      <id>EthIf_ASR430_SetControllerMode_Wakeup_Deactivate_SwitchPortGroup</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR430/TestSpec_Generated.h</sourcefile>
      <sourceline>1103</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that transceiver link was correctly changed from ACIVE to DOWN when EthIf_SetControllerMode was activated with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST and switch port group was referenced.
Test Object: Deactivation with wakeup request
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch port group support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
    -   Activate link state of the transceiver
  
Test Execution: 
    01: Set Ethernet interface controller and transceiver mode to DOWN.
    02: Call EthIf_MainFunctionState to change link state to DOWN.
    03: VP(EthIf.SWS_EthIf_00262,1) Verify that the link was changed to DOWN.
    04: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00262</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>615</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1663</internalId></specobject>
    <specobject>
      <id>EthIf_ASR430_SwitchPortGroupRequestMode_Wakeup_Second_SwitchPortGroup</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR430/TestSpec_Generated.h</sourcefile>
      <sourceline>1127</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that when called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST, EthIf_SwitchPortGroupRequestMode shall always forward the call to EthSwt_SetSwitchPortMode.
Test Object: EthIf_SwitchPortGroupRequestMode
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch port group support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller mode to ACTIVE or ACTIVE_WITH_WAKEUP_REQUEST and indicate it to Eth.
    02: Request port group mode ACTIVE or ACTIVE_WITH_WAKEUP_REQUEST and indicate it to EthSwt.
    03: Request port group mode ACTIVE or ACTIVE_WITH_WAKEUP_REQUEST.
    04: VP(EthIf.EB.SWS_EthIf_00482,1) Verify that EthSwt_SetSwitchPortMode was called only for ACTIVE_WITH_WAKEUP_REQUEST.
    05: Request port group mode ACTIVE and check that nothing was called.
    06: Request port group mode ACTIVE_WITH_WAKEUP_REQUEST.
    07: VP(EthIf.EB.SWS_EthIf_00482,1) Verify that EthSwt_SetSwitchPortMode is called whenever EthIf_SwitchPortGroupRequestMode is called with ACTIVE_WITH_WAKEUP_REQUEST.
    08: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00482</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>377</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1664</internalId></specobject>
    <specobject>
      <id>EthIf_ASR430_SetControllerMode_Wakeup_Repeat_SwitchPortGroup</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR430/TestSpec_Generated.h</sourcefile>
      <sourceline>1154</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that EthSwt_SetSwitchPortMode will be recalled with ACTIVE_WITH_WAKEUP_REQUEST when repeat timer expires.
Test Object: Repeat timer for switch port group
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch port group support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller and switch port mode to ACTIVE_WITH_WAKEUP_REQUEST.
    02: Call EthIf_MainFunctionState to timeout the repeat timer without changing the link state.
    03: VP(EthIf.EB.SetModeTimeout.RepeatRequest.EthSwtGetLinkStateDown,1) Verify that EthSwt_SetSwitchPortMode was called because the link wasn't changed to ACTIVE.
    04: Call EthIf_MainFunctionState to change link state to ACTIVE.
    05: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SetModeTimeout.RepeatRequest.EthSwtGetLinkStateDown</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>259</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1665</internalId></specobject>
    <specobject>
      <id>EthIf_ASR430_SetControllerMode_Wakeup_Repeat_Next_SwitchPortGroup</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR430/TestSpec_Generated.h</sourcefile>
      <sourceline>1178</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that EthSwt_SetSwitchPortMode will be recalled with ACTIVE_WITH_WAKEUP_REQUEST in the next mainfunction if the first call fails.
Test Object: Repeat timer for switch port group
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch port group support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set return value of EthSwt_SetSwitchPortMode for first two ports to E_NOT_OK.
    02: Set Ethernet interface controller and switch port mode to ACTIVE_WITH_WAKEUP_REQUEST.
    03: Revert return value of EthSwt_SetSwitchPortMode for first two ports to E_OK.
    04: Call EthIf_MainFunctionState to retry informing switch.
    05: VP(EthIf.EB.Repeat.SetSwitchPortMode.HwNotOk,1) Verify that EthSwt_SetSwitchPortMode was called in the next mainfunction.
    06: Call EthIf_MainFunctionState to change link state to ACTIVE.
    07: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.Repeat.SetSwitchPortMode.HwNotOk</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>264</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1666</internalId></specobject>
    <specobject>
      <id>EthIf_ASR430_SetControllerMode_Wakeup_Preemption_SwitchPortGroup</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR430/TestSpec_Generated.h</sourcefile>
      <sourceline>1204</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that EthIf_SetControllerMode will not pass the call to the EthSwt_SetSwitchPortMode for those ports in switch port group that are locked because EthIf_MainFunctionState processing was preempted. In this case E_OK was set for EthSwt_SetSwitchPortMode in the first EthIf_MainFunctionState call.
Test Object: EthIf_SetControllerMode preemption of EthIf_MainFunctionState
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch port group support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set return value of EthSwt_SetSwitchPortMode for first two ports to E_NOT_OK.
    02: Set Ethernet interface controller and switch port mode to ACTIVE_WITH_WAKEUP_REQUEST.
    03: Revert return value of EthSwt_SetSwitchPortMode for first two ports to E_OK.
    04: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthSwt_SetSwitchPortMode.
    05: Call EthIf_MainFunctionState to retry informing switch.
    06: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthSwt_SetSwitchPortMode was called from EthIf_SetControllerMode for the ports that don't reference a transceiver because others are locked.
    07: Call EthIf_MainFunctionState to change link state to ACTIVE.
    08: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>218</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1667</internalId></specobject>
    <specobject>
      <id>EthIf_ASR430_SetControllerMode_Wakeup_Preemption_SwitchPortGroup_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR430/TestSpec_Generated.h</sourcefile>
      <sourceline>1231</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that EthIf_SetControllerMode will not pass the call to the EthSwt_SetSwitchPortMode for those ports in switch port group that are locked because EthIf_MainFunctionState processing was preempted. In this case E_OK was set for EthSwt_SetSwitchPortMode in the second EthIf_MainFunctionState call.
Test Object: EthIf_SetControllerMode preemption of EthIf_MainFunctionState
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch port group support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set return value of EthSwt_SetSwitchPortMode for first two ports to E_NOT_OK.
    02: Set Ethernet interface controller and switch port mode to ACTIVE_WITH_WAKEUP_REQUEST.
    03: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthSwt_SetSwitchPortMode.
    04: Call EthIf_MainFunctionState to retry informing switch.
    05: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthSwt_SetSwitchPortMode was called from EthIf_SetControllerMode for the ports that don't reference a transceiver because others are locked.
    06: Revert return value of EthSwt_SetSwitchPortMode for first two ports to E_OK.
    07: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthSwt_SetSwitchPortMode.
    08: Call EthIf_MainFunctionState to retry informing switch.
    09: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthSwt_SetSwitchPortMode was called from EthIf_SetControllerMode for the ports that don't reference a transceiver because others are locked.
    10: Call EthIf_MainFunctionState to change link state to ACTIVE.
    11: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>218</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1668</internalId></specobject>
    <specobject>
      <id>EthIf_ASR430_SetControllerMode_Wakeup_Preemption_SwitchPortGroup_3</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR430/TestSpec_Generated.h</sourcefile>
      <sourceline>1261</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that EthIf_SetControllerMode will not pass the call to the EthSwt_SetSwitchPortMode for those ports in switch port group that are locked because EthIf_MainFunctionState processing was preempted. In this case E_OK was set for EthSwt_SetSwitchPortMode in the third EthIf_MainFunctionState call.
Test Object: EthIf_SetControllerMode preemption of EthIf_MainFunctionState
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Switch port group support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set return value of EthSwt_SetSwitchPortMode for first two ports to E_NOT_OK.
    02: Set Ethernet interface controller and switch port mode to ACTIVE_WITH_WAKEUP_REQUEST.
    03: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthSwt_SetSwitchPortMode.
    04: Call EthIf_MainFunctionState to retry informing switch.
    05: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthSwt_SetSwitchPortMode was called from EthIf_SetControllerMode for the ports that don't reference a transceiver because others are locked.
    06: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthSwt_SetSwitchPortMode.
    07: Call EthIf_MainFunctionState to retry informing switch.
    08: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthSwt_SetSwitchPortMode was called from EthIf_SetControllerMode for the ports that don't reference a transceiver because others are locked.
    09: Revert return value of EthSwt_SetSwitchPortMode for first two ports to E_OK.
    10: Set callout so that EthIf_SetControllerMode with ACTIVE_WITH_WAKEUP_REQUEST will preempt first call of EthSwt_SetSwitchPortMode.
    11: Call EthIf_MainFunctionState to retry informing switch.
    12: VP(EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag,1) Verify that EthSwt_SetSwitchPortMode was called from EthIf_SetControllerMode for the ports that don't reference a transceiver because others are locked.
    13: Call EthIf_MainFunctionState to change link state to ACTIVE.
    14: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.MainFunctionRx.CheckMiiAccessFlag</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>218</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1669</internalId></specobject>
    <specobject>
      <id>EthIf_ASR430_EthIf_TrcvModeIndication_Wodl_UnexpectedMode</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest09_TC10_ASR430/TestSpec_Generated.h</sourcefile>
      <sourceline>1294</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that EthIf does not check the state of transceiver link if transceiver reports mode down when ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST had been requested.
Test Object: Activation with wakeup request
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   EthIf and test setup is initialized
    -   Asynchronous mode is configured.
  
Test Execution: 
    01: Set Ethernet interface controller and transceiver mode to ACTIVE_WITH_WAKEUP_REQUEST.
    02: Call EthIf_MainFunctionState.
    03: VP(EthIf.SWS_EthIf_00232, 1) Verify EthTrcv_GetLinkState was not called.
    04: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00232</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>557</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1670</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EthIf_ConTest10000_SetSwitchPortMode</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest10_SingleDriverVendorApi/source/application/EthIf_ConTest10_SingleDriverVendorApi.c</sourcefile>
      <sourceline>95</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that Eth and EthSwt drivers are called with API names containing
    VendorId and Vendor specific name, as specified in Bswmd files.
  
Test Object: 
    EthIf use of drivers with mangled API names containing VendorId and Vendor specific name:
    - Eth_1_Vendor1_Receive
    - EthSwt_1_Vendor1_SetSwitchPortMode()
    - EthSwt_1_Vendor1_GetLinkState().
  
Test Precondition: 
    - EthIf initialized.
  
Test Execution: 
    01: Call EthIf_SetControllerMode() to set Ethernet interface controller mode to ACTIVE.
        The controller references an Ethernet switch.
    02: VP(EthSwt_FuncNameMangling): Verify that EthSwt_1_Vendor1_SetSwitchPortMode() was called
        indicating use of VendorId and Vendor name in API name.
    03: Call EthIf_MainFunctionRx().
    04: VP(EthController_FuncNameMangling, EthSwt_FuncNameMangling):
        Verify that Eth_1_Vendor1_Receive() and EthSwt_1_Vendor1_GetLinkState() were called
        indicating use of VendorId and Vendor name in API name.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.DriverVendorInfo.EthController_FuncNameMangling</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1143</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.DriverVendorInfo.EthSwt_FuncNameMangling</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1145</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1671</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest10001_PreProcessRxFrame</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest10_SingleDriverVendorApi/source/application/EthIf_ConTest10_SingleDriverVendorApi.c</sourcefile>
      <sourceline>175</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that EthSwt driver is called with API names containing VendorId and Vendor
    specific name, as specified in Bswmd files.
  
Test Object: 
    EthIf use of drivers with mangled API names containing VendorId and Vendor specific name:
    - EthSwt_1_Vendor1_EthIfPreProcessRxFrame()
  
Test Precondition: 
    EthIf initialized.
    EthIfCtrl_0 activated.
  
Test Execution: 
    01: Call EthIf_RxIndication().
    02: VP(): Verify that EthSwt_1_Vendor1_EthIfPreProcessRxFrame() was called indicating use of
              VendorId and Vendor name in API name.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.DriverVendorInfo.EthSwt_FuncNameMangling</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1145</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1672</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest10002_Transmit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest10_SingleDriverVendorApi/source/application/EthIf_ConTest10_SingleDriverVendorApi.c</sourcefile>
      <sourceline>254</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that Eth and EthSwt drivers are called with API names containing VendorId and
    Vendor specific name, as specified in Bswmd files.
  
Test Object: 
    EthIf use of drivers with mangled API names containing VendorId and Vendor specific name:
    - EthSwt_1_Vendor1_EthIfTxAdaptFrameTypeBufferLength()
    - Eth_1_Vendor1_ProvideTxBuffer()
    - EthSwt_1_Vendor1_EthIfPreProcessTxFrame()
    - Eth_1_Vendor1_Transmit()
    - Eth_1_Vendor1_Retransmit()
    - Eth_1_Vendor1_TxConfirmation().
  
Test Precondition: 
    EthIf initialized.
    EthIfCtrl_1 activated.
  
Test Execution: 
    01: Call EthIf_ProvideTxBuffer() using a CtrlIdx that has EthIfVlanId enabled.
    02: Copy payload to Tx Buffer.
    03: VP(EthSwt_FuncNameMangling):
        Verify that EthSwt_1_Vendor1_EthIfTxAdaptFrameTypeBufferLength() was called indicating use
        of VendorId and Vendor name in API name.
    04: VP(EthController_FuncNameMangling): Verify that Eth_1_Vendor1_ProvideTxBuffer() was called
        indicating use of VendorId and Vendor name in API name.
    05: VP(EthSwt_FuncNameMangling): Verify that EthSwt_1_Vendor1_EthIfPreProcessTxFrame() was
        called indicating use of VendorId and Vendor name in API name.
    06: Call EthIf_Transmit() using a CtrlIdx that has EthIfVlanId enabled.
    07: VP(EthSwt_FuncNameMangling):
        Verify that EthSwt_1_Vendor1_EthIfTxAdaptFrameTypeBufferLength() was called indicating use
        of VendorId and Vendor name in API name.
    08: VP(EthController_FuncNameMangling): Verify that Eth_1_Vendor1_Transmit() was called
        indicating use of VendorId and Vendor name in API name.
    09: Call EthIf_Retransmit() using a CtrlIdx &amp; OrigCtrlIdx that has EthIfVlanId enabled.
    10: VP(EthController_FuncNameMangling): Verify that Eth_1_Vendor1_Retransmit() was called
        indicating use of VendorId and Vendor name in API name.
    11: Call EthIf_MainFunctionTx().
    12: VP(EthController_FuncNameMangling): Verify that Eth_1_Vendor1_TxConfirmation() was called
        indicating use of VendorId and Vendor name in API name.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.DriverVendorInfo.EthController_FuncNameMangling</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1143</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.DriverVendorInfo.EthSwt_FuncNameMangling</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1145</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1673</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest10003_GetIngressTimeStamp</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest10_SingleDriverVendorApi/source/application/EthIf_ConTest10_SingleDriverVendorApi.c</sourcefile>
      <sourceline>471</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that Eth driver is called with API names containing VendorId and Vendor
    specific name, as specified in Bswmd files.
  
Test Object: 
    EthIf use of drivers with mangled API names containing VendorId and Vendor specific name:
    - Eth_1_Vendor1_GetIngressTimeStamp().
  
Test Precondition: 
    EthIf initialized.
    EthIfCtrl_0 activated.
  
Test Execution: 
    01: Call EthIf_GetIngressTimeStamp().
    02: VP(EthController_FuncNameMangling): Verify that Eth_1_Vendor1_GetIngressTimeStamp() was
        called indicating use of VendorId and Vendor name in API name.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.DriverVendorInfo.EthController_FuncNameMangling</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1143</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1674</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest10004_GetPortSignalQuality</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest10_SingleDriverVendorApi/source/application/EthIf_ConTest10_SingleDriverVendorApi.c</sourcefile>
      <sourceline>533</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that EthSwt driver is called with API names containing VendorId and Vendor
    specific name, as specified in Bswmd files.
  
Test Object: 
    EthIf use of drivers with mangled API names containing VendorId and Vendor specific name:
    - EthSwt_1_Vendor1_GetPortSignalQuality().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_SetControllerMode() to set Ethernet interface controller mode to ACTIVE.
        The controller references an Ethernet switch.
    02: Call EthIf_MainFunctionRx().
    03: Call EthIf_GetSwitchPortSignalQuality().
    04: VP(): Verify that EthSwt_1_Vendor1_GetPortSignalQuality() was called indicating use of
        VendorId and Vendor name in API name.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.DriverVendorInfo.EthSwt_FuncNameMangling</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1145</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1675</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest10005_GetArlTable</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest10_SingleDriverVendorApi/source/application/EthIf_ConTest10_SingleDriverVendorApi.c</sourcefile>
      <sourceline>622</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that EthSwt driver is called with API names containing VendorId and Vendor
    specific name, as specified in Bswmd files.
  
Test Object: 
    EthIf use of drivers with mangled API names containing VendorId and Vendor specific name:
    - EthSwt_1_Vendor1_GetArlTable().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_GetArlTable() with SwitchIdx = 0 to obtain ArlTable.
    02: VP(): Verify that EthSwt_1_Vendor1_GetArlTable() was called indicating use of VendorId
        and Vendor name in API name.
    03: Call EthIf_GetArlTable() with SwitchIdx = 1 to obtain ArlTable.
    04: VP(): Verify that EthSwt_1_Vendor1_GetArlTable() was called indicating use of VendorId
        and Vendor name in API name.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.DriverVendorInfo.EthSwt_FuncNameMangling</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1145</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1676</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest10006_GetBufferLevel</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest10_SingleDriverVendorApi/source/application/EthIf_ConTest10_SingleDriverVendorApi.c</sourcefile>
      <sourceline>689</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that EthSwt driver is called with API names containing VendorId and Vendor
    specific name, as specified in Bswmd files.
  
Test Object: 
    EthIf use of drivers with mangled API names containing VendorId and Vendor specific name:
    - EthSwt_1_Vendor1_GetBufferLevel().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_GetBufferLevel() with SwitchIdx = 0 to read the buffer level.
    02: VP(): Verify that EthSwt_1_Vendor1_GetBufferLevel() was called indicating use of VendorId
        and Vendor name in API name.
    03: Call EthIf_GetBufferLevel() with SwitchIdx = 1 to read the buffer level.
    04: VP(): Verify that EthSwt_1_Vendor1_GetBufferLevel() was called indicating use of VendorId
        and Vendor name in API name.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.DriverVendorInfo.EthSwt_FuncNameMangling</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1145</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1677</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest10007_SwtGetCounterValues</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest10_SingleDriverVendorApi/source/application/EthIf_ConTest10_SingleDriverVendorApi.c</sourcefile>
      <sourceline>756</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that EthSwt driver is called with API names containing VendorId and Vendor
    specific name, as specified in Bswmd files.
  
Test Object: 
    EthIf use of drivers with mangled API names containing VendorId and Vendor specific name:
    - EthSwt_1_Vendor1_GetCounterValues().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_SwtGetCounterValues() with SwitchIdx = 0 to obtain the list of values.
    02: VP(): Verify that EthSwt_1_Vendor1_GetCounterValues() was called indicating use of VendorId
        and Vendor name in API name.
    03: Call EthIf_SwtGetCounterValues() with SwitchIdx = 1 to obtain the list of values.
    04: VP(): Verify that EthSwt_1_Vendor1_GetCounterValues() was called indicating use of VendorId
        and Vendor name in API name.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.DriverVendorInfo.EthSwt_FuncNameMangling</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1145</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1678</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest10008_StoreConfiguration</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest10_SingleDriverVendorApi/source/application/EthIf_ConTest10_SingleDriverVendorApi.c</sourcefile>
      <sourceline>822</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that EthSwt driver is called with API names containing VendorId and Vendor
    specific name, as specified in Bswmd files.
  
Test Object: 
    EthIf use of drivers with mangled API names containing VendorId and Vendor specific name:
    - EthSwt_1_Vendor1_StoreConfiguration().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_StoreConfiguration() with SwitchIdx = 0.
    02: VP(): Verify that EthSwt_1_Vendor1_StoreConfiguration() was called indicating use of
        VendorId and Vendor name in API name.
    03: Call EthIf_StoreConfiguration() with SwitchIdx = 1.
    04: VP(): Verify that EthSwt_1_Vendor1_StoreConfiguration() was called indicating use of
        VendorId and Vendor name in API name.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.DriverVendorInfo.EthSwt_FuncNameMangling</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1145</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1679</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest10009_ResetConfiguration</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest10_SingleDriverVendorApi/source/application/EthIf_ConTest10_SingleDriverVendorApi.c</sourcefile>
      <sourceline>887</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that EthSwt driver is called with API names containing VendorId and Vendor
    specific name, as specified in Bswmd files.
  
Test Object: 
    EthIf use of drivers with mangled API names containing VendorId and Vendor specific name:
    - EthSwt_1_Vendor1_ResetConfiguration().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_ResetConfiguration() with SwitchIdx = 0.
    02: VP(): Verify that EthSwt_1_Vendor1_ResetConfiguration() was called indicating use of
        VendorId and Vendor name in API name.
    03: Call EthIf_ResetConfiguration() with SwitchIdx = 1.
    04: VP(): Verify that EthSwt_1_Vendor1_ResetConfiguration() was called indicating use of
        VendorId and Vendor name in API name.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.DriverVendorInfo.EthSwt_FuncNameMangling</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1145</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1680</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest10011_SetPhyLoopbackMode</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest10_SingleDriverVendorApi/source/application/EthIf_ConTest10_SingleDriverVendorApi.c</sourcefile>
      <sourceline>952</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that EthTrcv driver is called with API names containing VendorId and Vendor
    specific name, as specified in Bswmd files.
  
Test Object: 
    EthIf use of drivers with mangled API names containing VendorId and Vendor specific name:
    - EthTrcv_1_Vendor1_SetPhyLoopbackMode().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_GetTrcvSignalQuality().
    02: VP(): Verify that EthTrcv_1_Vendor1_SetPhyLoopbackMode() was called indicating use of
              VendorId and Vendor name in API name.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.DriverVendorInfo.EthTrcv_FuncNameMangling</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1144</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1681</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest10012_SetPhyTxMode</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest10_SingleDriverVendorApi/source/application/EthIf_ConTest10_SingleDriverVendorApi.c</sourcefile>
      <sourceline>1006</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that EthTrcv driver is called with API names containing VendorId and Vendor
    specific name, as specified in Bswmd files.
  
Test Object: 
    EthIf use of drivers with mangled API names containing VendorId and Vendor specific name:
    - EthTrcv_1_Vendor1_SetPhyTxMode().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_SetPhyTxMode().
    02: VP(): Verify that EthTrcv_1_Vendor1_SetPhyTxMode() was called indicating use of VendorId
              and Vendor name in API name.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.DriverVendorInfo.EthTrcv_FuncNameMangling</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1144</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1682</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest10013_GetPhySignalQuality</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest10_SingleDriverVendorApi/source/application/EthIf_ConTest10_SingleDriverVendorApi.c</sourcefile>
      <sourceline>1060</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that EthTrcv driver is called with API names containing VendorId and Vendor
    specific name, as specified in Bswmd files.
  
Test Object: 
    EthIf use of drivers with mangled API names containing VendorId and Vendor specific name:
    - EthTrcv_1_Vendor1_GetPhySignalQuality().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_GetTrcvSignalQuality().
    02: VP(): Verify that EthTrcv_1_Vendor1_GetPhySignalQuality() was called indicating use of
              VendorId and Vendor name in API name.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.DriverVendorInfo.EthTrcv_FuncNameMangling</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1144</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1683</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest10014_GetPhyIdentifier</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest10_SingleDriverVendorApi/source/application/EthIf_ConTest10_SingleDriverVendorApi.c</sourcefile>
      <sourceline>1114</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that EthTrcv driver is called with API names containing VendorId and Vendor
    specific name, as specified in Bswmd files.
  
Test Object: 
    EthIf use of drivers with mangled API names containing VendorId and Vendor specific name:
    - EthTrcv_1_Vendor1_GetPhyIdentifier().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_GetPhyIdentifier().
    02: VP(): Verify that EthTrcv_1_Vendor1_GetPhyIdentifier() was called indicating use of VendorId
              and Vendor name in API name.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.DriverVendorInfo.EthTrcv_FuncNameMangling</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1144</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1684</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest10015_SetPhyTestMode</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest10_SingleDriverVendorApi/source/application/EthIf_ConTest10_SingleDriverVendorApi.c</sourcefile>
      <sourceline>1170</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that EthTrcv driver is called with API names containing VendorId and Vendor
    specific name, as specified in Bswmd files.
  
Test Object: 
    EthIf use of drivers with mangled API names containing VendorId and Vendor specific name:
    - EthTrcv_1_Vendor1_SetPhyTestMode().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_SetPhyTestMode().
    02: VP(): Verify that EthTrcv_1_Vendor1_SetPhyTestMode() was called indicating use of VendorId
              and Vendor name in API name.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.DriverVendorInfo.EthTrcv_FuncNameMangling</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1144</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1685</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest10016_SetTransceiverWakeupMode</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest10_SingleDriverVendorApi/source/application/EthIf_ConTest10_SingleDriverVendorApi.c</sourcefile>
      <sourceline>1225</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that EthTrcv driver is called with API names containing VendorId and Vendor
    specific name, as specified in Bswmd files.
  
Test Object: 
    EthIf use of drivers with mangled API names containing VendorId and Vendor specific name:
    - EthTrcv_1_Vendor1_SetTransceiverWakeupMode().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_SetTransceiverWakeupMode() to set trcv. wake-up mode to ETHTRCV_WUM_ENABLE.
    02: VP(): Verify that EthTrcv_1_Vendor1_SetTransceiverWakeupMode() was called indicating use of
              VendorId and Vendor name in API name.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.DriverVendorInfo.EthTrcv_FuncNameMangling</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1144</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1686</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest10017_GetTransceiverWakeupMode</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest10_SingleDriverVendorApi/source/application/EthIf_ConTest10_SingleDriverVendorApi.c</sourcefile>
      <sourceline>1278</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that EthTrcv driver is called with API names containing VendorId and Vendor
    specific name, as specified in Bswmd files.
  
Test Object: 
    EthIf use of drivers with mangled API names containing VendorId and Vendor specific name:
    - EthTrcv_1_Vendor1_GetTransceiverWakeupMode().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_GetTransceiverWakeupMode() to retrieve wake-up mode of the transceiver
    02: VP(): Verify that EthTrcv_1_Vendor1_GetTransceiverWakeupMode() was called indicating use of
              VendorId and Vendor name in API name.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.DriverVendorInfo.EthTrcv_FuncNameMangling</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1144</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1687</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest10018_CheckWakeup</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest10_SingleDriverVendorApi/source/application/EthIf_ConTest10_SingleDriverVendorApi.c</sourcefile>
      <sourceline>1332</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that EthTrcv driver is called with API names containing VendorId and Vendor
    specific name, as specified in Bswmd files.
  
Test Object: 
    EthIf use of drivers with mangled API names containing VendorId and Vendor specific name:
    - EthTrcv_1_Vendor1_CheckWakeup().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_CheckWakeup() with a random parameter WakeupSource (as it is not used).
    02: VP(): Verify that EthTrcv_1_Vendor1_CheckWakeup() was called indicating use of VendorId and
              Vendor name in API name.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.DriverVendorInfo.EthTrcv_FuncNameMangling</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1144</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1688</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest10019_TrcvPortCableDiagnostic</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest10_SingleDriverVendorApi/source/application/EthIf_ConTest10_SingleDriverVendorApi.c</sourcefile>
      <sourceline>1385</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that EthTrcv driver is called with API names containing VendorId and Vendor
    specific name, as specified in Bswmd files.
  
Test Object: 
    EthIf use of drivers with mangled API names containing VendorId and Vendor specific name:
    - EthTrcv_1_Vendor1_GetCableDiagnosticsResult().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Set EthTrcv_1_Vendor1_GetCableDiagnosticsResult_Stub to return ETHTRCV_CABLEDIAG_WRONG_POLARITY.
    02: Call EthIf_GetCableDiagnosticsResult().
    03: VP(): Verify that EthTrcv_1_Vendor1_GetCableDiagnosticsResult() was called indicating use of
        VendorId and Vendor name in API name.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.DriverVendorInfo.EthTrcv_FuncNameMangling</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1144</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1689</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest10020_GetPhysAddr</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest10_SingleDriverVendorApi/source/application/EthIf_ConTest10_SingleDriverVendorApi.c</sourcefile>
      <sourceline>1446</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that Eth driver is called with API names containing VendorId and Vendor
    specific name, as specified in Bswmd files.
  
Test Object: 
    EthIf use of drivers with mangled API names containing VendorId and Vendor specific name:
    - Eth_1_Vendor1_GetPhysAddr().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_GetPhysAddr().
    02: VP(): Verify that Eth_1_Vendor1_GetPhysAddr() was called indicating use of VendorId and
              Vendor name in API name.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.DriverVendorInfo.EthController_FuncNameMangling</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1143</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1690</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest10021_ReadWriteMii</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest10_SingleDriverVendorApi/source/application/EthIf_ConTest10_SingleDriverVendorApi.c</sourcefile>
      <sourceline>1498</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that Eth driver is called with API names containing VendorId and Vendor
    specific name, as specified in Bswmd files.
  
Test Object: 
    EthIf use of drivers with mangled API names containing VendorId and Vendor specific name:
    - Eth_1_Vendor1_ReadMii()
    - Eth_1_Vendor1_WriteMii().
  
Test Precondition: 
    EthIf initialized.
    EthIfMiiApiEnable = STD_ON.
  
Test Execution: 
    01: Call EthIf_ReadMii().
    02: VP(): Verify that Eth_1_Vendor1_ReadMii() was called indicating use of VendorId and Vendor
              name in API name.
    03: Call EthIf_WriteMii().
    04: VP(): Verify that Eth_1_Vendor1_WriteMii() was called indicating use of VendorId and Vendor
              name in API name.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.DriverVendorInfo.EthController_FuncNameMangling</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1143</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1691</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest10022_EthPhysAddr</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest10_SingleDriverVendorApi/source/application/EthIf_ConTest10_SingleDriverVendorApi.c</sourcefile>
      <sourceline>1566</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that Eth driver is called with API names containing VendorId and Vendor
    specific name, as specified in Bswmd files.
  
Test Object: 
    EthIf use of drivers with mangled API names containing VendorId and Vendor specific name:
    - Eth_1_Vendor1_SetPhysAddr()
    - Eth_1_Vendor1_UpdatePhysAddrFilter().
  
Test Precondition: 
    EthIf initialized.
    EthIfSetPhysAddrSupportEnable = TRUE.
  
Test Execution: 
    01: Call EthIf_SetPhysAddr().
    02: VP(): Verify that Eth_1_Vendor1_SetPhysAddr() was called indicating use of VendorId and
              Vendor name in API name.
    03: Call EthIf_UpdatePhysAddrFilter().
    04: VP(): Verify that Eth_1_Vendor1_UpdatePhysAddrFilter() was called indicating use of VendorId
              and Vendor name in API name.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.DriverVendorInfo.EthController_FuncNameMangling</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1143</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1692</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest10023_EthTimeFunctions</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest10_SingleDriverVendorApi/source/application/EthIf_ConTest10_SingleDriverVendorApi.c</sourcefile>
      <sourceline>1635</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that Eth driver is called with API names containing VendorId and Vendor
    specific name, as specified in Bswmd files.
  
Test Object: 
    EthIf use of drivers with mangled API names containing VendorId and Vendor specific name:
    - Eth_1_Vendor1_GetCurrentTime()
    - Eth_1_Vendor1_EnableEgressTimeStamp()
    - Eth_1_Vendor1_GetEgressTimeStamp().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_GetCurrentTime().
    02: VP(): Verify that Eth_1_Vendor1_GetCurrentTime() was called indicating use of VendorId and
              Vendor name in API name.
    03: Call EthIf_EnableEgressTimeStamp().
    04: VP(): Verify that Eth_1_Vendor1_EnableEgressTimeStamp() was called indicating use of
              VendorId and Vendor name in API name.
    05: Call EthIf_GetEgressTimeStamp().
    06: VP(): Verify that Eth_1_Vendor1_GetEgressTimeStamp() was called indicating use of VendorId
              and Vendor name in API name.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.DriverVendorInfo.EthController_FuncNameMangling</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1143</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1693</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest10024_SetGetControllerMode</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest10_SingleDriverVendorApi/source/application/EthIf_ConTest10_SingleDriverVendorApi.c</sourcefile>
      <sourceline>1714</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that Eth driver is called with API names containing VendorId and Vendor
    specific name, as specified in Bswmd files.
  
Test Object: 
    EthIf use of drivers with mangled API names containing VendorId and Vendor specific name:
    - Eth_1_Vendor1_SetControllerMode()
    - Eth_1_Vendor1_GetControllerMode().
  
Test Precondition: 
    - EthIf initialized.
  
Test Execution: 
    01: Call EthIf_SetControllerMode() to set Ethernet interface controller mode to ACTIVE.
    02: VP(): Verify that Eth_1_Vendor1_SetControllerMode() was called indicating use of VendorId
              and Vendor name in API name.
    03: Call EthIf_GetControllerMode() to retrieve Ethernet interface controller mode.
    04: VP(): Verify that Eth_1_Vendor1_GetControllerMode() was called indicating use of VendorId
              and Vendor name in API name.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.DriverVendorInfo.EthController_FuncNameMangling</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1143</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1694</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest10025_MacSecAddDeleteTxSa</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest10_SingleDriverVendorApi/source/application/EthIf_ConTest10_SingleDriverVendorApi.c</sourcefile>
      <sourceline>1788</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that Eth driver is called with API names containing VendorId and Vendor
    specific name, as specified in Bswmd files.
  
Test Object: 
    EthIf use of drivers with mangled API names containing VendorId and Vendor specific name:
    - EthTrcv_1_Vendor1_MacSecAddTxSa()
    - EthTrcv_1_Vendor1_MacSecDeleteTxSa().
  
Test Precondition: 
    - EthIf initialized.
  
Test Execution: 
    01: Call EthIf_MacSecAddTxSa() to add new SA on transmitting side.
    02: VP(): Verify that EthTrcv_1_Vendor1_MacSecAddTxSa() was called indicating use of VendorId
              and Vendor name in API name.
    03: Call EthIf_MacSecDeleteTxSa() to remove SA for provided AN on transmitting side.
    04: VP(): Verify that EthTrcv_1_Vendor1_MacSecDeleteTxSa() was called indicating use of VendorId
              and Vendor name in API name.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.DriverVendorInfo.EthTrcv_FuncNameMangling</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1144</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1695</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest10026_MacSecUpdateSecY</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest10_SingleDriverVendorApi/source/application/EthIf_ConTest10_SingleDriverVendorApi.c</sourcefile>
      <sourceline>1871</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that Eth driver is called with API names containing VendorId and Vendor
    specific name, as specified in Bswmd files.
  
Test Object: 
    EthIf use of drivers with mangled API names containing VendorId and Vendor specific name:
    - EthTrcv_1_Vendor1_MacSecUpdateSecY().
  
Test Precondition: 
    - EthIf initialized.
  
Test Execution: 
    01: Call EthIf_MacSecUpdateSecY() to update the SecY data in the hardware.
    02: VP(): Verify that EthTrcv_1_Vendor1_MacSecUpdateSecY() was called indicating use of VendorId
              and Vendor name in API name.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.DriverVendorInfo.EthTrcv_FuncNameMangling</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1144</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1696</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest10027_MacSecInitResetRxSc</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest10_SingleDriverVendorApi/source/application/EthIf_ConTest10_SingleDriverVendorApi.c</sourcefile>
      <sourceline>1939</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that Eth driver is called with API names containing VendorId and Vendor
    specific name, as specified in Bswmd files.
  
Test Object: 
    EthIf use of drivers with mangled API names containing VendorId and Vendor specific name:
    - EthTrcv_1_Vendor1_MacSecInitRxSc()
    - EthTrcv_1_Vendor1_MacSecResetRxSc().
  
Test Precondition: 
    - EthIf initialized.
  
Test Execution: 
    01: Call EthIf_MacSecInitRxSc() to configure a Reception SC for the given SCI.
    02: VP(): Verify that EthTrcv_1_Vendor1_MacSecInitRxSc() was called indicating use of VendorId
              and Vendor name in API name.
    03: Call EthIf_MacSecResetRxSc() to reset the MACsec values of the Reception SC for the given SCI.
    04: VP(): Verify that EthTrcv_1_Vendor1_MacSecResetRxSc() was called indicating use of VendorId
              and Vendor name in API name.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.DriverVendorInfo.EthTrcv_FuncNameMangling</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1144</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1697</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest10028_MacSecAddDeleteRxSa</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest10_SingleDriverVendorApi/source/application/EthIf_ConTest10_SingleDriverVendorApi.c</sourcefile>
      <sourceline>2016</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that Eth driver is called with API names containing VendorId and Vendor
    specific name, as specified in Bswmd files.
  
Test Object: 
    EthIf use of drivers with mangled API names containing VendorId and Vendor specific name:
    - EthTrcv_1_Vendor1_MacSecAddTxSa()
    - EthTrcv_1_Vendor1_MacSecDeleteRxSa().
  
Test Precondition: 
    - EthIf initialized.
  
Test Execution: 
    01: Call EthIf_MacSecAddRxSa() to add new SA on receiving side.
    02: VP(): Verify that EthTrcv_1_Vendor1_MacSecAddTxSa() was called indicating use of VendorId
              and Vendor name in API name.
    03: Call EthIf_MacSecDeleteRxSa() to remove SA for provided AN on receiving side.
    04: VP(): Verify that EthTrcv_1_Vendor1_MacSecDeleteRxSa() was called indicating use of VendorId
              and Vendor name in API name.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.DriverVendorInfo.EthTrcv_FuncNameMangling</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1144</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1698</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest10029_EthIf_MacSecUpdateTxRxSa</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest10_SingleDriverVendorApi/source/application/EthIf_ConTest10_SingleDriverVendorApi.c</sourcefile>
      <sourceline>2099</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that Eth driver is called with API names containing VendorId and Vendor
    specific name, as specified in Bswmd files.
  
Test Object: 
    EthIf use of drivers with mangled API names containing VendorId and Vendor specific name:
    - EthTrcv_1_Vendor1_MacSecUpdateTxSa()
    - EthTrcv_1_Vendor1_MacSecUpdateRxSa().
  
Test Precondition: 
    - EthIf initialized.
  
Test Execution: 
    01: Call EthIf_MacSecUpdateTxSa() to add new SA on receiving side.
    02: VP(): Verify that EthTrcv_1_Vendor1_MacSecUpdateTxSa() was called indicating use of VendorId
              and Vendor name in API name.
    03: Call EthIf_MacSecUpdateRxSa() to remove SA for provided AN on receiving side.
    04: VP(): Verify that EthTrcv_1_Vendor1_MacSecUpdateRxSa() was called indicating use of VendorId
              and Vendor name in API name.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.DriverVendorInfo.EthTrcv_FuncNameMangling</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1144</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1699</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EthIf_ConTest11001_Transmit_Vendor1</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest11_MultipleDriverVendorApi/source/application/EthIf_ConTest11_MultipleDriverVendorApi.c</sourcefile>
      <sourceline>44</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that Eth driver Eth_1_Vendor1 is called with API names containing VendorId
    and Vendor specific name, as specified in Bswmd files.
  
Test Object: 
    EthIf use of drivers with mangled API names containing VendorId and Vendor specific name:
    - Eth_1_Vendor1_ProvideTxBuffer()
    - Eth_1_Vendor1_Transmit()
    - Eth_1_Vendor1_Retransmit()
    - Eth_1_Vendor1_TxConfirmation().
  
Test Precondition: 
    EthIf initialized.
    EthIfCtrl_1 activated.
  
Test Execution: 
    01: Call EthIf_ProvideTxBuffer() for EthIfCtrl_1 which is referencing Eth_1_Vendor1 driver.
        EthIfCtrl_1 has EthIfVlanId enabled.
    02: VP(): Verify that Eth_1_Vendor1_ProvideTxBuffer() was called indicating use of VendorId
        and Vendor name in API name.
    03: Call EthIf_Transmit() for EthIfCtrl_1.
    04: VP(): Verify that Eth_1_Vendor1_Transmit() was called indicating use of VendorId and Vendor
        name in API name.
    05: Call EthIf_Retransmit() for EthIfCtrl_1 and EthIfCtrl_2 where both have EthIfVlanId enabled.
    06: VP(): Verify that Eth_1_Vendor1_Retransmit() was called indicating use of VendorId and
        Vendor name in API name.
    07: Call EthIf_MainFunctionTx() for EthIfCtrl_1.
    08: VP(): Verify that Eth_1_Vendor1_TxConfirmation() was called indicating use of VendorId and
        Vendor name in API name.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MultipleEthCtrlTrcv.MultipleEthControllers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1146</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1700</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest11002_Transmit_Vendor2</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest11_MultipleDriverVendorApi/source/application/EthIf_ConTest11_MultipleDriverVendorApi.c</sourcefile>
      <sourceline>210</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that Eth driver Eth_2_Vendor2 is called with API names containing VendorId
    and Vendor specific name, as specified in Bswmd files.
  
Test Object: 
    EthIf use of drivers with mangled API names containing VendorId and Vendor specific name:
    - Eth_2_Vendor2_ProvideTxBuffer()
    - Eth_2_Vendor2_Transmit()
    - Eth_2_Vendor2_Retransmit()
    - Eth_2_Vendor2_TxConfirmation().
  
Test Precondition: 
    EthIf initialized.
    EthIfCtrl_5 activated.
  
Test Execution: 
    01: Call EthIf_ProvideTxBuffer() for EthIfCtrl_5 which is referencing Eth_2_Vendor2 driver.
        EthIfCtrl_1 has EthIfVlanId enabled.
    02: VP(): Verify that Eth_2_Vendor2_ProvideTxBuffer() was called indicating use of VendorId
        and Vendor name in API name.
    03: Call EthIf_Transmit() for EthIfCtrl_5.
    04: VP(): Verify that Eth_2_Vendor2_Transmit() was called indicating use of VendorId and Vendor
        name in API name.
    05: Call EthIf_Retransmit() for EthIfCtrl_5 and EthIfCtrl_2 where both have EthIfVlanId enabled.
    06: VP(): Verify that Eth_2_Vendor2_Retransmit() was called indicating use of VendorId and
        Vendor name in API name.
    07: Call EthIf_MainFunctionTx().
    08: VP(): Verify that Eth_2_Vendor2_TxConfirmation() was called indicating use of VendorId and
        Vendor name in API name.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MultipleEthCtrlTrcv.MultipleEthControllers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1146</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1701</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest11003_GetIngressTimeStamp</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest11_MultipleDriverVendorApi/source/application/EthIf_ConTest11_MultipleDriverVendorApi.c</sourcefile>
      <sourceline>370</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that 2 Eth drivers are called with API names containing VendorId and Vendor
    specific name, as specified in Bswmd files.
  
Test Object: 
    EthIf use of drivers with mangled API names containing VendorId and Vendor specific name:
    - Eth_1_Vendor1_GetIngressTimeStamp()
    - Eth_2_Vendor2_GetIngressTimeStamp().
  
Test Precondition: 
    EthIf initialized.
    EthIfCtrl_0 activated.
  
Test Execution: 
    01: Call EthIf_GetIngressTimeStamp() for EthIfCtrl_0 which is referencing Eth_1_Vendor1 driver.
    02: VP(): Verify that Eth_1_Vendor1_GetIngressTimeStamp() was called indicating use of VendorId
              and Vendor name in API name.
    03: Call EthIf_GetIngressTimeStamp() for EthIfCtrl_5 which is referencing Eth_2_Vendor2 driver.
    04: VP(): Verify that Eth_2_Vendor2_GetIngressTimeStamp() was called indicating use of VendorId
              and Vendor name in API name.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MultipleEthCtrlTrcv.MultipleEthControllers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1146</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1702</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest11004_SetPhyLoopbackMode</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest11_MultipleDriverVendorApi/source/application/EthIf_ConTest11_MultipleDriverVendorApi.c</sourcefile>
      <sourceline>444</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that 2 EthTrcv drivers are called with API names containing VendorId and
    Vendor specific name, as specified in Bswmd files.
  
Test Object: 
    EthIf use of drivers with mangled API names containing VendorId and Vendor specific name:
    - EthTrcv_1_Vendor1_SetPhyLoopbackMode()
    - EthTrcv_2_Vendor2_SetPhyLoopbackMode().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_GetTrcvSignalQuality() for EthIfTransceiver_0 which is referencing
        EthTrcv_1_Vendor1 driver.
    02: VP(): Verify that EthTrcv_1_Vendor1_SetPhyLoopbackMode() was called indicating use of
              VendorId and Vendor name in API name.
    03: Call EthIf_GetTrcvSignalQuality() for EthIfTransceiver_1 which is referencing
        EthTrcv_2_Vendor2 driver.
    04: VP(): Verify that EthTrcv_2_Vendor2_SetPhyLoopbackMode() was called indicating use of
              VendorId and Vendor name in API name.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MultipleEthCtrlTrcv.MultipleEthTransceivers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1147</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1703</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest11005_SetPhyTxMode</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest11_MultipleDriverVendorApi/source/application/EthIf_ConTest11_MultipleDriverVendorApi.c</sourcefile>
      <sourceline>513</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that 2 EthTrcv drivers are called with API names containing VendorId and
    Vendor specific name, as specified in Bswmd files.
  
Test Object: 
    EthIf use of drivers with mangled API names containing VendorId and Vendor specific name:
    - EthTrcv_1_Vendor1_SetPhyTxMode()
    - EthTrcv_2_Vendor2_SetPhyTxMode().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_SetPhyTxMode() for EthIfTransceiver_0 which is referencing EthTrcv_1_Vendor1
        driver.
    02: VP(): Verify that EthTrcv_1_Vendor1_SetPhyTxMode() was called indicating use of VendorId
              and Vendor name in API name.
    03: Call EthIf_SetPhyTxMode() for EthIfTransceiver_1 which is referencing EthTrcv_2_Vendor2
        driver.
    04: VP(): Verify that EthTrcv_2_Vendor2_SetPhyTxMode() was called indicating use of VendorId
              and Vendor name in API name.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MultipleEthCtrlTrcv.MultipleEthTransceivers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1147</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1704</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest11006_GetPhySignalQuality</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest11_MultipleDriverVendorApi/source/application/EthIf_ConTest11_MultipleDriverVendorApi.c</sourcefile>
      <sourceline>581</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that 2 EthTrcv drivers are called with API names containing VendorId and
    Vendor specific name, as specified in Bswmd files.
  
Test Object: 
    EthIf use of drivers with mangled API names containing VendorId and Vendor specific name:
    - EthTrcv_1_Vendor1_GetPhySignalQuality().
    - EthTrcv_2_Vendor2_GetPhySignalQuality().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_GetTrcvSignalQuality() for EthIfTransceiver_0 which is referencing
        EthTrcv_1_Vendor1 driver.
    02: VP(): Verify that EthTrcv_1_Vendor1_GetPhySignalQuality() was called indicating use of
              VendorId and Vendor name in API name.
    03: Call EthIf_GetTrcvSignalQuality() for EthIfTransceiver_1 which is referencing
        EthTrcv_2_Vendor2 driver.
    04: VP(): Verify that EthTrcv_2_Vendor2_GetPhySignalQuality() was called indicating use of
              VendorId and Vendor name in API name.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MultipleEthCtrlTrcv.MultipleEthTransceivers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1147</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1705</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest11007_GetPhyIdentifier</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest11_MultipleDriverVendorApi/source/application/EthIf_ConTest11_MultipleDriverVendorApi.c</sourcefile>
      <sourceline>649</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that 2 EthTrcv drivers are called with API names containing VendorId and
    Vendor specific name, as specified in Bswmd files.
  
Test Object: 
    EthIf use of drivers with mangled API names containing VendorId and Vendor specific name:
    - EthTrcv_1_Vendor1_GetPhyIdentifier()
    - EthTrcv_2_Vendor2_GetPhyIdentifier().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_GetPhyIdentifier() for EthIfTransceiver_0 which is referencing EthTrcv_1_Vendor1
        driver.
    02: VP(): Verify that EthTrcv_1_Vendor1_GetPhyIdentifier() was called indicating use of VendorId
              and Vendor name in API name.
    03: Call EthIf_GetPhyIdentifier() for EthIfTransceiver_1 which is referencing EthTrcv_2_Vendor2
        driver.
    04: VP(): Verify that EthTrcv_2_Vendor2_GetPhyIdentifier() was called indicating use of VendorId
              and Vendor name in API name.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MultipleEthCtrlTrcv.MultipleEthTransceivers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1147</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1706</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest11008_SetPhyTestMode</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest11_MultipleDriverVendorApi/source/application/EthIf_ConTest11_MultipleDriverVendorApi.c</sourcefile>
      <sourceline>719</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that 2 EthTrcv drivers are called with API names containing VendorId and
    Vendor specific name, as specified in Bswmd files.
  
Test Object: 
    EthIf use of drivers with mangled API names containing VendorId and Vendor specific name:
    - EthTrcv_1_Vendor1_SetPhyTestMode()
    - EthTrcv_2_Vendor2_SetPhyTestMode().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_SetPhyTestMode() for EthIfTransceiver_0 which is referencing EthTrcv_1_Vendor1
        driver.
    02: VP(): Verify that EthTrcv_1_Vendor1_SetPhyTestMode() was called indicating use of VendorId
              and Vendor name in API name.
    03: Call EthIf_SetPhyTestMode() for EthIfTransceiver_1 which is referencing EthTrcv_2_Vendor2
        driver.
    04: VP(): Verify that EthTrcv_2_Vendor2_SetPhyTestMode() was called indicating use of VendorId
              and Vendor name in API name.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MultipleEthCtrlTrcv.MultipleEthTransceivers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1147</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1707</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest11009_SetTransceiverWakeupMode</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest11_MultipleDriverVendorApi/source/application/EthIf_ConTest11_MultipleDriverVendorApi.c</sourcefile>
      <sourceline>788</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that 2 EthTrcv drivers are called with API names containing VendorId and
    Vendor specific name, as specified in Bswmd files.
  
Test Object: 
    EthIf use of drivers with mangled API names containing VendorId and Vendor specific name:
    - EthTrcv_1_Vendor1_SetTransceiverWakeupMode()
    - EthTrcv_2_Vendor2_SetTransceiverWakeupMode().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_SetTransceiverWakeupMode() for EthIfTransceiver_0 which is referencing
        EthTrcv_1_Vendor1 driver to set transceiver wake-up mode to ETHTRCV_WUM_ENABLE.
    02: VP(): Verify that EthTrcv_1_Vendor1_SetTransceiverWakeupMode() was called indicating use of
              VendorId and Vendor name in API name.
    03: Call EthIf_SetTransceiverWakeupMode() for EthIfTransceiver_1 which is referencing
        EthTrcv_2_Vendor2 driver to set transceiver wake-up mode to ETHTRCV_WUM_ENABLE.
    04: VP(): Verify that EthTrcv_2_Vendor2_SetTransceiverWakeupMode() was called indicating use of
              VendorId and Vendor name in API name.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MultipleEthCtrlTrcv.MultipleEthTransceivers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1147</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1708</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest11010_GetTransceiverWakeupMode</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest11_MultipleDriverVendorApi/source/application/EthIf_ConTest11_MultipleDriverVendorApi.c</sourcefile>
      <sourceline>855</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that 2 EthTrcv drivers are called with API names containing VendorId and
    Vendor specific name, as specified in Bswmd files.
  
Test Object: 
    EthIf use of drivers with mangled API names containing VendorId and Vendor specific name:
    - EthTrcv_1_Vendor1_GetTransceiverWakeupMode().
    - EthTrcv_2_Vendor2_GetTransceiverWakeupMode().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_GetTransceiverWakeupMode() for EthIfTransceiver_0 which is referencing
        EthTrcv_1_Vendor1 driver to retrieve wake-up mode of the transceiver.
    02: VP(): Verify that EthTrcv_1_Vendor1_GetTransceiverWakeupMode() was called indicating use of
              VendorId and Vendor name in API name.
    03: Call EthIf_GetTransceiverWakeupMode() for EthIfTransceiver_1 which is referencing
        EthTrcv_2_Vendor2 driver to retrieve wake-up mode of the transceiver.
    04: VP(): Verify that EthTrcv_2_Vendor2_GetTransceiverWakeupMode() was called indicating use of
              VendorId and Vendor name in API name.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MultipleEthCtrlTrcv.MultipleEthTransceivers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1147</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1709</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest11011_CheckWakeup</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest11_MultipleDriverVendorApi/source/application/EthIf_ConTest11_MultipleDriverVendorApi.c</sourcefile>
      <sourceline>923</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that 2 EthTrcv drivers are called with API names containing VendorId and
    Vendor specific name, as specified in Bswmd files.
  
Test Object: 
    EthIf use of drivers with mangled API names containing VendorId and Vendor specific name:
    - EthTrcv_1_Vendor1_CheckWakeup()
    - EthTrcv_2_Vendor2_CheckWakeup().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_CheckWakeup() with a random parameter WakeupSource (as it is not used).
    02: VP(): Verify that EthTrcv_1_Vendor1_CheckWakeup() and EthTrcv_2_Vendor2_CheckWakeup() were
              called indicating use of VendorId and Vendor name in API name.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MultipleEthCtrlTrcv.MultipleEthTransceivers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1147</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1710</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest11012_TrcvPortCableDiagnostic_Vendor1</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest11_MultipleDriverVendorApi/source/application/EthIf_ConTest11_MultipleDriverVendorApi.c</sourcefile>
      <sourceline>978</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that EthTrcv driver Vendor1 is called with API names containing VendorId and
    Vendor specific name, as specified in Bswmd files.
  
Test Object: 
    EthIf use of drivers with mangled API names containing VendorId and Vendor specific name:
    - EthTrcv_1_Vendor1_GetCableDiagnosticsResult().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Set EthTrcv_1_Vendor1_GetCableDiagnosticsResult_Stub to return 
        ETHTRCV_CABLEDIAG_WRONG_POLARITY.
    02: Call EthIf_GetCableDiagnosticsResult().
    03: VP(): Verify that EthTrcv_1_Vendor1_GetCableDiagnosticsResult() was called indicating use of
        VendorId and Vendor name in API name.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MultipleEthCtrlTrcv.MultipleEthTransceivers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1147</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1711</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest11013_TrcvPortCableDiagnostic_Vendor2</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest11_MultipleDriverVendorApi/source/application/EthIf_ConTest11_MultipleDriverVendorApi.c</sourcefile>
      <sourceline>1041</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that EthTrcv driver Vendor2 is called with API names containing VendorId and
    Vendor specific name, as specified in Bswmd files.
  
Test Object: 
    EthIf use of drivers with mangled API names containing VendorId and Vendor specific name:
    - EthTrcv_2_Vendor2_GetCableDiagnosticsResult().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Set EthTrcv_2_Vendor2_GetCableDiagnosticsResult_Stub to return
        ETHTRCV_CABLEDIAG_WRONG_POLARITY and call EthIf_MainFunctionState() to reach transceiver
        cable diagnostic state machine state ETHIF_DEM_REPORTED.
    02: Call EthIf_GetCableDiagnosticsResult().
    03: VP(): Verify that EthTrcv_2_Vendor2_GetCableDiagnosticsResult() was called indicating use of
        VendorId and Vendor name in API name.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MultipleEthCtrlTrcv.MultipleEthTransceivers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1147</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1712</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest11014_GetPhysAddr</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest11_MultipleDriverVendorApi/source/application/EthIf_ConTest11_MultipleDriverVendorApi.c</sourcefile>
      <sourceline>1104</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that 2 Eth drivers are called with API names containing VendorId and Vendor
    specific name, as specified in Bswmd files.
  
Test Object: 
    EthIf use of drivers with mangled API names containing VendorId and Vendor specific name:
    - Eth_1_Vendor1_GetPhysAddr()
    - Eth_2_Vendor2_GetPhysAddr().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_GetPhysAddr() for EthIfCtrl_0 which is referencing Eth_1_Vendor1 driver.
    02: VP(): Verify that Eth_1_Vendor1_GetPhysAddr() was called indicating use of VendorId and
              Vendor name in API name.
    03: Call EthIf_GetPhysAddr() for EthIfCtrl_5 which is referencing Eth_2_Vendor2 driver.
    04: VP(): Verify that Eth_2_Vendor2_GetPhysAddr() was called indicating use of VendorId and
              Vendor name in API name.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MultipleEthCtrlTrcv.MultipleEthControllers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1146</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1713</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest11015_ReadWriteMii</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest11_MultipleDriverVendorApi/source/application/EthIf_ConTest11_MultipleDriverVendorApi.c</sourcefile>
      <sourceline>1166</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that 2 Eth drivers are called with API names containing VendorId and Vendor
    specific name, as specified in Bswmd files.
  
Test Object: 
    EthIf use of drivers with mangled API names containing VendorId and Vendor specific name:
    - Eth_1_Vendor1_ReadMii()
    - Eth_1_Vendor1_WriteMii()
    - Eth_2_Vendor2_ReadMii()
    - Eth_2_Vendor2_WriteMii().
  
Test Precondition: 
    EthIf initialized.
    EthIfMiiApiEnable = STD_ON.
  
Test Execution: 
    01: Call EthIf_ReadMii() for EthIfCtrl_0 which is referencing Eth_1_Vendor1 driver.
    02: VP(): Verify that Eth_1_Vendor1_ReadMii() was called indicating use of VendorId and Vendor
              name in API name.
    03: Call EthIf_WriteMii() for EthIfCtrl_0 which is referencing Eth_1_Vendor1 driver.
    04: VP(): Verify that Eth_1_Vendor1_WriteMii() was called indicating use of VendorId and Vendor
              name in API name.
    05: Call EthIf_ReadMii() for EthIfCtrl_5 which is referencing Eth_2_Vendor2 driver.
    06: VP(): Verify that Eth_2_Vendore_ReadMii() was called indicating use of VendorId and Vendor
              name in API name.
    07: Call EthIf_WriteMii() for EthIfCtrl_0 which is referencing Eth_2_Vendor2 driver.
    08: VP(): Verify that Eth_2_Vendore_WriteMii() was called indicating use of VendorId and Vendor
              name in API name.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MultipleEthCtrlTrcv.MultipleEthControllers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1146</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1714</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest11016_EthPhysAddr</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest11_MultipleDriverVendorApi/source/application/EthIf_ConTest11_MultipleDriverVendorApi.c</sourcefile>
      <sourceline>1258</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that 2 Eth drivers are called with API names containing VendorId and Vendor
    specific name, as specified in Bswmd files.
  
Test Object: 
    EthIf use of drivers with mangled API names containing VendorId and Vendor specific name:
    - Eth_1_Vendor1_SetPhysAddr()
    - Eth_1_Vendor1_UpdatePhysAddrFilter()
    - Eth_2_Vendor2_SetPhysAddr()
    - Eth_2_Vendor2_UpdatePhysAddrFilter().
  
Test Precondition: 
    EthIf initialized.
    EthIfSetPhysAddrSupportEnable = TRUE.
  
Test Execution: 
    01: Call EthIf_SetPhysAddr() for EthIfCtrl_0 which is referencing Eth_1_Vendor1 driver.
    02: VP(): Verify that Eth_1_Vendor1_SetPhysAddr() was called indicating use of VendorId and
              Vendor name in API name.
    03: Call EthIf_UpdatePhysAddrFilter() for EthIfCtrl_0 which is referencing Eth_1_Vendor1 driver.
    04: VP(): Verify that Eth_1_Vendor1_UpdatePhysAddrFilter() was called indicating use of VendorId
              and Vendor name in API name.
    05: Call EthIf_SetPhysAddr() for EthIfCtrl_5 which is referencing Eth_1_Vendor1 driver.
    06: VP(): Verify that Eth_2_Vendor2_SetPhysAddr() was called indicating use of VendorId and
              Vendor name in API name.
    07: Call EthIf_UpdatePhysAddrFilter() for EthIfCtrl_5 which is referencing Eth_1_Vendor1 driver.
    08: VP(): Verify that Eth_2_Vendor2_UpdatePhysAddrFilter() was called indicating use of VendorId
              and Vendor name in API name.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MultipleEthCtrlTrcv.MultipleEthControllers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1146</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1715</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest11017_EthTimeFunctions</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest11_MultipleDriverVendorApi/source/application/EthIf_ConTest11_MultipleDriverVendorApi.c</sourcefile>
      <sourceline>1354</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that 2 Eth drivers are called with API names containing VendorId and Vendor
    specific name, as specified in Bswmd files.
  
Test Object: 
    EthIf use of drivers with mangled API names containing VendorId and Vendor specific name:
    - Eth_1_Vendor1_GetCurrentTime()
    - Eth_1_Vendor1_EnableEgressTimeStamp()
    - Eth_1_Vendor1_GetEgressTimeStamp()
    - Eth_2_Vendor2_GetCurrentTime()
    - Eth_2_Vendor2_EnableEgressTimeStamp()
    - Eth_2_Vendor2_GetEgressTimeStamp().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_GetCurrentTime() EthIfCtrl_0 which is referencing Eth_1_Vendor1 driver.
    02: VP(): Verify that Eth_1_Vendor1_GetCurrentTime() was called indicating use of VendorId and
              Vendor name in API name.
    03: Call EthIf_EnableEgressTimeStamp() EthIfCtrl_0 which is referencing Eth_1_Vendor1 driver.
    04: VP(): Verify that Eth_1_Vendor1_EnableEgressTimeStamp() was called indicating use of
              VendorId and Vendor name in API name.
    05: Call EthIf_GetEgressTimeStamp() EthIfCtrl_0 which is referencing Eth_1_Vendor1 driver.
    06: VP(): Verify that Eth_1_Vendor1_GetEgressTimeStamp() was called indicating use of VendorId
              and Vendor name in API name.
    07: Call EthIf_GetCurrentTime() EthIfCtrl_5 which is referencing Eth_2_Vendor2 driver.
    08: VP(): Verify that Eth_2_Vendor2_GetCurrentTime() was called indicating use of VendorId and
              Vendor name in API name.
    09: Call EthIf_EnableEgressTimeStamp() EthIfCtrl_5 which is referencing Eth_2_Vendor2 driver.
    10: VP(): Verify that Eth_2_Vendor2_EnableEgressTimeStamp() was called indicating use of
              VendorId and Vendor name in API name.
    11: Call EthIf_GetEgressTimeStamp() EthIfCtrl_5 which is referencing Eth_2_Vendor2 driver.
    12: VP(): Verify that Eth_2_Vendor2_GetEgressTimeStamp() was called indicating use of VendorId
              and Vendor name in API name.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MultipleEthCtrlTrcv.MultipleEthControllers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1146</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1716</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest11018_SetGetControllerMode</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest11_MultipleDriverVendorApi/source/application/EthIf_ConTest11_MultipleDriverVendorApi.c</sourcefile>
      <sourceline>1465</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that 2 Eth drivers are called with API names containing VendorId and Vendor
    specific name, as specified in Bswmd files.
  
Test Object: 
    EthIf use of drivers with mangled API names containing VendorId and Vendor specific name:
    - Eth_1_Vendor1_SetControllerMode()
    - Eth_1_Vendor1_GetControllerMode()
    - Eth_1_Vendor1_Receive()
    - Eth_2_Vendor2_SetControllerMode()
    - Eth_2_Vendor2_GetControllerMode()
    - Eth_2_Vendor2_Receive().
  
Test Precondition: 
    - EthIf initialized.
  
Test Execution: 
    01: Call EthIf_SetControllerMode() for EthIfCtrl_0 which is referencing Eth_1_Vendor1 driver to
        set Ethernet interface controller mode to ACTIVE.
    02: VP(): Verify that Eth_1_Vendor1_SetControllerMode() was called indicating use of VendorId
              and Vendor name in API name.
    03: Call EthIf_GetControllerMode() for EthIfCtrl_0 which is referencing Eth_1_Vendor1 driver to
        retrieve Ethernet interface controller mode.
    04: VP(): Verify that Eth_1_Vendor1_GetControllerMode() was called indicating use of VendorId
              and Vendor name in API name.
    05: Call EthIf_SetControllerMode() for EthIfCtrl_5 which is referencing Eth_2_Vendor2 driver to
        set Ethernet interface controller mode to ACTIVE.
    06: VP(): Verify that Eth_2_Vendor2_SetControllerMode() was called indicating use of VendorId
              and Vendor name in API name.
    07: Call EthIf_GetControllerMode() for EthIfCtrl_5 which is referencing Eth_2_Vendor21 driver to
        retrieve Ethernet interface controller mode.
    08: VP(): Verify that Eth_2_Vendor2_GetControllerMode() was called indicating use of VendorId
              and Vendor name in API name.
    09: Call EthIf_MainFunctionRx().
    10: VP(): Verify that Eth_1_Vendor1_Receive() and Eth_1_Vendor1_Receive() were called indicating
              use of VendorId and Vendor name in API name.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MultipleEthCtrlTrcv.MultipleEthControllers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1146</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1717</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest11019_MacSecGetTxSaNextPn</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest11_MultipleDriverVendorApi/source/application/EthIf_ConTest11_MultipleDriverVendorApi.c</sourcefile>
      <sourceline>1588</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that 2 EthTrcv drivers are called with API names containing VendorId and
    Vendor specific name, as specified in Bswmd files.
  
Test Object: 
    EthIf use of drivers with mangled API names containing VendorId and Vendor specific name:
    - EthTrcv_1_Vendor1_MacSecGetTxSaNextPn()
    - EthTrcv_2_Vendor2_MacSecGetTxSaNextPn().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_MacSecGetTxSaNextPn() for EthIfTransceiver_0 which is referencing EthTrcv_1_Vendor1
        driver.
    02: VP(): Verify that EthTrcv_1_Vendor1_MacSecGetTxSaNextPn() was called indicating use of VendorId
              and Vendor name in API name.
    03: Call EthIf_MacSecGetTxSaNextPn() for EthIfTransceiver_1 which is referencing EthTrcv_2_Vendor2
        driver.
    04: VP(): Verify that EthTrcv_2_Vendor2_MacSecGetTxSaNextPn() was called indicating use of VendorId
              and Vendor name in API name.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MultipleEthCtrlTrcv.MultipleEthTransceivers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1147</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1718</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest11020_MacSecGetMacSecStats</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest11_MultipleDriverVendorApi/source/application/EthIf_ConTest11_MultipleDriverVendorApi.c</sourcefile>
      <sourceline>1670</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that 2 EthTrcv drivers are called with API names containing VendorId and
    Vendor specific name, as specified in Bswmd files.
  
Test Object: 
    EthIf use of drivers with mangled API names containing VendorId and Vendor specific name:
    - EthTrcv_1_Vendor1_MacSecGetMacSecStats()
    - EthTrcv_2_Vendor2_MacSecGetMacSecStats().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_MacSecGetMacSecStats() for EthIfTransceiver_0 which is referencing EthTrcv_1_Vendor1
        driver.
    02: VP(): Verify that EthTrcv_1_Vendor1_MacSecGetMacSecStats() was called indicating use of VendorId
              and Vendor name in API name.
    03: Call EthIf_MacSecGetMacSecStats() for EthIfTransceiver_1 which is referencing EthTrcv_2_Vendor2
        driver.
    04: VP(): Verify that EthTrcv_2_Vendor2_MacSecGetMacSecStats() was called indicating use of VendorId
              and Vendor name in API name.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MultipleEthCtrlTrcv.MultipleEthTransceivers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1147</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1719</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest11021_MacSecSetControlledPortEnabled</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest11_MultipleDriverVendorApi/source/application/EthIf_ConTest11_MultipleDriverVendorApi.c</sourcefile>
      <sourceline>1740</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that 2 EthTrcv drivers are called with API names containing VendorId and
    Vendor specific name, as specified in Bswmd files.
  
Test Object: 
    EthIf use of drivers with mangled API names containing VendorId and Vendor specific name:
    - EthTrcv_1_Vendor1_MacSecSetControlledPortEnabled()
    - EthTrcv_2_Vendor2_MacSecSetControlledPortEnabled().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_MacSecSetControlledPortEnabled() for EthIfTransceiver_0 which is referencing EthTrcv_1_Vendor1
        driver.
    02: VP(): Verify that EthTrcv_1_Vendor1_MacSecSetControlledPortEnabled() was called indicating use of VendorId
              and Vendor name in API name.
    03: Call EthIf_MacSecSetControlledPortEnabled() for EthIfTransceiver_1 which is referencing EthTrcv_2_Vendor2
        driver.
    04: VP(): Verify that EthTrcv_2_Vendor2_MacSecSetControlledPortEnabled() was called indicating use of VendorId
              and Vendor name in API name.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MultipleEthCtrlTrcv.MultipleEthTransceivers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1147</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1720</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EthIf_ConTest11022_Transmit_NoVendor</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest11_MultipleDriverVendorApi/source/application/EthIf_ConTest11_SingleEthMultipleTrcvVendorApi.c</sourcefile>
      <sourceline>38</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that Eth driver is called with coresponding Eth API names.
  
Test Object: 
    EthIf use of drivers with mangled API names:
    - Eth_ProvideTxBuffer()
    - Eth_Transmit()
    - Eth_Retransmit()
    - Eth_TxConfirmation().
  
Test Precondition: 
    EthIf initialized.
    EthIfCtrl_1 activated.
    No additional Eth controller types configured
    Additional trasceiver types configured
  
Test Execution: 
    01: Call EthIf_ProvideTxBuffer() for EthIfCtrl_1 which is referencing Eth driver.
        EthIfCtrl_1 has EthIfVlanId enabled.
    02: VP(): Verify that Eth_ProvideTxBuffer() was called without use of VendorId
        and Vendor name in API name.
    03: Call EthIf_Transmit() for EthIfCtrl_1.
    04: VP(): Verify that Eth_Transmit() was called without use of VendorId and Vendor
        name in API name.
    05: Call EthIf_Retransmit() for EthIfCtrl_1 and EthIfCtrl_2 where both have EthIfVlanId enabled.
    06: VP(): Verify that Eth_Retransmit() was called without use of VendorId and
        Vendor name in API name.
    07: Call EthIf_MainFunctionTx() for EthIfCtrl_1.
    08: VP(): Verify that Eth_TxConfirmation() was called without use of VendorId and
        Vendor name in API name.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00076.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>944</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00068.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>940</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.RetransmitExtension.Retransmit.Behaviour</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>300</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00115</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>473</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1721</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest11023_Transmit_NoVendor</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest11_MultipleDriverVendorApi/source/application/EthIf_ConTest11_SingleEthMultipleTrcvVendorApi.c</sourcefile>
      <sourceline>209</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that Eth driver is called with coresponding Eth API names.
  
Test Object: 
    EthIf use of drivers with mangled API names:
    - Eth_ProvideTxBuffer()
    - Eth_Transmit()
    - Eth_Retransmit()
    - Eth_TxConfirmation().
  
Test Precondition: 
    EthIf initialized.
    EthIfCtrl_1 activated with wakeup request.
    No additional Eth controller types configured
    Additional trasceiver types configured
  
Test Execution: 
    01: Call EthIf_ProvideTxBuffer() for EthIfCtrl_1 which is referencing Eth driver.
        EthIfCtrl_1 has EthIfVlanId enabled.
    02: VP(): Verify that Eth_ProvideTxBuffer() was called without use of VendorId
        and Vendor name in API name.
    03: Call EthIf_Transmit() for EthIfCtrl_1.
    04: VP(): Verify that Eth_Transmit() was called without use of VendorId and Vendor
        name in API name.
    05: Call EthIf_Retransmit() for EthIfCtrl_1 and EthIfCtrl_2 where both have EthIfVlanId enabled.
    06: VP(): Verify that Eth_Retransmit() was called without use of VendorId and
        Vendor name in API name.
    07: Call EthIf_MainFunctionTx() for EthIfCtrl_1.
    08: VP(): Verify that Eth_TxConfirmation() was called without use of VendorId and
        Vendor name in API name.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00076.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>945</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00068.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>941</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.RetransmitExtension.Retransmit.Behaviour</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>300</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00115</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>473</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1722</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EthIf_ConTest12000_RptSecEvToIdsM_ETHIF_SEV_DROP_INV_VLAN</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest12_IdsMSecurityEvents/source/application/EthIf_ConTest12_IdsMSecurityEvents.c</sourcefile>
      <sourceline>64</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if reporting security events to IdsM is enabled and EthIf_RxIndication()
    is called for the with invalid CrtlIdx, EthIf module shall not report event
    ETHIF_SEV_DROP_INV_VLAN to the IdsM via the IdsM_SetSecurityEvent interface since
    ETHIF_SEV_DROP_INV_VLAN reference is disabled/invalid. Also verifies that
    EthIfReportIssueCallout is called when EthIfReportIssueCalloutFuncName is configured.
  
Test Object: 
    EthIf_RxIndication().
  
Test Precondition: 
    EthIf initialized.
    EthIfReportIssueCalloutFuncName is configured.
  
Test Execution: 
    01: Call EthIf_RxIndication() with invalid CrtlIdx.
    02: VP(ECUC_EthIf_00083, ECUC_EthIf_00079): If reporting events to
        IdsM is enabled, verify that IdsM_SetSecurityEvent() was not called since event reference
        ETHIF_SEV_DROP_INV_VLAN is disabled.
    03: VP(EthIf.EB.ReportIssueCallout.Signature,EthIf.EB.ReportIssueCallout.INV_VLAN)
        Verify that ReportIssueCallout was called with ReportId equal to ETHIF_REPORT_ID_INV_VLAN
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00083</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>848</internalId></provcov>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00079</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>844</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.ReportIssueCallout.Signature</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>382</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.ReportIssueCallout.INV_VLAN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>383</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1723</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest12001_RptSecEvToIdsM_ETHIF_SEV_DROP_INV_VLAN_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest12_IdsMSecurityEvents/source/application/EthIf_ConTest12_IdsMSecurityEvents.c</sourcefile>
      <sourceline>148</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that when EthIf_RxIndication() is called and datagrams are VLAN tagged
    and reporting security events to IdsM is enabled , EthIf module shall not report event
    ETHIF_SEV_DROP_INV_VLAN to the IdsM via the IdsM_SetSecurityEvent interface since
    ETHIF_SEV_DROP_INV_VLAN reference is disabled/invalid. Also verifies that
    EthIfReportIssueCallout is called when EthIfReportIssueCalloutFuncName is configured.
  
Test Object: 
    EthIf_RxIndication().
  
Test Precondition: 
    EthIf initialized.
    EthIfVLANSupportEnable = OFF.
    EthIfReportIssueCalloutFuncName is configured.
  
Test Execution: 
    01: Call EthIf_RxIndication() with VLAN tagged datagrams.
    02: VP(ECUC_EthIf_00083, ECUC_EthIf_00079): Verify that if VLAN is not enabled and frame is VLAN tagged
        event is not reported to the IdsM via the IdsM_SetSecurityEvent interface since
        ETHIF_SEV_DROP_INV_VLAN event reference is disabled/invalid.
    03: VP(EthIf.EB.ReportIssueCallout.Signature,EthIf.EB.ReportIssueCallout.INV_VLAN)
        Verify that ReportIssueCallout was called with ReportId equal to ETHIF_REPORT_ID_INV_VLAN
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00083</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>848</internalId></provcov>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00079</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>844</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.ReportIssueCallout.Signature</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>382</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.ReportIssueCallout.INV_VLAN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>383</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1724</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest12002_RptSecEvToIdsM_ETHIF_SEV_DROP_VLAN_DOUBLE_TAG</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest12_IdsMSecurityEvents/source/application/EthIf_ConTest12_IdsMSecurityEvents.c</sourcefile>
      <sourceline>231</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if reporting security events to IdsM is enabled and EthIf_RxIndication()
    is called and an Ethernet datagram was dropped due to double VLAN tag EthIf module shall not
    report event ETHIF_SEV_DROP_VLAN_DOUBLE_TAG to the IdsM via the IdsM_SetSecurityEvent interface
    since ETHIF_SEV_DROP_VLAN_DOUBLE_TAG event reference is disabled/invalid. Also verifies that
    EthIfReportIssueCallout is called when EthIfReportIssueCalloutFuncName is configured.
  
Test Object: 
    EthIf_RxIndication().
  
Test Precondition: 
    EthIf initialized.
    EthIfReportIssueCalloutFuncName is configured.
  
Test Execution: None.
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00082</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>847</internalId></provcov>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00079</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>844</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00502</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>870</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.ReportIssueCallout.Signature</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>382</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.ReportIssueCallout.VLAN_DOUBLE_TAG</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>384</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1725</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest12003_RptSecEvToIdsM_ETHIF_SEV_DROP_INV_VLAN_3</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest12_IdsMSecurityEvents/source/application/EthIf_ConTest12_IdsMSecurityEvents.c</sourcefile>
      <sourceline>315</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if reporting security events to IdsM is enabled and EthIf_RxIndication()
    is called and frame is not VLAN, and if CtrlIdx does not match to any EthIfCtrlIdx with disabled
    config parameter EthIfVlanId, EthIf module shall not report event ETHIF_SEV_DROP_INV_VLAN to the
    IdsM via the IdsM_SetSecurityEvent interface since ETHIF_SEV_DROP_INV_VLAN event reference is
    disabled/invalid. Also verifies that
    EthIfReportIssueCallout is called when EthIfReportIssueCalloutFuncName is configured.
  
Test Object: 
    EthIf_RxIndication().
  
Test Precondition: 
    EthIf initialized.
    EthIfReportIssueCalloutFuncName is configured.
  
Test Execution: 
    01: Call EthIf_RxIndication() using an CtrlIdx which has EthIfVlanId enabled.
    02: VP(EthIf.ECUC_EthIf_00083,ECUC_EthIf_00079): If reporting events to
        IdsM is enabled, verify that IdsM_SetSecurityEvent() was not called since event reference
        ETHIF_SEV_DROP_INV_VLAN is disabled/invalid.
    03: VP(EthIf.EB.ReportIssueCallout.1,EthIf.EB.ReportIssueCallout.INV_VLAN)
        Verify that ReportIssueCallout was called with ReportId equal to ETHIF_REPORT_ID_INV_VLAN
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00083</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>848</internalId></provcov>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00079</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>844</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.ReportIssueCallout.Signature</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>382</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.ReportIssueCallout.INV_VLAN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>383</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1726</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest12004_RptSecEvToIdsM_ETHIF_SEV_DROP_UNKNOWN_ETHERTYPE</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest12_IdsMSecurityEvents/source/application/EthIf_ConTest12_IdsMSecurityEvents.c</sourcefile>
      <sourceline>395</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if reporting security events to IdsM is enabled and EthIf_RxIndication()
    is called and an Ethernet datagram was dropped due to the unknown Ethernet type EthIf module
    shall not report event ETHIF_SEV_DROP_UNKNOWN_ETHERTYPE to the IdsM via the
    IdsM_SetSecurityEvent interface since ETHIF_SEV_DROP_UNKNOWN_ETHERTYPE event reference is
    disabled/invalid. Also verifies that
    EthIfReportIssueCallout is called when EthIfReportIssueCalloutFuncName is configured.
  
Test Object: 
    EthIf_RxIndication().
  
Test Precondition: 
    EthIf is initialized.
    EthIfReportIssueCalloutFuncName is configured.
  
Test Execution: 
    01: Call EthIf_RxIndication() with invalid frame type.
    02: VP(EthIf.ECUC_EthIf_00081, ECUC_EthIf_00079): If reporting
        events to IdsM is enabled, verify that IdsM_SetSecurityEvent() was not called since event
        reference ETHIF_SEV_DROP_UNKNOWN_ETHERTYPE is disabled/invalid.
    03: VP(EthIf.EB.ReportIssueCallout.Signature,EthIf.EB.ReportIssueCallout.UNKNOWN_ETHERTYPE)
        Verify that ReportIssueCallout was called with ReportId equal to ETHIF_REPORT_ID_UNKNOWN_ETHERTYPE
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00081</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>846</internalId></provcov>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00079</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>844</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.ReportIssueCallout.Signature</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>382</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.ReportIssueCallout.UNKNOWN_ETHERTYPE</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>385</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1727</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EthIf_ConTest01300_MacSec_BasicTest_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest13_MacSecSupport/source/application/EthIf_ConTest13_MacSecSupport.c</sourcefile>
      <sourceline>269</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test is a basic MacSec support test.
  
Test Object: 
    MacSecSupportEnabled
  
Test Precondition: 
    Config parameter MacSecSupportEnabled is true.
    EthIf is initialized.
  
Test Execution: 
    01: Call EthIf MacSec API EthIf_MacSecUpdateSecY().
    02: VP(SWS_EthIf_91215):
        Verify that EthIf_MacSecUpdateSecY() returned E_OK and called EthTrcv_MacSecUpdateSecY().
    03: Call EthIf MacSec API EthIf_MacSecAddTxSa().
    04: VP(SWS_EthIf_91206):
        Verify that EthIf_MacSecAddTxSa() returned E_OK and called EthTrcv_MacSecAddTxSa().
    05: Call EthIf MacSec API EthIf_MacSecAddRxSa().
    06: VP(SWS_EthIf_91205):
        Verify that EthIf_MacSecAddRxSa() returned E_OK and called EthTrcv_MacSecAddRxSa().
    07: Call EthIf MacSec API EthIf_MacSecGetMacSecStats().
    08: VP(SWS_EthIf_91209):
        Verify that EthIf_MacSecGetMacSecStats() returned E_OK and called EthTrcv_MacSecGetMacSecStats().
    09: Call EthIf MacSec API EthIf_MacSecInitRxSc().
    10: VP(SWS_EthIf_91211):
        Verify that EthIf_MacSecInitRxSc() returned E_OK and called EthTrcv_MacSecInitRxSc().
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_91215</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>902</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_91206</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>910</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_91205</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>918</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_91209</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>928</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_91211</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>906</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1728</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01300_MacSec_BasicTest_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest13_MacSecSupport/source/application/EthIf_ConTest13_MacSecSupport.c</sourcefile>
      <sourceline>389</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test is a basic MacSec support test.
  
Test Object: 
    MacSecSupportEnabled
  
Test Precondition: 
    Config parameter MacSecSupportEnabled is true.
    EthIf is initialized.
  
Test Execution: 
    01: Call EthIf MacSec API EthIf_MacSecResetRxSc().
    02: VP(SWS_EthIf_91213):
        Verify that EthIf_MacSecResetRxSc() returned E_OK and called EthTrcv_MacSecResetRxSc().
    03: Call EthIf MacSec API EthIf_MacSecUpdateTxSa().
    04: VP(SWS_EthIf_91216):
        Verify that EthIf_MacSecUpdateTxSa() returned E_OK and called EthTrcv_MacSecAddTxSa().
    05: Call EthIf MacSec API EthIf_MacSecDeleteTxSa().
    06: VP(SWS_EthIf_91208):
        Verify that EthIf_MacSecDeleteTxSa() returned E_OK and called EthTrcv_MacSecDeleteTxSa().
    07: Call EthIf MacSec API EthIf_MacSecUpdateRxSa().
    08: VP(SWS_EthIf_91214):
        Verify that EthIf_MacSecUpdateRxSa() returned E_OK and called EthTrcv_MacSecUpdateRxSa().
    09: Call EthIf MacSec API EthIf_MacSecDeleteRxSa().
    10: VP(SWS_EthIf_91207):
        Verify that EthIf_MacSecDeleteRxSa() returned E_OK and called EthTrcv_MacSecDeleteRxSa().
    11: Call EthIf MacSec API EthIf_MacSecGetTxSaNextPn().
    12: VP(SWS_EthIf_91210):
        Verify that EthIf_MacSecGetTxSaNextPn() returned E_OK and called EthTrcv_MacSecGetTxSaNextPn().
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_91213</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>908</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_91216</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>914</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_91208</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>916</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_91214</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>922</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_91207</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>924</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_91210</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>926</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1729</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01300_MacSec_BasicTest_3</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest13_MacSecSupport/source/application/EthIf_ConTest13_MacSecSupport.c</sourcefile>
      <sourceline>517</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    This test is a basic MacSec support test.
  
Test Object: 
    MacSecSupportEnabled
  
Test Precondition: 
    Config parameter MacSecSupportEnabled is true.
    EthIf is initialized.
  
Test Execution: 
    01: Call EthIf MacSec API EthIf_MacSecOperational().
    02: VP(SWS_EthIf_91212):
        Verify that EthIf_MacSecOperational() returned E_OK.
    03: Call EthIf MacSec API EthIf_MacSecSetControlledPortEnabled().
    04: VP(SWS_EthIf_91238):
        Verify that EthIf_MacSecSetControlledPortEnabled() returned E_OK and called EthTrcv_MacSecSetControlledPortEnabled().
    05: Call EthIf MacSec API EthIf_MacSecGetMacSecStatsNotification().
    06: VP(SWS_EthIf_91235):
        Verify that EthIf_MacSecGetMacSecStatsNotification() called Mka_GetMacSecStatisticsNotification().
    07: Call EthIf MacSec API EthIf_MacSecUpdateSecYNotification().
    08: VP(SWS_EthIf_91218):
        Verify that EthIf_MacSecUpdateSecYNotification() called Mka_MacSecUpdateSecYNotification().
    09: Call EthIf MacSec API EthIf_MacSecAddTxSaNotification().
    10: VP(SWS_EthIf_91224):
        Verify that EthIf_MacSecAddTxSaNotification() called Mka_MacSecAddTxSaNotification().
    11: Call EthIf MacSec API EthIf_MacSecAddRxSaNotification().
    12: VP(SWS_EthIf_91229):
        Verify that EthIf_MacSecAddRxSaNotification() called Mka_MacSecAddRxSaNotification().
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_91212</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>932</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_91238</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>934</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_91235</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>930</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_91218</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>904</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_91224</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>912</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR_R22-11.SWS_EthIf_91229</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>920</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1730</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01301_MacSec_MKAStateChange</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest13_MacSecSupport/source/application/EthIf_ConTest13_MacSecSupport.c</sourcefile>
      <sourceline>628</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    Test case verifies that Ethernet interface calls Mka_LinkStateChange() when transceiver link state changes
    from DOWN to ACTIVE or vice versa. It also verifies that the call is performed only if MkaPaeInstance exists that references
    EthIfCtrl, which references transceiver that changes link state.
  
Test Object: 
    Mka_LinkStateChange()
  
Test Precondition: 
    Config parameter MacSecSupportEnabled is true.
    EthIf is initialized.
  
Test Execution: 
    01: Call EthIf_SetControllerMode() to active Ethernet Interface Controller ETHIFCTRL_0, that
        is referenced by MkaPaeInstance_1.
    02: Call EthIf_MainFunctionRx() to poll transceiver link state.
    03: VP(): Verify that MKA_LinkStateChange() was called and the state is ACTIVE.
    04: Call EthIf_MainFunctionRx().
    05: VP(): Verify that the link state did not change and Mka_LinkStateChange was not called.
    06: Configure EthTrace_GetLinkState stub to return that the transceiver link state is DOWN
        when called.
    07: Call EthIf_MainFunctionRx().
    08: VP(): Verify that MKA_LinkStateChange() was called and the state is DOWN.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00581.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>896</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1731</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01302_MacSec_MKAStateChange_NoCall</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest13_MacSecSupport/source/application/EthIf_ConTest13_MacSecSupport.c</sourcefile>
      <sourceline>732</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that Ethernet interface does not call Mka_LinkStateChange() for Ethernet Interface Controller
    that is referencing a transceiver not used by any MkaPae.
  
Test Object: 
    Mka_LinkStateChange().
  
Test Precondition: 
    Config parameter MacSecSupportEnabled is true.
    EthIf is initialized.
  
Test Execution: 
    01: Call EthIf_SetControllerMode() to active Ethernet Interface Controller ETHIFCTRL_6, that
        is not referenced by MkaPaeInstance.
    02: Call EthIf_MainFunctionRx() to activate link polling.
    03: VP(): Verify that MKA_LinkStateChange() was not called for ETHIFCTRL_6.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00581.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>896</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1732</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01303_MacSec_MacSecOperational_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest13_MacSecSupport/source/application/EthIf_ConTest13_MacSecSupport.c</sourcefile>
      <sourceline>800</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that Ethernet interface calls EthSM_TrcvLinkStateChg() when MACsec Operational changes
    from FALSE to TRUE or vice versa. EthSM_TrcvLinkStateChg() is reported ACTIVE only if transceiver
    link state is ACTIVE and MACsec Operational is TRUE.
  
Test Object: 
    EthIf_MacSecOperational()
  
Test Precondition: 
    Config parameter MacSecSupportEnabled is true.
    EthIf is initialized.
    EthTrcv_GetLinkState stub is configured to return ACTIVE for all configured transceivers.
  
Test Execution: 
    01: Activate all EthIf controllers with function call EbTest_ActivateAllControllers().
    02: Call EthIf_MainFunctionRx() to poll transceiver link state.
    03: VP(EthIf.EB.SWS_EthIf_00582.1):
        Verify that only those EthIf controller with empty EthIfPaeInstanceRef shall report
        transceiver link state to UL.
    04: Report MACsec Operational of MkaPaeInstance_0 to TRUE.
    05: VP(EthIf.EB.SWS_EthIf_00582.1, EthIf.EB.SWS_EthIf_00582.2):
        Verify that EthIf controllers that have MkaPaeInstance_0 configured in EthIfPaeInstanceRef
        reported EthSM_TrcvLinkStateChg(ACTIVE).
        This also verifies that MAC operational will be TRUE, if any of listed PAEs has reported
        MACsec Operational TRUE, then MACsec Operational of EthIf controller is also TRUE.
    06: Report MACsec Operational of MkaPaeInstance_1 to TRUE.
    07: VP(EthIf.EB.SWS_EthIf_00582.1):
        Verify that EthIf controllers that have MkaPaeInstance_1 configured in EthIfPaeInstanceRef
        reported EthSM_TrcvLinkStateChg(ACTIVE).
    08: Report MACsec Operational of MkaPaeInstance_0 to FALSE.
    09: VP(EthIf.EB.SWS_EthIf_00582.1, EthIf.EB.SWS_EthIf_00582.2):
        Verify that EthIf controllers that have only MkaPaeInstance_0 configured in EthIfPaeInstanceRef
        reported EthSM_TrcvLinkStateChg(DOWN).
        This also verifies that MAC operational will be FALSE only if all listed PAEs reported MAC
        operational as FALSE, e.g. EthIf controllers 0 and 6. The fact that EthIf controller 3 is
        still TRUE, verifies that if any of listed PAEs has reported MACsec Operational TRUE,
        then MACsec Operational of EthIf controller is also TRUE.
    10: Report MACsec Operational of MkaPaeInstance_1 to FALSE.
    11: VP(EthIf.EB.SWS_EthIf_00582.1, EthIf.EB.SWS_EthIf_00582.2):
        Verify that EthIf controllers that have only MkaPaeInstance_1 configured in EthIfPaeInstanceRef
        reported EthSM_TrcvLinkStateChg(DOWN).
        This also verifies that MAC operational will be FALSE only if all listed PAEs reported MAC
        operational as FALSE, e.g. EthIf controllers 4 and 5. The fact that EthIf controller 3 is
        become FALSE, verifies that if all listed PAEs reported MAC operational as FALSE, then
        MACsec Operational of EthIf controller is also FALSE.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00582.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>898</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00582.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>899</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1733</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01304_MacSec_MacSecOperational_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest13_MacSecSupport/source/application/EthIf_ConTest13_MacSecSupport.c</sourcefile>
      <sourceline>1023</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that Ethernet interface calls EthSM_TrcvLinkStateChg() when MACsec Operational changes
    from FALSE to TRUE. It also verifies that EthSM_TrcvLinkStateChg(DOWN) was called for all EthIf controllers
    for reference transceiver after being shut-down.
  
Test Object: 
    EthIf_MacSecOperational()
  
Test Precondition: 
    Config parameter MacSecSupportEnabled is true.
    EthIf is initialized.
    EthTrcv_GetLinkState stub is configured to return ACTIVE for all configured transceivers.
  
Test Execution: 
    01: Activate all EthIf controllers with function call EbTest_ActivateAllControllers().
    02: Report MACsec Operational of MkaPaeInstance_0 and MkaPaeInstance_1 to TRUE.
    03: Bring link state of underlying Transceiver_0 (EBTEST_ETHIFTRCV_0_ETHIFTRCVIDX) to DOWN.
    04: VP(): Verify that EthSM_TrcvLinkStateChg(DOWN) was called for all EthIf controllers that
              reference transceiver being shut-down
              (EBTEST_ETHIFCTRL_0_ETHIFCTRLIDX - EBTEST_ETHIFCTRL_2_ETHIFCTRLIDX).
    05: Bring link state of underlying Transceiver_1 (EBTEST_ETHIFTRCV_1_ETHIFTRCVIDX) to DOWN.
    06: VP(): Verify that EthSM_TrcvLinkStateChg(DOWN) was called for all EthIf controllers that
              reference transceiver being shut-down
              (EBTEST_ETHIFCTRL_3_ETHIFCTRLIDX - EBTEST_ETHIFCTRL_5_ETHIFCTRLIDX).
    07: Bring link state of underlying Transceiver_2 (EBTEST_ETHIFTRCV_2_ETHIFTRCVIDX) to DOWN.
    08: VP(): Verify that EthSM_TrcvLinkStateChg(DOWN) was called for all EthIf controllers that
              reference transceiver being shut-down (EBTEST_ETHIFCTRL_6_ETHIFCTRLIDX).
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00582.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>898</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1734</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01305_MacSecUpdateSecY_ActiveMiiAccessFlag</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest13_MacSecSupport/source/application/EthIf_ConTest13_MacSecSupport.c</sourcefile>
      <sourceline>1187</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that EthIf_MacSecUpdateSecY() shall not forward the call to function
    EthTrcv_MacSecUpdateSecY if the Mii access flag is active and the function shall return
    E_NOT_OK. It also checks if correct Eth controller idx is locked.
  
Test Object: 
     EthIf_MacSecUpdateSecY
  
Test Precondition: 
    EthIfTrcvSupportEnable = STD_ON.
    EthIf initialised.
  
Test Execution: 
    01: Set Callout of Eth_ReadMii_Stub.Callout to EthIf_MacSecUpdateSecY
        to call of EthIf_MacSecUpdateSecY while Mii access flag is active for given controller.
    02: Call EthIf_ReadMii().
    03: VP():
        Verify that EthTrcv_MacSecUpdateSecY() was not called.
        Verify that call of EthIf_MacSecUpdateSecY() returned E_NOT_OK. Return code of the
        EthIf_MacSecUpdateSecY is returned through a global variable MiiAccessFlagRetCode_Callout.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.EthIf_MacSecUpdateSecY.CheckMiiAccessFlag.Active</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>219</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1735</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01306_MacSecAddTxSa_ActiveMiiAccessFlag</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest13_MacSecSupport/source/application/EthIf_ConTest13_MacSecSupport.c</sourcefile>
      <sourceline>1256</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that EthIf_MacSecAddTxSa() shall not forward the call to function
    EthTrcv_MacSecAddTxSa if the Mii access flag is active and the function shall return
    E_NOT_OK. It also checks if correct Eth controller idx is locked.
  
Test Object: 
     EthIf_MacSecAddTxSa
  
Test Precondition: 
    EthIfTrcvSupportEnable = STD_ON.
    EthIf initialised.
  
Test Execution: 
    01: Set Callout of Eth_ReadMii_Stub.Callout to EthIf_MacSecAddTxSa
        to call of EthIf_MacSecAddTxSa while Mii access flag is active for given controller.
    02: Call EthIf_ReadMii().
    03: VP():
        Verify that EthTrcv_MacSecAddTxSa() was not called.
        Verify that call of EthIf_MacSecAddTxSa() returned E_NOT_OK. Return code of the
        EthIf_MacSecAddTxSa is returned through a global variable MiiAccessFlagRetCode_Callout.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.EthIf_MacSecAddTxSa.CheckMiiAccessFlag.Active</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1736</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01307_MacSecAddRxSa_ActiveMiiAccessFlag</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest13_MacSecSupport/source/application/EthIf_ConTest13_MacSecSupport.c</sourcefile>
      <sourceline>1325</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that EthIf_MacSecAddRxSa() shall not forward the call to function
    EthTrcv_MacSecAddRxSa if the Mii access flag is active and the function shall return
    E_NOT_OK. It also checks if correct Eth controller idx is locked.
  
Test Object: 
     EthIf_MacSecAddRxSa
  
Test Precondition: 
    EthIfTrcvSupportEnable = STD_ON.
    EthIf initialised.
  
Test Execution: 
    01: Set Callout of Eth_ReadMii_Stub.Callout to EthIf_MacSecAddRxSa
        to call of EthIf_MacSecAddRxSa while Mii access flag is active for given controller.
    02: Call EthIf_ReadMii().
    03: VP():
        Verify that EthTrcv_MacSecAddRxSa() was not called.
        Verify that call of EthIf_MacSecAddRxSa() returned E_NOT_OK. Return code of the
        EthIf_MacSecAddRxSa is returned through a global variable MiiAccessFlagRetCode_Callout.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.EthIf_MacSecAddRxSa.CheckMiiAccessFlag.Active</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>221</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1737</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01308_MacSecGetMacSecStats_ActiveMiiAccessFlag</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest13_MacSecSupport/source/application/EthIf_ConTest13_MacSecSupport.c</sourcefile>
      <sourceline>1394</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that EthIf_MacSecGetMacSecStats() shall not forward the call to function
    EthTrcv_MacSecGetMacSecStats if the Mii access flag is active and the function shall return
    E_NOT_OK. It also checks if correct Eth controller idx is locked.
  
Test Object: 
     EthIf_MacSecGetMacSecStats
  
Test Precondition: 
    EthIfTrcvSupportEnable = STD_ON.
    EthIf initialised.
  
Test Execution: 
    01: Set Callout of Eth_ReadMii_Stub.Callout to EthIf_MacSecGetMacSecStats
        to call of EthIf_MacSecGetMacSecStats while Mii access flag is active for given controller.
    02: Call EthIf_ReadMii().
    03: VP():
        Verify that EthTrcv_MacSecGetMacSecStats() was not called.
        Verify that call of EthIf_MacSecGetMacSecStats() returned E_NOT_OK. Return code of the
        EthIf_MacSecGetMacSecStats is returned through a global variable MiiAccessFlagRetCode_Callout.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.EthIf_MacSecGetMacSecStats.CheckMiiAccessFlag.Active</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>222</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1738</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01309_MacSecInitRxSc_ActiveMiiAccessFlag</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest13_MacSecSupport/source/application/EthIf_ConTest13_MacSecSupport.c</sourcefile>
      <sourceline>1463</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that EthIf_MacSecInitRxSc() shall not forward the call to function
    EthTrcv_MacSecInitRxSc if the Mii access flag is active and the function shall return
    E_NOT_OK. It also checks if correct Eth controller idx is locked.
  
Test Object: 
     EthIf_MacSecInitRxSc
  
Test Precondition: 
    EthIfTrcvSupportEnable = STD_ON.
    EthIf initialised.
  
Test Execution: 
    01: Set Callout of Eth_ReadMii_Stub.Callout to EthIf_MacSecInitRxSc
        to call of EthIf_MacSecInitRxSc while Mii access flag is active for given controller.
    02: Call EthIf_ReadMii().
    03: VP():
        Verify that EthTrcv_MacSecInitRxSc() was not called.
        Verify that call of EthIf_MacSecInitRxSc() returned E_NOT_OK. Return code of the
        EthIf_MacSecInitRxSc is returned through a global variable MiiAccessFlagRetCode_Callout.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.EthIf_MacSecInitRxSc.CheckMiiAccessFlag.Active</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>223</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1739</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01310_MacSecResetRxSc_ActiveMiiAccessFlag</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest13_MacSecSupport/source/application/EthIf_ConTest13_MacSecSupport.c</sourcefile>
      <sourceline>1532</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that EthIf_MacSecResetRxSc() shall not forward the call to function
    EthTrcv_MacSecResetRxSc if the Mii access flag is active and the function shall return
    E_NOT_OK. It also checks if correct Eth controller idx is locked.
  
Test Object: 
     EthIf_MacSecResetRxSc
  
Test Precondition: 
    EthIfTrcvSupportEnable = STD_ON.
    EthIf initialised.
  
Test Execution: 
    01: Set Callout of Eth_ReadMii_Stub.Callout to EthIf_MacSecResetRxSc
        to call of EthIf_MacSecResetRxSc while Mii access flag is active for given controller.
    02: Call EthIf_ReadMii().
    03: VP():
        Verify that EthTrcv_MacSecResetRxSc() was not called.
        Verify that call of EthIf_MacSecResetRxSc() returned E_NOT_OK. Return code of the
        EthIf_MacSecResetRxSc is returned through a global variable MiiAccessFlagRetCode_Callout.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.EthIf_MacSecResetRxSc.CheckMiiAccessFlag.Active</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1740</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01311_MacSecUpdateTxSa_ActiveMiiAccessFlag</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest13_MacSecSupport/source/application/EthIf_ConTest13_MacSecSupport.c</sourcefile>
      <sourceline>1601</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that EthIf_MacSecUpdateTxSa() shall not forward the call to function
    EthTrcv_MacSecUpdateTxSa if the Mii access flag is active and the function shall return
    E_NOT_OK. It also checks if correct Eth controller idx is locked.
  
Test Object: 
     EthIf_MacSecUpdateTxSa
  
Test Precondition: 
    EthIfTrcvSupportEnable = STD_ON.
    EthIf initialised.
  
Test Execution: 
    01: Set Callout of Eth_ReadMii_Stub.Callout to EthIf_MacSecUpdateTxSa
        to call of EthIf_MacSecUpdateTxSa while Mii access flag is active for given controller.
    02: Call EthIf_ReadMii().
    03: VP():
        Verify that EthTrcv_MacSecUpdateTxSa() was not called.
        Verify that call of EthIf_MacSecUpdateTxSa() returned E_NOT_OK. Return code of the
        EthIf_MacSecUpdateTxSa is returned through a global variable MiiAccessFlagRetCode_Callout.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.EthIf_MacSecUpdateTxSa.CheckMiiAccessFlag.Active</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>225</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1741</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01312_MacSecDeleteTxSa_ActiveMiiAccessFlag</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest13_MacSecSupport/source/application/EthIf_ConTest13_MacSecSupport.c</sourcefile>
      <sourceline>1670</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that EthIf_MacSecDeleteTxSa() shall not forward the call to function
    EthTrcv_MacSecDeleteTxSa if the Mii access flag is active and the function shall return
    E_NOT_OK. It also checks if correct Eth controller idx is locked.
  
Test Object: 
     EthIf_MacSecDeleteTxSa
  
Test Precondition: 
    EthIfTrcvSupportEnable = STD_ON.
    EthIf initialised.
  
Test Execution: 
    01: Set Callout of Eth_ReadMii_Stub.Callout to EthIf_MacSecDeleteTxSa
        to call of EthIf_MacSecDeleteTxSa while Mii access flag is active for given controller.
    02: Call EthIf_ReadMii().
    03: VP():
        Verify that EthTrcv_MacSecDeleteTxSa() was not called.
        Verify that call of EthIf_MacSecDeleteTxSa() returned E_NOT_OK. Return code of the
        EthIf_MacSecDeleteTxSa is returned through a global variable MiiAccessFlagRetCode_Callout.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.EthIf_MacSecDeleteTxSa.CheckMiiAccessFlag.Active</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>226</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1742</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01313_MacSecUpdateRxSa_ActiveMiiAccessFlag</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest13_MacSecSupport/source/application/EthIf_ConTest13_MacSecSupport.c</sourcefile>
      <sourceline>1739</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that EthIf_MacSecUpdateRxSa() shall not forward the call to function
    EthTrcv_MacSecUpdateRxSa if the Mii access flag is active and the function shall return
    E_NOT_OK. It also checks if correct Eth controller idx is locked.
  
Test Object: 
     EthIf_MacSecUpdateRxSa
  
Test Precondition: 
    EthIfTrcvSupportEnable = STD_ON.
    EthIf initialised.
  
Test Execution: 
    01: Set Callout of Eth_ReadMii_Stub.Callout to EthIf_MacSecUpdateRxSa
        to call of EthIf_MacSecUpdateRxSa while Mii access flag is active for given controller.
    02: Call EthIf_ReadMii().
    03: VP():
        Verify that EthTrcv_MacSecUpdateRxSa() was not called.
        Verify that call of EthIf_MacSecUpdateRxSa() returned E_NOT_OK. Return code of the
        EthIf_MacSecUpdateRxSa is returned through a global variable MiiAccessFlagRetCode_Callout.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.EthIf_MacSecUpdateRxSa.CheckMiiAccessFlag.Active</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>227</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1743</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01314_MacSecDeleteRxSa_ActiveMiiAccessFlag</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest13_MacSecSupport/source/application/EthIf_ConTest13_MacSecSupport.c</sourcefile>
      <sourceline>1808</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that EthIf_MacSecDeleteRxSa() shall not forward the call to function
    EthTrcv_MacSecDeleteRxSa if the Mii access flag is active and the function shall return
    E_NOT_OK. It also checks if correct Eth controller idx is locked.
  
Test Object: 
     EthIf_MacSecDeleteRxSa
  
Test Precondition: 
    EthIfTrcvSupportEnable = STD_ON.
    EthIf initialised.
  
Test Execution: 
    01: Set Callout of Eth_ReadMii_Stub.Callout to EthIf_MacSecDeleteRxSa
        to call of EthIf_MacSecDeleteRxSa while Mii access flag is active for given controller.
    02: Call EthIf_ReadMii().
    03: VP():
        Verify that EthTrcv_MacSecDeleteRxSa() was not called.
        Verify that call of EthIf_MacSecDeleteRxSa() returned E_NOT_OK. Return code of the
        EthIf_MacSecDeleteRxSa is returned through a global variable MiiAccessFlagRetCode_Callout.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.EthIf_MacSecDeleteRxSa.CheckMiiAccessFlag.Active</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>228</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1744</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01315_MacSecGetTxSaNextPn_ActiveMiiAccessFlag</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest13_MacSecSupport/source/application/EthIf_ConTest13_MacSecSupport.c</sourcefile>
      <sourceline>1877</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that EthIf_MacSecGetTxSaNextPn() shall not forward the call to function
    EthTrcv_MacSecGetTxSaNextPn if the Mii access flag is active and the function shall return
    E_NOT_OK. It also checks if correct Eth controller idx is locked.
  
Test Object: 
     EthIf_MacSecGetTxSaNextPn
  
Test Precondition: 
    EthIfTrcvSupportEnable = STD_ON.
    EthIf initialised.
  
Test Execution: 
    01: Set Callout of Eth_ReadMii_Stub.Callout to EthIf_MacSecGetTxSaNextPn
        to call of EthIf_MacSecGetTxSaNextPn while Mii access flag is active for given controller.
    02: Call EthIf_ReadMii().
    03: VP():
        Verify that EthTrcv_MacSecGetTxSaNextPn() was not called.
        Verify that call of EthIf_MacSecGetTxSaNextPn() returned E_NOT_OK. Return code of the
        EthIf_MacSecGetTxSaNextPn is returned through a global variable MiiAccessFlagRetCode_Callout.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.EthIf_MacSecGetTxSaNextPn.CheckMiiAccessFlag.Active</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>229</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1745</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01316_MacSecSetControlledPortEnabled_ActiveMiiAccessFlag</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest13_MacSecSupport/source/application/EthIf_ConTest13_MacSecSupport.c</sourcefile>
      <sourceline>1946</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that EthIf_MacSecSetControlledPortEnabled() shall not forward the call to function
    EthTrcv_MacSecSetControlledPortEnabled if the Mii access flag is active and the function shall return
    E_NOT_OK. It also checks if correct Eth controller idx is locked.
  
Test Object: 
     EthIf_MacSecSetControlledPortEnabled
  
Test Precondition: 
    EthIfTrcvSupportEnable = STD_ON.
    EthIf initialised.
  
Test Execution: 
    01: Set Callout of Eth_ReadMii_Stub.Callout to EthIf_MacSecSetControlledPortEnabled
        to call of EthIf_MacSecSetControlledPortEnabled while Mii access flag is active for given controller.
    02: Call EthIf_ReadMii().
    03: VP():
        Verify that EthTrcv_MacSecSetControlledPortEnabled() was not called.
        Verify that call of EthIf_MacSecSetControlledPortEnabled() returned E_NOT_OK. Return code of the
        EthIf_MacSecSetControlledPortEnabled is returned through a global variable MiiAccessFlagRetCode_Callout.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MIIExtension.EthIf_MacSecSetControlledPortEnabled.CheckMiiAccessFlag.Active</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>230</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1746</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01317_MacSec_MKAStateChange_E_NOT_OK</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest13_MacSecSupport/source/application/EthIf_ConTest13_MacSecSupport.c</sourcefile>
      <sourceline>2015</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    Test case verifies that Ethernet interface calls Mka_LinkStateChange() when transceiver link state changes
    from DOWN to ACTIVE or vice versa. If Mka_LinkStateChange() return E_OK, EthIf will update the status of MkaLinkState,
    if Mka_LinkStateChange() return E_NOT_OK, EthIf will not update the status of MkaLinkState.
  
Test Object: 
    Mka_LinkStateChange()
  
Test Precondition: 
    Config parameter MacSecSupportEnabled is true.
    EthIf is initialized.
  
Test Execution: 
    01: Call EthIf_SetControllerMode() to active Ethernet Interface Controller ETHIFCTRL_0, that
        is referenced by MkaPaeInstance_1.
    02: Call EthIf_MainFunctionRx() to poll transceiver link state.
    03: VP(): Verify that MKA_LinkStateChange() was called and the state is ACTIVE.
    04: Set up stub Mka_LinkStateChange to return E_NOT_OK and EthTrcv_GetLinkState returns state DOWN.
    05: Call EthIf_MainFunctionRx().
    06: VP(): Verify that MKA_LinkStateChange() was called and the state is DOWN.
    07: Set up stub Mka_LinkStateChange to return E_OK and call again EthIf_MainFunctionRx().
    08: VP(): Verify that MKA_LinkStateChange() was also called which indicates that EthIf didn't
              update status of MkaLinkState in previous call.
    09: Call EthIf_MainFunctionRx().
    10: VP(): Verify that when link state isn't changed, that Mka_LinkStateChange isn't called, which
              indicated that EthIf changed status of MkaLinkState in previous call when MKA_LinkStateChange()
              returned E_OK.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00581.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>896</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1747</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest01318_MacSec_MacSecOperational_3</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_ConTest13_MacSecSupport/source/application/EthIf_ConTest13_MacSecSupport.c</sourcefile>
      <sourceline>2152</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies correct operation of EthIf_MacSecOperational() API after EthIf module initialization.
  
Test Object: 
    EthIf_MacSecOperational(), EthIf_Init()
  
Test Precondition: 
    Config parameter MacSecSupportEnabled is true.
    EthIf is initialized.
    EthTrcv_GetLinkState stub is configured to return ACTIVE for all configured transceivers.
  
Test Execution: 
    01: Activate all EthIf controllers with function call EbTest_ActivateAllControllers().
    02: Call EthIf_MainFunctionRx() to poll transceiver link state.
    03: VP(EthIf.EB.SWS_EthIf_00582.1):
        Verify that only those EthIf controller with empty EthIfPaeInstanceRef shall report
        transceiver link state to UL.
    04: Report MACsec Operational of MkaPaeInstance_0 to TRUE.
    05: VP(EthIf.EB.SWS_EthIf_00582.1, EthIf.EB.SWS_EthIf_00582.2):
        Verify that EthIf controllers that have MkaPaeInstance_0 configured in EthIfPaeInstanceRef
        reported EthSM_TrcvLinkStateChg(ACTIVE).
    06: Initialize EthIf module again.
        Repeat steps 01 - 05 after module initialization.
    07: Activate all EthIf controllers with function call EbTest_ActivateAllControllers().
    08: Call EthIf_MainFunctionRx() to poll transceiver link state.
    09: VP(EthIf.EB.SWS_EthIf_00582.1):
        Verify that only those EthIf controller with empty EthIfPaeInstanceRef shall report
        transceiver link state to UL.
    10: Report MACsec Operational of MkaPaeInstance_0 to TRUE.
    11: VP(EthIf.EB.SWS_EthIf_00582.1, EthIf.EB.SWS_EthIf_00582.2, EthIf.SWS_EthIf_00024):
        Verify that EthIf controllers that have MkaPaeInstance_0 configured in EthIfPaeInstanceRef
        reported EthSM_TrcvLinkStateChg(ACTIVE).
        This proves that EthIf_MacSecOperational() works correctly after module initialization.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00582.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>898</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00582.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>899</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00024</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>421</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1748</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EthIf_T100_DET_00_GetVersionInfo_DetInvPointer</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T100_VLanOff_TrcvOff/source/application/EthIf_T100_GetVersionInfo_VLanOff_TrcvOff.c</sourcefile>
      <sourceline>76</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the functionality of GetVersionInfo function when parameter is a invalid pointer.
  
Test Object: None.
Test Precondition: 
    The module under test needs to have version information
  
Test Execution: 
    01: Call function with the parameter(s) defined in the input section.
    02: VP: The function Det_ReportError shall be called with the expected output parameter(s).
  
Test Input: 
    Test Step 01:
    &lt;ModuleName&gt;_GetVersionInfo() Parameter(s):
      Std_VersionInfoType *Input_VersionInfo = NULL_PTR;
  
Test Output: 
    Det_ReportError() Parameter(s):
      uint16 Output_Det_ModuleId = TEST_CURRENT_MODULE_ID(TEST_MODULE_PREFIX);
      uint8 Output_Det_InstanceId = TEST_CURRENT_DET_INSTANCE_ID(TEST_MODULE_PREFIX);
      uint8 Output_Det_ApiId = TEST_CURRENT_DET_API_ID(TEST_MODULE_PREFIX);
      uint8 Output_Det_ErrorId = &lt;ModuleName&gt;_E_INV_POINTER;
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00082</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>448</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00127</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>479</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1749</internalId></specobject>
    <specobject>
      <id>EthIf_T100_00_GetVersionInfo_VersionTest</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T100_VLanOff_TrcvOff/source/application/EthIf_T100_GetVersionInfo_VLanOff_TrcvOff.c</sourcefile>
      <sourceline>141</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test calls the EthIf_GetVersionInfo() function and compares the returned values
    with the version info stored in the module in both initialized/uninitialized states.
  
Test Object: None.
Test Precondition: 
    The module under test needs to have version information.
  
Test Execution: 
    01: Call EthIf_GetVersionInfo
    02: VP(): The returned version information shall match output version information.
    03: Initialize EthIf.
    04: Call function with the parameter(s) defined in the input section.
    05: VP(): Verify that EthIf_GetVersionInfo() returns the module
     version information if EthIf_Init() was called before
  
Test Input: 
  
Test Output: 
    Output_VersionInfo.moduleID = TEST_CURRENT_MODULE_ID(TEST_MODULE_PREFIX);
    Output_VersionInfo.sw_major_version = TEST_CURRENT_SW_MAJOR_VERSION(TEST_MODULE_PREFIX);
    Output_VersionInfo.sw_minor_version = TEST_CURRENT_SW_MINOR_VERSION(TEST_MODULE_PREFIX);
    Output_VersionInfo.sw_patch_version = TEST_CURRENT_SW_PATCH_VERSION(TEST_MODULE_PREFIX);
    Output_VersionInfo.vendorID = TEST_CURRENT_VENDOR_ID(TEST_MODULE_PREFIX);
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00082</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>448</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00082_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>140</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1750</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EthIf_T111_DET_00_GetControllerMode_DetUninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T100_VLanOff_TrcvOff/source/application/EthIf_T111_GetControllerMode_VLanOff_TrcvOff.c</sourcefile>
      <sourceline>43</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the response of EthIf_GetControllerMode when EthIf_Init is not called.
  
Test Object: None.
Test Precondition: 
    The modules Eth and EthIf need to be configured:
      Input_EthIf_CtrlIdx = 0 maps to Output_Eth_CtrlIdx = 2
      Input_EthIf_CtrlIdx = 1 maps to Output_Eth_CtrlIdx = 1
      Input_EthIf_CtrlIdx = 2 maps to Output_Eth_CtrlIdx = 0
    EthIfVLANSupportEnable = OFF
    EthIfTrcvSupportEnable = OFF
    EthIf_Init is not called.
    Eth_GetControllerMode() configuration(s):
      CtrlModePtr_Out = ETH_MODE_DOWN;
  
Test Execution: 
    01: Call function under test with the parameter(s) defined in the input section.
    02: VP: The function under test shall return E_NOT_OK.
    03: VP: The function Det_ReportError shall be called with the expected output parameter(s).
  
Test Input: 
    EthIf_GetControllerMode() parameters(s):
      Input_EthIf_CtrlIdx= 0U;
  
Test Output: 
    Det_ReportError() parameter(s):
      Output_Det_ModuleId = ETHIF_MODULE_ID;
      Output_Det_InstanceId = ETHIF_INSTANCE_ID;
      Output_Det_ApiId = ETHIF_GETCONTROLLERMODE_SVCID;
      Output_Det_ErrorId = ETHIF_E_NOT_INITIALIZED;
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00039</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>427</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00041</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>41</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1751</internalId></specobject>
    <specobject>
      <id>EthIf_T111_DET_01_GetControllerMode_DetInvCtrlIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T100_VLanOff_TrcvOff/source/application/EthIf_T111_GetControllerMode_VLanOff_TrcvOff.c</sourcefile>
      <sourceline>121</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the response of EthIf_GetControllerMode when CtrlIdx is invalid.
  
Test Object: None.
Test Precondition: 
    The modules Eth and EthIf need to be configured:
      Input_EthIf_CtrlIdx = 0 maps to Output_Eth_CtrlIdx = 2
      Input_EthIf_CtrlIdx = 1 maps to Output_Eth_CtrlIdx = 1
      Input_EthIf_CtrlIdx = 2 maps to Output_Eth_CtrlIdx = 0
    EthIfVLANSupportEnable = OFF
    EthIfTrcvSupportEnable = OFF
    EthIf_Init is called.
    Eth_GetControllerMode() configuration(s):
      CtrlModePtr_Out = ETH_MODE_DOWN;
  
Test Execution: 
    01: Call function under test with the parameter(s) defined in the input section.
    02: VP: The function under test shall return E_NOT_OK.
    03: VP: The function Det_ReportError shall be called with the expected output parameter(s).
  
Test Input: 
    EthIf_GetControllerMode() parameters(s):
      Input_EthIf_CtrlIdx= 10U;
  
Test Output: 
    Det_ReportError() parameter(s):
      Output_Det_ModuleId = ETHIF_MODULE_ID;
      Output_Det_InstanceId = ETHIF_INSTANCE_ID;
      Output_Det_ApiId = ETHIF_GETCONTROLLERMODE_SVCID;
      Output_Det_ErrorId = ETHIF_E_INV_CTRL_IDX;
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00039</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>427</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00042</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>430</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1752</internalId></specobject>
    <specobject>
      <id>EthIf_T111_DET_02_GetControllerMode_DetInvParPtr</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T100_VLanOff_TrcvOff/source/application/EthIf_T111_GetControllerMode_VLanOff_TrcvOff.c</sourcefile>
      <sourceline>201</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the response of EthIf_GetControllerMode when parameter is a null pointer.
  
Test Object: None.
Test Precondition: 
    The modules Eth and EthIf need to be configured:
      Input_EthIf_CtrlIdx = 0 maps to Output_Eth_CtrlIdx = 2
      Input_EthIf_CtrlIdx = 1 maps to Output_Eth_CtrlIdx = 1
      Input_EthIf_CtrlIdx = 2 maps to Output_Eth_CtrlIdx = 0
    EthIfVLANSupportEnable = OFF
    EthIfTrcvSupportEnable = OFF
    EthIf_Init is called.
    Eth_GetControllerMode() configuration(s):
      CtrlModePtr_Out = ETH_MODE_DOWN;
  
Test Execution: 
    01: Call function under test with the parameter(s) defined in the input section.
    02: VP: The function under test shall return E_NOT_OK.
    03: VP: The function Det_ReportError shall be called with the expected output parameter(s).
  
Test Input: 
    EthIf_GetCurrentComMode() parameter(s):
      Input_EthIf_CtrlIdx= 0U;
      &amp;Output_EthIf_CtrlMode = NULL_PTR;
  
Test Output: 
    Det_ReportError() parameter(s):
      Output_Det_ModuleId = ETHIF_MODULE_ID;
      Output_Det_InstanceId = ETHIF_INSTANCE_ID;
      Output_Det_ApiId = ETHIF_GETCONTROLLERMODE_SVCID;
      Output_Det_ErrorId = ETHIF_E_PARAM_POINTER;
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00039</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>427</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00043</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>431</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1753</internalId></specobject>
    <specobject>
      <id>EthIf_T111_00_GetControllerMode_ValidParameters</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T100_VLanOff_TrcvOff/source/application/EthIf_T111_GetControllerMode_VLanOff_TrcvOff.c</sourcefile>
      <sourceline>279</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the functionality of EthIf_GetControllerMode function for valid parameters.
  
Test Object: None.
Test Precondition: 
    The modules Eth and EthIf need to be configured:
      Input_EthIf_CtrlIdx = 0 maps to Output_Eth_CtrlIdx = 2
      Input_EthIf_CtrlIdx = 1 maps to Output_Eth_CtrlIdx = 1
      Input_EthIf_CtrlIdx = 2 maps to Output_Eth_CtrlIdx = 0
    EthIfVLANSupportEnable = OFF
    EthIfTrcvSupportEnable = OFF
    EthIf_Init is called.
    Eth_GetControllerMode() configuration(s):
      Input_Eth_CtrlModePtr_Out[0U] = ETH_MODE_DOWN;
      Input_Eth_CtrlModePtr_Out[1U] = ETH_MODE_ACTIVE;
      Input_Eth_CtrlModePtr_Out[2U] = ETH_MODE_ACTIVE;
      Input_Eth_CtrlModePtr_Out[3U] = ETH_MODE_ACTIVE;
  
Test Execution: 
    01: Call function under test with the parameter(s) defined in the input section.
    02: VP: The function under test shall return E_OK.
    03: VP: The function Eth_GetControllerMode shall be called with the expected output parameter(s)
            and shall return the proper controller mode.
  
Test Input: 
    Test step 01:
    Test case 0-3:
    EthIf_SetControllerMode parameter(s):
      Input_EthIf_CtrlIdx[0U] = 1U;
      Input_EthIf_CtrlIdx[1U] = 1U;
      Input_EthIf_CtrlIdx[2U] = 0U;
      Input_EthIf_CtrlIdx[3U] = 1U;
  
Test Output: 
    Test step 03:
    Test case 0-3:
    Eth_SetControllerMode parameter(s):
      Output_Eth_CtrlIdx[0U] = 1U;
      Output_Eth_CtrlIdx[1U] = 1U;
      Output_Eth_CtrlIdx[2U] = 2U;
      Output_Eth_CtrlIdx[3U] = 1U;

    EthIf_SetControllerMode parameter(s):
      Output_EthIf_CtrlMode[0U] = Input_Eth_CtrlModePtr_Out[0U];
      Output_EthIf_CtrlMode[1U] = Input_Eth_CtrlModePtr_Out[1U];
      Output_EthIf_CtrlMode[2U] = Input_Eth_CtrlModePtr_Out[2U];
      Output_EthIf_CtrlMode[3U] = Input_Eth_CtrlModePtr_Out[3U];
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00040</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>428</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1754</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EthIf_T112_DET_00_SetControllerMode_DetUninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T100_VLanOff_TrcvOff/source/application/EthIf_T112_SetControllerMode_VLanOff_TrcvOff.c</sourcefile>
      <sourceline>44</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the response of EthIf_SetControllerMode when EthIf_Init is not called.
  
Test Object: None.
Test Precondition: 
    The modules Eth and EthIf need to be configured:
      Input_EthIf_CtrlIdx = 0 maps to Output_Eth_CtrlIdx = 2
      Input_EthIf_CtrlIdx = 1 maps to Output_Eth_CtrlIdx = 1
      Input_EthIf_CtrlIdx = 2 maps to Output_Eth_CtrlIdx = 0
    EthIfVLANSupportEnable = OFF
    EthIfTrcvSupportEnable = OFF
    EthIf_Init is not called
  
Test Execution: 
    01: Call function under test with the parameter(s) defined in the input section.
    02: VP: The function under test shall return E_NOT_OK.
    03: VP: The function Det_ReportError shall be called with the expected output parameter(s).
  
Test Input: 
    EthIf_SetControllerMode() parameters(s):
      Input_EthIf_CtrlIdx= 0U;
      Input_EthIf_CtrlMode = ETH_MODE_DOWN;
  
Test Output: 
    Det_ReportError() parameter(s):
      Output_Det_ModuleId = ETHIF_MODULE_ID;
      Output_Det_InstanceId = ETHIF_INSTANCE_ID;
      Output_Det_ApiId = ETHIF_SETCONTROLLERMODE_SVCID;
      Output_Det_ErrorId = ETHIF_E_NOT_INITIALIZED;
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00034</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>423</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00036</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>40</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1755</internalId></specobject>
    <specobject>
      <id>EthIf_T112_DET_01_SetControllerMode_DetInvCtrlIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T100_VLanOff_TrcvOff/source/application/EthIf_T112_SetControllerMode_VLanOff_TrcvOff.c</sourcefile>
      <sourceline>115</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the functionality of SetControllerMode function
  
Test Object: None.
Test Precondition: 
    The modules Eth and EthIf need to be configured:
      Input_EthIf_CtrlIdx = 0 maps to Output_Eth_CtrlIdx = 2
      Input_EthIf_CtrlIdx = 1 maps to Output_Eth_CtrlIdx = 1
      Input_EthIf_CtrlIdx = 2 maps to Output_Eth_CtrlIdx = 0
    EthIfVLANSupportEnable = OFF
    EthIfTrcvSupportEnable = OFF
    EthIf_Init is called
  
Test Execution: 
    01: Call function under test with the parameter(s) defined in the input section.
    02: VP(SWS_EthIf_00034, SWS_EthIf_00037): The function under test shall return E_NOT_OK.
    03: VP(SWS_EthIf_00034, SWS_EthIf_00037): The function Det_ReportError shall be called with the
        expected output parameter(s).
  
Test Input: 
    EthIf_SetControllerMode() parameters(s):
      Input_EthIf_CtrlIdx= 10U;
      Input_EthIf_CtrlMode = ETH_MODE_DOWN;
  
Test Output: 
    Det_ReportError() parameter(s):
      Output_Det_ModuleId = ETHIF_MODULE_ID;
      Output_Det_InstanceId = ETHIF_INSTANCE_ID;
      Output_Det_ApiId = ETHIF_SETCONTROLLERMODE_SVCID;
      Output_Det_ErrorId = ETHIF_E_INV_CTRL_IDX;
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00034</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>423</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00037</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>426</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1756</internalId></specobject>
    <specobject>
      <id>EthIf_T112_00_SetControllerMode_ValidParameters</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T100_VLanOff_TrcvOff/source/application/EthIf_T112_SetControllerMode_VLanOff_TrcvOff.c</sourcefile>
      <sourceline>191</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the functionality of SetControllerMode for valid parameters.
  
Test Object: None.
Test Precondition: 
    The modules Eth and EthIf need to be configured:
      Input_EthIf_CtrlIdx = 0 maps to Output_Eth_CtrlIdx = 2
      Input_EthIf_CtrlIdx = 1 maps to Output_Eth_CtrlIdx = 1
      Input_EthIf_CtrlIdx = 2 maps to Output_Eth_CtrlIdx = 0

    EthIfVLANSupportEnable = OFF
    EthIfTrcvSupportEnable = OFF
    EthIf_Init is called
  
Test Execution: 
    01: Call function under test with the parameter(s) defined in the input section.
    02: VP(SWS_EthIf_00034): The function under test shall return E_OK.
    03: VP(SWS_EthIf_00034): The function Eth_SetControllerMode shall be called with the
        expected output parameter(s).
    04: VP(SWS_EthIf_00252): Verify that EthSM_CtrlModeIndication() to inform EthSM about
        controller mode change.
  
Test Input: 
    Test step 01:
    Test case 0-4:
    EthIf_SetControllerMode parameter(s):
      Input_EthIf_CtrlIdx[0U] = 1U;
      Input_EthIf_CtrlMode[0U] = ETH_MODE_ACTIVE;
      Input_EthIf_CtrlIdx[1U] = 1U;
      Input_EthIf_CtrlMode[1U] = ETH_MODE_DOWN;
      Input_EthIf_CtrlIdx[2U] = 0U;
      Input_EthIf_CtrlMode[2U] = ETH_MODE_ACTIVE;
      Input_EthIf_CtrlIdx[3U] = 1U;
      Input_EthIf_CtrlMode[3U] = ETH_MODE_ACTIVE;
      Input_EthIf_CtrlIdx[4U] = 0U;
      Input_EthIf_CtrlMode[4U] = ETH_MODE_DOWN;
  
Test Output: 
    Test step 03:
    Test case 0-4:
    Eth_SetControllerMode parameter(s):
        Output_Eth_CtrlIdx[0U] = 1U;
        Output_EthIf_CtrlMode[0U] = ETH_MODE_ACTIVE;
        Output_Eth_CtrlIdx[1U] = 1U;
        Output_EthIf_CtrlMode[1U] = ETH_MODE_DOWN;
        Output_Eth_CtrlIdx[2U] = 2U;
        Output_EthIf_CtrlMode[2U] = ETH_MODE_ACTIVE;
        Output_Eth_CtrlIdx[3U] = 1U;
        Output_EthIf_CtrlMode[3U] = ETH_MODE_ACTIVE;
        Output_Eth_CtrlIdx[4U] = 2U;
        Output_EthIf_CtrlMode[4U] = ETH_MODE_DOWN;
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00034</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>423</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00252</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>575</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1757</internalId></specobject>
    <specobject>
      <id>EthIf_T112_00_SetControllerMode_EthSetControllerMode_NotOk</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T100_VLanOff_TrcvOff/source/application/EthIf_T112_SetControllerMode_VLanOff_TrcvOff.c</sourcefile>
      <sourceline>315</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the functionality of SetControllerMode when Eth_SetControllerMode function returns
    E_NOT_OK and if mode ETH_MODE_ACTIVE has already been requested for the Ethernet Interface
    Controller referencing the Ethernet Controller.
  
Test Object: None.
Test Precondition: 
    The modules Eth and EthIf need to be configured:
      Input_EthIf_CtrlIdx = 0 maps to Output_Eth_CtrlIdx = 2
    EthIfVLANSupportEnable = OFF
    EthIfTrcvSupportEnable = OFF
    EthIf_Init is called
  
Test Execution: 
    01: Set Eth_SetControllerMode function to return E_NOT_OK.
    02: Call EthIf_SetControllerMode() with ETH_MODE_ACTIVE.
    03: VP(EthIf.EB.SetCtrlMode.HwNotOk): EthIf_SetControllerMode function returns E_NOT_OK.
    04: VP(SWS_EthIf_00034): Verify that Eth_SetControllerMode() is called.
    05: VP(EthIf.EB.SetCtrlMode.NoVirtCtrlAccess.EthSetControllerMode_NotOk):
        Verify that EthSM_CtrlModeIndication() is not called.
    06: Set Eth_SetControllerMode function to return E_OK.
    07: Call EthIf_MainFunctionRx().
    08: VP(EthIf.EB.VirtCtrlAccess.RepeatSetCtrlModeActive.HwNotOk):
        Verify that Eth_SetControllerMode() is called.
    09: VP(SWS_EthIf_00252): Function EthSM_CtrlModeIndication() shall be called.
    10: VP(EthIf.EB.EthIf_MainFunctionRx.NoEthTrcv): Verify that EthSM_TrcvLinkStateChg() is called.
    11: Call EthIf_SetControllerMode() with ETH_MODE_ACTIVE again.
    12: VP(SWS_EthIf_00035): Verify that no functions were called.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SetCtrlMode.HwNotOk</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>159</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00034</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>423</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00035</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>424</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00252</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>575</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.SetCtrlMode.NoVirtCtrlAccess.EthSetControllerMode_NotOk</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>160</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.VirtCtrlAccess.RepeatSetCtrlModeActive.HwNotOk</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>161</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.EthIf_MainFunctionRx.NoEthTrcv</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>198</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1758</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EthIf_T130_DET_00_Transmit_DetUninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T100_VLanOff_TrcvOff/source/application/EthIf_T130_Transmit_VLanOff_TrcvOff.c</sourcefile>
      <sourceline>44</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the response of EthIf_Transmit when EthIf_Init is not called.
  
Test Object: None.
Test Precondition: 
    The modules Eth and EthIf need to be configured:
      Input_EthIf_CtrlIdx = 0 maps to Output_Eth_CtrlIdx = 2
      Input_EthIf_CtrlIdx = 1 maps to Output_Eth_CtrlIdx = 1
      Input_EthIf_CtrlIdx = 2 maps to Output_Eth_CtrlIdx = 0
    EthIfVLANSupportEnable = OFF
    EthIfTrcvSupportEnable = OFF
    EthIf_Init is not called.
  
Test Execution: 
    01: Call function under test with the parameter(s) defined in the input section.
    02: VP: The function under test shall return E_NOT_OK.
    03: VP: The function Det_ReportError shall be called with the expected output parameter(s).
  
Test Input: 
    EthIf_Transmit() parameters(s):
      Input_EthIf_CtrlIdx = 0U;
      Input_EthIf_BufIdx = 12U;
      Input_EthIf_FrameType = 65535U;
      Input_EthIf_TxConfirmation = true;
      Input_EthIf_LenByte = 30U;
      Input_EthIf_PhysAddr[6U] = {1U, 2U, 3U, 4U, 5U, 6U};
  
Test Output: 
    Det_ReportError() parameter(s):
      Output_Det_ModuleId = ETHIF_MODULE_ID;
      Output_Det_InstanceId = ETHIF_INSTANCE_ID;
      Output_Det_ApiId = ETHIF_TRANSMIT_SVCID;
      Output_Det_ErrorId = ETHIF_E_NOT_INITIALIZED;
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00077</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>43</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1759</internalId></specobject>
    <specobject>
      <id>EthIf_T130_DET_01_Transmit_DetInvCtrlIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T100_VLanOff_TrcvOff/source/application/EthIf_T130_Transmit_VLanOff_TrcvOff.c</sourcefile>
      <sourceline>126</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the response of EthIf_Transmit when CtrlIdx is invalid.
  
Test Object: None.
Test Precondition: 
    The modules Eth and EthIf need to be configured:
      Input_EthIf_CtrlIdx = 0 maps to Output_Eth_CtrlIdx = 2
      Input_EthIf_CtrlIdx = 1 maps to Output_Eth_CtrlIdx = 1
      Input_EthIf_CtrlIdx = 2 maps to Output_Eth_CtrlIdx = 0
    EthIfVLANSupportEnable = OFF
    EthIfTrcvSupportEnable = OFF
    EthIf_Init is called.
  
Test Execution: 
    01: Call function under test with the parameter(s) defined in the input section.
    02: VP: The function under test shall return E_NOT_OK.
    03: VP: The function Det_ReportError shall be called with the expected output parameter(s).
  
Test Input: 
    EthIf_Transmit() parameters(s):
      Input_EthIf_CtrlIdx = 10U;
      Input_EthIf_BufIdx = 12U;
      Input_EthIf_FrameType = 65535U;
      Input_EthIf_TxConfirmation = true;
      Input_EthIf_LenByte = 30U;
      Input_EthIf_PhysAddr[6U] = {1U, 2U, 3U, 4U, 5U, 6U};
  
Test Output: 
    Det_ReportError() parameter(s):
      Output_Det_ModuleId = ETHIF_MODULE_ID;
      Output_Det_InstanceId = ETHIF_INSTANCE_ID;
      Output_Det_ApiId = ETHIF_TRANSMIT_SVCID;
      Output_Det_ErrorId = ETHIF_E_INV_CTRL_IDX;
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00078</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>445</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1760</internalId></specobject>
    <specobject>
      <id>EthIf_T130_DET_02_Transmit_DetInvParPtr</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T100_VLanOff_TrcvOff/source/application/EthIf_T130_Transmit_VLanOff_TrcvOff.c</sourcefile>
      <sourceline>212</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the response of EthIf_Transmit when parameter is a null pointer.
  
Test Object: None.
Test Precondition: 
    The modules Eth and EthIf need to be configured:
      Input_EthIf_CtrlIdx = 0 maps to Output_Eth_CtrlIdx = 2
      Input_EthIf_CtrlIdx = 1 maps to Output_Eth_CtrlIdx = 1
      Input_EthIf_CtrlIdx = 2 maps to Output_Eth_CtrlIdx = 0
    EthIfVLANSupportEnable = OFF
    EthIfTrcvSupportEnable = OFF
    EthIf_Init is called.
  
Test Execution: 
    01: Call function under test with the parameter(s) defined in the input section.
    02: VP: The function under test shall return E_NOT_OK.
    03: VP: The function Det_ReportError shall be called with the expected output parameter(s).
  
Test Input: 
    EthIf_Transmit() parameters(s):
      Input_EthIf_CtrlIdx = 10U;
      Input_EthIf_BufIdx = 12U;
      Input_EthIf_FrameType = 65535U;
      Input_EthIf_TxConfirmation = true;
      Input_EthIf_LenByte = 30U;
      &amp;Input_EthIf_PhysAddr = NULL_PTR;
  
Test Output: 
    Det_ReportError() parameter(s):
      Output_Det_ModuleId = ETHIF_MODULE_ID;
      Output_Det_InstanceId = ETHIF_INSTANCE_ID;
      Output_Det_ApiId = ETHIF_TRANSMIT_SVCID;
      Output_Det_ErrorId = ETHIF_E_PARAM_POINTER;
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00080</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>447</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1761</internalId></specobject>
    <specobject>
      <id>EthIf_T130_00_Transmit_ValidParameters</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T100_VLanOff_TrcvOff/source/application/EthIf_T130_Transmit_VLanOff_TrcvOff.c</sourcefile>
      <sourceline>297</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the functionality of EthIf_Transmit function for valid parameters.
  
Test Object: None.
Test Precondition: 
    The modules Eth and EthIf need to be configured:
      Input_EthIf_CtrlIdx = 0 maps to Output_Eth_CtrlIdx = 2
      Input_EthIf_CtrlIdx = 1 maps to Output_Eth_CtrlIdx = 1
      Input_EthIf_CtrlIdx = 2 maps to Output_Eth_CtrlIdx = 0
    EthIfVLANSupportEnable = OFF
    EthIfTrcvSupportEnable = OFF
    EthIf_Init is called.
    A controller is in state ACTIVE.
  
Test Execution: 
    01: Call function under test with the parameter(s) defined in the input section.
    02: VP: The function under test shall return E_OK.
    03: VP: The function Eth_Transmit shall be called with the expected output parameter(s).
  
Test Input: 
    Test step 01:
    Test case 0:
    EthIf_Transmit() parameters(s):
      Input_EthIf_CtrlIdx[0U] = 0U;
      Input_EthIf_BufIdx[0U] = 12U;
      Input_EthIf_FrameType[0U] = 65535U;
      Input_EthIf_TxConfirmation = true;
      Input_EthIf_LenByte[0U] = 30U;
      Input_EthIf_PhysAddr[0U][6U] = {1U, 2U, 3U, 4U, 5U, 6U};

    Test step 01:
    Test case 1:
    EthIf_Transmit() parameters(s):
      Input_EthIf_CtrlIdx[1U] = 2U;
      Input_EthIf_BufIdx[1U] = 14U;
      Input_EthIf_FrameType[1U] = 12U;
      Input_EthIf_TxConfirmation = true;
      Input_EthIf_LenByte[1U] = 16U;
      Input_EthIf_PhysAddr[1U][6U] = {11U, 12U, 13U, 14U, 15U, 16U};
  
Test Output: 
    Test step 03:
    Test case 0:
    Eth_Transmit parameter(s):
      Output_Eth_CtrlIdx[0U] = 2U;
      Output_Eth_BufIdx[0U] = Input_EthIf_BufIdx[0];
      Output_Eth_FrameType[0U] = Input_EthIf_FrameType[0U];
      Output_Eth_LenByte[0U] = Input_EthIf_LenByte[0U];
      Output_Eth_PhysAddrPtr[0U] = &amp;Input_EthIf_PhysAddr[0U];

    Test step 03:
    Test case 1:
    Eth_Transmit parameter(s):
      Output_Eth_CtrlIdx[1U] = 0U;
      Output_Eth_BufIdx[1U] = Input_EthIf_BufIdx[1U];
      Output_Eth_FrameType[1U] = Input_EthIf_FrameType[1U];
      Output_Eth_LenByte[1U] = Input_EthIf_LenByte[1U];
      Output_Eth_PhysAddrPtr[1U] = &amp;Input_EthIf_PhysAddr[1U];
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00076.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>944</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1762</internalId></specobject>
    <specobject>
      <id>EthIf_T130_01_MODE_DOWN_Transmit_E_NOT_OK</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T100_VLanOff_TrcvOff/source/application/EthIf_T130_Transmit_VLanOff_TrcvOff.c</sourcefile>
      <sourceline>439</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_Transmit() is called while
    controller mode is ETH_MODE_DOWN, the call will not be forwarded and the
    function will will return E_NOT_OK.
  
Test Object: None.
Test Precondition: 
    The modules Eth and EthIf need to be configured:
      Input_EthIf_CtrlIdx = 0 maps to Output_Eth_CtrlIdx = 2
      Input_EthIf_CtrlIdx = 1 maps to Output_Eth_CtrlIdx = 1
      Input_EthIf_CtrlIdx = 2 maps to Output_Eth_CtrlIdx = 0
    EthIfVLANSupportEnable = OFF
    EthIfTrcvSupportEnable = OFF
    EthIf_Init is called.
    A controller is in state DOWN.
  
Test Execution: 
    01: Call EthIf_Transmit() with the parameter(s) defined in the input section.
    02: VP(EthIf.SWS_EthIf_00076.3):
        Verify that the call was not forwarded and that EthIf_Transmit() returned E_NOT_OK.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00076.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>946</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1763</internalId></specobject>
    <specobject>
      <id>EthIf_T130_02_Transmit_ValidParameters</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T100_VLanOff_TrcvOff/source/application/EthIf_T130_Transmit_VLanOff_TrcvOff.c</sourcefile>
      <sourceline>521</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the functionality of EthIf_Transmit function for valid parameters.
  
Test Object: None.
Test Precondition: 
    The modules Eth and EthIf need to be configured:
      Input_EthIf_CtrlIdx = 0 maps to Output_Eth_CtrlIdx = 2
      Input_EthIf_CtrlIdx = 1 maps to Output_Eth_CtrlIdx = 1
      Input_EthIf_CtrlIdx = 2 maps to Output_Eth_CtrlIdx = 0
    EthIfVLANSupportEnable = OFF
    EthIfTrcvSupportEnable = OFF
    EthIf_Init is called.
    A controller is in state ACTIVE_WITH_WAKEUP_REQUEST.
  
Test Execution: 
    01: Call function under test with the parameter(s) defined in the input section.
    02: VP: The function under test shall return E_OK.
    03: VP: The function Eth_Transmit shall be called with the expected output parameter(s).
  
Test Input: 
    Test step 01:
    Test case 0:
    EthIf_Transmit() parameters(s):
      Input_EthIf_CtrlIdx[0U] = 0U;
      Input_EthIf_BufIdx[0U] = 12U;
      Input_EthIf_FrameType[0U] = 65535U;
      Input_EthIf_TxConfirmation = true;
      Input_EthIf_LenByte[0U] = 30U;
      Input_EthIf_PhysAddr[0U][6U] = {1U, 2U, 3U, 4U, 5U, 6U};

    Test step 01:
    Test case 1:
    EthIf_Transmit() parameters(s):
      Input_EthIf_CtrlIdx[1U] = 2U;
      Input_EthIf_BufIdx[1U] = 14U;
      Input_EthIf_FrameType[1U] = 12U;
      Input_EthIf_TxConfirmation = true;
      Input_EthIf_LenByte[1U] = 16U;
      Input_EthIf_PhysAddr[1U][6U] = {11U, 12U, 13U, 14U, 15U, 16U};
  
Test Output: 
    Test step 03:
    Test case 0:
    Eth_Transmit parameter(s):
      Output_Eth_CtrlIdx[0U] = 2U;
      Output_Eth_BufIdx[0U] = Input_EthIf_BufIdx[0];
      Output_Eth_FrameType[0U] = Input_EthIf_FrameType[0U];
      Output_Eth_LenByte[0U] = Input_EthIf_LenByte[0U];
      Output_Eth_PhysAddrPtr[0U] = &amp;Input_EthIf_PhysAddr[0U];

    Test step 03:
    Test case 1:
    Eth_Transmit parameter(s):
      Output_Eth_CtrlIdx[1U] = 0U;
      Output_Eth_BufIdx[1U] = Input_EthIf_BufIdx[1U];
      Output_Eth_FrameType[1U] = Input_EthIf_FrameType[1U];
      Output_Eth_LenByte[1U] = Input_EthIf_LenByte[1U];
      Output_Eth_PhysAddrPtr[1U] = &amp;Input_EthIf_PhysAddr[1U];
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00076.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>945</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1764</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EthIf_T140_DET_00_RxIndication_DetUninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T100_VLanOff_TrcvOff/source/application/EthIf_T140_RxIndication_VLanOff_TrcvOff.c</sourcefile>
      <sourceline>72</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the response of EthIf_RxIndication when EthIf_Init is not called.
  
Test Object: None.
Test Precondition: 
    The modules Eth and EthIf need to be configured:
      Input_EthIf_CtrlIdx = 0 maps to Output_Eth_CtrlIdx = 2
      Input_EthIf_CtrlIdx = 1 maps to Output_Eth_CtrlIdx = 1
      Input_EthIf_CtrlIdx = 2 maps to Output_Eth_CtrlIdx = 0
    EthIfVLANSupportEnable = OFF
    EthIfTrcvSupportEnable = OFF
    EthIf_Init is not called.
  
Test Execution: 
    01: Call function under test with the parameter(s) defined in the input section.
    02: VP: The function Det_ReportError shall be called with the expected output parameter(s).
  
Test Input: 
    EthIf_RxIndication() parameters(s):
      Input_EthIf_CtrlIdx = 0U;
      Input_EthIf_Data[ETHIF_TEST_DATASIZE_32] = {0U};
      Input_EthIf_LenByte = ETHIF_TEST_DATA_BYTENUMBER;
  
Test Output: 
    Det_ReportError() parameter(s):
      Output_Det_ModuleId = ETHIF_MODULE_ID;
      Output_Det_InstanceId = ETHIF_INSTANCE_ID;
      Output_Det_ApiId = ETHIF_CBK_RXINDICATION_SVCID;
      Output_Det_ErrorId = ETHIF_E_NOT_INITIALIZED;
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00086</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>44</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1765</internalId></specobject>
    <specobject>
      <id>EthIf_T140_DET_01_RxIndication_DetInvCtrlIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T100_VLanOff_TrcvOff/source/application/EthIf_T140_RxIndication_VLanOff_TrcvOff.c</sourcefile>
      <sourceline>146</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the response of EthIf_RxIndication when CtrlIdx is invalid.
  
Test Object: None.
Test Precondition: 
    The modules Eth and EthIf need to be configured:
      Input_EthIf_CtrlIdx = 0 maps to Output_Eth_CtrlIdx = 2
      Input_EthIf_CtrlIdx = 1 maps to Output_Eth_CtrlIdx = 1
      Input_EthIf_CtrlIdx = 2 maps to Output_Eth_CtrlIdx = 0
    EthIfVLANSupportEnable = OFF
    EthIfTrcvSupportEnable = OFF
    EthIf_Init is called.
  
Test Execution: 
    01: Call function under test with the parameter(s) defined in the input section.
    02: VP: The function Det_ReportError shall be called with the expected output parameter(s).
  
Test Input: 
    EthIf_RxIndication() parameters(s):
      Input_EthIf_CtrlIdx = 10U;
      Input_EthIf_Data[ETHIF_TEST_DATASIZE_32] = {0U};
      Input_EthIf_LenByte = ETHIF_TEST_DATA_BYTENUMBER;
  
Test Output: 
    Det_ReportError() parameter(s):
      Output_Det_ModuleId = ETHIF_MODULE_ID;
      Output_Det_InstanceId = ETHIF_INSTANCE_ID;
      Output_Det_ApiId = ETHIF_CBK_RXINDICATION_SVCID;
      Output_Det_ErrorId = ETHIF_E_INV_CTRL_IDX;
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00087</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>451</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1766</internalId></specobject>
    <specobject>
      <id>EthIf_T140_DET_02_RxIndication_DetInvParPtr</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T100_VLanOff_TrcvOff/source/application/EthIf_T140_RxIndication_VLanOff_TrcvOff.c</sourcefile>
      <sourceline>224</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the response of EthIf_RxIndication when parameter is a null pointer.
  
Test Object: None.
Test Precondition: 
    The modules Eth and EthIf need to be configured:
      Input_EthIf_CtrlIdx = 0 maps to Output_Eth_CtrlIdx = 2
      Input_EthIf_CtrlIdx = 1 maps to Output_Eth_CtrlIdx = 1
      Input_EthIf_CtrlIdx = 2 maps to Output_Eth_CtrlIdx = 0
    EthIfVLANSupportEnable = OFF
    EthIfTrcvSupportEnable = OFF
    EthIf_Init is called.
  
Test Execution: 
    01: Call function under test with the parameter(s) defined in the input section.
    02: VP: The function Det_ReportError shall be called with the expected output parameter(s).
  
Test Input: 
    EthIf_RxIndication() parameters(s):
      Input_EthIf_CtrlIdx = 0U;
      &amp;Input_EthIf_Data[ETHIF_TEST_DATASIZE_32] = NULL_PTR;
      Input_EthIf_LenByte = ETHIF_TEST_DATA_BYTENUMBER;
  
Test Output: 
    Det_ReportError() parameter(s):
      Output_Det_ModuleId = ETHIF_MODULE_ID;
      Output_Det_InstanceId = ETHIF_INSTANCE_ID;
      Output_Det_ApiId = ETHIF_CBK_RXINDICATION_SVCID;
      Output_Det_ErrorId = ETHIF_E_PARAM_POINTER;
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00088</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>452</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1767</internalId></specobject>
    <specobject>
      <id>EthIf_T140_00_RxIndication_ValidParameters</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T100_VLanOff_TrcvOff/source/application/EthIf_T140_RxIndication_VLanOff_TrcvOff.c</sourcefile>
      <sourceline>299</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the functionality of EthIf_RxIndication function for valid parameters.
  
Test Object: None.
Test Precondition: 
    The modules Eth and EthIf need to be configured:
      Input_EthIf_CtrlIdx = 0 maps to Output_Eth_CtrlIdx = 2
      Input_EthIf_CtrlIdx = 1 maps to Output_Eth_CtrlIdx = 1
      Input_EthIf_CtrlIdx = 2 maps to Output_Eth_CtrlIdx = 0
    EthIfVLANSupportEnable = OFF
    EthIfTrcvSupportEnable = OFF
    EthIf_Init is called.
  
Test Execution: 
    01: Call function under test with the parameter(s) defined in the input section.
    02: VP: The function TcpIp_RxIndication shall be called with the expected output parameter(s).
  
Test Input: 
    Test step 01:
    Test case 0:
    EthIf_RxIndication() parameters(s):
      Input_EthIf_CtrlIdx[0U] = 0U;
      &amp;Input_EthIf_Data[0U][0U] FrameType = Output_TcpIp_FrameType[0U] set in Ethernet data buffer
      Input_EthIf_LenByte[0U] = ETHIF_TEST_DATA_BYTENUMBER;

    Test step 01:
    Test case 1:
    EthIf_RxIndication() parameters(s):
      Input_EthIf_CtrlIdx[1U] = 2U;
      &amp;Input_EthIf_Data[1U][0U] FrameType = Output_TcpIp_FrameType[1U] set in Ethernet data buffer
      Input_EthIf_LenByte[1U] = ETHIF_TEST_DATA_BYTENUMBER;

  
Test Output: 
    Test step 02:
    Test case 0:
    TcpIp_RxIndication parameter(s):
      Output_TcpIp_CtrlIdx[0U] = Input_Eth_CtrlIdx[0U];
      Output_TcpIp_FrameType[0U] = 0x0800U; - IPv4
      Output_TcpIp_PhysAddrPtr[0U] = &amp;Input_EthIf_Data[0U][ETHIF_TEST_MAC_SRC_OFFSET];
      Output_TcpIp_DataPtr[0U] = &amp;Input_EthIf_Data[0U][ETHIF_TEST_DATA_PAYLOAD_OFFSET];
      Output_TcpIp_LenByte[0U] = ETHIF_TEST_DATA_BYTENUMBER - ETHIF_TEST_DATA_PAYLOAD_OFFSET;

    Test step 02:
    Test case 1:
    TcpIp_RxIndication parameter(s):
      Output_TcpIp_CtrlIdx[1U] = Input_Eth_CtrlIdx[1U];
      Output_TcpIp_FrameType[1U] = 0x86DD; - IPv6
      Output_TcpIp_PhysAddrPtr[1U] = &amp;Input_EthIf_Data[1U][ETHIF_TEST_MAC_SRC_OFFSET];
      Output_TcpIp_DataPtr[1U] = &amp;Input_EthIf_Data[1U][ETHIF_TEST_DATA_PAYLOAD_OFFSET];
      Output_TcpIp_LenByte[1U] = ETHIF_TEST_DATA_BYTENUMBER - ETHIF_TEST_DATA_PAYLOAD_OFFSET;
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.ETHIF085_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>142</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1768</internalId></specobject>
    <specobject>
      <id>EthIf_T140_01_GetAndResetMeasurementData</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T100_VLanOff_TrcvOff/source/application/EthIf_T140_RxIndication_VLanOff_TrcvOff.c</sourcefile>
      <sourceline>428</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies functionality of EthIf_GetAndResetMeasurementData() in case that VLAN is not
    enabled, but received datagrams are VLAN tagged.
  
Test Object: 
    EthIf_GetAndResetMeasurementData().
    EthIf_RxIndication().
  
Test Precondition: 
    - EthIf initialized.
    - EthIfVLANSupportEnable = OFF.
    - EthIfGetAndResetMeasurementDataApi = ON.
  
Test Execution: 
    01: VP(SWS_EthIf_91011): Call EthIf_GetAndResetMeasurementData() with measurement index
        ETHIF_MEAS_ALL and reset flag set to TRUE to reset all measurement data.
    02: Call EthIf_GetAndResetMeasurementData() with measurement index ETHIF_MEAS_DROP_CRTLIDX.
    03: VP(SWS_EthIf_00312): Verify that measurement data is set to 0.
    04: Call EthIf_RxIndication() with VLAN tagged datagrams defined number of times.
    05: VP(ETHIF_SEV_DROP_INV_VLAN): Verify that if VLAN is not enabled and frame is VLAN tagged
        event is reported to the IdsM via the IdsM_SetSecurityEvent interface.
    06: Call EthIf_GetAndResetMeasurementData() with measurement index ETHIF_MEAS_DROP_CRTLIDX and
        valid MeasurementDataPtr.
    07: VP(SWS_EthIf_00308, SWS_EthIf_00309, SWS_EthIf_00317): Verify that measurement data equals
        the number of dropped datagrams caused by VLAN not being active.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>731</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00308</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>652</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00309</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>653</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00312</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>655</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00317</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>659</internalId></provcov>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00083</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>848</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1769</internalId></specobject>
    <specobject>
      <id>EthIf_T140_02_DropData_MaxCounterValue</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T100_VLanOff_TrcvOff/source/application/EthIf_T140_RxIndication_VLanOff_TrcvOff.c</sourcefile>
      <sourceline>542</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that measurement data counter does not overrun.
  
Test Object: 
    EthIf_GetAndResetMeasurementData().
    EthIf_RxIndication().
  
Test Precondition: 
    - EthIf initialized.
  
Test Execution: 
    01: Set EthIf_MeasurementData_InvCtrlVLAN counter to maximal value.
    02: Call EthIf_RxIndication() with VLAN tagged datagrams several times.
    03: VP(ETHIF_SEV_DROP_INV_VLAN): Verify that if VLAN is not enabled and frame is VLAN tagged
        event is reported to the IdsM via the IdsM_SetSecurityEvent interface.
    04: Call EthIf_GetAndResetMeasurementData() with measurement index ETHIF_MEAS_DROP_CRTLIDX.
    05: VP(): Verify that Measurement counter did not overrun.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00313</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>656</internalId></provcov>
        <provcov>
          <linksto>EthIf.ECUC_EthIf_00083</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>848</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1770</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EthIf_T150_DET_00_ProvideTxBuffer_DetUninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T100_VLanOff_TrcvOff/source/application/EthIf_T150_ProvideTxBuffer_VLanOff_TrcvOff.c</sourcefile>
      <sourceline>48</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the response of EthIf_ProvideTxBuffer when EthIf_Init is not called.
  
Test Object: None.
Test Precondition: 
    The modules Eth and EthIf need to be configured:
      Input_EthIf_CtrlIdx = 0 maps to Output_Eth_CtrlIdx = 2
      Input_EthIf_CtrlIdx = 1 maps to Output_Eth_CtrlIdx = 1
      Input_EthIf_CtrlIdx = 2 maps to Output_Eth_CtrlIdx = 0
    EthIfVLANSupportEnable = OFF
    EthIfTrcvSupportEnable = OFF
    EthIf_Init is not called.
  
Test Execution: 
    01: Call function under test with the parameter(s) defined in the input section.
    02: VP: The function under test shall return BUFREQ_E_NOT_OK.
    03: VP: The function Det_ReportError shall be called with the expected output parameter(s).
  
Test Input: 
    EthIf_ProvideTxBuffer() parameters(s):
      Input_EthIf_CtrlIdx = 0U;
      Input_EthIf_FrameType = 60000U;
      Input_EthIf_Priority = 5U;
      InOut_EthIf_LenByte = ETHIF_TEST_REQUESTED_BYTES;
  
Test Output: 
    Det_ReportError() parameter(s):
      Output_Det_ModuleId = ETHIF_MODULE_ID;
      Output_Det_InstanceId = ETHIF_INSTANCE_ID;
      Output_Det_ApiId = ETHIF_PROVIDETXBUFFER_SVCID;
      Output_Det_ErrorId = ETHIF_E_NOT_INITIALIZED;
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00069</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>438</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1771</internalId></specobject>
    <specobject>
      <id>EthIf_T150_DET_01_ProvideTxBuffer_DetInvCtrlIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T100_VLanOff_TrcvOff/source/application/EthIf_T150_ProvideTxBuffer_VLanOff_TrcvOff.c</sourcefile>
      <sourceline>139</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the response of EthIf_ProvideTxBuffer when CtrlIdx is invalid.
  
Test Object: None.
Test Precondition: 
    The modules Eth and EthIf need to be configured:
      Input_EthIf_CtrlIdx = 0 maps to Output_Eth_CtrlIdx = 2
      Input_EthIf_CtrlIdx = 1 maps to Output_Eth_CtrlIdx = 1
      Input_EthIf_CtrlIdx = 2 maps to Output_Eth_CtrlIdx = 0
    EthIfVLANSupportEnable = OFF
    EthIfTrcvSupportEnable = OFF
    EthIf_Init is called.
  
Test Execution: 
    01: Call function under test with the parameter(s) defined in the input section.
    02: VP: The function under test shall return E_NOT_OK.
    03: VP: The function Det_ReportError shall be called with the expected output parameter(s).
  
Test Input: 
      EthIf_ProvideTxBuffer() parameters(s):
        Input_EthIf_CtrlIdx = 10U;
        Input_EthIf_FrameType = 60000U;
        Input_EthIf_Priority = 5U;
        InOut_EthIf_LenByte = ETHIF_TEST_REQUESTED_BYTES;
  
Test Output: 
    Det_ReportError() parameter(s):
      Output_Det_ModuleId = ETHIF_MODULE_ID;
      Output_Det_InstanceId = ETHIF_INSTANCE_ID;
      Output_Det_ApiId = ETHIF_PROVIDETXBUFFER_SVCID;
      Output_Det_ErrorId = ETHIF_E_INV_CTRL_IDX;
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00070</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>439</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1772</internalId></specobject>
    <specobject>
      <id>EthIf_T150_DET_02_ProvideTxBuffer_DetInvParPtr_BufIdxPtr</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T100_VLanOff_TrcvOff/source/application/EthIf_T150_ProvideTxBuffer_VLanOff_TrcvOff.c</sourcefile>
      <sourceline>234</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the response of EthIf_ProvideTxBuffer when parameter is a null pointer.
  
Test Object: None.
Test Precondition: 
    The modules Eth and EthIf need to be configured:
      Input_EthIf_CtrlIdx = 0 maps to Output_Eth_CtrlIdx = 2
      Input_EthIf_CtrlIdx = 1 maps to Output_Eth_CtrlIdx = 1
      Input_EthIf_CtrlIdx = 2 maps to Output_Eth_CtrlIdx = 0
    EthIfVLANSupportEnable = OFF
    EthIfTrcvSupportEnable = OFF
    EthIf_Init is called.
  
Test Execution: 
    01: Call function under test with the parameter(s) defined in the input section.
    02: VP: The function under test shall return BUFREQ_E_NOT_OK.
    03: VP: The function Det_ReportError shall be called with the expected output parameter(s).
  
Test Input: 
    EthIf_ProvideTxBuffer() parameters(s):
      Input_EthIf_CtrlIdx = 0U;
      Input_EthIf_FrameType = 60000U;
      Input_EthIf_Priority = 5U;
      &amp;Output_EthIf_BufIdxPtr = NULL_PTR;
      InOut_EthIf_LenByte = ETHIF_TEST_REQUESTED_BYTES;
  
Test Output: 
    Det_ReportError() parameter(s):
      Output_Det_ModuleId = ETHIF_MODULE_ID;
      Output_Det_InstanceId = ETHIF_INSTANCE_ID;
      Output_Det_ApiId = ETHIF_PROVIDETXBUFFER_SVCID;
      Output_Det_ErrorId = ETHIF_E_PARAM_POINTER;
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00071</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>440</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1773</internalId></specobject>
    <specobject>
      <id>EthIf_T150_DET_03_ProvideTxBuffer_DetInvParPtr_BufPtr</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T100_VLanOff_TrcvOff/source/application/EthIf_T150_ProvideTxBuffer_VLanOff_TrcvOff.c</sourcefile>
      <sourceline>330</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the response of EthIf_ProvideTxBuffer when parameter is a null pointer.
  
Test Object: None.
Test Precondition: 
    The modules Eth and EthIf need to be configured:
      Input_EthIf_CtrlIdx = 0 maps to Output_Eth_CtrlIdx = 2
      Input_EthIf_CtrlIdx = 1 maps to Output_Eth_CtrlIdx = 1
      Input_EthIf_CtrlIdx = 2 maps to Output_Eth_CtrlIdx = 0
    EthIfVLANSupportEnable = OFF
    EthIfTrcvSupportEnable = OFF
    EthIf_Init is called.
  
Test Execution: 
    01: Call function under test with the parameter(s) defined in the input section.
    02: VP: The function under test shall return BUFREQ_E_NOT_OK.
    03: VP: The function Det_ReportError shall be called with the expected output parameter(s).
  
Test Input: 
    EthIf_ProvideTxBuffer() parameters(s):
      Input_EthIf_CtrlIdx = 0U;
      Input_EthIf_FrameType = 60000U;
      Input_EthIf_Priority = 5U;
      &amp;Output_EthIf_BufPtr = NULL_PTR;
      InOut_EthIf_LenByte = ETHIF_TEST_REQUESTED_BYTES;
  
Test Output: 
    Det_ReportError() parameter(s):
      Output_Det_ModuleId = ETHIF_MODULE_ID;
      Output_Det_InstanceId = ETHIF_INSTANCE_ID;
      Output_Det_ApiId = ETHIF_PROVIDETXBUFFER_SVCID;
      Output_Det_ErrorId = ETHIF_E_PARAM_POINTER;
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00072</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>441</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1774</internalId></specobject>
    <specobject>
      <id>EthIf_T150_DET_04_ProvideTxBuffer_DetInvParPtr_LenBytePtr</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T100_VLanOff_TrcvOff/source/application/EthIf_T150_ProvideTxBuffer_VLanOff_TrcvOff.c</sourcefile>
      <sourceline>426</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the response of EthIf_ProvideTxBuffer when parameter is a null pointer.
  
Test Object: None.
Test Precondition: 
    The modules Eth and EthIf need to be configured:
      Input_EthIf_CtrlIdx = 0 maps to Output_Eth_CtrlIdx = 2
      Input_EthIf_CtrlIdx = 1 maps to Output_Eth_CtrlIdx = 1
      Input_EthIf_CtrlIdx = 2 maps to Output_Eth_CtrlIdx = 0
    EthIfVLANSupportEnable = OFF
    EthIfTrcvSupportEnable = OFF
    EthIf_Init is called.
  
Test Execution: 
    01: Call function under test with the parameter(s) defined in the input section.
    02: VP: The function under test shall return BUFREQ_E_NOT_OK.
    03: VP: The function Det_ReportError shall be called with the expected output parameter(s).
  
Test Input: 
    EthIf_ProvideTxBuffer() parameters(s):
      Input_EthIf_CtrlIdx = 0U;
      Input_EthIf_FrameType = 60000U;
      Input_EthIf_Priority = 5U;
      &amp;InOut_EthIf_LenByte = NULL_PTR;
  
Test Output: 
    Det_ReportError() parameter(s):
      Output_Det_ModuleId = ETHIF_MODULE_ID;
      Output_Det_InstanceId = ETHIF_INSTANCE_ID;
      Output_Det_ApiId = ETHIF_PROVIDETXBUFFER_SVCID;
      Output_Det_ErrorId = ETHIF_E_PARAM_POINTER;
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00073</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>442</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1775</internalId></specobject>
    <specobject>
      <id>EthIf_T150_00_ProvideTxBuffer_ValidParameters</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T100_VLanOff_TrcvOff/source/application/EthIf_T150_ProvideTxBuffer_VLanOff_TrcvOff.c</sourcefile>
      <sourceline>517</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the functionality of EthIf_ProvideTxBuffer function for valid parameters.
    Also check that if CtrlIdx refers to an EthIfCtrl where no EthIfVlanID is configured,
    the parameters FrameType and Priority are not used.
  
Test Object: None.
Test Precondition: 
    The modules Eth and EthIf need to be configured:
      Input_EthIf_CtrlIdx = 0 maps to Output_Eth_CtrlIdx = 2
      Input_EthIf_CtrlIdx = 1 maps to Output_Eth_CtrlIdx = 1
      Input_EthIf_CtrlIdx = 2 maps to Output_Eth_CtrlIdx = 0
    EthIfVLANSupportEnable = OFF
    EthIfTrcvSupportEnable = OFF
    EthIf_Init is called.
    A buffer for the Ethernet stub is required.
    A buffer index for the Ethernet stub is required.
    A controller is in state ACTIVE.
  
Test Execution: 
    01: Call function under test with the parameter(s) defined in the input section.
    02: VP(EthIf.SWS_EthIf_00068.1): The function under test shall return BUFREQ_E_OK.
    03: VP(EthIf.SWS_EthIf_00068.1):
        The function Eth_ProvideTxBuffer shall be called with the expected output parameter(s).
    04: VP(EthIf.ASR43.SWS_EthIf_00146): Verify that the buffer pointer and the length are not
        modified by EthIf, therefore frame type and priority are not added to payload.
  
Test Input: 
    Test step 01:
    Test case 00:
    EthIf_ProvideTxBuffer() parameters(s):
      Input_EthIf_CtrlIdx[0U] = 0U;
      Input_EthIf_FrameType[0U] = 60000U;
      Input_EthIf_Priority[0U] = 7U;
      InOut_EthIf_LenByte[0U] = ETHIF_TEST_REQUESTED_BYTES;

    Test step 01:
    Test case 01:
    EthIf_ProvideTxBuffer() parameters(s):
      Input_EthIf_CtrlIdx[1U] = 2U;
      Input_EthIf_FrameType[1U] = 12U;
      Input_EthIf_Priority[1U] = 5U;
      InOut_EthIf_LenByte[1U] = ETHIF_TEST_REQUESTED_BYTES;

  
Test Output: 
    Test step 03:
    Test case 00:
    Eth_ProvideTxBuffer() parameters(s):
        Output_Eth_CtrlIdx[0U] = 2U;

    EthIf_ProvideTxBuffer() parameters(s):
      Output_EthIf_BufIdxPtr[0U] = 12U;
      *Output_EthIf_BufPtr[0U] = Output_Eth_BufPtr;
      InOut_EthIf_LenByte[0U] = ETHIF_TEST_REQUESTED_BYTES;

    Test step 03:
    Test case 01:
    Eth_ProvideTxBuffer() parameters(s):
      Output_Eth_CtrlIdx[1U] = 0U;

    EthIf_ProvideTxBuffer() parameters(s):
      Output_EthIf_BufIdxPtr[1U] = 12U;
      *Output_EthIf_BufPtr[1U] = Output_Eth_BufPtr;
      InOut_EthIf_LenByte[1U] = ETHIF_TEST_REQUESTED_BYTES;
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00068.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>940</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00146</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>504</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1776</internalId></specobject>
    <specobject>
      <id>EthIf_T150_01_ProvideTxBuffer_ValidParameters</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T100_VLanOff_TrcvOff/source/application/EthIf_T150_ProvideTxBuffer_VLanOff_TrcvOff.c</sourcefile>
      <sourceline>674</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the functionality of EthIf_ProvideTxBuffer function for valid parameters.
    Also check that if CtrlIdx refers to an EthIfCtrl where no EthIfVlanID is configured,
    the parameters FrameType and Priority are not used.
  
Test Object: None.
Test Precondition: 
    The modules Eth and EthIf need to be configured:
      Input_EthIf_CtrlIdx = 0 maps to Output_Eth_CtrlIdx = 2
      Input_EthIf_CtrlIdx = 1 maps to Output_Eth_CtrlIdx = 1
      Input_EthIf_CtrlIdx = 2 maps to Output_Eth_CtrlIdx = 0
    EthIfVLANSupportEnable = OFF
    EthIfTrcvSupportEnable = OFF
    EthIf_Init is called.
    A buffer for the Ethernet stub is required.
    A buffer index for the Ethernet stub is required.
    A controller is in state ACTIVE_WITH_WAKEUP_REQUEST.
  
Test Execution: 
    01: Call function under test with the parameter(s) defined in the input section.
    02: VP(EthIf.SWS_EthIf_00068.2): The function under test shall return BUFREQ_E_OK.
    03: VP(EthIf.SWS_EthIf_00068.2):
        The function Eth_ProvideTxBuffer shall be called with the expected output parameter(s).
    04: VP(EthIf.ASR43.SWS_EthIf_00146): Verify that the buffer pointer and the length are not
        modified by EthIf, therefore frame type and priority are not added to payload.
  
Test Input: 
    Test step 01:
    Test case 00:
    EthIf_ProvideTxBuffer() parameters(s):
      Input_EthIf_CtrlIdx[0U] = 0U;
      Input_EthIf_FrameType[0U] = 60000U;
      Input_EthIf_Priority[0U] = 7U;
      InOut_EthIf_LenByte[0U] = ETHIF_TEST_REQUESTED_BYTES;

    Test step 01:
    Test case 01:
    EthIf_ProvideTxBuffer() parameters(s):
      Input_EthIf_CtrlIdx[1U] = 2U;
      Input_EthIf_FrameType[1U] = 12U;
      Input_EthIf_Priority[1U] = 5U;
      InOut_EthIf_LenByte[1U] = ETHIF_TEST_REQUESTED_BYTES;

  
Test Output: 
    Test step 03:
    Test case 00:
    Eth_ProvideTxBuffer() parameters(s):
        Output_Eth_CtrlIdx[0U] = 2U;

    EthIf_ProvideTxBuffer() parameters(s):
      Output_EthIf_BufIdxPtr[0U] = 12U;
      *Output_EthIf_BufPtr[0U] = Output_Eth_BufPtr;
      InOut_EthIf_LenByte[0U] = ETHIF_TEST_REQUESTED_BYTES;

    Test step 03:
    Test case 01:
    Eth_ProvideTxBuffer() parameters(s):
      Output_Eth_CtrlIdx[1U] = 0U;

    EthIf_ProvideTxBuffer() parameters(s):
      Output_EthIf_BufIdxPtr[1U] = 12U;
      *Output_EthIf_BufPtr[1U] = Output_Eth_BufPtr;
      InOut_EthIf_LenByte[1U] = ETHIF_TEST_REQUESTED_BYTES;
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00068.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>941</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00146</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>504</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1777</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EthIf_T160_DET_00_GetPhysAddr_DetUninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T100_VLanOff_TrcvOff/source/application/EthIf_T160_GetPhysAddr_VLanOff_TrcvOff.c</sourcefile>
      <sourceline>43</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the response of EthIf_GetPhysAddr when EthIf_Init is not called.
  
Test Object: None.
Test Precondition: 
    The modules Eth and EthIf need to be configured:
      Input_EthIf_CtrlIdx = 0 maps to Output_Eth_CtrlIdx = 2
      Input_EthIf_CtrlIdx = 1 maps to Output_Eth_CtrlIdx = 1
      Input_EthIf_CtrlIdx = 2 maps to Output_Eth_CtrlIdx = 0
    EthIfVLANSupportEnable = OFF
    EthIfTrcvSupportEnable = OFF
    EthIf_Init is not called.
    Eth_GetPhyAddr() configuration(s):
      Set first byte (PhysAddrPtr_Out) of MAC address to 12U.
  
Test Execution: 
    01: Call function under test with the parameter(s) defined in the input section.
    02: VP: The function Det_ReportError shall be called with the expected output parameter(s).
  
Test Input: 
    EthIf_GetPhysAddr() parameters(s):
      Input_EthIf_CtrlIdx= 0U;
  
Test Output: 
    Det_ReportError() parameter(s):
      Output_Det_ModuleId = ETHIF_MODULE_ID;
      Output_Det_InstanceId = ETHIF_INSTANCE_ID;
      Output_Det_ApiId = ETHIF_GETPHYSADDR_SVCID;
      Output_Det_ErrorId = ETHIF_E_NOT_INITIALIZED;
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00061</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>432</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00063</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>42</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1778</internalId></specobject>
    <specobject>
      <id>EthIf_T160_DET_01_GetPhysAddr_DetInvCtrlIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T100_VLanOff_TrcvOff/source/application/EthIf_T160_GetPhysAddr_VLanOff_TrcvOff.c</sourcefile>
      <sourceline>118</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the response of EthIf_GetPhysAddr when CtrlIdx is invalid.
  
Test Object: None.
Test Precondition: 
    The modules Eth and EthIf need to be configured:
      Input_EthIf_CtrlIdx = 0 maps to Output_Eth_CtrlIdx = 2
      Input_EthIf_CtrlIdx = 1 maps to Output_Eth_CtrlIdx = 1
      Input_EthIf_CtrlIdx = 2 maps to Output_Eth_CtrlIdx = 0
    EthIfVLANSupportEnable = OFF
    EthIfTrcvSupportEnable = OFF
    EthIf_Init is called
    Eth_GetPhyAddr() configuration(s):
      Set first byte (PhysAddrPtr_Out) of MAC address to 12U.
  
Test Execution: 
    01: Call function under test with the parameter(s) defined in the input section.
    02: VP: The function Det_ReportError shall be called with the expected output parameter(s).
  
Test Input: 
    EthIf_GetPhysAddr() parameters(s):
      Input_EthIf_CtrlIdx= 10U;
  
Test Output: 
    Det_ReportError() parameter(s):
      Output_Det_ModuleId = ETHIF_MODULE_ID;
      Output_Det_InstanceId = ETHIF_INSTANCE_ID;
      Output_Det_ApiId = ETHIF_GETPHYSADDR_SVCID;
      Output_Det_ErrorId = ETHIF_E_INV_CTRL_IDX;
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00061</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>432</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00064</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>435</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1779</internalId></specobject>
    <specobject>
      <id>EthIf_T160_DET_02_GetPhysAddr_DetInvParPtr</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T100_VLanOff_TrcvOff/source/application/EthIf_T160_GetPhysAddr_VLanOff_TrcvOff.c</sourcefile>
      <sourceline>196</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the response of EthIf_GetPhysAddr when parameter is a null pointer.
  
Test Object: None.
Test Precondition: 
    The modules Eth and EthIf need to be configured:
      Input_EthIf_CtrlIdx = 0 maps to Output_Eth_CtrlIdx = 2
      Input_EthIf_CtrlIdx = 1 maps to Output_Eth_CtrlIdx = 1
      Input_EthIf_CtrlIdx = 2 maps to Output_Eth_CtrlIdx = 0
    EthIfVLANSupportEnable = OFF
    EthIfTrcvSupportEnable = OFF
    EthIf_Init is called
    Eth_GetPhyAddr() configuration(s):
      Set first byte (PhysAddrPtr_Out) of MAC address to 12U.
  
Test Execution: 
    01: Call function under test with the parameter(s) defined in the input section.
    02: VP: The function Det_ReportError shall be called with the expected output parameter(s).
  
Test Input: 
    EthIf_GetPhysAddr() parameters(s):
      Input_EthIf_CtrlIdx= 0U;
      &amp;Output_EthIf_PhysAddr = NULL_PTR;
  
Test Output: 
    Det_ReportError() parameter(s):
      Output_Det_ModuleId = ETHIF_MODULE_ID;
      Output_Det_InstanceId = ETHIF_INSTANCE_ID;
      Output_Det_ApiId = ETHIF_GETPHYSADDR_SVCID;
      Output_Det_ErrorId = ETHIF_E_PARAM_POINTER;
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00061</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>432</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00065</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>436</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1780</internalId></specobject>
    <specobject>
      <id>EthIf_T160_00_GetPhysAddr_ValidParameters</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T100_VLanOff_TrcvOff/source/application/EthIf_T160_GetPhysAddr_VLanOff_TrcvOff.c</sourcefile>
      <sourceline>272</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the functionality of EthIf_GetPhysAddr function for valid parameters.
  
Test Object: None.
Test Precondition: 
    The modules Eth and EthIf need to be configured:
      Input_EthIf_CtrlIdx = 0 maps to Output_Eth_CtrlIdx = 2
      Input_EthIf_CtrlIdx = 1 maps to Output_Eth_CtrlIdx = 1
      Input_EthIf_CtrlIdx = 2 maps to Output_Eth_CtrlIdx = 0
    EthIfVLANSupportEnable = OFF
    EthIfTrcvSupportEnable = OFF
    EthIf_Init is called
    Eth_GetPhyAddr() configuration(s) (Set first byte of MAC address):
      Input_Eth_PhysAddrPtr_Out[0U] = 12U;
      Input_Eth_PhysAddrPtr_Out[1U] = 34U;
  
Test Execution: 
    01: Call function under test with the parameter(s) defined in the input section.
    02: VP(SWS_EthIf_00061, SWS_EthIf_00062, SWS_EthIf_00111):
        Verify that Ethernet controller driver function Eth_GetPhysAddr() was called.
        Verify that that the function is called with expected output parameter(s) and shall return
        the proper MAC address.
  
Test Input: 
    Test step 01:
    Test case 0-1:
    EthIf_GetPhysAddr parameter(s):
      Input_EthIf_CtrlIdx[0U] = 1U;
      Input_EthIf_CtrlIdx[1U] = 0U;
  
Test Output: 
    Test step 02:
    Test case 0-1:
    Eth_GetPhysAddr parameter(s):
      Output_Eth_CtrlIdx[0U] = 1U;
      Output_Eth_CtrlIdx[1U] = 2U;
    EthIf_GetPhysAddr parameter(s):
      Output_EthIf_PhysAddr[0U] = Input_Eth_PhysAddrPtr_Out[0U];
      Output_EthIf_PhysAddr[1U] = Input_Eth_PhysAddrPtr_Out[1U];
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00061</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>432</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00062</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>433</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00111</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>469</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1781</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EthIf_T330_DET_00_Transmit_DetUninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T300_VLan_TrcvOff/source/application/EthIf_T330_Transmit_VLan_TrcvOff.c</sourcefile>
      <sourceline>44</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the response of EthIf_Transmit when EthIf_Init is not called.
  
Test Object: None.
Test Precondition: 
    The modules Eth and EthIf need to be configured:
      Input_EthIf_CtrlIdx = 0 maps to Output_Eth_CtrlIdx = 1 (no VLAN)
      Input_EthIf_CtrlIdx = 1 maps to Output_Eth_CtrlIdx = 2 and Output_Eth_VID = 2
      Input_EthIf_CtrlIdx = 2 maps to Output_Eth_CtrlIdx = 2 and Output_Eth_VID = 4095
      Input_EthIf_CtrlIdx = 3 maps to Output_Eth_CtrlIdx = 2 and Output_Eth_VID = 0
    EthIfVLANSupportEnable = ON
    EthIfTrcvSupportEnable = OFF
    EthIf_Init is not called.
  
Test Execution: 
    01: Call function under test with the parameter(s) defined in the input section.
    02: VP: The function under test shall return E_NOT_OK.
    03: VP: The function Det_ReportError shall be called with the expected output parameter(s).
  
Test Input: 
    EthIf_Transmit() parameters(s):
      Input_EthIf_CtrlIdx = 0U;
      Input_EthIf_BufIdx = 12U;
      Input_EthIf_FrameType = 65535U;
      Input_EthIf_TxConfirmation = true;
      Input_EthIf_LenByte = 30U;
      Input_EthIf_PhysAddr[6U] = {1U, 2U, 3U, 4U, 5U, 6U};
  
Test Output: 
    Det_ReportError() parameter(s):
      Output_Det_ModuleId = ETHIF_MODULE_ID;
      Output_Det_InstanceId = ETHIF_INSTANCE_ID;
      Output_Det_ApiId = ETHIF_TRANSMIT_SVCID;
      Output_Det_ErrorId = ETHIF_E_NOT_INITIALIZED;
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00077</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>43</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1782</internalId></specobject>
    <specobject>
      <id>EthIf_T330_DET_01_Transmit_DetInvCtrlIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T300_VLan_TrcvOff/source/application/EthIf_T330_Transmit_VLan_TrcvOff.c</sourcefile>
      <sourceline>127</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the response of EthIf_Transmit when CtrlIdx is invalid.
  
Test Object: None.
Test Precondition: 
    The modules Eth and EthIf need to be configured:
      Input_EthIf_CtrlIdx = 0 maps to Output_Eth_CtrlIdx = 1 (no VLAN)
      Input_EthIf_CtrlIdx = 1 maps to Output_Eth_CtrlIdx = 2 and Output_Eth_VID = 2
      Input_EthIf_CtrlIdx = 2 maps to Output_Eth_CtrlIdx = 2 and Output_Eth_VID = 4095
      Input_EthIf_CtrlIdx = 3 maps to Output_Eth_CtrlIdx = 2 and Output_Eth_VID = 0
    EthIfVLANSupportEnable = ON
    EthIfTrcvSupportEnable = OFF
    EthIf_Init is called.
  
Test Execution: 
    01: Call function under test with the parameter(s) defined in the input section.
    02: VP: The function under test shall return E_NOT_OK.
    03: VP: The function Det_ReportError shall be called with the expected output parameter(s).
  
Test Input: 
    EthIf_Transmit() parameters(s):
      Input_EthIf_CtrlIdx = 10U;
      Input_EthIf_BufIdx = 12U;
      Input_EthIf_FrameType = 65535U;
      Input_EthIf_TxConfirmation = true;
      Input_EthIf_LenByte = 30U;
      Input_EthIf_PhysAddr[6U] = {1U, 2U, 3U, 4U, 5U, 6U};
  
Test Output: 
    Det_ReportError() parameter(s):
      Output_Det_ModuleId = ETHIF_MODULE_ID;
      Output_Det_InstanceId = ETHIF_INSTANCE_ID;
      Output_Det_ApiId = ETHIF_TRANSMIT_SVCID;
      Output_Det_ErrorId = ETHIF_E_INV_CTRL_IDX;
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00078</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>445</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1783</internalId></specobject>
    <specobject>
      <id>EthIf_T330_DET_02_Transmit_DetInvParPtr</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T300_VLan_TrcvOff/source/application/EthIf_T330_Transmit_VLan_TrcvOff.c</sourcefile>
      <sourceline>215</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the response of EthIf_Transmit when parameter is a null pointer.
  
Test Object: None.
Test Precondition: 
    The modules Eth and EthIf need to be configured:
      Input_EthIf_CtrlIdx = 0 maps to Output_Eth_CtrlIdx = 1 (no VLAN)
      Input_EthIf_CtrlIdx = 1 maps to Output_Eth_CtrlIdx = 2 and Output_Eth_VID = 2
      Input_EthIf_CtrlIdx = 2 maps to Output_Eth_CtrlIdx = 2 and Output_Eth_VID = 4095
      Input_EthIf_CtrlIdx = 3 maps to Output_Eth_CtrlIdx = 2 and Output_Eth_VID = 0
    EthIfVLANSupportEnable = ON
    EthIfTrcvSupportEnable = OFF
    EthIf_Init is called.
  
Test Execution: 
    01: Call function under test with the parameter(s) defined in the input section.
    02: VP: The function under test shall return E_NOT_OK.
    03: VP: The function Det_ReportError shall be called with the expected output parameter(s).
  
Test Input: 
    EthIf_Transmit() parameters(s):
      Input_EthIf_CtrlIdx = 10U;
      Input_EthIf_BufIdx = 12U;
      Input_EthIf_FrameType = 65535U;
      Input_EthIf_TxConfirmation = true;
      Input_EthIf_LenByte = 30U;
      &amp;Input_EthIf_PhysAddr = NULL_PTR;
  
Test Output: 
    Det_ReportError() parameter(s):
      Output_Det_ModuleId = ETHIF_MODULE_ID;
      Output_Det_InstanceId = ETHIF_INSTANCE_ID;
      Output_Det_ApiId = ETHIF_TRANSMIT_SVCID;
      Output_Det_ErrorId = ETHIF_E_PARAM_POINTER;
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00080</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>447</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1784</internalId></specobject>
    <specobject>
      <id>EthIf_T330_00_Transmit_ValidParameters</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T300_VLan_TrcvOff/source/application/EthIf_T330_Transmit_VLan_TrcvOff.c</sourcefile>
      <sourceline>301</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the functionality of EthIf_Transmit function for valid parameters.
  
Test Object: None.
Test Precondition: 
    The modules Eth and EthIf need to be configured:
      Input_EthIf_CtrlIdx = 0 maps to Output_Eth_CtrlIdx = 1 (no VLAN)
      Input_EthIf_CtrlIdx = 1 maps to Output_Eth_CtrlIdx = 2 and Output_Eth_VID = 2
      Input_EthIf_CtrlIdx = 2 maps to Output_Eth_CtrlIdx = 2 and Output_Eth_VID = 4095
      Input_EthIf_CtrlIdx = 3 maps to Output_Eth_CtrlIdx = 2 and Output_Eth_VID = 0
    EthIfVLANSupportEnable = ON
    EthIfTrcvSupportEnable = OFF
    EthIf_Init is called.
    A controller is in state ACTIVE.
  
Test Execution: 
    01: Call function under test with the parameter(s) defined in the input section.
    02: VP: The function under test shall return E_OK.
    03: VP: The function Eth_Transmit shall be called with the expected output parameter(s).
    04: VP(SWS_EthIf_00250): For all controllers with VLAN the frame type will be replaced by 0x8100.
    05: VP: For all controllers with VLAN the buffer size at Ethernet level needs to be 4 bytes bigger.
  
Test Input: 
    Test step 01:
    Test case 0:
    EthIf_Transmit() parameters(s):
      Input_EthIf_CtrlIdx[0U] = 0U;
      Input_EthIf_BufIdx[0U] = 12U;
      Input_EthIf_FrameType[0U] = 65535U;
      Input_EthIf_TxConfirmation = true;
      Input_EthIf_LenByte[0U] = 30U;
      Input_EthIf_PhysAddr[0U][6U] = {1U, 2U, 3U, 4U, 5U, 6U};

    Test step 01:
    Test case 1:
    EthIf_Transmit() parameters(s):
      Input_EthIf_CtrlIdx[1U] = 2U;
      Input_EthIf_BufIdx[1U] = 14U;
      Input_EthIf_FrameType[1U] = 12U;
      Input_EthIf_TxConfirmation = true;
      Input_EthIf_LenByte[1U] = 16U;
      Input_EthIf_PhysAddr[1U][6U] = {11U, 12U, 13U, 14U, 15U, 16U};
  
Test Output: 
    Test step 03:
    Test case 0:
    Eth_Transmit parameter(s):
      Output_Eth_CtrlIdx[0U] = 1U;
      Output_Eth_BufIdx[0U] = Input_EthIf_BufIdx[0];
      Output_Eth_FrameType[0U] = Input_EthIf_FrameType[0U];
      Output_Eth_LenByte[0U] = Input_EthIf_LenByte[0U];
      Output_Eth_PhysAddrPtr[0U] = &amp;Input_EthIf_PhysAddr[0U];

    Test step 03,04,05:
    Test case 1:
    Eth_Transmit parameter(s):
      Output_Eth_CtrlIdx[1U] = 2U; VLAN
      Output_Eth_BufIdx[1U] = Input_EthIf_BufIdx[1U];
      Output_Eth_FrameType[1U] = 0x8100U;
      Output_Eth_LenByte[1U] = Input_EthIf_LenByte[1U] + 4U;
      Output_Eth_PhysAddrPtr[1U] = &amp;Input_EthIf_PhysAddr[1U];
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00076.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>944</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.ECUC_EthIf_00029_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>94</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00250</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>574</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1785</internalId></specobject>
    <specobject>
      <id>EthIf_T330_01_Transmit_ValidParameters</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T300_VLan_TrcvOff/source/application/EthIf_T330_Transmit_VLan_TrcvOff.c</sourcefile>
      <sourceline>457</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the functionality of EthIf_Transmit function for valid parameters.
  
Test Object: None.
Test Precondition: 
    The modules Eth and EthIf need to be configured:
      Input_EthIf_CtrlIdx = 0 maps to Output_Eth_CtrlIdx = 1 (no VLAN)
      Input_EthIf_CtrlIdx = 1 maps to Output_Eth_CtrlIdx = 2 and Output_Eth_VID = 2
      Input_EthIf_CtrlIdx = 2 maps to Output_Eth_CtrlIdx = 2 and Output_Eth_VID = 4095
      Input_EthIf_CtrlIdx = 3 maps to Output_Eth_CtrlIdx = 2 and Output_Eth_VID = 0
    EthIfVLANSupportEnable = ON
    EthIfTrcvSupportEnable = OFF
    EthIf_Init is called.
    A controller is in state ACTIVE_WITH_WAKEUP_REQUEST.
  
Test Execution: 
    01: Call function under test with the parameter(s) defined in the input section.
    02: VP: The function under test shall return E_OK.
    03: VP: The function Eth_Transmit shall be called with the expected output parameter(s).
    04: VP(SWS_EthIf_00250): For all controllers with VLAN the frame type will be replaced by 0x8100.
    05: VP: For all controllers with VLAN the buffer size at Ethernet level needs to be 4 bytes bigger.
  
Test Input: 
    Test step 01:
    Test case 0:
    EthIf_Transmit() parameters(s):
      Input_EthIf_CtrlIdx[0U] = 0U;
      Input_EthIf_BufIdx[0U] = 12U;
      Input_EthIf_FrameType[0U] = 65535U;
      Input_EthIf_TxConfirmation = true;
      Input_EthIf_LenByte[0U] = 30U;
      Input_EthIf_PhysAddr[0U][6U] = {1U, 2U, 3U, 4U, 5U, 6U};

    Test step 01:
    Test case 1:
    EthIf_Transmit() parameters(s):
      Input_EthIf_CtrlIdx[1U] = 2U;
      Input_EthIf_BufIdx[1U] = 14U;
      Input_EthIf_FrameType[1U] = 12U;
      Input_EthIf_TxConfirmation = true;
      Input_EthIf_LenByte[1U] = 16U;
      Input_EthIf_PhysAddr[1U][6U] = {11U, 12U, 13U, 14U, 15U, 16U};
  
Test Output: 
    Test step 03:
    Test case 0:
    Eth_Transmit parameter(s):
      Output_Eth_CtrlIdx[0U] = 1U;
      Output_Eth_BufIdx[0U] = Input_EthIf_BufIdx[0];
      Output_Eth_FrameType[0U] = Input_EthIf_FrameType[0U];
      Output_Eth_LenByte[0U] = Input_EthIf_LenByte[0U];
      Output_Eth_PhysAddrPtr[0U] = &amp;Input_EthIf_PhysAddr[0U];

    Test step 03,04,05:
    Test case 1:
    Eth_Transmit parameter(s):
      Output_Eth_CtrlIdx[1U] = 2U; VLAN
      Output_Eth_BufIdx[1U] = Input_EthIf_BufIdx[1U];
      Output_Eth_FrameType[1U] = 0x8100U;
      Output_Eth_LenByte[1U] = Input_EthIf_LenByte[1U] + 4U;
      Output_Eth_PhysAddrPtr[1U] = &amp;Input_EthIf_PhysAddr[1U];
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00076.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>945</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.ECUC_EthIf_00029_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>94</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00250</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>574</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1786</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EthIf_T340_DET_00_RxIndication_DetUninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T300_VLan_TrcvOff/source/application/EthIf_T340_RxIndication_VLan_TrcvOff.c</sourcefile>
      <sourceline>90</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the response of EthIf_RxIndication when EthIf_Init is not called.
  
Test Object: None.
Test Precondition: 
    The modules Eth and EthIf need to be configured:
      Input_EthIf_CtrlIdx = 0 maps to Output_Eth_CtrlIdx = 1 (no VLAN)
      Input_EthIf_CtrlIdx = 1 maps to Output_Eth_CtrlIdx = 2 and Input_Eth_VID = 2
      Input_EthIf_CtrlIdx = 2 maps to Output_Eth_CtrlIdx = 2 and Input_Eth_VID = 4094
      Input_EthIf_CtrlIdx = 3 maps to Output_Eth_CtrlIdx = 2 and Input_Eth_VID = 1
    EthIfVLANSupportEnable = ON
    EthIfTrcvSupportEnable = OFF
    EthIf_Init is not called.
  
Test Execution: 
    01: Call function under test with the parameter(s) defined in the input section.
    02: VP: The function Det_ReportError shall be called with the expected output parameter(s).
  
Test Input: 
    EthIf_RxIndication() parameters(s):
      Input_EthIf_CtrlIdx = 0U;
      Input_EthIf_Data[ETHIF_TEST_DATASIZE_32] = {0U};
      Input_EthIf_LenByte = ETHIF_TEST_DATA_BYTENUMBER;
  
Test Output: 
    Det_ReportError() parameter(s):
      Output_Det_ModuleId = ETHIF_MODULE_ID;
      Output_Det_InstanceId = ETHIF_INSTANCE_ID;
      Output_Det_ApiId = ETHIF_CBK_RXINDICATION_SVCID;
      Output_Det_ErrorId = ETHIF_E_NOT_INITIALIZED;
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00086</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>44</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1787</internalId></specobject>
    <specobject>
      <id>EthIf_T340_DET_01_RxIndication_DetInvCtrlIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T300_VLan_TrcvOff/source/application/EthIf_T340_RxIndication_VLan_TrcvOff.c</sourcefile>
      <sourceline>165</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the response of EthIf_RxIndication when CtrlIdx is invalid.
  
Test Object: None.
Test Precondition: 
    The modules Eth and EthIf need to be configured:
      Input_EthIf_CtrlIdx = 0 maps to Output_Eth_CtrlIdx = 1 (no VLAN)
      Input_EthIf_CtrlIdx = 1 maps to Output_Eth_CtrlIdx = 2 and Input_Eth_VID = 2
      Input_EthIf_CtrlIdx = 2 maps to Output_Eth_CtrlIdx = 2 and Input_Eth_VID = 4094
      Input_EthIf_CtrlIdx = 3 maps to Output_Eth_CtrlIdx = 2 and Input_Eth_VID = 1
    EthIfVLANSupportEnable = ON
    EthIfTrcvSupportEnable = OFF
    EthIf_Init is called.
  
Test Execution: 
    01: Call function under test with the parameter(s) defined in the input section.
    02: VP: The function Det_ReportError shall be called with the expected output parameter(s).
  
Test Input: 
    EthIf_RxIndication() parameters(s):
      Input_EthIf_CtrlIdx = 10U;
      Input_EthIf_Data[ETHIF_TEST_DATASIZE_32] = {0U};
      Input_EthIf_LenByte = ETHIF_TEST_DATA_BYTENUMBER;
  
Test Output: 
    Det_ReportError() parameter(s):
      Output_Det_ModuleId = ETHIF_MODULE_ID;
      Output_Det_InstanceId = ETHIF_INSTANCE_ID;
      Output_Det_ApiId = ETHIF_CBK_RXINDICATION_SVCID;
      Output_Det_ErrorId = ETHIF_E_INV_CTRL_IDX;
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00087</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>451</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1788</internalId></specobject>
    <specobject>
      <id>EthIf_T340_DET_02_RxIndication_DetInvParPtr</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T300_VLan_TrcvOff/source/application/EthIf_T340_RxIndication_VLan_TrcvOff.c</sourcefile>
      <sourceline>244</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the response of EthIf_RxIndication when parameter is a null pointer.
  
Test Object: None.
Test Precondition: 
    The modules Eth and EthIf need to be configured:
      Input_EthIf_CtrlIdx = 0 maps to Output_Eth_CtrlIdx = 1 (no VLAN)
      Input_EthIf_CtrlIdx = 1 maps to Output_Eth_CtrlIdx = 2 and Input_Eth_VID = 2
      Input_EthIf_CtrlIdx = 2 maps to Output_Eth_CtrlIdx = 2 and Input_Eth_VID = 4094
      Input_EthIf_CtrlIdx = 3 maps to Output_Eth_CtrlIdx = 2 and Input_Eth_VID = 1
    EthIfVLANSupportEnable = ON
    EthIfTrcvSupportEnable = OFF
    EthIf_Init is called.
  
Test Execution: 
    01: Call function under test with the parameter(s) defined in the input section.
    02: VP: The function Det_ReportError shall be called with the expected output parameter(s).
  
Test Input: 
    EthIf_RxIndication() parameters(s):
      Input_EthIf_CtrlIdx = 0U;
      &amp;Input_EthIf_Data[ETHIF_TEST_DATASIZE_32] = NULL_PTR;
      Input_EthIf_LenByte = ETHIF_TEST_DATA_BYTENUMBER;
  
Test Output: 
    Det_ReportError() parameter(s):
      Output_Det_ModuleId = ETHIF_MODULE_ID;
      Output_Det_InstanceId = ETHIF_INSTANCE_ID;
      Output_Det_ApiId = ETHIF_CBK_RXINDICATION_SVCID;
      Output_Det_ErrorId = ETHIF_E_PARAM_POINTER;
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00088</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>452</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1789</internalId></specobject>
    <specobject>
      <id>EthIf_T340_00_RxIndication_NoVLanControllers</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T300_VLan_TrcvOff/source/application/EthIf_T340_RxIndication_VLan_TrcvOff.c</sourcefile>
      <sourceline>320</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the functionality of EthIf_RxIndication function for valid parameters.
  
Test Object: None.
Test Precondition: 
    The modules Eth and EthIf need to be configured:
      Input_EthIf_CtrlIdx = 0 maps to Output_Eth_CtrlIdx = 1 (no VLAN)
      Input_EthIf_CtrlIdx = 1 maps to Output_Eth_CtrlIdx = 2 and Input_Eth_VID = 2
      Input_EthIf_CtrlIdx = 2 maps to Output_Eth_CtrlIdx = 2 and Input_Eth_VID = 4094
      Input_EthIf_CtrlIdx = 3 maps to Output_Eth_CtrlIdx = 2 and Input_Eth_VID = 1
    EthIfVLANSupportEnable = ON
    EthIfTrcvSupportEnable = OFF
    EthIf_Init is called.
  
Test Execution: 
    01: Call function under test with the parameter(s) defined in the input section.
    02: VP: The function TcpIp_RxIndication shall be called with the expected output parameter(s).
  
Test Input: 
    Test step 01:
    EthIf_RxIndication() parameters(s):
      Input_EthIf_CtrlIdx = 0U;
      &amp;Input_EthIf_Data[0U] FrameType = Output_TcpIp_FrameType set in Ethernet data buffer
      Input_EthIf_LenByte = ETHIF_TEST_DATA_BYTENUMBER;
  
Test Output: 
    Test step 02:
    TcpIp_RxIndication parameter(s):
      Output_TcpIp_CtrlIdx = Input_EthIf_CtrlIdx;
      Output_TcpIp_FrameType = 0x0800U; - IPv4
      Output_TcpIp_PhysAddrPtr = &amp;Input_EthIf_Data[ETHIF_TEST_MAC_SRC_OFFSET];
      Output_TcpIp_DataPtr = &amp;Input_EthIf_Data[ETHIF_TEST_DATA_PAYLOAD_OFFSET];
      Output_TcpIp_LenByte = ETHIF_TEST_DATA_BYTENUMBER - ETHIF_TEST_DATA_PAYLOAD_OFFSET;
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.ETHIF085</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>141</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1790</internalId></specobject>
    <specobject>
      <id>EthIf_T340_01_RxIndication_VLanControllers</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T300_VLan_TrcvOff/source/application/EthIf_T340_RxIndication_VLan_TrcvOff.c</sourcefile>
      <sourceline>425</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the functionality of EthIf_RxIndication function for valid parameters.
  
Test Object: None.
Test Precondition: 
    The modules Eth and EthIf need to be configured:
      Input_EthIf_CtrlIdx = 0 maps to Output_Eth_CtrlIdx = 1 (no VLAN)
      Input_EthIf_CtrlIdx = 1 maps to Output_Eth_CtrlIdx = 2 and Input_Eth_VID = 2
      Input_EthIf_CtrlIdx = 2 maps to Output_Eth_CtrlIdx = 2 and Input_Eth_VID = 4094
      Input_EthIf_CtrlIdx = 3 maps to Output_Eth_CtrlIdx = 2 and Input_Eth_VID = 1
    EthIfVLANSupportEnable = ON
    EthIfTrcvSupportEnable = OFF
    EthIf_Init is called.
  
Test Execution: 
    01: Call function under test with the parameter(s) defined in the input section.
    02: VP: The function TcpIp_RxIndication shall be called with the expected output parameter(s).
  
Test Input: 
    Test step 01:
    Test case 0:
    EthIf_RxIndication() parameters(s):
      Input_EthIf_CtrlIdx[0U] = 0U;
      &amp;Input_EthIf_Data[0U][0U]
        Input_EthIf_TPID[1U] = 0x8100U; indication that frame is VLAN frame
        Input_EthIf_VId[0U] = 4094U; set in Ethernet data buffer
        Output_TcpIp_FrameType[0U] = 0x0800U; - IPv4 - set in Ethernet data buffer
      Input_EthIf_LenByte[0U] = ETHIF_TEST_DATA_BYTENUMBER;

    Test step 01:
    Test case 1:
    EthIf_RxIndication() parameters(s):
      Input_EthIf_CtrlIdx[1U] = 0U;
      &amp;Input_EthIf_Data[1U][0U]
        Input_EthIf_TPID[1U] = 0x8100U; indication that frame is VLAN frame
        Input_EthIf_VId[1U] = 1U; set in Ethernet data buffer
        Output_TcpIp_FrameType[1U] = 0x86DD; - IPv6 - set in Ethernet data buffer
      Input_EthIf_LenByte[1U] = ETHIF_TEST_DATA_BYTENUMBER;
  
Test Output: 
    Test step 02:
    Test case 0:
    TcpIp_RxIndication parameter(s):
      Output_TcpIp_CtrlIdx[0U] = Input_Eth_CtrlIdx[0U];
      Output_TcpIp_FrameType[0U] = 0x0800U; - IPv4
      Output_TcpIp_PhysAddrPtr[0U] = &amp;Input_EthIf_Data[0U][ETHIF_TEST_MAC_SRC_OFFSET];
      Output_TcpIp_DataPtr[0U] = &amp;Input_EthIf_Data[0U][ETHIF_TEST_VLAN_DATA_PAYLOAD_OFFSET];
      Output_TcpIp_LenByte[0U] = ETHIF_TEST_DATA_BYTENUMBER - ETHIF_TEST_DATA_PAYLOAD_OFFSET;

    Test step 02:
    Test case 1:
    TcpIp_RxIndication parameter(s):
      Output_TcpIp_CtrlIdx[1U] = Input_Eth_CtrlIdx[1U];
      Output_TcpIp_FrameType[1U] = 0x86DD; - IPv6
      Output_TcpIp_PhysAddrPtr[1U] = &amp;Input_EthIf_Data[1U][ETHIF_TEST_MAC_SRC_OFFSET];
      Output_TcpIp_DataPtr[1U] = &amp;Input_EthIf_Data[1U][ETHIF_TEST_VLAN_DATA_PAYLOAD_OFFSET];
      Output_TcpIp_LenByte[1U] = ETHIF_TEST_DATA_BYTENUMBER - ETHIF_TEST_VLAN_DATA_PAYLOAD_OFFSET;
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.VLANReception</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>152</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1791</internalId></specobject>
    <specobject>
      <id>EthIf_T340_02_RxIndication_MixedControllers</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T300_VLan_TrcvOff/source/application/EthIf_T340_RxIndication_VLan_TrcvOff.c</sourcefile>
      <sourceline>570</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    If both, an EthIf controller with VLAN ID and an EthIf controller without VLAN ID are mapped to
    the same Eth controller and an Ethernet frame contains no VLAN tag, the EthIf
    CtrlIdx of EthIf controller without VLAN ID shall be indicated to the upper layer
    for reception.
  
Test Object: None.
Test Precondition: 
    The modules Eth and EthIf need to be configured:
      Input_EthIf_CtrlIdx = 0 maps to Output_Eth_CtrlIdx = 1 (no VLAN)
      Input_EthIf_CtrlIdx = 5 maps to Output_Eth_CtrlIdx = 1 and Input_Eth_VID = 1
    EthIfVLANSupportEnable = ON
    EthIfTrcvSupportEnable = OFF
    EthIf_Init is called.
  
Test Execution: 
    01: Call EthIf_RxIndication() for a frame without VLAN tag.
    02: VP: The function TcpIp_RxIndication shall be called for controller which has VLAN disabled.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MixedMapping</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>158</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1792</internalId></specobject>
    <specobject>
      <id>EthIf_T340_03_GetAndResetMeasurementData</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T300_VLan_TrcvOff/source/application/EthIf_T340_RxIndication_VLan_TrcvOff.c</sourcefile>
      <sourceline>657</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies functionality of EthIf_GetAndResetMeasurementData() for invalid CrtlIdxes.
  
Test Object: 
    EthIf_GetAndResetMeasurementData().
  
Test Precondition: 
    - EthIf initialized.
  
Test Execution: 
    01: Call Call EthIf_RxIndication() with InvalidCtrlIdx.
    02: Call EthIf_GetAndResetMeasurementData() with measurement index ETHIF_MEAS_ALL and reset flag
        set to TRUE to reset all measurement data.
    03: Call EthIf_GetAndResetMeasurementData() with measurement index ETHIF_MEAS_DROP_CRTLIDX.
    04: VP(SWS_EthIf_00312): Verify that measurement data is set to 0.
    05: Call EthIf_RxIndication() with InvalidCtrlIdx five times.
    06: Call EthIf_GetAndResetMeasurementData() with measurement index ETHIF_MEAS_DROP_CRTLIDX and
        NULL_PTR.
    07: VP(SWS_EthIf_00314): Verify that function returned E_OK.
    08: Call EthIf_GetAndResetMeasurementData() with measurement index ETHIF_MEAS_DROP_CRTLIDX and
        valid MeasurementDataPtr.
    09: VP(SWS_EthIf_00308, SWS_EthIf_00309): Verify that measurement data equals the number of
        dropped datagrams caused by invalid CrtlIdx.
    10: Call EthIf_RxIndication() with Vlan CtrlIdx and IPv4 frame tag seven times.
    11: Call EthIf_GetAndResetMeasurementData() with measurement index ETHIF_MEAS_DROP_CRTLIDX and
        valid MeasurementDataPtr.
    12: VP(SWS_EthIf_00308, SWS_EthIf_00309): Verify that measurement data got increased for the
        number of newly dropped frames as frame VLAN was not configured for a VLAN EthIfCtrl.
    13: Call EthIf_GetAndResetMeasurementData() with not supported measurement index.
    14: VP(SWS_EthIf_00310): Verify that E_NOT_OK is returned.
    15: Call EthIf_GetAndResetMeasurementData() with measurement index ETHIF_MEAS_ALL and reset flag
        set to FALSE.
    16: VP(SWS_EthIf_00312): Verify that measurement data is not set to 0 as reset flag was set to
        FALSE.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00308</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>652</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00309</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>653</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00310</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>654</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00312</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>655</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00314</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>657</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1793</internalId></specobject>
    <specobject>
      <id>EthIf_T340_04_DropData_MaxCounterValue</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T300_VLan_TrcvOff/source/application/EthIf_T340_RxIndication_VLan_TrcvOff.c</sourcefile>
      <sourceline>833</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that measurement data counter does not overrun.
  
Test Object: 
    EthIf_GetAndResetMeasurementData().
  
Test Precondition: 
    - EthIf initialized.
  
Test Execution: 
    01: Set EthIf_MeasurementData_InvCtrlVLAN counter to maximal value.
    02: Call EthIf_RxIndication() with invalid InvalidCtrlIdx several times.
    03: Call EthIf_GetAndResetMeasurementData() with measurement index ETHIF_MEAS_DROP_CRTLIDX.
    04: VP(): Verify that Measurement counter did not overrun.
    05: Call EthIf_RxIndication() with Vlan CtrlIdx and IPv4 frame tag seven times.
    06: Call EthIf_GetAndResetMeasurementData() with measurement index ETHIF_MEAS_DROP_CRTLIDX.
    07: VP(): Verify that Measurement counter did not overrun.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00313</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>656</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1794</internalId></specobject>
    <specobject>
      <id>EthIf_T340_05_GetAndResetMeasurementData_EthIfCtrlDown</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T300_VLan_TrcvOff/source/application/EthIf_T340_RxIndication_VLan_TrcvOff.c</sourcefile>
      <sourceline>929</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies functionality of EthIf_GetAndResetMeasurementData() when received VLAN tagged
    frame matches to the VLAN EthIfCtrl which is in mode DOWN.
  
Test Object: 
    EthIf_GetAndResetMeasurementData().
  
Test Precondition: 
    - EthIf initialized.
    - EthIfCtrl is in mode DOWN.
  
Test Execution: 
    01: Call EthIf_GetAndResetMeasurementData() with measurement index ETHIF_MEAS_ALL and reset flag
        set to TRUE to reset all measurement data.
    02: Call EthIf_GetAndResetMeasurementData() with measurement index ETHIF_MEAS_DROP_CRTLIDX.
    03: VP(SWS_EthIf_00312): Verify that measurement data is set to 0.
    04: Call EthIf_RxIndication() with VLAN tagged frame five times.
    05: Call EthIf_GetAndResetMeasurementData() with measurement index ETHIF_MEAS_DROP_CRTLIDX and
        valid MeasurementDataPtr.
    06: VP(SWS_EthIf_00308, SWS_EthIf_00317): Verify that measurement data equals the number of
        dropped datagrams caused by invalid CrtlIdx.
    07: Set all EthIfCtrls to ACTIVE.
    08: Call EthIf_RxIndication() with VLAN tagged frame three times.
    09: Call EthIf_GetAndResetMeasurementData() with measurement index ETHIF_MEAS_DROP_CRTLIDX and
        valid MeasurementDataPtr.
    10: VP(SWS_EthIf_00317): Verify that Measurement data counter was not increased as CrtlIdx is
        in valid state now.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00317</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>659</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1795</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EthIf_T350_DET_00_ProvideTxBuffer_DetUninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T300_VLan_TrcvOff/source/application/EthIf_T350_ProvideTxBuffer_VLan_TrcvOff.c</sourcefile>
      <sourceline>119</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the response of EthIf_ProvideTxBuffer when EthIf_Init is not called.
  
Test Object: None.
Test Precondition: 
    The modules Eth and EthIf need to be configured:
      Input_EthIf_CtrlIdx = 0 maps to Output_Eth_CtrlIdx = 1 (no VLAN)
      Input_EthIf_CtrlIdx = 1 maps to Output_Eth_CtrlIdx = 2 and Output_Eth_VId = 2
      Input_EthIf_CtrlIdx = 2 maps to Output_Eth_CtrlIdx = 2 and Output_Eth_VId = 4095
      Input_EthIf_CtrlIdx = 3 maps to Output_Eth_CtrlIdx = 2 and Output_Eth_VId = 0
    EthIfVLANSupportEnable = ON
    EthIfTrcvSupportEnable = OFF
    EthIf_Init is not called.
  
Test Execution: 
    01: Call function under test with the parameter(s) defined in the input section.
    02: VP: The function under test shall return BUFREQ_E_NOT_OK.
    03: VP: The function Det_ReportError shall be called with the expected output parameter(s).
  
Test Input: 
    EthIf_ProvideTxBuffer() parameters(s):
      Input_EthIf_CtrlIdx = 0U;
      Input_EthIf_FrameType = 60000U;
      Input_EthIf_Priority = 5U;
      InOut_EthIf_LenByte = ETHIF_TEST_REQUESTED_BYTES;
  
Test Output: 
    Det_ReportError() parameter(s):
      Output_Det_ModuleId = ETHIF_MODULE_ID;
      Output_Det_InstanceId = ETHIF_INSTANCE_ID;
      Output_Det_ApiId = ETHIF_PROVIDETXBUFFER_SVCID;
      Output_Det_ErrorId = ETHIF_E_NOT_INITIALIZED;
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00069</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>438</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1796</internalId></specobject>
    <specobject>
      <id>EthIf_T350_DET_01_ProvideTxBuffer_DetInvCtrlIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T300_VLan_TrcvOff/source/application/EthIf_T350_ProvideTxBuffer_VLan_TrcvOff.c</sourcefile>
      <sourceline>212</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the response of EthIf_ProvideTxBuffer when CtrlIdx is invalid.
  
Test Object: None.
Test Precondition: 
    The modules Eth and EthIf need to be configured:
      Input_EthIf_CtrlIdx = 0 maps to Output_Eth_CtrlIdx = 1 (no VLAN)
      Input_EthIf_CtrlIdx = 1 maps to Output_Eth_CtrlIdx = 2 and Output_Eth_VId = 2
      Input_EthIf_CtrlIdx = 2 maps to Output_Eth_CtrlIdx = 2 and Output_Eth_VId = 4095
      Input_EthIf_CtrlIdx = 3 maps to Output_Eth_CtrlIdx = 2 and Output_Eth_VId = 0
    EthIfVLANSupportEnable = ON
    EthIfTrcvSupportEnable = OFF
    EthIf_Init is called.
  
Test Execution: 
    01: Call function under test with the parameter(s) defined in the input section.
    02: VP: The function under test shall return E_NOT_OK.
    03: VP: The function Det_ReportError shall be called with the expected output parameter(s).
  
Test Input: 
      EthIf_ProvideTxBuffer() parameters(s):
        Input_EthIf_CtrlIdx = 10U;
        Input_EthIf_FrameType = 60000U;
        Input_EthIf_Priority = 5U;
        InOut_EthIf_LenByte = ETHIF_TEST_REQUESTED_BYTES;
  
Test Output: 
    Det_ReportError() parameter(s):
      Output_Det_ModuleId = ETHIF_MODULE_ID;
      Output_Det_InstanceId = ETHIF_INSTANCE_ID;
      Output_Det_ApiId = ETHIF_PROVIDETXBUFFER_SVCID;
      Output_Det_ErrorId = ETHIF_E_INV_CTRL_IDX;
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00070</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>439</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1797</internalId></specobject>
    <specobject>
      <id>EthIf_T350_DET_02_ProvideTxBuffer_DetInvParPtr_BufIdxPtr</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T300_VLan_TrcvOff/source/application/EthIf_T350_ProvideTxBuffer_VLan_TrcvOff.c</sourcefile>
      <sourceline>308</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the response of EthIf_ProvideTxBuffer when parameter is a null pointer.
  
Test Object: None.
Test Precondition: 
    The modules Eth and EthIf need to be configured:
      Input_EthIf_CtrlIdx = 0 maps to Output_Eth_CtrlIdx = 1 (no VLAN)
      Input_EthIf_CtrlIdx = 1 maps to Output_Eth_CtrlIdx = 2 and Output_Eth_VId = 2
      Input_EthIf_CtrlIdx = 2 maps to Output_Eth_CtrlIdx = 2 and Output_Eth_VId = 4095
      Input_EthIf_CtrlIdx = 3 maps to Output_Eth_CtrlIdx = 2 and Output_Eth_VId = 0
    EthIfVLANSupportEnable = ON
    EthIfTrcvSupportEnable = OFF
    EthIf_Init is called.
  
Test Execution: 
    01: Call function under test with the parameter(s) defined in the input section.
    02: VP: The function under test shall return BUFREQ_E_NOT_OK.
    03: VP: The function Det_ReportError shall be called with the expected output parameter(s).
  
Test Input: 
    EthIf_ProvideTxBuffer() parameters(s):
      Input_EthIf_CtrlIdx = 0U;
      Input_EthIf_FrameType = 60000U;
      Input_EthIf_Priority = 5U;
      &amp;Output_EthIf_BufIdxPtr = NULL_PTR;
      InOut_EthIf_LenByte = ETHIF_TEST_REQUESTED_BYTES;
  
Test Output: 
    Det_ReportError() parameter(s):
      Output_Det_ModuleId = ETHIF_MODULE_ID;
      Output_Det_InstanceId = ETHIF_INSTANCE_ID;
      Output_Det_ApiId = ETHIF_PROVIDETXBUFFER_SVCID;
      Output_Det_ErrorId = ETHIF_E_PARAM_POINTER;
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00071</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>440</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1798</internalId></specobject>
    <specobject>
      <id>EthIf_T350_DET_03_ProvideTxBuffer_DetInvParPtr_BufPtr</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T300_VLan_TrcvOff/source/application/EthIf_T350_ProvideTxBuffer_VLan_TrcvOff.c</sourcefile>
      <sourceline>405</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the response of EthIf_ProvideTxBuffer when parameter is a null pointer.
  
Test Object: None.
Test Precondition: 
    The modules Eth and EthIf need to be configured:
      Input_EthIf_CtrlIdx = 0 maps to Output_Eth_CtrlIdx = 1 (no VLAN)
      Input_EthIf_CtrlIdx = 1 maps to Output_Eth_CtrlIdx = 2 and Output_Eth_VId = 2
      Input_EthIf_CtrlIdx = 2 maps to Output_Eth_CtrlIdx = 2 and Output_Eth_VId = 4095
      Input_EthIf_CtrlIdx = 3 maps to Output_Eth_CtrlIdx = 2 and Output_Eth_VId = 0
    EthIfVLANSupportEnable = ON
    EthIfTrcvSupportEnable = OFF
    EthIf_Init is called.
  
Test Execution: 
    01: Call function under test with the parameter(s) defined in the input section.
    02: VP: The function under test shall return BUFREQ_E_NOT_OK.
    03: VP: The function Det_ReportError shall be called with the expected output parameter(s).
  
Test Input: 
    EthIf_ProvideTxBuffer() parameters(s):
      Input_EthIf_CtrlIdx = 0U;
      Input_EthIf_FrameType = 60000U;
      Input_EthIf_Priority = 5U;
      &amp;Output_EthIf_BufPtr = NULL_PTR;
      InOut_EthIf_LenByte = ETHIF_TEST_REQUESTED_BYTES;
  
Test Output: 
    Det_ReportError() parameter(s):
      Output_Det_ModuleId = ETHIF_MODULE_ID;
      Output_Det_InstanceId = ETHIF_INSTANCE_ID;
      Output_Det_ApiId = ETHIF_PROVIDETXBUFFER_SVCID;
      Output_Det_ErrorId = ETHIF_E_PARAM_POINTER;
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00072</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>441</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1799</internalId></specobject>
    <specobject>
      <id>EthIf_T350_DET_04_ProvideTxBuffer_DetInvParPtr_LenBytePtr</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T300_VLan_TrcvOff/source/application/EthIf_T350_ProvideTxBuffer_VLan_TrcvOff.c</sourcefile>
      <sourceline>502</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the response of EthIf_ProvideTxBuffer when parameter is a null pointer.
  
Test Object: None.
Test Precondition: 
    The modules Eth and EthIf need to be configured:
      Input_EthIf_CtrlIdx = 0 maps to Output_Eth_CtrlIdx = 1 (no VLAN)
      Input_EthIf_CtrlIdx = 1 maps to Output_Eth_CtrlIdx = 2 and Output_Eth_VId = 2
      Input_EthIf_CtrlIdx = 2 maps to Output_Eth_CtrlIdx = 2 and Output_Eth_VId = 4095
      Input_EthIf_CtrlIdx = 3 maps to Output_Eth_CtrlIdx = 2 and Output_Eth_VId = 0
    EthIfVLANSupportEnable = ON
    EthIfTrcvSupportEnable = OFF
    EthIf_Init is called.
  
Test Execution: 
    01: Call function under test with the parameter(s) defined in the input section.
    02: VP: The function under test shall return BUFREQ_E_NOT_OK.
    03: VP: The function Det_ReportError shall be called with the expected output parameter(s).
  
Test Input: 
    EthIf_ProvideTxBuffer() parameters(s):
      Input_EthIf_CtrlIdx = 0U;
      Input_EthIf_FrameType = 60000U;
      Input_EthIf_Priority = 5U;
      &amp;InOut_EthIf_LenByte = NULL_PTR;
  
Test Output: 
    Det_ReportError() parameter(s):
      Output_Det_ModuleId = ETHIF_MODULE_ID;
      Output_Det_InstanceId = ETHIF_INSTANCE_ID;
      Output_Det_ApiId = ETHIF_PROVIDETXBUFFER_SVCID;
      Output_Det_ErrorId = ETHIF_E_PARAM_POINTER;
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00073</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>442</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1800</internalId></specobject>
    <specobject>
      <id>EthIf_T350_00_ProvideTxBuffer_VLanControllers</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T300_VLan_TrcvOff/source/application/EthIf_T350_ProvideTxBuffer_VLan_TrcvOff.c</sourcefile>
      <sourceline>593</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the functionality of EthIf_ProvideTxBuffer function for valid parameters.
  
Test Object: None.
Test Precondition: 
    The modules Eth and EthIf need to be configured:
      Input_EthIf_CtrlIdx = 0 maps to Output_Eth_CtrlIdx = 1 (no VLAN)
      Input_EthIf_CtrlIdx = 1 maps to Output_Eth_CtrlIdx = 2 and Output_Eth_VId = 2
      Input_EthIf_CtrlIdx = 2 maps to Output_Eth_CtrlIdx = 2 and Output_Eth_VId = 4094
      Input_EthIf_CtrlIdx = 3 maps to Output_Eth_CtrlIdx = 2 and Output_Eth_VId = 1
    EthIfVLANSupportEnable = ON
    EthIfTrcvSupportEnable = OFF
    EthIf_Init is called.
    A buffer for the Ethernet stub is required.
    A buffer index for the Ethernet stub is required.
    A controller is in state ACTIVE.
  
Test Execution: 
    01: Call function under test with the parameter(s) defined in the input section.
    02: VP: The function under test shall return BUFREQ_E_OK.
    03: VP: The function Eth_ProvideTxBuffer shall be called with the expected output parameter(s).
    04: VP: Check the VLan identifier (VID) in the TCI field of the Ethernet buffer.
    05: VP: Check the canonical format identifier (CFI) in the TCI field of the Ethernet buffer.
    06: VP: Check the user priority (UP) in the TCI field of the Ethernet buffer.
    07: VP: Check the frame type in the Ethernet buffer.
    08: VP: The buffer length at Ethernet level must 4 bytes bigger (VLan header) than the requested buffer length.
  
Test Input: 
    Test step 01:
    Test case 00:
    EthIf_ProvideTxBuffer() parameters(s):
      Input_EthIf_CtrlIdx[0U] = 1U;
      Input_EthIf_FrameType[0U] = 60000U;
      Input_EthIf_Priority[0U] = 7U;
      InOut_EthIf_LenByte[0U] = ETHIF_TEST_REQUESTED_BYTES;

    Test step 01:
    Test case 01:
    EthIf_ProvideTxBuffer() parameters(s):
      Input_EthIf_CtrlIdx[1U] = 0U;
      Input_EthIf_FrameType[1U] = 12U;
      Input_EthIf_Priority[1U] = 5U;
      InOut_EthIf_LenByte[1U] = ETHIF_TEST_REQUESTED_BYTES;

  
Test Output: 
    Test step 03:
    Test case 00:
    Eth_ProvideTxBuffer() parameters(s):
        Output_Eth_CtrlIdx[0U] = 2U;
        &amp;Output_Eth_Buffer[0U]
          Output_EthIf_Priority[0U] = Input_EthIf_Priority[0U]; stored in Ethernet buffer
          Output_EthIf_VId[0U] = 2U; stored in Ethernet buffer
          Output_EthIf_FrameType[0U] = Input_EthIf_FrameType[0U]; stored in Ethernet buffer
        Output_Eth_LenByte = EthIf_Test_BufferLength = ETHIF_TEST_REQUESTED_BYTES + ETHIF_TEST_VLAN_PAYLOAD_OFFSET;

    EthIf_ProvideTxBuffer() parameters(s):
      Output_EthIf_BufIdxPtr[0U] = 12U;
      *Output_EthIf_BufPtr[0U] = &amp;Output_Eth_Buffer[0U] + ETHIF_TEST_VLAN_PAYLOAD_OFFSET;
      InOut_EthIf_LenByte[0U] = ETHIF_TEST_REQUESTED_BYTES;

    Test step 03:
    Test case 01:
    Eth_ProvideTxBuffer() parameters(s):
      Output_Eth_CtrlIdx[1U] = 2U;
      &amp;Output_Eth_Buffer[1U]
        Output_EthIf_Priority[1U] = Input_EthIf_Priority[1U]; stored in Ethernet buffer
        Output_EthIf_VId[1U] = 1U; stored in Ethernet buffer
        Output_EthIf_FrameType[1U] = Input_EthIf_FrameType[1U]; stored in Ethernet buffer

    EthIf_ProvideTxBuffer() parameters(s):
      Output_EthIf_BufIdxPtr[1U] = 12U;
      Output_EthIf_BufPtr[1U] = &amp;Output_Eth_Buffer[1U] + ETHIF_TEST_VLAN_PAYLOAD_OFFSET;
      InOut_EthIf_LenByte[1U] = ETHIF_TEST_REQUESTED_BYTES;
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00068.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>940</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00147</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>505</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1801</internalId></specobject>
    <specobject>
      <id>EthIf_T350_01_ProvideTxBuffer_VLanControllers</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T300_VLan_TrcvOff/source/application/EthIf_T350_ProvideTxBuffer_VLan_TrcvOff.c</sourcefile>
      <sourceline>775</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the functionality of EthIf_ProvideTxBuffer function for valid parameters.
  
Test Object: None.
Test Precondition: 
    The modules Eth and EthIf need to be configured:
      Input_EthIf_CtrlIdx = 0 maps to Output_Eth_CtrlIdx = 1 (no VLAN)
      Input_EthIf_CtrlIdx = 1 maps to Output_Eth_CtrlIdx = 2 and Output_Eth_VId = 2
      Input_EthIf_CtrlIdx = 2 maps to Output_Eth_CtrlIdx = 2 and Output_Eth_VId = 4094
      Input_EthIf_CtrlIdx = 3 maps to Output_Eth_CtrlIdx = 2 and Output_Eth_VId = 1
    EthIfVLANSupportEnable = ON
    EthIfTrcvSupportEnable = OFF
    EthIf_Init is called.
    A buffer for the Ethernet stub is required.
    A buffer index for the Ethernet stub is required.
    A controller is in state ACTIVE_WITH_WAKEUP_REQUEST.
  
Test Execution: 
    01: Call function under test with the parameter(s) defined in the input section.
    02: VP: The function under test shall return BUFREQ_E_OK.
    03: VP: The function Eth_ProvideTxBuffer shall be called with the expected output parameter(s).
    04: VP: Check the VLan identifier (VID) in the TCI field of the Ethernet buffer.
    05: VP: Check the canonical format identifier (CFI) in the TCI field of the Ethernet buffer.
    06: VP: Check the user priority (UP) in the TCI field of the Ethernet buffer.
    07: VP: Check the frame type in the Ethernet buffer.
    08: VP: The buffer length at Ethernet level must 4 bytes bigger (VLan header) than the requested buffer length.
  
Test Input: 
    Test step 01:
    Test case 00:
    EthIf_ProvideTxBuffer() parameters(s):
      Input_EthIf_CtrlIdx[0U] = 1U;
      Input_EthIf_FrameType[0U] = 60000U;
      Input_EthIf_Priority[0U] = 7U;
      InOut_EthIf_LenByte[0U] = ETHIF_TEST_REQUESTED_BYTES;

    Test step 01:
    Test case 01:
    EthIf_ProvideTxBuffer() parameters(s):
      Input_EthIf_CtrlIdx[1U] = 0U;
      Input_EthIf_FrameType[1U] = 12U;
      Input_EthIf_Priority[1U] = 5U;
      InOut_EthIf_LenByte[1U] = ETHIF_TEST_REQUESTED_BYTES;

  
Test Output: 
    Test step 03:
    Test case 00:
    Eth_ProvideTxBuffer() parameters(s):
        Output_Eth_CtrlIdx[0U] = 2U;
        &amp;Output_Eth_Buffer[0U]
          Output_EthIf_Priority[0U] = Input_EthIf_Priority[0U]; stored in Ethernet buffer
          Output_EthIf_VId[0U] = 2U; stored in Ethernet buffer
          Output_EthIf_FrameType[0U] = Input_EthIf_FrameType[0U]; stored in Ethernet buffer
        Output_Eth_LenByte = EthIf_Test_BufferLength = ETHIF_TEST_REQUESTED_BYTES + ETHIF_TEST_VLAN_PAYLOAD_OFFSET;

    EthIf_ProvideTxBuffer() parameters(s):
      Output_EthIf_BufIdxPtr[0U] = 12U;
      *Output_EthIf_BufPtr[0U] = &amp;Output_Eth_Buffer[0U] + ETHIF_TEST_VLAN_PAYLOAD_OFFSET;
      InOut_EthIf_LenByte[0U] = ETHIF_TEST_REQUESTED_BYTES;

    Test step 03:
    Test case 01:
    Eth_ProvideTxBuffer() parameters(s):
      Output_Eth_CtrlIdx[1U] = 2U;
      &amp;Output_Eth_Buffer[1U]
        Output_EthIf_Priority[1U] = Input_EthIf_Priority[1U]; stored in Ethernet buffer
        Output_EthIf_VId[1U] = 1U; stored in Ethernet buffer
        Output_EthIf_FrameType[1U] = Input_EthIf_FrameType[1U]; stored in Ethernet buffer

    EthIf_ProvideTxBuffer() parameters(s):
      Output_EthIf_BufIdxPtr[1U] = 12U;
      Output_EthIf_BufPtr[1U] = &amp;Output_Eth_Buffer[1U] + ETHIF_TEST_VLAN_PAYLOAD_OFFSET;
      InOut_EthIf_LenByte[1U] = ETHIF_TEST_REQUESTED_BYTES;
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00068.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>941</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00147</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>505</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1802</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EthIf_T390_01_MainFunctionRx_VLan_ETH_MODE_DOWN</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T300_VLan_TrcvOff/source/application/EthIf_T390_MainFunctionRx_VLan_TrcvOff.c</sourcefile>
      <sourceline>43</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that EthIf_MainFunctionRx does not perform a hardware access (call Eth_Receive())
    for Ethernet controllers that are in the state ETH_MODE_DOWN.
  
Test Object: None.
Test Precondition: 
    The modules Eth and EthIf need to be configured:
      Input_EthIf_CtrlIdx = 0 maps to Output_Eth_CtrlIdx = 1 (no VLAN)
      Input_EthIf_CtrlIdx = 1 maps to Output_Eth_CtrlIdx = 2 and Output_Eth_VID = 2
      Input_EthIf_CtrlIdx = 2 maps to Output_Eth_CtrlIdx = 2 and Output_Eth_VID = 4095
      Input_EthIf_CtrlIdx = 3 maps to Output_Eth_CtrlIdx = 2 and Output_Eth_VID = 0
      Input_EthIf_CtrlIdx = 4 maps to Output_Eth_CtrlIdx = 0 and Output_Eth_VID = 0
    EthIfVLANSupportEnable = STD_ON
    EthIfTrcvSupportEnable = STD_OFF
    ETHIF_LEGACY_40R3_ETH_RECEIVE = STD_OFF
    EthIf_Init is called.
    All Eth are in ETH_MODE_DOWN
  
Test Execution: 
    01: EthIf_MainFunctionRx().
    02: VP: Verify that Eth_Receive () is not called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_00097_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>134</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1803</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EthIf_T490_00_MainFunctionRx_EthReceive</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T400_VLan_TrcvOff_EBPolling/source/application/EthIf_T490_MainFunctionRx_VLan_TrcvOff_EBPolling.c</sourcefile>
      <sourceline>44</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the functionality of EthIf_MainFunctionRx function. This function shall poll
    Eth_Receive for every CtrlIdx. If more data is available for a certain CtrlIdx, Eth_Receive
    shall be repeated a certain amount.
  
Test Object: None.
Test Precondition: 
    The modules Eth and EthIf need to be configured:
      Input_EthIf_CtrlIdx = 0 maps to Output_Eth_CtrlIdx = 1 (no VLAN)
      Input_EthIf_CtrlIdx = 1 maps to Output_Eth_CtrlIdx = 2 and Output_Eth_VID = 2
      Input_EthIf_CtrlIdx = 2 maps to Output_Eth_CtrlIdx = 2 and Output_Eth_VID = 4095
      Input_EthIf_CtrlIdx = 3 maps to Output_Eth_CtrlIdx = 2 and Output_Eth_VID = 0
      Input_EthIf_CtrlIdx = 4 maps to Output_Eth_CtrlIdx = 0 and Output_Eth_VID = 0
    EthIfVLANSupportEnable = STD_ON
    EthIfTrcvSupportEnable = STD_OFF
    ETHIF_LEGACY_40R3_ETH_RECEIVE = STD_OFF
    EthIf_Init is called.
    Eth_Receive() output parameters need to be set:
      Input_Eth_RxStatus[0U] = RxStatus_Out_Ary[0U] = ETH_NOT_RECEIVED
      Input_Eth_RxStatus[1U] = RxStatus_Out_Ary[1U] = ETH_RECEIVED
      Input_Eth_RxStatus[2U] = RxStatus_Out_Ary[2U] = ETH_RECEIVED_MORE_DATA_AVAILABLE
      Input_Eth_RxStatus[3U] = RxStatus_Out_Ary[3U] = ETH_RECEIVED_MORE_DATA_AVAILABLE

  
Test Execution: 
    01: Call function under test.
    02: VP: The function Eth_Receive shall be called 4 times with the expected output parameter(s).
  
Test Input: 
  
Test Output: 
    Test step 02:
    Eth_Receive()
     Output_Eth_CtrlIdx[0U] = 0U;
     Output_Eth_CtrlIdx[1U] = 1U;
     Output_Eth_CtrlIdx[2U] = 2U;
     Output_Eth_CtrlIdx[3U] = 2U;
     Output_Eth_RxStatus[i] = Input_Eth_RxStatus[i];

  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00097</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>457</internalId></provcov>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_MainFunctionRx_PollEthReceiveNoData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1804</internalId></specobject>
    <specobject>
      <id>EthIf_T490_01_MainFunctionRx_TrcvLinkStateChg</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T400_VLan_TrcvOff_EBPolling/source/application/EthIf_T490_MainFunctionRx_VLan_TrcvOff_EBPolling.c</sourcefile>
      <sourceline>176</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the functionality of EthIf_MainFunctionRx function. This function shall
    call EthSM_TrcvLinkStateChg for every transceiver mode changes.
  
Test Object: None.
Test Precondition: 
    The modules Eth and EthIf need to be configured:
      Input_EthIf_CtrlIdx = 0 maps to Output_Eth_CtrlIdx = 1 (no VLAN)
      Input_EthIf_CtrlIdx = 1 maps to Output_Eth_CtrlIdx = 2 and Output_Eth_VID = 2
      Input_EthIf_CtrlIdx = 2 maps to Output_Eth_CtrlIdx = 2 and Output_Eth_VID = 4095
      Input_EthIf_CtrlIdx = 3 maps to Output_Eth_CtrlIdx = 2 and Output_Eth_VID = 0
      Input_EthIf_CtrlIdx = 4 maps to Output_Eth_CtrlIdx = 0 and Output_Eth_VID = 0
    EthIfVLANSupportEnable = STD_ON
    EthIfTrcvSupportEnable = STD_OFF
    ETHIF_LEGACY_40R3_ETH_RECEIVE = STD_OFF
    EthIf_Init is called.
  
Test Execution: 
    01: VP: The function EthIf_SetControllerMode shall be used to force transceiver mode changes.
    02: VP Function returns E_OK.
    03: Call function under test.
    04: VP: The Eth_Receive shall be called 2 times (for each CtrlIdx)..
    05: VP: The function EthSM_TrcvLinkStateChg shall be called for every CtrlIdx which has a
            transceiver mode change.
    06: VP: The function EthIf_SetControllerMode shall be used to force transceiver mode changes.
    07: VP Function returns E_OK.
    08: Reset EthSM_TrcvLinkStateChg call counter.
    09: Call function under test.
    10: VP: The Eth_Receive shall be called 3 times (for each CtrlIdx).
    11: VP: The function EthSM_TrcvLinkStateChg shall be called for every CtrlIdx which has a
            transceiver mode change.
  
Test Input: 
    Test step 01:
    EthIf_SetControllerMode()
      Input_EthIf_CtrlIdx = 0U -&gt; Input_EthIf_TrcvMode = ETHTRCV_MODE_ACTIVE
      Input_EthIf_CtrlIdx = 1U -&gt; Input_EthIf_TrcvMode = ETHTRCV_MODE_DOWN
      Input_EthIf_CtrlIdx = 2U -&gt; Input_EthIf_TrcvMode = ETHTRCV_MODE_ACTIVE
      Input_EthIf_CtrlIdx = 3U -&gt; Input_EthIf_TrcvMode = ETHTRCV_MODE_DOWN

    Test step 05:
    EthIf_SetControllerMode()
      Input_EthIf_CtrlIdx = 1U -&gt; Input_EthIf_TrcvMode = ETHTRCV_MODE_ACTIVE
      Input_EthIf_CtrlIdx = 2U -&gt; Input_EthIf_TrcvMode = ETHTRCV_MODE_DOWN
      Input_EthIf_CtrlIdx = 4U -&gt; Input_EthIf_TrcvMode = ETHTRCV_MODE_ACTIVE
  
Test Output: 
    Test step 04:
    EthSM_TrcvLinkStateChg() first function call:
      Output_EthIf_CtrlIdx = 0U;
      Output_EthIf_LinkState = ETHTRCV_LINK_STATE_ACTIVE;
    EthSM_TrcvLinkStateChg() second function call:
      Output_EthIf_CtrlIdx = 2U;
      Output_EthIf_LinkState = ETHTRCV_LINK_STATE_ACTIVE;

    Test step 09:
    EthSM_TrcvLinkStateChg() first function call:
      Output_EthIf_CtrlIdx = 4U;
      Output_EthIf_LinkState = ETHTRCV_LINK_STATE_ACTIVE;
    EthSM_TrcvLinkStateChg() second function call:
      Output_EthIf_CtrlIdx = 1U;
      Output_EthIf_LinkState = ETHTRCV_LINK_STATE_ACTIVE;
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00097</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>457</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1805</internalId></specobject>
    <specobject>
      <id>EthIf_T490_02_MainFunctionRx_PollEthReceiveMax</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T400_VLan_TrcvOff_EBPolling/source/application/EthIf_T490_MainFunctionRx_VLan_TrcvOff_EBPolling.c</sourcefile>
      <sourceline>347</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    It shall be tested that within the context of EthIf_MainFunctionRx() the module polls
    Eth_Receive() to a maximum of ETHIF_RX_INDICATION_ITERATIONS.
  
Test Object: None.
Test Precondition: 
    - The modules Eth and EthIf need to be configured:
        Input_EthIf_CtrlIdx = 1 maps to Output_Eth_CtrlIdx = 2 and Output_Eth_VID = 2
        Input_EthIf_CtrlIdx = 2 maps to Output_Eth_CtrlIdx = 2 and Output_Eth_VID = 4095
        Input_EthIf_CtrlIdx = 3 maps to Output_Eth_CtrlIdx = 2 and Output_Eth_VID = 0
    - EthIfVLANSupportEnable = STD_ON
    - EthIfTrcvSupportEnable = STD_OFF
    - ETHIF_LEGACY_40R3_ETH_RECEIVE = STD_ON
    - EthIf_Init is called.
    - EthIf_SetControllerMode(ETH_MODE_ACTIVE) called for all stated EthIfCtrl
    - Set Eth_Receive() stub to return more data available.
  
Test Execution: 
    01: Call EthIf_MainFunctionRx().
    02: VP: Verify that Eth_Receive() is called ETHIF_RX_INDICATION_ITERATIONS times.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_MainFunctionRx_PollEthReceiveMax</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>132</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1806</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EthIf_T500_SetControllerMode_Wakeup_Activate</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T500_Voting/TestSpec_Generated.h</sourcefile>
      <sourceline>9</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that transceiver link was correctly changed from DOWN to ACIVE when EthIf_SetControllerMode was called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST.
Test Object: Activation with wakeup request
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   Switch and switch group support is disabled
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller and transceiver mode to ACTIVE_WITH_WAKEUP_REQUEST.
    02: Call EthIf_MainFunctionRx to change link state to ACTIVE.
    03: VP(EthIf.ASR43.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange,1) Verify that the link was changed to ACTIVE.
    04: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>130</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1807</internalId></specobject>
    <specobject>
      <id>EthIf_T500_SetControllerMode_Wakeup_Deactivate</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T500_Voting/TestSpec_Generated.h</sourcefile>
      <sourceline>33</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that transceiver link was correctly changed from ACIVE to DOWN when EthIf_SetControllerMode was activated with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST.
Test Object: Deactivation with wakeup request
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   Switch and switch group support is disabled
    -   EthIf and test setup is initialized
    -   Activate link state of the transceiver
  
Test Execution: 
    01: Set Ethernet interface controller and transceiver mode to DOWN.
    02: Call EthIf_MainFunctionRx to change link state to DOWN.
    03: VP(EthIf.ASR43.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange,1) Verify that the link was changed to DOWN.
    04: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>130</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1808</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EthIf_T500_SetControllerMode_Concurrent</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T500_Voting/source/application/EthIf_T500_Voting.c</sourcefile>
      <sourceline>139</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test sequence tests the concurrent access to function EthIf_SetControllerMode()
    for multiple EthIf controller assigned to a single physical Eth controller.
  
Test Object: 
    - EthIf_SetControllerMode()
  
Test Precondition: 
    - EthIf is initialized.
    - Underlying Eth controller 0 and 2 are initialized
  
Test Execution: 
    01: Call EthIf_SetControllerMode() for EthIfCtrl_6 to set controller in state 'active'.
    02: VP:
        EthIf set underlying Eth controller to state 'active.
    03: Call EthIf_SetControllerMode() for EthIfCtrl_0 to set controller in state 'active'.
    04: VP:
        EthIf set underlying Eth controller to state 'active'.
    05: Call EthIf_SetControllerMode() for EthIfCtrl_1 to set controller in state 'active'.
    06: VP:
        EthIf does not forward the call.
    07: Call EthIf_SetControllerMode() for EthIfCtrl_2 to set controller in state 'active'.
    08: VP:
        EthIf does not forward the call.
    09: Call EthIf_SetControllerMode() for EthIfCtrl_6 to set controller in state 'down'.
    10: VP:
        EthIf set underlying Eth controller to state 'down'.
    11: Call EthIf_SetControllerMode() for EthIfCtrl_0 to set controller in state 'down'.
    12: Call EthIf_SetControllerMode() for EthIfCtrl_1 to set controller in state 'down'.
    13: VP:
        EthIf does not forward the call.
    14: Call EthIf_SetControllerMode() for EthIfCtrl_2 to set controller in state 'down'.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00263</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>616</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00035</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>424</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1809</internalId></specobject>
    <specobject>
      <id>EthIf_T500_RxIndication_VLAN_Forwarding</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T500_Voting/source/application/EthIf_T500_Voting.c</sourcefile>
      <sourceline>310</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test sequence tests the reception of VLAN frames. EthIf shall forward
    the frames to TcpIp with the correct parameters.
  
Test Object: 
    - EthIf_RxIndication()
  
Test Precondition: 
    - EthIf is initialized.
    - EthIfCtrl_1 - EthIfCtrl_5 are active.
  
Test Execution: 
    01: Simulate the reception of a Ethernet frame with VLAN ID 1
        and the underlying EthCtrl of EthIfCtrl_1.
    02: VP:
        EthIf forward frame to TcpIp, indicating a index of EthIfCtrl_1, frame type Ipv4,
        and data length of 8bytes.
    03: Simulate the reception of a Ethernet frame with VLAN ID 50
        and the underlying EthCtrl of EthIfCtrl_2.
    04: VP:
        EthIf forward frame to TcpIp, indicating a index of EthIfCtrl_2, frame type Ipv4,
        and data length of 8bytes.
    05: Simulate the reception of a Ethernet frame with VLAN ID 1
        and the underlying EthCtrl of EthIfCtrl_3.
    06: VP:
        EthIf forward frame to TcpIp, indicating a index of EthIfCtrl_3, frame type Ipv4,
        and data length of 8bytes.
    07: Simulate the reception of a Ethernet frame with VLAN ID 4094
        and the underlying EthCtrl of EthIfCtrl_4.
    08: VP:
        EthIf forward frame to TcpIp, indicating a index of EthIfCtrl_4, frame type Ipv4,
        and data length of 8bytes.
    09: Simulate the reception of a Ethernet frame with VLAN ID 256
        and the underlying EthCtrl of EthIfCtrl_5.
    10: VP:
        EthIf forward frame to TcpIp, indicating a index of EthIfCtrl_5, frame type Ipv4,
        and data length of 8bytes.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.VLANReception</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>152</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00145</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>503</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.User_RxIndication.VLAN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>188</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1810</internalId></specobject>
    <specobject>
      <id>EthIf_T500_RxIndication_NoVLAN_Forwarding</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T500_Voting/source/application/EthIf_T500_Voting.c</sourcefile>
      <sourceline>491</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test sequence tests the reception of Ethernet frames without VLAN.
    EthIf shall forward the frames to TcpIp with the correct EthIfController index.
  
Test Object: 
    - EthIf_RxIndication()
  
Test Precondition: 
    - EthIf is initialized.
    - EthIfCtrl_0 and EthIfCtrl_6 are active.
  
Test Execution: 
    01: Simulate the reception of a Ethernet frame (no VLAN)
        and the underlying EthCtrl of EthIfCtrl_0.
    02: VP(EthIf.EB.User_RxIndication, SWS_EthIf_00145):
        EthIf forward frame to TcpIp, indicating a index of EthIfCtrl_0.
    03: Simulate the reception of a Ethernet frame (no VLAN)
        and the underlying EthCtrl of EthIfCtrl_6.
    04: VP(EthIf.EB.User_RxIndication, SWS_EthIf_00145):
        EthIf forward frame to TcpIp, indicating a index of EthIfCtrl_6.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00145</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>503</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.User_RxIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>190</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1811</internalId></specobject>
    <specobject>
      <id>EthIf_T500_SetPhysAddr_UpdatePhysAddr_Disabled</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Conformance/IN/EthIf_T500_Voting/source/application/EthIf_T500_Voting.c</sourcefile>
      <sourceline>594</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that EthIf_SetPhysAddr() shall not call Eth_SetPhysAddr() if configuration
    parameter EthIfSetPhysAddrSupportEnable is disabled.
  
Test Object: 
    EthIf_SetPhysAddr().
  
Test Precondition: 
    - EthIf initialized.
    - Configuration parameter EthIfSetPhysAddrSupportEnable = FALSE.
  
Test Execution: 
    01: Call EthIf_SetPhysAddr().
    02: VP: Verify that Eth_SetPhysAddr() is not called.
    03: Call EthIf_UpdatePhysAddrFilter().
    04: VP: Verify that Eth_UpdatePhysAddrFilter() is not called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.EthIfSetPhysAddrSupportEnable_Disable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>184</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.EthIfUpdatePhysAddrFilterSupportEnable_Disable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>187</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1812</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_ETHIF_Gen_00000_OnlyPbCfg</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_00_OnlyPbCfg/source/application/EthIf_GenTest_00_OnlyPBcfg.h</sourcefile>
      <sourceline>27</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that the ETHIF post build configuration also compiles stand alone.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
    * Set TS_BUILD_POST_BUILD_BINARY to TRUE to prevent compilation of non post build files.
    * Remove all generated ETHIF C files except post build files if there are any.

Test Execution: 
    The test run is successful when the ETHIF compiles under sticking to the precondition and a
    binary file is generated.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.PostBuild_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>976</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1813</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EthIf_GenTest01001_Err_Owner_Not_Consecutive</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>28</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    If configuration parameter EthIfOwner is not consecutive,
    the generator shall report an error message.
  
Test Object: XDM check
Test Precondition: 
    EthIfOwner = not consecutive.
  
Test Execution: 
    VP: The generator shall report an error which states that the configuration parameter
        EthIfOwner is not consecutive.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfOwner.ZeroBasedConsecutive</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1157</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1814</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest01002_Err_Owner_Not_ZeroBased</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>51</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    If configuration parameter EthIfOwner is not zero based,
    the generator shall raise an error message.
  
Test Object: XDM check
Test Precondition: 
    EthIfOwner = not zero based.
  
Test Execution: 
    VP: The generator shall report an error which states that the configuration parameter
        EthIfOwner is not zero based.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfOwner.ZeroBasedConsecutive</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1157</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1815</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest01003_Err_EthIfPhysControllerIdx_NotZeroBased</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>74</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if not all EthIfPhysControllerIdx are zero based.
  
Test Object: XDM check
Test Precondition: 
    EthIfPhysControllerIdx = not zero based.
  
Test Execution: 
    VP: The generator shall report an error which states that the configuration parameter
        EthIfPhysControllerIdx is not zero based for all EthIf controller.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfPhysControllerIdx.ZeroBased</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1158</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1816</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest01004_Err_EthIfPhysControllerIdx_NotConsecuitve</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>96</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if not all EthIfPhysControllerIdx are consecutive.
  
Test Object: XDM check
Test Precondition: 
    EthIfPhysControllerIdx = not consecutive.
  
Test Execution: 
    VP: The generator shall report an error which states that the configuration parameter
        EthIfPhysControllerIdx is not consecutive for all EthIf controller.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfPhysControllerIdx.Consecutive</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1159</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1817</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest01005_Err_EthIfPhysController_NotConfigured</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>118</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    If EthIfPhysControllerRef does not contain a valid reference, the generator shall
    raise an error message.
  
Test Object: XDM check
Test Precondition: 
    EthIfPhysControllerRef = not configured.
  
Test Execution: 
    VP: The generator shall report an error that a valid controller reference shall be configured.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfPhysControllerRef.Valid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1160</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1818</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest01006_Err_EthIfEthCtrlRef_NotConfigured</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>140</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    If EthIfEthCtrlRef does not contain a valid reference, the generator shall
    raise an error message.
  
Test Object: XDM check
Test Precondition: 
    EthIfEthCtrlRef = not configured.
  
Test Execution: 
    VP: The generator shall report an error that a valid controller reference shall be configured.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfEthCtrlRef.Valid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1161</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1819</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest01007_Err_EthIfEthTrcvRef_NotConfigured</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>162</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    If EthIfEthTrcvRef does not contain a valid reference, the generator shall
    raise an error message.
  
Test Object: XDM check
Test Precondition: 
    EthIfEthTrcvRef = not configured.
  
Test Execution: 
    VP: The generator shall report an error that a valid transceiver reference shall be configured
        or disabled.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfEthTrcvRef.Valid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1162</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1820</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest01008_Err_EthIfCtrlIdx_NotZeroBased</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>185</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if not all EthIfCtrlIdx are zero based.
  
Test Object: XDM check
Test Precondition: 
    EthIfCtrlIdx = not zero based.
  
Test Execution: 
    VP: The generator shall report an error which states that the configuration parameter
        EthIfCtrlIdx is not zero based for all EthIf controller.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfCtrlIdx.ZeroBased</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1165</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1821</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest01009_Err_EthIfCtrlIdx_NotConsecutive</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>207</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if not all EthIfCtrlIdx are consecutive.
  
Test Object: XDM check
Test Precondition: 
    EthIfCtrlIdx = not consecutive.
  
Test Execution: 
    VP: The generator shall report an error which states that the configuration parameter
        EthIfCtrlIdx is not consecutive for all EthIf controller.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfCtrlIdx.Consecutive</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1166</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1822</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest01010_Err_EthIfSwitchRef_NotConfigured</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>229</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    If EthIfSwitchRef does not contain a valid reference, the generator shall
    raise an error message.
  
Test Object: XDM check
Test Precondition: 
    EthIfSwitchRef = not configured.
  
Test Execution: 
    VP: The generator shall report an error that a valid switch reference shall be configured
        or disabled.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfSwitchRef.Valid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1167</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1823</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest01011_Err_EthIfSwitchIdx_NotZeroBased</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>252</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if not all EthIfSwitchIdx are zero based.
  
Test Object: XDM check
Test Precondition: 
    EthIfSwitchIdx = not zero based.
  
Test Execution: 
    VP: The generator shall report an error which states that the configuration parameter
        EthIfSwitchIdx is not zero based for all EthIf switches.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfSwitch.ZeroBased</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1168</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1824</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest01012_Err_EthIfSwitchIdx_NotConsecutive</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>274</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if not all EthIfSwitchIdx are consecutive.
  
Test Object: XDM check
Test Precondition: 
    EthIfSwitchIdx = not consecutive.
  
Test Execution: 
    VP: The generator shall report an error which states that the configuration parameter
        EthIfSwitchIdx is not consecutive for all EthIf switches.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfSwitch.Consecutive</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1169</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1825</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest01013_Err_EthIfTransceiverIdx_NotZeroBased</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>296</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if not all EthIfTransceiverIdx are zero based.
  
Test Object: XDM check
Test Precondition: 
    EthIfTransceiverIdx = not zero based.
  
Test Execution: 
    VP: The generator shall report an error which states that the configuration parameter
        EthIfTransceiverIdx is not zero based for all EthIf controller.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfTransceiverIdx.ZeroBased</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1163</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1826</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest01014_Err_EthIfTransceiverIdx_NotConsecuitve</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>318</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if not all EthIfTransceiverIdx are consecutive.
  
Test Object: XDM check
Test Precondition: 
    EthIfTransceiverIdx = not consecutive.
  
Test Execution: 
    VP: The generator shall report an error which states that the configuration parameter
        EthIfTransceiverIdx is not consecutive for all EthIf controller.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfTransceiverIdx.Consecutive</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1164</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1827</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest01015_Err_EthIfEthTrcvRef_NotConfigured</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>340</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    If EthIfEthTrcvRef does not contain a valid reference, the generator shall
    raise an error message.
  
Test Object: XDM check
Test Precondition: 
    EthIfEthTrcvRef = not configured.
  
Test Execution: 
    VP: The generator shall report an error that a valid transceiver reference shall be configured
        or disabled.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfEthTrcvRef.Valid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1162</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1828</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest01016_War_SetModeTimeout_NotDivisible_ByMF</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>363</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    If EthIfSetModeTimeout is not divisible by EthIfMainFunctionPeriod
    the generator shall report a warning.
  
Test Object: XDM check
Test Precondition: 
    EthIfSetModeTimeout = 0.01
    EthSMMainFunctionPeriod = 0.035
  
Test Execution: 
    VP: The generator shall report a warning which states that EthIfSetModeTimeout is not
        a multiple of EthIfMainFunctionPeriod and it`s value will be rounded up.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.SetModeTimeout.NotMultipleValue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1209</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1829</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest01017_War_SetModeTimeout_MaxValue</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>387</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    If the calculation of EthIfSetModeTimeout/EthIfMainFunctionPeriod is greater than
    65535 the generator shall report a warning.
  
Test Object: XDM check
Test Precondition: 
    EthIfSetModeTimeout = 660
    EthIfMainFunctionPeriod = 0.01
  
Test Execution: 
    VP: The generator shall report a warning which states that the repetition time will be
        limited to the maximum of 65535 main function cycles.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.SetModeTimeout.MaxValue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1210</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1830</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest01018_Err_EthIfSwitchingPortGroupSupport</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>411</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message reportring that when switching of port groups
    feature is enabled and at least one EthIfSwitchPortGroup or EthIfSwitch must be defined.
  
Test Object: XDM check
Test Precondition: 
  
Test Execution: 
    VP: The generator shall report a warning which states that when switching of port groups
        feature is enabled at least one EthIfSwitchPortGroup or EthIfSwitch need to be defined.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfSwitchingPortGroupSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1200</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1831</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest01019_Err_EthIfAsyncEthTrcvModeSupport</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>433</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if EthIfAsyncEthTrcvModeSupport is enabled and
    EthIfTrcvSupportEnable is disabled.
  
Test Object: XDM check
Test Precondition: 
  
Test Execution: 
    VP: The generator shall report an errir message which states that EthIfTrcvSupportEnable must
        be enabled when EthIfAsyncEthTrcvModeSupport is enabled.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfAsyncEthTrcvModeSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1211</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1832</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest01020_Err_EthIfSecurityEventRefs_Not_Unique_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>455</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if a reference contained in EthIfSecurityEventRefs is
    not unique.
  
Test Object: XDM check
Test Precondition: 
    EthIfSecurityEventRefs has reference ETHIF_SEV_DROP_UNKNOWN_ETHERTYPE set to the same value
    as some other EthIfSecurityEventRefs value.
  
Test Execution: 
    VP: The generator shall report an error which says that the configuration parameter
        EthIfSecurityEventRefs ETHIF_SEV_DROP_UNKNOWN_ETHERTYPE is not unique.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfSecurityEventRefs.Unique</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1225</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1833</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest01021_Err_EthIfSecurityEventRefs_Not_Unique_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>479</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if a reference contained in EthIfSecurityEventRefs is
    not unique.
  
Test Object: XDM check
Test Precondition: 
    EthIfSecurityEventRefs has reference ETHIF_SEV_DROP_VLAN_DOUBLE_TAG set to the same value
    as some other EthIfSecurityEventRefs value.
  
Test Execution: 
    VP: The generator shall report an error which says that the configuration parameter
        EthIfSecurityEventRefs ETHIF_SEV_DROP_VLAN_DOUBLE_TAG is not unique.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfSecurityEventRefs.Unique</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1225</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1834</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest01022_Err_EthIfSecurityEventRefs_Not_Unique_3</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>503</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if a reference contained in EthIfSecurityEventRefs is
    not unique.
  
Test Object: XDM check
Test Precondition: 
    EthIfSecurityEventRefs has reference ETHIF_SEV_DROP_INV_VLAN set to the same value
    as some other EthIfSecurityEventRefs value.
  
Test Execution: 
    VP: The generator shall report an error which says that the configuration parameter
        EthIfSecurityEventRefs ETHIF_SEV_DROP_INV_VLAN is not unique.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfSecurityEventRefs.Unique</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1225</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1835</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest01023_Err_EthIfSecurityEventRefs_Invalid</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>527</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if a reference contained in EthIfSecurityEventRefs
    container is not valid.
  
Test Object: XDM check
Test Precondition: 
    EthIfSecurityEventRefs has references set to values not defined in IdsM configuration.
  
Test Execution: 
    VP: The generator shall report an error which says that the configuration parameter
        EthIfSecurityEventRefs shall point to a valid node or must be disabled.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfSecurityEventRefs.Valid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1224</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1836</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest01024_Err_EthIfSecurityEventRefs_Added</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>550</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if EthIfEnableSecurityEventReporting is enabled,
    but no EthIfSecurityEventRefs are defined.
  
Test Object: XDM check
Test Precondition: 
    EthIfEnableSecurityEventReporting has been enabled and no EthIfSecurityEventRefs are defined.
  
Test Execution: 
    VP: The generator shall report an error which says that if EthIfEnableSecurityEventReporting is
        enabled, at least one reference has to be added.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfSecurityEventRefs.Added</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1223</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1837</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest01025_Err_EthIfRxInd_NumberOfElements1</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>573</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if there are more elements in EthIfFrameOwnerConfig 
        than in EthIfRxIndicationConfig.
  
Test Object: XDM check
Test Precondition: 
    More elements in EthIfFrameOwnerConfig than in EthIfRxIndicationConfig.
  
Test Execution: 
    VP: The generator shall report an error which says that the number of elements in 
        EthIfFrameOwnerConfig and EthIfRxIndicationConfig do not match.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfFrameOwnerConfig.EthIfRxIndicationConfig.NumberOfElementsMatch</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1222</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1838</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest01026_Err_EthIfRxInd_NumberOfElements2</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>596</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if there are less elements in EthIfFrameOwnerConfig 
        than in EthIfRxIndicationConfig.
  
Test Object: XDM check
Test Precondition: 
    Less elements in EthIfFrameOwnerConfig than in EthIfRxIndicationConfig.
  
Test Execution: 
    VP: The generator shall report an error which says that the number of elements in 
        EthIfFrameOwnerConfig and EthIfRxIndicationConfig do not match.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfFrameOwnerConfig.EthIfRxIndicationConfig.NumberOfElementsMatch</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1222</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1839</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EthIf_GenTest02001_Err_EthIfPhysCtrlRxMainFunctionPeriod_OutOfRange1</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_02_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>28</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if EthIfPhysCtrlRxMainFunctionPeriod is above
    the range [0, 65535].
  
Test Object: XDM check
Test Precondition: 
    EthIfPhysCtrlRxMainFunctionPeriod is set to 65536.
  
Test Execution: 
    VP: The generator shall report an error which states that the value of
    EthIfPhysCtrlRxIndicationIterations is out of the range and it must be "&gt;= 0" and "&lt;= 65535".
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfPhysCtrlRxMainFunctionPeriod.Range</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1189</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1840</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest02002_Err_EthIfPhysCtrlRxMainFunctionPeriod_OutOfRange2</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_02_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>51</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if EthIfPhysCtrlRxMainFunctionPeriod is below
    the range [0, 65535].
  
Test Object: XDM check
Test Precondition: 
    EthIfPhysCtrlRxMainFunctionPeriod is set to -1.
  
Test Execution: 
    VP: The generator shall report an error which states that the value of
    EthIfPhysCtrlRxIndicationIterations is out of the range and it must be "&gt;= 0" and "&lt;= 65535".
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfPhysCtrlRxMainFunctionPeriod.Range</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1189</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1841</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest02003_Err_EthIfCtrlIdx_NoVlanGroupedFirst</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_02_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>74</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if EthIfCtrlIdx of controllers without VLAN
    are not grouped before controllers using VLAN.
  
Test Object: XDM check
Test Precondition: 
    EthIfVlanId of EthIfCtrl_2 is not set (disabled) -&gt; since EthIfVlanId of EthIfCtrl_1 is enabled
    the tested conditoin is not met.
  
Test Execution: 
    VP: The generator shall report an error which states that the EthIfControllers with VLAN
        disabled must be positioned before those with VLAN enabled, according to EthIfCtrlIdx.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfCtrlIdx.NoVlanGroupedFirst</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1170</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1842</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest02004_Err_EthIfMaxCtrl_Exceeded</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_02_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>98</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if the number of EthIfController containers
    exceedes the parameter EthIfMaxCtrl.
  
Test Object: XDM check
Test Precondition: 
    EthIfMaxCtrl is set to 5 -&gt; less then the number of configured EthIfCtrls.
  
Test Execution: 
    VP: The generator shall report an error which states that the number of EthIfController
        containers must not exceed EthIfMaxCtrl.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfMaxCtrl</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1171</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1843</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest02006_Err_EthIfVirtualCtrlSupportEnable_DisabledWhenVlanUsed</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_02_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>121</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if EthIfVirtualCtrlSupportEnable is disabled
    and at least one Eth controller is referenced by more than one EthIf controller.
  
Test Object: XDM check
Test Precondition: 
    EthIfVirtualCtrlSupportEnable is disabled, while a signle EthCtrl is referenced by several
    EthIfCtrls.
  
Test Execution: 
    VP: The generator shall report an error which states that EthIfVirtualCtrlSupportEnable
        must be enabled if one Eth controller is referenced by more than one EthIf controller.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfVirtualCtrlSupportEnable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1172</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1844</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest02007_Err_EthIfVlanId_MultipleControllersNotConfigured</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_02_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>145</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if more then one EthIf controller referencing
    the same Eth controller does not have a valid VLAN identifier.
  
Test Object: XDM check
Test Precondition: 
    EthIfVlanId is disabled in two EthIfCtrls referencing the same EthCtrl.
  
Test Execution: 
    VP: The generator shall report an error which states that all but one EthIf controller
        referencing the same Eth controller must have a valid VLAN identifier.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfVlanId.MultipleControllersNotConfigured</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1173</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1845</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest02008_Err_EthIfController_SameEthController_DiffEthTrcv</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_02_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>168</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if any of EthIf controllers referencing the
    same Eth controller do not reference the same EthTrcv.
  
Test Object: XDM check
Test Precondition: 
    EthIfCtrl_1 is set to reference EthIfTransceiver_2 while referencing EthIfPhysController_0.
    EthIfCtrl_0 and EthIfCtrl_2 reference EthIfTransceiver_0 and EthIfPhysController_0.
  
Test Execution: 
    VP: The generator shall report an error which states that all EthIf controller that reference
        the same Eth controller must also reference the same EthTrcv.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfController.SameEthController.DiffEthTrcv</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1174</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1846</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest02009_Err_EthTrcv_MultipleEthControllers</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_02_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>192</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if EthTrcv is referenced by more then one
    Eth controller.
  
Test Object: XDM check
Test Precondition: 
    EthIfCtrl_1 is set to reference EthIfTransceiver_2, while referencing EthIfPhysController_0.
    EthIfCtrl_0 and EthIfCtrl_2 are referencing EthIfTransceiver_0 and EthIfPhysController_0.
  
Test Execution: 
    VP: The generator shall report an error which states that EthTrcv should be referenced by
        only one Eth controller.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthTrcv.MultipleEthControllers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1175</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1847</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest02010_Err_EthIfVlanId_NotUnique</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_02_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>216</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if VLAN identifiers are not unique for
    EthIf controllers referencing the same Eth controller.
  
Test Object: XDM check
Test Precondition: 
    EthIfVlanId of EthIfCtrl_5 is set to 101, a value already set in EthIfCtrl_4. Both of those
    EthIfCtrls reference the same EthCtrl.
  
Test Execution: 
    VP: The generator shall report an error which states that VLAN identifiers must be unique
        for EthIf controllers referencing the same Eth controller.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfVlanId.Unique</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1176</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1848</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest02011_Err_EthIfOwner_OutOfRange1</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_02_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>240</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if EthIfOwner is below the range [0, 254].
  
Test Object: XDM check
Test Precondition: 
     EthIfOwner is set to -1.
  
Test Execution: 
    VP: The generator shall report an error which states that EthIfOwner value is out of the range,
        and it has to be "&gt;= 0" and "&lt;= 254".
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfOwner.Range</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1177</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1849</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest02012_Err_EthIfOwner_OutOfRange2</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_02_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>262</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if EthIfOwner is above the range [0, 254].
  
Test Object: XDM check
Test Precondition: 
     EthIfOwner is set to 255.
  
Test Execution: 
    VP: The generator shall report an error which states that EthIfOwner value is out of the range,
        and it has to be "&gt;= 0" and "&lt;= 254".
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfOwner.Range</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1177</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1850</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest02013_Err_EthIfMaxPhyCtrl_Exceeded</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_02_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>284</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if the number of physical eth controllers
    (EthIfPhysController) exceeds value of parameter EthIfMaxPhyCtrl.
  
Test Object: XDM check
Test Precondition: 
     EthIfMaxPhyCtrl is set to 2, while there are 3 EthCtrls configured.
  
Test Execution: 
    VP: The generator shall report an error which states that the number of physical eth
        controllers ("EthIfPhysController") must not exceed EthIfMaxPhyCtrl.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfMaxPhyCtrl</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1178</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1851</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest02015_Err_EthCtrl_NotReferenced</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_02_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>307</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if EthIfPhysController is not referenced
    by at least one EthIfController.
  
Test Object: XDM check
Test Precondition: 
    EthIfCtrl_6 is set to reference EthIfPhysController_1, thus EthIfPhysController_2 is not
    referenced by any EthIfCtrl.
  
Test Execution: 
    VP: The generator shall report an error which states that EthIfPhysController shall be
        referenced by one or more EthIfController.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthCtrl.NotReferenced</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1179</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1852</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest02016_Err_EthIfTransciever_BothReferencesDisabled</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_02_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>331</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if EthIfTransciever have both EthIfEthTrcvRef
    and EthIfWEthTrcvRef disabled.
  
Test Object: XDM check
Test Precondition: 
    For EthIfTransceiver_0 both references - EthIfEthTrcvRef and EthIfWEthTrcvRef are disabled.
  
Test Execution: 
    VP: The generator shall report an error which states that EthIfTransciever shall have either
        EthIfEthTrcvRef or EthIfWEthTrcvRef enabled.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfTransciever.BothReferencesDisabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1180</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1853</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest02017_Err_EthIfTransciever_NotReferenced</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_02_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>354</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if EthIfTransciever is not referenced by
    at least one EthIfController.
  
Test Object: XDM check
Test Precondition: 
    A reference to EthIfTransciever in EthIfCtrl_6 is removed, thus EthIfTransceiver_2 is not
    referenced by any EthIfCtrl.
  
Test Execution: 
    VP: The generator shall report an error which states that EthIfTransciever shall be referenced
        by one or more EthIfController.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfTransciever.NotReferenced</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1181</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1854</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest02018_Warn_EthCtrlEnableRxInterrupt_Enabled</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_02_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>378</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise a warning message if at least one Eth controller is configured
    with "EthCtrlEnableRxInterrupt = true" - since EthIf does not support receive interrupts.
  
Test Object: XDM check
Test Precondition: 
    For EthCtrlConfig_0 EthCtrlEnableRxInterrupt is enabled.
  
Test Execution: 
    VP: The generator shall report a warning which states that at least one Eth controller
        is configured with "EthCtrlEnableRxInterrupt = true", and since EthIf does not support
        receive interrupts, user is asked to disable EthCtrlEnableRxInterrupt.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthCtrlEnableRxInterrupt.Enabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1182</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1855</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest02019_Warn_EthCtrlEnableTxInterrupt_Enabled</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_02_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>402</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise a warning message if at least one Eth controller is configured
    with "EthCtrlEnableTxInterrupt = true" - since EthIf does not support transmit interrupts.
  
Test Object: XDM check
Test Precondition: 
    For EthCtrlConfig_0 EthCtrlEnableTxInterrupt is enabled.
  
Test Execution: 
    VP: The generator shall report a warning which states that at least one Eth controller
        is configured with "EthCtrlEnableTxInterrupt = true", and since EthIf does not support
        transmit interrupts, user is asked to disable EthCtrlEnableTxInterrupt.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthCtrlEnableTxInterrupt.Enabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1183</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1856</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest02020_Err_EthIfMainFunctionPeriod_OutOfRange1</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_02_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>426</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if EthIfMainFunctionPeriod is above
    the range [0, 65535].
  
Test Object: XDM check
Test Precondition: 
    EthIfMainFunctionPeriod is set to 65536.0.
  
Test Execution: 
    VP: The generator shall report an error which states that the value of EthIfMainFunctionPeriod
        is out of the range and it must be "&gt;= 0" and "&lt;= 65535".
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfMainFunctionPeriod.Range</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1184</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1857</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest02021_Err_EthIfMainFunctionPeriod_OutOfRange2</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_02_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>449</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if EthIfMainFunctionPeriod is
    below the range [0, 65535].
  
Test Object: XDM check
Test Precondition: 
    EthIfMainFunctionPeriod is set to -1.
  
Test Execution: 
    VP: The generator shall report an error which states that the value of EthIfMainFunctionPeriod
        is out of the range and it must be "&gt;= 0" and "&lt;= 65535".
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfMainFunctionPeriod.Range</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1184</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1858</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest02022_Err_EthIfRxIndicationIterations_OutOfRange1</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_02_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>472</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if EthIfRxIndicationIterations is
    above the range [1, 65535].
  
Test Object: XDM check
Test Precondition: 
    EthIfMainFunctionPeriod is set to 65536.
  
Test Execution: 
    VP: The generator shall report an error which states that the value of
        EthIfRxIndicationIterations is out of the range and it must be "&gt;= 1" and "&lt;= 65535".
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfRxIndicationIterations.Range</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1185</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1859</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest02023_Err_EthIfRxIndicationIterations_OutOfRange2</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_02_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>496</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if EthIfRxIndicationIterations is below the
    range [1, 65535].
  
Test Object: XDM check
Test Precondition: 
    EthIfMainFunctionPeriod is set to 0.
  
Test Execution: 
    VP: The generator shall report an error which states that the value of
        EthIfRxIndicationIterations is out of the range and it must be "&gt;= 1" and "&lt;= 65535".
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfRxIndicationIterations.Range</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1185</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1860</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest02024_Err_EthIfPhysCtrlRxMainFuncPrioProces_EthIfEthCtrlRef_Invalid</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_02_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>520</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if EthIfEthCtrlRef in
    EthIfPhysCtrlRxMainFunctionPriorityProcessing is not valid.
  
Test Object: XDM check
Test Precondition: 
    EthIfEthCtrlRef in EthIfPhysCtrlRxMainFunctionPriorityProcessing is set invalid.
  
Test Execution: 
    VP: The generator shall report an error which states that invalid reference is detected,
        and that EthIfEthCtrlRef must refer to a valid node.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfPhysCtrlRxMainFuncPrioProces.EthIfEthCtrlRef.Invalid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1186</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1861</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest02025_Err_EthIfPhysCtrlRxMainFuncPrioProces_FifoAlreadyMapped</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_02_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>544</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if EthIfEthCtrlRef in
    EthIfPhysCtrlRxMainFunctionPriorityProcessing is already used.
  
Test Object: XDM check
Test Precondition: 
    The same EthIfEthCtrlRef is used twice in EthIfPhysCtrlRxMainFunctionPriorityProcessing.
  
Test Execution: 
    VP: The generator shall report an error which states that "fifo is already mapped".
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfPhysCtrlRxMainFuncPrioProces.FifoAlreadyMapped</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1187</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1862</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest02026_Err_EthIfPhysCtrlRxIndicationIterations_OutOfRange1</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_02_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>567</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if EthIfPhysCtrlRxIndicationIterations is above
    the range [1, 65535].
  
Test Object: XDM check
Test Precondition: 
    EthIfPhysCtrlRxIndicationIterations is set to 65536.
  
Test Execution: 
    VP: The generator shall report an error which states that the value of
       EthIfPhysCtrlRxIndicationIterations is out of the range and it must be "&gt;= 1" and "&lt;= 65535".
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfPhysCtrlRxIndicationIterations.Range</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1188</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1863</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest02027_Err_EthIfPhysCtrlRxIndicationIterations_OutOfRange2</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_02_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>590</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if EthIfPhysCtrlRxIndicationIterations is below
    the range [1, 65535].
  
Test Object: XDM check
Test Precondition: 
    EthIfPhysCtrlRxIndicationIterations is set to 0.
  
Test Execution: 
    VP: The generator shall report an error which states that the value of
    EthIfPhysCtrlRxIndicationIterations is out of the range and it must be "&gt;= 1" and "&lt;= 65535".
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfPhysCtrlRxIndicationIterations.Range</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1188</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1864</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EthIf_GenTest03001_Err_PortsInPortGroup_Unique</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_03_SwtPortGroups_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>28</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if ports in a port group are duplicated.
  
Test Object: XDM check
Test Precondition: 
  
Test Execution: 
    VP: The generator shall report an error which states that ports must be unique
        in the port group.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.PortsInPortGroup.Unique</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1199</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1865</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest03002_Err_EthIfSwitchPortGroupIdx_NotZeroBased</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_03_SwtPortGroups_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>49</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if not all EthIfSwitchPortGroupIdx are zero based.
  
Test Object: XDM check
Test Precondition: 
    EthIfSwitchPortGroupIdx = not zero based.
  
Test Execution: 
    VP: The generator shall report an error which states that the configuration parameter
        EthIfSwitchPortGroupIdx is not zero based.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfSwitchPortGroupIdx.ZeroBased</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1191</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1866</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest03003_Err_EthIfSwitchPortGroupIdx_NotConsecutive</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_03_SwtPortGroups_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>71</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if not all EthIfSwitchPortGroupIdx are
    consecutive.
  
Test Object: XDM check
Test Precondition: 
    EthIfSwitchPortGroupIdx = not consecutive.
  
Test Execution: 
    VP: The generator shall report an error which states that the configuration parameter
        EthIfSwitchPortGroupIdx is not consecutive.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfSwitchPortGroupIdx.Consecutive</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1192</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1867</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest03004_Err_EthIfSwitchIdx_NotZeroBased</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_03_SwtPortGroups_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>94</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if not all EthIfSwitchIdx are zero based.
  
Test Object: XDM check
Test Precondition: 
    EthIfSwitchIdx = not zero based.
  
Test Execution: 
    VP: The generator shall report an error which states that the configuration parameter
        EthIfSwitchIdx is not zero based.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfSwitchIdx.ZeroBased</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1193</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1868</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest03005_Err_EthIfSwitchIdx_NotConsecutive</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_03_SwtPortGroups_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>116</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if not all EthIfSwitchIdx are consecutive.
  
Test Object: XDM check
Test Precondition: 
    EthIfSwitchIdx = not consecutive.
  
Test Execution: 
    VP: The generator shall report an error which states that the configuration parameter
        EthIfSwitchIdx is not consecutive.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfSwitchIdx.Consecutive</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1194</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1869</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest03006_Err_EthIfMaxSwtPortGroups_Exceeded</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_03_SwtPortGroups_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>138</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if total number of switch ports groups exceeds
    the value of parameter EthIfMaxSwtPortGroups.
  
Test Object: XDM check
Test Precondition: 
     EthIfMaxSwtPortGroups is set to 4, while there are 5 switch ports groups configured.
  
Test Execution: 
    VP: The generator shall report an error which states that the total number of ports
        must not exceed EthIfMaxSwtPortGroups.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfMaxSwtPortGroups</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1195</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1870</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest03007_Err_Trcv_PortGroup_InvalidReference</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_03_SwtPortGroups_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>161</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if a single EthIfController references both
    Ethernet transceiver and a port group.
  
Test Object: XDM check
Test Precondition: 
  
Test Execution: 
    VP: The generator shall report an error which states that EthTrcv and Port group (Switch)
        cannot be referenced by the same EthIf controller.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.Trcv.PortGroup.InvalidReference</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1196</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1871</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest03008_Err_EthIfSwitchRefOrPortGroupRef_InvalidReference</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_03_SwtPortGroups_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>183</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if EthIfSwitchRefOrPortGroupRef is enabled
    but does not reference a valid port group or a switch.
  
Test Object: XDM check
Test Precondition: 
  
Test Execution: 
    VP: The generator shall report an error which states that invalid reference is detected, and
        that EthIfSwitchRefOrPortGroupRef must refer to valid node if enabled.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfSwitchRefOrPortGroupRef.InvalidReference</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1197</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1872</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest03009_Err_PortGroupRefByIfCtrl_PortSemanticsNotSet</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_03_SwtPortGroups_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>205</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if port group referenced by EthIf controller
    does not have EthIfSwitchPortGroupRefSemantics set.
  
Test Object: XDM check
Test Precondition: 
  
Test Execution: 
    VP: The generator shall report an error which states that port group referenced by 
        EthIf controller does not have EthIfSwitchPortGroupRefSemantics set.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.PortGroupRefByIfCtrl.PortSemanticsNotSet</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1198</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1873</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest03010_Err_EthIfMaxSwtPorts_Exceeded</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_03_SwtPortGroups_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>227</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if total number of switch ports exceeds the value
    of parameter EthIfMaxSwtPorts.
  
Test Object: XDM check
Test Precondition: 
     EthIfMaxSwtPorts is set to 11, while there are 12 switch ports configured.
  
Test Execution: 
    VP: The generator shall report an error which states that the total number of ports
        must not exceed EthIfMaxSwtPorts.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfMaxSwtPorts</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1190</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1874</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest03011_Err_EthIfSwitchPortGroup_EthIfPortRef_Invalid</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_03_SwtPortGroups_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>250</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if EthIfPortRef contains invalid reference.
  
Test Object: XDM check
Test Precondition: 
  
Test Execution: 
    VP: The generator shall report an error which states that invalid reference has been detected
    and that EthIfPortRef must refer to valid node.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfSwitchPortGroup.EthIfPortRef.Invalid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1201</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1875</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest03012_Err_EthIfSwitchPortGroup_EthIfPortRef_SwitchUndefined</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_03_SwtPortGroups_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>271</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message for a port referenced in a port group, 
    that does not have switch defined in EthIfSwitch container.
  
Test Object: XDM check
Test Precondition: 
  
Test Execution: 
    VP: The generator shall report an error which states that port referenced in a port group 
    requires its switch to be defined in EthIfSwitch container.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfSwitchPortGroup.EthIfPortRef.SwitchUndefined</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1202</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1876</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest03013_Err_EthIfGetBufferLevelApi_EthSwtGetBufferLevelApi_False</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_03_SwtPortGroups_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>293</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if config parameter EthIfGetBufferLevelApi is
    set, but connecting config param in EthSwt, EthSwtGetBufferLevelApi is not set.
  
Test Object: XDM check
Test Precondition: 
  
Test Execution: 
    VP: The generator shall report an error which states that when EthIfGetBufferLevelApi is
    set, EthSwt/EthSwtGeneral/EthSwtGetBufferLevelApi must also be enabled.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfSwitch.GetBufferLevelApiSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1204</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1877</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest03014_Err_EthIfGetArlTableApi_EthSwtGetArlTableApi_False</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_03_SwtPortGroups_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>315</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if config parameter EthIfGetArlTableApi is set, but
    connecting config param in EthSwt, EthSwtGetArlTableApi is not set.
  
Test Object: XDM check
Test Precondition: 
  
Test Execution: 
    VP: The generator shall report an error which states that when EthIfGetArlTableApi is set,
    EthSwt/EthSwtGeneral/EthSwtGetArlTableApi must also be enabled.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfSwitch.GetArlTableApiSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1205</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1878</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest03015_Err_EthIfSwtGetCounterValuesApi_EthSwtGetDropCountApi_False</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_03_SwtPortGroups_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>337</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if config parameter EthIfSwtGetCounterValuesApi
    is set,but connecting config param in EthSwt, EthSwtGetDropCountApi is not set.
  
Test Object: XDM check
Test Precondition: 
  
Test Execution: 
    VP: The generator shall report an error which states that when EthIfSwtGetCounterValuesApi is
    set, EthSwt/EthSwtGeneral/EthSwtGetDropCountApi must also be enabled.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfSwitch.GetCounterValuesApiSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1206</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1879</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest03016_Err_EthIfStoreConfigurationApi_EthSwtStoreConfigurationApi_False</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_03_SwtPortGroups_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>359</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if config parameter EthIfStoreConfigurationApi is set, but
    connecting config param in EthSwt, EthSwtStoreConfigurationApi is not set.
  
Test Object: XDM check
Test Precondition: 
  
Test Execution: 
    VP: The generator shall report an error which states that when EthIfStoreConfigurationApi is set,
    EthSwt/EthSwtGeneral/EthSwtStoreConfigurationApi must also be enabled.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfSwitch.StoreConfigurationApiSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1207</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1880</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest03017_Err_EthIfResetConfigurationApi_EthSwtResetConfigurationApi_False</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_03_SwtPortGroups_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>381</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The generator shall raise an error message if config parameter EthIfResetConfigurationApi is set, but
    connecting config param in EthSwt, EthSwtResetConfigurationApi is not set.
  
Test Object: XDM check
Test Precondition: 
  
Test Execution: 
    VP: The generator shall report an error which states that when EthIfResetConfigurationApi is set,
    EthSwt/EthSwtGeneral/EthSwtResetConfigurationApi must also be enabled.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfSwitch.ResetConfigurationApiSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1208</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1881</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EthIf_GenTest04001_Err_EthIfEthControllerBswmdImplementationRefs_NotUnique</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_04_MultipleDriverSupport/source/application/testspec.h</sourcefile>
      <sourceline>28</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case shall check that the generator shall raise an error message if an entry in
    EthIfEthControllerBswmdImplementationRefs is not unique.
  
Test Object: XDM check
Test Precondition: 
    Configuration set with multiple Ethernet controller and transceivers.
  
Test Execution: 
    VP: The generator shall report an error which states that an entry in
    EthIfEthControllerBswmdImplementationRefs must be unique.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfEthControllerBswmdImplementationRefs.Unique</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1213</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1882</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest04002_Err_EthIfEthTrcvBswmdImplementationRefs_NotUnique</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_04_MultipleDriverSupport/source/application/testspec.h</sourcefile>
      <sourceline>52</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case shall check that the generator shall raise an error message if an entry in
    EthIfEthTrcvBswmdImplementationRefs is not unique.
  
Test Object: XDM check
Test Precondition: 
    Configuration set with multiple Ethernet controller and transceivers.
  
Test Execution: 
    VP: The generator shall report an error which states that an entry in
    EthIfEthTrcvBswmdImplementationRefs must be unique.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfEthTrcvBswmdImplementationRefs.Unique</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1217</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1883</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest04003_Err_BswmdImplementationRefs_WrongASRVers</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_04_MultipleDriverSupport/source/application/testspec.h</sourcefile>
      <sourceline>76</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case shall check that the generator shall raise an error message if an entry in
    EthIfEthControllerBswmdImplementationRefs or EthIfEthTrcvBswmdImplementationRefs or 
  EthIfEthSwtBswmdImplementationRefs exist while EthIfSupportEthAPI is set for the value
  below ASR430 (ASR403 or ASR422).
  
Test Object: XDM check
Test Precondition: 
    Configuration set with multiple Ethernet controllers and transceivers.
  
Test Execution: 
    VP: The generator shall report an error which states that neither
  EthIfEthControllerBswmdImplementationRefs nor EthIfEthTrcvBswmdImplementationRefs nor 
  EthIfEthSwtBswmdImplementationRefscan can be used for driver versions below ASR4.3.0.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfEthControllerBswmdImplementationRefs.WrongASRVers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1214</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfEthTrcvBswmdImplementationRefs.WrongASRVers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1218</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfEthSwtBswmdImplementationRefs.WrongASRVers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1221</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1884</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest04004_Err_BswmdImplementationRefs_InitCtrlTrcvSet</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_04_MultipleDriverSupport/source/application/testspec.h</sourcefile>
      <sourceline>111</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case checks that the generator shall raise an error message if an entry in
    EthIfEthControllerBswmdImplementationRefs or EthIfEthTrcvBswmdImplementationRefs exist while 
  EthIfInitControllersTransceivers is set to true, which is not allowed for Ethernet drivers
  below ASR430.
  
Test Object: XDM check
Test Precondition: 
    Configuration set with multiple Ethernet controller and transceivers.
  
Test Execution: 
    VP: The generator shall report an error which states that neither
  EthIfEthControllerBswmdImplementationRefs nor EthIfEthTrcvBswmdImplementationRefs can be used 
  while EthIfInitControllersTransceivers is enabled.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfEthControllerBswmdImplementationRefs.InitCtrlTrcvSet</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1215</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfEthTrcvBswmdImplementationRefs.InitCtrlTrcvSet</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1219</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1885</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EthIf_GenTest05001_Err_EthIfQualifiedUnexpectedLinkDownTime_PassiveSlave</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_05_Trcv_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>28</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case shall check that the generator shall raise an error message if
    EthIfQualifiedUnexpectedLinkDownTime is used and EthTrcvActAsSlavePassiveEnabled
    is set to FALSE.
  
Test Object: XDM check
Test Precondition: 
    EthIfWakeupSleepOnDatalineSupportEnabled is enabled
    EthIfQualifiedUnexpectedLinkDownTime is used
    EthTrcvActAsSlavePassiveEnabled is set to FALSE
  
Test Execution: 
    VP: The generator shall report an error which states that if
    EthIfQualifiedUnexpectedLinkDownTime is used then referenced transceiver
    needs to have EthTrcvActAsSlavePassiveEnabled set to TRUE.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfQualifiedUnexpectedLinkDownTime.PassiveSlave</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1226</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1886</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest05002_Err_EthIfQualifiedUnexpectedLinkDownTime_StatePeriod</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_05_Trcv_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>56</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case shall check that the generator shall raise an error message if
    EthIfQualifiedUnexpectedLinkDownTime is used and EthIfMainFunctionStatePeriod
    is disabled.
  
Test Object: XDM check
Test Precondition: 
    EthIfWakeupSleepOnDatalineSupportEnabled is enabled
    EthIfQualifiedUnexpectedLinkDownTime is used
    EthIfMainFunctionStatePeriod is disabled
  
Test Execution: 
    VP: The generator shall report an error which states that if
    EthIfQualifiedUnexpectedLinkDownTime is used then
    EthIfMainFunctionStatePeriod has to be enabled.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfQualifiedUnexpectedLinkDownTime.StatePeriod</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1227</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1887</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest05003_Err_EthIfQualifiedUnexpectedLinkDownTime_WakeupSupport</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_05_Trcv_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>84</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case shall check that the generator shall raise an error message if
    EthIfQualifiedUnexpectedLinkDownTime is used and EthIfWakeupSleepOnDatalineSupportEnabled
    is disabled.
  
Test Object: XDM check
Test Precondition: 
    EthIfWakeupSleepOnDatalineSupportEnabled is enabled
    EthIfQualifiedUnexpectedLinkDownTime is used
    EthIfWakeupSleepOnDatalineSupportEnabled is disabled
  
Test Execution: 
    VP: The generator shall report an error which states that if
    EthIfQualifiedUnexpectedLinkDownTime is used then
    EthIfWakeupSleepOnDatalineSupportEnabled needs to be enabled.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfQualifiedUnexpectedLinkDownTime.WakeupSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1228</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1888</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest05004_Err_EthIfQualifiedUnexpectedLinkDownTime_StatePeriodMultiple</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_05_Trcv_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>112</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case shall check that the generator shall raise an error message if
    EthIfQualifiedUnexpectedLinkDownTime is used and the value is not
    multiple of EthIfMainFunctionStatePeriod.
  
Test Object: XDM check
Test Precondition: 
    EthIfWakeupSleepOnDatalineSupportEnabled is enabled
    EthIfQualifiedUnexpectedLinkDownTime is used and set to value 0.03
    EthIfMainFunctionStatePeriod is enabled and set to value 0.02
  
Test Execution: 
    VP: The generator shall report an error which states that if
    EthIfQualifiedUnexpectedLinkDownTime is used then value should
    be multiple of EthIfMainFunctionStatePeriod.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfQualifiedUnexpectedLinkDownTime.StatePeriodMultiple</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1229</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1889</internalId></specobject>
    <specobject>
      <id>EthIf_GenTest05005_Err_EthIfQualifiedUnexpectedLinkDownTime_Range</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Generic/IN/EthIf_GenTest_05_Trcv_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>140</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case shall check that the generator shall raise an error message if
    EthIfQualifiedUnexpectedLinkDownTime is used and neither Infinity nor in
    the range between 0 and 65534.
  
Test Object: XDM check
Test Precondition: 
    EthIfWakeupSleepOnDatalineSupportEnabled is enabled
    EthIfQualifiedUnexpectedLinkDownTime is used and set to value 65535.0
  
Test Execution: 
    VP: The generator shall report an error which states that if
    EthIfQualifiedUnexpectedLinkDownTime is used then the range of
    the given value is either Infinity or between 0 and 65534.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.XdmCheck.EthIfQualifiedUnexpectedLinkDownTime.Range</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1230</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1890</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EthIf_ConTest02048_SetControllerMode_Wakeup_Activate</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Include/EthIf_Incl07_ConTest02_Common/TestSpec_Generated.h</sourcefile>
      <sourceline>9</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that transceiver link was correctly changed from DOWN to ACIVE when EthIf_SetControllerMode was called with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST.
Test Object: Activation with wakeup request
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   Switch and switch group support is disabled
    -   EthIf and test setup is initialized
  
Test Execution: 
    01: Set Ethernet interface controller and transceiver mode to ACTIVE_WITH_WAKEUP_REQUEST.
    02: Call EthIf_MainFunctionRx to change link state to ACTIVE.
    03: VP(EthIf.ASR43.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange,1) Verify that the link was changed to ACTIVE.
    04: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>130</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1891</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest02049_SetControllerMode_Wakeup_Deactivate</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Include/EthIf_Incl07_ConTest02_Common/TestSpec_Generated.h</sourcefile>
      <sourceline>33</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Verify that transceiver link was correctly changed from ACIVE to DOWN when EthIf_SetControllerMode was activated with ETH_MODE_ACTIVE_WITH_WAKEUP_REQUEST.
Test Object: Deactivation with wakeup request
Test Precondition: 
    -   Wakeup and sleep on data line support is enabled
    -   Transceiver support is enabled and referenced on EthIf controller
    -   Switch and switch group support is disabled
    -   EthIf and test setup is initialized
    -   Activate link state of the transceiver
  
Test Execution: 
    01: Set Ethernet interface controller and transceiver mode to DOWN.
    02: Call EthIf_MainFunctionRx to change link state to DOWN.
    03: VP(EthIf.ASR43.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange,1) Verify that the link was changed to DOWN.
    04: Sanity check - Verify trace is empty
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_MainFunctionRx_NotifyTrcvLinkStateChange</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>130</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1892</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EthIf_ConTest02000_MainFunction_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Include/EthIf_Incl07_ConTest02_Common/source/application/EthIf_ConTest02_FunctionCheck.c</sourcefile>
      <sourceline>41</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that calling EthIf_MainFunctionRx() and EthIf_MainFunctionTx() while the
    module is not initialized, the functions will return without taking any action.
  
Test Object: 
    EthIf_MainFunctionRx().
    EthIf_MainFunctionTx().
  
Test Precondition: 
    EthIf uninitialized.
  
Test Execution: 
    01: Call EthIf_MainFunctionRx().
    02: VP(EthIf.EB.SWS_EthIf_00098): Verify that no action was taken.
    03: Call EthIf_MainFunctionTx().
    04: VP(EthIf.EB.SWS_EthIf_00124): Verify that no action was taken.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00098</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>149</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.SWS_EthIf_00124</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1893</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest02001_SetPhysAddr</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Include/EthIf_Incl07_ConTest02_Common/source/application/EthIf_ConTest02_FunctionCheck.c</sourcefile>
      <sourceline>93</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that EthIf_SetPhysAddr() shall forward the call to Eth_SetPhysAddr().
  
Test Object: 
    EthIf_SetPhysAddr().
  
Test Precondition: 
    - EthIf initialized.
    - Configuration parameter EthIfSetPhysAddrSupportEnable = TRUE.
  
Test Execution: 
    01: Call EthIf_SetPhysAddr().
    02: VP(EthIf.ASR43.SWS_EthIf_00134, EthIf.EB.EthIfSetPhysAddrSupportEnable_Enable):
        Verify that Eth_SetPhysAddr() was called with corresponding EthCtrlIdx.
        PhysAddr shall be passed from EthIf_SetPhysAddr() to Eth_SetPhysAddr().
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00134</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>494</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.EthIfSetPhysAddrSupportEnable_Enable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>183</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1894</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest02002_UpdatePhysAddrFilter</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Include/EthIf_Incl07_ConTest02_Common/source/application/EthIf_ConTest02_FunctionCheck.c</sourcefile>
      <sourceline>152</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that EthIf_UpdatePhysAddrFilter() shall forward the call to
    Eth_UpdatePhysAddrFilter().
  
Test Object: 
    EthIf_UpdatePhysAddrFilter().
  
Test Precondition: 
    - EthIf initialized.
    - Configuration parameter EthIfUpdatePhysAddrFilterSupportEnable = TRUE.
  
Test Execution: 
    01: Call EthIf_UpdatePhysAddrFilter().
    02: VP(EthIf.ASR43.SWS_EthIf_00140, EthIf.EB.EthIfUpdatePhysAddrFilterSupportEnable_Enable):
        Verify that Eth_UpdatePhysAddrFilter() was called with corresponding EthCtrlIdx.
        PhysAddr and the action shall be passed from EthIf_UpdatePhysAddrFilter()
        to Eth_UpdatePhysAddrFilter().
    03: Configure EthIf_UpdatePhysAddrFilter stub to return E_NOT_OK.
    04: Repeat the call to Eth_UpdatePhysAddrFilter() from step 02.
    05: VP(EthIf.ASR43.SWS_EthIf_00140): Verify that EthIf_UpdatePhysAddrFilter() returns E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00140</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>499</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.EthIfUpdatePhysAddrFilterSupportEnable_Enable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>186</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1895</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest02003_SetControllerMode</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Include/EthIf_Incl07_ConTest02_Common/source/application/EthIf_ConTest02_FunctionCheck.c</sourcefile>
      <sourceline>234</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that EthIf_SetControllerMode() returns E_NOT_OK if Eth_SetControllerMode()
    returns E_NOT_OK.
    Also it verifies that if EthIf_SetControllerMode() is called with ETH_MODE_ACTIVE and it returns
    E_NOT_OK, the next call to EthIf_MainFunction() shall call Eth_SetControllerMode() again with
    ETH_MODE_ACTIVE.
  
Test Object: 
    EthIf_SetControllerMode().
  
Test Precondition: 
    EthIf initialized.
    Eth_SetControllerMode return value set to E_NOT_OK.
  
Test Execution: 
    01: Call EthIf_SetControllerMode() and verify that Eth_SetControllerMode() was called with
        correct parameters.
    02: VP(EthIf.EB.SetCtrlMode.HwNotOk):
        Verify that EthIf_SetControllerMode() returns E_NOT_OK.
    03: Call EthIf_MainFunctionRx() in a loop.
    04: VP(EthIf.EB.VirtCtrlAccess.RepeatSetCtrlModeActive.HwNotOk): Verify that
        Eth_SetControllerMode() is repeatedly called with ETH_MODE_ACTIVE as long as it
        returns E_NOT_OK.
    05: Set Eth_SetControllerMode stub to return E_OK.
    06: Call EthIf_MainFunctionRx().
    07: Verify that Eth_SetControllerMode() is called with correct parameters.
    08: VP(SWS_EthIf_00252): Verify that EthSM_CtrlModeIndication() is called, as a consequence of
        a successful call to Eth_SetControllerMode() which triggered EthIf_CtrlModeIndication().
    09: Call EthIf_MainFunctionRx().
    10: VP(EthIf.EB.VirtCtrlAccess.RepeatSetCtrlModeActive.HwNotOk): Verify that
        Eth_SetControllerMode() is no longer called in MainFunction().
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SetCtrlMode.HwNotOk</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>159</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.VirtCtrlAccess.RepeatSetCtrlModeActive.HwNotOk</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>161</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00252</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>575</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1896</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest02005_MainFunction_NotInit</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Include/EthIf_Incl07_ConTest02_Common/source/application/EthIf_ConTest02_FunctionCheck.c</sourcefile>
      <sourceline>348</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that calling EthIf_MainFunctionRx() or EthIf_MainFunctionTx() will check
    the EthCtrlIdx if the controller is initialized and perform no API call to other modules if
    controller is not initialized.
  
Test Object: 
    EthIf_MainFunctionRx().
    EthIf_MainFunctionTx().
  
Test Precondition: 
    No Eth controller is initialized.
  
Test Execution: 
    01: Call EthIf_MainFunctionRx().
    02: VP(EthIf.EB.MainFunctionRx.CtrlNotInit): Since no controller is initialized, verify that
        no API call is performed.
    03: Call EthIf_MainFunctionTx().
    04: VP(EthIf.EB.MainFunctionTx.CtrlNotInit): Since no controller is initialized, verify that
        no API call is performed.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MainFunctionRx.CtrlNotInit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>175</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.MainFunctionTx.CtrlNotInit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>176</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1897</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest02007_TransceiverInit_NotOK</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Include/EthIf_Incl07_ConTest02_Common/source/application/EthIf_ConTest02_FunctionCheck.c</sourcefile>
      <sourceline>406</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthTrcv_TransceiverInit() returns E_NOT_OK, the transceiver will
    not be initialized when EthIf_Init() is called.
  
Test Object: 
    EthIf_Init().
  
Test Precondition: 
    EthTrcv_TransceiverInit() set to return E_NOT_OK.
  
Test Execution: 
    01: Call EthIf_Init() - it will initialize all configured EthControllers, but will not
        initialize EthTransceivers because of a stub setup.
    02: Call EthIf_SetControllerMode().
    03: VP(): Verify that EthTrcv_SetTransceiverMode() is not called - the call is skipped
        because transceiver is not initialized.
    04: Call EthIf_MainFunctionRx() to process transceiver link state transitions.
    05: VP(): Verify that EthTrcv_GetTransceiverMode() or EthTrcv_GetLinkState() have not been
        called - calls are skipped because transceiver is not initialized.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.EthTrcvTransceiverInit_NotOk</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>199</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1898</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest02008_RX_GetLinkState</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Include/EthIf_Incl07_ConTest02_Common/source/application/EthIf_ConTest02_FunctionCheck.c</sourcefile>
      <sourceline>479</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that EthIf_MainFunctionRx() polls EthTrcv_GetLinkState() for all
    configured transceivers to detect a link state change.
  
Test Object: 
    EthIf_MainFunctionRx().
  
Test Precondition: 
    EthIfVLANSupportEnable = STD_ON.
    EthIfTrcvSupportEnable = STD_ON.
    EthIf_Init is called.
  
Test Execution: 
    01: Call EthIf_SetControllerMode() to activate respective controller and transceiver.
    02: Call EthIf_MainFunctionRx().
    03: VP(): Verify that EthTrcv_GetLinkState() is called for an active transceiver.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.ASR43.SWS_EthIf_MainFunctionRx_PollEthTrcvLinkState</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>129</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1899</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest02010_SetControllerMode_Down</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Include/EthIf_Incl07_ConTest02_Common/source/application/EthIf_ConTest02_FunctionCheck.c</sourcefile>
      <sourceline>553</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that the second call to EthIf_SetControllerMode() for the same EthIfCtrlIdx
    using ETH_MODE_DOWN, will just return E_OK and don`t call Eth_SetControllerMode() and a
    further call to EthIf_SetControllerMode() using ETH_MODE_ACTIVE will call
    Eth_SetControllerMode() with ETH_MODE_ACTIVE.
  
Test Object: 
    EthIf_SetControllerMode().
  
Test Precondition: 
    EthIf initialized.
    Eth controller initialized.
    Set the controller to MODE_ACTIVE.
  
Test Execution: 
    01: Call EthIf_SetControllerMode() using ETH_MODE_DOWN.
    02: Call EthIf_MainFunctionRx() - It will call EthTrcv_GetTransceiverMode(), and since it's
        stub is configured to return DOWN it will put transceiver into DOWN mode.
    03: Call EthIf_SetControllerMode() for a second time using ETH_MODE_DOWN.
    04: VP(EthIf.EB.RepeatSetCtrlModeDown):
        Verify that second call of EthIf_SetControllerMode() returns E_OK.
    05: VP(EthIf.EB.RepeatSetCtrlModeDown):
        Verify that Eth_SetControllerMode is not called.
    06: Call EthIf_SetControllerMode() using ETH_MODE_ACTIVE.
    07: VP(EthIf.EB.RepeatSetCtrlModeDown):
        Verify that Eth_SetControllerMode is called with ETH_MODE_ACTIVE.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.RepeatSetCtrlModeDown</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>163</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1900</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest02015_SetControllerMode_DownRepeat</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Include/EthIf_Incl07_ConTest02_Common/source/application/EthIf_ConTest02_FunctionCheck.c</sourcefile>
      <sourceline>671</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that if EthIf_SetControllerMode() is called with ETH_MODE_DOWN and it
    returns E_NOT_OK, the next call to EthIf_MainFunction() shall call Eth_SetControllerMode()
    again with ETH_MODE_DOWN.
  
Test Object: 
    EthIf_SetControllerMode().
  
Test Precondition: 
    EthIf initialized.
    Eth controller initialized.
    Controller that has the virtual control enabled.
    Set controller mode to ETH_MODE_ACTIVE.
    Eth_SetControllerMode() return value set to E_NOT_OK.
  
Test Execution: 
    01: Call EthIf_SetControllerMode() using ETH_MODE_DOWN.
    02: Call EthIf_MainFunctionRx() in a loop.
    03: VP(): Verify that Eth_SetControllerMode() is repeatedly called with ETH_MODE_DOWN as
        long as it returns E_NOT_OK.
    04: Set Eth_SetControllerMode stub to return E_OK.
    05: Call EthIf_MainFunctionRx().
    06: VP(): Verify that Eth_SetControllerMode() is called with correct parameters.
    07: Call EthIf_MainFunctionRx().
    08: VP(): Verify that Eth_SetControllerMode() is no longer called in MainFunction().
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.VirtCtrlAccess.RepeatSetCtrlModeDown.HwNotOk</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>162</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1901</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest02016_GetControllerMode</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Include/EthIf_Incl07_ConTest02_Common/source/application/EthIf_ConTest02_FunctionCheck.c</sourcefile>
      <sourceline>789</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that EthIf_GetControllerMode() shall forward the call to function
    Eth_GetControllerMode() of the respective Ethernet controller driver.
  
Test Object: 
    EthIf_GetControllerMode().
  
Test Precondition: 
    EthIf initialized.
    Eth controller initialized.
  
Test Execution: 
    01: Call EthIf_GetControllerMode().
    02: VP(EthIf.ASR43.SWS_EthIf_00040): Verify that Eth_GetControllerMode() is called with
        ETH_MODE_DOWN and with the respective Ethernet controller driver.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00040</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>428</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1902</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest02019_MainFunction_Init_ACTIVE</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Include/EthIf_Incl07_ConTest02_Common/source/application/EthIf_ConTest02_FunctionCheck.c</sourcefile>
      <sourceline>845</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: None.
Test Object: 
    EthIf_MainFunctionRx().
    EthIf_MainFunctionTx().
  
Test Precondition: 
    EthIf initialized.
    Controllers initialized.
    Set the controller to ETH_MODE_ACTIVE.
  
Test Execution: 
    01: Call EthIf_MainFunctionTx().
    02: VP(SWS_EthIf_00115): Verify that Eth_TxConfirmation() was called for right Eth controller.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00114</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>472</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00115</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>473</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1903</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest02020_InvalidNoVLANCtrlIdx_RxIndication</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Include/EthIf_Incl07_ConTest02_Common/source/application/EthIf_ConTest02_FunctionCheck.c</sourcefile>
      <sourceline>896</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_RxIndication() is called and frame is not VLAN, and if CtrlIdx
    does not match to any EthIfCtrlIdx with disabled config parameter EthIfVlanId, the frame
    will be ignored.
  
Test Object: 
    EthIf_RxIndication().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_RxIndication() using an CtrlIdx which has EthIfVlanId enabled.
    02: VP(): Verify that the frame was ignored.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.EthIf_RxIndication.IgnorInvalidNoVLANCtrlIdx</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>192</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1904</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest02021_BufReq_NOTOK</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Include/EthIf_Incl07_ConTest02_Common/source/application/EthIf_ConTest02_FunctionCheck.c</sourcefile>
      <sourceline>949</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if Eth_ProvideTxBuffer returns BUFREQ_E_NOT_OK, EthIf_ProvideTxBuffer
    will return also BUFREQ_E_NOT_OK.
  
Test Object: None.
Test Precondition: 
    - A controller is in state ACTIVE.
  
Test Execution: 
    01: Set Eth_ProvideTxBuffer to return BUFREQ_E_NOT_OK.
    02: Call EthIf_ProvideTxBuffer with the parameter(s) defined in the input section.
    03: VP: Verify that EthIf_ProvideTxBuffer returned BUFREQ_E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.EthIf_ProvideTxBuffer.DriverError</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>196</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1905</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest02022_ProvideTxBuffer_Disabled_VlanId</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Include/EthIf_Incl07_ConTest02_Common/source/application/EthIf_ConTest02_FunctionCheck.c</sourcefile>
      <sourceline>1027</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Call EthIf_ProvideTxBuffer() using a CtrlIdx that has EthIfVlanId disabled.
  
Test Object: None.
Test Precondition: 
    EthIfVlanId is false.
    A controller is in state ACTIVE.
  
Test Execution: 
    01: Call EthIf_ProvideTxBuffer() using a CtrlIdx that has EthIfVlanId disabled.
    02: EthIf_ProvideTxBuffer() shall return BUFREQ_E_OK.
    03: VP: Eth_ProvideTxBuffer() shall be called with the expected parameter(s).
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00068.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>940</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1906</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest02023_TxConfirmation_Invalid_BufIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Include/EthIf_Incl07_ConTest02_Common/source/application/EthIf_ConTest02_FunctionCheck.c</sourcefile>
      <sourceline>1105</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_TxConfirmation() is called using an invalid BufIdx, the
    confirmation will be ignored.
  
Test Object: None.
Test Precondition: 
    EthIf initialized.
    A controller is in state ACTIVE.
  
Test Execution: 
    01: Call EthIf_Transmit().
    02: Call EthIf_TxConfirmation() using an invalid BufIdx.
    03: VP: Verify that the confirmation will be ignored.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.EthIf_TxConfirmation.InvBufIdx</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>194</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1907</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest02024_RxIndication_VLAN_InvVID</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Include/EthIf_Incl07_ConTest02_Common/source/application/EthIf_ConTest02_FunctionCheck.c</sourcefile>
      <sourceline>1173</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_RxIndication() is called with a frame which contains
    a VLAN tag which is not configured for the called EthCtrlIdx, the frame will be discarded
    without taking any action.
  
Test Object: 
    EthIf_RxIndication().
  
Test Precondition: 
    EthIf initialized.
    VID used is not present in config for all EthIf controller with linkage to EthCtrlIdx.
  
Test Execution: 
    01: Call EthIf_RxIndication() with invalid VLAN ID.
    02: VP(): Verify that the frame was discarded without calling anything.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.RxIndication.VLAN.InvVID</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>154</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1908</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest02026_MainFunction_GetTransceiverMode_NotActive</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Include/EthIf_Incl07_ConTest02_Common/source/application/EthIf_ConTest02_FunctionCheck.c</sourcefile>
      <sourceline>1231</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies for a call of EthIf_MainFunctionRx() and EthIf_MainFunctionTx() that if
    Eth_GetTransceiverMode() returns TrcvMode not equal to ETHTRCV_MODE_ACTIVE, the transceiver
    shall not be processed until next main function cycle.
  
Test Object: 
    - EthIf_MainFunctionRx()
    - EthIf_MainFunctionTx()
  
Test Precondition: 
    - EthIf initialized.
    - Controller and transceiver under test initialized.
    - Controller and transceiver is set to active.
  
Test Execution: 
    01: Set mode of Eth_GetTransceiverMode() stub to ETH_MODE_DOWN.
    02: Call EthIf_MainFunctionRx().
    03: VP(EthIf.EB.MainFunctionRx.GetTransceiverMode_NotActive): Verify that after call of
        Eth_GetTransceiverMode(), no other EthTrcv API is called.
    04: Call EthIf_MainFunctionTx().
    05: VP(EthIf.EB.MainFunctionTx.GetTransceiverMode_NotActive): Verify that after call of
        Eth_GetTransceiverMode(), no other EthTrcv API is called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MainFunctionRx.GetTransceiverMode_NotActive</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>179</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.MainFunctionTx.GetTransceiverMode_NotActive</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>180</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1909</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest02027_MainFunction_GetTransceiverMode_NotOk</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Include/EthIf_Incl07_ConTest02_Common/source/application/EthIf_ConTest02_FunctionCheck.c</sourcefile>
      <sourceline>1317</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies for a call of EthIf_MainFunctionRx() and EthIf_MainFunctionTx() that if
    Eth_GetTransceiverMode() returns not E_OK, the transceiver
    shall not be processed until next main function cycle.
  
Test Object: 
    - EthIf_MainFunctionRx()
    - EthIf_MainFunctionTx()
  
Test Precondition: 
    - EthIf initialized.
    - Controller and transceiver under test initialized.
    - Controller and transceiver is set to active.
  
Test Execution: 
    01: Set return value of Eth_GetTransceiverMode() stub to E_NOT_OK.
    02: Call EthIf_MainFunctionRx().
    03: VP(EthIf.EB.MainFunctionRx.GetTransceiverMode_NotActive): Verify that after call of
        Eth_GetTransceiverMode(), no other EthTrcv API is called.
    04: Call EthIf_MainFunctionTx().
    05: VP(EthIf.EB.MainFunctionTx.GetTransceiverMode_NotActive): Verify that after call of
        Eth_GetTransceiverMode(), no other EthTrcv API is called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.MainFunctionRx.GetTransceiverMode_NotOk</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>177</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.MainFunctionTx.GetTransceiverMode_NotOk</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>178</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1910</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest02030_RxIndication_VLAN_InvFrameType</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Include/EthIf_Incl07_ConTest02_Common/source/application/EthIf_ConTest02_FunctionCheck.c</sourcefile>
      <sourceline>1403</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_RxIndication() is called for a VLAN frame and the encapsulated
    frame type is not configured for the called EthCtrlIdx, then the received frame is discarded
    silently without taking any action.
  
Test Object: 
    EthIf_RxIndication().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_RxIndication() to receive a VLAN tagged frame with not configured frame type.
    02: VP(): Verify that the frame was discarded.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.RxIndication.VLAN.InvFrameType</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1911</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest02031_RxIndication_InvFrameType</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Include/EthIf_Incl07_ConTest02_Common/source/application/EthIf_ConTest02_FunctionCheck.c</sourcefile>
      <sourceline>1466</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_RxIndication() is called for a frame without VLAN tag and the
    frame type is not configured for the called EthCtrlIdx, then the received frame is discarded
    silently without taking any action.
  
Test Object: 
    EthIf_RxIndication().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_RxIndication() to receive a frame with not configured frame type.
    02: VP(): Verify that the frame was discarded.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.RxIndication.InvFrameType</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>156</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1912</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest02032_RxIndication_VLAN_InvLenByte</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Include/EthIf_Incl07_ConTest02_Common/source/application/EthIf_ConTest02_FunctionCheck.c</sourcefile>
      <sourceline>1528</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_RxIndication() is called for a VLAN frame and the parameter
    LenByte is smaller as the header of a VLAN frame, then the received frame is discarded
    silently without taking any action.
  
Test Object: 
    EthIf_RxIndication().
  
Test Precondition: 
    EthIf initialized.
  
Test Execution: 
    01: Call EthIf_RxIndication() to receive a VLAN tagged frame with not configured frame type.
    02: VP(): Verify that the frame was discarded.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.RxIndication.VLAN.InvLenByte</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1913</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest02033_RxIndication_VLANOnly_InvFrame</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Include/EthIf_Incl07_ConTest02_Common/source/application/EthIf_ConTest02_FunctionCheck.c</sourcefile>
      <sourceline>1593</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that if EthIf_RxIndication() is called for a frame without VLAN tag and all
    configured EthIf controller for the called EthCtrlIdx have VID enabled, then the received frame
    is discarded silently without taking any action.
  
Test Object: 
    EthIf_RxIndication().
  
Test Precondition: 
    - EthIf initialized.
    - Only EthIf controller with VID enabled are linked to the used EthCtrlIdx.
  
Test Execution: 
    01: Call EthIf_RxIndication() to receive a frame without VLAN tag.
    02: VP(): Verify that the frame was discarded.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.RxIndication.VLANOnly.InvFrame</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>157</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1914</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest02034_CtrlModeIndication</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Include/EthIf_Incl07_ConTest02_Common/source/application/EthIf_ConTest02_FunctionCheck.c</sourcefile>
      <sourceline>1658</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that in the context of EthIf_CtrlModeIndication() the function
    EthTrcv_SetTransceiverMode() is called if the EthIfController has a reference to a
    EthIfTransceiver. Also it verifies that EthIf_CtrlModeIndication() calls
    EthSM_CtrlModeIndication().
  
Test Object: 
    EthIf_CtrlModeIndication().
  
Test Precondition: 
    - EthIf initialized.
  
Test Execution: 
    01: Call EthIf_SetControllerMode() to set Ethernet interface controller mode to ACTIVE.
    02: VP(SWS_EthIf_00252): Verify that EthSM_CtrlModeIndication() is called for the respective
        EthIfCtrl, with a mode set to ETH_MODE_ACTIVE.
    03: VP(SWS_EthIf_00266): Verify that EthTrcv_SetTransceiverMode() is called for the respective
        transceiver, with a mode set to ETHTRCV_MODE_ACTIVE.
    04: Call EthIf_SetControllerMode() to set Ethernet interface controller mode to DOWN.
    05: VP(SWS_EthIf_00252): Verify that EthSM_CtrlModeIndication() is called for the respective
        EthIfCtrl, with a mode set to ETH_MODE_DOWN.
    06: VP(SWS_EthIf_00266): Verify that EthTrcv_SetTransceiverMode() is called for the respective
        transceiver, with a mode set to ETHTRCV_MODE_DOWN.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00266</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>619</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00252</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>575</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1915</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest02035_SetModeTimeout_GetLinkStateDown</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Include/EthIf_Incl07_ConTest02_Common/source/application/EthIf_ConTest02_FunctionCheck.c</sourcefile>
      <sourceline>1756</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that when Ethernet controller and transceiver are both ACTIVE and
    transceiver link state remains DOWN for ETHIF_SET_MODE_TIMEOUT cycles, the module shall
    repeat the call of EthTrcv_SetTransceiverMode(ETHTRCV_MODE_ACTIVE).
  
Test Object: 
    EthIfSetModeTimeout
  
Test Precondition: 
    - EthIf initialized.
  
Test Execution: 
    01: Call EthIf_SetControllerMode() to set Ethernet interface controller mode to ACTIVE.
    02: Call EthIf_MainFunctionRx() - It will call EthTrcv_GetTransceiverMode(), and since it's
        stub is configured to return ACTIVE it will put transceiver into ACTIVE mode.
    03: Call EthIf_MainFunctionRx() ETHIF_SET_MODE_TIMEOUT - 1 number of times.
    04: Call EthIf_MainFunctionRx() one more time to reach timeout threshold.
    05: VP(): Verify that EthTrcv_SetTransceiverMode() is called again after exactly
        ETHIF_SET_MODE_TIMEOUT cycles transceiver link state is DOWN.
    06: Set EthTrcv_GetLinkState_Stub() to return ACTIVE state upon next call.
    07: Call EthIf_MainFunctionRx().
    08: Call EthIf_MainFunctionRx() 2 * ETHIF_SET_MODE_TIMEOUT times.
    09: VP(): Verify that EthTrcv_SetTransceiverMode() is not called, i.e. timer is disabled since
        transceiver link state was set to ACTIVE.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SetModeTimeout.RepeatRequest.GetLinkStateDown</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>258</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1916</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest02036_SetModeTimeout_ReadFail</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Include/EthIf_Incl07_ConTest02_Common/source/application/EthIf_ConTest02_FunctionCheck.c</sourcefile>
      <sourceline>1898</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that when EthTrcv_SetTransceiverMode() is called and consecutive calls in
    EthIf_MainFunction() to EthTrcv_GetTransceiverMode() do not read the expected value for
    ETHIF_SET_MODE_TIMEOUT cycles, the module shall repeat the call of
    EthTrcv_SetTransceiverMode().
  
Test Object: 
    EthIfSetModeTimeout
  
Test Precondition: 
    - EthIf initialized.
    - EthTrcv_GetTransceiverMode_Stub is configured to return ETHTRCV_MODE_DOWN.
  
Test Execution: 
    01: Call EthIf_SetControllerMode() to set Ethernet interface controller mode to ACTIVE.
    02: Call EthIf_MainFunctionRx() ETHIF_SET_MODE_TIMEOUT - 1 number of times.
    03: Call EthIf_MainFunctionRx() one more time to reach timeout threshold.
    04: VP(): Verify that EthTrcv_SetTransceiverMode() is called again after exactly
        ETHIF_SET_MODE_TIMEOUT cycles because transceiver state is DOWN.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.SetModeTimeout.RepeatRequest.ReadFail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>260</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1917</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest02037_InitControllersTransceivers</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Include/EthIf_Incl07_ConTest02_Common/source/application/EthIf_ConTest02_FunctionCheck.c</sourcefile>
      <sourceline>1991</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies that when configuration parameter EthIfInitControllersTransceivers is set to
    true, EthIf will initialize configured transceivers and controllers by calling
    Eth_ControllerInit() and EthTrcv_TransceiverInit(). In case EthIfInitControllersTransceivers is
    not set no call to drivers will be made.
  
Test Object: 
    Configuration paramter: EthIfInitControllersTransceivers.
  
Test Precondition: 
  
Test Execution: 
    01: Call EthIf_Init()
    02: VP(): Verify that if config parameter EthIfInitControllersTransceiversall is set to true
              then all configured physical controllers and transceivers are initialized with
              a call to Eth_ControllerInit() and EthTrcv_TransceiverInit().
              In case EthIfInitControllersTransceiversall is set to false -&gt; no call to drivers
              will be made
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.InitControllersTransceivers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>270</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1918</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest02038_GetTrcvSignalQuality</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Include/EthIf_Incl07_ConTest02_Common/source/application/EthIf_ConTest02_FunctionCheck.c</sourcefile>
      <sourceline>2056</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the functionality of EthIf_GetTrcvSignalQuality and
    EthIf_ClearTrcvSignalQuality functions.
  
Test Object: 
    EthIf_GetTrcvSignalQuality()
    EthIf_ClearTrcvSignalQuality().
  
Test Precondition: 
    - EthIf initialized.
  
Test Execution: 
    01: Call EthIf_SetControllerMode() to set Ethernet interface controller mode to ACTIVE.
        The controller references an Ethernet switch.
    02: Call EthIf_MainFunctionRx().
    03: Call EthIf_GetTrcvSignalQuality().
    04: VP(SWS_EthIf_91056, SWS_EthIf_00391): Verify that EthTrcv_GetPhySignalQuality() is
        called with configured signal quality parameter.
    05: Call EthIf_ClearTrcvSignalQuality().
    06: VP(SWS_EthIf_91059, SWS_EthIf_00400): Verify that E_OK is returned.
    07: Set EthTrcv SignalQualityPtr_Out to a different value and call EthIf_MainFunctionRx().
    08: Call EthIf_GetTrcvSignalQuality().
    09: VP(SWS_EthIf_91056): Verify that EthTrcv_GetPhySignalQuality() is
        called with configured signal quality parameter and that ActualSignalQuality,
        LowestSignalQuality and HighestSignalQuality have the same signal quality value due to the
        previous call of EthIf_ClearTrcvSignalQuality.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91056</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>775</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91059</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>778</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00391</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>755</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00400</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>763</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1919</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest02039_GetTrcvSignalQuality_InvPort</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Include/EthIf_Incl07_ConTest02_Common/source/application/EthIf_ConTest02_FunctionCheck.c</sourcefile>
      <sourceline>2187</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the functionality of EthIf_GetTrcvSignalQuality and
    EthIf_ClearSwitchPortSignalQuality functions in case when invalid switch port index is used.
  
Test Object: 
    EthIf_GetTrcvSignalQuality()
    EthIf_ClearTrcvSignalQuality().
  
Test Precondition: 
    - EthIf initialized.
  
Test Execution: 
    01: Call EthIf_SetControllerMode() to set Ethernet interface controller mode to ACTIVE.
    02: Call EthIf_MainFunctionRx().
    03: Call EthIf_GetTrcvSignalQuality().
    04: Call EthIf_ClearSwitchPortSignalQuality() with invalid SwitchPortIdx.
    05: VP(EthIf.ASR431.SWS_EthIf_00402): Verify that E_NOT_OK is returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00402</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>765</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1920</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest02040_GetTrcvSignalQuality_NOK</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Include/EthIf_Incl07_ConTest02_Common/source/application/EthIf_ConTest02_FunctionCheck.c</sourcefile>
      <sourceline>2264</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the functionality of EthIf_GetTrcvSignalQuality in case when called function
    EthTrcv_GetPhySignalQuality() returns E_NOT_OK.
  
Test Object: 
    EthIf_GetTrcvSignalQuality()
  
Test Precondition: 
    - EthIf initialized.
  
Test Execution: 
    01: Call EthIf_SetControllerMode() to set Ethernet interface controller mode to ACTIVE.
    02: Set EthTrcv_GetPhySignalQuality_Stub to return E_NOT_OK.
    03: Call EthIf_MainFunctionRx().
    04: Call EthIf_GetTrcvSignalQuality().
    05: VP(EthIf.ASR431.SWS_EthIf_91056): Verify that E_NOT_OK is returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_91056</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>775</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1921</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest02041_DisableRelatedEthIfCtrls</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Include/EthIf_Incl07_ConTest02_Common/source/application/EthIf_ConTest02_FunctionCheck.c</sourcefile>
      <sourceline>2344</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the functionality of EthIf_DisableRelatedEthIfCtrls function.
  
Test Object: 
    EthIf_DisableRelatedEthIfCtrls().
  
Test Precondition: 
    - EthIf initialized.
  
Test Execution: 
    01: Call EthIf_DisableRelatedEthIfCtrls().
    02: VP(EthIf.EB.DevAuthExtension.DisableRelatedEthIfCtrls.ApiSignature,
           EthIf.EB.DevAuthExtension.DisableRelatedEthIfCtrls.Behaviour): 
           Verify that E_OK is returned.
    03: Call EthIf_MainFunctionRx().
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.DevAuthExtension.DisableRelatedEthIfCtrls.ApiSignature</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>287</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.DevAuthExtension.DisableRelatedEthIfCtrls.Behaviour</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>290</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1922</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest02042_EnableRelatedEthIfCtrls</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Include/EthIf_Incl07_ConTest02_Common/source/application/EthIf_ConTest02_FunctionCheck.c</sourcefile>
      <sourceline>2401</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Testing the functionality of EthIf_EnableRelatedEthIfCtrls function.
  
Test Object: 
    EthIf_EnableRelatedEthIfCtrls().
  
Test Precondition: 
    - EthIf initialized.
  
Test Execution: 
    01: Call EthIf_EnableRelatedEthIfCtrls().
    02: VP(EthIf.EB.DevAuthExtension.EnableRelatedEthIfCtrls.ApiSignature,
           EthIf.EB.DevAuthExtension.EnableRelatedEthIfCtrls.Behaviour): 
           Verify that E_OK is returned.
    03: Call EthIf_MainFunctionRx().
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.EB.DevAuthExtension.EnableRelatedEthIfCtrls.ApiSignature</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>285</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.DevAuthExtension.EnableRelatedEthIfCtrls.Behaviour</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>289</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1923</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest02043_GetAndResetMeasurementData_NoVLANtagFrame</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Include/EthIf_Incl07_ConTest02_Common/source/application/EthIf_ConTest02_FunctionCheck.c</sourcefile>
      <sourceline>2457</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies functionality of EthIf_GetAndResetMeasurementData() when an untagged frame 
    (without VLAN tag) is received and no configured EthIfCtrl with disabled VLAN id exists.
  
Test Object: 
    EthIf_GetAndResetMeasurementData().
  
Test Precondition: 
    - EthIf initialized.
    - only EthIfCtrl exists with EthIfVlanID enabled
  
Test Execution: 
    01: Call EthIf_GetAndResetMeasurementData() with measurement index ETHIF_MEAS_ALL and reset flag
        set to TRUE to reset all measurement data.
    02: Call EthIf_GetAndResetMeasurementData() with measurement index ETHIF_MEAS_DROP_CRTLIDX.
    03: VP(SWS_EthIf_00312): Verify that measurement data is set to 0.
    04: Call EthIf_RxIndication() with Vlan CtrlIdx and frame type other then 0x8100 seven times.
    05: Call EthIf_GetAndResetMeasurementData() with measurement index ETHIF_MEAS_DROP_CRTLIDX and
        valid MeasurementDataPtr.
    06: VP(SWS_EthIf_00308, SWS_EthIf_00309): Verify that measurement data equals the number of
        dropped datagrams.
    07: Set EthIf_MeasurementData_InvCtrlVLAN counter to maximal value.
    08: Call EthIf_RxIndication() with Vlan CtrlIdx and and frame type other then 0x8100 several
        times.
    09: Call EthIf_GetAndResetMeasurementData() with measurement index ETHIF_MEAS_DROP_CRTLIDX.
    10: VP(SWS_EthIf_00313): Verify that Measurement counter did not overrun.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00308</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>652</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00309</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>653</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00312</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>655</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00313</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>656</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1924</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest02044_GetAndResetMeasurementData_VlanNoMatch</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Include/EthIf_Incl07_ConTest02_Common/source/application/EthIf_ConTest02_FunctionCheck.c</sourcefile>
      <sourceline>2590</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies functionality of EthIf_GetAndResetMeasurementData() when VLAN Id from the 
    received frame does not match the VLAN Id configured for this EthIfCtrl.
  
Test Object: 
    EthIf_GetAndResetMeasurementData().
  
Test Precondition: 
    - EthIf initialized.
  
Test Execution: 
    01: Call EthIf_GetAndResetMeasurementData() with measurement index ETHIF_MEAS_ALL and reset flag
        set to TRUE to reset all measurement data.
    02: Call EthIf_RxIndication() with VlanId in the frame, that does not match any of the 
        configured ones, 4 times.
    03: Call EthIf_GetAndResetMeasurementData() with measurement index ETHIF_MEAS_DROP_CRTLIDX and
        valid MeasurementDataPtr.
    04: VP(SWS_EthIf_00308, SWS_EthIf_00309): Verify that measurement data equals the number of
        dropped datagrams.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00308</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>652</internalId></provcov>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00309</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>653</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1925</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest02045_GetAndResetMeasurementData_EthertypeNoMatch</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Include/EthIf_Incl07_ConTest02_Common/source/application/EthIf_ConTest02_FunctionCheck.c</sourcefile>
      <sourceline>2682</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies functionality of EthIf_GetAndResetMeasurementData() when received FrameType
    does not match any EthIfFrameType from the configuration.
  
Test Object: 
    EthIf_GetAndResetMeasurementData().
  
Test Precondition: 
    - EthIf initialized.
  
Test Execution: 
    01: Call EthIf_GetAndResetMeasurementData() with measurement index
        ETHIF_MEAS_DROP_UNKNOWN_ETHERTYPE and reset flag set to TRUE to reset measurement data.
    02: Call EthIf_RxIndication() with VlanId in the frame that does not match any of the configured
        ones 5 times.
    03: Call EthIf_GetAndResetMeasurementData() with measurement index
        ETHIF_MEAS_DROP_UNKNOWN_ETHERTYPE and valid MeasurementDataPtr.
    04: VP(EthIf.EB.EthIf_GetAndResetMeasurementData.Unknown_EtherType): Verify that measurement
        data equals the number of dropped datagrams.
    05: Set EthIf_MeasurementData_InvEtherType counter to maximal value.
    06: Call EthIf_RxIndication() with VlanId in the frame that does not match any of the configured
        ones several times.
    07: Call EthIf_GetAndResetMeasurementData() with measurement index
        ETHIF_MEAS_DROP_UNKNOWN_ETHERTYPE.
    08: VP(SWS_EthIf_00313): Verify that Measurement counter EthIf_MeasurementData_InvEtherType did
        not overrun.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00313</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>656</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.EthIf_GetAndResetMeasurementData.Unknown_EtherType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1154</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1926</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest02046_GetAndResetMeasurementData_DoubleVLANTag</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Include/EthIf_Incl07_ConTest02_Common/source/application/EthIf_ConTest02_FunctionCheck.c</sourcefile>
      <sourceline>2812</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test case verifies functionality of EthIf_GetAndResetMeasurementData() when received FrameType
    is VLAN, but two 802.1Q headers with TPID = 0x8001 are received.
  
Test Object: 
    EthIf_GetAndResetMeasurementData().
  
Test Precondition: 
    - EthIf initialized.
  
Test Execution: 
    01: Call EthIf_GetAndResetMeasurementData() with measurement index
        ETHIF_MEAS_DROP_DOUBLE_VLANTAG and reset flag set to TRUE to reset measurement data.
    02: Call EthIf_RxIndication() with double VLAN tag in the frame, while received frame type is
        for single VLAN-tagged frame, four times.
    03: Call EthIf_GetAndResetMeasurementData() with measurement index
        ETHIF_MEAS_DROP_DOUBLE_VLANTAG and valid MeasurementDataPtr.
    04: VP(EthIf.EB.EthIf_GetAndResetMeasurementData.Double_VLANTag): Verify that measurement
        data equals the number of dropped datagrams.
    05: Set EthIf_MeasurementData_DuplVLANTag counter to maximal value.
    06: Call EthIf_RxIndication() with double VLAN tag in the frame, while received frame type is
        for single VLAN-tagged frame, several times.
    07: Call EthIf_GetAndResetMeasurementData() with measurement index
        ETHIF_MEAS_DROP_DOUBLE_VLANTAG.
    08: VP(SWS_EthIf_00313): Verify that Measurement counter EthIf_MeasurementData_DuplVLANTag did
        not overrun.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00313</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>656</internalId></provcov>
        <provcov>
          <linksto>EthIf.EB.EthIf_GetAndResetMeasurementData.Double_VLANTag</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1155</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1927</internalId></specobject>
    <specobject>
      <id>EthIf_ConTest02047_ProvideTxBuffer_Disabled_VlanId</id>
      <status>approved</status>
      <source>EB test case specification (asc_EthIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_EthIf/test/ts5/Include/EthIf_Incl07_ConTest02_Common/source/application/EthIf_ConTest02_FunctionCheck.c</sourcefile>
      <sourceline>2943</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Call EthIf_ProvideTxBuffer() using a CtrlIdx that has EthIfVlanId disabled.
  
Test Object: None.
Test Precondition: 
    EthIfVlanId is false.
    A controller is in state ACTIVE_WITH_WAKEUP_REQUEST.
  
Test Execution: 
    01: Call EthIf_ProvideTxBuffer() using a CtrlIdx that has EthIfVlanId disabled.
    02: EthIf_ProvideTxBuffer() shall return BUFREQ_E_OK.
    03: VP: Eth_ProvideTxBuffer() shall be called with the expected parameter(s).
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EthIf.SWS_EthIf_00068.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>941</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1928</internalId></specobject>
  </specobjects>
  </specdocument>
  <violations/>
  <oreqmViolations/>
</tracingresults>
