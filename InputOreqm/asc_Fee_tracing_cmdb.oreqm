<?xml version="1.0" encoding="UTF-8"?>
<tracingresults>
  <environment>
    <toolname>ReqM2</toolname>
    <toolversion>1.30.0 (stable)</toolversion>
    <toolcopyright>Copyright 2010 - 2018 Elektrobit Automotive GmbH</toolcopyright>
    <libxmlversion>2.0207</libxmlversion>
    <libxml2compileversion>2.9.10</libxml2compileversion>
    <libxml2runtimeversion>20912</libxml2runtimeversion>
    <perlversion>v5.32.1</perlversion>
    <perlptrsize>64</perlptrsize>
    <commandline>-t -q -o asc_Fee_tracing_cmdb.oreqm -O /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/TestProtocols/LogBase/requirements -c /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_PluginBuildEnv/common/config/AutoCoreReqM2Rules_RMP4_0.xml -s approved,rejected --wfatal WDUPLICATEID,WDUPLICATEIDANDVER /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/build/reqm/ReqM2_Native/asc_Fee_public_modulereference_integration_req.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/build/reqm/ReqM2_Native/asc_Fee_requirements_AUTOSAR_SWS_FlashEEPROMEmulation_4_0_3.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/build/reqm/ReqM2_Native/asc_Fee_requirements_AUTOSAR_SWS_FlashEEPROMEmulation_R21-11.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/build/reqm/ReqM2_Native/asc_Fee_requirements_EB_Limitations.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/build/reqm/ReqM2_Native/asc_Fee_requirements_EB_Refinements.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/build/reqm/ReqM2_Native/asc_Fee_requirements_EB_Requirements.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/build/reqm/ReqM2_Native/asc_Fee_test_manTest_ResourceConsumption.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/build/reqm/common_req/Fee_DbgInst_EB_Extension.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/build/reqm/common_req/Fee_VerifyStub_EB_Extension.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/build/reqm/ReqM2_GenericImporter/reqm_DEV.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/build/reqm/ReqM2_GenericImporter/reqm_IMPL.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/build/reqm/ReqM2_GenericImporter/reqm_IMPLXML.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/build/reqm/ReqM2_DocBookImporter/reqm_SWDD.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/build/reqm/ReqM2_OldCImporter/reqm_SWUTS_LEGACY.reqm</commandline>
    <timestamp>Mon Jun 17 22:03:25 2024</timestamp>
  </environment>
  <cmdline>
    <cmdparam>
      <name>I</name>
      <values>
        <value>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/TestProtocols/LogBase/requirements</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>O</name>
      <values>
        <value>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/TestProtocols/LogBase/requirements</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>c</name>
      <values>
        <value>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_PluginBuildEnv/common/config/AutoCoreReqM2Rules_RMP4_0.xml</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>o</name>
      <values>
        <value>asc_Fee_tracing_cmdb.oreqm</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>q</name>
    </cmdparam>
    <cmdparam>
      <name>s</name>
      <values>
        <value>approved</value>
        <value>rejected</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>t</name>
    </cmdparam>
    <cmdparam>
      <name>wfatal</name>
      <values>
        <value>WDUPLICATEID</value>
        <value>WDUPLICATEIDANDVER</value>
      </values>
    </cmdparam>
  </cmdline>
  <inputfiles>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/build/reqm/ReqM2_Native/asc_Fee_public_modulereference_integration_req.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/build/reqm/ReqM2_Native/asc_Fee_requirements_AUTOSAR_SWS_FlashEEPROMEmulation_4_0_3.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/build/reqm/ReqM2_Native/asc_Fee_requirements_AUTOSAR_SWS_FlashEEPROMEmulation_R21-11.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/build/reqm/ReqM2_Native/asc_Fee_requirements_EB_Limitations.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/build/reqm/ReqM2_Native/asc_Fee_requirements_EB_Refinements.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/build/reqm/ReqM2_Native/asc_Fee_requirements_EB_Requirements.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/build/reqm/ReqM2_Native/asc_Fee_test_manTest_ResourceConsumption.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/build/reqm/common_req/Fee_DbgInst_EB_Extension.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/build/reqm/common_req/Fee_VerifyStub_EB_Extension.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/build/reqm/ReqM2_GenericImporter/reqm_DEV.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/build/reqm/ReqM2_GenericImporter/reqm_IMPL.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/build/reqm/ReqM2_GenericImporter/reqm_IMPLXML.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/build/reqm/ReqM2_DocBookImporter/reqm_SWDD.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/build/reqm/ReqM2_OldCImporter/reqm_SWUTS_LEGACY.reqm</inputfile>
  </inputfiles>
  <configuration>
    <doctypes>
    <regexs>
      <!-- external level -->
      <regex>creq</regex>       <!-- since 10/1018: introduced for updated tracing model-->

      <!-- product line level -->
      <regex>fea</regex>
      <regex>swpad</regex>      <!-- since 10/1018: introduced for updated tracing model-->
      <regex>swts</regex>

      <!-- bundle level -->
      <regex>swrs</regex>
      <regex>swad</regex>
      <regex>swintts</regex>

      <!-- module level -->
      <regex>swdd</regex>
      <regex>swurs</regex>      <!-- since 10/1018: introduced for updated tracing model-->
      <regex>swmts</regex>      <!-- since 01/1010: introduced for updated tracing model RMP4.0-->
      <regex>swuts</regex>
      <regex>impl</regex>

      <!-- legacy items -->
      <regex>dev</regex>
      <regex>man</regex>
      <regex>lim</regex>
    </regexs>
  </doctypes>
    <rules>
    <!-- The Ruleset for RMP4.0 is currently identical to the previous rule set. This rule is
        intoduce to show that the right file is uses. It will be removed when the RMP4.0 rule set is
    reworked -->
    <rule>
      <name>INFO.Rule set RMP4.0</name>
      <description>This rules indicates that RMP4.0 rule set is used.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status!='approved') and (./status!='rejected')]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>WRN.general.doctypes</name>
      <description>The used doctype is not part of the tracing model</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobjects/@doctype</applyto>
          <condition>((. != 'creq') or (. != 'fea') or (. != 'swpad') or (. != 'swts') or (. != 'swrs') or (. !='swad') or (. != 'swintts') or (.!= 'swdd') or (. != 'swurs') or (. != 'swmts') or (. != 'swuts') or (. != 'impl') or (. != 'dev') or (. != 'man') or (. != 'lim'))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.status</name>
      <description>All specification objects must be either in status=approved or in status=rejected. Other
        statuses are not allowed. How to fix: Set status to rejected or approved.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status!='approved') and (./status!='rejected')]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.rejected</name>
      <description>Status status=rejected is only allowed for requirements. How to fix: set to approved for specification object that are not requirements.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype!='swrs')  and (../@doctype!='swmrs') and (../@doctype!='swurs') and (./status='rejected')]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.comment</name>
      <description>Specification objects with status=rejected shall have a comment or rationale that
        starts with on of the following texts: "This requirement is informational only", "This requirement is not applicable".
        How to fix: Add some text starting with "This requirement is informational only"
        or "This requirement is not applicable" to either the comment or to the rationale.
        Comment: Implementation of check checks for contains instead of starts-with since there is
        no trim function in the used XPATH engine.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status='rejected')]</applyto>
          <condition>contains(./comment,"This requirement is informational only") or contains(./rationale,"This requirement is informational only") or contains(./comment,"This requirement is not applicable") or contains(./rationale,"This requirement is not applicable")</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.rejected.coverage</name>
      <description>Specification objects with status=rejected shall not need coverage. How to fix: remove need for coverage.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status='rejected')]</applyto>
          <condition>count(./needscoverage)=0</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swurs.needscoverage.count</name>
      <description>Unit requirements with status=approved need to be covered, exceptions from
      this rule: configuration requirements (postfix "_CONF" or "_Conf" or prefix "ECUC_") and requirements with
      a comment starting with "The adherence to this requirement is ensured by the following
      release check (URL to the checklist template plus ID of the check):".
      How to fix: Provide a needsobj element for those specobjects or comment according to the rule.
      </description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swurs') and (./status='approved') and count(./needscoverage/needsobj)=0 and count(./fulfilledby/ffbObj)=0]</applyto>
          <!--This condition is false if the id of a specification object does not end with '_Conf' or '_CONF' or does not start with ECUC_ -->
          <condition>substring-after(./id,"ECUC_")!="" or substring-before(./id,"_Conf")!="" or substring-before(./id,"_CONF")!="" or contains(./comment,"The adherence to this requirement is ensured by the following release check (URL to the checklist template plus ID of the check):")</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swurs.needscoverage.rationale</name>
      <description>Requirements with status=approved and without coverage needs that are
        configuration requirements (postfix "_CONF" or "_Conf" or prefix "ECUC_") shall have a comment or rationale
        with the following text: "This is a configuration parameter requirement without functional
        specification.". How to fix: Add some text starting with "This is a configuration parameter
        requirements without functional specification" to either the comment or to the rationale.</description>
      <regexchecks>
        <regexcheck>
          <applyto>//specobject[(../@doctype='swurs') and (./status='approved') and count(./needscoverage/needsobj)=0 and (substring-after(./id,"ECUC_")!="" or substring-before(./id,"_CONF")!="" or substring-before(./id,"_Conf")!="")]</applyto>
          <regex>This is a configuration parameter requirement without functional specification.</regex>
        </regexcheck>
      </regexchecks>
    </rule>

    <rule>
      <name>ERR.swrs.needscoverage.rationale</name>
      <description>Requirements with status=approved and without coverage needs that are
        configuration requirements (postfix "_CONF" or "_Conf" or prefix "ECUC_") shall have a comment or rationale
        with the following text: "This is a configuration parameter requirement without functional
        specification.". How to fix: Add some text starting with "This is a configuration parameter
        requirements without functional specification" to either the comment or to the rationale.</description>
      <regexchecks>
        <regexcheck>
          <applyto>//specobject[(../@doctype='swrs') and (./status='approved') and count(./needscoverage/needsobj)=0 and (substring-after(./id,"ECUC_")!="" or substring-before(./id,"_CONF")!="" or substring-before(./id,"_Conf")!="")]</applyto>
          <regex>This is a configuration parameter requirement without functional specification.</regex>
        </regexcheck>
      </regexchecks>
    </rule>

    <rule>
      <name>ERR.swurs.releases</name>
      <description>Requirements which originates from AUTOSAR (source tag contains term 'AUTOSAR_SWS', 'AUTOSAR_TPS',
        'AUTOSAR_ASWS' or 'AUTOSAR_TR') shall have their release tag set to 'AUTOSAR {major}.{minor}.{patch}' (e.g. 'AUTOSAR 4.3.0').
        Other requirements (including refinements of AUTOSAR requirements) must not contain any of the listed prefixes as
        part of the source tag.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swurs') and (contains(./source,'AUTOSAR_SWS') or contains(./source,'AUTOSAR_TPS') or contains(./source,'AUTOSAR_ASWS') or contains(./source,'AUTOSAR_TR'))]</applyto>
          <condition>contains(./releases/release,'AUTOSAR')</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swrs.releases</name>
      <description>Requirements which originates from AUTOSAR (source tag contains term 'AUTOSAR_SWS', 'AUTOSAR_TPS',
        'AUTOSAR_ASWS' or 'AUTOSAR_TR') shall have their release tag set to 'AUTOSAR {major}.{minor}.{patch}' (e.g. 'AUTOSAR 4.3.0').
        Other requirements (including refinements of AUTOSAR requirements) must not contain any of the listed prefixes as
        part of the source tag.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swrs') and (contains(./source,'AUTOSAR_SWS') or contains(./source,'AUTOSAR_TPS') or contains(./source,'AUTOSAR_ASWS') or contains(./source,'AUTOSAR_TR'))]</applyto>
          <condition>contains(./releases/release,'AUTOSAR')</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swdd.needscoverage.count</name>
      <description>Design elements with status=approved need to be covered.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swdd') and (./status='approved') and count(./needscoverage/needsobj)=0]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swurs.needscoverage.doctypes</name>
      <description>Requirements can be covered only by swurs, swad, dev, lim, swdd, impl, swuts, swmts, or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swurs')]</applyto>
          <condition>(./needscoverage/needsobj="swurs" or ./needscoverage/needsobj="swad" or ./needscoverage/needsobj="dev" or ./needscoverage/needsobj="lim" or ./needscoverage/needsobj="swdd" or ./needscoverage/needsobj="impl" or ./needscoverage/needsobj="swuts" or ./needscoverage/needsobj="swmts" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swrs.needscoverage.doctypes</name>
      <description>Requirements of type swrs can be covered only by swrs, swurs, swad, swintts or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swrs')]</applyto>
          <condition>(./needscoverage/needsobj="swrs" or ./needscoverage/needsobj="swurs" or ./needscoverage/needsobj="swad" or ./needscoverage/needsobj="swuts" or ./needscoverage/needsobj="swintts" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swdd.needscoverage.doctypes</name>
      <description>Design elements of type swdd can only be covered by swdd, swurs, impl, swuts, lim or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swdd')]</applyto>
          <condition>(./needscoverage/needsobj="swdd" or ./needscoverage/needsobj="swurs" or ./needscoverage/needsobj="impl" or ./needscoverage/needsobj="swuts" or ./needscoverage/needsobj="swmts" or ./needscoverage/needsobj="lim" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.dev.needscoverage.count</name>
      <description>Deviations shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='dev')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swuts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swuts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swmts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swmts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swintts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swintts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.man.needscoverage.count</name>
      <description>Manual test cases shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='man')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.impl.needscoverage.count</name>
      <description>Source code shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='impl')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.lim.needscoverage.count</name>
      <description>Limitations shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='lim')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.fea.needscoverage.test</name>
      <description>Features shall be tested by software test ('swts') or manuel test ('man'). If no test is planned a justification shall be given.
                   A justification can be given in the futherinfo tag. The justification shall start with this rule name.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='fea')]</applyto>
          <condition>(
               ./needscoverage/needsobj="swts" or ./needscoverage/needsobj="man" or ./fulfilledby/ffbObj/ffbType="swts" or ./fulfilledby/ffbObj/ffbType="man" or contains(./furtherinfo,"fea.needscoverage.test") or contains(./furtherinfo,"fea.needscoverage.doctypes"))</condition>
        </conditioncheck>
      </conditionchecks>
          </rule>

    <rule>
      <name>WRN.fea.needscoverage.impl</name>
      <description>Features shall be covered by implementation fea, swrs, swad, swpad, swurs, man and swts. For lagacy features a justification is acceppted. A justification can be given in the futherinfo tag. The justification shall start with this rule name.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='fea')]</applyto>
          <condition>( ./needscoverage/needsobj="swrs" or ./fulfilledby/ffbObj/ffbType="swrs" or ./fulfilledby/ffbObj/ffbType="swad" or ./needscoverage/needsobj="swpad" or ./fulfilledby/ffbObj/ffbType="swpad" or ./needscoverage/needsobj="swurs" or ./fulfilledby/ffbObj/ffbType="swurs" or ./needscoverage/needsobj="fea" or ./fulfilledby/ffbObj/ffbType="fea" or contains(./furtherinfo,"fea.needscoverage.impl"))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>


    <rule>
      <name>ERR.swad.fulfilledby.doctypes</name>
      <description>Architectural design objects of type swad can only be covered by swurs, swad, swdd, swintts, man, otherwise they should be refined with swrs</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swad')]</applyto>
          <condition>(./fulfilledby/ffbObj/ffbType="swurs" or ./needscoverage/needsobj="swurs" or ./fulfilledby/ffbObj/ffbType="req" or ./needscoverage/needsobj="req" or ./fulfilledby/ffbObj/ffbType="swad" or ./needscoverage/needsobj="swad" or ./fulfilledby/ffbObj/ffbType="swdd" or ./fulfilledby/ffbObj/ffbType="swintts" or ./needscoverage/needsobj="swintts" or ./fulfilledby/ffbObj/ffbType="man" or ./needscoverage/needsobj="man") </condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swmts.providescoverage.doctypes</name>
      <description>Test case specifications (tcs) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='tcs')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.man.providescoverage.doctypes</name>
      <description>Manual test case specification (man) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='man')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

   <rule>
      <name>ERR.swuts.providescoverage.doctypes</name>
      <description>Software unit test case specification (swuts) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swuts')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

   <rule>
      <name>ERR.swintts.providescoverage.doctypes</name>
      <description>Software integration test case specification (swintts) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swintts')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

   <rule>
      <name>ERR.swts.providescoverage.doctypes</name>
      <description>Software test case specification (swts) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swts')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

  </rules>
    <oreqmRules>

        <rule>
            <name>WRN.swts.needscoverage.count</name>
            <description>Violated if there are more than 10 swts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
        <rule>
            <name>WRN.man.needscoverage.count</name>
            <description>Violated if there are more than 10 man specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='man']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='man']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>man.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
        <rule>
            <name>WRN.swintts.needscoverage.count</name>
            <description>Violated if there are more than 10 swintts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swintts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swintts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swintts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
        <rule>
            <name>WRN.swmts.needscoverage.count</name>
            <description>Violated if there are more than 10 swmts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swmts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swmts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swmts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swuts.needscoverage.count</name>
            <description>Violated if there are more than 10 swuts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swuts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swuts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swuts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swpad.needscoverage.count</name>
            <description>Violated if there are more than 10 swpad specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swpad']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swpad']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swpad.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swrs.needscoverage.count</name>
            <description>Violated if there are more than 10 swrs specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swrs']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swrs']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swrs.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swad.needscoverage.count</name>
            <description>Violated if there are more than 10 swad specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swad']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swad']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swad.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swurs.needscoverage.count</name>
            <description>Violated if there are more than 10 swurs specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swurs']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swurs']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swurs.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swdd.needscoverage.count</name>
            <description>Violated if there are more than 10 swdd specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swdd']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swdd']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swdd.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.impl.needscoverage.count</name>
            <description>Violated if there are more than 10 impl specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='impl']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='impl']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>impl.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swrs.fulfilledby.count</name>
            <description>Violated if there are more than 10 swrs specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swrs'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swrs'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swrs.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swad.fulfilledby.count</name>
            <description>Violated if there are more than 10 swad specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swad'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swad'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swad.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swurs.fulfilledby.count</name>
            <description>Violated if there are more than 10 swurs specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swurs'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swurs'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swurs.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swdd.fulfilledby.count</name>
            <description>Violated if there are more than 10 swdd specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swdd'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swdd'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swdd.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
  </oreqmRules>
  </configuration>
  <specdocument>
    <specobjects doctype="lim">
        <specobject>
            <id>lim.Fee.EB_INTREQ_Fee_0001</id>
            <status>approved</status>
            <source>EB integration requirement</source>
            <version>1</version>
            <description>
              Callbacks:
              The EB memory stack modules NvM, Ea, and Fee make only limited
              use of the callback calls from their underlying modules. This
              also means that callbacks from the Fls to the Fee are not
              synchronously forwarded to the NvM. During the integration
              one has to make sure that the NvM, Ea, and Fee main functions
              are only called from the same task context so that they cannot
              preempt each other.
            </description>
            <rationale> 
              This approach enables a simple and lock-free implementation
              resulting in smaller code.
            </rationale>
            <providescoverage>
                <provcov>
                    <linksto>Fee.Callback.LimitUse</linksto>
                    <dstversion>1</dstversion>
                <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>202</internalId></provcov>
            </providescoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>0</internalId></specobject>
        <specobject>
            <id>lim.Fee.EB_INTREQ_Fee_0002</id>
            <status>approved</status>
            <source>EB integration requirement</source>
            <version>1</version>
            <description>
              Contiguous and ascending Flash sectors:
              The Flash sectors configured in <code>Fee_FlsSectorList</code> of the
              flash driver configuration should be contiguous if more than
              one sector is configured and they shall be in the ascending
              order of their addresses.
            </description>
            <rationale> 
              The logic used for calculating the Fee section size is
              dependent upon this configuration.
            </rationale>
            <providescoverage>
                <provcov>
                    <linksto>Fee.NonVolatileMemory.ContinuousAddressing</linksto>
                    <dstversion>1</dstversion>
                <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>199</internalId></provcov>
            </providescoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1</internalId></specobject>
        <specobject>
            <id>lim.Fee.EB_INTREQ_Fee_0003</id>
            <status>approved</status>
            <source>EB integration requirement</source>
            <version>1</version>
            <description>
              Flash virtual page size re-configuration:
              If the flash virtual page size is reconfigured, the Fee module
              cannot retrieve the data blocks which are present in the
              flash.
            </description>
            <rationale> 
              Internal management information size and aligned block size
              are dependent on the virtual page size.
            </rationale>
            <providescoverage>
                <provcov>
                    <linksto>Fee.VirtualPageSize.Constant</linksto>
                    <dstversion>1</dstversion>
                <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>201</internalId></provcov>
            </providescoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2</internalId></specobject>
        <specobject>
            <id>lim.Fee.EB_INTREQ_Fee_0004</id>
            <status>approved</status>
            <source>EB integration requirement</source>
            <version>1</version>
            <description>
              Flash erase value limitation:
              Only the first byte of the Fls published parameter <code>FlsErasedValue</code>
              is used by the Fee module.
            </description>
            <rationale>
              The Fls erased value is not expected to be different from one
              byte to another.
            </rationale>
            <providescoverage>
                <provcov>
                    <linksto>Fee.NonVolatileMemory.ErasedValue.OneByte</linksto>
                    <dstversion>1</dstversion>
                <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>200</internalId></provcov>
            </providescoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>3</internalId></specobject>
        
        <specobject>
            <id>lim.Fee.EB_INTREQ_Fee_0005</id>
            <status>approved</status>
            <source>EB integration requirement</source>
            <version>1</version>
            <description>
              Main functions:
              During the integration, the responsible for the MemStack modules has to
              make sure that the MemStack modules main functions are only called from
              the same task context and only from one task context so that they cannot
              preempt each other.
            </description>
            <rationale>
              This approach enables a simple and lock-free implementation
              resulting in smaller code.
            </rationale>
            
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>4</internalId></specobject>
        <specobject>
            <id>lim.Fee.EB_INTREQ_Fee_0006</id>
            <status>approved</status>
            <source>EB integration requirement</source>
            <version>1</version>
            <description>
              Emergency job result:
              When the user requests an erase-immediate job for emergency block it shall wait for job completion 
              by verifying the result of the job returned by <code>Fee_GetJobResult</code> API.
            </description>
            <rationale>
              If other means are used the user shall still call at least once the API <code>Fee_GetJobResult</code> after termination of the erase immediate job.
              The reason for this is to be compatible with NvM behavior.
            </rationale>
            
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>5</internalId></specobject>
        <specobject>
            <id>lim.Fee.EB_INTREQ_Fee_0007</id>
            <status>approved</status>
            <source>EB integration requirement</source>
            <version>1</version>
            <description>
              Emergency freezes Fee:
              Once the emergency block is requested to be written, the user shall stop the <code>NvM_MainFunction</code>'s task 
              until the emergency block is erased, when the task can be resumed.
            </description>
            <rationale>
                User may read the emergency block any time, once the emergency block is written.
            </rationale>
            
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>6</internalId></specobject>
        <specobject>
            <id>lim.Fee.EB_INTREQ_Fee_0008</id>
            <status>approved</status>
            <source>EB integration requirement</source>
            <version>1</version>
            <description>
              Emergency unfreezes Fee:
              If the emergency block is active in project, the user shall start the <code>NvM_MainFunction</code>'s task 
              at startup after the emergency block is erased.
            </description>
            <rationale>
              There is the possibility that the emergency block to be already written in flash by the time the system starts. 
              In this case Fee will remain frozen internally until the user requests an erase-immediate of this block. 
              Meanwile the user might read the emergency block any time.
            </rationale>
            
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>7</internalId></specobject>
        <specobject>
            <id>lim.Fee.EB_INTREQ_Fee_0009</id>
            <status>approved</status>
            <source>EB integration requirement</source>
            <version>1</version>
            <description>
              Emergency erase write:
              If the user requested an erase-immediate for emergency block and immediately the environment requires the emergency block to be written again, 
              the user shall not wait for the erase job to complete, but it shall request the emergency write job immediately 
              as long as at least one <code>Fee_MainFunction</code> had been called after requesting the erase immediate job.
            </description>
            <rationale>
              The signal to unfreeze Fee from emergency situation is given by the request of the erase immediate.
              Therefore after the request Fee is not frozen any more, and in case of another emergency write it should 
              behave consistently.
              Mind the fact that the code <code>Fee_EraseImmediate(EBlock); Fee_Write(EBlock,Buff);</code> will not work since by the time the write job comes 
              Fee would still be frozen internally. It needs on cycle of Fee main function after the erase-immediate request in order to unfreeze.
            </rationale>
            
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>8</internalId></specobject>
        <specobject>
            <id>lim.Fee.EB_INTREQ_Fee_0010</id>
            <status>approved</status>
            <source>EB integration requirement</source>
            <version>1</version>
            <description>
              Emergency failing normal job:
              The environment shall be aware that if an emergency write is called when NvM has a job already pending in Fee, the NvM job will be reported as failed.
            </description>
            <rationale>
              NvM is informed about the failure by either the notification callbacks or by NvM's polling mode.
              In this case the environment must take measures like retying the jobs.
            </rationale>
            
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>9</internalId></specobject>
        <specobject>
            <id>lim.Fee.EB_INTREQ_Fee_0011</id>
            <status>approved</status>
            <source>EB integration requirement</source>
            <version>1</version>
            <description>
              Emergency preemption:
              If an emergency block is active in the project and a custom API(Fee_WriteCustom or Fee_ReadCustom) is used,
              the user shall consider the possibility of an emergency block write request being declined if it preempts
              a custom API: a retry could be needed, or preemption to be prevented by the system.
            </description>
            <rationale>
              When Fee_WriteCustom or Fee_ReadCustom are configured, preemption protection is active for all Fee APIs,
              in order to prevent collision between NvM calling Fee API and a CDD calling Fee custom API.
              If the write of an emergency block comes at the same time with a custom API call that had already took the 
              preemption protection lock, the emergency job will not be accepted and it has to be retried.
              Other measure would be to freeze the CDD that uses the Fee custom APIs in case of an emergency event.
            </rationale>
            
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>10</internalId></specobject>
        <specobject>
            <id>lim.Fee.EB_INTREQ_Fee_0012</id>
            <status>approved</status>
            <source>EB integration requirement</source>
            <version>1</version>
            <description>
              Custom APIs after init:
              Any call of Fee_ReadCustom/Fee_WriteCustom shall be made after Fee initialization is over(when Fee is Idle and not Busy Internal).
            </description>
            <rationale>
              The environment must be aware that Fee_ReadCustom/Fee_WriteCustom depends on Fee initialization as the blocks that are not configured 
              can only be detected at initialization.
            </rationale>
            
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>11</internalId></specobject>
        <specobject>
            <id>lim.Fee.EB_INTREQ_Fee_0013</id>
            <status>approved</status>
            <source>EB integration requirement</source>
            <version>1</version>
            <description>
              Custom APIs preemption:
              The system shall be aware that SCHM_FEE_EXCLUSIVE_AREA_0 is used if Fee_WriteCustom or Fee_ReadCustom are configured. 
            </description>
            <rationale>
              The interrupts will be disabled only for checking and setting a preemption flag, that prevents call collisions of 
              the custom APIs with the standard APIs called by MemIf.
            </rationale>
            
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>12</internalId></specobject>
        <specobject>
            <id>lim.Fee.EB_INTREQ_Fee_0014</id>
            <status>approved</status>
            <source>EB integration requirement</source>
            <version>1</version>
            <description>
              Big buffer:
              The user must allocate enough RAM for Fee buffer to accommodate the biggest block if the FeeUseBufferForJobs is enabled.
            </description>
            <rationale>
              If the lower layer has alignment requirement Fee will have to make sure that the address given to the lower layer during
              a job request is aligned. Therefore Fee uses the internal buffer as an intermediary. As Fee is limited in performing a job
              in one shot, the internal buffer needs to be big enough to fit any configured block.
            </rationale>
            <providescoverage>
                <provcov>
                    <linksto>Fee.FeeUseBufferForJobs.MinimumBufferSize</linksto>
                    <dstversion>1</dstversion>
                <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>203</internalId></provcov>
            </providescoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>13</internalId></specobject>
        <specobject>
            <id>lim.Fee.EB_INTREQ_Fee_0015</id>
            <status>approved</status>
            <source>EB integration requirement</source>
            <version>1</version>
            <description>
              Number of write cycles:
              The parameter FeeNumberOfWriteCycles is not used by current Fee implementation and 
              it can be ignored during integration.
            </description>
            <rationale>
              As opposed to Ea implementation Fee implementation doesn't use fixed addresses for writing blocks.
              Therefore FeeNumberOfWriteCycles could only be used as a bad approximation, since the total available space
              for a particular block depends very much on the writing frequency of other blocks in the project.
            </rationale>
            <providescoverage>
                <provcov>
                    <linksto>Fee.SWS_Fee_00102</linksto>
                    <dstversion>1</dstversion>
                <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>136</internalId></provcov>
            </providescoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>14</internalId></specobject>
        <specobject>
            <id>lim.Fee.EB_INTREQ_Fee_0016</id>
            <status>approved</status>
            <source>EB integration requirement</source>
            <version>1</version>
            <description>
              Read failing during section switch:
              In case of flash driver reporting failure during Section switch reading operation
              Fee will perform a single retry of the reading. If the reading fails again, 
              the block will be skipped by Section switch and the data is lost.
              The integrator may use means of freezing the system after the first Fls read failure,
              until the system is steady again.
            </description>
            <rationale>
              If the failure happens because of damaged flesh cells, 
              there is no reason to consider that the memory cells will recover if keep retrying to read them.
              There is nothing to be done in this case.
              The switch must carry on.
            </rationale>
            <providescoverage>
                <provcov>
                    <linksto>Fee.Dns.FailureHandling.Behaviour.SectionSwitch.BlockDataRead</linksto>
                    <dstversion>1</dstversion>
                <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>933</internalId></provcov>
            </providescoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>15</internalId></specobject>
        <specobject>
            <id>lim.Fee.EB_INTREQ_Fee_0017</id>
            <status>approved</status>
            <source>EB integration requirement</source>
            <version>1</version>
            <description>
              Reading non-blank pages:
              If the flash technology doesn't guarantee a safe reading by blank-checking the same memory cells,
              the integrator shall configure 'FeeConsistencyPattern' in order to assure the consistency of the data
              and the avoidance of ECCs.
            </description>
            <rationale>
              If consistency patterns are not used Fee is not able to tell whether the memory cells 
              containing the section headers and footers are safe to be read on RV40F memory technology(used as an example).
              There are situations(quite probable) when blank checking the section management information is not enough
              for avoiding ECC errors. An incomplete erase/write can lead to this situation.
              There are also other situations(less probable) that may lead to data loss during Fee startup.
              Although EB Fee has mechanisms to assure data consistency up to a point, by using CRC
              in section management information, there are still situations,
              when the blank check performed over the section management information can fail
              because of an incomplete erase of the cells and the data will match the CRC because the hardware returns the 
              previously written data. (By ignoring ECC the probability of this situation increases)
              Please consult RV40F technology documentation(erata).
            </rationale>
            
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>16</internalId></specobject>
        <specobject>
            <id>lim.Fee.EB_INTREQ_Fee_0018</id>
            <status>approved</status>
            <source>EB integration requirement</source>
            <version>1</version>
            <description>
              Blank check and data retention:
              If the flash technology doesn't guarantee through blank-checking that a word can safely be written,
              the integrator shall configure 'FeeConsistencyPattern' in order to assure data retention.
            </description>
            <rationale>
              An incompletely erased word may still be seen as blank. Although the writing over that word
              doesn't lead to any error, the data retention cannot be assured.
              Please consult RV40F technology documentation(erata).
            </rationale>
            
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>17</internalId></specobject>
        <specobject>
            <id>lim.Fee.EB_INTREQ_Fee_0019</id>
            <status>approved</status>
            <source>EB integration requirement</source>
            <version>1</version>
            <description>
              Many sections and startup:
              If there are many sections configured (ex.: 16) and there are less frequently written blocks,
              the Fee startup may take too long. The integrator can mitigate this issue by configuring a 
              lower number of sections (eg.: 4) for the same total flash size.
            </description>
            <rationale>
              Section switch is designed to naturally keep half of the sections with data and half empty.
              Because of this sometimes less frequently written blocks remain hanging in the oldest section.
              Fee doesn't stop the block searching until they are found, leading to parsing half of the sections
              during startup.
            </rationale>
            <providescoverage>
                <provcov>
                    <linksto>Fee.Dns.SS.TriggeringTheSwitch.WriteRequest</linksto>
                    <dstversion>1</dstversion>
                <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>897</internalId></provcov>
            </providescoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>18</internalId></specobject>
        <specobject>
            <id>lim.Fee.EB_INTREQ_Fee_0020</id>
            <status>approved</status>
            <source>EB integration requirement</source>
            <version>1</version>
            <description>
              Integrity of block management data:
              Integrity of the block's data is ensured by writing management
              information before and after writing the actual user data. If
              an unexpected shutdown occurs before the writing of the Written marker, 
              the module retrieves the older block's instance if it exists.
            </description>
            <rationale>
              The module ensures the integrity of blocks stored in flash by
              storing extra block management data.
            </rationale>
            
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>19</internalId></specobject>
    </specobjects>
    <specobjects doctype="swurs">
    <specobject>
      <id>Fee.ASR40.ECUC_Fee_00070</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_4_0_3.xml</source>
      <version>1</version>
      <description>
        Name: FeeMaximumBlockingTime
        Parameter Type: FloatValue
        Parent Containers: FeePublishedInformation,
        Description: The maximum time the FEE module's API routines shall be blocked (delayed) by 
        internal operations.
        Introduction: Note: Internal operations in that case means operations that are not explicitly 
        invoked from the upper layer module but need to be handled for proper operation of this module 
        or the underlying memory driver.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Origin: AUTOSAR_ECUC
        Symbolic-Name-Value: false
        Max-Value: Inf (Type:
        Min-Value: 0 (Type:
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_1764</srcid><srcstatus/><internalId>813</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>20</internalId></specobject>
    <specobject>
      <id>Fee.ASR40.ECUC_Fee_00152</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_4_0_3.xml</source>
      <version>1</version>
      <description>
        Name: FeeIndex
        Parameter Type: Integer
        Parent Containers: FeeGeneral,
        Description: Specifies the InstanceId of this module instance. If only one instance is present 
        it shall have the Id 0.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Origin: AUTOSAR_ECUC
        Symbolic-Name-Value: false
        Max-Value: 254 (Type:
        Min-Value: 0 (Type:
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_552</srcid><srcstatus/><internalId>776</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>21</internalId></specobject>
    <specobject>
      <id>Fee.ASR40.SWS_Fee_00002</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_4_0_3.xml</source>
      <version>1</version>
      <description>
        The file include structure shall be as follows: Figure 2: Flash EEPROM Emulation File Include 
        Structure
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/include/Fee_Cfg.h.m4_9</srcid><srcstatus/><internalId>352</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/generate/include/Fee_Cfg.h.m4_14</srcid><srcstatus/><internalId>353</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/generate/include/Fee_Cfg.h.m4_23</srcid><srcstatus/><internalId>354</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/include/Fee.h.m4_6</srcid><srcstatus/><internalId>371</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/include/Fee.h.m4_8</srcid><srcstatus/><internalId>372</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/include/Fee_Initialization.h_21</srcid><srcstatus/><internalId>375</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/include/Fee_Internal.h.m4_22</srcid><srcstatus/><internalId>376</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/include/Fee_Jobs.h_21</srcid><srcstatus/><internalId>382</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/include/Fee_Sections.h_21</srcid><srcstatus/><internalId>383</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/include/Fee_Sections.h_23</srcid><srcstatus/><internalId>384</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/include/Fee_SectionsSwitch.h_21</srcid><srcstatus/><internalId>385</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/include/Fee_SectionsSwitch.h_23</srcid><srcstatus/><internalId>386</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee.c.m4_15</srcid><srcstatus/><internalId>388</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations><ruleid>WRN.impl.needscoverage.count</ruleid></oreqmViolations><covstatus>covered</covstatus><internalId>22</internalId></specobject>
    <specobject>
      <id>Fee.ASR40.SWS_Fee_00010</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_4_0_3.xml</source>
      <version>1</version>
      <description>
        The FEE module shall detect the following errors and exceptions depending on its configuration 
        development/production): Type or error Relevance Related error code Value [hex] API service 
        called when module was not initialized Development FEE_E_UNINIT 0x01 API service called with 
        invalid block number Development FEE_E_INVALID_BLOCK_NO 0x02 API service called with invalid 
        block offset Development FEE_E_INVALID_BLOCK_OFS 0x03 API service called with invalid data 
        pointer Development FEE_E_INVALID_DATA_PTR 0x04 API service called with invalid length 
        information Development FEE_E_INVALID_BLOCK_LEN 0x05 API service called while module is busy 
        processing a user request Development FEE_E_BUSY 0x06 API service called while module is busy 
        doing internal management operations. Development FEE_E_BUSY_INTERNAL 0x07 Fee_Cancel called 
        while no job was pending. Development FEE_E_INVALID_CANCEL 0x08
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_30032</srcid><srcstatus/><internalId>1234</internalId></linkedfrom><linkedfrom><srcid>TS_FEE_30033</srcid><srcstatus/><internalId>1235</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>23</internalId></specobject>
    <specobject>
      <id>Fee.ASR40.SWS_Fee_00011</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_4_0_3.xml</source>
      <version>1</version>
      <description>
        The detection of development errors is configurable (ON / OFF) at pre-compile time. The switch 
        FeeDevErrorDetect  shall activate or deactivate the detection of all development errors.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_20000</srcid><srcstatus/><internalId>973</internalId></linkedfrom><linkedfrom><srcid>TS_FEE_20001</srcid><srcstatus/><internalId>974</internalId></linkedfrom><linkedfrom><srcid>TS_FEE_20002</srcid><srcstatus/><internalId>975</internalId></linkedfrom><linkedfrom><srcid>TS_FEE_20003</srcid><srcstatus/><internalId>976</internalId></linkedfrom><linkedfrom><srcid>TS_FEE_20004</srcid><srcstatus/><internalId>977</internalId></linkedfrom><linkedfrom><srcid>TS_FEE_20005</srcid><srcstatus/><internalId>978</internalId></linkedfrom><linkedfrom><srcid>TS_FEE_20006</srcid><srcstatus/><internalId>979</internalId></linkedfrom><linkedfrom><srcid>TS_FEE_20007</srcid><srcstatus/><internalId>980</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>24</internalId></specobject>
    <specobject>
      <id>Fee.ASR40.SWS_Fee_00013</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_Fee_4_0_3.xml</source>
      <version>1</version>
      <description>
        The Fee module shall perform inter module checks to avoid integration of incompatible files: 
        all included header files shall be checked by pre-processing directives. The Fee module shall 
        thereby verify that &lt;MODULENAME&gt;_AR_RELEASE_MAJOR_VERSION and &lt;MODULENAME&gt;
        _AR_RELEASE_MINOR_VERSION are identical to the expected values, where &lt;MODULENAME&gt; is the 
        module abbreviation of the external module, which provides the included header file. If the 
        values are not identical, an error shall be raised at compile time.
      </description>
      <comment>
        This requirement is not applicable since NONE: [BSWM_CHK_401] Inter module
        version check, Although required by the SRS General, BSW004, inter-module
        version-checks SHALL NOT be done. A deviation is documented globally for all
        BSW modules within the release notes and SHALL NOT be documented
        for each module.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>25</internalId></specobject>
    <specobject>
      <id>Fee.ASR40.SWS_Fee_00020</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_Fee_4_0_3.xml</source>
      <version>1</version>
      <description>
        If the current module status is MEMIF_IDLE and if supported by the underlying hardware and 
        device driver, the function Fee_SetMode shall call the function Fls_SetMode of the underlying 
        flash driver with the given "Mode" parameter.
      </description>
      <comment>
        This requirement is not applicable. It is a duplicate of requirement SWS_Fee_00190.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>26</internalId></specobject>
    <specobject>
      <id>Fee.ASR40.SWS_Fee_00045</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_4_0_3.xml</source>
      <version>1</version>
      <description>
        Detected development errors shall be reported to the Det_ReportError service of the Development 
        Error Tracer (DET) if the pre-processor switch FeeDevErrorDetect is set 
      </description>
      <comment>
        There are no DEM errors specified for FEE.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_30032</srcid><srcstatus/><internalId>1234</internalId></linkedfrom><linkedfrom><srcid>TS_FEE_30033</srcid><srcstatus/><internalId>1235</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>27</internalId></specobject>
    <specobject>
      <id>Fee.ASR40.SWS_Fee_00047</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_Fee_4_0_3.xml</source>
      <version>1</version>
      <description>
        Values for production code Event Ids are assigned externally by the configuration of the Dem. 
        They are published in the file Dem_IntErrId.h and included via Dem.h.
      </description>
      <comment>
        This requirement is not applicable as there is no Dem error reported from Fee.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>28</internalId></specobject>
    <specobject>
      <id>Fee.ASR40.SWS_Fee_00048</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_4_0_3.xml</source>
      <version>1</version>
      <description>
        Development error values are of type uint8.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/Fee_Internal.h.m4_30</srcid><srcstatus/><internalId>377</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>29</internalId></specobject>
    <specobject>
      <id>Fee.ASR40.SWS_Fee_00059</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_Fee_4_0_3.xml</source>
      <version>1</version>
      <description>
        The code file structure shall not be defined within this specification.
      </description>
      <comment>
        This requirement is informational only.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>30</internalId></specobject>
    <specobject>
      <id>Fee.ASR40.SWS_Fee_00060</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_4_0_3.xml</source>
      <version>1</version>
      <description>
        The module shall include the Dem.h file. By this inclusion, the APIs to report errors as well 
        as the required Event Id symbols are included. This specification defines the name of the Event 
        Id symbols which are provided by XML to the DEM configuration tool. The DEM configuration tool 
        assigns ECU dependent values to the Event Id symbols and publishes the symbols in Dem_IntErrId.
        h.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_21</srcid><srcstatus/><internalId>467</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_38</srcid><srcstatus/><internalId>579</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>31</internalId></specobject>
    <specobject>
      <id>Fee.ASR40.SWS_Fee_00062</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_4_0_3.xml</source>
      <version>1</version>
      <description>
        If the FeeDevErrorDetect switch is enabled, API parameter checking is enabled. The detailed 
        description of the detected errors can be found in chapter 7.2 and chapter 10.2.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_DetFeeUninit</srcid><srcstatus/><internalId>1228</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>32</internalId></specobject>
    <specobject>
      <id>Fee.ASR40.SWS_Fee_00063</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_Fee_4_0_3.xml</source>
      <version>1</version>
      <description>
        The detection of production code errors cannot be switched off.
      </description>
      <comment>
        This requirement is not applicable as there is no Dem error reported from Fee.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>33</internalId></specobject>
    <specobject>
      <id>Fee.ASR40.SWS_Fee_00064</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_4_0_3.xml</source>
      <version>1</version>
      <description>
        The function Fee_GetVersionInfo shall return the version information of the FEE module. The 
        version information includes: Module Id Vendor Id Vendor specific version numbers (BSW00407)
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_30031</srcid><srcstatus/><internalId>1212</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>34</internalId></specobject>
    <specobject>
      <id>Fee.ASR40.SWS_Fee_00065</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_4_0_3.xml</source>
      <version>1</version>
      <description>
        The function Fee_GetVersionInfo shall be pre-compile time configurable On/Off by the 
        configuration parameter FeeVersionInfoApi.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_20000</srcid><srcstatus/><internalId>973</internalId></linkedfrom><linkedfrom><srcid>TS_FEE_20001</srcid><srcstatus/><internalId>974</internalId></linkedfrom><linkedfrom><srcid>TS_FEE_20002</srcid><srcstatus/><internalId>975</internalId></linkedfrom><linkedfrom><srcid>TS_FEE_20003</srcid><srcstatus/><internalId>976</internalId></linkedfrom><linkedfrom><srcid>TS_FEE_20004</srcid><srcstatus/><internalId>977</internalId></linkedfrom><linkedfrom><srcid>TS_FEE_20005</srcid><srcstatus/><internalId>978</internalId></linkedfrom><linkedfrom><srcid>TS_FEE_20006</srcid><srcstatus/><internalId>979</internalId></linkedfrom><linkedfrom><srcid>TS_FEE_20007</srcid><srcstatus/><internalId>980</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>35</internalId></specobject>
    <specobject>
      <id>Fee.ASR40.SWS_Fee_00069</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_4_0_3.xml</source>
      <version>1</version>
      <description>
        The FEE module shall provide function prototypes of the callback functions in the file Fee_Cbk.
        h
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/Fee_Cbk.h_38</srcid><srcstatus/><internalId>373</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/include/Fee_Cbk.h_49</srcid><srcstatus/><internalId>374</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>36</internalId></specobject>
    <specobject>
      <id>Fee.ASR40.SWS_Fee_00082</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_Fee_4_0_3.xml</source>
      <version>1</version>
      <description>
        If source code for caller and callee of the function Fee_GetVersionInfo is available, the FEE 
        module should realize this function as a macro. The FEE module should define this macro in the 
        module's header file.
      </description>
      <comment>
        This requirement is not applicable as the support for this function is in line with EB implementation and
        a macro is not used in any case.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>37</internalId></specobject>
    <specobject>
      <id>Fee.ASR40.SWS_Fee_00085</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_4_0_3.xml</source>
      <version>2</version>
      <description>
        Service name: Fee_Init Syntax: void Fee_Init(void) Service ID[hex]: 0x00 Sync/Async: 
        Asynchronous Reentrancy: Non Reentrant Parameters (in): None Parameters (inout): None 
        Parameters (out): None Return value: None Description: Service to initialize the FEE module.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_30001</srcid><srcstatus/><internalId>1213</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>38</internalId></specobject>
    <specobject>
      <id>Fee.ASR40.SWS_Fee_00098</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_Fee_4_0_3.xml</source>
      <version>1</version>
      <description>
        Service name: NvM_JobEndNotification Syntax: void NvM_JobEndNotification( void) Sync/Async: 
        true Reentrancy: Don't care Parameters (in): None Parameters (inout): None Parameters (out): 
        None Return value: None Description:
      </description>
      <comment>
        This requirement is not applicable since this is the specification of NvM interface.
        FEE ensures that this interface function is being called and FEE is not responsible for
        implementation of this function.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>39</internalId></specobject>
    <specobject>
      <id>Fee.ASR40.SWS_Fee_00099</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_Fee_4_0_3.xml</source>
      <version>1</version>
      <description>
        Service name: NvM_JobErrorNotification Syntax: void NvM_JobErrorNotification( void) Sync/
        Async: true Reentrancy: Don't care Parameters (in): None Parameters (inout): None Parameters (
        out): None Return value: None Description:
      </description>
      <comment>
        This requirement is not applicable since this is the specification of NvM interface.
        FEE ensures that this interface function is being called and FEE is not responsible
        for implementation of this function.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>40</internalId></specobject>
    <specobject>
      <id>Fee.ASR40.SWS_Fee_00104</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_Fee_4_0_3.xml</source>
      <version>1</version>
      <description>
        API function Description Det_ReportError Service to report development errors.
      </description>
      <comment>
        This requirement is not applicable since it is the specification of DET interface.
        FEE ensures that this interface function is being called and FEE is not responsible
        for implementation of this function.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>41</internalId></specobject>
    <specobject>
      <id>Fee.ASR40.SWS_Fee_00105</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_Fee_4_0_3.xml</source>
      <version>1</version>
      <description>
        API function Description Fls_Cancel Cancels an ongoing job. Fls_Compare Compares the contents 
        of an area of flash memory with that of an application data buffer. Fls_Erase Erases flash 
        sector(s). Fls_GetJobResult Returns the result of the last job. Fls_GetStatus Returns the 
        driver state. Fls_Read Reads from flash memory. Fls_SetMode Sets the flash driver's operation 
        mode. Fls_Write Writes one or more complete flash pages.
      </description>
      <comment>
        This requirement is not applicable since this is the spec of mandatory interfaces
        needed from flash driver to achieve core functionality.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>42</internalId></specobject>
    <specobject>
      <id>Fee.ASR40.SWS_Fee_00106</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_Fee_4_0_3.xml</source>
      <version>1</version>
      <description>
        Production errors shall be reported to Diagnostic Event Manager.
      </description>
      <comment>
        This requirement is not applicable as there is no Dem error reported from Fee.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>43</internalId></specobject>
    <specobject>
      <id>Fee.ASR40.SWS_Fee_00120</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_4_0_3.xml</source>
      <version>1</version>
      <description>
        The function Fee_Init shall set the module state from MEMIF_UNINIT to MEMIF_BUSY_INTERNAL once 
        it starts the module's initialization.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Ts_Fee_Cancel_Behavior_JobPending_Startup1_NoRequest</srcid><srcstatus/><internalId>993</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>44</internalId></specobject>
    <specobject>
      <id>Fee.ASR40.SWS_Fee_00130</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_4_0_3.xml</source>
      <version>1</version>
      <description>
        The modules status, the job result and the block meta information  shall be made available for 
        debugging (reading). Therefore those variables shall be implemented as global variables.
      </description>
      <comment>
        Fee state (giving information about the module's status and the current action) is available for debugging.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Fee.NoSupportForDebugging</srcid><srcstatus/><internalId>322</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>45</internalId></specobject>
    <specobject>
      <id>Fee.ASR40.SWS_Fee_00131</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_4_0_3.xml</source>
      <version>1</version>
      <description>
        The type definitions and declarations of all variables which shall be used for debugging shall 
        be given in the modules header file Fee.h.
      </description>
      <comment>
        Internal types and internal variables not published for Fee users.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Fee.NoSupportForDebugging</srcid><srcstatus/><internalId>322</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>46</internalId></specobject>
    <specobject>
      <id>Fee.ASR40.SWS_Fee_00132</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_4_0_3.xml</source>
      <version>1</version>
      <description>
        All variables which shall be used for debugging shall be described in detail in the modules 
        description file.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate_swcd/swcd/Fee_Bswmd.arxml.m4_31</srcid><srcstatus/><internalId>815</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>47</internalId></specobject>
    <specobject>
      <id>Fee.ASR40.SWS_Fee_00133</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_4_0_3.xml</source>
      <version>1</version>
      <description>
        If development error detection is enabled for the module: the function Fee_Read shall check if 
        the module state is MEMIF_BUSY. If this is the case, the function Fee_Read shall reject the 
        read request, raise the development error FEE_E_BUSY and return with E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_DetMemIfBusy</srcid><srcstatus/><internalId>1232</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>48</internalId></specobject>
    <specobject>
      <id>Fee.ASR40.SWS_Fee_00136</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_4_0_3.xml</source>
      <version>1</version>
      <description>
        If development error detection is enabled for the module: the function Fee_Read shall check 
        that the given data pointer is valid (i.e. that it is not NULL). If this is not the case, the 
        function Fee_Read shall reject the read request, raise the development error 
        FEE_E_INVALID_DATA_PTR and return with E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_DetInvalidDataPtr</srcid><srcstatus/><internalId>1229</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>49</internalId></specobject>
    <specobject>
      <id>Fee.ASR40.SWS_Fee_00139</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_4_0_3.xml</source>
      <version>1</version>
      <description>
        If development error detection is enabled for the module: the function Fee_Write shall check 
        that the given data pointer is valid (i.e. that it is not NULL). If this is not the case, the 
        function Fee_Write shall reject the write request, raise the development error 
        FEE_E_INVALID_DATA_PTR and return with E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_DetInvalidDataPtr</srcid><srcstatus/><internalId>1229</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>50</internalId></specobject>
    <specobject>
      <id>Fee.ASR40.SWS_Fee_00144</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_4_0_3.xml</source>
      <version>1</version>
      <description>
        If development error detection is enabled for the module: the function Fee_Write shall check if 
        the module state is MEMIF_BUSY. If this is the case, the function Fee_Write shall reject the 
        write request, raise the development error FEE_E_BUSY and return with E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_DetMemIfBusy</srcid><srcstatus/><internalId>1232</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>51</internalId></specobject>
    <specobject>
      <id>Fee.ASR40.SWS_Fee_00145</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_4_0_3.xml</source>
      <version>1</version>
      <description>
        If development error detection is enabled for the module: the function Fee_InvalidateBlock 
        shall check if the module status is MEMIF_BUSY. If this is the case, the function 
        Fee_InvalidateBlock shall reject the request, raise the development error FEE_E_BUSY and return 
        with E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee.c.m4_778</srcid><srcstatus/><internalId>421</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_DetMemIfBusy</srcid><srcstatus/><internalId>1232</internalId></linkedfrom><linkedfrom><srcid>TS_FEE_30010</srcid><srcstatus/><internalId>1240</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>52</internalId></specobject>
    <specobject>
      <id>Fee.ASR40.SWS_Fee_00146</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_4_0_3.xml</source>
      <version>1</version>
      <description>
        If development error detection is enabled for the module: the function Fee_EraseImmediateBlock 
        shall check if the module state is MEMIF_BUSY. If this is the case, the function 
        Fee_EraseImmediateBlock shall reject the erase request, raise the development error FEE_E_BUSY 
        and return with E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee.c.m4_894</srcid><srcstatus/><internalId>427</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_DetMemIfBusy</srcid><srcstatus/><internalId>1232</internalId></linkedfrom><linkedfrom><srcid>TS_FEE_30010</srcid><srcstatus/><internalId>1240</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>53</internalId></specobject>
    <specobject>
      <id>Fee.ASR40.SWS_Fee_00147</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_4_0_3.xml</source>
      <version>1</version>
      <description>
        If development error detection is enabled for the module: the function Fee_GetVersionInfo shall 
        check that the given data pointer is valid (i.e. that it is not NULL). If this is not the case,
        the function Fee_GetVersionInfo shall raise the development error FEE_E_INVALID_DATA_PTR.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_DetGetVersionInfo</srcid><srcstatus/><internalId>1237</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>54</internalId></specobject>
    <specobject>
      <id>Fee.ASR40.SWS_Fee_00167</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_4_0_3.xml</source>
      <version>1</version>
      <description>
        VARIANT-PRE-COMPILE
        Only parameters with "Pre-compile time" configuration are allowed in this
        variant.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_34</srcid><srcstatus/><internalId>760</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>55</internalId></specobject>
    <specobject>
      <id>Fee.ASR40.SWS_Fee_00168</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_Fee_4_0_3.xml</source>
      <version>1</version>
      <description>
        If initialization is finished within Fee_Init, the function Fee_Init shall set the module state 
        from MEMIF_BUSY_INTERNAL to MEMIF_IDLE once initialization has been successfully finished.
      </description>
      <comment>
        This requirement is not applicable as the initialization is not finished with in Fee_Init.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>56</internalId></specobject>
    <specobject>
      <id>Fee.ASR40.SWS_Fee_00169</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_4_0_3.xml</source>
      <version>1</version>
      <description>
        If the module initialization (started in the function Fee_Init) is completed in the module's 
        main function, the function Fee_MainFunction shall set the module status from 
        MEMIF_BUSY_INTERNAL to MEMIF_IDLE once initialization of the module has been successfully 
        finished.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_2510</srcid><srcstatus/><internalId>574</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>57</internalId></specobject>
    <specobject>
      <id>Fee.ASR40.SWS_Fee_00170</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_4_0_3.xml</source>
      <version>1</version>
      <description>
        If development error detection is enabled for the module: the function Fee_SetMode shall check 
        if the module state is MEMIF_BUSY. If this is the case, the function Fee_SetMode shall raise 
        the development error FEE_E_BUSY and return to the caller without executing the mode switch.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_DetMemIfBusy</srcid><srcstatus/><internalId>1232</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>58</internalId></specobject>
    <specobject>
      <id>Fee.ASR40.SWS_Fee_00171</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_Fee_4_0_3.xml</source>
      <version>1</version>
      <description>
        If development error detection is enabled for the module: the function Fee_SetMode shall check 
        if the module state is MEMIF_BUSY_INTERNAL. If this is the case, the function Fee_SetMode shall 
        raise the development error FEE_E_BUSY_INTERNAL and return to the caller without executing the 
        mode switch.
      </description>
      <comment>
        This requirement is not applicable.This requirement is obsolete as with Autosar 4.3 version.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>59</internalId></specobject>
    <specobject>
      <id>Fee.ASR40.SWS_Fee_00173</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_Fee_4_0_3.xml</source>
      <version>1</version>
      <description>
        If development error detection is enabled for the module: if the current module status is 
        MEMIF_BUSY_INTERNAL and if it is not possible to suspend or abort the internal management 
        operation (because of data consistency / module implementation / hardware restrictions), the 
        function Fee_Read shall reject the read request, raise the development error 
        FEE_E_BUSY_INTERNAL and return with E_NOT_OK.
      </description>
      <comment>
        This requirement is not applicable.This requirement is obsolete as with Autosar 4.3 version.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>60</internalId></specobject>
    <specobject>
      <id>Fee.ASR40.SWS_Fee_00175</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_Fee_4_0_3.xml</source>
      <version>1</version>
      <description>
        If development error detection is enabled for the module: if the current module status is 
        MEMIF_BUSY_INTERNAL and if it is not possible to suspend or abort the internal management 
        operation (because of data consistency / module implementation / hardware restrictions), the 
        function Fee_Write shall reject the write request, raise the development error 
        FEE_E_BUSY_INTERNAL and return with E_NOT_OK.
      </description>
      <comment>
        This requirement is not applicable.This requirement is obsolete as with Autosar 4.3 version.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>61</internalId></specobject>
    <specobject>
      <id>Fee.ASR40.SWS_Fee_00176</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_Fee_4_0_3.xml</source>
      <version>1</version>
      <description>
        If the current module status is not MEMIF_IDLE, the function Fee_InvalidateBlock shall reject 
        the invalidation request and return with E_NOT_OK.
      </description>
      <comment>
        This requirement is not applicable.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>62</internalId></specobject>
    <specobject>
      <id>Fee.ASR40.SWS_Fee_00177</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_Fee_4_0_3.xml</source>
      <version>1</version>
      <description>
        If development error detection is enabled for the module: if the current module status is 
        MEMIF_BUSY_INTERNAL and if it is not possible to suspend or abort the internal management 
        operation (because of data consistency / module implementation / hardware restrictions), the 
        function Fee_InvalidateBlock shall reject the invalidation request, raise the development error 
        FEE_E_BUSY_INTERNAL and return with E_NOT_OK.
      </description>
      <comment>
        This requirement is not applicable.This requirement is obsolete as with Autosar 4.3 version.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>63</internalId></specobject>
    <specobject>
      <id>Fee.ASR40.SWS_Fee_00178</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_Fee_4_0_3.xml</source>
      <version>1</version>
      <description>
        If development error detection is enabled for the module: if the current module status is 
        MEMIF_BUSY_INTERNAL and if it is not possible to suspend or abort the internal management 
        operation (because of data consistency / module implementation / hardware restrictions), the 
        function Fee_EraseImmediateBlock shall reject the request, raise the development error 
        FEE_E_BUSY_INTERNAL and return with E_NOT_OK.
      </description>
      <comment>
        This requirement is not applicable.This requirement is obsolete as with Autosar 4.3 version.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>64</internalId></specobject>
    <specobject>
      <id>Fee.ASR40.SWS_Fee_00179</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_4_0_3.xml</source>
      <version>1</version>
      <description>
        If the current module status is MEMIF_BUSY_INTERNAL and if the internal management operation 
        can be suspended without jeopardizing the data consistency: the function Fee_MainFunction shall 
        save all information which is necessary to resume the internal management operation, suspend 
        the internal management operation and start processing the job requested by the upper layer.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>doc/public/changelog/Deviations.xml_147</srcid><srcstatus/><internalId>324</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>65</internalId></specobject>
    <specobject>
      <id>Fee.ASR40.SWS_Fee_00180</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_4_0_3.xml</source>
      <version>1</version>
      <description>
        If the current module status is MEMIF_BUSY_INTERNAL and if the internal management operation 
        can be aborted without jeopardizing the data consistency: the function Fee_MainFunction shall 
        save all information which is necessary to restart the internal management operation, abort the 
        internal management operation and start processing the job requested by the upper layer.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>doc/public/changelog/Deviations.xml_148</srcid><srcstatus/><internalId>325</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>66</internalId></specobject>
    <specobject>
      <id>Fee.ASR40.SWS_Fee_00181</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_4_0_3.xml</source>
      <version>1</version>
      <description>
        If an internal management operation has been suspended because of a job request from the upper 
        layer, the function Fee_MainFunction shall resume this internal management operation once the 
        job requested by the upper layer has been finished.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>doc/public/changelog/Deviations.xml_149</srcid><srcstatus/><internalId>326</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>67</internalId></specobject>
    <specobject>
      <id>Fee.ASR40.SWS_Fee_00182</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_4_0_3.xml</source>
      <version>1</version>
      <description>
        If an internal management operation has been aborted because of a job request from the upper 
        layer, the function Fee_MainFunction shall restart this internal management operation once the 
        job requested by the upper layer has been finished.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Fee.Fee_InternalOperationManagement</srcid><srcstatus/><internalId>327</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>68</internalId></specobject>
    <specobject>
      <id>Fee.ASR40.SWS_Fee_00183</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_Fee_4_0_3.xml</source>
      <version>1</version>
      <description>
        If the write request addresses a block containing immediate data, the function Fee_Write shall 
        accept the write request, even if the current module status is MEMIF_BUSY_INTERNAL and the 
        internal management operation can't be suspended or aborted.
      </description>
      <comment>
        This requirement is not applicable.This requirement is obsolete as with Autosar 4.3 version.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>69</internalId></specobject>
    <specobject>
      <id>Fee.ASR40.SWS_Fee_00184</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_4_0_3.xml</source>
      <version>1</version>
      <description>
        If the current module status is not MEMIF_BUSY (i.e. there is no job to cancel and therefore 
        the request to cancel a pending job is rejected by the function Fee_Cancel), the function 
        Fee_Cancel shall raise the development error FEE_E_INVALID_CANCEL.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_DetInvalidCancel</srcid><srcstatus/><internalId>1236</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>70</internalId></specobject>
    <specobject>
      <id>Fee.ASR40.SWS_Fee_00185</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_4_0_3.xml</source>
      <version>1</version>
      <description>
        BSW00402 in the General Requirements on Basic Software Modules [3] shall be
        published within the header file of this module and need to be provided in the BSW
        Module Description. The according module abbreviation can be found in the List of
        Basic Software Modules [1]
        Additional module-specific published parameters are listed below if applicable.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/Fee_Version.h.m4_2</srcid><srcstatus/><internalId>387</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/generate_swcd/swcd/Fee_Bswmd.arxml.m4_356</srcid><srcstatus/><internalId>816</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>71</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs">
    <specobject>
      <id>Fee.ECUC_Fee_00039</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        Name: FeeGeneral
        Container Type: Container
        Description: Container for general parameters. These parameters are not specific to a block.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_292</srcid><srcstatus/><internalId>770</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>72</internalId></specobject>
    <specobject>
      <id>Fee.ECUC_Fee_00040</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        Name: FeeBlockConfiguration
        Container Type: Container
        Description: Configuration of block specific parameters for the Flash EEPROM Emulation module.
        Lower Multiplicity: 1
        infinite
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_58</srcid><srcstatus/><internalId>761</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>73</internalId></specobject>
    <specobject>
      <id>Fee.ECUC_Fee_00043</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        Name: FeePublishedInformation
        Container Type: Container
        Description: Additional published parameters not covered by CommonPublishedInformation 
        container.
        Introduction: Note that these parameters do not have any configuration class setting, since 
        they are published information.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_1712</srcid><srcstatus/><internalId>811</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>74</internalId></specobject>
    <specobject>
      <id>Fee.ECUC_Fee_00110</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        Name: FeeNumberOfWriteCycles
        Parameter Type: Integer
        Parent Containers: FeeBlockConfiguration,
        Description: Number of write cycles required for this block.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: 4294967295 (Type:
        Min-Value: 0 (Type:
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_191</srcid><srcstatus/><internalId>767</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>75</internalId></specobject>
    <specobject>
      <id>Fee.ECUC_Fee_00111</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        Name: FeeDevErrorDetect
        Parameter Type: Boolean
        Parent Containers: FeeGeneral,
        Description: Switches the development error detection and notification on or off.
        Introduction: * true: detection and notification is enabled. * false: detection and 
        notification is disabled.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_523</srcid><srcstatus/><internalId>775</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>76</internalId></specobject>
    <specobject>
      <id>Fee.ECUC_Fee_00112</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        Name: FeeNvmJobEndNotification
        Parameter Type: FunctionRef
        Parent Containers: FeeGeneral,
        Description: Mapped to the job end notification routine provided by the upper layer module (
        NvM_JobEndNotification)
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: false
        Post-Build-Variant-Value: false
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        FunctionName Def Condition:Max-Length: , Min-Length
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_605</srcid><srcstatus/><internalId>778</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>77</internalId></specobject>
    <specobject>
      <id>Fee.ECUC_Fee_00113</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        Name: FeeNvmJobErrorNotification
        Parameter Type: FunctionRef
        Parent Containers: FeeGeneral,
        Description: Mapped to the job error notification routine provided by the upper layer module (
        NvM_JobErrorNotification)
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: false
        Post-Build-Variant-Value: false
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        FunctionName Def Condition:Max-Length: , Min-Length
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_632</srcid><srcstatus/><internalId>779</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>78</internalId></specobject>
    <specobject>
      <id>Fee.ECUC_Fee_00114</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        Name: FeePollingMode
        Parameter Type: Boolean
        Parent Containers: FeeGeneral,
        Description: Pre-processor switch to enable and disable the polling mode for this module.
        Introduction: true: Polling mode enabled, callback functions (provided to MemAcc module) 
        disabled. false: Polling mode disabled, callback functions (provided to MemAcc module) enabled.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_FEE114_PollingMode</srcid><srcstatus/><internalId>208</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_659</srcid><srcstatus/><internalId>780</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>79</internalId></specobject>
    <specobject>
      <id>Fee.ECUC_Fee_00115</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        Name: FeeVersionInfoApi
        Parameter Type: Boolean
        Parent Containers: FeeGeneral,
        Description: Pre-processor switch to enable / disable the API to read out the modules version 
        information.
        Introduction: true: Version info API enabled. false: Version info API disabled.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_738</srcid><srcstatus/><internalId>783</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>80</internalId></specobject>
    <specobject>
      <id>Fee.ECUC_Fee_00116</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        Name: FeeVirtualPageSize
        Parameter Type: Integer
        Parent Containers: FeeGeneral,
        Description: The size in bytes to which logical blocks shall be aligned.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: 65535 (Type:
        Min-Value: 0 (Type:
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_770</srcid><srcstatus/><internalId>784</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>81</internalId></specobject>
    <specobject>
      <id>Fee.ECUC_Fee_00117</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        Name: FeeBlockOverhead
        Parameter Type: Integer
        Parent Containers: FeePublishedInformation,
        Description: Management overhead per logical block in bytes.
        Introduction: Note: If the management overhead depends on the block size or block location a 
        formula has to be provided that allows the configurator to calculate the management overhead 
        correctly.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PUBLISHED-INFORMATION, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: 65535 (Type:
        Min-Value: 0 (Type:
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_1729</srcid><srcstatus/><internalId>812</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>82</internalId></specobject>
    <specobject>
      <id>Fee.ECUC_Fee_00118</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        Name: FeePageOverhead
        Parameter Type: Integer
        Parent Containers: FeePublishedInformation,
        Description: Management overhead per page in bytes.
        Introduction: Note: If the management overhead depends on the block size or block location a 
        formula has to be provided that allows the configurator to calculate the management overhead 
        correctly.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PUBLISHED-INFORMATION, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: 65535 (Type:
        Min-Value: 0 (Type:
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_1805</srcid><srcstatus/><internalId>814</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>83</internalId></specobject>
    <specobject>
      <id>Fee.ECUC_Fee_00119</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        Name: FeeSetModeSupported
        Parameter Type: Boolean
        Parent Containers: FeeGeneral,
        Description: Compiler switch to enable/disable the 'SetMode' functionality of the FEE module. 
        Tags: atp.Status=obsolete
        Introduction: TRUE: SetMode functionality supported / code present, FALSE: SetMode 
        functionality not supported / code not present. Note: This configuration setting has to be 
        consistent with that of all underlying flash device drivers (configuration parameter 
        FlsSetModeApi). This element is obsolete and will be removed in a future revision.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_700</srcid><srcstatus/><internalId>782</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>84</internalId></specobject>
    <specobject>
      <id>Fee.ECUC_Fee_00148</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        Name: FeeBlockSize
        Parameter Type: Integer
        Parent Containers: FeeBlockConfiguration,
        Description: Size of a logical block in bytes.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: 65535 (Type:
        Min-Value: 1 (Type:
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_122</srcid><srcstatus/><internalId>764</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>85</internalId></specobject>
    <specobject>
      <id>Fee.ECUC_Fee_00149</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        Name: FeeDeviceIndex
        Parameter Type: Reference
        Parent Containers: FeeBlockConfiguration,
        Description: Reference to the device this block is stored in. Tags: atp.Status=obsolete
        Introduction: This reference is mutually exclusicve to FeeMemAccAddressArea. This element is 
        obsolete and will be removed in a future revision.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: false
        Post-Build-Variant-Value: false
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Destination: /AUTOSAR/EcucDefs/Fls/FlsGeneral
        Destination type: ECUC-PARAM-CONF-CONTAINER-DEF
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_221</srcid><srcstatus/><internalId>768</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>86</internalId></specobject>
    <specobject>
      <id>Fee.ECUC_Fee_00150</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        Name: FeeBlockNumber
        Parameter Type: Integer
        Parent Containers: FeeBlockConfiguration,
        Description: Block identifier (handle)
        Introduction: 0x0000 and 0xFFFF shall not be used for block numbers (see FEE006). 
        Range: min = 2^NVM_DATASET_SELECTION_BITS max = 0xFFFF -2^NVM_DATASET_SELECTION_BITS 
        Note: Depending on the number of bits set aside for dataset selection several other block numbers shall also be left 
        out to ease implementation.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: true
        Max-Value: 65534 (Type:
        Min-Value: 1 (Type:
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_74</srcid><srcstatus/><internalId>762</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_20000</srcid><srcstatus/><internalId>973</internalId></linkedfrom><linkedfrom><srcid>TS_FEE_NonLegSymbolicNames</srcid><srcstatus/><internalId>985</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>87</internalId></specobject>
    <specobject>
      <id>Fee.ECUC_Fee_00151</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        Name: FeeImmediateData
        Parameter Type: Boolean
        Parent Containers: FeeBlockConfiguration,
        Description: Marker for high priority data.
        Introduction: true: Block contains immediate data. 
        false: Block does not contain immediate data.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_155</srcid><srcstatus/><internalId>765</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>88</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00005</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        Each configured logical block shall take up an integer multiple of the configured virtual page 
        size (see also Chapter [REF] configuration parameter FeeVirtualPageSize)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/src/Fee_Cfg.c_184</srcid><srcstatus/><internalId>370</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>89</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00006</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        The block numbers 0x0000 and 0xFFFF shall not be configurable for a logical block.
      </description>
      <comment>
        review the template code
        there shall be a specific check to ensure that the configured
        block numbers should not include 0x0000 and 0xFFFF.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_109</srcid><srcstatus/><internalId>763</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>90</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00007</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        Depending on the implementation of the FEE module and the exact address format used, the 
        functions of the FEE module shall combine the 16bit block number and 16bit address offset to 
        derive the physical flash address needed for the underlying flash driver.
      </description>
      <comment>
        this is implicitly covered when API functions using
        block number and offset are covered.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Jobs.c_397</srcid><srcstatus/><internalId>712</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>91</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00009</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        Blocks containing immediate data have to be written instantaneously, i.e. the FEE module has to 
        ensure that it can write such blocks without the need to erase the corresponding memory area (e.
        g. by using pre-erased memory) and that the write request is not delayed by currently running 
        module internal management operations.
      </description>
      <comment>
        This requirement is not applicable
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_886</srcid><srcstatus/><internalId>628</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_1423</srcid><srcstatus/><internalId>671</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_1655</srcid><srcstatus/><internalId>681</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Sections.c_560</srcid><srcstatus/><internalId>737</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Sections.c_578</srcid><srcstatus/><internalId>740</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_1219</srcid><srcstatus/><internalId>796</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_AbortErase_DuringSwitch</srcid><srcstatus/><internalId>1019</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_AbortErase_HighPrioritySwitch</srcid><srcstatus/><internalId>1020</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_AbortErase_NormalStartup2</srcid><srcstatus/><internalId>1021</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_AbortErase_HighestPrioStartup2</srcid><srcstatus/><internalId>1022</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_AbortErase_LeadsToHPSwitch</srcid><srcstatus/><internalId>1024</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_AbortErase_LeadsToHPStartup2</srcid><srcstatus/><internalId>1025</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_AbortErase_DuringSwitch_i4s</srcid><srcstatus/><internalId>1112</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Imm_HPrioSwitchOk</srcid><srcstatus/><internalId>1251</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Fee.ImmediateData</srcid><srcstatus/><internalId>351</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>92</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00010</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        Type of error | Related error code | Error value 
        API service called when module was not initialized | FEE_E_UNINITFee.FEE_E_UNINIT | 0x01 
        API service called with invalid block number | FEE_E_INVALID_BLOCK_NOFee.FEE_E_INVALID_BLOCK_NO 
        0x02 
        API service called with invalid block offset | FEE_E_INVALID_BLOCK_OFSFee.
        FEE_E_INVALID_BLOCK_OFS | 0x03 
        API service called with invalid data pointer | FEE_E_PARAM_POINTERFee.FEE_E_PARAM_POINTER | 
        0x04 
        API service called with invalid length information | FEE_E_INVALID_BLOCK_LENFee.
        FEE_E_INVALID_BLOCK_LEN | 0x05 
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Fee.Fee_InvalildDataPointer</srcid><srcstatus/><internalId>342</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>93</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00016</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        The types mentioned in SWS_Fee_00084 shall not be changed or extended for a specific FEE module 
        or hardware platform.
      </description>
      <comment>
        This requirement is informational only.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>94</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00021</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        The function Fee_Read shall take the block start address and offset and calculate the 
        corresponding memory read address.
      </description>
      <comment>
        This requirement is not applicable.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>95</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00022</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        If the current module status is MEMIF_IDLE or if the current module status is MEMIF_BUSY 
        INTERNAL, the function Fee_Read shall accept the read request, copy the given / computed 
        parameters to module internal variables, initiate a read job, set the FEE module status to 
        MEMIF_BUSY, set the job result to MEMIF_JOB_PENDING and return with E_OK.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee.c.m4_409</srcid><srcstatus/><internalId>401</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_30002</srcid><srcstatus/><internalId>1216</internalId></linkedfrom><linkedfrom><srcid>TS_FEE_30003</srcid><srcstatus/><internalId>1217</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>96</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00023</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        The function Fee_MainFunction shall check the consistency of the logical block being read 
        before notifying the caller. If an inconsistency of the read data is detected or if the 
        requested block can't be found, the function Fee_MainFunction shall set the job result to 
        MEMIF_BLOCK_INCONSISTENT and call the error notification routine of the upper layer if 
        configured.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_30002</srcid><srcstatus/><internalId>1216</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>97</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00024</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        The function Fee_Write shall take the block start address and calculate the corresponding 
        memory write address. The block address offset shall be fixed to zero.
      </description>
      <comment>
        This requirement is not applicable.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>98</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00025</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        If the current module status is MEMIF_IDLE or if the current module status is MEMIF_BUSY 
        INTERNAL, the function Fee_Write shall accept the write request, copy the given / computed 
        parameters to module internal variables, initiate a write job, set the FEE module status to 
        MEMIF_BUSY, set the job result to MEMIF_JOB_PENDING and return with E_OK.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee.c.m4_567</srcid><srcstatus/><internalId>408</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Extra.c_278</srcid><srcstatus/><internalId>453</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_30030</srcid><srcstatus/><internalId>1218</internalId></linkedfrom><linkedfrom><srcid>TS_FEE_30054</srcid><srcstatus/><internalId>1241</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>99</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00026</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        The FEE module shall execute the write operation asynchronously within the FEE module's main 
        function.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_30030</srcid><srcstatus/><internalId>1218</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>100</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00034</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        The function Fee_GetStatus shall return MEMIF_UNINIT if the module has not (yet) been 
        initialized.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_30001</srcid><srcstatus/><internalId>1213</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>101</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00035</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        The function Fee_GetJobResult shall return MEMIF_JOB_OK if the last job has been finished 
        successfully.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_TestJobResults</srcid><srcstatus/><internalId>1225</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>102</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00036</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        The function Fee_InvalidateBlock shall take the block number and calculate the corresponding 
        memory block address.
      </description>
      <comment>
        This requirement is not applicable.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>103</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00037</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        The function Fee_InvalidateBlock shall invalidate the requested block &lt;BlockNumber&gt; by calling 
        the erase function of the underlying device driver and / or by changing some module internal 
        management information accordingly.
      </description>
      <comment>
        This requirement is not applicable.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>104</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00049</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        The FEE module shall manage for each block the information, whether this block is correct (i.e.
        not corrupted") from the point of view of the FEE module or not. This information shall only 
        concern the internal handling of the block, not the block's contents.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Fee.Dsn.Initialization.Startup1.FillCacheWithBlockInfos</srcid><srcstatus/><internalId>840</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Initialization.Startup1.BlockInfoFound</srcid><srcstatus/><internalId>844</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Initialization.Startup1.BlockInconsistent.01</srcid><srcstatus/><internalId>845</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Initialization.Startup1.BlockInconsistent.02</srcid><srcstatus/><internalId>846</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Initialization.Startup1.BlocksSearchStop.SwNotConfigBlocksOFF</srcid><srcstatus/><internalId>847</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Initialization.Startup1.BlockInfoCacheIfNewer</srcid><srcstatus/><internalId>849</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>105</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00052</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        The function Fee_JobEndNotification shall perform any necessary block management operations and 
        subsequently call the job end notification routine of the upper layer module if configured.
      </description>
      <comment>
        To make the module less complex and the interrupt mode don't provide
        too much gain in performance the callback routine of the upper layer module
        shall not be called from Fee_JobEndNotification. It shall be called
        by Fee_MainFunction().
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Fee.Callback.LimitUse</srcid><srcstatus/><internalId>202</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>106</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00054</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        The function Fee_JobErrorNotification shall perform any necessary block management and error 
        handling operations and subsequently call the job error notification routine of the upper layer 
        module if configured.
      </description>
      <comment>
        To make the module less complex and the interrupt mode don't provide
        too much gain in performance the callback routine of the upper layer module
        shall not be called from Fee_JobErrorNotification. It shall be called
        by Fee_MainFunction().
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Fee.Callback.LimitUse</srcid><srcstatus/><internalId>202</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>107</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00055</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        The FEE module shall call the function defined in the configuration parameter 
        FeeNvmJobEndNotification upon successful end of an asynchronous operation and after performing 
        all necessary internal management operations:
        Read job finished &amp; OK
        Write job finished &amp; OK &amp; block marked as valid
        Erase job for immediate data finished &amp; OK (see SWS_Fee_00067)
        Invalidation of memory block finished &amp; OK
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_30003</srcid><srcstatus/><internalId>1217</internalId></linkedfrom><linkedfrom><srcid>TS_FEE_30030</srcid><srcstatus/><internalId>1218</internalId></linkedfrom><linkedfrom><srcid>TS_FEE_30004</srcid><srcstatus/><internalId>1219</internalId></linkedfrom><linkedfrom><srcid>TS_FEE_30009</srcid><srcstatus/><internalId>1222</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>108</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00056</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        The FEE module shall call the function defined in the configuration parameter 
        FeeNvmJobErrorNotification upon failure of an asynchronous operation and after performing all 
        necessary internal management and error handling operations:
        Read job finished &amp; failed (e.g. block invalid or inconsistent)
        Write job finished &amp; failed &amp; block marked as invalid
        Erase job for immediate data finished &amp; failed (see SWS_Fee_00067)
        Invalidation of memory block finished &amp; failed
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_30002</srcid><srcstatus/><internalId>1216</internalId></linkedfrom><linkedfrom><srcid>TS_FEE_30004</srcid><srcstatus/><internalId>1219</internalId></linkedfrom><linkedfrom><srcid>TS_FEE_30007</srcid><srcstatus/><internalId>1220</internalId></linkedfrom><linkedfrom><srcid>TS_FEE_30008</srcid><srcstatus/><internalId>1221</internalId></linkedfrom><linkedfrom><srcid>TS_FEE_30011</srcid><srcstatus/><internalId>1242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>109</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00057</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        The function Fee_MainFunction shall asynchronously handle the read / write / erase / invalidate 
        jobs requested by the upper layer and internal management operations.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee.c.m4_992</srcid><srcstatus/><internalId>432</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>110</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00066</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        The function Fee_EraseImmediateBlock shall take the block number and calculate the 
        corresponding memory block address.
      </description>
      <comment>
        This requirement is not applicable since the current implementation of Fee does'nt
        support this.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>111</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00067</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        The function Fee_EraseImmediateBlock shall ensure that the FEE module can write immediate data.
        Whether this involves physically erasing a memory area and therefore calling the erase function 
        of the underlying driver depends on the implementation of the module.
      </description>
      <comment>
        This requirement is not applicable.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>112</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00068</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        If development error detection is enabled for the module: the function Fee_EraseImmediateBlock 
        shall check whether the addressed logical block is configured as containing immediate data (
        FeeImmediateData == TRUE). If not, the function Fee_EraseImmediateBlock shall raise the 
        development error FEE_E_INVALID_BLOCK_NO.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_30032</srcid><srcstatus/><internalId>1234</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>113</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00071</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        Logical blocks must not overlap each other and must not be contained within one another.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/src/Fee_Cfg.c_32</srcid><srcstatus/><internalId>366</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>114</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00073</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        The FEE module shall execute the read operation asynchronously within the FEE module's main 
        function.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_30002</srcid><srcstatus/><internalId>1216</internalId></linkedfrom><linkedfrom><srcid>TS_FEE_30003</srcid><srcstatus/><internalId>1217</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Fee.Dsn.Read.Behaviour.IDLE</srcid><srcstatus/><internalId>871</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Read.Behaviour.BlockInvalid</srcid><srcstatus/><internalId>873</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Read.Behaviour.BlockInconsistent</srcid><srcstatus/><internalId>874</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>115</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00074</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        The function Fee_GetStatus shall return MEMIF_BUSY_INTERNAL, if an internal management 
        operation is currently ongoing.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee.c.m4_668</srcid><srcstatus/><internalId>416</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>116</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00075</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        The function Fee_MainFunction shall check, whether the block requested for reading has been 
        invalidated by the upper layer module. If so, the function Fee_MainFunction shall set the job 
        result to MEMIF_BLOCK_INVALID and call the error notification routine of the upper layer if 
        configured.
      </description>
      <comment>
        This requirement is not applicable.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>117</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00076</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        The configuration of the Fee module shall be such that the virtual page size (defined in 
        FeeVirtualPageSize) is an integer multiple of the physical page size, i.e. it is not allowed to 
        configure a smaller virtual page than the actual physical page size.
      </description>
      <comment>
        review the template code there shall be a specific check to ensure that the configured
        virtual page size is a multiple of the physical page size as published
        by Fee.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_799</srcid><srcstatus/><internalId>785</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>118</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00080</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        If the current module status is MEMIF_BUSY (i.e. the request to cancel a pending job is 
        accepted by the function Fee_Cancel), the function Fee_Cancel shall call the cancel function of 
        the underlying flash driver.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Fee_FEE_080_1</srcid><srcstatus/><internalId>204</internalId></linkedfrom><linkedfrom><srcid>Fee_FEE_080_2</srcid><srcstatus/><internalId>205</internalId></linkedfrom><linkedfrom><srcid>Fee_FEE_080_3</srcid><srcstatus/><internalId>206</internalId></linkedfrom><linkedfrom><srcid>Fee_FEE_080_4</srcid><srcstatus/><internalId>207</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>119</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00081</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        If the current module status is MEMIF_BUSY (i.e. the request to cancel a pending job is 
        accepted by the function Fee_Cancel), the function Fee_Cancel shall reset the FEE module's 
        internal variables to make the module ready for a new job request from the upper layer, i.e. it 
        shall set the module status to MEMIF_IDLE.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_30007</srcid><srcstatus/><internalId>1220</internalId></linkedfrom><linkedfrom><srcid>TS_FEE_30008</srcid><srcstatus/><internalId>1221</internalId></linkedfrom><linkedfrom><srcid>TS_FEE_30011</srcid><srcstatus/><internalId>1242</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Fee.Dsn.Startup1.Cancel.HasRequest</srcid><srcstatus/><internalId>938</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Startup2.Cancel.HasRequest.Pending</srcid><srcstatus/><internalId>940</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Startup2.Cancel.HasRequest.Ongoing</srcid><srcstatus/><internalId>941</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Normal.Cancel.HasRequest.Pending</srcid><srcstatus/><internalId>942</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.SectonSwitch.Cancel.HasRequest.Pending</srcid><srcstatus/><internalId>944</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.SectonSwitch.Cancel.HasRequest.Ongoing</srcid><srcstatus/><internalId>945</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>120</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00084</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        Module | Header File | Imported Type 
        MemAcc | MemAcc.h | MemAcc_AddressAreaIdType (draft)
        MemAcc.h | MemAcc_AddressType (draft)
        MemAcc.h | MemAcc_DataType (draft)
        MemAcc.h | MemAcc_JobResultType (draft)
        MemAcc.h | MemAcc_LengthType (draft)
        MemIf | MemIf.h | MemIf_JobResultType (obsolete)
        MemIf.h | MemIf_ModeType (obsolete)
        MemIf.h | MemIf_StatusType 
        Std | Std_Types.h | Std_ReturnType 
        Std_Types.h | Std_VersionInfoType 
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/include/Fee_Cfg.h.m4_9</srcid><srcstatus/><internalId>352</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/generate/include/Fee_Cfg.h.m4_14</srcid><srcstatus/><internalId>353</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/generate/src/Fee_Cfg.c_4</srcid><srcstatus/><internalId>364</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/include/Fee.h.m4_6</srcid><srcstatus/><internalId>371</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/include/Fee_Initialization.h_21</srcid><srcstatus/><internalId>375</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/include/Fee_Internal.h.m4_22</srcid><srcstatus/><internalId>376</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/include/Fee_Jobs.h_21</srcid><srcstatus/><internalId>382</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/include/Fee_Sections.h_21</srcid><srcstatus/><internalId>383</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/include/Fee_Sections.h_23</srcid><srcstatus/><internalId>384</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/include/Fee_SectionsSwitch.h_21</srcid><srcstatus/><internalId>385</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/include/Fee_SectionsSwitch.h_23</srcid><srcstatus/><internalId>386</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations><ruleid>WRN.impl.needscoverage.count</ruleid></oreqmViolations><covstatus>covered</covstatus><internalId>121</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00085</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>3</version>
      <description>
        Service Name | Fee_Init 
        Syntax 
        void Fee_Init (const Fee_ConfigType* ConfigPtr)
        Service ID [hex] | 0x00 
        Sync/Async | Asynchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | ConfigPtr | Pointer to the selected configuration set.
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | Service to initialize the FEE module.
        Available via | Fee.h 
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>doc/public/changelog/Deviations.xml_287</srcid><srcstatus/><internalId>344</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>122</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00086</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        Service Name | Fee_SetMode (obsolete)
        Syntax 
        void Fee_SetMode (MemIf_ModeType Mode)
        Service ID [hex] | 0x01 
        Sync/Async | Asynchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | Mode | Desired mode for the underlying flash driver 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | Function to switch the mode of the underlying Flash Driver Tags: atp.Status=
        obsolete 
        Available via | Fee.h 
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_30014</srcid><srcstatus/><internalId>1223</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>123</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00087</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        Service Name | Fee_Read 
        Syntax 
        Std_ReturnType Fee_Read (uint16 BlockNumber, uint16 BlockOffset, uint8* DataBufferPtr, uint16 
        Length)
        Service ID [hex] | 0x02 
        Sync/Async | Asynchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | BlockNumber | Number of logical block, also denoting start address of that 
        block in flash memory.
        BlockOffset | Read address offset inside the block 
        Length | Number of bytes to read 
        Parameters (inout) | None 
        Parameters (out) | DataBufferPtr | Pointer to data buffer 
        Return value | Std_ReturnType | E_OK: The requested job has been accepted by the module.
        E_NOT_OK: The requested job has not been accepted by the module.
        Description | Service to initiate a read job.
        Available via | Fee.h 
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_30002</srcid><srcstatus/><internalId>1216</internalId></linkedfrom><linkedfrom><srcid>TS_FEE_30003</srcid><srcstatus/><internalId>1217</internalId></linkedfrom><linkedfrom><srcid>TS_FEE_30015</srcid><srcstatus/><internalId>1224</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>124</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00088</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        Service Name | Fee_Write 
        Syntax 
        Std_ReturnType Fee_Write (uint16 BlockNumber, const uint8* DataBufferPtr)
        Service ID [hex] | 0x03 
        Sync/Async | Asynchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | BlockNumber | Number of logical block, also denoting start address of that 
        block in EEPROM.
        DataBufferPtr | Pointer to data buffer 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | Std_ReturnType | E_OK: The requested job has been accepted by the module.
        E_NOT_OK: The requested job has not been accepted by the module.
        Description | Service to initiate a write job.
        Available via | Fee.h 
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Fee.Fee_Write.DataBufferPtr.type</srcid><srcstatus/><internalId>209</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>125</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00089</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        Service Name | Fee_Cancel 
        Syntax 
        void Fee_Cancel (void)
        Service ID [hex] | 0x04 
        Sync/Async | Asynchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | None 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | Service to call the cancel function of the underlying flash driver.
        Available via | Fee.h 
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_30007</srcid><srcstatus/><internalId>1220</internalId></linkedfrom><linkedfrom><srcid>TS_FEE_30008</srcid><srcstatus/><internalId>1221</internalId></linkedfrom><linkedfrom><srcid>TS_FEE_30011</srcid><srcstatus/><internalId>1242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>126</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00090</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        Service Name | Fee_GetStatus 
        Syntax 
        MemIf_StatusType Fee_GetStatus (void)
        Service ID [hex] | 0x05 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | None 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | MemIf_StatusType | MEMIF_UNINIT: The FEE module has not been initialized.
        MEMIF_IDLE: The FEE module is currently idle.MEMIF_BUSY: The FEE module is currently busy.
        MEMIF_BUSY_INTERNAL: The FEE module is busy with internal management operations.
        Description | Service to return the status.
        Available via | Fee.h 
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_TestStatusUninit</srcid><srcstatus/><internalId>1214</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>127</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00091</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        Service Name | Fee_GetJobResult 
        Syntax 
        MemIf_JobResultType Fee_GetJobResult (void)
        Service ID [hex] | 0x06 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | None 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | MemIf_JobResultType | MEMIF_JOB_OK: The last job has been finished successfully.
        MEMIF_JOB_PENDING: The last job is waiting for execution or currently being executed.
        MEMIF_JOB_CANCELED: The last job has been canceled (which means it failed).MEMIF_JOB_FAILED: 
        The last job has not been finished successfully (it failed).MEMIF_BLOCK_INCONSISTENT: The 
        requested block is inconsistent, it may contain corrupted data.MEMIF_BLOCK_INVALID: The 
        requested block has been invalidated, the requested read operation can not be performed.
        Description | Service to query the result of the last accepted job issued by the upper layer 
        software.
        Available via | Fee.h 
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_TestJobResults</srcid><srcstatus/><internalId>1225</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>128</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00092</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        Service Name | Fee_InvalidateBlock 
        Syntax 
        Std_ReturnType Fee_InvalidateBlock (uint16 BlockNumber)
        Service ID [hex] | 0x07 
        Sync/Async | Asynchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | BlockNumber | Number of logical block, also denoting start address of that 
        block in flash memory.
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | Std_ReturnType | E_OK: The requested job has been accepted by the module.
        E_NOT_OK - only if DET is enabled: The requested job has not been accepted by the module.
        Description | Service to invalidate a logical block.
        Available via | Fee.h 
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_30004</srcid><srcstatus/><internalId>1219</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>129</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00093</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        Service Name | Fee_GetVersionInfo 
        Syntax 
        void Fee_GetVersionInfo (Std_VersionInfoType* VersionInfoPtr)
        Service ID [hex] | 0x08 
        Sync/Async | Synchronous 
        Reentrancy | Reentrant 
        Parameters (in) | None 
        Parameters (inout) | None 
        Parameters (out) | VersionInfoPtr | Pointer to standard version information structure.
        Return value | None 
        Description | Service to return the version information of the FEE module.
        Available via | Fee.h 
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_30031</srcid><srcstatus/><internalId>1212</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>130</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00094</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        Service Name | Fee_EraseImmediateBlock 
        Syntax 
        Std_ReturnType Fee_EraseImmediateBlock (uint16 BlockNumber)
        Service ID [hex] | 0x09 
        Sync/Async | Asynchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | BlockNumber | Number of logical block, also denoting start address of that 
        block in EEPROM.
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | Std_ReturnType | E_OK: The requested job has been accepted by the module.
        E_NOT_OK - only if DET is enabled: The requested job has not been accepted by the module.
        Description | Service to erase a logical block.
        Available via | Fee.h 
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_30009</srcid><srcstatus/><internalId>1222</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>131</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00095</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        Service Name | Fee_JobEndNotification 
        Syntax 
        void Fee_JobEndNotification (void)
        Service ID [hex] | 0x10 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | None 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | Service to report to this module the successful end of an asynchronous operation.
        Available via | Fee.h 
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_JobEndNotification</srcid><srcstatus/><internalId>1226</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>132</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00096</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        Service Name | Fee_JobErrorNotification (obsolete)
        Syntax 
        void Fee_JobErrorNotification (void)
        Service ID [hex] | 0x11 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | None 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | Service to report to this module the failure of an asynchronous operation. Tags: 
        atp.Status=obsolete 
        Available via | Fee.h 
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_JobErrorNotification</srcid><srcstatus/><internalId>1227</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>133</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00097</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        Service Name | Fee_MainFunction 
        Syntax 
        void Fee_MainFunction (void)
        Service ID [hex] | 0x12 
        Description | Service to handle the requested read / write / erase jobs and the internal 
        management operations.
        Available via | SchM_Fee.h 
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee.c.m4_974</srcid><srcstatus/><internalId>430</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>134</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00100</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        Only those bits of the 16bit block number, that do not denote a specific dataset or redundant 
        copy shall be used for address calculation.
      </description>
      <comment>
        This requirement is not applicable since each data set is considered as separate block
        in current FEE implementation.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>135</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00102</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        The configuration of the FEE module shall define the expected number of erase/write cycles for 
        each logical block in the configuration parameter FeeNumberOfWriteCycles.
      </description>
      <comment>
        VSMD check, review the module template code and ensure that this parameter is used at
        least once.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>lim</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>lim.Fee.EB_INTREQ_Fee_0015</srcid><srcstatus/><internalId>14</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_190</srcid><srcstatus/><internalId>766</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>136</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00103</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        If the underlying flash device or device driver does not provide at least the configured number 
        of erase/write cycles per physical memory cell, the FEE module shall provide mechanisms to 
        spread the write access such that the physical device is not overstressed. This shall also 
        apply to all management data used internally by the FEE module.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/src/Fee_Cfg.c_32</srcid><srcstatus/><internalId>366</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>137</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00104</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        API Function | Header File | Description 
        Det_ReportError | Det.h | Service to report development errors.
        MemAcc_BlankCheck (draft) | MemAcc.h | Checks if the passed address space is blank, i.e. erased 
        and writeable. The result of this service can be retrieved using the MemAcc_GetJobResult API. 
        If the address area defined by targetAddress and length is blank, the result is MEMACC_MEM_OK, 
        otherwise the result is MEMACC_MEM_INCONSISTENT. Tags: atp.Status=draft 
      </description>
      <comment>
        This requirement is not applicable since it is the specification of DET interface.
        FEE ensures that this interface function is being called and FEE is not responsible
        for implementation of this function.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>138</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00105</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        API Function | Header File | Description 
        Det_ReportRuntimeError | Det.h | Service to report runtime errors. If a callout has been 
        configured then this callout shall be called.
        MemAcc_Cancel (draft) | MemAcc.h | Triggers a cancel operation of the pending job for the 
        address area referenced by the addressAreaId. Cancelling affects only jobs in pending state. 
        For any other states, the request will be ignored. Tags: atp.Status=draft 
        MemAcc_Compare (draft) | MemAcc.h | Triggers a job to compare the passed data to the memory 
        content of the provided address area. The job terminates, if all bytes matched or a difference 
        was detected. The result of this service can be retrieved using the MemAcc_GetJobResult() API. 
        If the compare operation determined a mismatch, the result code is MEMACC_MEM_INCONSISTENT. 
        Tags: atp.Status=draft 
        MemAcc_Erase (draft) | MemAcc.h | Triggers an erase job of the given area. Triggers an erase 
        job of the given area defined by targetAddress and length. The result of this service can be 
        retrieved using the Mem_GetJobResult API. If the erase operation was successful, the result of 
        the job is MEM_JOB_OK. If the erase operation failed, e.g. due to a hardware issue, the result 
        of the job is MEM_JOB_FAILED. Tags: atp.Status=draft 
        MemAcc_GetJobResult (draft) | MemAcc.h | Returns the consolidated job result of the address 
        area referenced by addressAreaId. Tags: atp.Status=draft 
        MemAcc_Read (draft) | MemAcc.h | Triggers a read job to copy data from the source address into 
        the referenced destination data buffer. The result of this service can be retrieved using the 
        MemAcc_GetJobResult API. If the read operation was successful, the result of the job is 
        MEMACC_MEM_OK. If the read operation failed, the result of the job is either MEMACC_MEM_FAILED 
        in case of a general error or MEMACC_MEM_ECC_CORRECTED/MEMACC_MEM_ECC_UNCORRECTED in case of a 
        correctable/uncorrectable ECC error. Tags: atp.Status=draft 
        MemAcc_Write (draft) | MemAcc.h | Triggers a write job to store the passed data to the provided 
        address area with given address and length. The result of this service can be retrieved using 
        the MemAcc_GetJobResult API. If the write operation was successful, the job result is 
        MEMACC_MEM_OK. If there was an issue writing the data, the result is MEMACC_MEM_FAILED. Tags: 
        atp.Status=draft 
      </description>
      <comment>
        This requirement is not applicable since this is the spec of mandatory interfaces
        needed from flash driver to achieve core functionality.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>139</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00121</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        If development error detection is enabled for the module: the function Fee_SetMode shall check 
        if the module status is MEMIF_UNINIT. If this is the case, the function Fee_SetMode shall raise 
        the development error FEE_E_UNINIT.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_DetFeeUninit</srcid><srcstatus/><internalId>1228</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>140</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00122</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        If development error detection is enabled for the module: the function Fee_Read shall check if 
        the module state is MEMIF_UNINIT. If this is the case, the function Fee_Read shall raise the 
        development error FEE_E_UNINIT.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_DetFeeUninit</srcid><srcstatus/><internalId>1228</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>141</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00123</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        If development error detection is enabled for the module: the function Fee_Write shall check if 
        the module state is MEMIF_UNINIT. If this is the case, the function Fee_Write shall raise the 
        development error FEE_E_UNINIT.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_DetFeeUninit</srcid><srcstatus/><internalId>1228</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>142</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00124</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        If development error detection is enabled for the module: the function Fee_Cancel shall check 
        if the module state is MEMIF_UNINIT. If this is the case the function Fee_Cancel shall raise 
        the development error FEE_E_UNINIT.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_DetFeeUninit</srcid><srcstatus/><internalId>1228</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>143</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00125</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        If development error detection is enabled for the module: the function Fee_GetJobResult shall 
        check if the module state is MEMIF_UNINIT. If this is the case, the function Fee_GetJobResult 
        shall raise the development error FEE_E_UNINIT.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_DetFeeUninit</srcid><srcstatus/><internalId>1228</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>144</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00126</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        If development error detection is enabled for the module: the function Fee_InvalidateBlock 
        shall check if the module status is MEMIF_UNINIT. If this is the case, the function 
        Fee_InvalidateBlock shall raise the development error FEE_E_UNINIT.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee.c.m4_769</srcid><srcstatus/><internalId>420</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_DetFeeUninit</srcid><srcstatus/><internalId>1228</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>145</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00127</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        If development error detection is enabled for the module: the function Fee_EraseImmediateBlock 
        shall check if the module state is MEMIF_UNINIT. If this is the case, the function 
        Fee_EraseImmediateBlock shall raise the development error FEE_E_UNINIT.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee.c.m4_885</srcid><srcstatus/><internalId>426</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_DetFeeUninit</srcid><srcstatus/><internalId>1228</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>146</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00128</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        The function Fee_GetStatus shall return MEMIF_IDLE if the module is neither processing a 
        request from the upper layer nor is it doing an internal management operation.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Fee.Dsn.Idle</srcid><srcstatus/><internalId>862</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_TestStatusResults</srcid><srcstatus/><internalId>1215</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>147</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00129</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        The function Fee_GetStatus shall return MEMIF_BUSY if it is currently processing a request from 
        the upper layer.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_TestStatusResults</srcid><srcstatus/><internalId>1215</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>148</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00133</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        The function Fee_Read shall check if the module state is MEMIF_BUSY. If this is the case, the 
        function Fee_Read shall reject the read request, raise the runtime error FEE_E_BUSY and return 
        with E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Fee.Fee_RuntimeErrors</srcid><srcstatus/><internalId>338</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>149</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00134</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        If development error detection is enabled for the module: the function Fee_Read shall check 
        that the given block number is valid (i.e. it has been configured). If this is not the case, 
        the function Fee_Read shall raise the development error FEE_E_INVALID_BLOCK_NO.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_30032</srcid><srcstatus/><internalId>1234</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>150</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00135</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        If development error detection is enabled for the module: the function Fee_Read shall check 
        that the given block offset is valid (i.e. that it is less than the block length configured for 
        this block). If this is not the case, the function Fee_Read shall raise the development error 
        FEE_E_INVALID_BLOCK_OFS.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_DetInvalidBlockOffset</srcid><srcstatus/><internalId>1230</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>151</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00136</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        If development error detection is enabled for the module: the function Fee_Read shall check 
        that the given data pointer is valid (i.e. that it is not NULL). If this is not the case, the 
        function Fee_Read shall raise the development error FEE_E_PARAM_POINTER.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>doc/public/changelog/Deviations.xml_251</srcid><srcstatus/><internalId>339</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>152</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00137</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        If development error detection is enabled for the module: the function Fee_Read shall check 
        that the given length information is valid, i.e. that the requested length information plus the 
        block offset do not exceed the block end address (block start address plus configured block 
        length). If this is not the case, the function Fee_Read shall raise the development error 
        FEE_E_INVALID_BLOCK_LEN.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_DetInvalidBlockLen</srcid><srcstatus/><internalId>1231</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>153</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00138</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        If development error detection is enabled for the module: the function Fee_Write shall check 
        that the given block number is valid (i.e. it has been configured). If this is not the case, 
        the function Fee_Write shall raise the development error FEE_E_INVALID_BLOCK_NO.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_DetInternalBusy</srcid><srcstatus/><internalId>1233</internalId></linkedfrom><linkedfrom><srcid>TS_FEE_30032</srcid><srcstatus/><internalId>1234</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>154</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00139</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        If development error detection is enabled for the module: the function Fee_Write shall check 
        that the given data pointer is valid (i.e. that it is not NULL). If this is not the case, the 
        function Fee_Write shall raise the development error FEE_E_PARAM_POINTER.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>doc/public/changelog/Deviations.xml_252</srcid><srcstatus/><internalId>340</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>155</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00140</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        If development error detection is enabled for the module: the function Fee_InvalidateBlock 
        shall check that the given block number is valid (i.e. it has been configured). If this is not 
        the case, the function Fee_InvalidateBlock shall raise the development error 
        FEE_E_INVALID_BLOCK_NO.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_30032</srcid><srcstatus/><internalId>1234</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>156</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00141</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        If development error detection is enabled for the module: the function Fee_EraseImmediateBlock 
        shall check that the given block number is valid (i.e. it has been configured). If this is not 
        the case, the function Fee_EraseImmediateBlock shall raise the development error 
        FEE_E_INVALID_BLOCK_NO.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_30032</srcid><srcstatus/><internalId>1234</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>157</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00142</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        If the job result is currently MEMIF_JOB_PENDING, the function Fee_JobEndNotification shall set 
        the job result to MEMIF_JOB_OK, else it shall leave the job result untouched.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_JobEndNotification</srcid><srcstatus/><internalId>1226</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>158</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00143</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        If the job result is currently MEMIF_JOB_PENDING, the function Fee_JobErrorNotification shall 
        set the job result to MEMIF_JOB_FAILED, else it shall leave the job result untouched.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_JobErrorNotification</srcid><srcstatus/><internalId>1227</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>159</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00144</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        The function Fee_Write shall check if the module state is MEMIF_BUSY. If this is the case, the 
        function Fee_Write shall reject the write request, raise the runtime error FEE_E_BUSY and 
        return with E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>doc/public/changelog/Deviations.xml_233</srcid><srcstatus/><internalId>335</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>160</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00145</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        The function Fee_InvalidateBlock shall check if the module status is MEMIF_BUSY. If this is the 
        case, the function Fee_InvalidateBlock shall reject the request, raise the runtime error 
        FEE_E_BUSY and return with E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>doc/public/changelog/Deviations.xml_234</srcid><srcstatus/><internalId>336</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>161</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00146</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        The function Fee_EraseImmediateBlock shall check if the module state is MEMIF_BUSY. If this is 
        the case, the function Fee_EraseImmediateBlock shall reject the erase request, raise the 
        runtime error FEE_E_BUSY and return with E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>doc/public/changelog/Deviations.xml_235</srcid><srcstatus/><internalId>337</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>162</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00147</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        If development error detection is enabled for the module: the function Fee_GetVersionInfo shall 
        check that the given data pointer is valid (i.e. that it is not NULL). If this is not the case,
        the function Fee_GetVersionInfo shall raise the development error FEE_E_PARAM_POINTER.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>doc/public/changelog/Deviations.xml_253</srcid><srcstatus/><internalId>341</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>163</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00153</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        When a block write operation is started, the FEE module shall mark the corresponding block as "
        corrupted"[1]
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Fee.Fee_BlockDataInterrupted</srcid><srcstatus/><internalId>328</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>164</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00154</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        Upon the successful end of the block write operation, the block shall be marked as "not 
        corrupted" (again)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Jobs.c_559</srcid><srcstatus/><internalId>720</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>165</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00155</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        Only those jobs which have been requested directly by the upper layer shall have influence on 
        the job result returned by the function Fee_GetJobResult. I.e. jobs which are issued by the FEE 
        module itself in the course of internal management operations shall not alter the job result.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_TestJobResults</srcid><srcstatus/><internalId>1225</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>166</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00156</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        The function Fee_GetJobResult shall return MEMIF_JOB_PENDING if the requested job is still 
        waiting for execution or is currently being executed.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_TestJobResults</srcid><srcstatus/><internalId>1225</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>167</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00157</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        The function Fee_GetJobResult shall return MEMIF_JOB_CANCELED if the last job has been canceled 
        by the upper layer.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_TestJobResults</srcid><srcstatus/><internalId>1225</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>168</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00158</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        The function Fee_GetJobResult shall return MEMIF_JOB_FAILED if the last job has failed.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_TestJobResults</srcid><srcstatus/><internalId>1225</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>169</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00159</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        The function Fee_GetJobResult shall return MEMIF_BLOCK_INCONSISTENT if the requested block is 
        found to be inconsistent (see chapter [REF] for details)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_TestJobResults</srcid><srcstatus/><internalId>1225</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>170</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00160</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        The function Fee_GetJobResult shall return MEMIF_BLOCK_INVALID if the requested block has been 
        invalidated by the upper layer.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_TestJobResults</srcid><srcstatus/><internalId>1225</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>171</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00162</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        If a read request is rejected by the function Fee_Read, i.e. requirements SWS_Fee_00122, 
        SWS_Fee_00133, SWS_Fee_00134, SWS_Fee_00135, SWS_Fee_00136 or SWS_Fee_00137 apply, the function 
        Fee_Read shall not change the current module status or job result.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_DetInvalidDataPtr</srcid><srcstatus/><internalId>1229</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>172</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00163</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        If a write request is rejected by the function Fee_Write, i.e. requirements SWS_Fee_00123, 
        SWS_Fee_00144, SWS_Fee_00138 or SWS_Fee_00139 apply, the function Fee_Write shall not change 
        the current module status or job result.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_DetInvalidDataPtr</srcid><srcstatus/><internalId>1229</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>173</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00164</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        If the current module status is not MEMIF_BUSY (i.e. the request to cancel a pending job is 
        rejected by the function Fee_Cancel), the function Fee_Cancel shall not change the current 
        module status or job result.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_30006</srcid><srcstatus/><internalId>1239</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Fee.Dsn.Cancel.Behaviour.NoJobPending</srcid><srcstatus/><internalId>885</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Cancel.Behaviour.InternalOperations</srcid><srcstatus/><internalId>891</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Startup1.Cancel.NoRequest</srcid><srcstatus/><internalId>937</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Startup2.Cancel.NoRequest</srcid><srcstatus/><internalId>939</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>174</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00165</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        If an invalidation request is rejected by the function Fee_InvalidateBlock, i.e. requirements 
        SWS_Fee_00126, SWS_Fee_00140 or SWS_Fee_00145 apply, the function Fee_InvalidateBlock shall not 
        change the current module status or job result.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_DetMemIfBusy</srcid><srcstatus/><internalId>1232</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>175</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00166</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        If a erase request is rejected by the function Fee_EraseImmediateBlock, i.e. requirements 
        SWS_Fee_00068, SWS_Fee_00127, SWS_Fee_00141 or SWS_Fee_00146 apply, the function 
        Fee_EraseImmediateBlock shall not change the current module status or job result.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_DetMemIfBusy</srcid><srcstatus/><internalId>1232</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>176</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00168</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        If initialization is finished within Fee_Init, the function Fee_Init shall set the module state 
        from MEMIF_UNINIT to MEMIF_IDLE once initialization has been successfully finished.
      </description>
      <comment>
        This requirement is not applicable as the initialization is not finished with in Fee_Init.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>177</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00169</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        If the module initialization (started in the function Fee_Init) is completed in the module's 
        main function, the function Fee_MainFunction shall set the module status from MEMIF_UNINIT to 
        MEMIF_IDLE once initialization of the module has been successfully finished.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Fee.Fee_Initfinished</srcid><srcstatus/><internalId>343</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>178</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00170</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        The function Fee_SetMode shall check if the module state is MEMIF_BUSY. If this is the case, 
        the function Fee_SetMode shall raise the runtime error FEE_E_BUSY and return to the caller 
        without executing the mode switch.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>doc/public/changelog/Deviations.xml_232</srcid><srcstatus/><internalId>334</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>179</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00172</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        If the current module status is MEMIF_UNINIT or MEMIF_BUSY, the function Fee_Read shall reject 
        the job request and return with E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee.c.m4_410</srcid><srcstatus/><internalId>402</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee.c.m4_419</srcid><srcstatus/><internalId>403</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Extra.c_313</srcid><srcstatus/><internalId>455</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_30003</srcid><srcstatus/><internalId>1217</internalId></linkedfrom><linkedfrom><srcid>TS_FEE_30010</srcid><srcstatus/><internalId>1240</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>180</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00174</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        If the current module status is MEMIF_UNINIT or MEMIF_BUSY, the function Fee_Write shall reject 
        the job request and return with E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee.c.m4_531</srcid><srcstatus/><internalId>407</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_30030</srcid><srcstatus/><internalId>1218</internalId></linkedfrom><linkedfrom><srcid>TS_FEE_30010</srcid><srcstatus/><internalId>1240</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>181</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00184</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        If the current module status is not MEMIF_BUSY (i.e. there is no job to cancel and therefore 
        the request to cancel a pending job is rejected by the function Fee_Cancel), the function 
        Fee_Cancel shall raise the runtime error FEE_E_INVALID_CANCEL.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>doc/public/changelog/Deviations.xml_231</srcid><srcstatus/><internalId>333</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>182</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00999</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        These requirements are not applicable to this specification.
      </description>
      <comment>
        This requirement is not applicable.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>183</internalId></specobject>
    <specobject>
      <id>Fee.ECUC_Fee_00153</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        Name: FeeMainFunctionPeriod
        Parameter Type: FloatValue
        Parent Containers: FeeGeneral,
        Description: The period between successive calls to the main function in seconds.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: INF (Type: OPEN)
        Min-Value: 0 (Type: OPEN)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_582</srcid><srcstatus/><internalId>777</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>184</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00187</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>2</version>
      <description>
        The function Fee_Read shall call the function MemAcc_BlankCheck to determine in advance whether 
        a given memory area can be read without encountering e.g. ECC errors due to trying to read 
        erased but not programmed flash cells.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Fee.Dsn.BlankCheck.SectionManagement</srcid><srcstatus/><internalId>954</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.BlankCheck.SectionMarkers</srcid><srcstatus/><internalId>955</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.BlankCheck.SectionManagementRefused</srcid><srcstatus/><internalId>956</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.BlankCheck.ErasableRefused</srcid><srcstatus/><internalId>957</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.BlankCheck.ActiveRefused</srcid><srcstatus/><internalId>958</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.BlankCheck.WrittenMarker</srcid><srcstatus/><internalId>959</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.BlankCheck.WrittenMarkerBlank</srcid><srcstatus/><internalId>960</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.BlankCheck.BlockStamp</srcid><srcstatus/><internalId>961</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.BlankCheck.BlockStampBlank</srcid><srcstatus/><internalId>962</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.BlankCheck.ErasableBitFlip</srcid><srcstatus/><internalId>963</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.BlankCheck.Retention</srcid><srcstatus/><internalId>964</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.BlankCheck.FreshBlock</srcid><srcstatus/><internalId>965</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_StartUp_Empty_Empty</srcid><srcstatus/><internalId>1133</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_BlankCheckFls</srcid><srcstatus/><internalId>1136</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Fee.Fee_BlankCheckEnable</srcid><srcstatus/><internalId>329</internalId></linkedfrom><linkedfrom><srcid>dev.Fee.Fee_BlankCheckAsync</srcid><srcstatus/><internalId>330</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations><ruleid>WRN.swdd.needscoverage.count</ruleid></oreqmViolations><covstatus>covered</covstatus><internalId>185</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00188</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        Name | Fee_ConfigType 
        Kind | Structure 
        Elements | implementation specific 
        Type 
        Comment 
        Description | Configuration data structure of the Fee module.
        Available via | Fee.h 
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Fee.Fee_PostBuild</srcid><srcstatus/><internalId>345</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>186</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00190</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        The function Fee_SetMode shall check if the module state is MEMIF_IDLE or MEMIF_BUSY_INTERNAL. 
        If this is the case the module shall accept the mode change request. The mode change shall be 
        executed asynchronously in the module's main function as soon as the module has finished the 
        internal management operation.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee.c.m4_354</srcid><srcstatus/><internalId>397</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_30014</srcid><srcstatus/><internalId>1223</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>187</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00191</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        The FEE module shall execute the mode change request asynchronously within the FEE module's 
        main function.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Fee.Fee_ModeChange</srcid><srcstatus/><internalId>350</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>188</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00192</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        The function Fee_InvalidateBlock shall check if the module state is MEMIF_IDLE or 
        MEMIF_BUSY_INTERNAL. If this is the case the module shall accept the invalidation request and 
        shall return E_OK to the caller. The block invalidation shall be executed asynchronously in the 
        module's main function as soon as the module has finished the internal management operation.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee.c.m4_799</srcid><srcstatus/><internalId>422</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Switch_JobInterrupts_1_3s</srcid><srcstatus/><internalId>1180</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>189</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00193</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        The FEE module shall execute the block invalidation request asynchronously within the FEE 
        module's main function.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_832</srcid><srcstatus/><internalId>626</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_30008</srcid><srcstatus/><internalId>1221</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>190</internalId></specobject>
    <specobject>
      <id>Fee.ECUC_Fee_00154</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        Module Name | FeeFee 
        Module Description | Configuration of the Fee (Flash EEPROM Emulation) module.
        Post-Build Variant Support | false 
        Supported Config Variants | VARIANT-PRE-COMPILE 
        Included Containers 
        Container Name | Multiplicity | Scope / Dependency 
        FeeBlockConfiguration | 1..* | Configuration of block specific parameters for the Flash EEPROM 
        Emulation module.
        FeeGeneral | 1 | Container for general parameters. These parameters are not specific to a block.
        FeePublishedInformation | 1 | Additional published parameters not covered by 
        CommonPublishedInformation container. Note that these parameters do not have any configuration 
        class setting, since they are published information.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_15</srcid><srcstatus/><internalId>759</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>191</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_91002</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        Type of error | Related error code | Error value 
        API service called while module is busy processing a user request | FEE_E_BUSYFee.FEE_E_BUSY | 
        0x06 
        Fee_Cancel called while no job was pending. | FEE_E_INVALID_CANCELFee.FEE_E_INVALID_CANCEL | 
        0x08 
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_DetMemIfBusy</srcid><srcstatus/><internalId>1232</internalId></linkedfrom><linkedfrom><srcid>TS_FEE_DetInvalidCancel</srcid><srcstatus/><internalId>1236</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>192</internalId></specobject>
    <specobject>
      <id>Fee.ECUC_Fee_00155</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        Name: FeeMemAccAddressArea
        Parameter Type: Reference
        Parent Containers: FeeBlockConfiguration,
        Description: Reference to the MemAccAddressAreaConfiguration. Tags: atp.Status=draft
        Introduction: This reference is mutually exclusicve to FeeDeviceIndex.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: false
        Post-Build-Variant-Value: false
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Destination: /AUTOSAR/EcucDefs/MemAcc/MemAccAddressAreaConfiguration
        Destination type: ECUC-PARAM-CONF-CONTAINER-DEF
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Fee.Fee_MemAccUsage</srcid><srcstatus/><internalId>332</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_253</srcid><srcstatus/><internalId>769</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>193</internalId></specobject>
    <specobject>
      <id>Fee.ECUC_Fee_00156</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        Name: FeeMinimumReadPageSize
        Parameter Type: Integer
        Parent Containers: FeeGeneral,
        Description: Minimum Page size will be a multiple of the minimum page size. Fee shall align 
        read requests to this size. Tags: atp.Status=draft
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: 65535 (Type:
        Min-Value: 0 (Type:
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Fee.Fee_ReadAlign</srcid><srcstatus/><internalId>348</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_802</srcid><srcstatus/><internalId>786</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>194</internalId></specobject>
    <specobject>
      <id>Fee.ECUC_Fee_00157</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        Name: FeeBufferAlignmentValue
        Parameter Type: Reference
        Parent Containers: FeeGeneral,
        Description: Parameter determines the alignment of the start address that Fee buffers need to 
        have. Tags: atp.Status=draft
        Introduction: Value shall be inherited from MemAccBufferAlignmentValue.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Destination: /AUTOSAR/EcucDefs/MemAcc/MemAccAddressAreaConfiguration
        Destination type: ECUC-PARAM-CONF-CONTAINER-DEF
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>doc/public/changelog/Deviations.xml_215</srcid><srcstatus/><internalId>331</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_1556</srcid><srcstatus/><internalId>806</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeUseBufferForJobs.Config</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>219</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>195</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00194</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        The function Fee_JobEndNotification shall perform any necessary block management and error 
        handling operations and subsequently call the job error notification routine of the upper layer 
        module if configured.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Fee.Fee_JobEndNotification</srcid><srcstatus/><internalId>349</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>196</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00195</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        The Fee shall align internal buffers to the value of FeeBufferAlignmentValueRef
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Fee.Fee_BufferAlign</srcid><srcstatus/><internalId>346</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>197</internalId></specobject>
    <specobject>
      <id>Fee.SWS_Fee_00196</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_Fee_R21-11.arxml</source>
      <version>1</version>
      <description>
        The Fee shall align read request to the value of FeeMinimumReadPageSize
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>doc/public/changelog/Deviations.xml_318</srcid><srcstatus/><internalId>347</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>198</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs">
        <specobject>
            <id>Fee.NonVolatileMemory.ContinuousAddressing</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                Fee requires that the underlying non-volatile memory, containing the
                sections that Fee uses, is in a continuous address ares, starting from the beginning
                of the first section and ending at the end of the last section.
            </description>
            <comment>
                Fee does not know about the physical addresses of the non-volatile memory
                that contains its sections. Therefore, Fee uses a continuous address base for all
                sections.
            </comment>
            <needscoverage>
                <needscov><needsobj>lim</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>lim.Fee.EB_INTREQ_Fee_0002</srcid><srcstatus/><internalId>1</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>199</internalId></specobject>
        <specobject>
            <id>Fee.NonVolatileMemory.ErasedValue.OneByte</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                Fee only uses one byte of the "Erased Value" that the underlying Fls
                driver provides.
            </description>
            <comment>
                The "Erased Value" is the same for all erased bytes. Therefore, Fee does
                not need more than 1 byte in order to be able to use the "Erased Value" for its internal
                processing.
            </comment>
            <needscoverage>
                <needscov><needsobj>lim</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>lim.Fee.EB_INTREQ_Fee_0004</srcid><srcstatus/><internalId>3</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>200</internalId></specobject>
        <specobject>
            <id>Fee.VirtualPageSize.Constant</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                Fee requires that the initial virtual page size remains constant, in order
                to be able to retrieve the contents of the non-volatile memory that is used as its
                section.
            </description>
            <comment>
                If the sections are populated with data, based on a virtual page size value,
                changing that value will cause Fee not to recognize the contents of the sections as the
                alignment is lost.
            </comment>
            <needscoverage>
                <needscov><needsobj>lim</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>lim.Fee.EB_INTREQ_Fee_0003</srcid><srcstatus/><internalId>2</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>201</internalId></specobject>
        <specobject>
            <id>Fee.Callback.LimitUse</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                The EB memory stack modules NvM, Ea, and Fee make only limited
                use of the callback calls from their underlying modules.
            </description>
            <comment>
                The callbacks from the Fls to the Fee are not
                synchronously forwarded to the NvM.
            </comment>
            <needscoverage>
                <needscov><needsobj>lim</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>lim.Fee.EB_INTREQ_Fee_0001</srcid><srcstatus/><internalId>0</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
            <providescoverage>
                <provcov>
                    <linksto>Fee.SWS_Fee_00052</linksto>
                    <dstversion>1</dstversion>
                <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>106</internalId></provcov>
                <provcov>
                    <linksto>Fee.SWS_Fee_00054</linksto>
                    <dstversion>1</dstversion>
                <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>107</internalId></provcov>
            </providescoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>202</internalId></specobject>
        <specobject>
            <id>Fee.FeeUseBufferForJobs.MinimumBufferSize</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                This compatibility setting implies a minimum limit to buffer size, 
                as being large enough to fit the largest block configured.
            </description>
            <comment>
            </comment>
            <needscoverage>
                <needscov><needsobj>lim</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>lim.Fee.EB_INTREQ_Fee_0014</srcid><srcstatus/><internalId>13</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
            <providescoverage>
                <provcov>
                    <linksto>Fee.FeeUseBufferForJobs.Config</linksto>
                    <dstversion>1</dstversion>
                <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>219</internalId></provcov>
            </providescoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>203</internalId></specobject>
    </specobjects>
    <specobjects doctype="swurs">
    <specobject>
      <id>Fee_FEE_080_1</id>
      <status>approved</status>
      <source>EB Refinement</source>
      <version>1</version>
      <description>
      Fee_Cancel() shall abort ongoing application
      read/write/... requests immediately.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Ts_Fee_Cancel_Behavior_JobPending_Normal</srcid><srcstatus/><internalId>992</internalId></linkedfrom><linkedfrom><srcid>Ts_Fee_Cancel_Behavior_JobPending_Startup2_NoRequest</srcid><srcstatus/><internalId>994</internalId></linkedfrom><linkedfrom><srcid>Ts_Fee_Cancel_Behavior_JobPending_SectionSwitch_Imp01</srcid><srcstatus/><internalId>997</internalId></linkedfrom><linkedfrom><srcid>TS_FEE_30006</srcid><srcstatus/><internalId>1239</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Fee.Dsn.Cancel.Behaviour.ReadJob</srcid><srcstatus/><internalId>886</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Cancel.Behaviour.WriteJob.WriteBlockInfo</srcid><srcstatus/><internalId>887</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Cancel.Behaviour.WriteBlockData</srcid><srcstatus/><internalId>888</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Cancel.Behaviour.InvalidateJob.WriteBlockInfo</srcid><srcstatus/><internalId>889</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Cancel.Behaviour.WriteJob.WriteWrittenMarker</srcid><srcstatus/><internalId>890</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Cancel.Behaviour.ReportNvm</srcid><srcstatus/><internalId>892</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Normal.Cancel.HasRequest.Ongoing</srcid><srcstatus/><internalId>943</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00080</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>119</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>204</internalId></specobject>

    <specobject>
      <id>Fee_FEE_080_2</id>
      <status>approved</status>
      <source>EB Refinement</source>
      <version>1</version>
      <description>
        Fee_Cancel() shall be ignored while module status is "internal busy".
      </description>
      <comment>
    </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Ts_Fee_Cancel_Behavior_JobPending_Startup1_NoRequest</srcid><srcstatus/><internalId>993</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00080</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>119</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>205</internalId></specobject>

    <specobject>
      <id>Fee_FEE_080_3</id>
      <status>approved</status>
      <source>EB Refinement</source>
      <version>1</version>
      <description>
        The call to the cancel function of the underlying flash driver shall be
        ignored while management information is being written to the flash.
      </description>
      <comment>
        In the AUTOSAR Fee SWS only the hardware is allowed to delay the
        abortion of actual request (see note to FEE081).
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Ts_Fee_Cancel_Behavior_WrittenMarkerOngoing_Imp01</srcid><srcstatus/><internalId>998</internalId></linkedfrom><linkedfrom><srcid>Ts_Fee_Cancel_Behavior_WritingSectionHeader_Imp01</srcid><srcstatus/><internalId>999</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00080</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>119</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>206</internalId></specobject>

    <specobject>
      <id>Fee_FEE_080_4</id>
      <status>approved</status>
      <source>EB Refinement</source>
      <version>1</version>
      <description>
        If MemAcc is used when the lower layer "Cancel" API is processed asyncrounous.
      </description>
      <comment>
        If MemAcc is used the "Cancel" API of the lower layer will make Fee internal state "CANCEL_ONGOING".
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_MemAccAsyncCancel</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Fee.Dsn.Cancel.Behaviour.FeeMemAccUsage.CancelOngoing</srcid><srcstatus/><internalId>893</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Cancel.Behaviour.FeeMemAccUsage.Cancel</srcid><srcstatus/><internalId>894</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00080</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>119</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>207</internalId></specobject>
    
    <specobject>
      <id>EB_FEE114_PollingMode</id>
      <status>approved</status>
      <source>EB Refinement</source>
      <version>1</version>
      <description>
        When parameter "FeeMemAccUsage" is set to 'true' then Polling mode shall be enabled.
      </description>
      <comment>
        In the current ASR21-11 draft the MemAcc module doesn't support callback notification.
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_692</srcid><srcstatus/><internalId>781</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.ECUC_Fee_00114</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>79</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>208</internalId></specobject>
 
    <specobject>
      <id>Fee.Fee_Write.DataBufferPtr.type</id>
      <status>approved</status>
      <source>Bugzilla #55397</source>
      <version>1</version>
      <description>
        Service name: Fee_Write  Syntax: Std_ReturnType Fee_Write(  uint16 BlockNumber,
        const uint8* DataBufferPtr )
      </description>
      <comment>
        Fee_Write DataBufferPtr is changed to const uint8* as against uint8*.
      </comment>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Fee.Fee_WriteDataBufferPtrType</srcid><srcstatus/><internalId>323</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00088</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>125</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>209</internalId></specobject>

  </specobjects>
    <specobjects doctype="swurs">
        <specobject>
            <id>Fee.MainFunction.InitCheck</id>
            <status>approved</status>
            <source>EB: ASCCCB-1403</source>
            <version>1</version>
            <description>
                If the Fee_MainFunction of the un-initialized Fee module is called from the
                BSW Scheduler, then it shall return immediately without
                performing any functionality and without raising any errors.
            </description>
            <comment>
                EB requirement is in line with the AUTOSAR 4.0 General SRS
                requirement BSW00450.

                https://issue.ebgroup.elektrobit.com/browse/ASCCCB-1403
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee.c.m4_54</srcid><srcstatus/><internalId>389</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee.c.m4_977</srcid><srcstatus/><internalId>431</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_30052</srcid><srcstatus/><internalId>1238</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>210</internalId></specobject>

        <specobject>
            <id>Fee.GetStatus.InitCheck</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                Fee_GetStatus() shall report to DET if called while the module is uninitialized.
                The return value of the function shall be MEMIF_UNINIT.
            </description>
            <comment>
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee.c.m4_652</srcid><srcstatus/><internalId>415</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_30040</srcid><srcstatus/><internalId>1243</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>211</internalId></specobject>

        <specobject>
            <id>Fee.Mode.DET</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                When development error detection is enabled for the FEE module; the
                function Fee_SetMode shall check that the given Mode is
                valid. If this is not the case the function shall reject the
                request, raise the development error FEE_E_INVALID_MODE.
            </description>
            <comment>
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee.c.m4_349</srcid><srcstatus/><internalId>396</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_30044</srcid><srcstatus/><internalId>1244</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>212</internalId></specobject>

        <specobject>
            <id>Fee.GlobalVariables</id>
            <status>approved</status>
            <source>HIS-Recommendation for a scalable AUTOSAR Stack, 1.4, 2009-9-28</source>
            <version>1</version>
            <description>
                The global variables of the Flash EEPROM Emulation shall be
                implemented as elements of a single structure.
            </description>
            <comment>
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/Fee_Internal_Types.h_67</srcid><srcstatus/><internalId>380</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee.c.m4_68</srcid><srcstatus/><internalId>390</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>213</internalId></specobject>

        <specobject>
            <id>Fee.StaticVariables</id>
            <status>rejected</status>
            <source>HIS-Recommendation for a scalable AUTOSAR Stack, 1.4, 2009-9-28</source>
            <version>1</version>
            <description>
                The static variables of the Flash EEPROM Emulation shall be
                implemented as elements of a single structure.
            </description>
            <comment>
                This requirement is not applicable since there is not static variables used in Fee
                implementation. In order to reduce startup time, there shall not be double Initialization of
                variables once during power on Initialization and then as part of module Initialization, unless
                it is required. So variable which holds the information whether the module is initialised
                or not can be kept as a separate variable, otherwise, keeping this variable also with
                common structure shall demand Initialization of all structure elements with power on reset.
                But Initialization of all structure elements as part of module init functionality is desired
                as it helps for testing and re-Initialization.
            </comment>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>214</internalId></specobject>

        <specobject>
            <id>Fee.EB.BSWMDGeneration_1</id>
            <status>rejected</status>
            <source>EB</source>
            <version>1</version>
            <description>
                The Fee module's generator shall generate a basic software
                module description (BSWMD) based on the Fee module's
                configuration containing information on the exclusive areas
                required by the Fee module's implementation.
            </description>
            <comment>
                This requirement is not applicable since Fee module does not use any exclusive areas.
            </comment>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>215</internalId></specobject>

        <specobject>
            <id>Fee.EB.BSWMDGeneration_2</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                The Fee module's generator shall generate a basic software
                module description (BSWMD) based on the Fee module's
                configuration containing information on the scheduled
                MainFunctions together with the scheduling period.
            </description>
            <needscoverage>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_SCHM</srcid><srcstatus/><internalId>983</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>216</internalId></specobject>

        <specobject>
            <id>Fee.EB.BSWMDGeneration_3</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                The Fee module's BSWMD shall be generated using a generator
                mode named "generate_swcd".
            </description>
            <needscoverage>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_SCHM</srcid><srcstatus/><internalId>983</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>217</internalId></specobject>

        <specobject>
            <id>Fee.Configuration.FeeBuffer</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                If Fee internal buffer configured size is smaller than a virtual page size or smaller than a block info
                (toghether with the written marker/consistency patterns) an error shall be trown at generation phase.
            </description>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/include/Fee_Checks.m_325</srcid><srcstatus/><internalId>359</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>218</internalId></specobject>

        <specobject>
            <id>Fee.FeeUseBufferForJobs.Config</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                Fee shall offer a vendor specific boolean parameter 'FeeUseBufferForJobs'.
                If TRUE Fee shall guarantee that LowerLayer will get only pointers to aligned to the needed value.
            </description>
            <comment>
                In order to assure compatibility with drivers demanding aligned data, 
                Fee may be configured to handle all operations through it's internal buffer.
                If 'FeeMemAccUsage' is set to 'true' the alignment value will be taken from parameter 'FeeBufferAlignmentValue'.
                If 'FeeMemAccUsage' is set to 'false' the alignment value will be 4 bytes.
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_420</srcid><srcstatus/><internalId>771</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_UserBufferUnaligned</srcid><srcstatus/><internalId>1073</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Fee.ECUC_Fee_00157</srcid><srcstatus/><internalId>195</internalId></linkedfrom><linkedfrom><srcid>Fee.FeeUseBufferForJobs.MinimumBufferSize</srcid><srcstatus/><internalId>203</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>219</internalId></specobject>

        <specobject>
            <id>Fee.Robustness</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                A reset of the ECU or a hardware failure shall never set the Fee in an inoperative state where
                further read/write/... requests will not be accepted and processed anymore.
            </description>
            <rationale>
                If the Fee would refuse further read/write/... requests
                because it stays in an uninitialized state after startup, the ECU flash data
                can not even be reset to some default values triggered by a diagnostic service.
                The customer would have to exchange the ECU in the workshop which is
                unacceptable due to the high costs.
            </rationale>
            <comment>
                An ECU reset caused by a voltage drop, a watchdog reset, an explicit
                diagnostic request or due to other reasons can appear at any time. After the
                next ECU startup the Fee shall always be able to continue working and try to
                recover user data if it is still available.
            </comment>
            <needscoverage>
                <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Fee.Dsn.Initialization.Startup1.MarkerValidity</srcid><srcstatus/><internalId>817</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Initialization.Startup1.BlockInfoValidity.SwitchNotConfiguredBlocksOFF</srcid><srcstatus/><internalId>818</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Initialization.Startup1.BlockInfoValidity.SwitchNotConfiguredBlocksON</srcid><srcstatus/><internalId>819</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Initialization.Startup1.BlockInfoValidity.WrittenMarker</srcid><srcstatus/><internalId>820</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Initialization.Startup1.BlockInfoValidity.WrittenMarkerValidity</srcid><srcstatus/><internalId>821</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Initialization.Startup1.Sections.06</srcid><srcstatus/><internalId>826</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Initialization.Startup1.Sections.07</srcid><srcstatus/><internalId>827</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Initialization.Startup1.Sections.08</srcid><srcstatus/><internalId>828</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Initialization.Startup1.Sections.09</srcid><srcstatus/><internalId>829</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Initialization.Startup1.Sections.10</srcid><srcstatus/><internalId>830</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Initialization.Startup1.Sections.13</srcid><srcstatus/><internalId>833</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Initialization.Startup1.Sections.14</srcid><srcstatus/><internalId>834</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Initialization.Startup1.Sections.15</srcid><srcstatus/><internalId>835</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Initialization.Startup1.BlockInfos.01</srcid><srcstatus/><internalId>836</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Initialization.Startup1.BlockInfos.03</srcid><srcstatus/><internalId>838</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Initialization.CacheInit</srcid><srcstatus/><internalId>839</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Initialization.Startup1.BlockInfosSearch</srcid><srcstatus/><internalId>841</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Initialization.Startup1.InvalidLastBlockInfos</srcid><srcstatus/><internalId>843</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Initialization.Startup2.01</srcid><srcstatus/><internalId>850</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Initialization.Startup2.02</srcid><srcstatus/><internalId>851</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Initialization.Startup2.03</srcid><srcstatus/><internalId>852</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Initialization.Startup2.04</srcid><srcstatus/><internalId>853</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Initialization.Startup2.05</srcid><srcstatus/><internalId>854</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Initialization.Startup2.07</srcid><srcstatus/><internalId>856</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Initialization.Startup2.08</srcid><srcstatus/><internalId>857</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Initialization.Startup2.09</srcid><srcstatus/><internalId>858</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.WriteBlockInfo</srcid><srcstatus/><internalId>863</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.WrittenMarker</srcid><srcstatus/><internalId>864</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.FlashRefusal</srcid><srcstatus/><internalId>913</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.FlashRefusal.Failed</srcid><srcstatus/><internalId>914</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.FlashRefusal.Failed.Det</srcid><srcstatus/><internalId>915</internalId></linkedfrom><linkedfrom><srcid>Fee.Dns.FailureHandling.Job</srcid><srcstatus/><internalId>916</internalId></linkedfrom><linkedfrom><srcid>Fee.Dns.FailureHandling.Behaviour.StoreReqFailure</srcid><srcstatus/><internalId>917</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.FlashRead.BlockInfos.Fails</srcid><srcstatus/><internalId>919</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.FlashRead.BlockInfoByBlockInfo.Fails</srcid><srcstatus/><internalId>920</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.FailureHandling.Behaviour.Startup1.HeaderFailed</srcid><srcstatus/><internalId>921</internalId></linkedfrom><linkedfrom><srcid>Fee.Dns.FailureHandling.Behaviour.Startup1.FooterFailed</srcid><srcstatus/><internalId>922</internalId></linkedfrom><linkedfrom><srcid>Fee.Dns.FailureHandling.Behaviour.Startup1.BothSectionManagementObjectsFailed</srcid><srcstatus/><internalId>923</internalId></linkedfrom><linkedfrom><srcid>Fee.Dns.FailureHandling.Behaviour.WritingSectionHeader.Failure</srcid><srcstatus/><internalId>924</internalId></linkedfrom><linkedfrom><srcid>Fee.Dns.FailureHandling.Behaviour.WritingSectionFooter.Failure</srcid><srcstatus/><internalId>925</internalId></linkedfrom><linkedfrom><srcid>Fee.Dns.FailureHandling.Behaviour.MarkingHeaderActive.Failure</srcid><srcstatus/><internalId>926</internalId></linkedfrom><linkedfrom><srcid>Fee.Dns.FailureHandling.Behaviour.MarkingFooterActive.Failure</srcid><srcstatus/><internalId>927</internalId></linkedfrom><linkedfrom><srcid>Fee.Dns.FailureHandling.Behaviour.MarkingHeaderErasable.Failure</srcid><srcstatus/><internalId>928</internalId></linkedfrom><linkedfrom><srcid>Fee.Dns.FailureHandling.Behaviour.MarkingFooterErasable.Failure</srcid><srcstatus/><internalId>929</internalId></linkedfrom><linkedfrom><srcid>Fee.Dns.FailureHandling.Behaviour.SectionSwitch.WriteBlockInfo</srcid><srcstatus/><internalId>930</internalId></linkedfrom><linkedfrom><srcid>Fee.Dns.FailureHandling.Behaviour.SectionSwitch.BlockDataWrite</srcid><srcstatus/><internalId>931</internalId></linkedfrom><linkedfrom><srcid>Fee.Dns.FailureHandling.Behaviour.SectionSwitch.BlockWrittenMarkerWrite</srcid><srcstatus/><internalId>932</internalId></linkedfrom><linkedfrom><srcid>Fee.Dns.FailureHandling.Behaviour.SectionSwitch.BlockDataRead</srcid><srcstatus/><internalId>933</internalId></linkedfrom><linkedfrom><srcid>Fee.Dns.FailureHandling.Behaviour.Failure.SectionErase.HighPrio</srcid><srcstatus/><internalId>935</internalId></linkedfrom><linkedfrom><srcid>Fee.Dns.FailureHandling.Behaviour.Failure.SectionErase.LowPrio</srcid><srcstatus/><internalId>936</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations><ruleid>WRN.swdd.needscoverage.count</ruleid></oreqmViolations><covstatus>covered</covstatus><internalId>220</internalId></specobject>
        
        <specobject>
            <id>Fee.Secured</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                Fee shall not lose blocks during section switch in the following situations:
                - overstressed with any jobs during section switch; and/or:
                - as many Fls write/erase failures occur during section switch; and/or:
                - as many resets occur during section switch;
            </description>
            <rationale>
                Comes from ASCPD-342.
            </rationale>
            <comment>
               Feature: Secured section switch/Restart section switch
            </comment>
            <needscoverage>
                <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Fee.Dns.SS.SwitchPriority</srcid><srcstatus/><internalId>905</internalId></linkedfrom><linkedfrom><srcid>Fee.Dns.SS.RestartSwitch.ConditionForRestart</srcid><srcstatus/><internalId>909</internalId></linkedfrom><linkedfrom><srcid>Fee.Dns.SS.RestartSwitch.TriggerAfterInit</srcid><srcstatus/><internalId>910</internalId></linkedfrom><linkedfrom><srcid>Fee.Dns.SS.RestartSwitch.Priority</srcid><srcstatus/><internalId>911</internalId></linkedfrom><linkedfrom><srcid>Fee.Dns.SS.RestartSwitch</srcid><srcstatus/><internalId>912</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>221</internalId></specobject>

        <specobject>
            <id>Fee.NoFlashPageOverriden</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                Fee shall never request a write operation for Fls driver that overwrites a physical flash page
                already written by Fee, without previously erasing it.
            </description>
            <rationale>
                Fee must be generic software. There are flash techonogies on the market that does not allow
                even an overwrite "from high state to low state" tranzition.
            </rationale>
            <comment>
                This shouldn't happen not even when the overwrite happens to be from high state to low state
                (0xFF -&gt; 0x00), in case the default erased value for flash device is 0xFF.
            </comment>
            <needscoverage>
                <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Fee.Dsn.Initialization.Startup1.BlockInfosSearch</srcid><srcstatus/><internalId>841</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Initialization.Startup1.InvalidLastBlockInfos</srcid><srcstatus/><internalId>843</internalId></linkedfrom><linkedfrom><srcid>Fee.Dns.FailureHandling.Behaviour.BlockInfoMargin</srcid><srcstatus/><internalId>918</internalId></linkedfrom><linkedfrom><srcid>Fee.Dns.FailureHandling.Behaviour.SectionSwitch.WriteBlockInfo</srcid><srcstatus/><internalId>930</internalId></linkedfrom><linkedfrom><srcid>Fee.Dns.FailureHandling.Behaviour.SectionSwitch.BlockDataWrite</srcid><srcstatus/><internalId>931</internalId></linkedfrom><linkedfrom><srcid>Fee.Dns.FailureHandling.Behaviour.SectionSwitch.BlockWrittenMarkerWrite</srcid><srcstatus/><internalId>932</internalId></linkedfrom><linkedfrom><srcid>Fee.Dns.FailureHandling.Behaviour.SectionSwitch.BlockInfoMargin</srcid><srcstatus/><internalId>934</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Critical.SectionFull</srcid><srcstatus/><internalId>947</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Switch_NoConfErasedBlock_Sections3</srcid><srcstatus/><internalId>1191</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>222</internalId></specobject>

        <specobject>
            <id>Fee.WriteMultipleOfVP</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                If data size is not multiple of virtual page size, Fee shall write the last bytes within a distinct virtual page. The reason is that Fls does not accept write requests where the size is not multiple of phisical page size.
            </description>
            <rationale>
                Fls driver does not handle write operation for sizes that are not multiple of physical page size.
            </rationale>
            <comment>
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Jobs.c_276</srcid><srcstatus/><internalId>707</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Ts_Fee_Jobs_Idle</srcid><srcstatus/><internalId>1000</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_WriteRefusedRetries</srcid><srcstatus/><internalId>1064</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>223</internalId></specobject>

        <specobject>
            <id>Fee.Sections</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                The mechanisms to spread the write access in order not to overstress the flash memory 
                shall consist in sepparating the virtual memory in as equally as possible sized Sections,
                each of them multiple of the smallest erasable physical sector size and wear them sequentially.
            </description>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/src/Fee_Cfg.c_31</srcid><srcstatus/><internalId>365</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Fee.Dsn.Initialization.Startup1.Sections.01</srcid><srcstatus/><internalId>822</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Initialization.Startup1.Sections.02</srcid><srcstatus/><internalId>823</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Initialization.Startup1.BlockInfos.03</srcid><srcstatus/><internalId>838</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Initialization.Startup2.01</srcid><srcstatus/><internalId>850</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Initialization.Startup2.02</srcid><srcstatus/><internalId>851</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Initialization.Startup2.03</srcid><srcstatus/><internalId>852</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Initialization.Startup2.04</srcid><srcstatus/><internalId>853</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Initialization.Startup2.06</srcid><srcstatus/><internalId>855</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Write.Behaviour.IDLE.IsSpace</srcid><srcstatus/><internalId>865</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Write.Behaviour.IDLE.NoSpace</srcid><srcstatus/><internalId>866</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Write.Behaviour.SSOngoing.IsSpace</srcid><srcstatus/><internalId>867</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Write.Behaviour.SSOngoing.SwapNeeded</srcid><srcstatus/><internalId>868</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Invalidate.Behaviour.IDLE.IsSpace</srcid><srcstatus/><internalId>875</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Invalidate.Behaviour.IDLE.NoSpace</srcid><srcstatus/><internalId>876</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Invalidate.Behaviour.SSOngoing.IsSpace</srcid><srcstatus/><internalId>877</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Invalidate.Behaviour.SSOngoing.SwapNeeded</srcid><srcstatus/><internalId>878</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Invalidate.Behaviour.SSOngoing.NoSpace</srcid><srcstatus/><internalId>879</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.EraseImmediate.Behaviour.IDLE.IsSpace</srcid><srcstatus/><internalId>880</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.EraseImmediate.Behaviour.IDLE.NoSpace</srcid><srcstatus/><internalId>881</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.EraseImmediate.Behaviour.SSOngoing.IsSpace</srcid><srcstatus/><internalId>882</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.EraseImmediate.Behaviour.SSOngoing.SwapNeeded</srcid><srcstatus/><internalId>883</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.EraseImmediate.Behaviour.SSOngoing.NoSpace</srcid><srcstatus/><internalId>884</internalId></linkedfrom><linkedfrom><srcid>Fee.Dns.SS.CopyBlocks</srcid><srcstatus/><internalId>895</internalId></linkedfrom><linkedfrom><srcid>Fee.Dns.SS.RevalidateOldSection</srcid><srcstatus/><internalId>896</internalId></linkedfrom><linkedfrom><srcid>Fee.Dns.SS.TriggeringTheSwitch.WriteRequest</srcid><srcstatus/><internalId>897</internalId></linkedfrom><linkedfrom><srcid>Fee.Dns.SS.TriggeringTheSwitch.InvalidateRequest</srcid><srcstatus/><internalId>898</internalId></linkedfrom><linkedfrom><srcid>Fee.Dns.SS.TriggeringTheSwitch.EraseRequest</srcid><srcstatus/><internalId>899</internalId></linkedfrom><linkedfrom><srcid>Fee.Dns.SS.TriggeringTheSwitch.AfterInit</srcid><srcstatus/><internalId>900</internalId></linkedfrom><linkedfrom><srcid>Fee.Dns.SS.Behaviour.SSResume.BlockSwitching.Writing</srcid><srcstatus/><internalId>901</internalId></linkedfrom><linkedfrom><srcid>Fee.Dns.SS.Behaviour.SSResume.BlockSwitching.Reading</srcid><srcstatus/><internalId>902</internalId></linkedfrom><linkedfrom><srcid>Fee.Dns.SS.Behaviour.SSResume.BlockSwitching.SectionErase</srcid><srcstatus/><internalId>903</internalId></linkedfrom><linkedfrom><srcid>Fee.Dns.SS.Behaviour.ChangingActiveSection</srcid><srcstatus/><internalId>904</internalId></linkedfrom><linkedfrom><srcid>Fee.Dns.SS.SwitchPriority</srcid><srcstatus/><internalId>905</internalId></linkedfrom><linkedfrom><srcid>Fee.Dns.SS.ErasePriority</srcid><srcstatus/><internalId>906</internalId></linkedfrom><linkedfrom><srcid>Fee.Dns.SS.SwitchPriority.BlockToSwitch</srcid><srcstatus/><internalId>907</internalId></linkedfrom><linkedfrom><srcid>Fee.Dns.SS.SwitchPriority.JobLosesPriority</srcid><srcstatus/><internalId>908</internalId></linkedfrom><linkedfrom><srcid>Fee.Dns.SS.RestartSwitch.ConditionForRestart</srcid><srcstatus/><internalId>909</internalId></linkedfrom><linkedfrom><srcid>Fee.Dns.SS.RestartSwitch.TriggerAfterInit</srcid><srcstatus/><internalId>910</internalId></linkedfrom><linkedfrom><srcid>Fee.Dns.SS.RestartSwitch.Priority</srcid><srcstatus/><internalId>911</internalId></linkedfrom><linkedfrom><srcid>Fee.Dns.SS.RestartSwitch</srcid><srcstatus/><internalId>912</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations><ruleid>WRN.swdd.needscoverage.count</ruleid></oreqmViolations><covstatus>covered</covstatus><internalId>224</internalId></specobject>

        <specobject>
            <id>Fee.Sections.NumberOfSections.Configurable</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                The number of configured sections must be at least 2 and at most 254.
                Configuration parameter: FeeNumberOfSections, 2..254, optional.
            </description>
            <comment>
                The value 255 is reserved for possible further usage.
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_830</srcid><srcstatus/><internalId>787</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>225</internalId></specobject>

        <specobject>
            <id>Fee.Sections.NumberOfSections.Validate</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                If the configured number of sections is not valid:
                - the configured number of sections is not in the definition range, or
                - the configured number of sections is smaller than the number of configured Fls sectors.
                then an error shall be thrown during the generation phase to indicate this. 
            </description>
            <comment>
                The number of sections configured must be a valid number. In order to avoid erroneous
                behavior due to human error, the configured value shall be validation prior to usage
                and, if found incorrect, an error is reported so that it can be corrected.
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/include/Fee_Checks.m_193</srcid><srcstatus/><internalId>357</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_855</srcid><srcstatus/><internalId>788</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>226</internalId></specobject>

        <specobject>
            <id>Fee.Sections.Generation</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                Fee shall calculate the start addresses and the size for each section taking into
                consideration the configuration parameters of Fls, at generation time.
            </description>
            <comment>
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/src/Fee_Cfg.c_33</srcid><srcstatus/><internalId>367</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>227</internalId></specobject>

        <specobject>
            <id>Fee.Sections.HeaderSecured</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                The section management object's information shall be secured with an error-detectig mechanisms.
            </description>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_1974</srcid><srcstatus/><internalId>536</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Fee.Dsn.Initialization.Startup1.Sections.03</srcid><srcstatus/><internalId>824</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Initialization.Startup1.Sections.04</srcid><srcstatus/><internalId>825</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>228</internalId></specobject>

        <specobject>
            <id>Fee.Sections.ACTIVE_marker</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                A marker named ACTIVE shall be used in order to mark a section as having 
                blocks written in the section.
            </description>
            <rationale>
            </rationale>
            <comment>
            </comment>
            <needscoverage>
                <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Fee.Dsn.Initialization.Startup1.MarkerValidity</srcid><srcstatus/><internalId>817</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Initialization.Startup1.Sections.07</srcid><srcstatus/><internalId>827</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>229</internalId></specobject>

        <specobject>
            <id>Fee.Sections.ERASABLE_marker</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                A marker named ERASABLE shall be used in order to mark a section as to be erased.
            </description>
            <rationale>
            </rationale>
            <comment>
            </comment>
            <needscoverage>
                <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Fee.Dsn.Initialization.Startup1.MarkerValidity</srcid><srcstatus/><internalId>817</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Initialization.Startup1.Sections.08</srcid><srcstatus/><internalId>828</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Initialization.Startup2.05</srcid><srcstatus/><internalId>854</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>230</internalId></specobject>

        <specobject>
            <id>Fee.Configuration.TotalBlocksSize</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                All the configured blocks shall have the possibility to be all written within the smallest section.
                If the size of all the blocks toghether with all the internal management information(section's, block's and other) 
                does not fit in the smallest section, the user shall be notified of this through an error when 
                the configurations files are generated.
            </description>
            <comment>
                If the total number of configured blocks, with regards to their sizes, is great enough to
                cause data loss during section switch or not to allow to store all blocks in such a way
                that the section switch is not impacted, an error shall be reported for this.

                Whenever possible, human errors should be compensated by automatic validations/verifications.
                The same situation is this, especially since it is with significant effort on the human part
                to perform such a verification, while for a computer it is a matter of seconds, at most.
                If all the configured blocks are written in the smallest section and the empty space left in the section is 
                smaller than the biggest configured block size, an warning should be raised.
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/include/Fee_Checks.m_267</srcid><srcstatus/><internalId>358</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/generate/src/Fee_Cfg.c_125</srcid><srcstatus/><internalId>368</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>231</internalId></specobject>

        <specobject>
            <id>Fee.Configuration.TotalBlocksSize.SwitchNotConfiguredBlocks</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                If FeeNumberOfNotConfigBlocks is different than 0, the generator shall consider the value of FeeDataSizeNotConfiguredBlocks
                toghether with all the configured blocks size to fit within the smallest section.
                Otherwise an error shall be raised.
            </description>
            <comment>
                If all the configured blocks are written in the smallest section toghether with the not configured blocks size specified by 
                FeeDataSizeNotConfiguredBlocks and the empty space left in the section is smaller than the biggest configured block size, 
                an warning should be raised.
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/include/Fee_Checks.m_267</srcid><srcstatus/><internalId>358</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_NotConfigBlocks_StandardSwitch</srcid><srcstatus/><internalId>1162</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_NotConfigBlocks_SS_NotNeeded</srcid><srcstatus/><internalId>1163</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_NotConfigBlocks_HPSS</srcid><srcstatus/><internalId>1164</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_NotConfigBlocks_RestartSwitch</srcid><srcstatus/><internalId>1165</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_ConfigBlocks_RestartSwitch_AllBlocks</srcid><srcstatus/><internalId>1166</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>232</internalId></specobject>

        <specobject>
            <id>Fee.Configuration.FeeNumberOfNotConfigBlocks</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                The configuration parameter FeeNumberOfNotConfigBlocks shall defines the maximum number of not configured blocks 
                that Fee can identify and memorise at initialization and carry them during runtime through switch mechanism.
            </description>
            <comment>
                Type : uint16
                Range : 0 : (65535 - The configured blocks)
                Optional : TRUE
                If FeeNumberOfNotConfigBlocks is different than 0 the feature Switch Not Configured Blocks is considered ON.
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_1253</srcid><srcstatus/><internalId>798</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Fee.Dsn.Initialization.Startup1.BlockInfoValidity.SwitchNotConfiguredBlocksON</srcid><srcstatus/><internalId>819</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Initialization.Startup1.BlockInfos.02</srcid><srcstatus/><internalId>837</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Initialization.Startup1.SwitchNotConfiguredBlocks</srcid><srcstatus/><internalId>842</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Initialization.Startup1.BlocksSearchStop.SwNotConfigBlocksON</srcid><srcstatus/><internalId>848</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_NotConfigBlocks_StandardSwitch</srcid><srcstatus/><internalId>1162</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_NotConfigBlocks_SS_NotNeeded</srcid><srcstatus/><internalId>1163</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_NotConfigBlocks_HPSS</srcid><srcstatus/><internalId>1164</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_NotConfigBlocks_RestartSwitch</srcid><srcstatus/><internalId>1165</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_ConfigBlocks_RestartSwitch_AllBlocks</srcid><srcstatus/><internalId>1166</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_NotConfigBlocks_ReconfSizeSmaller</srcid><srcstatus/><internalId>1172</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_NotConfigBlocks_ReconfSizeBigger</srcid><srcstatus/><internalId>1173</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_NotConfigBlocks_InvalidatedBlock</srcid><srcstatus/><internalId>1175</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>233</internalId></specobject>

        <specobject>
            <id>Fee.FeeNumberOfNotConfigBlocks.BlocksLost</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                If there are more blocks than Fee can identifie a Det error, FEE_E_NOT_CFG_BLK_LOST, shall be reported
                for the first block that can't be cached.
            </description>
            <comment>
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_1416</srcid><srcstatus/><internalId>513</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_1455</srcid><srcstatus/><internalId>514</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Fee.Dsn.WriteCustom.TooManyBlocks</srcid><srcstatus/><internalId>869</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_NotConfigBlocks_StandardSwitch</srcid><srcstatus/><internalId>1162</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>234</internalId></specobject>

        <specobject>
            <id>Fee.Configuration.FeeDataSizeNotConfiguredBlocks</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                The configuration parameter FeeDataSizeNotConfiguredBlocks shall define the total data size in section 
                to be considered by Fee for not configured blocks, if FeeNumberOfNotConfigBlocks is different than 0.
            </description>
            <comment>
                Type : uint32
                Optional : if FeeNumberOfNotConfigBlocks is different than 0
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_1286</srcid><srcstatus/><internalId>799</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_NotConfigBlocks_StandardSwitch</srcid><srcstatus/><internalId>1162</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_NotConfigBlocks_SS_NotNeeded</srcid><srcstatus/><internalId>1163</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_NotConfigBlocks_HPSS</srcid><srcstatus/><internalId>1164</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_NotConfigBlocks_RestartSwitch</srcid><srcstatus/><internalId>1165</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_ConfigBlocks_RestartSwitch_AllBlocks</srcid><srcstatus/><internalId>1166</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>235</internalId></specobject>
        
        <specobject>
            <id>Fee.FeeNotConfigBlocks.SizeReconfigured</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                If Fee finds at initialization a newer instance of a not-configured block, but with a different size that the previous instance,
                it shall cache the block and take the new size as valid.
            </description>
            <comment>
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_1541</srcid><srcstatus/><internalId>519</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_NotConfigBlocks_ReconfSizeSmaller</srcid><srcstatus/><internalId>1172</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_NotConfigBlocks_ReconfSizeBigger</srcid><srcstatus/><internalId>1173</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>236</internalId></specobject>

        <specobject>
            <id>Fee.Configuration.FeeWriteCustomApi</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                The configuration parameter FeeWriteCustomApi shall enable the API FeeWriteCustom.
                true: API FeeWriteCustom enabled. 
                false: API FeeWriteCustom disabled.
            </description>
            <comment>
                Type : boolean
                Optional : if FeeNumberOfNotConfigBlocks is different than 0
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_1326</srcid><srcstatus/><internalId>800</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_WriteCustom_FullSlots</srcid><srcstatus/><internalId>1167</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_WriteCustom_Refusals</srcid><srcstatus/><internalId>1168</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_WriteCustom_Acceptance</srcid><srcstatus/><internalId>1169</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>237</internalId></specobject>

        <specobject>
            <id>Fee.FeeWriteCustom</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                FeeWriteCustom is an asynchronous non-reentrant API that shall initiate a write job for a not configured block.
                Syntax: Std_ReturnType FeeWriteCustom( uint16 BlockNumber, const uint8* DataBufferPtr, uint16 BlockSize )
                BlockNumber - Number of the not configured block;
                DataBufferPtr - Pointer to data buffer;
                BlockSize  - Size of the not configured block.
                The Api shall return E_OK if the requested job has been accepted by the module, and E_NOT_OK otherwise.
            </description>
            <comment>
                Type : boolean
                Optional : if FeeNumberOfNotConfigBlocks is different than 0
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Extra.c_77</srcid><srcstatus/><internalId>434</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_WriteCustom_FullSlots</srcid><srcstatus/><internalId>1167</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_WriteCustom_Refusals</srcid><srcstatus/><internalId>1168</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_WriteCustom_Acceptance</srcid><srcstatus/><internalId>1169</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>238</internalId></specobject>

        <specobject>
            <id>Fee.FeeWriteCustom.UninitOrBusy</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                If the current module status is MEMIF_UNINIT or MEMIF_BUSY, the function Fee_WriteCustom shall reject the job request
                and return with E_NOT_OK.
            </description>
            <comment>
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Extra.c_116</srcid><srcstatus/><internalId>437</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Extra.c_127</srcid><srcstatus/><internalId>439</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_WriteCustom_Refusals</srcid><srcstatus/><internalId>1168</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>239</internalId></specobject>

        <specobject>
            <id>Fee.FeeWriteCustom.ConfiguredBlock</id>
            <status>approved</status>
            <source>EB</source>
            <version>2</version>
            <description>
                The function FeeWriteCustom shall reject the request in case the given block number is among the configured blocks.
            </description>
            <comment>
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Extra.c_156</srcid><srcstatus/><internalId>443</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Critical_ReadInIdle</srcid><srcstatus/><internalId>1035</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_WriteCustom_Refusals</srcid><srcstatus/><internalId>1168</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>240</internalId></specobject>

        <specobject>
            <id>Fee.FeeWriteCustom.Det.Uninit</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                If development error detection is enabled for the module the function Fee_WriteCustom shall raise the development error FEE_E_UNINIT
                if the current module status is MEMIF_UNINIT.
            </description>
            <comment>
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Extra.c_119</srcid><srcstatus/><internalId>438</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_WriteCustom_Refusals</srcid><srcstatus/><internalId>1168</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>241</internalId></specobject>

        <specobject>
            <id>Fee.FeeWriteCustom.Det.Busy</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                If development error detection is enabled for the module the function Fee_WriteCustom shall raise the development error FEE_E_BUSY
                if the current module status is MEMIF_BUSY.
            </description>
            <comment>
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Extra.c_130</srcid><srcstatus/><internalId>440</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_WriteCustom_Refusals</srcid><srcstatus/><internalId>1168</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>242</internalId></specobject>

        <specobject>
            <id>Fee.FeeWriteCustom.Det.BlockNumber.Invalid</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                If development error detection is enabled for the module the function Fee_WriteCustom shall raise
                the development error FEE_E_INVALID_BLOCK_NO if the given block number is invalid (id 0).
            </description>
            <comment>
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Extra.c_140</srcid><srcstatus/><internalId>441</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_WriteCustom_Refusals</srcid><srcstatus/><internalId>1168</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>243</internalId></specobject>

        <specobject>
            <id>Fee.FeeWriteCustom.Det.BlockNumber.ConfiguredBlock</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                If development error detection is enabled for the module the function Fee_WriteCustom shall raise
                the development error FEE_E_INVALID_BLOCK_NO if the given block number corresponds to a configured block.
            </description>
            <comment>
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Extra.c_159</srcid><srcstatus/><internalId>444</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_WriteCustom_Refusals</srcid><srcstatus/><internalId>1168</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>244</internalId></specobject>

        <specobject>
            <id>Fee.FeeWriteCustom.Det.DataPointer</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                If development error detection is enabled for the module the function Fee_WriteCustom shall raise 
                the development error FEE_E_INVALID_DATA_PTR if the given data pointer is invalid (NULL_PTR).
            </description>
            <comment>
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Extra.c_146</srcid><srcstatus/><internalId>442</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_WriteCustom_Refusals</srcid><srcstatus/><internalId>1168</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>245</internalId></specobject>

        <specobject>
            <id>Fee.FeeWriteCustom.Det.BlockSize</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                If development error detection is enabled for the module the function Fee_WriteCustom shall raise 
                the development error FEE_E_INVALID_BLOCK_LEN if the given block size is invalid.
            </description>
            <comment>
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Extra.c_198</srcid><srcstatus/><internalId>448</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Extra.c_207</srcid><srcstatus/><internalId>449</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Extra.c_246</srcid><srcstatus/><internalId>451</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Extra.c_264</srcid><srcstatus/><internalId>452</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_WriteCustom_Refusals</srcid><srcstatus/><internalId>1168</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>246</internalId></specobject>

        <specobject>
            <id>Fee.Configuration.FeeReadCustomApi</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                The configuration parameter FeeReadCustomApi shall enable the API FeeReadCustom.
                true: API FeeReadCustom enabled. 
                false: API FeeReadCustom disabled.
            </description>
            <comment>
                Type : boolean
                Optional : if FeeNumberOfNotConfigBlocks is different than 0
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_1382</srcid><srcstatus/><internalId>801</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_ReadCustom_Refusals</srcid><srcstatus/><internalId>1170</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_ReadCustom_Acceptance</srcid><srcstatus/><internalId>1171</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_CustomBlkErasedWrittenInSection0</srcid><srcstatus/><internalId>1174</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>247</internalId></specobject>

        <specobject>
            <id>Fee.FeeReadCustom</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                FeeReadCustom is an asynchronous non-reentrant API that shall initiate a read job for a not configured block.
                Syntax: Std_ReturnType FeeReadCustom( uint16 BlockNumber, uint16 BlockOffset, uint8* DataBufferPtr, uint16 Length )
                BlockNumber - Number of the not configured block;
                BlockOffset - Read address offset inside the block
                DataBufferPtr - Pointer to data buffer;
                Length  - Number of bytes to read.
                The Api shall return E_OK if the requested job has been accepted by the module, and E_NOT_OK otherwise.
            </description>
            <comment>
                Type : boolean
                Optional : if FeeNumberOfNotConfigBlocks is different than 0
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Extra.c_303</srcid><srcstatus/><internalId>454</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_ReadCustom_Refusals</srcid><srcstatus/><internalId>1170</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_ReadCustom_Acceptance</srcid><srcstatus/><internalId>1171</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_CustomBlkErasedWrittenInSection0</srcid><srcstatus/><internalId>1174</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>248</internalId></specobject>

        <specobject>
            <id>Fee.FeeReadCustom.UninitOrBusy</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                If the current module status is MEMIF_UNINIT or MEMIF_BUSY, the function Fee_ReadCustom shall reject the job request
                and return with E_NOT_OK.
            </description>
            <comment>
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Extra.c_341</srcid><srcstatus/><internalId>458</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_ReadCustom_Refusals</srcid><srcstatus/><internalId>1170</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>249</internalId></specobject>
        
        <specobject>
            <id>Fee.FeeReadCustom.BlockNumber</id>
            <status>approved</status>
            <source>EB</source>
            <version>2</version>
            <description>
                If the given block number is not among the memorized unconfigured blocks,
                the function Fee_ReadCustom shall reject the job request and return with E_NOT_OK.
            </description>
            <comment>
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Extra.c_375</srcid><srcstatus/><internalId>462</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Critical_ReadInIdle</srcid><srcstatus/><internalId>1035</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_ReadCustom_Refusals</srcid><srcstatus/><internalId>1170</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>250</internalId></specobject>

        <specobject>
            <id>Fee.FeeReadCustom.Det.Uninit</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                If development error detection is enabled for the module the function Fee_ReadCustom shall raise the development error FEE_E_UNINIT
                if the current module status is MEMIF_UNINIT.
            </description>
            <comment>
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Extra.c_346</srcid><srcstatus/><internalId>459</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_ReadCustom_Refusals</srcid><srcstatus/><internalId>1170</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>251</internalId></specobject>

        <specobject>
            <id>Fee.FeeReadCustom.Det.Busy</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                If development error detection is enabled for the module the function Fee_ReadCustom shall raise the development error FEE_E_BUSY
                if the current module status is MEMIF_BUSY.
            </description>
            <comment>
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Extra.c_355</srcid><srcstatus/><internalId>460</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_ReadCustom_Refusals</srcid><srcstatus/><internalId>1170</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>252</internalId></specobject>

        <specobject>
            <id>Fee.FeeReadCustom.Det.BlockNumber</id>
            <status>approved</status>
            <source>EB</source>
            <version>2</version>
            <description>
                If development error detection is enabled for the module the function Fee_ReadCustom shall raise 
                the development error FEE_E_INVALID_BLOCK_NO if the given block number is invalid
                (not among the memorized unconfigured blocks).
            </description>
            <comment>
                If an immediate not-configured block is erased, the block will be considered as not existing.
                In this case Fee_ReadCustom will return E_NOT_OK and report a DET error.
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Extra.c_383</srcid><srcstatus/><internalId>463</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_ReadCustom_Refusals</srcid><srcstatus/><internalId>1170</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>253</internalId></specobject>

        <specobject>
            <id>Fee.FeeReadCustom.Det.DataPointer</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                If development error detection is enabled for the module the function Fee_ReadCustom shall raise 
                the development error FEE_E_INVALID_DATA_PTR if the given data pointer is invalid (NULL_PTR) and
                return with E_NOT_OK.
            </description>
            <comment>
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Extra.c_366</srcid><srcstatus/><internalId>461</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_ReadCustom_Refusals</srcid><srcstatus/><internalId>1170</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>254</internalId></specobject>

        <specobject>
            <id>Fee.FeeReadCustom.Det.WrongLength</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                If development error detection is enabled for the module: 
                The function FeeReadCustom shall raise the development error FEE_E_INVALID_BLOCK_LEN and return with E_NOT_OK 
                if the given length plus the block offset exeeds the block end address.
            </description>
            <comment>
                For an invalidated not-configured block Fee will not do this check because it can not know the size of the block.
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Extra.c_407</srcid><srcstatus/><internalId>465</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_ReadCustom_Refusals</srcid><srcstatus/><internalId>1170</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>255</internalId></specobject>

        <specobject>
            <id>Fee.FeeReadCustom.Det.WrongOffset</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                If development error detection is enabled for the module: 
                The function FeeReadCustom shall raise the development error FEE_E_INVALID_BLOCK_OFS and return with E_NOT_OK 
                if the given block offset exeeds the block end address.
            </description>
            <comment>
                For an invalidated not-configured block Fee will not do this check because it can not know the size of the block.
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Extra.c_398</srcid><srcstatus/><internalId>464</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_ReadCustom_Refusals</srcid><srcstatus/><internalId>1170</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>256</internalId></specobject>

        <specobject>
            <id>Fee.Initialization.EmptyFlash</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                If there is no section valid found at initialization, Fee shall process 
                user job requests as soon as at least one section is validated.
            </description>
            <rationale>
                In production they might want to start with an empty flash. Fee must be able 
                to work propperly with an empty flash.
            </rationale>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_351</srcid><srcstatus/><internalId>592</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Sections.c_139</srcid><srcstatus/><internalId>725</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_StartUp_Inconsistent_Inconsistent</srcid><srcstatus/><internalId>1145</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>257</internalId></specobject>

        <specobject>
            <id>Fee.Initializaion.UserJobRequests</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                Fee shall accept user requests during initialization and process them right after the status
                of all the blocks is known, giving user requests higher priority over 
                other initialization actions, but without interrupting initialization in a destructive way.
            </description>
            <rationale>
            </rationale>
            <comment>
                After all sections statuses are known and all the data is cached Fee can process job requests.
                The overall startup time of the ECU must be as short as possible, also depending on
                project specifics. Therefore, a specific value cannot be given for a generic
                approach.
                Interrupting initialization in a destructive way means interrupting an internal write or erase by using Fls_Cancel.
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee.c.m4_408</srcid><srcstatus/><internalId>400</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_202</srcid><srcstatus/><internalId>582</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Fee.Dsn.Timer.UserJobRequests</srcid><srcstatus/><internalId>859</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Initialization.Idle</srcid><srcstatus/><internalId>860</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Timer.InternalOperation</srcid><srcstatus/><internalId>861</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_StartUp_Inconsistent_Inconsistent</srcid><srcstatus/><internalId>1145</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>258</internalId></specobject>

        <specobject>
            <id>Fee.SS.TriggeringTheSwitch.ReadRequest</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                A read request shall never trigger a Section Switch.
            </description>
            <comment>
            </comment>
            <needscoverage>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Switch_ReadNoTrigger_c2s</srcid><srcstatus/><internalId>1034</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_ReadNoTrigger_c4s</srcid><srcstatus/><internalId>1051</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_ReadNoTrigger_i2s</srcid><srcstatus/><internalId>1093</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_ReadNoTrigger_i4s</srcid><srcstatus/><internalId>1109</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_ReadNoTrigger_4s</srcid><srcstatus/><internalId>1197</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_ReadNoTrigger</srcid><srcstatus/><internalId>1259</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>259</internalId></specobject>

        <specobject>
            <id>Fee.SS.UserJobRequests</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                Fee shall accept user requests during section switch but process them in the first moment in time
                the switch can be interrupted in a non-distructive way, only if the switch doesn't have the highest 
                priority or is about to take the highest priority because of the current job.
            </description>
            <rationale>
            </rationale>
            <comment>
                Interrupting section switch in a destructive way means interrupting an internal write or erase by using Fls_Cancel.
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_203</srcid><srcstatus/><internalId>583</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Fee.Dsn.Timer.UserJobRequests</srcid><srcstatus/><internalId>859</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Timer.InternalOperation</srcid><srcstatus/><internalId>861</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Read.Behaviour.SSOngoing</srcid><srcstatus/><internalId>872</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Switch_JobInterrupts_1_c4s</srcid><srcstatus/><internalId>1048</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_JobInterrupts_2_c4s</srcid><srcstatus/><internalId>1049</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_JobInterrupts_1_i4s</srcid><srcstatus/><internalId>1106</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_JobInterrupts_2_i4s</srcid><srcstatus/><internalId>1107</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_JobInterrupts_1_3s</srcid><srcstatus/><internalId>1180</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_Interruptions_02</srcid><srcstatus/><internalId>1184</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_Interruptions_03</srcid><srcstatus/><internalId>1185</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_Interruptions_04</srcid><srcstatus/><internalId>1186</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_JobInterrupts_1_4s</srcid><srcstatus/><internalId>1195</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_JobInterrupts_2</srcid><srcstatus/><internalId>1276</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>260</internalId></specobject>

        <specobject>
            <id>Fee.FailureHandling.Behaviour.ProductionError.FEE_E_FLASH_ACCESSIBLE</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                Fee shall provide optional parameter FEE_E_FLASH_ACCESSIBLE for enabling/disabling
                reporting of a production error in case the flash is not accessible (read, write access
                or erase) during an internal operation.
            </description>
            <comment>
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_743</srcid><srcstatus/><internalId>613</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_1637</srcid><srcstatus/><internalId>809</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Switch_Failures_c4s</srcid><srcstatus/><internalId>1040</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_Failures</srcid><srcstatus/><internalId>1075</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_Failures_i4s</srcid><srcstatus/><internalId>1098</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>261</internalId></specobject>

        <specobject>
            <id>Fee.FailureHandling.Behaviour.ProductionError.FEE_E_DATA_RECOVERED</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                Fee shall provide optional parameter FEE_E_DATA_RECOVERED for enabling/disabling
                reporting of a production error in case at startup Fee finds that no data can be 
                recovered from flash.
            </description>
            <comment>
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_1674</srcid><srcstatus/><internalId>810</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_StartUp_Inconsistent_Inconsistent</srcid><srcstatus/><internalId>1145</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>262</internalId></specobject>

        <specobject>
            <id>Fee.FailureHandling.Behaviour.Startup1.ProductionError</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                In case reporting of production errors is enabled and all section headers can not be
                read from the flash memory during initialization phase, Fee shall raise the production
                error FEE_E_FLASH_ACCESSIBLE to DEM.
            </description>
            <comment>
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_2416</srcid><srcstatus/><internalId>567</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Section_Refusals_S2</srcid><srcstatus/><internalId>1078</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>263</internalId></specobject>

        <specobject>
            <id>Fee.FailureHandling.Behaviour.ProductionError.Config</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                Fee shall offer a vendor specific parameter 'FeeProdErrorDetect'. This parameter
                enables or disables the detection of production errors.
            </description>
            <comment>
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_998</srcid><srcstatus/><internalId>789</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>264</internalId></specobject>

        <specobject>
            <id>Fee.JobNotification.InitCheck</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                The callback functions Fee_JobEndNotification and Fee_JobErrorNotification shall check if the
                module is not initialized.
                If this is the case, Fee_JobEndNotification and Fee_JobErrorNotification shall not change
                any job result.
            </description>
            <comment>
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee.c.m4_940</srcid><srcstatus/><internalId>428</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee.c.m4_958</srcid><srcstatus/><internalId>429</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_JobEndNotification</srcid><srcstatus/><internalId>1226</internalId></linkedfrom><linkedfrom><srcid>TS_FEE_JobErrorNotification</srcid><srcstatus/><internalId>1227</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>265</internalId></specobject>

        <specobject>
            <id>Fee.SectionEraseCounter</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                A section management object shall store the number of the erase operations performed so far 
                on all configured sections, in a counter represented on 32 bits.
            </description>
            <rationale>
                By reading this number you can determine the life of the flash, with approximation.
                This is done by dividing the highest counter value by the number of sections.
            </rationale>
            <comment>
                This number could be read by using a vendor specific API.
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/Fee_Internal_Types.h_108</srcid><srcstatus/><internalId>381</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_1978</srcid><srcstatus/><internalId>537</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_StartUp_Active_Active_WrongEraseCntCrc</srcid><srcstatus/><internalId>1152</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Fee.Dsn.Initialization.Startup1.Sections.04</srcid><srcstatus/><internalId>825</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Initialization.Startup1.Sections.12</srcid><srcstatus/><internalId>832</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Initialization.Startup2.04</srcid><srcstatus/><internalId>853</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>266</internalId></specobject>

        <specobject>
            <id>Fee.EraseCounter.API</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                Fee shall offer a vendor specific parameter 'FeeEraseCounter'. By enabling this parameter,
                Fee will provide the 'Fee_GetEraseCounterValue()' API, which returns an uint32 value
                representing the number of flash memory erase cycles for all the configured sections.
            </description>
            <comment>
                In order to statistically determine the amount of erase cycles for a section, the value
                could be divided by the number of configured sections.
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_1027</srcid><srcstatus/><internalId>790</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Ts_Fee_GetEraseCounter</srcid><srcstatus/><internalId>1018</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>267</internalId></specobject>
        
        <specobject>
            <id>Fee.FeeUseBlankCheck.Config</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                Fee shall offer a vendor specific configuration parameter 'FeeUseBlankCheck'.
                By enabling this configuration parameter, Fee shall use the API Fls_BlankCheck 
                in order to detemine whether an area is erased prior to reading it.
            </description>
            <comment>
                Fls_BlankCheck is only used as part of Fee startup and not for user read jobs.
                The reason for configuring this parameter is to avoid possible ECC errors while 
                trying to read an erased area.
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_1127</srcid><srcstatus/><internalId>793</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>268</internalId></specobject>

        <specobject>
            <id>Fee.ConsistencyPattern.Config</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                Fee shall offer a vendor specific configuration parameter 'FeeConsistencyPattern'.
                By enabling this configuration parameter, Fee shall use an additional data validation
                mechanism based on reading/writing consistency end patterns.
            </description>
            <comment>
                Enabling this parameter changes the flash memory layout.
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_1153</srcid><srcstatus/><internalId>794</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>269</internalId></specobject>

        <specobject>
            <id>Fee.ConsistencyPatterns.SectionHeader.Read.Startup</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                If the 'FeeConsistencyPattern' configuration parameter is enabled, Fee shall blank-check
                the pattern before reading it.
            </description>
            <comment>
                Reading blank data may result in ECC errors.
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_178</srcid><srcstatus/><internalId>468</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_259</srcid><srcstatus/><internalId>471</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Switch_RevalidateOldSection_c2s</srcid><srcstatus/><internalId>1031</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_RevalidateOldSection_i2s</srcid><srcstatus/><internalId>1090</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_RevalidateOldSection</srcid><srcstatus/><internalId>1262</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>270</internalId></specobject>

        <specobject>
            <id>Fee.ConsistencyPatterns.SectionHeader.Write</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                If the 'FeeConsistencyPattern' configuration parameter is enabled, after writing the section
                management object Fee shall also write the end pattern.
            </description>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Sections.c_378</srcid><srcstatus/><internalId>730</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Sections.c_506</srcid><srcstatus/><internalId>734</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Switch_RevalidateOldSection_c2s</srcid><srcstatus/><internalId>1031</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_RevalidateOldSection_i2s</srcid><srcstatus/><internalId>1090</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_RevalidateOldSection</srcid><srcstatus/><internalId>1262</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>271</internalId></specobject>
        
        <specobject>
            <id>Fee.ReadImmediate.Config</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                Fee shall offer a vendor specific configuration parameter 'FeeFlsReadApiType'.
                This parameter allows the user to select the Fls's read job API,
                between 'Fls_Read' and 'Fls_ReadImmediate'.
                This parameter deppends on enabling paramater 'FeeConsistencyPattern'.
            </description>
            <comment>
                The Flash drivers for RV40F technology use Fls_ReadImmediate for direct and much faster read.
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_1184</srcid><srcstatus/><internalId>795</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>272</internalId></specobject>

        <specobject>
            <id>Fee.FreezeActivities.API</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                Fee shall offer a vendor specific parameter 'FeeFreezeActivitiesApi'. By enabling this parameter,
                Fee will provide the 'Fee_FreezeActivities()' API, which shall freeze/unfreeze all the internal Fee
                activities.
            </description>
            <comment>
                If FEE_FreezeActivities API is called and the FEE module is not yet initialized, is shall return E_NOT_OK.
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Extra.c_56</srcid><srcstatus/><internalId>433</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_1066</srcid><srcstatus/><internalId>791</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Ts_Fee_FreezeActivities_NoInit</srcid><srcstatus/><internalId>1017</internalId></linkedfrom><linkedfrom><srcid>TS_FEE_30001</srcid><srcstatus/><internalId>1213</internalId></linkedfrom><linkedfrom><srcid>TS_FEE_30002</srcid><srcstatus/><internalId>1216</internalId></linkedfrom><linkedfrom><srcid>TS_FEE_30003</srcid><srcstatus/><internalId>1217</internalId></linkedfrom><linkedfrom><srcid>TS_FEE_30030</srcid><srcstatus/><internalId>1218</internalId></linkedfrom><linkedfrom><srcid>TS_FEE_30004</srcid><srcstatus/><internalId>1219</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>273</internalId></specobject>

        <specobject>
            <id>Fee.EnableAbortErase.NormalOperation</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                Fee shall offer a vendor specific parameter 'FeeEnableAbortErase'. If this parameter is enabled then 
                any write job for an immediate block will cause the abort of an erase operation, if in progress.
            </description>
            <comment>
                Write of immediate block is requested when Erase of section is in progress.
                If free space is available for the requested write block
                - If flash cancel API is available, then the write shall be processed immediately by
                cancelling the flash erase job.
                - If flash cancel API is not available, then the write shall be processed after the
                flash erase job is complete.

                Immediate Write requests have to be processed as soon as possible, this according to the
                AUTOSAR Standard. If the section switch can be interrupted by the Immediate Write then
                this means that there is sufficient available memory to process it. In this case, the
                Immediate Write request has to be given a higher priority than the switch.
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_1220</srcid><srcstatus/><internalId>797</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_AbortErase_DuringSwitch</srcid><srcstatus/><internalId>1019</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_AbortErase_NormalStartup2</srcid><srcstatus/><internalId>1021</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_AbortErase_DuringSwitch_i4s</srcid><srcstatus/><internalId>1112</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>274</internalId></specobject>

        <specobject>
            <id>Fee.EnableAbortErase.HighestInternalPriority</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                When Fee internal handling is in a state of highest internal priority for switch then the immediate writes
                are postponed and abort erase functionality shall not be done.
            </description>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Sections.c_559</srcid><srcstatus/><internalId>736</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_AbortErase_HighPrioritySwitch</srcid><srcstatus/><internalId>1020</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_AbortErase_HighestPrioStartup2</srcid><srcstatus/><internalId>1022</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_AbortErase_LeadsToHPSwitch</srcid><srcstatus/><internalId>1024</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_AbortErase_LeadsToHPStartup2</srcid><srcstatus/><internalId>1025</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>275</internalId></specobject>

        <specobject>
            <id>Fee.FeeCancelSectionErase.Config</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                Fee shall offer a vendor specific parameter 'FeeCancelSectionEraseApi'. By enabling this parameter,
                Fee will provide the 'Fee_CancelSectionErase()' API.
            </description>
            <comment>
                The feature is optional and deactivated by default.
                Dependency: Fls_Cancel API must be available.
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_1095</srcid><srcstatus/><internalId>792</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>276</internalId></specobject>

        <specobject>
            <id>Fee.FeeCancelSectionErase_Restart</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                Fee shall restart the section erase, if canceled, right after the delay timer expires 
                and behave as no cancellation has occured.
            </description>
            <comment>
            </comment>
            <needscoverage>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_CancelSectionErase_02</srcid><srcstatus/><internalId>1002</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>277</internalId></specobject>

        <specobject>
            <id>Fee.FeeCancelSectionErase.API</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                Fee shall provide a feature which synchronously cancels a section erase 
                at Fls level if ongoing by using 'Fee_CancelSectionErase()' API.
                Return value: 
                E_OK - the section erase was canceled.
                E_NOT_OK - the section erase was not canceled due to function being called during Fee_MainFunction 
                or while HighestInternalPriority was active OR erase was not ongoing.
            </description>
            <comment>
                The API Fee_CancelSectionErase() must not be called durring Fee main function execution.
                Otherwise it will only return E_NOT_OK and exit.
            </comment>
            <needscoverage>
                <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Fee.Dsn.CancelSectionErase</srcid><srcstatus/><internalId>870</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>278</internalId></specobject>

        <specobject>
            <id>Fee.FeeCriticalBlock.Config</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                Fee shall offer a vendor specific parameter 'FeeCriticalBlock'. This parameter is a reference
                to the configured immediate block that will operate as emergency block.
            </description>
            <comment>
                The feature is optional and deactivated by default.
                Dependencys: Fls_Cancel API must be available. The block must be immediate.
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_1439</srcid><srcstatus/><internalId>802</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>279</internalId></specobject>

        <specobject>
            <id>Fee.FeeCriticalBlock.CancelNvMJob</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                The write request for emergency block shall cancel any pending NvM write request,
                reporting failure to NvM, and accept the emergency write request.
            </description>
            <comment>
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_2556</srcid><srcstatus/><internalId>575</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_1338</srcid><srcstatus/><internalId>667</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Critical_InterfaceWithNvM</srcid><srcstatus/><internalId>1247</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>280</internalId></specobject>

        <specobject>
            <id>Fee.FeeCriticalBlock.Priority</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                The job of the write request for emergency block shall cancel any ongoing Fee operation
                and start writing the emergency block right away, once Fee has prepared the space 
                for this block at initialization.
            </description>
            <comment>
                The next Fee main function will start the critical write.
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_1560</srcid><srcstatus/><internalId>676</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Fee.Dsn.Critical.SectionChange</srcid><srcstatus/><internalId>946</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.Critical.CriticalSection</srcid><srcstatus/><internalId>948</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Critical_BehaviorAtStartUp_2s</srcid><srcstatus/><internalId>1028</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Critical_BehaviorAtStartUp_4s</srcid><srcstatus/><internalId>1037</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Critical_InterfaceWithNvM</srcid><srcstatus/><internalId>1247</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Critical_WriteTime_HP</srcid><srcstatus/><internalId>1248</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>281</internalId></specobject>

        <specobject>
            <id>Fee.FeeCriticalBlock.Cancel</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                The critical jobs, critical write and critical erase immediate, shall not be able to be canceled.
            </description>
            <comment>
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee.c.m4_597</srcid><srcstatus/><internalId>409</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Fee.Dsn.Critical.InterruptItself</srcid><srcstatus/><internalId>949</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Critical_BehaviorInIdle</srcid><srcstatus/><internalId>1245</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>282</internalId></specobject>

        <specobject>
            <id>Fee.FeeCriticalBlock.WriteFreeze</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                If the emergency block is successfully written, Fee shall freeze internaly.
            </description>
            <comment>
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee.c.m4_873</srcid><srcstatus/><internalId>425</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_284</srcid><srcstatus/><internalId>587</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Critical_ReadInIdle</srcid><srcstatus/><internalId>1035</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Critical_CriticalSectionS2</srcid><srcstatus/><internalId>1036</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Critical_BehaviorInIdle</srcid><srcstatus/><internalId>1245</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Critical_CriticalSection</srcid><srcstatus/><internalId>1246</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Critical_WriteTime_HP</srcid><srcstatus/><internalId>1248</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>283</internalId></specobject>

        <specobject>
            <id>Fee.FeeCriticalBlock.InitFreeze</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                If the emergency block is found consistent at initialization, Fee shall freeze internaly.
            </description>
            <comment>
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_2563</srcid><srcstatus/><internalId>576</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_2576</srcid><srcstatus/><internalId>578</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Critical_ReadInIdle</srcid><srcstatus/><internalId>1035</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>284</internalId></specobject>

        <specobject>
            <id>Fee.FeeCriticalBlock.StopBlockJobs</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                During Frozen state triggered by emergency block, Fee shall not accept any block jobs 
                except the Fee_EraseImmediateBlock and Fee_Read requests for emergency block.
            </description>
            <comment>
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee.c.m4_397</srcid><srcstatus/><internalId>399</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee.c.m4_504</srcid><srcstatus/><internalId>405</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee.c.m4_757</srcid><srcstatus/><internalId>419</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee.c.m4_872</srcid><srcstatus/><internalId>424</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Extra.c_104</srcid><srcstatus/><internalId>436</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Extra.c_332</srcid><srcstatus/><internalId>457</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_2569</srcid><srcstatus/><internalId>577</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Critical_ReadInIdle</srcid><srcstatus/><internalId>1035</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Critical_BehaviorInIdle</srcid><srcstatus/><internalId>1245</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Critical_FrozenState_HP</srcid><srcstatus/><internalId>1249</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>285</internalId></specobject>

        <specobject>
            <id>Fee.FeeCriticalBlock.ReadBlock</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                The read job for critical block comming durring frozen state shall leave Fee in frozen state 
                upon complition, successful or not.
            </description>
            <comment>
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_1636</srcid><srcstatus/><internalId>679</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Critical_ReadInIdle</srcid><srcstatus/><internalId>1035</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>286</internalId></specobject>

        <specobject>
            <id>Fee.FeeCriticalBlock.HealInternaly</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                The first erase immediate job for critical block, comming while Fee is internaly frozen, shall resume the Fee internal operations.
            </description>
            <comment>
                Fee naturaly provide space for another write job of the emergency block as soon as possible.
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_287</srcid><srcstatus/><internalId>588</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Fee.Dsn.Critical.ResumeFailed</srcid><srcstatus/><internalId>950</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Critical_FrozenState_HP</srcid><srcstatus/><internalId>1249</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>287</internalId></specobject>

        <specobject>
            <id>Fee.FeeCriticalBlock.Fail</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                If the emergency write is requested either a second time too soon and Fee could not recover enough space 
                or too early at initialization and Fee had no time to prepare the space, Fee will set the JobResult as MEMIF_JOB_FAILED, 
                and continue normal operations.           
            </description>
            <comment>
                The reason is that the emergency write job has to be processed imediately and, for example StartUp1 can not allow such treatment.
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_1538</srcid><srcstatus/><internalId>675</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Critical_CriticalSectionFail</srcid><srcstatus/><internalId>1027</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Critical_BehaviorAtStartUp_2s</srcid><srcstatus/><internalId>1028</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Critical_BehaviorAtStartUp_4s</srcid><srcstatus/><internalId>1037</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Critical_FrozenState_HP</srcid><srcstatus/><internalId>1249</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>288</internalId></specobject>

        <specobject>
            <id>Fee.FeeCriticalBlock.GetJobResult</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                Fee_GetJobResult API called after erasing the critical block shall set the job result to MEMIF_JOB_FAILED after 
                returning the erase immediate job result.
            </description>
            <comment>
                The reason is to report to NvM the failure of its job that was canceled by the critical block write.
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee.c.m4_707</srcid><srcstatus/><internalId>417</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Critical_InterfaceWithNvM</srcid><srcstatus/><internalId>1247</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>289</internalId></specobject>
        
        <specobject>
            <id>Fee.PreemptionProtection</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                Fee asynchronous APIs shall use protection mechanisms against interruptions with other asynchronous APIs.
            </description>
            <comment>
                The reason is to avoid overwriting jobs through call colision of standard 
                asynchronous APIs and vendor specific asynchronous APIs. (e.g. Fee_WriteCustom interrupting Fee_Read)
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_1911</srcid><srcstatus/><internalId>690</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_CustomWriteInterruptingWrite</srcid><srcstatus/><internalId>1113</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_CustomWriteInterruptingRead</srcid><srcstatus/><internalId>1114</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_CustomWriteInterruptingInvalidate</srcid><srcstatus/><internalId>1115</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_CustomWriteInterruptingEraseI</srcid><srcstatus/><internalId>1116</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_CustomReadInterruptingWrite</srcid><srcstatus/><internalId>1117</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_CustomReadInterruptingRead</srcid><srcstatus/><internalId>1118</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_CustomReadInterruptingInvalidate</srcid><srcstatus/><internalId>1119</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_CustomReadInterruptingEraseI</srcid><srcstatus/><internalId>1120</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_ReadInterruptingCustomWrite</srcid><srcstatus/><internalId>1121</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_ReadInterruptingCustomRead</srcid><srcstatus/><internalId>1122</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_WriteInterruptingCustomWrite</srcid><srcstatus/><internalId>1123</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_WriteInterruptingCustomRead</srcid><srcstatus/><internalId>1124</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_InvalidateInterruptingCustomWrite</srcid><srcstatus/><internalId>1125</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_InvalidateInterruptingCustomRead</srcid><srcstatus/><internalId>1126</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_EraseIInterruptingCustomWrite</srcid><srcstatus/><internalId>1127</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_EraseIInterruptingCustomRead</srcid><srcstatus/><internalId>1128</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations><ruleid>WRN.swuts.needscoverage.count</ruleid></oreqmViolations><covstatus>covered</covstatus><internalId>290</internalId></specobject>
        
        <specobject>
            <id>Fee.PreemptionProtection.DET</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                If a preemption occurs, FEE_E_PREEMPTION_OCCURED, shall be reported
                to DET.
            </description>
            <comment>
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee.c.m4_391</srcid><srcstatus/><internalId>398</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee.c.m4_498</srcid><srcstatus/><internalId>404</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee.c.m4_751</srcid><srcstatus/><internalId>418</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee.c.m4_866</srcid><srcstatus/><internalId>423</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Extra.c_98</srcid><srcstatus/><internalId>435</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Extra.c_326</srcid><srcstatus/><internalId>456</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_CustomWriteInterruptingWrite</srcid><srcstatus/><internalId>1113</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_CustomWriteInterruptingRead</srcid><srcstatus/><internalId>1114</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_CustomWriteInterruptingInvalidate</srcid><srcstatus/><internalId>1115</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_CustomWriteInterruptingEraseI</srcid><srcstatus/><internalId>1116</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_CustomReadInterruptingWrite</srcid><srcstatus/><internalId>1117</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_CustomReadInterruptingRead</srcid><srcstatus/><internalId>1118</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_CustomReadInterruptingInvalidate</srcid><srcstatus/><internalId>1119</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_CustomReadInterruptingEraseI</srcid><srcstatus/><internalId>1120</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_ReadInterruptingCustomWrite</srcid><srcstatus/><internalId>1121</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_ReadInterruptingCustomRead</srcid><srcstatus/><internalId>1122</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_WriteInterruptingCustomWrite</srcid><srcstatus/><internalId>1123</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_WriteInterruptingCustomRead</srcid><srcstatus/><internalId>1124</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_InvalidateInterruptingCustomWrite</srcid><srcstatus/><internalId>1125</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_InvalidateInterruptingCustomRead</srcid><srcstatus/><internalId>1126</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_EraseIInterruptingCustomWrite</srcid><srcstatus/><internalId>1127</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_EraseIInterruptingCustomRead</srcid><srcstatus/><internalId>1128</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations><ruleid>WRN.swuts.needscoverage.count</ruleid></oreqmViolations><covstatus>covered</covstatus><internalId>291</internalId></specobject>
    <specobject>
            <id>Fee.FeeDynamicBlockLength.Config</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                Fee shall offer a vendor specific general parameter 'FeeDynamicBlockLength'. If this parameter is true
                Fee will cache and switch also the blocks that are found with reconfigured size.
            </description>
            <comment>
                Extra (Total number of configured blocks * 2Bytes) RAM is required.
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_1468</srcid><srcstatus/><internalId>803</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_ReconfWrite</srcid><srcstatus/><internalId>1267</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_ReconfWriteSwitch</srcid><srcstatus/><internalId>1268</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_ReconfReadWrite</srcid><srcstatus/><internalId>1269</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_ReconfSwitchRead</srcid><srcstatus/><internalId>1270</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Fee.Dsn.DynamicBlockLength.Init</srcid><srcstatus/><internalId>952</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.DynamicBlockLength.Switch</srcid><srcstatus/><internalId>953</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>292</internalId></specobject>

        <specobject>
            <id>Fee.FeeDynamicBlockLength.IncreasedSizePedding</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                If a block is found reconfigured with a bigger size, when read Fee shall fill the difference in size with 
                the bitwise complement value of the last byte of data. (negated value)
            </description>
            <comment>
                Fee can only read the existing data in flash. In this case the data is smaller than what was requested by the user.
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Jobs.c_475</srcid><srcstatus/><internalId>715</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_ReconfReadWrite</srcid><srcstatus/><internalId>1269</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_ReconfSwitchRead</srcid><srcstatus/><internalId>1270</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>293</internalId></specobject>

        <specobject>
            <id>Fee.FeeDynamicBlockLength.IncreasedSizeResult</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                If a block is found reconfigured with a bigger size, the result of a successful read job 
                shall be set to MEMIF_JOB_OK_SIZE_INCREASED.
            </description>
            <comment>

            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Jobs.c_487</srcid><srcstatus/><internalId>716</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_ReconfReadWrite</srcid><srcstatus/><internalId>1269</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_ReconfSwitchRead</srcid><srcstatus/><internalId>1270</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>294</internalId></specobject>

        <specobject>
            <id>Fee.FeeDynamicBlockLength.DecreasedSizeResult</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                If a block is found reconfigured with a smaller size, the result of a successful read job 
                shall be set to MEMIF_JOB_OK_SIZE_DECREASED.
            </description>
            <comment>
                It should be obvious that in this case Fee will read only the length that was requested
                according to the current configuration.
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Jobs.c_456</srcid><srcstatus/><internalId>713</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_ReconfReadWrite</srcid><srcstatus/><internalId>1269</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_ReconfSwitchRead</srcid><srcstatus/><internalId>1270</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>295</internalId></specobject>

        <specobject>
            <id>Fee.FeeDynamicBlockLength.Write</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                Any write job for a reconfigured block shall be performed according to the current configuration.
            </description>
            <comment>

            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Jobs.c_584</srcid><srcstatus/><internalId>722</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_ReconfWrite</srcid><srcstatus/><internalId>1267</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_ReconfWriteSwitch</srcid><srcstatus/><internalId>1268</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>296</internalId></specobject>
        <specobject>
            <id>Fee.FeeEnableSmallSectionSize.Enable</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                Fee shall offer a vendor specific general parameter 'FeeEnableSmallSectionSize'. If this parameter is true
                Fee will allow configuring Fee sections with size less than the total size of the Fee Blocks. If more
                than 3 sections are configured.
            </description>
            <comment>

            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_1497</srcid><srcstatus/><internalId>804</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Switch_SmallSections</srcid><srcstatus/><internalId>1210</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_SmallSections_Retry</srcid><srcstatus/><internalId>1211</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>297</internalId></specobject>
        <specobject>
            <id>Fee.FeeEnableSmallSectionSize.Size</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                When FeeEnableSmallSectionSize is enabled. The size of half of the configured sections should be larger than the total
                size of the all the blocks.
            </description>
            <comment>

            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/src/Fee_Cfg.c_139</srcid><srcstatus/><internalId>369</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Switch_SmallSections</srcid><srcstatus/><internalId>1210</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_SmallSections_Retry</srcid><srcstatus/><internalId>1211</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>298</internalId></specobject>

        <specobject>
            <id>Fee.VendorInfixDriver.Support</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                The module shall support the use of third party flash driver with the vendorApiInfix and
                vendorId configured.
            </description>
            <comment>
                This requirment fullfils SWS_BSW_00101 and SWS_BSW_00102

            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/include/Fee_Cfg.h.m4_509</srcid><srcstatus/><internalId>355</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_VendorSpecificDriver</srcid><srcstatus/><internalId>984</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>299</internalId></specobject>
        <specobject>
            <id>Fee.FeeBufferCalculation.Enable</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                Fee shall offer a vendor specific boolean parameter 'FeeInitializeInLoop'.
                If TRUE Fee shall generate the smallest possible initialization buffer for 
                loop initialization.
            </description>
            <comment>

            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_502</srcid><srcstatus/><internalId>774</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>300</internalId></specobject>
        <specobject>
            <id>Fee.FeeBufferCalculation.SmallestBuffer</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                Fee shall shall generate the smallest possible value for the initialisation buffer when
                the configuration parameter 'FeeInitializeInLoop' is enabled.
            </description>
            <comment>

            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/include/Fee_Checks.m_389</srcid><srcstatus/><internalId>362</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_BufferCalculation</srcid><srcstatus/><internalId>1026</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>301</internalId></specobject>
        <specobject>
            <id>Fee.FeeBufferCalculation.DefaultBuffer</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                When the configuration parameter 'FeeBufferSize' is disabled the Fee module Shall calculate the internal
                buffer size as the minimum of largest configured Block and the maximum of 'FlsMaxWriteNormalMode' and
                'FlsMaxReadNormalMode'.
            </description>
            <comment>

            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/include/Fee_Checks.m_354</srcid><srcstatus/><internalId>360</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_BufferCalculation</srcid><srcstatus/><internalId>1026</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>302</internalId></specobject>
        <specobject>
            <id>Fee.FeeBufferCalculation.ConfiguredInitBuffer</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                When the configuration parameter 'FeeInitializationReadSize' is configured the Fee module shall
                use the configured value(truncated to be a multiple of Block Information Size) for the initialisation buffer.
            </description>
            <comment>

            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/include/Fee_Checks.m_393</srcid><srcstatus/><internalId>363</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_BufferCalculation</srcid><srcstatus/><internalId>1026</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>303</internalId></specobject>
        <specobject>
            <id>Fee.FeeBufferCalculation.InitBuffer</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                When the configuration parameters 'FeeInitializeInLoop' and 'FeeInitializationReadSize' are disabled the Fee module Shall calculate
                the initialisation buffer as the minimum of the internal buffer size and the maximum of
                the rounded down to block's management of 'FlsMaxReadFastMode' and the size of block's management.
            </description>
            <comment>

            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/include/Fee_Checks.m_386</srcid><srcstatus/><internalId>361</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_BufferCalculation</srcid><srcstatus/><internalId>1026</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>304</internalId></specobject>
        <specobject>
            <id>Fee.FeeImmediateSpaceReserved.Config</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                The configuration parameter FeeImmediateSpaceReserved shall define the number of bytes to be reserved for immediate blocks
                that can interrupt highest priority switch.
            </description>
            <comment>
                Type : uint16
                Range : 0 : (65535 - The configured blocks)
                Optional : TRUE (If the parameter is disabled Fee will not reserve space for immediate blocks)
                If FeeImmediateSpaceReserved is 0 Fee will reserve space for all the configured immediate blocks just once,
                otherwise the configured value is taken as is.
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_466</srcid><srcstatus/><internalId>772</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Fee.Dsn.ImmediateSpaceReserved.Runtime</srcid><srcstatus/><internalId>966</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.ImmediateSpaceReserved.Init</srcid><srcstatus/><internalId>967</internalId></linkedfrom><linkedfrom><srcid>Fee.Dsn.ImmediateSpaceReserved.Fail</srcid><srcstatus/><internalId>968</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Imm_HPNoReadAndErase</srcid><srcstatus/><internalId>1250</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>305</internalId></specobject>
        <specobject>
            <id>Fee.FeeImmediateSpaceReserved.Behavior</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                If an immediate write job is comming during highest priority internal operation Fee shall suspend the highest priority operation
                in a non-distructiv way as long as the space reserved for immediate blocks can accomodate the current immediate block,
                and perform the immediate job before resuming the highest priority internal operation.
            </description>
            <comment>
                If the reseved space left cannot acomodate the immediat block, the switch will carry on.
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_885</srcid><srcstatus/><internalId>627</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_1422</srcid><srcstatus/><internalId>670</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_1654</srcid><srcstatus/><internalId>680</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Sections.c_577</srcid><srcstatus/><internalId>739</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Imm_HPrioSwitchOk</srcid><srcstatus/><internalId>1251</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>306</internalId></specobject>
        <specobject>
            <id>Fee.FeeImmediateSpaceReserved.Restriction</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                Immediate space reserved feature is not compatible with Emergency block feature.
                They should not be configured together.
            </description>
            <comment>
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_495</srcid><srcstatus/><internalId>773</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>307</internalId></specobject>
        <specobject>
            <id>Fee.FeeMemAccUsage.Config</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                   The Fee shall provide a module specific boolean parameter named FeeMemAccUsage with parent container FeeGeneral
                to enable usage compatible with systems using MemAcc module.
                If this parameter is enabled, FeeBufferAlignmentValue is also enabled.
            </description>
            <comment>
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_1533</srcid><srcstatus/><internalId>805</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>308</internalId></specobject>
        <specobject>
            <id>Fee.FeeMemAccUsage.ApiCompliance</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                  When "FeeMemAccUsage" parameter is set to "True" the Fee module shall use the MemAcc module APIs to
                access flash services.
            </description>
            <comment>
                This applies for the following APIs :
                - MemAcc_Write
                - MemAcc_Read
                - MemAcc_GetJobResult
                - MemAcc_GetJobStatus
                - MemAcc_Cancel
                - MemAcc_Erase
                - MemAcc_BlankCheck
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/include/Fee_Cfg.h.m4_559</srcid><srcstatus/><internalId>356</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_MemAccApiCompliance</srcid><srcstatus/><internalId>989</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>309</internalId></specobject>
        <specobject>
            <id>Fee.FeeMemAccUsage.JobStatusCompatibility</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                  When "FeeMemAccUsage" parameter is set to "True" the Fee module shall reinterpret the
                MemAcc_GetJobStatus return "MEMACC_JOB_PENDING" as "MEMIF_BUSY".
            </description>
            <comment>
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_680</srcid><srcstatus/><internalId>609</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_MemAccJobResultCompatibility</srcid><srcstatus/><internalId>990</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>310</internalId></specobject>
        <specobject>
            <id>Fee.FeeMemAccUsage.GetJobResultCompatibility</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                  When "FeeMemAccUsage" parameter is set to "True" the Fee module shall reinterpret the
                MemAcc_GetJobResult return "MemAcc_JobResultType" into "MemIf_JobResultType".
            </description>
            <comment>
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_114</srcid><srcstatus/><internalId>580</internalId></linkedfrom></coveredby></needscov>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_MemAccJobResultCompatibility</srcid><srcstatus/><internalId>990</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>311</internalId></specobject>
        <specobject>
            <id>Fee.FeeMemAccUsage.BufferAlignmentValue</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                  When "FeeMemAccUsage" parameter is set to "True" the Fee module shall only support
                  'BufferAlignmentValue' parameters of value 1, 2,4 and 8 bytes..
            </description>
            <comment>
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_1557</srcid><srcstatus/><internalId>807</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>312</internalId></specobject>
        <specobject>
            <id>Fee.FeeMemAccUsage.DriverErasedValue</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                  When "FeeMemAccUsage" parameter is set to "True" the parameter 'FeeDriverErasedValue' shall define 
                the value the driver will return for erased cells.
            </description>
            <comment>
            </comment>
            <needscoverage>
                <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Fee.xdm.m4_1586</srcid><srcstatus/><internalId>808</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>313</internalId></specobject>
        <specobject>
            <id>Fee.Sections.ManualConfiguration.Validate</id>
            <status>approved</status>
            <source>EB</source>
            <version>1</version>
            <description>
                If the sections are manually configured and if, considering the values of the parameters
                FeeSectionStartAddress and FeeSectionSize, the sections overlap, an error must be reported.
            </description>
            <comment>
            </comment>
            <needscoverage>
                <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Fee_GenTest_02_Sections_not_consistent</srcid><srcstatus/><internalId>988</internalId></linkedfrom></coveredby></needscov>
            <containerCovstatus>covered</containerCovstatus></needscoverage>
        <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>314</internalId></specobject>
    </specobjects>
    <specobjects doctype="man">
    <specobject>
      <id>TS_Fee_ResourceConsumption</id>
      <status>approved</status>
      <source>EB manual test</source>
      <version>1</version>
      <description>
        01: Get RAM/ROM consumption of Fee_ComTest_ResourceConsumption
        02 VP(Fee.swdd.ROMConsumption_RefCfg1): Check the ROM consumption of
           the test run against the threshold specified in the requirement.
        03 VP(Fee.swdd.RAMConsumption_RefCfg1): Check the RAM consumption of
           the test run against the threshold specified in the requirement.
        Action if test any verification point is not fulfilled:
        If the consumption exceeds the threshold, an analysis shall be started to find the cause
        of the additional resource consumption.
        The result of the analysis shall trigger either:
        * an update of the resource view in the design and the existing threshold if there is a
          rationale for the additional resource consumption.
        OR
        * measurements to reduce the additional resource consumption below the existing threshold
          if there is no rationale for the additional resource consumption.
      </description>
      <providescoverage>
        <provcov>
          <linksto>Fee.swdd.ROMConsumption_RefCfg1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>969</internalId></provcov>
        <provcov>
          <linksto>Fee.swdd.RAMConsumption_RefCfg1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>970</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>315</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs">

    <specobject>
      <id>Fee.EB.DBGINST001</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Every public API of the module shall have debug instrumentation.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_DBGINST_001</srcid><srcstatus/><internalId>971</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>316</internalId></specobject>

    <specobject>
      <id>Fee.EB.DBGINST002</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The parameter of a API shall be available in the entry instrumentation.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_DBGINST_001</srcid><srcstatus/><internalId>971</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>317</internalId></specobject>

    <specobject>
      <id>Fee.EB.DBGINST003</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The parameter of a API shall be available in the exit instrumentation.
        If the API has a return value, the very first parameter of the macro shall contain the expected return value.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_DBGINST_001</srcid><srcstatus/><internalId>971</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>318</internalId></specobject>

    <specobject>
      <id>Fee.EB.DBGINST004</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The default implementation of the debug instrumentation shall be an empty macro.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_DBGINST_001</srcid><srcstatus/><internalId>971</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>319</internalId></specobject>

    <specobject>
      <id>Fee.EB.DBGINST005</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The module shall include the header files Base_Dbg.h in order to allow changing the default implementation of the debug instrumentation.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_DBGINST_001</srcid><srcstatus/><internalId>971</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>320</internalId></specobject>

  </specobjects>
    <specobjects doctype="swurs">

    <specobject>
      <id>Fee.EB.Interface.Consistency</id>
       <status>approved</status>
       <source>EB</source>
       <version>1</version>
       <description>
        The module shall provide a mechanism to guarantee consistency of interfaces and
        types between its implementation and its code stub.
       </description>
       <comment>
        The code stub of a module shall provide the same external view than the module itself.
        This is mandatory because unit test of modules test against the code stubs of
        adjacent modules. Inconsistent stubs may result in the situation that incompatible
        interfaces are not detected as unit test stage.
       </comment>
       <verifycrit>
        Create a compile test with two permutations that call all interfaces of a module
        (in both permutations).
        p0: Behave like a regular compile test; call the module generator and compile against
        the implementation of the module.
        p1: Do not generate module code and do not compile the implementation of the module.
        Instead the module shall be replaced with its own code stub.
       </verifycrit>
       <needscoverage>
          <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_VerifyCodeStub</srcid><srcstatus/><internalId>972</internalId></linkedfrom></coveredby></needscov>
       <containerCovstatus>covered</containerCovstatus></needscoverage>
       
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>321</internalId></specobject>

  </specobjects>
    <specobjects doctype="dev">
    <specobject>
      <id>dev.Fee.NoSupportForDebugging</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>103</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00130</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>45</internalId></provcov>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00131</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>46</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>322</internalId></specobject>
    <specobject>
      <id>dev.Fee.Fee_WriteDataBufferPtrType</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>123</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Fee_Write.DataBufferPtr.type</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>209</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>323</internalId></specobject>
    <specobject>
      <id>doc/public/changelog/Deviations.xml_147</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>147</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00179</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>65</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>324</internalId></specobject>
    <specobject>
      <id>doc/public/changelog/Deviations.xml_148</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>148</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00180</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>66</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>325</internalId></specobject>
    <specobject>
      <id>doc/public/changelog/Deviations.xml_149</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>149</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00181</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>67</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>326</internalId></specobject>
    <specobject>
      <id>dev.Fee.Fee_InternalOperationManagement</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>150</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00182</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>68</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>327</internalId></specobject>
    <specobject>
      <id>dev.Fee.Fee_BlockDataInterrupted</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>167</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00153</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>164</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>328</internalId></specobject>
    <specobject>
      <id>dev.Fee.Fee_BlankCheckEnable</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>185</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00187</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>185</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>329</internalId></specobject>
    <specobject>
      <id>dev.Fee.Fee_BlankCheckAsync</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>200</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00187</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>185</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>330</internalId></specobject>
    <specobject>
      <id>doc/public/changelog/Deviations.xml_215</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>215</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.ECUC_Fee_00157</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>195</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>331</internalId></specobject>
    <specobject>
      <id>dev.Fee.Fee_MemAccUsage</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>216</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.ECUC_Fee_00155</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>193</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>332</internalId></specobject>
    <specobject>
      <id>doc/public/changelog/Deviations.xml_231</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>231</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00184</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>182</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>333</internalId></specobject>
    <specobject>
      <id>doc/public/changelog/Deviations.xml_232</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>232</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00170</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>179</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>334</internalId></specobject>
    <specobject>
      <id>doc/public/changelog/Deviations.xml_233</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>233</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00144</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>160</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>335</internalId></specobject>
    <specobject>
      <id>doc/public/changelog/Deviations.xml_234</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>234</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00145</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>161</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>336</internalId></specobject>
    <specobject>
      <id>doc/public/changelog/Deviations.xml_235</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>235</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00146</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>162</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>337</internalId></specobject>
    <specobject>
      <id>dev.Fee.Fee_RuntimeErrors</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>236</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00133</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>149</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>338</internalId></specobject>
    <specobject>
      <id>doc/public/changelog/Deviations.xml_251</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>251</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00136</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>152</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>339</internalId></specobject>
    <specobject>
      <id>doc/public/changelog/Deviations.xml_252</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>252</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00139</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>340</internalId></specobject>
    <specobject>
      <id>doc/public/changelog/Deviations.xml_253</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>253</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00147</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>163</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>341</internalId></specobject>
    <specobject>
      <id>dev.Fee.Fee_InvalildDataPointer</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>254</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00010</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>93</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>342</internalId></specobject>
    <specobject>
      <id>dev.Fee.Fee_Initfinished</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>269</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00169</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>178</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>343</internalId></specobject>
    <specobject>
      <id>doc/public/changelog/Deviations.xml_287</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>287</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00085</linksto>
          <dstversion>3</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>122</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>344</internalId></specobject>
    <specobject>
      <id>dev.Fee.Fee_PostBuild</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>288</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00188</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>186</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>345</internalId></specobject>
    <specobject>
      <id>dev.Fee.Fee_BufferAlign</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>303</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00195</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>197</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>346</internalId></specobject>
    <specobject>
      <id>doc/public/changelog/Deviations.xml_318</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>318</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00196</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>198</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>347</internalId></specobject>
    <specobject>
      <id>dev.Fee.Fee_ReadAlign</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>319</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.ECUC_Fee_00156</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>194</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>348</internalId></specobject>
    <specobject>
      <id>dev.Fee.Fee_JobEndNotification</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>334</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00194</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>196</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>349</internalId></specobject>
    <specobject>
      <id>dev.Fee.Fee_ModeChange</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>349</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00191</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>188</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>350</internalId></specobject>
    <specobject>
      <id>dev.Fee.ImmediateData</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>381</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00009</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>351</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/generate/include/Fee_Cfg.h.m4_9</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/generate/include/Fee_Cfg.h.m4</sourcefile>
      <sourceline>9</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00084</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>22</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>352</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate/include/Fee_Cfg.h.m4_14</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/generate/include/Fee_Cfg.h.m4</sourcefile>
      <sourceline>14</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00084</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>22</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>353</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate/include/Fee_Cfg.h.m4_23</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/generate/include/Fee_Cfg.h.m4</sourcefile>
      <sourceline>23</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>22</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>354</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate/include/Fee_Cfg.h.m4_509</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/generate/include/Fee_Cfg.h.m4</sourcefile>
      <sourceline>509</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.VendorInfixDriver.Support</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>299</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>355</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate/include/Fee_Cfg.h.m4_559</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/generate/include/Fee_Cfg.h.m4</sourcefile>
      <sourceline>559</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeMemAccUsage.ApiCompliance</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>309</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>356</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/generate/include/Fee_Checks.m_193</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/generate/include/Fee_Checks.m</sourcefile>
      <sourceline>193</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Sections.NumberOfSections.Validate</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>226</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>357</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate/include/Fee_Checks.m_267</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/generate/include/Fee_Checks.m</sourcefile>
      <sourceline>267</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Configuration.TotalBlocksSize</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>231</internalId></provcov>
        <provcov>
          <linksto>Fee.Configuration.TotalBlocksSize.SwitchNotConfiguredBlocks</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>232</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>358</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate/include/Fee_Checks.m_325</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/generate/include/Fee_Checks.m</sourcefile>
      <sourceline>325</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Configuration.FeeBuffer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>218</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>359</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate/include/Fee_Checks.m_354</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/generate/include/Fee_Checks.m</sourcefile>
      <sourceline>354</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeBufferCalculation.DefaultBuffer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>302</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>360</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate/include/Fee_Checks.m_386</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/generate/include/Fee_Checks.m</sourcefile>
      <sourceline>386</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeBufferCalculation.InitBuffer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>304</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>361</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate/include/Fee_Checks.m_389</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/generate/include/Fee_Checks.m</sourcefile>
      <sourceline>389</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeBufferCalculation.SmallestBuffer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>301</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>362</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate/include/Fee_Checks.m_393</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/generate/include/Fee_Checks.m</sourcefile>
      <sourceline>393</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeBufferCalculation.ConfiguredInitBuffer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>303</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>363</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/generate/src/Fee_Cfg.c_4</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/generate/src/Fee_Cfg.c</sourcefile>
      <sourceline>4</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00084</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>364</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate/src/Fee_Cfg.c_31</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/generate/src/Fee_Cfg.c</sourcefile>
      <sourceline>31</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Sections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>365</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate/src/Fee_Cfg.c_32</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/generate/src/Fee_Cfg.c</sourcefile>
      <sourceline>32</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00071</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>114</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00103</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>137</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>366</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate/src/Fee_Cfg.c_33</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/generate/src/Fee_Cfg.c</sourcefile>
      <sourceline>33</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Sections.Generation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>227</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>367</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate/src/Fee_Cfg.c_125</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/generate/src/Fee_Cfg.c</sourcefile>
      <sourceline>125</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Configuration.TotalBlocksSize</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>231</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>368</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate/src/Fee_Cfg.c_139</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/generate/src/Fee_Cfg.c</sourcefile>
      <sourceline>139</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeEnableSmallSectionSize.Size</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>298</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>369</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate/src/Fee_Cfg.c_184</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/generate/src/Fee_Cfg.c</sourcefile>
      <sourceline>184</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00005</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>89</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>370</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/include/Fee.h.m4_6</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/include/Fee.h.m4</sourcefile>
      <sourceline>6</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00084</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>22</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>371</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/Fee.h.m4_8</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/include/Fee.h.m4</sourcefile>
      <sourceline>8</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>22</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>372</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/include/Fee_Cbk.h_38</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/include/Fee_Cbk.h</sourcefile>
      <sourceline>38</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00069</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>36</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>373</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/Fee_Cbk.h_49</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/include/Fee_Cbk.h</sourcefile>
      <sourceline>49</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00069</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>36</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>374</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/include/Fee_Initialization.h_21</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/include/Fee_Initialization.h</sourcefile>
      <sourceline>21</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00084</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>22</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>375</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/include/Fee_Internal.h.m4_22</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/include/Fee_Internal.h.m4</sourcefile>
      <sourceline>22</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00084</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>22</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>376</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/Fee_Internal.h.m4_30</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/include/Fee_Internal.h.m4</sourcefile>
      <sourceline>30</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00048</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>29</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>377</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/Fee_Internal.h.m4_190</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/include/Fee_Internal.h.m4</sourcefile>
      <sourceline>190</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Critical.ResumeFailed</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>950</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>378</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/Fee_Internal.h.m4_543</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/include/Fee_Internal.h.m4</sourcefile>
      <sourceline>543</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.DynamicBlockLength.Switch</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>953</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>379</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/include/Fee_Internal_Types.h_67</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/include/Fee_Internal_Types.h</sourcefile>
      <sourceline>67</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.GlobalVariables</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>213</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>380</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/Fee_Internal_Types.h_108</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/include/Fee_Internal_Types.h</sourcefile>
      <sourceline>108</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SectionEraseCounter</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>266</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>381</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/include/Fee_Jobs.h_21</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/include/Fee_Jobs.h</sourcefile>
      <sourceline>21</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00084</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>22</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>382</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/include/Fee_Sections.h_21</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/include/Fee_Sections.h</sourcefile>
      <sourceline>21</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00084</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>22</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>383</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/Fee_Sections.h_23</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/include/Fee_Sections.h</sourcefile>
      <sourceline>23</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00084</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>22</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>384</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/include/Fee_SectionsSwitch.h_21</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/include/Fee_SectionsSwitch.h</sourcefile>
      <sourceline>21</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00084</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>22</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>385</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/Fee_SectionsSwitch.h_23</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/include/Fee_SectionsSwitch.h</sourcefile>
      <sourceline>23</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00084</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>22</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>386</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/include/Fee_Version.h.m4_2</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/include/Fee_Version.h.m4</sourcefile>
      <sourceline>2</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00185</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>71</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>387</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/src/Fee.c.m4_15</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee.c.m4</sourcefile>
      <sourceline>15</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>22</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>388</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee.c.m4_54</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee.c.m4</sourcefile>
      <sourceline>54</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.MainFunction.InitCheck</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>210</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>389</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee.c.m4_68</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee.c.m4</sourcefile>
      <sourceline>68</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.GlobalVariables</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>213</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>390</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee.c.m4_191</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee.c.m4</sourcefile>
      <sourceline>191</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Idle</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>860</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>391</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee.c.m4_255</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee.c.m4</sourcefile>
      <sourceline>255</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.CacheInit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>839</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>392</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee.c.m4_258</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee.c.m4</sourcefile>
      <sourceline>258</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInconsistent.01</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>845</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>393</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee.c.m4_310</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee.c.m4</sourcefile>
      <sourceline>310</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.SectionMarkers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>955</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>394</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee.c.m4_313</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee.c.m4</sourcefile>
      <sourceline>313</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.02</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>823</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>395</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee.c.m4_349</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee.c.m4</sourcefile>
      <sourceline>349</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Mode.DET</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>212</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>396</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee.c.m4_354</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee.c.m4</sourcefile>
      <sourceline>354</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00190</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>187</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>397</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee.c.m4_391</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee.c.m4</sourcefile>
      <sourceline>391</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.PreemptionProtection.DET</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>291</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>398</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee.c.m4_397</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee.c.m4</sourcefile>
      <sourceline>397</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeCriticalBlock.StopBlockJobs</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>285</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>399</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee.c.m4_408</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee.c.m4</sourcefile>
      <sourceline>408</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Initializaion.UserJobRequests</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>258</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>400</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee.c.m4_409</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee.c.m4</sourcefile>
      <sourceline>409</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00022</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>96</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>401</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee.c.m4_410</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee.c.m4</sourcefile>
      <sourceline>410</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00172</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>180</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>402</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee.c.m4_419</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee.c.m4</sourcefile>
      <sourceline>419</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00172</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>180</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>403</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee.c.m4_498</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee.c.m4</sourcefile>
      <sourceline>498</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.PreemptionProtection.DET</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>291</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>404</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee.c.m4_504</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee.c.m4</sourcefile>
      <sourceline>504</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeCriticalBlock.StopBlockJobs</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>285</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>405</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee.c.m4_508</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee.c.m4</sourcefile>
      <sourceline>508</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Critical.InterruptItself</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>949</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>406</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee.c.m4_531</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee.c.m4</sourcefile>
      <sourceline>531</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00174</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>181</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>407</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee.c.m4_567</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee.c.m4</sourcefile>
      <sourceline>567</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00025</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>99</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>408</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee.c.m4_597</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee.c.m4</sourcefile>
      <sourceline>597</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeCriticalBlock.Cancel</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>282</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>409</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee.c.m4_618</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee.c.m4</sourcefile>
      <sourceline>618</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Startup1.Cancel.NoRequest</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>937</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>410</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee.c.m4_619</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee.c.m4</sourcefile>
      <sourceline>619</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Startup2.Cancel.NoRequest</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>939</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>411</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee.c.m4_620</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee.c.m4</sourcefile>
      <sourceline>620</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Cancel.Behaviour.NoJobPending</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>885</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>412</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee.c.m4_621</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee.c.m4</sourcefile>
      <sourceline>621</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Cancel.Behaviour.InternalOperations</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>891</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>413</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee.c.m4_628</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee.c.m4</sourcefile>
      <sourceline>628</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Cancel.Behaviour.ReportNvm</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>892</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>414</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee.c.m4_652</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee.c.m4</sourcefile>
      <sourceline>652</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.GetStatus.InitCheck</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>211</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>415</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee.c.m4_668</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee.c.m4</sourcefile>
      <sourceline>668</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00074</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>116</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>416</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee.c.m4_707</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee.c.m4</sourcefile>
      <sourceline>707</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeCriticalBlock.GetJobResult</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>289</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>417</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee.c.m4_751</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee.c.m4</sourcefile>
      <sourceline>751</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.PreemptionProtection.DET</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>291</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>418</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee.c.m4_757</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee.c.m4</sourcefile>
      <sourceline>757</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeCriticalBlock.StopBlockJobs</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>285</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>419</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee.c.m4_769</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee.c.m4</sourcefile>
      <sourceline>769</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00126</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>145</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>420</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee.c.m4_778</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee.c.m4</sourcefile>
      <sourceline>778</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00145</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>52</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>421</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee.c.m4_799</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee.c.m4</sourcefile>
      <sourceline>799</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00192</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>422</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee.c.m4_866</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee.c.m4</sourcefile>
      <sourceline>866</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.PreemptionProtection.DET</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>291</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>423</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee.c.m4_872</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee.c.m4</sourcefile>
      <sourceline>872</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeCriticalBlock.StopBlockJobs</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>285</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>424</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee.c.m4_873</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee.c.m4</sourcefile>
      <sourceline>873</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeCriticalBlock.WriteFreeze</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>283</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>425</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee.c.m4_885</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee.c.m4</sourcefile>
      <sourceline>885</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00127</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>146</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>426</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee.c.m4_894</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee.c.m4</sourcefile>
      <sourceline>894</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00146</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>53</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>427</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee.c.m4_940</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee.c.m4</sourcefile>
      <sourceline>940</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.JobNotification.InitCheck</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>265</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>428</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee.c.m4_958</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee.c.m4</sourcefile>
      <sourceline>958</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.JobNotification.InitCheck</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>265</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>429</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee.c.m4_974</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee.c.m4</sourcefile>
      <sourceline>974</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00097</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>134</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>430</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee.c.m4_977</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee.c.m4</sourcefile>
      <sourceline>977</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.MainFunction.InitCheck</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>210</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>431</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee.c.m4_992</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee.c.m4</sourcefile>
      <sourceline>992</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00057</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>110</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>432</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/src/Fee_Extra.c_56</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Extra.c</sourcefile>
      <sourceline>56</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FreezeActivities.API</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>273</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>433</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Extra.c_77</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Extra.c</sourcefile>
      <sourceline>77</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeWriteCustom</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>238</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>434</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Extra.c_98</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Extra.c</sourcefile>
      <sourceline>98</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.PreemptionProtection.DET</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>291</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>435</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Extra.c_104</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Extra.c</sourcefile>
      <sourceline>104</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeCriticalBlock.StopBlockJobs</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>285</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>436</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Extra.c_116</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Extra.c</sourcefile>
      <sourceline>116</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeWriteCustom.UninitOrBusy</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>239</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>437</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Extra.c_119</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Extra.c</sourcefile>
      <sourceline>119</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeWriteCustom.Det.Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>241</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>438</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Extra.c_127</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Extra.c</sourcefile>
      <sourceline>127</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeWriteCustom.UninitOrBusy</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>239</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>439</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Extra.c_130</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Extra.c</sourcefile>
      <sourceline>130</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeWriteCustom.Det.Busy</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>242</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>440</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Extra.c_140</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Extra.c</sourcefile>
      <sourceline>140</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeWriteCustom.Det.BlockNumber.Invalid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>243</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>441</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Extra.c_146</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Extra.c</sourcefile>
      <sourceline>146</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeWriteCustom.Det.DataPointer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>245</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>442</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Extra.c_156</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Extra.c</sourcefile>
      <sourceline>156</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeWriteCustom.ConfiguredBlock</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>240</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>443</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Extra.c_159</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Extra.c</sourcefile>
      <sourceline>159</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeWriteCustom.Det.BlockNumber.ConfiguredBlock</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>244</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>444</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Extra.c_166</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Extra.c</sourcefile>
      <sourceline>166</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.SwitchNotConfiguredBlocks</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>842</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>445</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Extra.c_167</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Extra.c</sourcefile>
      <sourceline>167</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInfos.02</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>837</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>446</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Extra.c_168</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Extra.c</sourcefile>
      <sourceline>168</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlocksSearchStop.SwNotConfigBlocksON</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>848</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>447</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Extra.c_198</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Extra.c</sourcefile>
      <sourceline>198</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeWriteCustom.Det.BlockSize</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>246</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>448</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Extra.c_207</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Extra.c</sourcefile>
      <sourceline>207</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeWriteCustom.Det.BlockSize</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>246</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>449</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Extra.c_216</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Extra.c</sourcefile>
      <sourceline>216</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.WriteCustom.TooManyBlocks</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>869</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>450</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Extra.c_246</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Extra.c</sourcefile>
      <sourceline>246</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeWriteCustom.Det.BlockSize</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>246</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>451</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Extra.c_264</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Extra.c</sourcefile>
      <sourceline>264</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeWriteCustom.Det.BlockSize</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>246</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>452</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Extra.c_278</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Extra.c</sourcefile>
      <sourceline>278</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00025</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>99</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>453</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Extra.c_303</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Extra.c</sourcefile>
      <sourceline>303</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeReadCustom</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>248</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>454</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Extra.c_313</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Extra.c</sourcefile>
      <sourceline>313</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00172</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>180</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>455</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Extra.c_326</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Extra.c</sourcefile>
      <sourceline>326</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.PreemptionProtection.DET</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>291</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>456</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Extra.c_332</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Extra.c</sourcefile>
      <sourceline>332</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeCriticalBlock.StopBlockJobs</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>285</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>457</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Extra.c_341</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Extra.c</sourcefile>
      <sourceline>341</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeReadCustom.UninitOrBusy</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>249</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>458</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Extra.c_346</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Extra.c</sourcefile>
      <sourceline>346</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeReadCustom.Det.Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>251</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>459</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Extra.c_355</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Extra.c</sourcefile>
      <sourceline>355</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeReadCustom.Det.Busy</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>252</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>460</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Extra.c_366</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Extra.c</sourcefile>
      <sourceline>366</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeReadCustom.Det.DataPointer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>254</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>461</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Extra.c_375</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Extra.c</sourcefile>
      <sourceline>375</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeReadCustom.BlockNumber</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>250</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>462</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Extra.c_383</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Extra.c</sourcefile>
      <sourceline>383</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeReadCustom.Det.BlockNumber</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>253</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>463</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Extra.c_398</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Extra.c</sourcefile>
      <sourceline>398</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeReadCustom.Det.WrongOffset</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>256</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>464</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Extra.c_407</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Extra.c</sourcefile>
      <sourceline>407</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeReadCustom.Det.WrongLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>255</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>465</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Extra.c_437</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Extra.c</sourcefile>
      <sourceline>437</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.CancelSectionErase</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>870</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>466</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_21</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>21</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00060</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>31</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>467</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_178</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>178</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.ConsistencyPatterns.SectionHeader.Read.Startup</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>270</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>468</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_183</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>183</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.SectionManagement</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>954</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>469</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_232</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>232</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.SectionManagementRefused</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>956</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>470</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_259</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>259</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.ConsistencyPatterns.SectionHeader.Read.Startup</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>270</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>471</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_268</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>268</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.SectionManagement</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>954</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>472</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_317</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>317</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.06</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>826</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>473</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_330</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>330</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.SectionManagementRefused</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>956</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>474</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_356</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>356</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.SectionMarkers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>955</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>475</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_390</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>390</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.ActiveRefused</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>958</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>476</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_425</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>425</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.SectionMarkers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>955</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>477</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_459</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>459</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.ActiveRefused</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>958</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>478</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_494</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>494</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.SectionMarkers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>955</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>479</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_527</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>527</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.ErasableRefused</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>957</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>480</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_562</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>562</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.SectionMarkers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>955</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>481</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_595</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>595</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.ErasableRefused</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>957</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>482</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_682</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>682</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.FailureHandling.Behaviour.Startup1.HeaderFailed</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>921</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>483</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_747</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>747</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.06</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>826</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>484</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_754</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>754</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.Startup1.FooterFailed</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>922</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>485</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_779</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>779</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.FillCacheWithBlockInfos</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>840</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>486</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_827</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>827</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.FlashRead.BlockInfos.Fails</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>919</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>487</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_902</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>902</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.FlashRead.BlockInfoByBlockInfo.Fails</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>920</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>488</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_906</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>906</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.InvalidLastBlockInfos</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>843</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>489</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_939</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>939</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.WrittenMarker</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>959</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>490</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_968</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>968</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.WrittenMarkerBlank</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>960</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>491</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_983</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>983</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.FlashRead.BlockInfoByBlockInfo.Fails</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>920</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>492</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_985</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>985</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.InvalidLastBlockInfos</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>843</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>493</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_1014</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>1014</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.BlockStamp</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>961</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>494</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_1093</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>1093</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.FlashRead.BlockInfoByBlockInfo.Fails</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>920</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>495</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_1095</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>1095</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.InvalidLastBlockInfos</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>843</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>496</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_1108</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>1108</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.BlockStamp</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>961</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>497</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_1154</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>1154</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.BlockStampBlank</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>962</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>498</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_1167</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>1167</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.FlashRead.BlockInfoByBlockInfo.Fails</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>920</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>499</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_1171</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>1171</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.InvalidLastBlockInfos</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>843</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>500</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_1205</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>1205</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.02</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>823</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>501</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_1230</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>1230</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.WrittenMarker</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>959</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>502</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_1233</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>1233</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInfos.01</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>836</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>503</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_1278</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>1278</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.WrittenMarker</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>959</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>504</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_1306</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>1306</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInfoValidity.SwitchNotConfiguredBlocksON</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>819</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>505</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_1307</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>1307</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInfoValidity.SwitchNotConfiguredBlocksOFF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>818</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>506</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_1355</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>1355</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInfoValidity.SwitchNotConfiguredBlocksOFF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>818</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>507</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_1356</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>1356</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInfoValidity.SwitchNotConfiguredBlocksON</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>819</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>508</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_1357</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>1357</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInconsistent.02</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>846</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>509</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_1385</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>1385</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.SwitchNotConfiguredBlocks</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>842</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>510</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_1386</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>1386</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInfos.02</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>837</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>511</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_1387</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>1387</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlocksSearchStop.SwNotConfigBlocksON</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>848</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>512</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_1416</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>1416</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeNumberOfNotConfigBlocks.BlocksLost</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>234</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>513</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_1455</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>1455</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeNumberOfNotConfigBlocks.BlocksLost</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>234</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>514</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_1485</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>1485</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.InvalidLastBlockInfos</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>843</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>515</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_1510</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>1510</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlocksSearchStop.SwNotConfigBlocksOFF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>847</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>516</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_1517</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>1517</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInfoFound</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>844</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>517</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_1532</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>1532</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInfoCacheIfNewer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>849</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>518</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_1541</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>1541</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeNotConfigBlocks.SizeReconfigured</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>236</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>519</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_1603</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>1603</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInfoValidity.WrittenMarker</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>820</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>520</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_1604</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>1604</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInfoValidity.WrittenMarkerValidity</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>821</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>521</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_1605</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>1605</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInfoValidity.SwitchNotConfiguredBlocksOFF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>818</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>522</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_1606</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>1606</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInfoValidity.SwitchNotConfiguredBlocksON</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>819</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>523</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_1631</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>1631</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.DynamicBlockLength.Init</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>524</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_1661</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>1661</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInfosSearch</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>841</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>525</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_1735</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>1735</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.FillCacheWithBlockInfos</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>840</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>526</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_1850</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>1850</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.ImmediateSpaceReserved.Init</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>967</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>527</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_1870</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>1870</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInfos.03</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>838</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>528</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_1894</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>1894</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlocksSearchStop.SwNotConfigBlocksOFF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>847</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>529</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_1897</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>1897</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlocksSearchStop.SwNotConfigBlocksON</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>848</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>530</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_1904</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>1904</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlocksSearchStop.SwNotConfigBlocksOFF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>847</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>531</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_1916</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>1916</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.WrittenMarker</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>959</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>532</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_1957</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>1957</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.01</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>822</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>533</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_1965</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>1965</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.03</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>824</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>534</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_1973</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>1973</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.04</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>825</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>535</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_1974</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>1974</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Sections.HeaderSecured</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>228</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>536</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_1978</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>1978</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SectionEraseCounter</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>266</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>537</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_1979</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>1979</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.12</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>832</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>538</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_2015</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>2015</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.06</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>826</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>539</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_2036</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>2036</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.08</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>828</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>540</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_2055</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>2055</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.07</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>827</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>541</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_2082</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>2082</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.MarkerValidity</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>817</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>542</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_2103</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>2103</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.MarkerValidity</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>817</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>543</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_2124</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>2124</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.MarkerValidity</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>817</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>544</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_2145</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>2145</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.MarkerValidity</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>817</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>545</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_2166</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>2166</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.03</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>824</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>546</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_2167</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>2167</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.Startup1.BothSectionManagementObjectsFailed</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>923</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>547</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_2179</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>2179</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.07</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>827</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>548</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_2180</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>2180</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.08</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>828</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>549</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_2190</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>2190</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.07</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>827</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>550</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_2191</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>2191</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.08</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>828</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>551</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_2213</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>2213</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.07</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>827</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>552</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_2219</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>2219</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.ErasableBitFlip</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>963</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>553</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_2222</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>2222</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.08</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>828</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>554</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_2232</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>2232</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.08</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>828</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>555</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_2237</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>2237</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.07</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>827</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>556</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_2246</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>2246</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.ErasableBitFlip</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>963</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>557</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_2249</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>2249</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.08</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>828</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>558</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_2255</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>2255</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.08</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>828</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>559</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_2263</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>2263</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.07</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>827</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>560</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_2268</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>2268</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.08</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>828</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>561</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_2280</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>2280</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.08</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>828</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>562</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_2285</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>2285</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.08</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>828</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>563</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_2338</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>2338</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.15</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>835</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>564</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_2381</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>2381</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.09</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>829</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>565</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_2382</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>2382</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.10</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>830</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>566</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_2416</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>2416</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FailureHandling.Behaviour.Startup1.ProductionError</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>263</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>567</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_2450</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>2450</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.14</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>834</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>568</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_2456</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>2456</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.13</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>833</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>569</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_2470</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>2470</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.11</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>831</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>570</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_2499</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>2499</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Idle</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>860</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>571</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_2502</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>2502</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.RestartSwitch.TriggerAfterInit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>910</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>572</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_2509</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>2509</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Idle</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>860</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>573</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_2510</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>2510</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00169</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>57</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>574</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_2556</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>2556</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeCriticalBlock.CancelNvMJob</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>280</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>575</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_2563</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>2563</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeCriticalBlock.InitFreeze</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>284</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>576</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_2569</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>2569</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeCriticalBlock.StopBlockJobs</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>285</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>577</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Initialization.c_2576</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Initialization.c</sourcefile>
      <sourceline>2576</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeCriticalBlock.InitFreeze</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>284</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>578</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_38</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>38</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00060</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>31</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>579</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_114</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>114</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeMemAccUsage.GetJobResultCompatibility</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>311</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>580</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_163</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>163</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Read.Behaviour.SSOngoing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>872</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>581</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_202</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>202</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Initializaion.UserJobRequests</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>258</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>582</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_203</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>203</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SS.UserJobRequests</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>260</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>583</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_215</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>215</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Idle</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>860</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>584</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_219</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>219</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Timer.UserJobRequests</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>859</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>585</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_220</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>220</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Timer.InternalOperation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>861</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>586</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_284</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>284</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeCriticalBlock.WriteFreeze</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>283</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>587</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_287</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>287</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeCriticalBlock.HealInternaly</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>287</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>588</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_293</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>293</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Critical.ResumeFailed</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>950</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>589</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_349</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>349</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup2.01</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>850</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>590</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_350</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>350</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup2.02</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>851</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>591</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_351</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>351</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Initialization.EmptyFlash</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>257</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>592</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_355</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>355</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup2.06</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>855</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>593</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_362</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>362</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup2.03</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>852</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>594</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_375</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>375</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup2.04</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>853</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>595</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_380</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>380</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup2.05</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>854</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>596</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_393</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>393</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup2.07</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>856</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>597</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_396</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>396</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.TriggeringTheSwitch.AfterInit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>900</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>598</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_404</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>404</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup2.09</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>858</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>599</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_434</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>434</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.Behaviour.SSResume.BlockSwitching.Writing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>901</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>600</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_435</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>435</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.Behaviour.SSResume.BlockSwitching.Reading</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>902</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>601</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_436</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>436</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.Behaviour.SSResume.BlockSwitching.SectionErase</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>903</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>602</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_458</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>458</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.CopyBlocks</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>895</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>603</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_486</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>486</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.RevalidateOldSection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>896</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>604</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_489</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>489</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.RestartSwitch.Priority</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>911</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>605</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_544</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>544</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.RestartSwitch.ConditionForRestart</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>909</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>606</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_559</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>559</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.Behaviour.ChangingActiveSection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>904</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>607</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_616</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>616</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Critical.SwitchRequiredSize</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>951</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>608</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_680</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>680</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeMemAccUsage.JobStatusCompatibility</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>310</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>609</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_692</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>692</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>913</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>610</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_699</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>699</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal.Failed.Det</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>915</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>611</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_703</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>703</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal.Failed</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>914</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>612</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_743</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>743</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FailureHandling.Behaviour.ProductionError.FEE_E_FLASH_ACCESSIBLE</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>261</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>613</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_761</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>761</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Startup2.Cancel.HasRequest.Ongoing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>941</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>614</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_762</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>762</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Normal.Cancel.HasRequest.Ongoing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>943</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>615</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_763</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>763</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.SectonSwitch.Cancel.HasRequest.Ongoing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>945</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>616</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_764</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>764</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Cancel.Behaviour.ReadJob</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>886</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>617</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_765</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>765</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Cancel.Behaviour.WriteJob.WriteBlockInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>887</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>618</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_766</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>766</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Cancel.Behaviour.WriteJob.WriteWrittenMarker</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>890</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>619</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_767</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>767</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Cancel.Behaviour.InvalidateJob.WriteBlockInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>889</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>620</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_768</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>768</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Cancel.Behaviour.WriteBlockData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>888</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>621</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_790</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>790</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Startup2.Cancel.HasRequest.Pending</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>940</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>622</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_791</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>791</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Normal.Cancel.HasRequest.Pending</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>942</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>623</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_792</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>792</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.SectonSwitch.Cancel.HasRequest.Pending</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>944</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>624</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_793</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>793</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Startup1.Cancel.HasRequest</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>938</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>625</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_832</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>832</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00193</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>190</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>626</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_885</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>885</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeImmediateSpaceReserved.Behavior</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>306</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>627</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_886</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>886</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00009</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>628</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_893</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>893</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.11</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>831</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>629</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_894</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>894</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.RestartSwitch.TriggerAfterInit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>910</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>630</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_920</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>920</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Invalidate.Behaviour.IDLE.IsSpace</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>875</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>631</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_921</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>921</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.EraseImmediate.Behaviour.IDLE.IsSpace</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>880</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>632</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_922</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>922</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Write.Behaviour.IDLE.IsSpace</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>865</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>633</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_923</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>923</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Write.Behaviour.SSOngoing.IsSpace</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>867</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>634</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_924</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>924</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.EraseImmediate.Behaviour.SSOngoing.IsSpace</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>882</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>635</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_925</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>925</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Invalidate.Behaviour.SSOngoing.IsSpace</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>877</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>636</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_929</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>929</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Timer.UserJobRequests</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>859</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>637</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_931</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>931</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Invalidate.Behaviour.IDLE.IsSpace</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>875</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>638</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_932</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>932</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Invalidate.Behaviour.SSOngoing.IsSpace</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>877</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>639</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_935</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>935</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.WriteBlockInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>863</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>640</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_956</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>956</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Critical.CriticalSection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>948</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>641</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_962</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>962</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.ImmediateSpaceReserved.Runtime</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>966</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>642</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_968</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>968</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.ErasePriority</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>906</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>643</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_969</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>969</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Invalidate.Behaviour.SSOngoing.NoSpace</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>879</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>644</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_970</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>970</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.EraseImmediate.Behaviour.SSOngoing.NoSpace</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>884</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>645</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_971</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>971</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.SwitchPriority</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>905</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>646</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_972</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>972</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup2.08</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>857</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>647</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_989</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>989</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Write.Behaviour.SSOngoing.SwapNeeded</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>868</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>648</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_990</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>990</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Invalidate.Behaviour.SSOngoing.SwapNeeded</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>878</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>649</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_991</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>991</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.EraseImmediate.Behaviour.SSOngoing.SwapNeeded</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>883</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>650</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_998</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>998</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.TriggeringTheSwitch.WriteRequest</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>897</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>651</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_999</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>999</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.TriggeringTheSwitch.InvalidateRequest</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>898</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>652</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_1000</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>1000</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.TriggeringTheSwitch.EraseRequest</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>899</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>653</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_1019</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>1019</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Critical.CriticalSection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>948</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>654</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_1025</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>1025</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.ImmediateSpaceReserved.Runtime</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>966</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>655</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_1031</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>1031</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Invalidate.Behaviour.SSOngoing.NoSpace</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>879</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>656</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_1032</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>1032</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.EraseImmediate.Behaviour.SSOngoing.NoSpace</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>884</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>657</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_1033</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>1033</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.SwitchPriority</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>905</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>658</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_1034</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>1034</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.SwitchPriority.JobLosesPriority</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>908</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>659</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_1040</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>1040</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Invalidate.Behaviour.IDLE.NoSpace</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>876</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>660</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_1041</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>1041</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.EraseImmediate.Behaviour.IDLE.NoSpace</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>881</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>661</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_1042</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>1042</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Write.Behaviour.IDLE.NoSpace</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>866</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>662</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_1180</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>1180</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.FreshBlock</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>965</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>663</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_1222</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>1222</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Idle</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>862</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>664</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_1259</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>1259</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Idle</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>862</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>665</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_1309</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>1309</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Critical.ResumeFailed</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>950</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>666</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_1338</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>1338</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeCriticalBlock.CancelNvMJob</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>280</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>667</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_1386</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>1386</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.ImmediateSpaceReserved.Runtime</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>966</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>668</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_1398</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>1398</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.WriteBlockInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>863</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>669</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_1422</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>1422</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeImmediateSpaceReserved.Behavior</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>306</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>670</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_1423</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>1423</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00009</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>671</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_1504</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>1504</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Critical.CriticalSection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>948</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>672</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_1525</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>1525</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Write.Behaviour.IDLE.NoSpace</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>866</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>673</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_1526</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>1526</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Critical.SectionChange</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>946</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>674</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_1538</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>1538</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeCriticalBlock.Fail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>288</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>675</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_1560</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>1560</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeCriticalBlock.Priority</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>281</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>676</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_1566</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>1566</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.WriteBlockInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>863</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>677</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_1591</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>1591</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Critical.CriticalSection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>948</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>678</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_1636</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>1636</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeCriticalBlock.ReadBlock</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>286</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>679</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_1654</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>1654</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeImmediateSpaceReserved.Behavior</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>306</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>680</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_1655</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>1655</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00009</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>681</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_1694</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>1694</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Critical.CriticalSection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>948</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>682</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_1717</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>1717</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.ImmediateSpaceReserved.Runtime</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>966</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>683</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_1785</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>1785</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Critical.CriticalSection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>948</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>684</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_1812</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>1812</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Timer.UserJobRequests</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>859</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>685</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_1817</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>1817</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Read.Behaviour.BlockInconsistent</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>874</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>686</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_1839</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>1839</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Read.Behaviour.BlockInvalid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>873</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>687</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_1853</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>1853</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Read.Behaviour.IDLE</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>871</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>688</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_1876</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>1876</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.RestartSwitch</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>912</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>689</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Internal.c_1911</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Internal.c</sourcefile>
      <sourceline>1911</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.PreemptionProtection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>290</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>690</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/src/Fee_Jobs.c_54</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Jobs.c</sourcefile>
      <sourceline>54</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.Retention</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>964</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>691</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Jobs.c_70</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Jobs.c</sourcefile>
      <sourceline>70</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.WriteBlockInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>863</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>692</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Jobs.c_77</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Jobs.c</sourcefile>
      <sourceline>77</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Invalidate.Behaviour.IDLE.IsSpace</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>875</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>693</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Jobs.c_78</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Jobs.c</sourcefile>
      <sourceline>78</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Invalidate.Behaviour.SSOngoing.IsSpace</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>877</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>694</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Jobs.c_85</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Jobs.c</sourcefile>
      <sourceline>85</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.EraseImmediate.Behaviour.IDLE.IsSpace</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>880</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>695</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Jobs.c_86</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Jobs.c</sourcefile>
      <sourceline>86</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.EraseImmediate.Behaviour.SSOngoing.IsSpace</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>882</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>696</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Jobs.c_104</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Jobs.c</sourcefile>
      <sourceline>104</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.StoreReqFailure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>917</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>697</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Jobs.c_135</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Jobs.c</sourcefile>
      <sourceline>135</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.Retention</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>964</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>698</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Jobs.c_188</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Jobs.c</sourcefile>
      <sourceline>188</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Critical.SectionFull</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>947</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>699</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Jobs.c_197</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Jobs.c</sourcefile>
      <sourceline>197</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.ImmediateSpaceReserved.Fail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>968</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>700</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Jobs.c_204</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Jobs.c</sourcefile>
      <sourceline>204</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.BlockInfoMargin</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>918</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>701</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Jobs.c_209</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Jobs.c</sourcefile>
      <sourceline>209</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Critical.SectionFull</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>947</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>702</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Jobs.c_215</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Jobs.c</sourcefile>
      <sourceline>215</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.StoreReqFailure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>917</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>703</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Jobs.c_224</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Jobs.c</sourcefile>
      <sourceline>224</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.Retention</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>964</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>704</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Jobs.c_238</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Jobs.c</sourcefile>
      <sourceline>238</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Job</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>916</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>705</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Jobs.c_260</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Jobs.c</sourcefile>
      <sourceline>260</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.StoreReqFailure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>917</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>706</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Jobs.c_276</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Jobs.c</sourcefile>
      <sourceline>276</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.WriteMultipleOfVP</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>223</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>707</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Jobs.c_283</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Jobs.c</sourcefile>
      <sourceline>283</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.StoreReqFailure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>917</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>708</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Jobs.c_307</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Jobs.c</sourcefile>
      <sourceline>307</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.StoreReqFailure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>917</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>709</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Jobs.c_345</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Jobs.c</sourcefile>
      <sourceline>345</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.WrittenMarker</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>864</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>710</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Jobs.c_363</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Jobs.c</sourcefile>
      <sourceline>363</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Job</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>916</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>711</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Jobs.c_397</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Jobs.c</sourcefile>
      <sourceline>397</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00007</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>91</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>712</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Jobs.c_456</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Jobs.c</sourcefile>
      <sourceline>456</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeDynamicBlockLength.DecreasedSizeResult</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>295</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>713</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Jobs.c_461</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Jobs.c</sourcefile>
      <sourceline>461</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Idle</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>862</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>714</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Jobs.c_475</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Jobs.c</sourcefile>
      <sourceline>475</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeDynamicBlockLength.IncreasedSizePedding</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>293</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>715</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Jobs.c_487</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Jobs.c</sourcefile>
      <sourceline>487</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeDynamicBlockLength.IncreasedSizeResult</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>294</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>716</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Jobs.c_492</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Jobs.c</sourcefile>
      <sourceline>492</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Idle</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>862</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>717</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Jobs.c_514</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Jobs.c</sourcefile>
      <sourceline>514</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Job</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>916</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>718</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Jobs.c_523</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Jobs.c</sourcefile>
      <sourceline>523</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInfoValidity.WrittenMarker</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>820</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>719</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Jobs.c_559</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Jobs.c</sourcefile>
      <sourceline>559</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00154</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>165</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>720</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Jobs.c_565</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Jobs.c</sourcefile>
      <sourceline>565</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.SwitchPriority.BlockToSwitch</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>907</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>721</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Jobs.c_584</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Jobs.c</sourcefile>
      <sourceline>584</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeDynamicBlockLength.Write</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>296</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>722</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Jobs.c_594</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Jobs.c</sourcefile>
      <sourceline>594</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Job</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>916</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>723</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/src/Fee_Sections.c_120</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Sections.c</sourcefile>
      <sourceline>120</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.ErasePriority</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>906</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>724</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Sections.c_139</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Sections.c</sourcefile>
      <sourceline>139</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Initialization.EmptyFlash</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>257</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>725</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Sections.c_169</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Sections.c</sourcefile>
      <sourceline>169</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.MarkingHeaderActive.Failure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>926</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>726</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Sections.c_183</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Sections.c</sourcefile>
      <sourceline>183</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.MarkingFooterActive.Failure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>927</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>727</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Sections.c_242</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Sections.c</sourcefile>
      <sourceline>242</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.MarkingHeaderErasable.Failure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>928</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>728</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Sections.c_300</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Sections.c</sourcefile>
      <sourceline>300</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.MarkingFooterErasable.Failure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>929</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>729</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Sections.c_378</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Sections.c</sourcefile>
      <sourceline>378</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.ConsistencyPatterns.SectionHeader.Write</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>271</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>730</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Sections.c_386</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Sections.c</sourcefile>
      <sourceline>386</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.WritingSectionHeader.Failure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>924</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>731</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Sections.c_468</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Sections.c</sourcefile>
      <sourceline>468</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.Behaviour.ChangingActiveSection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>904</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>732</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Sections.c_493</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Sections.c</sourcefile>
      <sourceline>493</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Write.Behaviour.IDLE.NoSpace</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>866</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>733</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Sections.c_506</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Sections.c</sourcefile>
      <sourceline>506</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.ConsistencyPatterns.SectionHeader.Write</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>271</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>734</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Sections.c_513</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Sections.c</sourcefile>
      <sourceline>513</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.WritingSectionFooter.Failure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>925</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>735</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Sections.c_559</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Sections.c</sourcefile>
      <sourceline>559</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.EnableAbortErase.HighestInternalPriority</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>275</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>736</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Sections.c_560</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Sections.c</sourcefile>
      <sourceline>560</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00009</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>737</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Sections.c_568</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Sections.c</sourcefile>
      <sourceline>568</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.Behaviour.SSResume.BlockSwitching.SectionErase</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>903</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>738</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Sections.c_577</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Sections.c</sourcefile>
      <sourceline>577</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeImmediateSpaceReserved.Behavior</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>306</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>739</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Sections.c_578</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Sections.c</sourcefile>
      <sourceline>578</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00009</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>740</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Sections.c_625</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Sections.c</sourcefile>
      <sourceline>625</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.Failure.SectionErase.HighPrio</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>935</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>741</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Sections.c_630</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Sections.c</sourcefile>
      <sourceline>630</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.Failure.SectionErase.LowPrio</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>936</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>742</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Sections.c_742</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Sections.c</sourcefile>
      <sourceline>742</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.Behaviour.ChangingActiveSection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>904</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>743</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_Sections.c_767</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_Sections.c</sourcefile>
      <sourceline>767</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.Behaviour.ChangingActiveSection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>904</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>744</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/src/Fee_SectionsSwitch.c_52</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_SectionsSwitch.c</sourcefile>
      <sourceline>52</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.Retention</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>964</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>745</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_SectionsSwitch.c_124</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_SectionsSwitch.c</sourcefile>
      <sourceline>124</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.Retention</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>964</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>746</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_SectionsSwitch.c_159</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_SectionsSwitch.c</sourcefile>
      <sourceline>159</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.Behaviour.SSResume.BlockSwitching.Writing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>901</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>747</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_SectionsSwitch.c_177</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_SectionsSwitch.c</sourcefile>
      <sourceline>177</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.SectionSwitch.WriteBlockInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>930</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>748</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_SectionsSwitch.c_180</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_SectionsSwitch.c</sourcefile>
      <sourceline>180</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.SectionSwitch.BlockInfoMargin</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>934</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>749</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_SectionsSwitch.c_198</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_SectionsSwitch.c</sourcefile>
      <sourceline>198</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.Retention</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>964</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>750</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_SectionsSwitch.c_272</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_SectionsSwitch.c</sourcefile>
      <sourceline>272</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.Behaviour.SSResume.BlockSwitching.Reading</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>902</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>751</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_SectionsSwitch.c_295</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_SectionsSwitch.c</sourcefile>
      <sourceline>295</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.Behaviour.SSResume.BlockSwitching.Reading</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>902</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>752</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_SectionsSwitch.c_313</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_SectionsSwitch.c</sourcefile>
      <sourceline>313</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.SectionSwitch.BlockDataRead</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>933</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>753</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_SectionsSwitch.c_390</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_SectionsSwitch.c</sourcefile>
      <sourceline>390</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.Behaviour.SSResume.BlockSwitching.Writing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>901</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>754</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_SectionsSwitch.c_395</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_SectionsSwitch.c</sourcefile>
      <sourceline>395</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.Behaviour.SSResume.BlockSwitching.Writing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>901</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>755</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_SectionsSwitch.c_413</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_SectionsSwitch.c</sourcefile>
      <sourceline>413</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.SectionSwitch.BlockDataWrite</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>931</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>756</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_SectionsSwitch.c_445</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_SectionsSwitch.c</sourcefile>
      <sourceline>445</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInfoValidity.WrittenMarker</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>820</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>757</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Fee_SectionsSwitch.c_504</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/src/Fee_SectionsSwitch.c</sourcefile>
      <sourceline>504</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.SectionSwitch.BlockWrittenMarkerWrite</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>932</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>758</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_15</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>15</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.ECUC_Fee_00154</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>191</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>759</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_34</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>34</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00167</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>55</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>760</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_58</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>58</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.ECUC_Fee_00040</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>73</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>761</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_74</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>74</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.ECUC_Fee_00150</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>87</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>762</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_109</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>109</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00006</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>90</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>763</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_122</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>122</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.ECUC_Fee_00148</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>85</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>764</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_155</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>155</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.ECUC_Fee_00151</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>88</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>765</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_190</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>190</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00102</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>136</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>766</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_191</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>191</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.ECUC_Fee_00110</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>75</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>767</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_221</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>221</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.ECUC_Fee_00149</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>86</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>768</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_253</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>253</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.ECUC_Fee_00155</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>193</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>769</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_292</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>292</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.ECUC_Fee_00039</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>770</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_420</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>420</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeUseBufferForJobs.Config</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>219</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>771</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_466</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>466</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeImmediateSpaceReserved.Config</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>305</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>772</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_495</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>495</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeImmediateSpaceReserved.Restriction</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>307</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>773</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_502</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>502</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeBufferCalculation.Enable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>300</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>774</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_523</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>523</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.ECUC_Fee_00111</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>76</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>775</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_552</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>552</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.ASR40.ECUC_Fee_00152</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>21</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>776</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_582</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>582</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.ECUC_Fee_00153</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>184</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>777</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_605</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>605</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.ECUC_Fee_00112</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>77</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>778</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_632</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>632</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.ECUC_Fee_00113</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>78</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>779</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_659</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>659</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.ECUC_Fee_00114</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>79</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>780</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_692</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>692</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EB_FEE114_PollingMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>208</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>781</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_700</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>700</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.ECUC_Fee_00119</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>84</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>782</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_738</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>738</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.ECUC_Fee_00115</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>80</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>783</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_770</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>770</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.ECUC_Fee_00116</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>81</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>784</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_799</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>799</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00076</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>118</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>785</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_802</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>802</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.ECUC_Fee_00156</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>194</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>786</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_830</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>830</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Sections.NumberOfSections.Configurable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>225</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>787</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_855</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>855</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Sections.NumberOfSections.Validate</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>226</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>788</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_998</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>998</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FailureHandling.Behaviour.ProductionError.Config</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>264</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>789</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_1027</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>1027</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.EraseCounter.API</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>267</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>790</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_1066</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>1066</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FreezeActivities.API</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>273</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>791</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_1095</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>1095</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeCancelSectionErase.Config</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>276</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>792</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_1127</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>1127</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeUseBlankCheck.Config</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>268</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>793</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_1153</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>1153</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.ConsistencyPattern.Config</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>269</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>794</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_1184</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>1184</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.ReadImmediate.Config</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>272</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>795</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_1219</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>1219</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00009</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>796</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_1220</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>1220</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.EnableAbortErase.NormalOperation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>274</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>797</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_1253</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>1253</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Configuration.FeeNumberOfNotConfigBlocks</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>233</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>798</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_1286</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>1286</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Configuration.FeeDataSizeNotConfiguredBlocks</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>235</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>799</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_1326</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>1326</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Configuration.FeeWriteCustomApi</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>237</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>800</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_1382</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>1382</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.Configuration.FeeReadCustomApi</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>247</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>801</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_1439</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>1439</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeCriticalBlock.Config</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>279</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>802</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_1468</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>1468</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeDynamicBlockLength.Config</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>292</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>803</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_1497</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>1497</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeEnableSmallSectionSize.Enable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>297</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>804</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_1533</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>1533</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeMemAccUsage.Config</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>308</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>805</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_1556</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>1556</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.ECUC_Fee_00157</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>195</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>806</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_1557</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>1557</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeMemAccUsage.BufferAlignmentValue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>312</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>807</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_1586</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>1586</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeMemAccUsage.DriverErasedValue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>313</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>808</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_1637</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>1637</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FailureHandling.Behaviour.ProductionError.FEE_E_FLASH_ACCESSIBLE</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>261</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>809</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_1674</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>1674</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.FailureHandling.Behaviour.ProductionError.FEE_E_DATA_RECOVERED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>262</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>810</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_1712</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>1712</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.ECUC_Fee_00043</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>811</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_1729</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>1729</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.ECUC_Fee_00117</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>82</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>812</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_1764</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>1764</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.ASR40.ECUC_Fee_00070</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>20</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>813</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Fee.xdm.m4_1805</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/config/Fee.xdm.m4</sourcefile>
      <sourceline>1805</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.ECUC_Fee_00118</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>83</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>814</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/generate_swcd/swcd/Fee_Bswmd.arxml.m4_31</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/generate_swcd/swcd/Fee_Bswmd.arxml.m4</sourcefile>
      <sourceline>31</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00132</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>47</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>815</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate_swcd/swcd/Fee_Bswmd.arxml.m4_356</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/src/Autosar/generate_swcd/swcd/Fee_Bswmd.arxml.m4</sourcefile>
      <sourceline>356</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00185</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>71</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>816</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd">
    <specobject>
      <id>Fee.Dsn.Initialization.Startup1.MarkerValidity</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>4</sourceline>
      <version>1</version>
      <description> A marker shall be considered valid if it has at least one byte equal with the pattern value of that particular marker. </description>
      <comment>If a marker was attempted to be written and we can
                detect that it is reasonable to consider that marker as written. Example: If we have
                a section with the ACTIVE marker written partially (only one byte), Fee will consider
                the section valid and won't erase it since it can have data written in the section. </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_2082</srcid><srcstatus/><internalId>542</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_2103</srcid><srcstatus/><internalId>543</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_2124</srcid><srcstatus/><internalId>544</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_2145</srcid><srcstatus/><internalId>545</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_StartUp_Erasable_Erasable</srcid><srcstatus/><internalId>1132</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Sections.ACTIVE_marker</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>229</internalId></provcov>
        <provcov>
          <linksto>Fee.Sections.ERASABLE_marker</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>230</internalId></provcov>
        <provcov>
          <linksto>Fee.Robustness</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>817</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Initialization.Startup1.BlockInfoValidity.SwitchNotConfiguredBlocksOFF</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>32</sourceline>
      <version>1</version>
      <description> Fee shall consider the block info as valid if the following conditions are
                met:
                &lt;itemizedlist&gt;
                    &lt;listitem&gt;
                        &lt;para&gt;- the stored checksum matches the recalculated checksum;&lt;/para&gt;
                    &lt;/listitem&gt;
                    &lt;listitem&gt;
                        &lt;para&gt;- the WRITTEN Marker is written; &lt;/para&gt;
                    &lt;/listitem&gt;
                    &lt;listitem&gt;
                        &lt;para&gt;- the block start address read from the flash memory plus its size does not exceed the
                            range of valid addresses for the section in which Fee found the block info.&lt;/para&gt;
                    &lt;/listitem&gt;
                    &lt;listitem&gt;
                        &lt;para&gt;- the block start address read from the flash memory is within the current working section address boundries.&lt;/para&gt;
                    &lt;/listitem&gt;
                    &lt;listitem&gt;
                        &lt;para&gt;- has an valid block Id (can be found in configuration);&lt;/para&gt;
                    &lt;/listitem&gt;
                    &lt;listitem&gt;
                        &lt;para&gt;- has an valid block Size (the configured size).&lt;/para&gt;
                    &lt;/listitem&gt;
                &lt;/itemizedlist&gt;                     
                Otherwise the block Info is considered invalid. </description>
      <comment> This extra check decreases the risk of miscalculating the block management
                information validity. The checksum is used to evaluate the integrity of the Block
                Info written to flash. If the checksum in found invalid, the Block Info itself is
                assumed to be corrupted and it is not possible to determine which block is affected.
                Therefore, the only reasonable approach is to retain an INCONSISTENT address in
                cache. The range of valid addresses means that the block data does not overlap the
                reserved area between the data part of the section and the block info part. </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_1307</srcid><srcstatus/><internalId>506</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_1355</srcid><srcstatus/><internalId>507</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_1605</srcid><srcstatus/><internalId>522</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_StartUp_InvalidBlockInfoWrongDataAddress</srcid><srcstatus/><internalId>1129</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_InvalidBlockInfo</srcid><srcstatus/><internalId>1130</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_Empty_Empty</srcid><srcstatus/><internalId>1133</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_ImplausibleBigSize_LowerBoundary</srcid><srcstatus/><internalId>1159</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_ImplausibleBigSize_SectionOverflow</srcid><srcstatus/><internalId>1160</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_ImplausibleSmallAddress</srcid><srcstatus/><internalId>1161</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Robustness</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>818</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Initialization.Startup1.BlockInfoValidity.SwitchNotConfiguredBlocksON</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>78</sourceline>
      <version>1</version>
      <description> Fee shall consider the block info as valid if the following conditions are
                met: 
                &lt;itemizedlist&gt;
                    &lt;listitem&gt;
                        &lt;para&gt;- the stored checksum matches the recalculated checksum;&lt;/para&gt;
                    &lt;/listitem&gt;
                    &lt;listitem&gt;
                        &lt;para&gt;- the WRITTEN Marker is written; &lt;/para&gt;
                    &lt;/listitem&gt;
                    &lt;listitem&gt;
                        &lt;para&gt;- the block start address read from the flash memory plus its size does not exceed the
                            range of valid addresses for the section in which Fee found the block info.&lt;/para&gt;
                    &lt;/listitem&gt;
                    &lt;listitem&gt;
                        &lt;para&gt;- if the block id can be found in memorized configuration the configured size shall match.&lt;/para&gt;
                    &lt;/listitem&gt;
                &lt;/itemizedlist&gt;        
                Otherwise the block Info is
                considered invalid. </description>
      <comment> This extra check decreased the risk of miscalculating the block management
                information validity. The checksum is used to evaluate the integrity of the Block
                Info written to flash. If the checksum in found invalid, the Block Info itself is
                assumed to be corrupted and it is not possible to determine which block is affected.
                Therefore, the only reasonable approach is to retain an INCONSISTENT address in
                cache. The range of valid addresses means that the block data does not overlap the
                reserved area between the data part of the section and the block info part. </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_1306</srcid><srcstatus/><internalId>505</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_1356</srcid><srcstatus/><internalId>508</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_1606</srcid><srcstatus/><internalId>523</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_NotConfigBlocks_StandardSwitch</srcid><srcstatus/><internalId>1162</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_WriteCustom_Acceptance</srcid><srcstatus/><internalId>1169</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Robustness</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
        <provcov>
          <linksto>Fee.Configuration.FeeNumberOfNotConfigBlocks</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>233</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>819</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Initialization.Startup1.BlockInfoValidity.WrittenMarker</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>123</sourceline>
      <version>1</version>
      <description> At Startup1 Fee shall ensure that the block is seen consistent only if the
                block Data had been successfully written. This is marked by a WRITTEN marker
                written at the end of the block Info right after writing the block Data. </description>
      <comment> At Startup1 Fee when searching for blocks Fee shall only look for the block
                Infos and not for data. The reason of writing the WRITTEN marker right next to block
                Info is to have the certainty that the data is fully written and no error had
                occurred while writing it (or a possible reset). A block writing consists of the
                following sequence of operations: writing the block Info; writing the data
                together with the block Id; writing the WRITTEN marker. </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_1603</srcid><srcstatus/><internalId>520</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Jobs.c_523</srcid><srcstatus/><internalId>719</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_SectionsSwitch.c_445</srcid><srcstatus/><internalId>757</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_WriteRefusedRetries</srcid><srcstatus/><internalId>1064</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_WriteFail</srcid><srcstatus/><internalId>1068</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Robustness</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>820</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Initialization.Startup1.BlockInfoValidity.WrittenMarkerValidity</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>148</sourceline>
      <version>1</version>
      <description> WRITTEN marker shall be considered valid if it has at least one byte equal with the pattern value of that particular marker. </description>
      <comment> If a marker was attempted to be written and we can
                detect that it is reasonable to consider that marker as written. </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_1604</srcid><srcstatus/><internalId>521</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_WriteFail</srcid><srcstatus/><internalId>1068</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_InvalidBlockInfoWrongDataAddress</srcid><srcstatus/><internalId>1129</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_InvalidBlockInfo</srcid><srcstatus/><internalId>1130</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Robustness</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>821</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Initialization.Startup1.Sections.01</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>166</sourceline>
      <version>1</version>
      <description>
                If all the section management object fields are equal to configured erased value 
                the section management object shall be considered not written (FEE_SECTION_ERASED).
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_1957</srcid><srcstatus/><internalId>533</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_InconsitentHeaderFooter</srcid><srcstatus/><internalId>1023</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_Active_EmptyNoFooter</srcid><srcstatus/><internalId>1140</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Sections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>822</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Initialization.Startup1.Sections.02</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>187</sourceline>
      <version>1</version>
      <description>
                As a first step of the initialization Fee shall read all the section headers and footers
                and validate them in order to identify the state of all sections, with the highest priority.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee.c.m4_313</srcid><srcstatus/><internalId>395</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_1205</srcid><srcstatus/><internalId>501</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_StartUp_Inconsistent_Inconsistent</srcid><srcstatus/><internalId>1145</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Sections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>823</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Initialization.Startup1.Sections.03</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>208</sourceline>
      <version>2</version>
      <description>
                A section shall be considered consistent if, in either the header or the footer, 
                both the 8bit CRC computed over the Config Id and the seciton counter is correct 
                and the configuration Id is the same with the compiled configuration Id or 
                the legacy configuration Id.
            </description>
      <comment>
                The legacy configuration Id represents the older way of computing the configuration Id and 
                it si verified for backwards compatibility reasons.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_1965</srcid><srcstatus/><internalId>534</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_2166</srcid><srcstatus/><internalId>546</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_ConfigId</srcid><srcstatus/><internalId>981</internalId></linkedfrom><linkedfrom><srcid>Ts_Fee_LegacyConfigId</srcid><srcstatus/><internalId>1006</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_ActiveHeader_InconsistentFooter_CIDCrc</srcid><srcstatus/><internalId>1153</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_InconsistentHeader_ActiveFooter_CIDCrc</srcid><srcstatus/><internalId>1154</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_SectionStatus_00</srcid><srcstatus/><internalId>1198</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_SectionStatus_01</srcid><srcstatus/><internalId>1199</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_SectionStatus_02</srcid><srcstatus/><internalId>1200</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Sections.HeaderSecured</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>228</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>824</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Initialization.Startup1.Sections.04</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>233</sourceline>
      <version>1</version>
      <description>
                The section erase counter value shall be protected by a 8bit CRC that is computed 
                on the section erase counter.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_1973</srcid><srcstatus/><internalId>535</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_StartUp_Active_Active_WrongEraseCntCrc</srcid><srcstatus/><internalId>1152</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Sections.HeaderSecured</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>228</internalId></provcov>
        <provcov>
          <linksto>Fee.SectionEraseCounter</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>266</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>825</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Initialization.Startup1.Sections.06</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>258</sourceline>
      <version>1</version>
      <description>
                The footer validity shall be checked either if the header was detected to be valid or invalid.
            </description>
      <comment>
                This is needed for two cases:
                - the header is valid and the the footer has not been written because of a reset;
                - the header is marked for erase and the footer is not, but the footer is valid.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_317</srcid><srcstatus/><internalId>473</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_747</srcid><srcstatus/><internalId>484</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_2015</srcid><srcstatus/><internalId>539</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_StartUp_InconsistentHeader_ActiveFooter_CIDCrc</srcid><srcstatus/><internalId>1154</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Robustness</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>826</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Initialization.Startup1.Sections.07</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>281</sourceline>
      <version>1</version>
      <description>
                A section is considered ACTIVE if all the following conditions are met:
                - the section is consistent;
                - a valid ACTIVE marker is found in either the header or the footer;
                - no ERASABLE marker if found valid in both the header and the footer.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_2055</srcid><srcstatus/><internalId>541</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_2179</srcid><srcstatus/><internalId>548</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_2190</srcid><srcstatus/><internalId>550</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_2213</srcid><srcstatus/><internalId>552</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_2237</srcid><srcstatus/><internalId>556</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_2263</srcid><srcstatus/><internalId>560</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_StartUp_Active_Active</srcid><srcstatus/><internalId>1139</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_Active_Inconsisntent_CIDCrc</srcid><srcstatus/><internalId>1151</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_ActiveHeader_InconsistentFooter_CIDCrc</srcid><srcstatus/><internalId>1153</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_InconsistentHeader_ActiveFooter_CIDCrc</srcid><srcstatus/><internalId>1154</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_ActiveNoHeader</srcid><srcstatus/><internalId>1155</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_SectionStatus_00</srcid><srcstatus/><internalId>1198</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_SectionStatus_01</srcid><srcstatus/><internalId>1199</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_SectionStatus_02</srcid><srcstatus/><internalId>1200</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Robustness</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
        <provcov>
          <linksto>Fee.Sections.ACTIVE_marker</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>229</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>827</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Initialization.Startup1.Sections.08</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>308</sourceline>
      <version>1</version>
      <description>
                A section is considered ERASABLE if all the following conditions are met:
                - the section is consistent;
                - a valid ERASABLE marker is found in either the header or the footer.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_2036</srcid><srcstatus/><internalId>540</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_2180</srcid><srcstatus/><internalId>549</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_2191</srcid><srcstatus/><internalId>551</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_2222</srcid><srcstatus/><internalId>554</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_2232</srcid><srcstatus/><internalId>555</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_2249</srcid><srcstatus/><internalId>558</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_2255</srcid><srcstatus/><internalId>559</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_2268</srcid><srcstatus/><internalId>561</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_2280</srcid><srcstatus/><internalId>562</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_2285</srcid><srcstatus/><internalId>563</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_StartUp_Erasable_Erasable</srcid><srcstatus/><internalId>1132</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_Active_ErasableHeader</srcid><srcstatus/><internalId>1141</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_Active_ErasableFooter</srcid><srcstatus/><internalId>1142</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_Active_Erasable</srcid><srcstatus/><internalId>1143</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_Erasable_Inconsistent</srcid><srcstatus/><internalId>1144</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Robustness</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
        <provcov>
          <linksto>Fee.Sections.ERASABLE_marker</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>230</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>828</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Initialization.Startup1.Sections.09</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>334</sourceline>
      <version>2</version>
      <description>
                The section with data (active) that has the highest section counter is considered the newest active section,
                or in short "the Active section".
            </description>
      <comment>
                The section counter must be a valid one, as Fee only writes circularly incremented counters.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_2381</srcid><srcstatus/><internalId>565</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_StartUp_Active_Active</srcid><srcstatus/><internalId>1139</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_RepairInBetween</srcid><srcstatus/><internalId>1204</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_SectionCounterOverflow_1</srcid><srcstatus/><internalId>1207</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_SectionCounterOverflow_2</srcid><srcstatus/><internalId>1208</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_SectionCounterOverflow_3</srcid><srcstatus/><internalId>1209</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Robustness</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>829</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Initialization.Startup1.Sections.10</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>356</sourceline>
      <version>2</version>
      <description>
                The closest active section to the newest active section going circularly to the right shall be considered
                the oldest active section.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_2382</srcid><srcstatus/><internalId>566</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_StartUp_Active_Active</srcid><srcstatus/><internalId>1139</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_RepairInBetween</srcid><srcstatus/><internalId>1204</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_SectionCounterOverflow_1</srcid><srcstatus/><internalId>1207</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_SectionCounterOverflow_2</srcid><srcstatus/><internalId>1208</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_SectionCounterOverflow_3</srcid><srcstatus/><internalId>1209</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Robustness</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>830</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Initialization.Startup1.Sections.11</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>377</sourceline>
      <version>1</version>
      <description>
                Fee shall give the switch the highest priority if all the sections are found 
                consistent with data, and during the idle time after the Startup1, 
                a write, invalidate or erase immediate job is requested or, 
                a read job is finished and the delay timer expires.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_2470</srcid><srcstatus/><internalId>570</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_893</srcid><srcstatus/><internalId>629</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_StartUp_Active_Active</srcid><srcstatus/><internalId>1139</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_HP_ImmediatelyAfterInit_AllBlocks</srcid><srcstatus/><internalId>1194</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_HP_ImmediatelyAfterInit</srcid><srcstatus/><internalId>1273</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>831</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Initialization.Startup1.Sections.12</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>394</sourceline>
      <version>1</version>
      <description>
                The initialization shall find and store the highest erase counter from all the consistent sections.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_1979</srcid><srcstatus/><internalId>538</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_StartUp_Active_Active_WrongEraseCntCrc</srcid><srcstatus/><internalId>1152</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.SectionEraseCounter</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>266</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>832</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Initialization.Startup1.Sections.13</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>414</sourceline>
      <version>1</version>
      <description>
                Any consistent section unmarked as Active, that has a correct section counter with respect to the counter of the Active section,
                shall be considered EMPTY and ready to be used.
            </description>
      <comment>
                A correct counter means it has to grow in a circular consecutive fashion starting from the reference section.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_2456</srcid><srcstatus/><internalId>569</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Init_CorruptedSectionNotEmpty_First</srcid><srcstatus/><internalId>1205</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Init_CorruptedSectionNotEmpty_Last</srcid><srcstatus/><internalId>1206</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Robustness</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>833</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Initialization.Startup1.Sections.14</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>436</sourceline>
      <version>1</version>
      <description>
                Any consistent section unmarked as Active, that has an incorrect section counter with respect to the counter of the Active section,
                shall be considered INCONSISTENT.
            </description>
      <comment>
                A correct counter means it has to grow in a circular consecutive fashion starting from the reference section.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_2450</srcid><srcstatus/><internalId>568</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Init_CorruptedSectionNotEmpty_First</srcid><srcstatus/><internalId>1205</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Init_CorruptedSectionNotEmpty_Last</srcid><srcstatus/><internalId>1206</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Robustness</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>834</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Initialization.Startup1.Sections.15</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>458</sourceline>
      <version>1</version>
      <description>
                If there is no section with data (no active section), the empty section with the lowest section counter
                shall be considered the starting section or in short "the Active section".
            </description>
      <comment>
                The other empty sections will be considered consistent or not based on req Sections.13 and Sections.14.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_2338</srcid><srcstatus/><internalId>564</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_StartUp_Empty_Empty</srcid><srcstatus/><internalId>1133</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Robustness</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>835</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Initialization.Startup1.BlockInfos.01</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>480</sourceline>
      <version>1</version>
      <description>
                At initialization Fee shall detect the states of all the configured blocks and memorize their addresses 
                as soon as the state of all sections is known and with the highest priority.
            </description>
      <rationale>
                The design should adjust the chosen flash data structures so that
                the initial internal management operation (reading the administrative data from Flash)
                can be performed with as few cycles as possible, in order to permit a very early ReadAll() call.
                Also the internal buffer size shall be considered at configuration time. The bigger the buffer is
                the faster the chaching of the blocks will be.
            </rationale>
      <comment>
                Block infos will be read all toghether or a big chunk of them because they are written 
                one after another at the end of the section. Therefore to guarantee it is done in a short time.
                The overall startup time of the ECU must be as short as possible, also depending on
                project specifics. Therefore, a specific value cannot be given for a generic
                approach.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_1233</srcid><srcstatus/><internalId>503</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_StartUp_Empty_Empty</srcid><srcstatus/><internalId>1133</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Robustness</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>836</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Initialization.Startup1.BlockInfos.02</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>513</sourceline>
      <version>1</version>
      <description>
                If Switch Not Configured Blocks feature is active, at initialization, Fee shall detect the states of 
                maximum 'FeeNumberOfNotConfigBlocks' different blocks and memorize their addresses.
            </description>
      <rationale>
                The not congigured blocks "discovered" configuration must be kept in RAM for the switch to move the block
                management information as well, and not only block's data.
            </rationale>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Extra.c_167</srcid><srcstatus/><internalId>446</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_1386</srcid><srcstatus/><internalId>511</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_NotConfigBlocks_StandardSwitch</srcid><srcstatus/><internalId>1162</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_WriteCustom_Acceptance</srcid><srcstatus/><internalId>1169</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Configuration.FeeNumberOfNotConfigBlocks</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>233</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>837</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Initialization.Startup1.BlockInfos.03</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>536</sourceline>
      <version>1</version>
      <description>
                Block management information shall be checked only in sections that are consistent and marked as ACTIVE.
            </description>
      <comment>
                For the sections that are considered ERASABLE there is no reason why we would check them for data. 
                They will be erased at startup 2.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_1870</srcid><srcstatus/><internalId>528</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_StartUp_Active_Empty</srcid><srcstatus/><internalId>1135</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_SectionUpperHalfErased</srcid><srcstatus/><internalId>1202</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Robustness</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
        <provcov>
          <linksto>Fee.Sections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>838</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Initialization.CacheInit</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>562</sourceline>
      <version>1</version>
      <description>
                Fee shall initialize all the addresses in cache with a constant value,
                indicating that the blocks haven't been found yet.
                (an address that shall never be used for writing blocks)
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee.c.m4_255</srcid><srcstatus/><internalId>392</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_StartUp_Active_EmptyNoFooter</srcid><srcstatus/><internalId>1140</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_InitBlockErasedInFirstSection</srcid><srcstatus/><internalId>1203</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Robustness</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>839</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Initialization.Startup1.FillCacheWithBlockInfos</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>584</sourceline>
      <version>1</version>
      <description>
                Filling of Cache shall be done by processing Block Management Information stored in the
                flash memory. Block Infos are read as many as possible in one call of Fls_Read()/MemAcc_Read()
                (the number of block infos read at once depends on the size of the internal buffer).
            </description>
      <comment>
                Since all the block infos are written one after another at the end of the section, this
                approach ensures that by reading one internal buffer at a time and then check for block
                infos inside reduces the init time as much as possible.
                Fee shall only request to read as many block infos, in one Fls_Read()/MemAcc_Read() call,
                as can completely fit in the Fee internal buffer.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_779</srcid><srcstatus/><internalId>486</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_1735</srcid><srcstatus/><internalId>526</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_StartUp_Empty_Empty</srcid><srcstatus/><internalId>1133</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00049</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>840</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Initialization.Startup1.BlockInfosSearch</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>611</sourceline>
      <version>1</version>
      <description>
                Fee shall search for block infos at the end of the section from the highest address to the lowest
                until an area, equal in size of the border between block data area and block info,
                is found empty and continue caching other sections.
            </description>
      <comment>
                There have to be an exit condition for block info searching in a section.
                Fee must compensate the situation where a block info or a couple of block infos are seen
                empty(possible due to a flash error) and the next block info happens to be written successfully.
                That block info is better to be identified. In virtue of this we have considered a
                great enough value, 4,  of the size of the barier between data and info in order to
                reduce the risk of not seeing that block info. Otherwise problems like losing data or overwrite
                an already written area can occur.
                The stop condition does not include reaching the data area because Fee reserves the amount
                of configured "empty" block infos so that this is not considered as part of the available
                section size and, thus, is never written.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_1661</srcid><srcstatus/><internalId>525</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_StartUp_Empty_Empty</srcid><srcstatus/><internalId>1133</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_CacheFullSection</srcid><srcstatus/><internalId>1158</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_ImplausibleSmallAddress</srcid><srcstatus/><internalId>1161</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_NotConfigBlocks_InvalidatedBlock</srcid><srcstatus/><internalId>1175</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_CacheAll_InvalidatedWritten</srcid><srcstatus/><internalId>1187</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_CacheAll_InvalidatedWrittenCopied</srcid><srcstatus/><internalId>1188</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_CacheAll_InvalidatedCopied</srcid><srcstatus/><internalId>1189</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_NoConfInvalidatedBlock_Sections3</srcid><srcstatus/><internalId>1190</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Robustness</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
        <provcov>
          <linksto>Fee.NoFlashPageOverriden</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>222</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>841</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Initialization.Startup1.SwitchNotConfiguredBlocks</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>648</sourceline>
      <version>1</version>
      <description>
                If Switch Not Configured Blocks feature is active, if Fee finds a valid, but not configured, 
                block at initialization Fee shall cache not only the address of the block, 
                but also the configuration information for a number of 'FeeNumberOfNotConfigBlocks' different blocks found.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Extra.c_166</srcid><srcstatus/><internalId>445</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_1385</srcid><srcstatus/><internalId>510</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_NotConfigBlocks_StandardSwitch</srcid><srcstatus/><internalId>1162</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_WriteCustom_Acceptance</srcid><srcstatus/><internalId>1169</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Configuration.FeeNumberOfNotConfigBlocks</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>233</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>842</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Initialization.Startup1.InvalidLastBlockInfos</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>671</sourceline>
      <version>1</version>
      <description>
                If the last block infos consecutively found in a section are invalid Fee shall compensate
                when computing the available section size in order to avoid overwrite, by considering a
                biggest block size of data for each invalid block info.
            </description>
      <comment>
                In order not to miscalculate the last written data address, not knowing for sure what
                block ids corresponds to those invalid block infos, Fee takes the worst case scenario and
                considers each invalid block info to be the block with the biggest configured size.
                A "biggest block" means the size of the biggest configured block, with the block ID appended,
                all of it aligned to the virtual page size.

                If afterwards Fee finds a valid block info (meaning that the invalid block infos are not
                actually the last ones) those invalid block infos are forgotten and the number of
                biggest block sizes corresponding to the invalid block infos is reset to 0.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_906</srcid><srcstatus/><internalId>489</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_985</srcid><srcstatus/><internalId>493</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_1095</srcid><srcstatus/><internalId>496</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_1171</srcid><srcstatus/><internalId>500</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_1485</srcid><srcstatus/><internalId>515</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Init_Cache_SectionTotalRefusal</srcid><srcstatus/><internalId>1059</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_BigLostSectionSize</srcid><srcstatus/><internalId>1281</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_BigInvalidBlockAddress</srcid><srcstatus/><internalId>1282</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.NoFlashPageOverriden</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>222</internalId></provcov>
        <provcov>
          <linksto>Fee.Robustness</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>843</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Initialization.Startup1.BlockInfoFound</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>706</sourceline>
      <version>1</version>
      <description>
                If a successfully read block info's validation indicates it is valid
                then Fee shall consider the block info contents and memorise them, if required, 
                for the found block instance.
            </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_1517</srcid><srcstatus/><internalId>517</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_StartUp_Empty_Empty</srcid><srcstatus/><internalId>1133</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_InitBlockErasedInFirstSection</srcid><srcstatus/><internalId>1203</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00049</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>844</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Initialization.Startup1.BlockInconsistent.01</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>726</sourceline>
      <version>1</version>
      <description>
                The block shall be considered INCONSISTENT if during start-up the block management information 
                for a configured block is not found (not written to flash memory).
            </description>
      <comment>
                Please refer to AUTOSAR Bugzilla #58294 for more details.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee.c.m4_258</srcid><srcstatus/><internalId>393</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_StartUp_Active_Empty</srcid><srcstatus/><internalId>1135</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00049</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>845</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Initialization.Startup1.BlockInconsistent.02</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>748</sourceline>
      <version>1</version>
      <description>
                The block shall be considered INCONSISTENT if during start-up 
                the block management information is invalid.
            </description>
      <comment>
                Please refer to AUTOSAR Bugzilla #58294 for more details.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_1357</srcid><srcstatus/><internalId>509</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_StartUp_InvalidBlockInfoWrongDataAddress</srcid><srcstatus/><internalId>1129</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_InvalidBlockInfo</srcid><srcstatus/><internalId>1130</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_ImplausibleBigSize_LowerBoundary</srcid><srcstatus/><internalId>1159</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_ImplausibleBigSize_SectionOverflow</srcid><srcstatus/><internalId>1160</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_ImplausibleSmallAddress</srcid><srcstatus/><internalId>1161</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00049</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>846</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Initialization.Startup1.BlocksSearchStop.SwNotConfigBlocksOFF</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>770</sourceline>
      <version>1</version>
      <description>
                Fee shall stop searching for block infos if all configured blocks were identified.
                (Switch Not Configured Blocks feature disabled)
            </description>
      <rationale>
            </rationale>
      <comment>
                After the processing of all Block Infos is completed, the Cache contains the latest
                data address for all blocks.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_1510</srcid><srcstatus/><internalId>516</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_1894</srcid><srcstatus/><internalId>529</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_1904</srcid><srcstatus/><internalId>531</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_StartUp_Active_Empty</srcid><srcstatus/><internalId>1135</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_InitBlockErasedInFirstSection</srcid><srcstatus/><internalId>1203</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00049</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>847</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Initialization.Startup1.BlocksSearchStop.SwNotConfigBlocksON</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>795</sourceline>
      <version>1</version>
      <description>
                Fee shall stop the block searching if all the configured blocks were identified and 
                the "FeeNumberOfNotConfigBlocks + 1"th not configured block was found; 
                Otherwise Fee shall search for block infos in all the consistent sections that are also marked as ACTIVE
                if Switch Not Configured Blocks feature is enabled.
            </description>
      <comment>
                After the processing of all Block Infos is completed, the Cache contains the latest
                data address for all blocks.
                In case of "Not configured blocks" feature configured Fee must identify all consistent
                blocks with a valid block Info, therefore Fee can not know where to stop searching for
                blocks since they can be found anywhere, in any section.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Extra.c_168</srcid><srcstatus/><internalId>447</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_1387</srcid><srcstatus/><internalId>512</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_1897</srcid><srcstatus/><internalId>530</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_NotConfigBlocks_StandardSwitch</srcid><srcstatus/><internalId>1162</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Configuration.FeeNumberOfNotConfigBlocks</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>233</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>848</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Initialization.Startup1.BlockInfoCacheIfNewer</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>823</sourceline>
      <version>1</version>
      <description>
                A block shall be cached only if the instance found is newer than the previously found instance of this block.
            </description>
      <comment>
                A block instance is newer only if the previously found instance is in the same section.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_1532</srcid><srcstatus/><internalId>518</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_StartUp_Erasable_Erasable</srcid><srcstatus/><internalId>1132</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_CustomBlkErasedWrittenInSection0</srcid><srcstatus/><internalId>1174</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_InitBlockErasedInFirstSection</srcid><srcstatus/><internalId>1203</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00049</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>849</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Initialization.Startup2.01</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>844</sourceline>
      <version>2</version>
      <description>
                All consecutive Inconsistent/Erasable sections, starting from the active section shall be erased and validated in startup 2 mode. If there is no active section, the revalidation shall start with the first section configured.
            </description>
      <comment>
                The switch will naturaly heal the inconsitent section with the section counter 
                smaller than the ACTIVE section and greater than the OLDEST section.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_349</srcid><srcstatus/><internalId>590</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_StartUp_Empty_Inconsistent</srcid><srcstatus/><internalId>1138</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_Active_Inconsisntent_CID</srcid><srcstatus/><internalId>1146</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_Active_InconsisntentEmptyFooter</srcid><srcstatus/><internalId>1147</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_Active_InconsisntentErasableFooter</srcid><srcstatus/><internalId>1148</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_Active_InconsisntenErasableEmptyFooter</srcid><srcstatus/><internalId>1149</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_Active_InconsisntenErasableErasableFooter</srcid><srcstatus/><internalId>1150</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_Active_Inconsisntent_CIDCrc</srcid><srcstatus/><internalId>1151</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_ActiveHeader_InconsistentFooter_CIDCrc</srcid><srcstatus/><internalId>1153</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_InconsistentHeader_ActiveFooter_CIDCrc</srcid><srcstatus/><internalId>1154</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_RepairInBetween</srcid><srcstatus/><internalId>1204</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Robustness</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
        <provcov>
          <linksto>Fee.Sections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>850</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Initialization.Startup2.02</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>870</sourceline>
      <version>1</version>
      <description>
                An ERASABLE section shall be be erased and validated at startup 2.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_350</srcid><srcstatus/><internalId>591</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_StartUp_Active_ErasableHeader</srcid><srcstatus/><internalId>1141</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_Active_ErasableFooter</srcid><srcstatus/><internalId>1142</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_Active_Erasable</srcid><srcstatus/><internalId>1143</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_Erasable_Inconsistent</srcid><srcstatus/><internalId>1144</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_Active_InconsisntentErasableFooter</srcid><srcstatus/><internalId>1148</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Robustness</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
        <provcov>
          <linksto>Fee.Sections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>851</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Initialization.Startup2.03</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>894</sourceline>
      <version>1</version>
      <description>
                If all the sections are EMPTY startup 2 shall mark the OLDEST section as ACTIVE 
                and consider it the current ACTIVE section.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_362</srcid><srcstatus/><internalId>594</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_StartUp_Empty_Empty</srcid><srcstatus/><internalId>1133</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Robustness</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
        <provcov>
          <linksto>Fee.Sections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>852</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Initialization.Startup2.04</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>919</sourceline>
      <version>1</version>
      <description>
                If an EMPTY section has no footer written startup 2 shall write the footer 
                with the highest erase counter.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_375</srcid><srcstatus/><internalId>595</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_StartUp_Active_EmptyNoFooter</srcid><srcstatus/><internalId>1140</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Robustness</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
        <provcov>
          <linksto>Fee.Sections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
        <provcov>
          <linksto>Fee.SectionEraseCounter</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>266</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>853</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Initialization.Startup2.05</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>948</sourceline>
      <version>1</version>
      <description>
                If a section has only one section management object marked as ERASABLE startup 2 
                shall mark the other section management object as ERASABLE.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_380</srcid><srcstatus/><internalId>596</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_StartUp_Active_ErasableHeader</srcid><srcstatus/><internalId>1141</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Robustness</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
        <provcov>
          <linksto>Fee.Sections.ERASABLE_marker</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>230</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>854</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Initialization.Startup2.06</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>973</sourceline>
      <version>1</version>
      <description>
                The validation of a section consists in erasing the section and afterwards writing 
                both the section management objects.
            </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_355</srcid><srcstatus/><internalId>593</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_StartUp_Active_ErasableHeader</srcid><srcstatus/><internalId>1141</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_Active_ErasableFooter</srcid><srcstatus/><internalId>1142</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_Active_Erasable</srcid><srcstatus/><internalId>1143</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_Erasable_Inconsistent</srcid><srcstatus/><internalId>1144</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_Inconsistent_Inconsistent</srcid><srcstatus/><internalId>1145</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_Active_Inconsisntent_CID</srcid><srcstatus/><internalId>1146</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_Active_InconsisntentEmptyFooter</srcid><srcstatus/><internalId>1147</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_Active_InconsisntentErasableFooter</srcid><srcstatus/><internalId>1148</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_Active_InconsisntenErasableEmptyFooter</srcid><srcstatus/><internalId>1149</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_Active_InconsisntenErasableErasableFooter</srcid><srcstatus/><internalId>1150</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_SectionUpperHalfErased</srcid><srcstatus/><internalId>1202</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Sections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations><ruleid>WRN.swuts.needscoverage.count</ruleid></oreqmViolations><covstatus>covered</covstatus><internalId>855</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Initialization.Startup2.07</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>992</sourceline>
      <version>1</version>
      <description>
                At initialization Fee shall detect if a switch was interrupted by a reset.
            </description>
      <comment>
                This is very important. Fee shall behave consistantly, as if no reset had occured,
                and continue the switch from the point where it was interrupted.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_393</srcid><srcstatus/><internalId>597</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Switch_ImmediatelyAfterInit_c2s</srcid><srcstatus/><internalId>1032</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_ImmediatelyAfterInit_c4s</srcid><srcstatus/><internalId>1045</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_ImmediatelyAfterInit_i2s</srcid><srcstatus/><internalId>1091</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_ImmediatelyAfterInit_i4s</srcid><srcstatus/><internalId>1103</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_HP_ImmediatelyAfterInit_AllBlocks</srcid><srcstatus/><internalId>1194</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_Inconsistent_InTheMiddle</srcid><srcstatus/><internalId>1201</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_ImmediatelyAfterInit</srcid><srcstatus/><internalId>1263</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_HP_ImmediatelyAfterInit</srcid><srcstatus/><internalId>1273</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Robustness</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>856</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Initialization.Startup2.08</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>1014</sourceline>
      <version>1</version>
      <description>
                If a write job does not fit in the current active section and the next section has to be revalidated, the revalidation process shall take the highest priority.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_972</srcid><srcstatus/><internalId>647</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Switch_SwitchPriority_2_4s</srcid><srcstatus/><internalId>1196</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Robustness</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>857</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Initialization.Startup2.09</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>1034</sourceline>
      <version>1</version>
      <description>
                If no other section needs restaurations Fee shall transition to Idle.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_404</srcid><srcstatus/><internalId>599</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_StartUp_Empty_Empty</srcid><srcstatus/><internalId>1133</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_Active_ErasableHeader</srcid><srcstatus/><internalId>1141</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_Active_ErasableFooter</srcid><srcstatus/><internalId>1142</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_Erasable_Inconsistent</srcid><srcstatus/><internalId>1144</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Robustness</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>858</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Timer.UserJobRequests</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>1054</sourceline>
      <version>1</version>
      <description>
                Any job that starts to be processed, shall trigger a delay timer or predefined number of main function cycles while Fee stays Idle and process coming jobs.
            </description>
      <comment>
                Usually the jobs that interrupts initialization are reads form ReadAll, and they come
                one after the other. It makes no sense to start an internal initialization operation,
                until ReadAll finishes.
                Until the timer expires the section swtich will remain in pending,
                but it will start after the timer has expired.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_219</srcid><srcstatus/><internalId>585</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_929</srcid><srcstatus/><internalId>637</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_1812</srcid><srcstatus/><internalId>685</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Switch_Timer_c4s</srcid><srcstatus/><internalId>1046</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_Timer_i4s</srcid><srcstatus/><internalId>1104</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_Inconsistent_Inconsistent</srcid><srcstatus/><internalId>1145</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_Active_Inconsisntent_CIDCrc</srcid><srcstatus/><internalId>1151</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_Timer</srcid><srcstatus/><internalId>1274</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Initializaion.UserJobRequests</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>258</internalId></provcov>
        <provcov>
          <linksto>Fee.SS.UserJobRequests</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>260</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>859</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Initialization.Idle</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>1083</sourceline>
      <version>1</version>
      <description>
                As soon as Startup1 is completed Fee shall enter in IDLE state and do nothing until the first user
                request comes.
            </description>
      <comment>
                All the non critical initialization opperations shall be postponed until any user job
                is requested, and shall be triggered with a defined delay(the delay timer) after the job completion.
                The implementation shall delay non-critical actions so that the ECU startup time is
                minimised.
                User job requests are more important than internal processes. Therefore we should give them 
                higher priority and interrupt internal processes without damaging them.
                Although they shall have lower priority than section status cheching and blocks caching.
                All other init actions shall be taken afterwards, without affecting ReadAll() run.
                After all the information is identified Fee is available for a ReadAll, therefore the
                multi-block operation can start as soon as possible.
                If the Startup2 would start right after Startup1 ReadAll might be postponed since a
                section erase take long time and it can not be interrupted by read requests.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee.c.m4_191</srcid><srcstatus/><internalId>391</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_2499</srcid><srcstatus/><internalId>571</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_2509</srcid><srcstatus/><internalId>573</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_215</srcid><srcstatus/><internalId>584</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_StartUp_Erasable_Erasable</srcid><srcstatus/><internalId>1132</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_Active_Inconsisntent_CIDCrc</srcid><srcstatus/><internalId>1151</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Initializaion.UserJobRequests</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>258</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>860</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Timer.InternalOperation</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>1116</sourceline>
      <version>1</version>
      <description>
                If the delay timer expires and Fee must continue with an internal operation, the internal operation shall start/resume.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_220</srcid><srcstatus/><internalId>586</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Switch_Timer_c4s</srcid><srcstatus/><internalId>1046</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_Timer_i4s</srcid><srcstatus/><internalId>1104</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_Timer</srcid><srcstatus/><internalId>1274</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Initializaion.UserJobRequests</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>258</internalId></provcov>
        <provcov>
          <linksto>Fee.SS.UserJobRequests</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>260</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>861</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Idle</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>1140</sourceline>
      <version>1</version>
      <description>
                If Fee does not have internal operation to be performed it shall stay Idle in Normal mode and process the requested jobs.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_1222</srcid><srcstatus/><internalId>664</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_1259</srcid><srcstatus/><internalId>665</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Jobs.c_461</srcid><srcstatus/><internalId>714</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Jobs.c_492</srcid><srcstatus/><internalId>717</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Ts_Fee_Jobs_Idle</srcid><srcstatus/><internalId>1000</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00128</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>862</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.WriteBlockInfo</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>1160</sourceline>
      <version>1</version>
      <description>
                A write job starts with writing the block information at the end of the section before writing data.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_935</srcid><srcstatus/><internalId>640</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_1398</srcid><srcstatus/><internalId>669</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_1566</srcid><srcstatus/><internalId>677</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Jobs.c_70</srcid><srcstatus/><internalId>692</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_WriteRefusedRetries</srcid><srcstatus/><internalId>1064</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Robustness</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>863</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.WrittenMarker</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>1180</sourceline>
      <version>1</version>
      <description>
                In order to validate a write job, a marker with the size of a virtual page shall be written next to block info right after data was written.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Jobs.c_345</srcid><srcstatus/><internalId>710</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_WriteFail</srcid><srcstatus/><internalId>1068</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Robustness</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>864</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Write.Behaviour.IDLE.IsSpace</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>1200</sourceline>
      <version>1</version>
      <description>
                If space is available in the Active section for the requested write job the 
                write operation shall be performed in the current Active section.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_922</srcid><srcstatus/><internalId>633</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Ts_Fee_Jobs_Idle</srcid><srcstatus/><internalId>1000</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Sections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>865</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Write.Behaviour.IDLE.NoSpace</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>1221</sourceline>
      <version>1</version>
      <description>
                If space is not available in the Active section for the requested write job the 
                write operation shall be performed in the next Active section, after marking the 
                next section as ACTIVE.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_1042</srcid><srcstatus/><internalId>662</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_1525</srcid><srcstatus/><internalId>673</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Sections.c_493</srcid><srcstatus/><internalId>733</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Switch_CopyBlocks</srcid><srcstatus/><internalId>1260</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Sections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>866</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Write.Behaviour.SSOngoing.IsSpace</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>1243</sourceline>
      <version>1</version>
      <description>
                Write is requested during section switch.
                If free space is available for the write job request and the blocks to be switched
                then it is accepted and processed at the first moment in time when ongoing internal 
                operation can be suspended nondistructively.
                (except the immediate write comming during section erase)
            </description>
      <comment>
                Nondistructively = if a write or an erase is ongoing Fls_Cancel()/MemAcc_Cancel() is not called.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_923</srcid><srcstatus/><internalId>634</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Switch_JobInterrupts_1_3s</srcid><srcstatus/><internalId>1180</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_Interruptions_02</srcid><srcstatus/><internalId>1184</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_Interruptions_03</srcid><srcstatus/><internalId>1185</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_Interruptions_04</srcid><srcstatus/><internalId>1186</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Sections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>867</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Write.Behaviour.SSOngoing.SwapNeeded</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>1268</sourceline>
      <version>1</version>
      <description>
                If space is not available in the Active section for the requested write job,
                but free space is available in other sections for the write job and the blocks
                to be switched the write operation shall be performed in the next Active section,
                after marking the next section as ACTIVE.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_989</srcid><srcstatus/><internalId>648</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Switch_JobInterrupts_1_3s</srcid><srcstatus/><internalId>1180</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_Interruptions_02</srcid><srcstatus/><internalId>1184</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_Interruptions_03</srcid><srcstatus/><internalId>1185</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_Interruptions_04</srcid><srcstatus/><internalId>1186</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Sections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>868</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.WriteCustom.TooManyBlocks</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>1291</sourceline>
      <version>1</version>
      <description>
                If the requested block to write exceedes the configured number of not-configured blocks 
                the job shall be rejected and a Det error, FEE_E_NOT_CFG_BLK_LOST, shall be reported.
            </description>
      <comment>
                If there are more blocks than Fee can identifie or switch, it makes not sense to store it
                in nonvolatile memory. It will be lost anyway.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Extra.c_216</srcid><srcstatus/><internalId>450</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_WriteCustom_FullSlots</srcid><srcstatus/><internalId>1167</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_WriteCustom_Refusals</srcid><srcstatus/><internalId>1168</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeNumberOfNotConfigBlocks.BlocksLost</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>234</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>869</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.CancelSectionErase</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>1314</sourceline>
      <version>1</version>
      <description>
                Fee_CancelSectionErase API calls Fls_Cancel()/MemAcc_Cancel() and sets a flag for Fee_MainFunction to update the Fee state.
                If Fee_MainFunction is interrupted by the call to CancelSectionErase, or if a section erase is not ongoing,
                E_NOT_OK shall be returned.
            </description>
      <comment>
                Fee internal variables and state shall be updated on the next main function call.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Extra.c_437</srcid><srcstatus/><internalId>466</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_CancelSectionErase_01</srcid><srcstatus/><internalId>1001</internalId></linkedfrom><linkedfrom><srcid>TS_FEE_CancelSectionErase_02</srcid><srcstatus/><internalId>1002</internalId></linkedfrom><linkedfrom><srcid>TS_FEE_CancelSectionErase_03</srcid><srcstatus/><internalId>1003</internalId></linkedfrom><linkedfrom><srcid>TS_FEE_CancelSectionErase_04</srcid><srcstatus/><internalId>1004</internalId></linkedfrom><linkedfrom><srcid>TS_FEE_CancelSectionErase_05</srcid><srcstatus/><internalId>1005</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeCancelSectionErase.API</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>278</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>870</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Read.Behaviour.IDLE</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>1337</sourceline>
      <version>1</version>
      <description>
                If a read operation is requested when the module is Idle and the Block is found consistent
                in cache the read request shall be stored and processed.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_1853</srcid><srcstatus/><internalId>688</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Ts_Fee_Jobs_Idle</srcid><srcstatus/><internalId>1000</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00073</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>115</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>871</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Read.Behaviour.SSOngoing</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>1358</sourceline>
      <version>1</version>
      <description>
                If a read operation is requested when a section switch is ongoing, the read request shall be
                accepted and Fee shall process it at the first moment in time when ongoing internal operation can be
                suspended nondistructively.
            </description>
      <comment>
                Nondistructively = if a write or an erase is ongoing Fls_Cancel()/MemAcc_Cancel() is not called.

                A read request can interrupt a switch but it must do so in such a way that the data written by
                the switch is consistent. This means that the write operations of the section switch must take
                priority over the read requests.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_163</srcid><srcstatus/><internalId>581</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Switch_JobInterrupts_1_3s</srcid><srcstatus/><internalId>1180</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_JobInterrupts_2</srcid><srcstatus/><internalId>1276</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.SS.UserJobRequests</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>260</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>872</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Read.Behaviour.BlockInvalid</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>1385</sourceline>
      <version>1</version>
      <description>
                If a read operation is requested and the requested Block Number is found invalidated
                in cache, the Block shall be reported as invalidated.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_1839</srcid><srcstatus/><internalId>687</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Ts_Fee_Jobs_Idle</srcid><srcstatus/><internalId>1000</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00073</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>115</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>873</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Read.Behaviour.BlockInconsistent</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>1406</sourceline>
      <version>1</version>
      <description>
                If a read operation is requested and the requested Block Number is found inconsistent
                in cache, the Block shall be reported as inconsistent.
            </description>
      <comment>
                This can occur if:
                - either the block has no valid instance (from the Fee point of view) in the flash
                - or it was "erased" by a user request (applicable for immediate blocks).

                An erase of the block cannot be done by physically erasing the flash area occupied by
                the block, due to hardware limitations. This is compensating by writing the block header
                with a marker indicating it was erased. In order to be consistent with what an erase
                actually means, Fee shall consider all blocks which have been erased and not written
                or invalidated afterwards, as being inconsistent. After all, an erase is done so that
                the data that was erased cannot be accessed any more.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_1817</srcid><srcstatus/><internalId>686</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Ts_Fee_Jobs_Idle</srcid><srcstatus/><internalId>1000</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00073</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>115</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>874</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Invalidate.Behaviour.IDLE.IsSpace</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>1437</sourceline>
      <version>1</version>
      <description>
                If space is available in the Active section for the requested invalidate job the 
                invalidate operation shall be performed in the current Active section.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_920</srcid><srcstatus/><internalId>631</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_931</srcid><srcstatus/><internalId>638</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Jobs.c_77</srcid><srcstatus/><internalId>693</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Ts_Fee_Jobs_Idle</srcid><srcstatus/><internalId>1000</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Sections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>875</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Invalidate.Behaviour.IDLE.NoSpace</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>1458</sourceline>
      <version>1</version>
      <description>
                If space is not available in the Active section for the requested invalidate job the 
                invalidate operation shall be performed in the next Active section, after marking the 
                next section as ACTIVE.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_1040</srcid><srcstatus/><internalId>660</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Switch_TrigBy_Invalidation</srcid><srcstatus/><internalId>1181</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Sections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>876</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Invalidate.Behaviour.SSOngoing.IsSpace</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>1480</sourceline>
      <version>1</version>
      <description>
                Invalidate is requested during section switch.
                If free space is available for the invalidate job request and the blocks to be switched
                then it is accepted and processed at the first moment in time when ongoing internal 
                operation can be suspended nondistructively.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_925</srcid><srcstatus/><internalId>636</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_932</srcid><srcstatus/><internalId>639</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Jobs.c_78</srcid><srcstatus/><internalId>694</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Switch_JobInterrupts_1_3s</srcid><srcstatus/><internalId>1180</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Sections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>877</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Invalidate.Behaviour.SSOngoing.SwapNeeded</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>1503</sourceline>
      <version>1</version>
      <description>
                If space is not available in the Active section for the requested invalidate job,
                but free space is available in other sections for the invalidate job and the blocks
                to be switched the invalidate operation shall be performed in the next Active section,
                after marking the next section as ACTIVE.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_990</srcid><srcstatus/><internalId>649</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Switch_TrigBy_Invalidation</srcid><srcstatus/><internalId>1181</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Sections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>878</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Invalidate.Behaviour.SSOngoing.NoSpace</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>1526</sourceline>
      <version>1</version>
      <description>
                Invalidate is requested during section switch.
                If free space is not available for the invalidate job request and the blocks to be switched
                then it is accepted but it shall be processed after the section switch finishes.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_969</srcid><srcstatus/><internalId>644</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_1031</srcid><srcstatus/><internalId>656</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Switch_TrigBy_Invalidation</srcid><srcstatus/><internalId>1181</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Sections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>879</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.EraseImmediate.Behaviour.IDLE.IsSpace</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>1548</sourceline>
      <version>1</version>
      <description>
                If space is available in the Active section for the requested EraseImmediate job the 
                EraseImmediate operation shall be performed in the current Active section.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_921</srcid><srcstatus/><internalId>632</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Jobs.c_85</srcid><srcstatus/><internalId>695</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Ts_Fee_Jobs_Idle</srcid><srcstatus/><internalId>1000</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Sections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>880</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.EraseImmediate.Behaviour.IDLE.NoSpace</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>1569</sourceline>
      <version>1</version>
      <description>
                If space is not available in the Active section for the requested EraseImmediate job the 
                EraseImmediate operation shall be performed in the next Active section, after marking the 
                next section as ACTIVE.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_1041</srcid><srcstatus/><internalId>661</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Switch_TrigBy_EraseImm</srcid><srcstatus/><internalId>1182</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Sections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>881</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.EraseImmediate.Behaviour.SSOngoing.IsSpace</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>1591</sourceline>
      <version>1</version>
      <description>
                EraseImmediate is requested during section switch.
                If free space is available for the EraseImmediate job request and the blocks to be switched
                then it is accepted and processed at the first moment in time when ongoing internal 
                operation can be suspended nondistructively.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_924</srcid><srcstatus/><internalId>635</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Jobs.c_86</srcid><srcstatus/><internalId>696</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Switch_JobInterrupts_1_3s</srcid><srcstatus/><internalId>1180</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Sections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>882</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.EraseImmediate.Behaviour.SSOngoing.SwapNeeded</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>1614</sourceline>
      <version>1</version>
      <description>
                If space is not available in the Active section for the requested EraseImmediate job,
                but free space is available in other sections for the EraseImmediate job and the blocks
                to be switched the EraseImmediate operation shall be performed in the next Active section,
                after marking the next section as ACTIVE.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_991</srcid><srcstatus/><internalId>650</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Switch_TrigBy_EraseImm</srcid><srcstatus/><internalId>1182</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Sections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>883</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.EraseImmediate.Behaviour.SSOngoing.NoSpace</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>1637</sourceline>
      <version>1</version>
      <description>
                EraseImmediate is requested during section switch.
                If free space is not available for the EraseImmediate job request and the blocks to be switched
                then it is accepted but it shall be processed after the section switch finishes.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_970</srcid><srcstatus/><internalId>645</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_1032</srcid><srcstatus/><internalId>657</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Switch_TrigBy_EraseImm</srcid><srcstatus/><internalId>1182</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Sections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>884</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Cancel.Behaviour.NoJobPending</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>1659</sourceline>
      <version>1</version>
      <description>
                If Cancel is requested in IDLE when no Fee job is pending then Fee shall perform no action.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee.c.m4_620</srcid><srcstatus/><internalId>412</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Ts_Fee_Cancel_Behavior_JobPending_Normal_NoJobPending</srcid><srcstatus/><internalId>1008</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00164</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>174</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>885</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Cancel.Behaviour.ReadJob</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>1679</sourceline>
      <version>1</version>
      <description>
                Cancel is requested and Read job is in progress
                - If flash cancel API is available, the flash job is cancelled.
                - If flash cancel API is not available, the Fee job is stopped after the pending flash
                job is complete.

                In both cases, Fee does not copy data from the internal buffer to the user buffer.
            </description>
      <comment>
                NOTE: the read job here does not refer to a read during section switch but to a normal
                NvM read request.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_764</srcid><srcstatus/><internalId>617</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Ts_Fee_Cancel_Behavior_JobOngoing_Normal_02</srcid><srcstatus/><internalId>1009</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee_FEE_080_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>204</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>886</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Cancel.Behaviour.WriteJob.WriteBlockInfo</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>1706</sourceline>
      <version>1</version>
      <description>
                If a Cancel is requested during write of Block Info for a write job, Fee shall
                cancel the ongoing flash write operation for the block info.
            </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_765</srcid><srcstatus/><internalId>618</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Ts_Fee_Cancel_Behavior_JobOngoing_Normal_02</srcid><srcstatus/><internalId>1009</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee_FEE_080_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>204</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>887</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Cancel.Behaviour.WriteBlockData</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>1725</sourceline>
      <version>1</version>
      <description>
                Cancel is requested when Write of Block Data is in progress
                - If flash cancel API is available, the flash job is cancelled.
                - If flash cancel API is not available, the Fee job is stopped after the pending flash
                job is complete.
            </description>
      <comment>
                NOTE:
                If section switching has been interrupted for the write of an immediate block, the
                fee_status will then be set back to MEMIF_BUSY_INTERNAL, otherwise it will be MEMIF_IDLE.
                In any case, the fee_state will be set to IDLE. Section switching will be resumed from there.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_768</srcid><srcstatus/><internalId>621</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Ts_Fee_Cancel_Behavior_JobOngoing_Normal_02</srcid><srcstatus/><internalId>1009</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee_FEE_080_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>204</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>888</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Cancel.Behaviour.InvalidateJob.WriteBlockInfo</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>1752</sourceline>
      <version>1</version>
      <description>
                If a Cancel is requested during write of Block Info for an invalidate job, Fee shall
                cancel the ongoing flash write operation for the block info.
            </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_767</srcid><srcstatus/><internalId>620</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Ts_Fee_Cancel_Behavior_JobOngoing_Normal_02</srcid><srcstatus/><internalId>1009</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee_FEE_080_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>204</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>889</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Cancel.Behaviour.WriteJob.WriteWrittenMarker</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>1771</sourceline>
      <version>1</version>
      <description>
                If a Cancel is requested during write of Written Marker Fee shall
                cancel the ongoing flash write operation for the block info written marker.
            </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_766</srcid><srcstatus/><internalId>619</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Ts_Fee_Cancel_Behavior_WrittenMarkerOngoing_Imp01</srcid><srcstatus/><internalId>998</internalId></linkedfrom><linkedfrom><srcid>Ts_Fee_Cancel_Behavior_JobOngoing_Normal_02</srcid><srcstatus/><internalId>1009</internalId></linkedfrom><linkedfrom><srcid>Ts_Fee_Cancel_Behavior_WrittenMarkerOngoing</srcid><srcstatus/><internalId>1015</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee_FEE_080_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>204</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>890</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Cancel.Behaviour.InternalOperations</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>1790</sourceline>
      <version>1</version>
      <description>
                If Cancel is requested while an internal write/erase operation is in progress, Fee
                shall not cancel the ongoing flash write/erase operation.
            </description>
      <comment>
                Internal write operations must not be cancelled or subject to cancellation due to upper layer
                Cancel requests.
                The cancellation of a section erase is determined internally by the Fee module,
                based on existing conditions at the time the upper layer makes a request that can
                cause a section erase to be cancelled (immediate write or read, either during a
                section switch).
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee.c.m4_621</srcid><srcstatus/><internalId>413</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Ts_Fee_Cancel_Behavior_WritingSectionHeader_Imp01</srcid><srcstatus/><internalId>999</internalId></linkedfrom><linkedfrom><srcid>Ts_Fee_Cancel_Behavior_WritingSectionHeader</srcid><srcstatus/><internalId>1016</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00164</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>174</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>891</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Cancel.Behaviour.ReportNvm</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>1817</sourceline>
      <version>1</version>
      <description>
                If a Cancel is requested by the upper layer then, after taking the needed actions,
                Fee shall, as a last action, call the job error notification callback of the upper
                layer before returning from the Fee_Cancel call.
            </description>
      <comment>
                The cancellation of a job is a synchronous operation. This means that the outcome of the Cancel
                request must be "visible" before the Cancel function returns, for the upper layer.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee.c.m4_628</srcid><srcstatus/><internalId>414</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Ts_Fee_Cancel_Behavior_JobOngoing_Normal_02</srcid><srcstatus/><internalId>1009</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee_FEE_080_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>204</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>892</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Cancel.Behaviour.FeeMemAccUsage.CancelOngoing</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>1841</sourceline>
      <version>1</version>
      <description>
                 If MemAcc is used when the lower layer "Cancel" API is called, the Fee state mashine will enter the internal
                state "CANCEL_ONGOING".
            </description>
      <comment>
                If MemAcc is used the "Cancel" API of the lower layer shall be considered asyncrounous.
            </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_MemAccAsyncCancel</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee_FEE_080_4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>207</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>893</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Cancel.Behaviour.FeeMemAccUsage.Cancel</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>1862</sourceline>
      <version>1</version>
      <description>
                  When the Fee state mashine is in the state "CANCEL_ONGOING" it will enter the next pending state when 
                the lower layer state is different than "PENDING".
            </description>
      <comment>
                If MemAcc is used the "Cancel" API of the lower layer shall be considered asyncrounous.
            </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FEE_MemAccAsyncCancel</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee_FEE_080_4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>207</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>894</internalId></specobject>
    <specobject>
      <id>Fee.Dns.SS.CopyBlocks</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>1883</sourceline>
      <version>1</version>
      <description>
                For each block that has it's newest instance in the oldest consistent section,
                section switch shall copy the instance in the current ACTIVE section, regardless 
                that the instance is written by user or already copied by switch.
            </description>
      <comment>
                By doing so, the latest data is kept in the non volatile memory, 
                and the physical memory is uniformly worn.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_458</srcid><srcstatus/><internalId>603</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Fee.Dsn.Critical.SwitchRequiredSize</srcid><srcstatus/><internalId>951</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Switch_CopyBlocks_c2s</srcid><srcstatus/><internalId>1029</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_CopyCopiedBlocks_c2s</srcid><srcstatus/><internalId>1030</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_CopyBlocks_c4s</srcid><srcstatus/><internalId>1041</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_CopyCopiedBlocks_c4s</srcid><srcstatus/><internalId>1042</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_OnlyOldSection_c4s</srcid><srcstatus/><internalId>1043</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_CopyBlocks_i2s</srcid><srcstatus/><internalId>1088</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_CopyCopiedBlocks_i2s</srcid><srcstatus/><internalId>1089</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Imm_RestartSwitchFromRS</srcid><srcstatus/><internalId>1095</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_CopyBlocks_i4s</srcid><srcstatus/><internalId>1099</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_CopyCopiedBlocks_i4s</srcid><srcstatus/><internalId>1100</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_OnlyOldSection_i4s</srcid><srcstatus/><internalId>1101</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_ActiveNoFooter</srcid><srcstatus/><internalId>1156</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_ActiveWrongConsisntencyPattern</srcid><srcstatus/><internalId>1157</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_OnlyOldSection</srcid><srcstatus/><internalId>1192</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_CopyBlocks</srcid><srcstatus/><internalId>1260</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_CopyCopiedBlocks</srcid><srcstatus/><internalId>1261</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Sections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations><ruleid>WRN.swuts.needscoverage.count</ruleid></oreqmViolations><covstatus>covered</covstatus><internalId>895</internalId></specobject>
    <specobject>
      <id>Fee.Dns.SS.RevalidateOldSection</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>1908</sourceline>
      <version>1</version>
      <description>
                After copying all the blocks that needed to be copied from oldest section, the oldest section shall be revalidated.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_486</srcid><srcstatus/><internalId>604</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Switch_RevalidateOldSection_c2s</srcid><srcstatus/><internalId>1031</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_RevalidateOldSection_c4s</srcid><srcstatus/><internalId>1044</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_RevalidateOldSection_i2s</srcid><srcstatus/><internalId>1090</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_RevalidateOldSection_i4s</srcid><srcstatus/><internalId>1102</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_RevalidateOldSection_AllBlocks</srcid><srcstatus/><internalId>1193</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_RevalidateOldSection</srcid><srcstatus/><internalId>1262</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Sections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>896</internalId></specobject>
    <specobject>
      <id>Fee.Dns.SS.TriggeringTheSwitch.WriteRequest</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>1928</sourceline>
      <version>1</version>
      <description>
                If there are more than 2 sections configured then, at runtime, the Section Switch shall
                be triggered if the current Write request, upon completion, shall cause the number of
                remaining empty sections to be less than half of the configured ones, rounded up.
            </description>
      <comment>
                The triggering of the Section Switch can be done in advance so that the available
                memory for the block switching is greater. This allows for more available memory
                where to store possible immediate write requests.
            </comment>
      <needscoverage>
        <needscov><needsobj>lim</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>lim.Fee.EB_INTREQ_Fee_0019</srcid><srcstatus/><internalId>18</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_998</srcid><srcstatus/><internalId>651</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Switch_CopyBlocks_c2s</srcid><srcstatus/><internalId>1029</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_CopyBlocks_c4s</srcid><srcstatus/><internalId>1041</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_CopyBlocks_i2s</srcid><srcstatus/><internalId>1088</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Imm_RestartSwitchFromRS</srcid><srcstatus/><internalId>1095</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_CopyBlocks_i4s</srcid><srcstatus/><internalId>1099</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_CopyBlocks</srcid><srcstatus/><internalId>1260</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Sections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>897</internalId></specobject>
    <specobject>
      <id>Fee.Dns.SS.TriggeringTheSwitch.InvalidateRequest</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>1954</sourceline>
      <version>1</version>
      <description>
                If there are more than 2 sections configured then, at runtime, the Section Switch shall
                be triggered if the current Invalidate request, upon completion, shall cause the number
                of remaining empty sections to be less than half of the configured ones, rounded up.
            </description>
      <comment>
                The triggering of the Section Switch can be done in advance so that the available
                memory for the block switching is greater. This allows for more available memory
                where to store possible immediate write requests.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_999</srcid><srcstatus/><internalId>652</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Switch_InvalidateTrigger</srcid><srcstatus/><internalId>1265</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Sections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>898</internalId></specobject>
    <specobject>
      <id>Fee.Dns.SS.TriggeringTheSwitch.EraseRequest</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>1979</sourceline>
      <version>1</version>
      <description>
                If there are more than 2 sections configured then, at runtime, the Section Switch shall
                be triggered if the current Erase request, upon completion, shall cause the number
                of remaining empty sections to be less than half of the configured ones, rounded up.
            </description>
      <comment>
                The triggering of the Section Switch can be done in advance so that the available
                memory for the block switching is greater. This allows for more available memory
                where to store possible immediate write requests.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_1000</srcid><srcstatus/><internalId>653</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Switch_EraseImmTrigger</srcid><srcstatus/><internalId>1266</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Sections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>899</internalId></specobject>
    <specobject>
      <id>Fee.Dns.SS.TriggeringTheSwitch.AfterInit</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>2004</sourceline>
      <version>1</version>
      <description>
                If, during initialization, the Fee module detects that a section switch was interrupted
                by a reset then the section switch is triggered imediatelly after the Startup2.
            </description>
      <comment>
                By delaing the resume of the section switch until the first write job and not a read job 
                will assure that ReadAll will not be interrupted by internal operations, as long as the 
                first request is a read from ReadAll as it should be.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_396</srcid><srcstatus/><internalId>598</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Switch_ImmediatelyAfterInit_c2s</srcid><srcstatus/><internalId>1032</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_HP_ImmediatelyAfterInit_c2s</srcid><srcstatus/><internalId>1033</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_ImmediatelyAfterInit_c4s</srcid><srcstatus/><internalId>1045</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_ImmediatelyAfterInit_i2s</srcid><srcstatus/><internalId>1091</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_HP_ImmediatelyAfterInit_i2s</srcid><srcstatus/><internalId>1092</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_ImmediatelyAfterInit_i4s</srcid><srcstatus/><internalId>1103</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_HP_ImmediatelyAfterInit_2s</srcid><srcstatus/><internalId>1176</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_ImmediatelyAfterInit</srcid><srcstatus/><internalId>1263</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Sections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>900</internalId></specobject>
    <specobject>
      <id>Fee.Dns.SS.Behaviour.SSResume.BlockSwitching.Writing</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>2028</sourceline>
      <version>1</version>
      <description>
                Section switch shall be resumed if the request that interrupted it is complete,
                the section switch is in progress and the last switch operation done was a write.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_434</srcid><srcstatus/><internalId>600</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_SectionsSwitch.c_159</srcid><srcstatus/><internalId>747</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_SectionsSwitch.c_390</srcid><srcstatus/><internalId>754</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_SectionsSwitch.c_395</srcid><srcstatus/><internalId>755</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Switch_WriteResumed_c4s</srcid><srcstatus/><internalId>1047</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_JobInterrupts_1_c4s</srcid><srcstatus/><internalId>1048</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_JobInterrupts_2_c4s</srcid><srcstatus/><internalId>1049</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_WriteResumed_i4s</srcid><srcstatus/><internalId>1105</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_JobInterrupts_1_i4s</srcid><srcstatus/><internalId>1106</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_JobInterrupts_2_i4s</srcid><srcstatus/><internalId>1107</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_JobInterrupts_1_3s</srcid><srcstatus/><internalId>1180</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_JobInterrupts_1_4s</srcid><srcstatus/><internalId>1195</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_WriteResumed</srcid><srcstatus/><internalId>1275</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_JobInterrupts_2</srcid><srcstatus/><internalId>1276</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Sections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>901</internalId></specobject>
    <specobject>
      <id>Fee.Dns.SS.Behaviour.SSResume.BlockSwitching.Reading</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>2049</sourceline>
      <version>1</version>
      <description>
                The last operation of the section switch shall be restarted if the request that
                interrupted it is complete, the section switch is in progress and the last
                switch operation done was a read.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_435</srcid><srcstatus/><internalId>601</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_SectionsSwitch.c_272</srcid><srcstatus/><internalId>751</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_SectionsSwitch.c_295</srcid><srcstatus/><internalId>752</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Switch_ReadRestarted_c4s</srcid><srcstatus/><internalId>1050</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_ReadRestarted_i4s</srcid><srcstatus/><internalId>1108</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_ReadRestarted</srcid><srcstatus/><internalId>1277</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Sections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>902</internalId></specobject>
    <specobject>
      <id>Fee.Dns.SS.Behaviour.SSResume.BlockSwitching.SectionErase</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>2071</sourceline>
      <version>1</version>
      <description>
                The section erase shall be restarted if the request that interrupted is complete.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_436</srcid><srcstatus/><internalId>602</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Sections.c_568</srcid><srcstatus/><internalId>738</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_AbortErase_DuringSwitch</srcid><srcstatus/><internalId>1019</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_AbortErase_DuringSwitch_i4s</srcid><srcstatus/><internalId>1112</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Sections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>903</internalId></specobject>
    <specobject>
      <id>Fee.Dns.SS.Behaviour.ChangingActiveSection</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>2091</sourceline>
      <version>1</version>
      <description>
                When the switch is processing a write, if Fee detects that
                the remaining available memory in the current ACTIVE section is not enough
                to store the block, Fee shall change the ACTIVE section to the next one that
                can be used and also write the related markers, before processing the request.
            </description>
      <comment>
                Fee always calculates the space available in memory and before processing a
                Write/Erase/Invalidate it is verified if the space is enough to store the block.
                The next empty section will become the new Active section.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_559</srcid><srcstatus/><internalId>607</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Sections.c_468</srcid><srcstatus/><internalId>732</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Sections.c_742</srcid><srcstatus/><internalId>743</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Sections.c_767</srcid><srcstatus/><internalId>744</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Switch_ChangingActive_5s</srcid><srcstatus/><internalId>1054</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_ChangingActive_s</srcid><srcstatus/><internalId>1084</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_ChangingActive</srcid><srcstatus/><internalId>1278</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Sections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>904</internalId></specobject>
    <specobject>
      <id>Fee.Dns.SS.SwitchPriority</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>2117</sourceline>
      <version>1</version>
      <description>
                When the last empty section is used (becomes ACTIVE) then the section switch will
                get the highest priority.
            </description>
      <comment>
                If there is no more space in the current section and a section change is needed for the requested write job and the next section is the last one available, 
                the write job will be performed in the next Active section, after the high priority switch is finished.

                If the section is used exclusively for block switching then, if needed, it can be erased
                and the section switch restarted without any risk of data loss.

                If the last not full, ACTIVE section, becomes too full with unusable data (due to
                multiple resets, for example) then that section can be erased and the section switch
                restarted since it only contains blocks that were copied by the section switch. If
                any immediate write would be allowed to be performed in this section then:
                - either it would not have enough available memory for all switch remaining blocks
                - or, upon erase, it will not contain the immediate write request(s)

                Either way, at least one block will be lost.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_971</srcid><srcstatus/><internalId>646</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_1033</srcid><srcstatus/><internalId>658</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Switch_Interruptions_01</srcid><srcstatus/><internalId>1183</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_SwitchPriority_2_4s</srcid><srcstatus/><internalId>1196</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_Inconsistent_InTheMiddle</srcid><srcstatus/><internalId>1201</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_SwitchPriority_2</srcid><srcstatus/><internalId>1258</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_SwitchPriority_1</srcid><srcstatus/><internalId>1264</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_SwitchPriority_3</srcid><srcstatus/><internalId>1279</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Sections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
        <provcov>
          <linksto>Fee.Secured</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>221</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>905</internalId></specobject>
    <specobject>
      <id>Fee.Dns.SS.ErasePriority</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>2156</sourceline>
      <version>1</version>
      <description>
                If there is no more space whatsoever in the last available section, the next/oldest section being marked as erasable during high priority switch, 
                the write job shall be performed in the next section, after the high priority revalidation and marking as active is done.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_968</srcid><srcstatus/><internalId>643</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Sections.c_120</srcid><srcstatus/><internalId>724</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Switch_Inconsistent_InTheMiddle</srcid><srcstatus/><internalId>1201</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Sections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>906</internalId></specobject>
    <specobject>
      <id>Fee.Dns.SS.SwitchPriority.BlockToSwitch</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>2177</sourceline>
      <version>1</version>
      <description>
                If a request triggers a Section Switch and the block subject to the request is among
                the ones that will be switched then, if written successfully, Fee will not switch 
                the old instance any more.
            </description>
      <comment>
                Giving the request priority is the same as giving the switch priority, in terms of a
                reset occuring while the block is being written/switched. Therefore, it makes sense
                to give a change for completion to the upper layer request as it is newer than the
                already stored instance of the block.

                Both block writing and block switching are done "header first".
                - If the reset occurs during the writing of the header then it will be seen as "not
                valid" during the initialization. In this case, the previous instance will be found
                and, if possible, switched.
                - Otherwise, the header will be seen as valid during the initialization, meaning that
                the block will be seen as valid during init and it will not be switched any more, thus
                causing its valid instance to be lost when the section that was switched is erased.

                After writing the block header and the block data, the marker will be written in an
                independent Virtual Page of the block header. In this case if the block is either
                written or switched, a reset can occur after writing the data but prior to writing
                the marker.

                Either way, Fee will behave the same after init.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Jobs.c_565</srcid><srcstatus/><internalId>721</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Switch_BlockToSwitch</srcid><srcstatus/><internalId>1280</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Sections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>907</internalId></specobject>
    <specobject>
      <id>Fee.Dns.SS.SwitchPriority.JobLosesPriority</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>2218</sourceline>
      <version>1</version>
      <description>
                Any job that will cause the section switch to have the highest priority or
                the job is requested while the section switch already has the highest priority
                than the job will be performed only after the section switch is completely finished.
            </description>
      <comment>
                In order to guarantee no data loss for the blocks already existing in the section that requires
                switching, Fee must complete the section switch, erase and validate the switched section and only
                then perform the immediate write. Otherwise, at least one block that requires switching will not
                be switched and, thus, lost when its section is erased.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_1034</srcid><srcstatus/><internalId>659</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Switch_Interruptions_01</srcid><srcstatus/><internalId>1183</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_Interruptions_04</srcid><srcstatus/><internalId>1186</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_SwitchPriority_1</srcid><srcstatus/><internalId>1264</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_SwitchPriority_3</srcid><srcstatus/><internalId>1279</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Sections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>908</internalId></specobject>
    <specobject>
      <id>Fee.Dns.SS.RestartSwitch.ConditionForRestart</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>2244</sourceline>
      <version>1</version>
      <description>
                The section switch will be restarted if the newest section is ACTIVE and 
                the remaining available memory in it is not enough for all the blocks which require switching.
            </description>
      <comment>
                Since, in the only non-full section, there are only instances of the blocks that
                were written there by the switch mechanism, these can be erased without any risk
                of data loss. Once the section is erased and validated, being completely empty it
                has enough room for all blocks which require switching.

                This way, there is no risk of data loss due to insufficient available memory for
                all blocks that need switching. The downsize is that the total amount of time needed
                for the section switching is higher and that there is extra stress over the affected
                section (at least one extra erase-write cycle).

                However, since this situation has a very low likelihood of occurring in the every day
                usage of the car, the impact can be consider insignificant.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_544</srcid><srcstatus/><internalId>606</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Switch_Restart_DueToFailures_2s</srcid><srcstatus/><internalId>1177</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_Restart_DueToResets_2s</srcid><srcstatus/><internalId>1178</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_Restart_DueToFailures</srcid><srcstatus/><internalId>1271</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_Restart_DueToResets</srcid><srcstatus/><internalId>1272</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Sections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
        <provcov>
          <linksto>Fee.Secured</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>221</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>909</internalId></specobject>
    <specobject>
      <id>Fee.Dns.SS.RestartSwitch.TriggerAfterInit</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>2281</sourceline>
      <version>1</version>
      <description>
                If, during module initialization, Fee detects that a switch restart is required then,
                once the initialization completes, Fee will not trigger the
                restart of the section switch until the first user request from the upper layer.
            </description>
      <comment>
                Since the switch restart implies early on a section erase which cannot be cancelled if
                the Fls_Cancel is not available, this will delay the ReadAll without any real justification,
                thus causing a prolonged ECU init time.

                Giving the NvM_ReadAll a higher priority than the section switch will reduce init time.

                Starting the switch early means that it will be at least partially complete by the time
                the ECU initialization is finished.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_2502</srcid><srcstatus/><internalId>572</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_894</srcid><srcstatus/><internalId>630</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Switch_Restart_DueToResets_2s</srcid><srcstatus/><internalId>1178</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_Restart_DueToFailures</srcid><srcstatus/><internalId>1271</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_Restart_DueToResets</srcid><srcstatus/><internalId>1272</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Sections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
        <provcov>
          <linksto>Fee.Secured</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>221</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>910</internalId></specobject>
    <specobject>
      <id>Fee.Dns.SS.RestartSwitch.Priority</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>2315</sourceline>
      <version>1</version>
      <description>
                The section switch shall have the highest priority, in case of a switch restart, until all
                the switch related operations are finished.
            </description>
      <comment>
                In order to ensure that no data loss takes place due to the restarting of the switch, any
                immediate write request will have to be postponed so that it will not be done in the same
                section in which the blocks are switched.

                If an immediate write request is given priority over the switch and, due to resets, for
                example, the Fee module detects that the ACTIVE section needs to be erased and the switch
                restarted, the immediate block will be lost with the erase of the ACTIVE section. Since
                data loss must be avoided whenever possible, the logical approach is to give top priority
                to the switch mechanism so that when Fee processes the immediate write, it will do so
                without the risk of losing the block due to a restart of the switch.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_489</srcid><srcstatus/><internalId>605</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Switch_Restart_DueToFailures_2s</srcid><srcstatus/><internalId>1177</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_Restart_DueToFailures</srcid><srcstatus/><internalId>1271</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Sections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
        <provcov>
          <linksto>Fee.Secured</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>221</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>911</internalId></specobject>
    <specobject>
      <id>Fee.Dns.SS.RestartSwitch</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>2350</sourceline>
      <version>1</version>
      <description>
                When restarting a switch, Fee shall identify all blocks that require switching and
                it shall switch all of them again, once the ACTIVE section is revalidated.
            </description>
      <comment>
                The idea is not to lose any blocks that still require switching so that data loss is avoided.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_1876</srcid><srcstatus/><internalId>689</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Switch_Restart_DueToFailures_2s</srcid><srcstatus/><internalId>1177</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_Restart_DueToResets_2s</srcid><srcstatus/><internalId>1178</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_Restart_DueToFailures</srcid><srcstatus/><internalId>1271</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_Restart_DueToResets</srcid><srcstatus/><internalId>1272</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Sections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
        <provcov>
          <linksto>Fee.Secured</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>221</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>912</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.FlashRefusal</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>2376</sourceline>
      <version>1</version>
      <description>
                If Fls/MemAcc being busy refuses a Fee job request (returns E_NOT_OK) then Fee shall perform a predefined number of retries.
            </description>
      <comment>
                Fls/MemAcc should not refuse Fee requests. Therefore, if it does, it means that either it is not
                initialized or that it is busy. In both situations, this is an integration issue.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_692</srcid><srcstatus/><internalId>610</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Fee_GenTest_01_Insuficient_AllBlocks</srcid><srcstatus/><internalId>986</internalId></linkedfrom><linkedfrom><srcid>Fee_GenTest_02_Insuficient_AllBlocksPlusOne</srcid><srcstatus/><internalId>987</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Init_BlankCheckRefusals_H_and_F</srcid><srcstatus/><internalId>1055</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Init_Failures_H_and_F</srcid><srcstatus/><internalId>1057</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Init_BlockCache_RefuseFail</srcid><srcstatus/><internalId>1058</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Init_Cache_SectionTotalRefusal</srcid><srcstatus/><internalId>1059</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_WriteRefused</srcid><srcstatus/><internalId>1060</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_ReadRefused</srcid><srcstatus/><internalId>1061</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_InvalidateRefused</srcid><srcstatus/><internalId>1062</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_EraseImmediateRefused</srcid><srcstatus/><internalId>1063</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_WriteRefusedRetries</srcid><srcstatus/><internalId>1064</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_ReadRefusedRetries</srcid><srcstatus/><internalId>1065</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_InvalidateRefusedRetries</srcid><srcstatus/><internalId>1066</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_EraseImmRefusedRetries</srcid><srcstatus/><internalId>1067</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_Refusals</srcid><srcstatus/><internalId>1074</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_FlsError</srcid><srcstatus/><internalId>1076</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_S2</srcid><srcstatus/><internalId>1078</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_Swap</srcid><srcstatus/><internalId>1079</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_SS</srcid><srcstatus/><internalId>1080</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_SS_OldS</srcid><srcstatus/><internalId>1081</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_HP_SS</srcid><srcstatus/><internalId>1082</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_HP_Reset</srcid><srcstatus/><internalId>1083</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_HeaderWriteError</srcid><srcstatus/><internalId>1085</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Robustness</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations><ruleid>WRN.swuts.needscoverage.count</ruleid></oreqmViolations><covstatus>covered</covstatus><internalId>913</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.FlashRefusal.Failed</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>2400</sourceline>
      <version>1</version>
      <description>
                If Fls/MemAcc is not busy and refuses a Fee job request (returns E_NOT_OK), or all the predefined number of retries 
                performed due to refusal expire, then Fee shall consider the request as failed and behave just like Fls/MemAcc reported a failure,
                but without considering any lost flash space.
            </description>
      <comment>
                Fls/MemAcc should not refuse Fee requests. Therefore, if it does, it means that either it is not
                initialized or that it is busy. In both situations, this is an integration issue.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_703</srcid><srcstatus/><internalId>612</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Init_BlankCheckRefusals_H_and_F</srcid><srcstatus/><internalId>1055</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Init_Failures_H_and_F</srcid><srcstatus/><internalId>1057</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Init_BlockCache_RefuseFail</srcid><srcstatus/><internalId>1058</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Init_Cache_SectionTotalRefusal</srcid><srcstatus/><internalId>1059</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_WriteRefused</srcid><srcstatus/><internalId>1060</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_ReadRefused</srcid><srcstatus/><internalId>1061</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_InvalidateRefused</srcid><srcstatus/><internalId>1062</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_EraseImmediateRefused</srcid><srcstatus/><internalId>1063</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_WriteRefusedRetries</srcid><srcstatus/><internalId>1064</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_ReadRefusedRetries</srcid><srcstatus/><internalId>1065</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_InvalidateRefusedRetries</srcid><srcstatus/><internalId>1066</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_EraseImmRefusedRetries</srcid><srcstatus/><internalId>1067</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_Refusals</srcid><srcstatus/><internalId>1074</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_FlsError</srcid><srcstatus/><internalId>1076</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_S2</srcid><srcstatus/><internalId>1078</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_Swap</srcid><srcstatus/><internalId>1079</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_SS</srcid><srcstatus/><internalId>1080</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_SS_OldS</srcid><srcstatus/><internalId>1081</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_HP_SS</srcid><srcstatus/><internalId>1082</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_HP_Reset</srcid><srcstatus/><internalId>1083</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_HeaderWriteError</srcid><srcstatus/><internalId>1085</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Robustness</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations><ruleid>WRN.swuts.needscoverage.count</ruleid></oreqmViolations><covstatus>covered</covstatus><internalId>914</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.FlashRefusal.Failed.Det</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>2426</sourceline>
      <version>1</version>
      <description>
                If Fls/MemAcc is not busy and refuses a Fee job request (returns E_NOT_OK), or all the predefined number of retries 
                performed due to refusal expire, then Fee shall report the Det runtime error FEE_E_FLS_REQUEST_REFUSED.
            </description>
      <comment>
                Fls/MemAcc should not refuse Fee requests. Therefore, if it does, it means that either it is not
                initialized or that it is busy. In both situations, this is an integration issue.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_699</srcid><srcstatus/><internalId>611</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Init_Failures_H_and_F</srcid><srcstatus/><internalId>1057</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Init_BlockCache_RefuseFail</srcid><srcstatus/><internalId>1058</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Init_Cache_SectionTotalRefusal</srcid><srcstatus/><internalId>1059</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_WriteRefused</srcid><srcstatus/><internalId>1060</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_ReadRefused</srcid><srcstatus/><internalId>1061</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_InvalidateRefused</srcid><srcstatus/><internalId>1062</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_EraseImmediateRefused</srcid><srcstatus/><internalId>1063</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_WriteRefusedRetries</srcid><srcstatus/><internalId>1064</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_ReadRefusedRetries</srcid><srcstatus/><internalId>1065</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_InvalidateRefusedRetries</srcid><srcstatus/><internalId>1066</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_EraseImmRefusedRetries</srcid><srcstatus/><internalId>1067</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_Refusals</srcid><srcstatus/><internalId>1074</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_FlsError</srcid><srcstatus/><internalId>1076</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_S2</srcid><srcstatus/><internalId>1078</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_Swap</srcid><srcstatus/><internalId>1079</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_SS</srcid><srcstatus/><internalId>1080</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_SS_OldS</srcid><srcstatus/><internalId>1081</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_HP_SS</srcid><srcstatus/><internalId>1082</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_HP_Reset</srcid><srcstatus/><internalId>1083</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_HeaderWriteError</srcid><srcstatus/><internalId>1085</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Robustness</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations><ruleid>WRN.swuts.needscoverage.count</ruleid></oreqmViolations><covstatus>covered</covstatus><internalId>915</internalId></specobject>
    <specobject>
      <id>Fee.Dns.FailureHandling.Job</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>2450</sourceline>
      <version>1</version>
      <description>
                If a flash failure occurs during the processing of an user job request, 
                Fee shall proceed with the following actions:
                - Stop the job processing;
                - Set the job result to failure;
                - Report an error to the upper layer via "JobError" callback(if configured);
                - Set the module status to IDLE;
                - Fee is ready to accept further job requests.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Jobs.c_238</srcid><srcstatus/><internalId>705</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Jobs.c_363</srcid><srcstatus/><internalId>711</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Jobs.c_514</srcid><srcstatus/><internalId>718</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Jobs.c_594</srcid><srcstatus/><internalId>723</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_DataInfoMarginFail_c4s</srcid><srcstatus/><internalId>1052</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_WriteRefused</srcid><srcstatus/><internalId>1060</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_ReadRefused</srcid><srcstatus/><internalId>1061</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_InvalidateRefused</srcid><srcstatus/><internalId>1062</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_EraseImmediateRefused</srcid><srcstatus/><internalId>1063</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_WriteRefusedRetries</srcid><srcstatus/><internalId>1064</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_ReadRefusedRetries</srcid><srcstatus/><internalId>1065</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_InvalidateRefusedRetries</srcid><srcstatus/><internalId>1066</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_EraseImmRefusedRetries</srcid><srcstatus/><internalId>1067</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_WriteFail</srcid><srcstatus/><internalId>1068</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_ReadFail</srcid><srcstatus/><internalId>1069</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_InvalidateFail</srcid><srcstatus/><internalId>1070</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_EraseImmediateFail</srcid><srcstatus/><internalId>1071</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_DataInfoMarginFail</srcid><srcstatus/><internalId>1072</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_DataInfoMarginFail_i4s</srcid><srcstatus/><internalId>1110</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Robustness</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations><ruleid>WRN.swuts.needscoverage.count</ruleid></oreqmViolations><covstatus>covered</covstatus><internalId>916</internalId></specobject>
    <specobject>
      <id>Fee.Dns.FailureHandling.Behaviour.StoreReqFailure</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>2476</sourceline>
      <version>1</version>
      <description>
                If a write/invalidate/erase request made by Fee to Fls/MemAcc is accepted by the Fls/MemAcc but the
                processing of the write request fails, Fee shall update the addresses used for write
                operations to compensate.
            </description>
      <comment>
                If the Fls/MemAcc accepted the "write" request then Fee has no possibilty of knowing if the failure that
                Fls/MemAcc reported took place prior to any data being written or during the writing of the data. In this
                case, Fee must compensate by skipping the entire area subject to the "write" and continuing from
                the next available address.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Jobs.c_104</srcid><srcstatus/><internalId>697</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Jobs.c_215</srcid><srcstatus/><internalId>703</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Jobs.c_260</srcid><srcstatus/><internalId>706</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Jobs.c_283</srcid><srcstatus/><internalId>708</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Jobs.c_307</srcid><srcstatus/><internalId>709</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_DataInfoMarginFail_c4s</srcid><srcstatus/><internalId>1052</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_InvalidateFail</srcid><srcstatus/><internalId>1070</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_EraseImmediateFail</srcid><srcstatus/><internalId>1071</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_DataInfoMarginFail</srcid><srcstatus/><internalId>1072</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_DataInfoMarginFail_i4s</srcid><srcstatus/><internalId>1110</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Robustness</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>917</internalId></specobject>
    <specobject>
      <id>Fee.Dns.FailureHandling.Behaviour.BlockInfoMargin</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>2502</sourceline>
      <version>1</version>
      <description>
                If a configured number of block infos, representing the border between data and infos,
                fail to be written consecutively Fee shall go to the next section.
            </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Jobs.c_204</srcid><srcstatus/><internalId>701</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_DataInfoMarginFail_c4s</srcid><srcstatus/><internalId>1052</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_DataInfoMarginFail</srcid><srcstatus/><internalId>1072</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_DataInfoMarginFail_i4s</srcid><srcstatus/><internalId>1110</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.NoFlashPageOverriden</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>222</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>918</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.FlashRead.BlockInfos.Fails</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>2521</sourceline>
      <version>1</version>
      <description>
                If Fls/MemAcc reported a failure when reading a set of block infos (by calling the Fee_JobErrorNotification
                callback) then Fee shall perform needed internal operations in order to take into account the read
                failure and proceed with reading all possible block infos from the related memory area, one at a time.
            </description>
      <comment>
                If a read request failed then it is logical to assume that the related contents from the
                flash memory are either unreadable or corrupt. Therefore, Fee must consider the data as
                inconsistent and proceed as such with its internal operations that are related to the
                read request.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_827</srcid><srcstatus/><internalId>487</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Init_BlockCache_RefuseFail</srcid><srcstatus/><internalId>1058</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Robustness</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>919</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.FlashRead.BlockInfoByBlockInfo.Fails</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>2547</sourceline>
      <version>1</version>
      <description>
                If Fls/MemAcc reported a failure when reading a single block info (by calling the Fee_JobErrorNotification
                callback) then Fee shall ignore the block and continue reading the next block info until 
                all the size that failed during buffer reading is checked.
            </description>
      <comment>
                If a read request failed then it is logical to assume that the related contents from the
                flash memory are either unreadable or corrupt. Therefore, Fee must consider the data as
                inconsistent and proceed as such with its internal operations that are related to the
                read request.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_902</srcid><srcstatus/><internalId>488</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_983</srcid><srcstatus/><internalId>492</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_1093</srcid><srcstatus/><internalId>495</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_1167</srcid><srcstatus/><internalId>499</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Init_Cache_SectionTotalRefusal</srcid><srcstatus/><internalId>1059</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Robustness</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>920</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.FailureHandling.Behaviour.Startup1.HeaderFailed</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>2573</sourceline>
      <version>1</version>
      <description>
                If, during module initialization, the reading or validation of the first section
                header fails, Fee shall memorise this and attempt to read the section footer.
            </description>
      <comment>
                The term "validation" includes, besides the checking of the data Vs the checksum to
                see if it can be used or not, also the patterns that are written for the section header.
                If the patterns are not correct, the header is considered to be "not valid".
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_682</srcid><srcstatus/><internalId>483</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Init_Failures_H_and_F</srcid><srcstatus/><internalId>1057</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Robustness</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>921</internalId></specobject>
    <specobject>
      <id>Fee.Dns.FailureHandling.Behaviour.Startup1.FooterFailed</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>2597</sourceline>
      <version>1</version>
      <description>
                If, during module initialization, the reading or validation of the footer section
                fails, Fee shall memorise this and determine the validity based also on the
                section header.
            </description>
      <comment>
                The reason behind this is that it might be possible for a section marker to fail
                when written for the first section header but to be successfully written for the
                second section header. The term "validation" includes, besides the checking of the
                data Vs the checksum to see if it can be used or not, also the patterns that are
                written for the section header. If the patterns are not correct, the header is
                considered to be "not valid".
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_754</srcid><srcstatus/><internalId>485</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Init_Failures_H_and_F</srcid><srcstatus/><internalId>1057</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Robustness</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>922</internalId></specobject>
    <specobject>
      <id>Fee.Dns.FailureHandling.Behaviour.Startup1.BothSectionManagementObjectsFailed</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>2625</sourceline>
      <version>1</version>
      <description>
                If, during module initialization, a section has no readable or valid headers (meaning both failed
                in terms or reading or validation), Fee shall memorise the INCONSISTENCY of the section in order to
                be revalidated prior to using it.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Init_Failures_H_and_F</srcid><srcstatus/><internalId>1057</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_SectionStatus_00</srcid><srcstatus/><internalId>1198</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_SectionStatus_01</srcid><srcstatus/><internalId>1199</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_SectionStatus_02</srcid><srcstatus/><internalId>1200</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_2167</srcid><srcstatus/><internalId>547</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Robustness</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>923</internalId></specobject>
    <specobject>
      <id>Fee.Dns.FailureHandling.Behaviour.WritingSectionHeader.Failure</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>2647</sourceline>
      <version>1</version>
      <description>
                If a write failure occurs while writing the section header (or its related patterns, if configured),
                Fee shall memorise this and proceed with writing the same but for the section footer.
            </description>
      <comment>
                It shall be assured that the section status is always correct in order to avoid invalid
                combinations of section status during startup. Since a section has two headers, determining
                the outcome of writing a given field should be done only when both write requests have a
                known result.
            </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Section_Refusals_FlsError</srcid><srcstatus/><internalId>1076</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_S2</srcid><srcstatus/><internalId>1078</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_Swap</srcid><srcstatus/><internalId>1079</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_SS</srcid><srcstatus/><internalId>1080</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_SS_OldS</srcid><srcstatus/><internalId>1081</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_HP_SS</srcid><srcstatus/><internalId>1082</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_HP_Reset</srcid><srcstatus/><internalId>1083</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_HeaderWriteError</srcid><srcstatus/><internalId>1085</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Sections.c_386</srcid><srcstatus/><internalId>731</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Robustness</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>924</internalId></specobject>
    <specobject>
      <id>Fee.Dns.FailureHandling.Behaviour.WritingSectionFooter.Failure</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>2672</sourceline>
      <version>1</version>
      <description>
                If a write failure occurs while writing the section footer (or its related patterns, if configured),
                Fee shall trigger revalidation of the section by requesting the marking for erasable.
            </description>
      <comment>
                Retrying to write the field will most likely result in failure as well. It makes no sense
                to do so. Also, on a healthy flash, write errors should, theoretically, not occur (or
                occur but very rarely). By continuing with its activities, Fee will allow for the chance
                to recover from the encountered error.
            </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Section_Refusals_FlsError</srcid><srcstatus/><internalId>1076</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_S2</srcid><srcstatus/><internalId>1078</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_Swap</srcid><srcstatus/><internalId>1079</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_SS</srcid><srcstatus/><internalId>1080</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_SS_OldS</srcid><srcstatus/><internalId>1081</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_HP_SS</srcid><srcstatus/><internalId>1082</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_HP_Reset</srcid><srcstatus/><internalId>1083</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Sections.c_513</srcid><srcstatus/><internalId>735</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Robustness</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>925</internalId></specobject>
    <specobject>
      <id>Fee.Dns.FailureHandling.Behaviour.MarkingHeaderActive.Failure</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>2697</sourceline>
      <version>1</version>
      <description>
                If a write failure occurs while writing the ACTIVE field for the section header,
                Fee shall trigger an ACTIVE marking in footer.
            </description>
      <comment>  
                Retrying to write the field will most likely result in failure as well. It makes no sense to do
                so. Also, on a healthy flash, write errors should, theoretically, not occur (or occur but very
                rarely). By continuing with its activities, Fee will allow for the chance to recover from the
                encountered error.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Sections.c_169</srcid><srcstatus/><internalId>726</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Section_Refusals_FlsError</srcid><srcstatus/><internalId>1076</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_S2</srcid><srcstatus/><internalId>1078</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_Swap</srcid><srcstatus/><internalId>1079</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_SS</srcid><srcstatus/><internalId>1080</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_SS_OldS</srcid><srcstatus/><internalId>1081</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_HP_SS</srcid><srcstatus/><internalId>1082</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_HP_Reset</srcid><srcstatus/><internalId>1083</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_HeaderWriteError</srcid><srcstatus/><internalId>1085</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_ConsistentActiveX_Empty</srcid><srcstatus/><internalId>1134</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Robustness</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>926</internalId></specobject>
    <specobject>
      <id>Fee.Dns.FailureHandling.Behaviour.MarkingFooterActive.Failure</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>2722</sourceline>
      <version>1</version>
      <description>
                If a write failure occurs while writing the ACTIVE field for the section footer,
                Fee shall trigger revalidation of the section by requesting the marking for erasable.
            </description>
      <comment>  
                Retrying to write the field will most likely result in failure as well. It makes no sense to do
                so. Also, on a healthy flash, write errors should, theoretically, not occur (or occur but very
                rarely). By continuing with its activities, Fee will allow for the chance to recover from the
                encountered error.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Sections.c_183</srcid><srcstatus/><internalId>727</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Section_Refusals_FlsError</srcid><srcstatus/><internalId>1076</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_S2</srcid><srcstatus/><internalId>1078</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_Swap</srcid><srcstatus/><internalId>1079</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_SS</srcid><srcstatus/><internalId>1080</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_SS_OldS</srcid><srcstatus/><internalId>1081</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_HP_SS</srcid><srcstatus/><internalId>1082</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_HP_Reset</srcid><srcstatus/><internalId>1083</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Robustness</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>927</internalId></specobject>
    <specobject>
      <id>Fee.Dns.FailureHandling.Behaviour.MarkingHeaderErasable.Failure</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>2747</sourceline>
      <version>1</version>
      <description>
                If a write failure occurs while writing the ERASABLE field for the section header,
                Fee shall trigger an ERASABLE marking in footer.
            </description>
      <comment>  
                Retrying to write the field will most likely result in failure as well. It makes no sense to do
                so. Also, on a healthy flash, write errors should, theoretically, not occur (or occur but very
                rarely). By continuing with its activities, Fee will allow for the chance to recover from the
                encountered error.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Sections.c_242</srcid><srcstatus/><internalId>728</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Section_Refusals_FlsError</srcid><srcstatus/><internalId>1076</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_S2</srcid><srcstatus/><internalId>1078</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_Swap</srcid><srcstatus/><internalId>1079</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_SS</srcid><srcstatus/><internalId>1080</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_SS_OldS</srcid><srcstatus/><internalId>1081</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_HP_SS</srcid><srcstatus/><internalId>1082</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_HP_Reset</srcid><srcstatus/><internalId>1083</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Robustness</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>928</internalId></specobject>
    <specobject>
      <id>Fee.Dns.FailureHandling.Behaviour.MarkingFooterErasable.Failure</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>2772</sourceline>
      <version>1</version>
      <description>
                If a write failure occurs while writing the ERASABLE field for the section footer,
                Fee shall trigger revalidation of the section by requesting an erase for the section.
            </description>
      <comment>  
                Retrying to write the field will most likely result in failure as well. It makes no sense to do
                so. Also, on a healthy flash, write errors should, theoretically, not occur (or occur but very
                rarely). By continuing with its activities, Fee will allow for the chance to recover from the
                encountered error.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Sections.c_300</srcid><srcstatus/><internalId>729</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Section_Refusals_FlsError</srcid><srcstatus/><internalId>1076</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_S2</srcid><srcstatus/><internalId>1078</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_Swap</srcid><srcstatus/><internalId>1079</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_SS</srcid><srcstatus/><internalId>1080</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_SS_OldS</srcid><srcstatus/><internalId>1081</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_HP_SS</srcid><srcstatus/><internalId>1082</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_HP_Reset</srcid><srcstatus/><internalId>1083</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Robustness</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>929</internalId></specobject>
    <specobject>
      <id>Fee.Dns.FailureHandling.Behaviour.SectionSwitch.WriteBlockInfo</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>2797</sourceline>
      <version>1</version>
      <description>
                If the switch writing of a block info fails, then Fee shall consider the coresponding write space as lost, 
                update the section adresses accordingly and restart the switching of the same block.
            </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_SectionsSwitch.c_177</srcid><srcstatus/><internalId>748</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Switch_Failures_c4s</srcid><srcstatus/><internalId>1040</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_Refusals</srcid><srcstatus/><internalId>1074</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_Failures</srcid><srcstatus/><internalId>1075</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_Failures_i4s</srcid><srcstatus/><internalId>1098</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Robustness</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
        <provcov>
          <linksto>Fee.NoFlashPageOverriden</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>222</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>930</internalId></specobject>
    <specobject>
      <id>Fee.Dns.FailureHandling.Behaviour.SectionSwitch.BlockDataWrite</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>2820</sourceline>
      <version>1</version>
      <description>
                If the switch writing of a block data fails, then Fee shall consider the coresponding write space as lost, 
                update the section adresses accordingly and restart the switching of the same block.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_SectionsSwitch.c_413</srcid><srcstatus/><internalId>756</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Switch_Failures_c4s</srcid><srcstatus/><internalId>1040</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_Refusals</srcid><srcstatus/><internalId>1074</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_Failures</srcid><srcstatus/><internalId>1075</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_Failures_i4s</srcid><srcstatus/><internalId>1098</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Robustness</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
        <provcov>
          <linksto>Fee.NoFlashPageOverriden</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>222</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>931</internalId></specobject>
    <specobject>
      <id>Fee.Dns.FailureHandling.Behaviour.SectionSwitch.BlockWrittenMarkerWrite</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>2845</sourceline>
      <version>1</version>
      <description>
                If the switch writing of a written marker fails, then Fee shall consider the coresponding write space as lost, 
                update the section adresses accordingly and restart the switching of the same block.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_SectionsSwitch.c_504</srcid><srcstatus/><internalId>758</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Switch_Failures_c4s</srcid><srcstatus/><internalId>1040</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_Refusals</srcid><srcstatus/><internalId>1074</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_Failures</srcid><srcstatus/><internalId>1075</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_Failures_i4s</srcid><srcstatus/><internalId>1098</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Robustness</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
        <provcov>
          <linksto>Fee.NoFlashPageOverriden</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>222</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>932</internalId></specobject>
    <specobject>
      <id>Fee.Dns.FailureHandling.Behaviour.SectionSwitch.BlockDataRead</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>2870</sourceline>
      <version>1</version>
      <description>
                If the switch data reading fails then Fee shall perform one retry to read the block data and:
                - if the retry fails, consider the block as lost and continue with the next switch operation;
                - if the retry is successful, continue with switching the block.
            </description>
      <comment>
                In this case, the read and all related retries failed, the block is lost. Fee cannot use
                the block data as it cannot be read. On a healthy ECU, this should not happen.
            </comment>
      <needscoverage>
        <needscov><needsobj>lim</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>lim.Fee.EB_INTREQ_Fee_0016</srcid><srcstatus/><internalId>15</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_SectionsSwitch.c_313</srcid><srcstatus/><internalId>753</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Switch_Failures_c4s</srcid><srcstatus/><internalId>1040</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_Refusals</srcid><srcstatus/><internalId>1074</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_Failures</srcid><srcstatus/><internalId>1075</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_Failures_i4s</srcid><srcstatus/><internalId>1098</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Robustness</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>933</internalId></specobject>
    <specobject>
      <id>Fee.Dns.FailureHandling.Behaviour.SectionSwitch.BlockInfoMargin</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>2895</sourceline>
      <version>1</version>
      <description>
                If a configured number of block infos, representing the border between data and infos,
                fail to be written consecutively Fee shall go to the next section. 
                In case of Switch No Suspend, the section shall be marked as ERASABLE,
                erased, validated and the switch must be restarted.
            </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_SectionsSwitch.c_180</srcid><srcstatus/><internalId>749</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Switch_Failures_c4s</srcid><srcstatus/><internalId>1040</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_Failures</srcid><srcstatus/><internalId>1075</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_Failures_i4s</srcid><srcstatus/><internalId>1098</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.NoFlashPageOverriden</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>222</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>934</internalId></specobject>
    <specobject>
      <id>Fee.Dns.FailureHandling.Behaviour.Failure.SectionErase.HighPrio</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>2916</sourceline>
      <version>1</version>
      <description>
                If a failure occurs while erasing a section with highest priority activated,
                Fee shall re-trigger an erase operation for that section.
            </description>
      <comment>
                Unless a section is erased and validated, it cannot be used by the Fee as it does not have
                a known state so attempts to store or retrieve data will, most likely, end in failure (this
                must be avoided).
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Sections.c_625</srcid><srcstatus/><internalId>741</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Section_Refusals_S2</srcid><srcstatus/><internalId>1078</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_Swap</srcid><srcstatus/><internalId>1079</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_SS</srcid><srcstatus/><internalId>1080</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_HP_Reset</srcid><srcstatus/><internalId>1083</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_PostponeErase_HighPrio</srcid><srcstatus/><internalId>1179</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Robustness</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>935</internalId></specobject>
    <specobject>
      <id>Fee.Dns.FailureHandling.Behaviour.Failure.SectionErase.LowPrio</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>2940</sourceline>
      <version>1</version>
      <description>
                If a failure occurs while erasing a section, without highest priority activated, Fee shall 
                allow other requests to be executed, and re-trigger an erase operation for that section at a later time.
            </description>
      <comment>
                If a read or write request is received, it may be executed before restarting the erase operation.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Sections.c_630</srcid><srcstatus/><internalId>742</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Section_Refusals_FlsError</srcid><srcstatus/><internalId>1076</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_SS_OldS</srcid><srcstatus/><internalId>1081</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_Refusals_HP_SS</srcid><srcstatus/><internalId>1082</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Section_PostponeErase_LowPrio</srcid><srcstatus/><internalId>1086</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Robustness</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>936</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Startup1.Cancel.NoRequest</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>2962</sourceline>
      <version>1</version>
      <description>
                If the upper layer calls the &lt;function&gt;Fee_Cancel&lt;/function&gt; function while Fee is processing
                Startup 1 and there is no upper layer request memorised by the Fee then the call to the
                &lt;function&gt;Fee_Cancel&lt;/function&gt; shall not impact the Fee module in any way.
            </description>
      <comment>
                This should never happen in a normal functionality, for a well integrated MemStack. If this does
                occur, the Det error &lt;literal&gt;FEE_E_INVALID_CANCEL&lt;/literal&gt; is reported by the Fee, if configured.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee.c.m4_618</srcid><srcstatus/><internalId>410</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Ts_Fee_Cancel_Behavior_JobPending_Startup1_NoRequest</srcid><srcstatus/><internalId>993</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00164</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>174</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>937</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Startup1.Cancel.HasRequest</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>2986</sourceline>
      <version>1</version>
      <description>
                If the upper layer calls the &lt;function&gt;Fee_Cancel&lt;/function&gt; function while Fee is processing
                Startup 1 and there is an upper layer request memorised by the Fee then Fee shall clear the
                memorised request and be ready to accept another request, prior to calling the upper layer
                notification callback function.
            </description>
      <comment>
                This is according to the AUTOSAR specified behavior.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_793</srcid><srcstatus/><internalId>625</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Ts_Fee_Cancel_Behavior_JobPending_Startup1_NoRequest</srcid><srcstatus/><internalId>993</internalId></linkedfrom><linkedfrom><srcid>Ts_Fee_Cancel_Behavior_JobPending_Startup1</srcid><srcstatus/><internalId>1010</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00081</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>938</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Startup2.Cancel.NoRequest</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>3010</sourceline>
      <version>1</version>
      <description>
                If the upper layer calls the &lt;function&gt;Fee_Cancel&lt;/function&gt; function while Fee is processing
                Startup 2 and there is no upper layer request memorised by the Fee then the call to the
                &lt;function&gt;Fee_Cancel&lt;/function&gt; shall not impact the Fee module in any way.
            </description>
      <comment>
                This should never happen in a normal functionality, for a well integrated MemStack. If this does
                occur, the Det error &lt;literal&gt;FEE_E_INVALID_CANCEL&lt;/literal&gt; is reported by the Fee, if configured.
            </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Ts_Fee_Cancel_Behavior_JobPending_Startup2_NoRequest</srcid><srcstatus/><internalId>994</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee.c.m4_619</srcid><srcstatus/><internalId>411</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00164</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>174</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>939</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Startup2.Cancel.HasRequest.Pending</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>3034</sourceline>
      <version>1</version>
      <description>
                If the upper layer calls the &lt;function&gt;Fee_Cancel&lt;/function&gt; function while Fee is processing
                Startup 2 and there is an upper layer request memorised by the Fee but not yet passed to the Fls/MemAcc,
                Fee shall clear the memorised request and be ready to accept another request, prior to calling
                the upper layer notification callback function.
            </description>
      <comment>
                This is according to the AUTOSAR specified behavior.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_790</srcid><srcstatus/><internalId>622</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Ts_Fee_Cancel_Behavior_JobPending_Startup2_NoRequest</srcid><srcstatus/><internalId>994</internalId></linkedfrom><linkedfrom><srcid>Ts_Fee_Cancel_Behavior_JobPending_Startup2</srcid><srcstatus/><internalId>1011</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00081</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>940</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Startup2.Cancel.HasRequest.Ongoing</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>3058</sourceline>
      <version>1</version>
      <description>
                If the upper layer calls the &lt;function&gt;Fee_Cancel&lt;/function&gt; function while Fee is processing
                Startup 2 and there is an upper layer request memorised by the Fee and passed to the Fls/MemAcc,
                Fee shall propagate the cancellation request to the Fls/MemAcc, clear the memorised request and
                be ready to accept another request, prior to calling the upper layer notification callback
                function.
            </description>
      <comment>
                This is according to the AUTOSAR specified behavior.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_761</srcid><srcstatus/><internalId>614</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Ts_Fee_Cancel_Behavior_JobOngoing_Startup2_Imp01</srcid><srcstatus/><internalId>995</internalId></linkedfrom><linkedfrom><srcid>Ts_Fee_Cancel_Behavior_JobOngoing_Startup2</srcid><srcstatus/><internalId>1012</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00081</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>941</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Normal.Cancel.HasRequest.Pending</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>3083</sourceline>
      <version>1</version>
      <description>
                If the upper layer calls the &lt;function&gt;Fee_Cancel&lt;/function&gt; function while an upper layer
                request is memorised by the Fee but not yet passed to the Fls/MemAcc, Fee shall only clear the
                memorised request so it can accept another, prior to calling the upper layer notification
                callback function.
            </description>
      <comment>
                This is according to the AUTOSAR specified behavior.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_791</srcid><srcstatus/><internalId>623</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Ts_Fee_Cancel_Behavior_JobPending_Normal</srcid><srcstatus/><internalId>992</internalId></linkedfrom><linkedfrom><srcid>Ts_Fee_Cancel_Behavior_JobOngoing_Normal_01</srcid><srcstatus/><internalId>1007</internalId></linkedfrom><linkedfrom><srcid>Ts_Fee_Cancel_Behavior_JobPending_Normal_NoJobPending</srcid><srcstatus/><internalId>1008</internalId></linkedfrom><linkedfrom><srcid>Ts_Fee_Cancel_Behavior_JobOngoing_Normal_02</srcid><srcstatus/><internalId>1009</internalId></linkedfrom><linkedfrom><srcid>Ts_Fee_Cancel_Behavior_JobOngoing_Normal_c4s</srcid><srcstatus/><internalId>1053</internalId></linkedfrom><linkedfrom><srcid>Ts_Fee_Cancel_Behavior_JobOngoing_Normal_i4s</srcid><srcstatus/><internalId>1111</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00081</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>942</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Normal.Cancel.HasRequest.Ongoing</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>3107</sourceline>
      <version>1</version>
      <description>
                If the upper layer calls the &lt;function&gt;Fee_Cancel&lt;/function&gt; function while an upper layer
                request memorised by the Fee and passed to the Fls/MemAcc is ongoing, Fee shall propagate the cancellation
                request to the Fls/MemAcc, clear the memorised request and be ready to accept another request, prior to
                calling the upper layer notification callback function.
            </description>
      <comment>
                This is according to the AUTOSAR specified behavior.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_762</srcid><srcstatus/><internalId>615</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Ts_Fee_Cancel_Behavior_JobPending_Normal</srcid><srcstatus/><internalId>992</internalId></linkedfrom><linkedfrom><srcid>Ts_Fee_Cancel_Behavior_JobOngoing_Normal_01</srcid><srcstatus/><internalId>1007</internalId></linkedfrom><linkedfrom><srcid>Ts_Fee_Cancel_Behavior_JobPending_Normal_NoJobPending</srcid><srcstatus/><internalId>1008</internalId></linkedfrom><linkedfrom><srcid>Ts_Fee_Cancel_Behavior_JobOngoing_Normal_02</srcid><srcstatus/><internalId>1009</internalId></linkedfrom><linkedfrom><srcid>Ts_Fee_Cancel_Behavior_JobOngoing_Normal_c4s</srcid><srcstatus/><internalId>1053</internalId></linkedfrom><linkedfrom><srcid>Ts_Fee_Cancel_Behavior_JobOngoing_Normal_i4s</srcid><srcstatus/><internalId>1111</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee_FEE_080_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>204</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>943</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.SectonSwitch.Cancel.HasRequest.Pending</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>3131</sourceline>
      <version>1</version>
      <description>
                If the upper layer calls the &lt;function&gt;Fee_Cancel&lt;/function&gt; function while Fee is processing
                the section switch and there is an upper layer request memorised by the Fee but not yet passed
                to the Fls/MemAcc, Fee shall clear the memorised request and be ready to accept another request, prior
                to calling the upper layer notification callback function.
            </description>
      <comment>
                This is according to the AUTOSAR specified behavior.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_792</srcid><srcstatus/><internalId>624</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Ts_Fee_Cancel_Behavior_JobPending_SectionSwitch_Imp01</srcid><srcstatus/><internalId>997</internalId></linkedfrom><linkedfrom><srcid>Ts_Fee_Cancel_Behavior_JobPending_SectionSwitch</srcid><srcstatus/><internalId>1014</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00081</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>944</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.SectonSwitch.Cancel.HasRequest.Ongoing</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>3155</sourceline>
      <version>1</version>
      <description>
                If the upper layer calls the &lt;function&gt;Fee_Cancel&lt;/function&gt; function while Fee is processing
                the section switch and there is an upper layer request memorised by the Fee and passed to the Fls/MemAcc,
                Fee shall propagate the cancellation request to the Fls/MemAcc, clear the memorised request and be ready
                to accept another request, prior to calling the upper layer notification callback function.
            </description>
      <comment>
                This is according to the AUTOSAR specified behavior.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_763</srcid><srcstatus/><internalId>616</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Ts_Fee_Cancel_Behavior_JobOngoing_SectionSwitch_Imp01</srcid><srcstatus/><internalId>996</internalId></linkedfrom><linkedfrom><srcid>Ts_Fee_Cancel_Behavior_JobOngoing_SectionSwitch</srcid><srcstatus/><internalId>1013</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00081</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>945</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Critical.SectionChange</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>3180</sourceline>
      <version>1</version>
      <description>
                If the critical block is configured, the write of the critical block that changes the section shall not trigger the marking as active, but the writing itself.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_1526</srcid><srcstatus/><internalId>674</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Critical_ChangeSection</srcid><srcstatus/><internalId>1038</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Critical_FailureChangeSection</srcid><srcstatus/><internalId>1039</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeCriticalBlock.Priority</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>281</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>946</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Critical.SectionFull</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>3200</sourceline>
      <version>1</version>
      <description>
                If the critical block is configured and the write of the critical block fails at block info writing while changing the section, that section shall be considered as full.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Jobs.c_188</srcid><srcstatus/><internalId>699</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Jobs.c_209</srcid><srcstatus/><internalId>702</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Critical_FailureChangeSection</srcid><srcstatus/><internalId>1039</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.NoFlashPageOverriden</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>222</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>947</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Critical.CriticalSection</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>3221</sourceline>
      <version>1</version>
      <description>
                If the critical block is configured, Fee shall reserve space for critical block only in critical section, namely the last section that can accept jobs.
            </description>
      <comment>
                The next section to critical section is either inconsistent or it is the highest priority switch section.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_956</srcid><srcstatus/><internalId>641</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_1019</srcid><srcstatus/><internalId>654</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_1504</srcid><srcstatus/><internalId>672</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_1591</srcid><srcstatus/><internalId>678</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_1694</srcid><srcstatus/><internalId>682</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_1785</srcid><srcstatus/><internalId>684</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Critical_ChangeSection</srcid><srcstatus/><internalId>1038</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeCriticalBlock.Priority</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>281</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>948</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Critical.InterruptItself</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>3243</sourceline>
      <version>1</version>
      <description>
                A critical write can not interrupt another request of critical write or critical read.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee.c.m4_508</srcid><srcstatus/><internalId>406</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Critical_ReadInIdle</srcid><srcstatus/><internalId>1035</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Critical_BehaviorAtStartUp_4s</srcid><srcstatus/><internalId>1037</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeCriticalBlock.Cancel</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>282</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>949</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Critical.ResumeFailed</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>3264</sourceline>
      <version>1</version>
      <description>
                Any Fee operation that are interrupted by critical write shall be resumed as failed after the critical block is requested to be erased.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/Fee_Internal.h.m4_190</srcid><srcstatus/><internalId>378</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_293</srcid><srcstatus/><internalId>589</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_1309</srcid><srcstatus/><internalId>666</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Critical_FrozenState_HP</srcid><srcstatus/><internalId>1249</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeCriticalBlock.HealInternaly</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>287</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>950</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.Critical.SwitchRequiredSize</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>3285</sourceline>
      <version>1</version>
      <description>
                If there are only 2 section configured, the space for critical block shall be considered while computing the switch required size.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_616</srcid><srcstatus/><internalId>608</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Critical_WriteTime_HP</srcid><srcstatus/><internalId>1248</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.CopyBlocks</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>895</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>951</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.DynamicBlockLength.Init</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>3305</sourceline>
      <version>1</version>
      <description>
                Fee shall store the block sizes found in flash at initialization in the FeeOldSizes[FEE_NO_OF_CONFIGURED_BLOCKS] array.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_1631</srcid><srcstatus/><internalId>524</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeDynamicBlockLength.Config</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>292</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>952</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.DynamicBlockLength.Switch</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>3324</sourceline>
      <version>1</version>
      <description>
                Fee shall switch the reconfigured blocks using the size stored in FeeOldSizes[FEE_NO_OF_CONFIGURED_BLOCKS] array.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/Fee_Internal.h.m4_543</srcid><srcstatus/><internalId>379</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_ReconfReadWrite</srcid><srcstatus/><internalId>1269</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_ReconfSwitchRead</srcid><srcstatus/><internalId>1270</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeDynamicBlockLength.Config</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>292</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>953</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.BlankCheck.SectionManagement</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>3344</sourceline>
      <version>1</version>
      <description>
                If the BlankCheck is used, Fee shall blank-check the section management object (in header and footer)
                and proceed with reading it if not blank.
            </description>
      <comment>
                If the blank-check passes Fee will put the erase value in buffer for evaluation.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_183</srcid><srcstatus/><internalId>469</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_268</srcid><srcstatus/><internalId>472</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Init_BlankCheckRefusals_H_and_F</srcid><srcstatus/><internalId>1055</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_Empty_Empty</srcid><srcstatus/><internalId>1133</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_Active_Empty</srcid><srcstatus/><internalId>1135</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_Active_Active</srcid><srcstatus/><internalId>1139</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_Active_EmptyNoFooter</srcid><srcstatus/><internalId>1140</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_Active_Erasable</srcid><srcstatus/><internalId>1143</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_Erasable_Inconsistent</srcid><srcstatus/><internalId>1144</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00187</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>185</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>954</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.BlankCheck.SectionMarkers</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>3366</sourceline>
      <version>1</version>
      <description>
                If the BlankCheck is used, Fee shall blank-check the section markers, Active and Erasable (in header and footer)
                and consider the marker written if not blank, otherwise consider the marker as not written.
            </description>
      <comment>
                If the BlankCheck is used, a section marker will not be read but considered either written or
                not depending on the blank-check result.
                If a blank-check passes on a section marker Fee will simulate the reading of an empty field by 
                writing the erased value in the reading buffer.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee.c.m4_310</srcid><srcstatus/><internalId>394</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_356</srcid><srcstatus/><internalId>475</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_425</srcid><srcstatus/><internalId>477</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_494</srcid><srcstatus/><internalId>479</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_562</srcid><srcstatus/><internalId>481</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Init_BlankCheckRefusals_H_and_F</srcid><srcstatus/><internalId>1055</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_Empty_Empty</srcid><srcstatus/><internalId>1133</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_Active_Empty</srcid><srcstatus/><internalId>1135</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_Active_Active</srcid><srcstatus/><internalId>1139</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_Active_EmptyNoFooter</srcid><srcstatus/><internalId>1140</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_Active_Erasable</srcid><srcstatus/><internalId>1143</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_Erasable_Inconsistent</srcid><srcstatus/><internalId>1144</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00187</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>185</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>955</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.BlankCheck.SectionManagementRefused</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>3391</sourceline>
      <version>1</version>
      <description>
                If the blank-check job on a section management is refused by Fls/MemAcc,
                Fee shall consider the section management as corrupted.
            </description>
      <comment>
                Fee will simulate a corrupted field by writing 0x00.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_232</srcid><srcstatus/><internalId>470</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_330</srcid><srcstatus/><internalId>474</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Init_BlankCheckRefusals_H_and_F</srcid><srcstatus/><internalId>1055</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00187</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>185</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>956</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.BlankCheck.ErasableRefused</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>3413</sourceline>
      <version>1</version>
      <description>
                If the blank-check job on Erasable marker is refused by Fls/MemAcc,
                Fee shall consider the marker as corrupted.
            </description>
      <comment>
                Fee will simulate a corrupted field by writing 0x00.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_527</srcid><srcstatus/><internalId>480</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_595</srcid><srcstatus/><internalId>482</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Init_BlankCheckRefusals_H_and_F</srcid><srcstatus/><internalId>1055</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00187</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>185</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>957</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.BlankCheck.ActiveRefused</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>3435</sourceline>
      <version>1</version>
      <description>
                If the blank-check job on Active marker is refused by Fls/MemAcc,
                Fee shall consider the marker as written.
            </description>
      <comment>
                Is better to consider the section as Active and not finding blocks in it than
                consider it as empty and try to write over already written data. (not to mention
                that the written data is lost)
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_390</srcid><srcstatus/><internalId>476</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_459</srcid><srcstatus/><internalId>478</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Init_BlankCheckRefusals_H_and_F</srcid><srcstatus/><internalId>1055</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00187</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>185</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>958</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.BlankCheck.WrittenMarker</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>3459</sourceline>
      <version>1</version>
      <description>
                If the BlankCheck is used, Fee shall blank-check the written marker instead of reading it while caching,
                and proceed with the reading of the block stamp if not blank.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_939</srcid><srcstatus/><internalId>490</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_1230</srcid><srcstatus/><internalId>502</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_1278</srcid><srcstatus/><internalId>504</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_1916</srcid><srcstatus/><internalId>532</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Init_BlockBlankCheck_RefuseFail</srcid><srcstatus/><internalId>1056</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_BlockCacheFlowBlankCheck</srcid><srcstatus/><internalId>1137</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00187</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>185</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>959</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.BlankCheck.WrittenMarkerBlank</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>3480</sourceline>
      <version>1</version>
      <description>
                If the Written marker is blank proceed with blank-checking the block stamp.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_968</srcid><srcstatus/><internalId>491</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Init_BlockBlankCheck_RefuseFail</srcid><srcstatus/><internalId>1056</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_BlockCacheFlowBlankCheck</srcid><srcstatus/><internalId>1137</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00187</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>185</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>960</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.BlankCheck.BlockStamp</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>3500</sourceline>
      <version>1</version>
      <description>
                If the block stamp is not blank Fee shall read the block stamp and validate it as usual.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_1014</srcid><srcstatus/><internalId>494</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_1108</srcid><srcstatus/><internalId>497</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Init_BlockBlankCheck_RefuseFail</srcid><srcstatus/><internalId>1056</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_BlockCacheFlowBlankCheck</srcid><srcstatus/><internalId>1137</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00187</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>185</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>961</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.BlankCheck.BlockStampBlank</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>3520</sourceline>
      <version>1</version>
      <description>
                If the block stamp is blank Fee shall consider that the block info was not written
                and continue the caching by blank-checking the next block info's written marker.
            </description>
      <comment>
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_1154</srcid><srcstatus/><internalId>498</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Init_BlockBlankCheck_RefuseFail</srcid><srcstatus/><internalId>1056</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_BlockCacheFlowBlankCheck</srcid><srcstatus/><internalId>1137</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00187</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>185</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>962</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.BlankCheck.ErasableBitFlip</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>3541</sourceline>
      <version>1</version>
      <description>
                If only one Erasable marker is not blank from the two, the header one or the footer one,
                the section shall be considered as Empty if not marked as Active, otherwise it shall be considered Active.
            </description>
      <comment>
                Any bit flip in a Erasable marker field could lead to losing all the data in the section.
                In this case better consider the section as not marked for erase and cache it.
                The only disadvantage is that the marking for erase will report write failure.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_2219</srcid><srcstatus/><internalId>553</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_2246</srcid><srcstatus/><internalId>557</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_AbortErase_NormalStartup2</srcid><srcstatus/><internalId>1021</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_AbortErase_HighestPrioStartup2</srcid><srcstatus/><internalId>1022</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_AbortErase_LeadsToHPStartup2</srcid><srcstatus/><internalId>1025</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_StartUp_Active_ErasableHeader</srcid><srcstatus/><internalId>1141</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_SectionStatus_01</srcid><srcstatus/><internalId>1199</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00187</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>185</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>963</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.BlankCheck.Retention</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>3565</sourceline>
      <version>1</version>
      <description>
                If the consistency pattern is used, at a fresh start, Fee shall always write a dummy block info first
                to asure the data retention on RV40F technology.
            </description>
      <comment>
                The last block info may look blank but some memory cells are above the erased level.
                By writing a different data to this pages RV40F technology cannot guarantee the data retention.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Jobs.c_54</srcid><srcstatus/><internalId>691</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Jobs.c_135</srcid><srcstatus/><internalId>698</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Jobs.c_224</srcid><srcstatus/><internalId>704</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_SectionsSwitch.c_52</srcid><srcstatus/><internalId>745</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_SectionsSwitch.c_124</srcid><srcstatus/><internalId>746</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_SectionsSwitch.c_198</srcid><srcstatus/><internalId>750</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Init_BlockBlankCheck_RefuseFail</srcid><srcstatus/><internalId>1056</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Switch_RetentionBlockInfo</srcid><srcstatus/><internalId>1077</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_BlockCacheFlowBlankCheck</srcid><srcstatus/><internalId>1137</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00187</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>185</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>964</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.BlankCheck.FreshBlock</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>3588</sourceline>
      <version>1</version>
      <description>
                If the consistency pattern is used, Fee shall write the section counter in the block info 
                and also check it at Startup1 in order to assure the block's freshness on RV40F technology.
            </description>
      <comment>
              Also usefull for the case flash ECC errors can be ignored by the project during startup.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_1180</srcid><srcstatus/><internalId>663</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_StartUp_BlockNotFresh</srcid><srcstatus/><internalId>1131</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00187</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>185</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>965</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.ImmediateSpaceReserved.Runtime</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>3610</sourceline>
      <version>1</version>
      <description>
                Fee shall reserve space for immediate blocks in the penultimate section(the section before high prio switch section).
            </description>
      <comment>

            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_962</srcid><srcstatus/><internalId>642</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_1025</srcid><srcstatus/><internalId>655</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_1386</srcid><srcstatus/><internalId>668</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Fee_Internal.c_1717</srcid><srcstatus/><internalId>683</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Imm_SectionEraseRS</srcid><srcstatus/><internalId>1087</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Imm_SwitchFromRS</srcid><srcstatus/><internalId>1094</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Imm_ChangeSection</srcid><srcstatus/><internalId>1096</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Imm_SectionEraseS2</srcid><srcstatus/><internalId>1097</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Imm_HPSpaceReserved</srcid><srcstatus/><internalId>1252</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Imm_ReserveSpace</srcid><srcstatus/><internalId>1254</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Imm_TriggerHP</srcid><srcstatus/><internalId>1255</internalId></linkedfrom><linkedfrom><srcid>TS_Fee_Imm_ReservedSpaceReset</srcid><srcstatus/><internalId>1257</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeImmediateSpaceReserved.Config</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>305</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>966</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.ImmediateSpaceReserved.Init</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>3631</sourceline>
      <version>1</version>
      <description>
                Fee shall find the reserved space at startup if there is any.
            </description>
      <comment>

            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Initialization.c_1850</srcid><srcstatus/><internalId>527</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Imm_StartupFindsReserved</srcid><srcstatus/><internalId>1253</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeImmediateSpaceReserved.Config</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>305</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>967</internalId></specobject>
    <specobject>
      <id>Fee.Dsn.ImmediateSpaceReserved.Fail</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/requirements_view.xml</sourcefile>
      <sourceline>3652</sourceline>
      <version>1</version>
      <description>
              If writing of a block info fails in the reserved space during high internal priority interruption
              Fee shall consider the entire reserved space compromised.
            </description>
      <comment>
              It's a design choice for a situation that should never occur, in order to not introduce another u16 
              variable for counting the margin block infos, and other complications.
            </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Fee_Jobs.c_197</srcid><srcstatus/><internalId>700</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_Imm_Failure</srcid><srcstatus/><internalId>1256</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeImmediateSpaceReserved.Config</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>305</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>968</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd">
    <specobject>
      <id>Fee.swdd.ROMConsumption_RefCfg1</id>
      <status>approved</status>
      <source>Elektrobit Automotive GmbH</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/resource_view.xml</sourcefile>
      <sourceline>136</sourceline>
      <version>1</version>
      <description>
                        The ROM consumption for reference configuration must not exceed 9500 bytes.
                      </description>
      <rationale>
                        The defined ROM consumption is the result of all analysed configuration
                        parameters of reference configuration 1.
                      </rationale>
      <needscoverage>
        <needscov><needsobj>man</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_ResourceConsumption</srcid><srcstatus/><internalId>315</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Fee_ComTest_ResourceConsumption</srcid><srcstatus/><internalId>982</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>969</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd">
    <specobject>
      <id>Fee.swdd.RAMConsumption_RefCfg1</id>
      <status>approved</status>
      <source>Elektrobit Automotive GmbH</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/doc/project/design/basic_software/resource_view.xml</sourcefile>
      <sourceline>179</sourceline>
      <version>1</version>
      <description>
                        The RAM consumption for reference configuration must not exceed 500 bytes.
                      </description>
      <rationale>
                        The defined RAM consumption is the result of all analysed configuration
                        parameters of reference configuration 1.
                      </rationale>
      <needscoverage>
        <needscov><needsobj>man</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Fee_ResourceConsumption</srcid><srcstatus/><internalId>315</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Fee_ComTest_ResourceConsumption</srcid><srcstatus/><internalId>982</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>970</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_Fee_DBGINST_001</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/build/reqm/common_req/Fee_DbgInst_Trace_APIs.c</sourcefile>
      <sourceline>40</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
   Test Dbg
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
  VP: Successful compilation test.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.EB.DBGINST001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>316</internalId></provcov>
        <provcov>
          <linksto>Fee.EB.DBGINST002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>317</internalId></provcov>
        <provcov>
          <linksto>Fee.EB.DBGINST003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>318</internalId></provcov>
        <provcov>
          <linksto>Fee.EB.DBGINST004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>319</internalId></provcov>
        <provcov>
          <linksto>Fee.EB.DBGINST005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>320</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>971</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_Fee_VerifyCodeStub</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/build/reqm/common_req/Fee_VerifyStub_testspec.h</sourcefile>
      <sourceline>7</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that the code stub of the module is consistent with the
    implementation.
  
Test Object: 
    Relocatable post-build configuration macros generation.
  
Test Precondition: 
    Permutation [VerifyStub == true]:
      - Unit test contains its own code stub
      - Module is excluded from generation and compilation
    Permutation [VerifyStub == false]:
      - unit test excludes its own code stub
  
Test Execution: 
    01: Invoke all module APIs
    02: VP(Fee.EB.Interface.Consistency):
        Unit test compiles (implicitly tested)
  
Test Input: 
  
Test Output: 
    Test is correctly generated and compiled.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.EB.Interface.Consistency</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>321</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>972</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_FEE_20000</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Compile/IN/Fee_ComTest_01/source/application/test_config.h</sourcefile>
      <sourceline>10</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Test to compile the module for the following configuration
      - DET STD_OFF
      - Fee Polling mode STD_ON.
      - Fee Set mode API available.
      - Fee VersionInfo API not available.
      - Virtual Page size of 1.
      - Nvm notification functions not configured.
      - Flash Cancel API available.
      - Flash Setmode API available.
      - Flash GetJobResult available.
      - Flash Erase value is 0xffffffff.
      - Flash configured with only 2 sectors having unequal size.
      and Verify the value of generated symbol for FeeBlockNumber when the number of
      Fee Block is 28 with equal size and no blocks configured immediate.
     -Check that symbolic names are defined with value for configuration parameter FeeBlockNumber when FEE_DONT_PROVIDE_LEGACY_SYMBOLIC_NAMES is OFF.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: None.
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>24</internalId></provcov>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00065</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>35</internalId></provcov>
        <provcov>
          <linksto>Fee.ECUC_Fee_00150</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>87</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>973</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_FEE_20001</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Compile/IN/Fee_ComTest_02/source/application/test_config.h</sourcefile>
      <sourceline>10</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Test to compile the module for the following configuration
      - DET STD_ON
      - Fee Polling mode STD_OFF.
      - - Fee Set mode API not available.
      - Fee VersionInfo API available.
      - Virtual Page size of 2.
      - Nvm notification functions configured.
      - Flash Cancel API not available.
      - Flash Setmode API not available.
      - Flash GetJobResult available.
      - Flash Erase value is zero.
      - Flash configured with only 2 sectors having equal size.
      and Verify the value of generated symbol for FeeBlockNumber when the number of
      Fee Block is ten configured in the order 1,2,3,4,5,6,7,8,9,10.
      - Set FeeDefProgEnabled to true.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: None.
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>24</internalId></provcov>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00065</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>35</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>974</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_FEE_20002</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Compile/IN/Fee_ComTest_03/source/application/test_config.h</sourcefile>
      <sourceline>10</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Test to compile the module for the following configuration
      - DET STD_ON
      - Fee Polling mode STD_ON.
      - Fee VersionInfo API available.
      - Fee Set mode API available.
      - Virtual Page size of 4.
      - Nvm notification functions configured.
      - Flash Cancel API available.
      - Flash Setmode API available.
      - Flash GetJobResult available.
      - Flash Erase value is 0xFF.
      - Flash configured with multiple sectors such that Fee sections have equal size.
      and Verify the value of generated symbol for FeeBlockNumber when the number of
      Fee Block is ten configured in the order 1,6,2,7,3,8,4,9,5,10.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: None.
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>24</internalId></provcov>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00065</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>35</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>975</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_FEE_20003</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Compile/IN/Fee_ComTest_04/source/application/test_config.h</sourcefile>
      <sourceline>10</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Test to compile the module for the following configuration
      - DET STD_OFF
      - Fee Polling mode STD_OFF.
      - Fee VersionInfo API available.
      - Fee Set mode API available.
      - Virtual Page size of 8.
      - Nvm notification functions not configured.
      - Flash Cancel API not available.
      - Flash Setmode API not available.
      - Flash GetJobResult not available.
      - Flash Erase value is 0xFF.
      - Flash configured with multiple sectors such that Fee sections have unequal size.
      and Verify the value of generated symbol for FeeBlockNumber when the number of
      Fee Block is ten configured in the order 10,9,8,7,6,5,4,3,2,1.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: None.
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>24</internalId></provcov>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00065</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>35</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>976</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_FEE_20004</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Compile/IN/Fee_ComTest_05/source/application/test_config.h</sourcefile>
      <sourceline>10</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Test to compile the module for the following configuration
      - DET STD_OFF
      - Fee Polling mode STD_OFF.
      - Fee VersionInfo API available.
      - Fee Set mode API available.
      - Virtual Page size of 8.
      - Nvm notification functions not configured.
      - Flash Cancel API not available.
      - Flash Setmode API not available.
      - Flash GetJobResult not available.
      - Flash Erase value is 0xFF.
      - Flash configured with multiple sectors such that Fee sections have unequal size.
      and Verify the value of generated symbol for FeeBlockNumber when the number of
      Fee Block is ten configured in the order 10,9,8,7,6,5,4,3,2,1.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: None.
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>24</internalId></provcov>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00065</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>35</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>977</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_FEE_20005</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Compile/IN/Fee_ComTest_06/source/application/test_config.h</sourcefile>
      <sourceline>10</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Test to compile the module for the following configuration
      - DET STD_OFF
      - Fee Polling mode STD_OFF.
      - Fee VersionInfo API available.
      - Fee Set mode API available.
      - Virtual Page size of 8.
      - Nvm notification functions not configured.
      - Flash Cancel API not available.
      - Flash Setmode API not available.
      - Flash GetJobResult not available.
      - Flash Erase value is 0xFF.
      - Flash configured with multiple sectors such that Fee sections have unequal size.
      and Verify the value of generated symbol for FeeBlockNumber when the number of
      Fee Block is ten configured in the order 10,9,8,7,6,5,4,3,2,1.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: None.
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>24</internalId></provcov>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00065</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>35</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>978</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_FEE_20006</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Compile/IN/Fee_ComTest_07/source/application/test_config.h</sourcefile>
      <sourceline>10</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Test to compile the module for the following configuration
      - DET STD_OFF
      - Fee Polling mode STD_OFF.
      - Fee VersionInfo API available.
      - Fee Set mode API available.
      - Virtual Page size of 8.
      - Nvm notification functions not configured.
      - Flash Cancel API not available.
      - Flash Setmode API not available.
      - Flash GetJobResult not available.
      - Flash Erase value is 0xFF.
      - Flash configured with multiple sectors such that Fee sections have unequal size.
      and Verify the value of generated symbol for FeeBlockNumber when the number of
      Fee Block is ten configured in the order 10,9,8,7,6,5,4,3,2,1.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: None.
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>24</internalId></provcov>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00065</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>35</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>979</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_FEE_20007</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Compile/IN/Fee_ComTest_08/source/application/test_config.h</sourcefile>
      <sourceline>10</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Test to compile the module for the following configuration
      - DET STD_OFF
      - Fee Polling mode STD_OFF.
      - Fee VersionInfo API available.
      - Fee Set mode API available.
      - Virtual Page size of 8.
      - Nvm notification functions not configured.
      - Flash Cancel API not available.
      - Flash Setmode API not available.
      - Flash GetJobResult not available.
      - Flash Erase value is 0xFF.
      - Flash configured with multiple sectors such that Fee sections have unequal size.
      and Verify the value of generated symbol for FeeBlockNumber when the number of
      Fee Block is ten configured in the order 10,9,8,7,6,5,4,3,2,1.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: None.
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>24</internalId></provcov>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00065</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>35</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>980</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_FEE_ConfigId</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Compile/IN/Fee_ComTest_09/source/application/test_config.h.m4</sourcefile>
      <sourceline>10</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Test to compile the module for the following configuration
Permutation details:
--------------- -------------------------------------------------|
| Permutation | Number of sections    | AutoSectionsGeneration   | Expected values for ConfigId |
|-------------- ----------------------|--------------------------|------------------------------|
| p0          | 2                     | true                     | 130                          |
| p1          | 2                     | false                    | 130                          |
| p2          | 4                     | true                     | 212                          |
| p3          | 4                     | true                     | 212                          |
-------------------------------------------------------------------------------------------------
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: None.
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.03</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>824</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>981</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>Fee_ComTest_ResourceConsumption</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Compile/IN/Fee_ComTest_ResourceConsumption/source/application/test_config.h</sourcefile>
      <sourceline>10</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
      This test shall be used as a reference test to estimate the RAM and ROM consumption.
    
Test Object: 
      RAM/ROM consumption of reference configuration
    
Test Precondition: None.
Test Execution: 
        This test is intended as compile test only.
    
Test Input: 
    
Test Output: 
        A compiled module.
    &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.swdd.ROMConsumption_RefCfg1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>969</internalId></provcov>
        <provcov>
          <linksto>Fee.swdd.RAMConsumption_RefCfg1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>970</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>982</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_FEE_SCHM</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Compile/IN/Fee_ComTest_SchM/source/application/test_config.h</sourcefile>
      <sourceline>7</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
     This test checks that the Fee module's generator generates a
     syntactically and semantically valid basic software module
     description (BSWMD) when the generator mode "generate_swcd" is
     invoked.
  
Test Object: None.
Test Precondition: None.
Test Execution: 
    Ts5 build environment steps:
      The module configuration generator produces the BSWMD. This implicitly
      verifies that the BSWMD is syntactically and semantically correct.
      The code generator produces errors if the BSWMD does not contain
      the correct information.
  
Test Input: 
    Usage of a common ASR configuration having all adjacent ASR modules
    configured.
  
Test Output: 
    Compile succeeds.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.EB.BSWMDGeneration_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>216</internalId></provcov>
        <provcov>
          <linksto>Fee.EB.BSWMDGeneration_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>217</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>983</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_FEE_VendorSpecificDriver</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Compile/IN/Fee_ComTest_VendorSpecificDriver/source/application/test_config.h</sourcefile>
      <sourceline>10</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Test to test that the APIs of a third party driver vendor is mapped correctly to the default
      APIs used by the module.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: None.
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.VendorInfixDriver.Support</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>299</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>984</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_FEE_NonLegSymbolicNames</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Compile/IN/Fee_Compile_NonLegSymbolic_Names/source/application/NonLegSymbolic_names.c</sourcefile>
      <sourceline>30</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
   Test whether the symbolic name macros generated for FeeBlockNumber when FEE_DONT_PROVIDE_LEGACY_SYMBOLIC_NAMES is ON."
&lt;/para&gt;

Test Object: 
  Symbolic Name generation.

Test Precondition: 

Test Execution: 
    01: Check that macros are generated with the names and the values listed in output.

Test Input: 
None.

Test Output: 
    macro generation:
    FeeConf_FeeBlockConfiguration_FeeBlockConfiguration_0   1U
    FeeConf_FeeBlockConfiguration_FeeBlockConfiguration_1   2U
    FeeConf_FeeBlockConfiguration_FeeBlockConfiguration_2   3U
    FeeConf_FeeBlockConfiguration_FeeBlockConfiguration_3   4U
    FeeConf_FeeBlockConfiguration_FeeBlockConfiguration_4   5U
    FeeConf_FeeBlockConfiguration_FeeBlockConfiguration_5   6U
    FeeConf_FeeBlockConfiguration_FeeBlockConfiguration_6   7U
    FeeConf_FeeBlockConfiguration_FeeBlockConfiguration_7   8U
    FeeConf_FeeBlockConfiguration_FeeBlockConfiguration_8   9U
    FeeConf_FeeBlockConfiguration_FeeBlockConfiguration_9   10U
    FeeConf_FeeBlockConfiguration_FeeBlockConfiguration_10  11U
    FeeConf_FeeBlockConfiguration_FeeBlockConfiguration_11  12U
    FeeConf_FeeBlockConfiguration_FeeBlockConfiguration_12  13U
    FeeConf_FeeBlockConfiguration_FeeBlockConfiguration_13  14U
    FeeConf_FeeBlockConfiguration_FeeBlockConfiguration_14  15U
    FeeConf_FeeBlockConfiguration_FeeBlockConfiguration_15  16U
    FeeConf_FeeBlockConfiguration_FeeBlockConfiguration_16  17U
    FeeConf_FeeBlockConfiguration_FeeBlockConfiguration_17  18U
    FeeConf_FeeBlockConfiguration_FeeBlockConfiguration_18  19U
    FeeConf_FeeBlockConfiguration_FeeBlockConfiguration_19  20U
    FeeConf_FeeBlockConfiguration_FeeBlockConfiguration_20  21U
    FeeConf_FeeBlockConfiguration_FeeBlockConfiguration_21  22U
    FeeConf_FeeBlockConfiguration_FeeBlockConfiguration_22  23U
    FeeConf_FeeBlockConfiguration_FeeBlockConfiguration_23  24U
    FeeConf_FeeBlockConfiguration_FeeBlockConfiguration_24  25U
    FeeConf_FeeBlockConfiguration_FeeBlockConfiguration_25  26U
    FeeConf_FeeBlockConfiguration_FeeBlockConfiguration_26  27U
    FeeConf_FeeBlockConfiguration_FeeBlockConfiguration_27  28U
    
    FeeBlockConfiguration_0   must not be defined
    FeeBlockConfiguration_1   must not be defined
    FeeBlockConfiguration_2   must not be defined
    FeeBlockConfiguration_3   must not be defined
    FeeBlockConfiguration_4   must not be defined
    FeeBlockConfiguration_5   must not be defined
    FeeBlockConfiguration_6   must not be defined
    FeeBlockConfiguration_7   must not be defined
    FeeBlockConfiguration_8   must not be defined
    FeeBlockConfiguration_9   must not be defined
    FeeBlockConfiguration_10  must not be defined
    FeeBlockConfiguration_11  must not be defined
    FeeBlockConfiguration_12  must not be defined
    FeeBlockConfiguration_13  must not be defined
    FeeBlockConfiguration_14  must not be defined
    FeeBlockConfiguration_15  must not be defined
    FeeBlockConfiguration_16  must not be defined
    FeeBlockConfiguration_17  must not be defined
    FeeBlockConfiguration_18  must not be defined
    FeeBlockConfiguration_19  must not be defined
    FeeBlockConfiguration_20  must not be defined
    FeeBlockConfiguration_21  must not be defined
    FeeBlockConfiguration_22  must not be defined
    FeeBlockConfiguration_23  must not be defined
    FeeBlockConfiguration_24  must not be defined
    FeeBlockConfiguration_25  must not be defined
    FeeBlockConfiguration_26  must not be defined
    FeeBlockConfiguration_27  must not be defined
    
    Fee_FeeBlockConfiguration_0   must not be defined
    Fee_FeeBlockConfiguration_1   must not be defined
    Fee_FeeBlockConfiguration_2   must not be defined
    Fee_FeeBlockConfiguration_3   must not be defined
    Fee_FeeBlockConfiguration_4   must not be defined
    Fee_FeeBlockConfiguration_5   must not be defined
    Fee_FeeBlockConfiguration_6   must not be defined
    Fee_FeeBlockConfiguration_7   must not be defined
    Fee_FeeBlockConfiguration_8   must not be defined
    Fee_FeeBlockConfiguration_9   must not be defined
    Fee_FeeBlockConfiguration_10  must not be defined
    Fee_FeeBlockConfiguration_11  must not be defined
    Fee_FeeBlockConfiguration_12  must not be defined
    Fee_FeeBlockConfiguration_13  must not be defined
    Fee_FeeBlockConfiguration_14  must not be defined
    Fee_FeeBlockConfiguration_15  must not be defined
    Fee_FeeBlockConfiguration_16  must not be defined
    Fee_FeeBlockConfiguration_17  must not be defined
    Fee_FeeBlockConfiguration_18  must not be defined
    Fee_FeeBlockConfiguration_19  must not be defined
    Fee_FeeBlockConfiguration_20  must not be defined
    Fee_FeeBlockConfiguration_21  must not be defined
    Fee_FeeBlockConfiguration_22  must not be defined
    Fee_FeeBlockConfiguration_23  must not be defined
    Fee_FeeBlockConfiguration_24  must not be defined
    Fee_FeeBlockConfiguration_25  must not be defined
    Fee_FeeBlockConfiguration_26  must not be defined
    Fee_FeeBlockConfiguration_27  must not be defined

    
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.ECUC_Fee_00150</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>87</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>985</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>Fee_GenTest_01_Insuficient_AllBlocks</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Compile/IN/Fee_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>27</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that Tresos shall not generate an FEE with too small section to fit all blocks
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
  The following error must be issued:
 All the blocks can not be written in the smallest section. Lower the number of sections or lower the blocks size, or add more data flash!

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>913</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>986</internalId></specobject>
    <specobject>
      <id>Fee_GenTest_02_Insuficient_AllBlocksPlusOne</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Compile/IN/Fee_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>52</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that Tresos shall not generate an FEE with too small section to fit all blocks plus one write of the largest block
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
  The following error must be issued:
  All the blocks plus one can not be written in the smallest section. Lower the number of sections or lower the blocks size, or add more data flash!

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>913</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>987</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>Fee_GenTest_02_Sections_not_consistent</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Compile/IN/Fee_GenTest_02_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>27</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that Tresos shall not generate an FEE if sections configuration is not consistent.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
  The following error must be issued:
 Sections configuration is not consistent

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Sections.ManualConfiguration.Validate</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>314</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>988</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_FEE_MemAccApiCompliance</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Conformance/IN/Fee_ConTest_MemAcc_Compliance/source/application/Test.c</sourcefile>
      <sourceline>92</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This tests verifies that when MemAcc module usage is enabled then all corresponding API
  from MemAcc are called.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
No special preconditions.

Test Execution: 

Initialize FEE and MemAcc Stub.
  Call Fee main function for processing the initialization phase.
  VP(MemAcc_Erase) :Check that MemAcc Erase API is called.
  VP(MemAcc_BlankCheck) :Check that MemAcc BlankCheck API is called
Write data
  Trigger a Write data to flash.
  Wait to finish write job by checking Job Result is MEMIF_JOB_OK
  VP(MemAcc_Write) :Check that MemAcc Write API is called
Read data
  Read same block number data from flash
  Wait to finish read job by checking Job Result is MEMIF_JOB_OK
  Check the Fee status is MEMIF_IDLE after read is complete 
  VP(MemAcc_Read) :Check that MemAcc Read API is called
  VP(MemAcc_GetJobResult) :Check that MemAcc GetJobResult API is called
  VP(MemAcc_GetJobStatus) :Check that MemAcc GetJobStatus API is called
Cancel Read data
  Read same block number data from flash
  Call one main function for Read operation to start
  Cancel above read operation that started
  Call Fee main function for processing the job/ canceling of job
  VP(MemAcc_Cancel) :Check that MemAcc Cancel API is called

Test Input: 
None

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeMemAccUsage.ApiCompliance</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>309</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>989</internalId></specobject>
    <specobject>
      <id>TS_FEE_MemAccJobResultCompatibility</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Conformance/IN/Fee_ConTest_MemAcc_Compliance/source/application/Test.c</sourcefile>
      <sourceline>271</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This tests verifies that when MemAcc module usage is enabled then Fee is compatible with the new
  return type that MemAcc returns when GetJobResult/GetJobStatus are called.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
No special preconditions.

Test Execution: 

Note: Unless otherwise stated, whenever an Fee Job is requested, Fee_MainFunction and
MemAcc_MainFunction are to be called continuously till the job gets completed.

Initialize FEE and MemAcc Stub
Write data
  Trigger a Write data to flash 
  Wait to finish write job by checking Job Result is MEMIF_JOB_OK
Read data
  Initialize MemAcc Read Stub to refuse the Read job.
  Read data from flash
  VP(FailedJob) : Wait to finish read job by checking Job Result is MEMIF_JOB_FAILED
  Check the Fee status is MEMIF_IDLE after read is complete
Initialize MemAcc Read Stub to refuse the Read job and the status of MemAcc 
for the corresponding AreaId to be MEMACC_JOB_PENDING.
  Read same block number data from flash
  VP(Failed): Wait to finish read job by checking Job Result is MEMIF_JOB_FAILED.
  Check the Fee status is MEMIF_IDLE after read is complete
Initialize MemAcc Stub to return MEMACC_JOB_PENDING status.
  Read same block number data from flash.
  Execute one MainFunction while MemAcc is pending.
  Initialize MemAcc Stub to return a MEMACC_MEM_FAILED Job result.
  VP(FAILED): Wait to finish read job by checking Job Result is MEMIF_JOB_FAILED
  Check the Fee status is MEMIF_IDLE after read is complete 

Test Input: 
None

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeMemAccUsage.GetJobResultCompatibility</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>311</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeMemAccUsage.JobStatusCompatibility</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>310</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>990</internalId></specobject>
    <specobject>
      <id>TS_FEE_MemAccAsyncCancel</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Conformance/IN/Fee_ConTest_MemAcc_Compliance/source/application/Test.c</sourcefile>
      <sourceline>439</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This tests verifies that when MemAcc module usage is enabled the Fee is able to handle asyncronous Cancel operations of the lower layer.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
No special preconditions.

Test Execution: 

Note: Unless otherwise stated, whenever an Fee Job is requested, Fee_MainFunction and
MemAcc_MainFunction are to be called continuously till the job gets completed.

   Init test
   Initialize FEE and MemAcc Stub
   Call Fee main function for processing the initialization phase 
   --- Write data --- 
   Trigger a Write data to flash 
   Call one main function for Write operation to start
   Cancel above write operation that started 
   Call Fee main function for processing the canceling of job 
   VP(Fee.Dsn.Cancel.Behaviour.FeeMemAccUsage.Cancel) :Check that MemAcc Cancel API is called 
   Verify that the Job result of the last job is JOB_CANCELED 
   --- Write data --- 
   Trigger a Write data to flash 
   Call one main function for Write operation to start
   Cancel above Write operation that started 
   Set the lower layer job result to PENDING to simulate job asyncrounous execution while cancel is ongoing
   Call Fee main function for processing the canceling of job 
   (VP Fee.Dsn.Cancel.Behaviour.FeeMemAccUsage.CancelOngoing) Verify that the internal state of the Fee SM is FEE_CANCEL_ONGOING while the lower layer is still pending
   Set the lower layer job result to IDLE to simulate job asyncrounous execution cancel was finished
   Execute one main function for Fee to realize the Cancel is completed
   (VP Fee.Dsn.Cancel.Behaviour.FeeMemAccUsage.Cancel) Verify that the internal state of the Fee SM is FEE_IDLE after the asyncrounus cancel is completed
   Trigger a Write data.
   (VP Fee_FEE_080_4) Check that the pending job completes succsesfully after the asyncronous cancel is completed

Test Input: 
None

Test Output: 
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee_FEE_080_4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>207</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Cancel.Behaviour.FeeMemAccUsage.CancelOngoing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>893</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Cancel.Behaviour.FeeMemAccUsage.Cancel</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>894</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>991</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>Ts_Fee_Cancel_Behavior_JobPending_Normal</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_01/source/application/Tests.c</sourcefile>
      <sourceline>57</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: Test the call of Fee_Cancel when Fee has a job pending and in NORMAL mode.
Test Description: 
    This test verifies the Fee behavior when Fee_Cancel is called while Fee has an
    upper layer request PENDING but not yet started, when in NORMAL mode.
  
Test Object: Fee_Cancel()
Test Precondition: 
    - The flash must be erased
  
Test Execution: 
    01. set the test result to indicate success - failures are set throughout the test
    02. The flash must be erased
    03. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    04. Perform initialization, (Startup1 and Startup2)
    05. request the Standard Read
    06. cancel it
    07. Check that Fee is IDLE
    08. request the Standard Write
    09. cancel it
    10. Check that Fee is IDLE
    11. request the Immediate Write
    12. cancel it
    13. Check that Fee is IDLE
    14. request the Invalidate
    15. cancel it
    16. Check that Fee is IDLE
    17. request the Erase for an immediate block
    18. cancel it
    19. Check that Fee is IDLE
    20. Get the test case result
    21. return the test outcome
  
Test Input: None.
Test Output: 
    The cancelation of each request must be done successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Normal.Cancel.HasRequest.Pending</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>942</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Normal.Cancel.HasRequest.Ongoing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>943</internalId></provcov>
        <provcov>
          <linksto>Fee_FEE_080_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>204</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>992</internalId></specobject>
    <specobject>
      <id>Ts_Fee_Cancel_Behavior_JobPending_Startup1_NoRequest</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_01/source/application/Tests.c</sourcefile>
      <sourceline>207</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: Test the call of Fee_Cancel when Fee has a job pending while in Startup1.
Test Description: 
    This test verifies the Fee behavior when Fee_Cancel is called while Fee has an
    upper layer request PENDING, when in Startup1.
  
Test Object: Fee_Cancel()
Test Precondition: 
    - The flash must be erased
  
Test Execution: 
    01. set the test result to indicate success - failures are set throughout the test
    02. The flash must be erased
    03. initialize the Fee module
    04. allow the Startup1 to run for a while
    05. Check that Fee is MEMIF_BUSY_INTERNAL
    06. request the Standard Read
    07. cancel it
    08. Check that Fee is MEMIF_BUSY_INTERNAL
    09. request the Standard Write
    10. cancel it
    11. Check that Fee is MEMIF_BUSY_INTERNAL
    12. request the Immediate Write
    13. cancel it
    14. Check that Fee is MEMIF_BUSY_INTERNAL
    15. request the Invalidate
    16. cancel it
    17. Check that Fee is MEMIF_BUSY_INTERNAL
    18. request the Erase for an immediate block
    19. cancel it
    20. Check that Fee is MEMIF_BUSY_INTERNAL
    21. Get the test case result
    22. return the test outcome
  
Test Input: None.
Test Output: 
    The cancelation of each request must be done successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Startup1.Cancel.NoRequest</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>937</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Startup1.Cancel.HasRequest</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>938</internalId></provcov>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00120</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>44</internalId></provcov>
        <provcov>
          <linksto>Fee_FEE_080_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>205</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>993</internalId></specobject>
    <specobject>
      <id>Ts_Fee_Cancel_Behavior_JobPending_Startup2_NoRequest</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_01/source/application/Tests.c</sourcefile>
      <sourceline>366</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: Test the call of Fee_Cancel when Fee has a job pending while in Startup2.
Test Description: 
    This test verifies the Fee behavior when Fee_Cancel is called while Fee has an
    upper layer request PENDING, when in Startup2.
  
Test Object: Fee_Cancel()
Test Precondition: 
    - The flash must be erased
  
Test Execution: 
    01. set the test result to indicate success - failures are set throughout the test
    02. The flash must be erased
    03. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    04. Perform initialization, (Startup1 and Startup2)
    05. Perform reset
    06. Initialize flash driver and test stubs for Nvm and Det
    07. Initialize Fee module
    08. Perform initialization, (Startup1, Startup2 and Switch). Switch starts immediately after initialization.
        There is no need for a trigger.
    09. request the Standard Read
    10. Wait untill startup2 starts
    11. Check that Fee is MEMIF_BUSY_INTERNAL
    12. request the Standard Read
    13. cancel it
    14. Check that Fee is IDLE
    15. request the Standard Write
    16. cancel it
    17. Check that Fee is IDLE
    18. request the Immediate Write
    19. cancel it
    20. Check that Fee is IDLE
    21. request the Invalidate
    22. cancel it
    23. Check that Fee is IDLE
    24. request the Erase for an immediate block
    25. cancel it
    26. Check that Fee is IDLE
    27. Get the test case result
    28. return the test outcome
  
Test Input: None.
Test Output: 
    The cancelation of each request must be done successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Startup2.Cancel.HasRequest.Pending</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>940</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Startup2.Cancel.NoRequest</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>939</internalId></provcov>
        <provcov>
          <linksto>Fee_FEE_080_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>204</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>994</internalId></specobject>
    <specobject>
      <id>Ts_Fee_Cancel_Behavior_JobOngoing_Startup2_Imp01</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_01/source/application/Tests.c</sourcefile>
      <sourceline>547</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: Test the call of Fee_Cancel when Fee has a job ongoing and in Startup2.
Test Description: 
    This test verifies the Fee behavior when Fee_Cancel is called while Fee has an
    upper layer request PENDING and started, when in Startup2.
  
Test Object: Fee_Cancel()
Test Precondition: 
    - The flash must be erased
  
Test Execution: 
    01. set the test result to indicate success - failures are set throughout the test
    02. The flash must be erased
    03. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    04. Perform initialization, (Startup1 and Startup2)
    05. Perform reset
    06. Initialize flash driver and test stubs for Nvm and Det
    07. Initialize Fee module
    08. Perform initialization, (Startup1, Startup2 and Switch). Switch starts immediately after initialization.
        There is no need for a trigger.
    09. Wait untill startup2 starts
    10. request the Standard Read
    11. cancel it
    12. Check that Fee is IDLE
    13. request the Standard Write
    14. cancel it
    15. Check that Fee is IDLE
    16. request the Immediate Write
    17. cancel it
    18. Check that Fee is IDLE
    19. request the Invalidate
    20. cancel it
    21. Check that Fee is IDLE
    22. request the Erase for an immediate block
    23. cancel it
    24. Check that Fee is IDLE
    25. Get the test case result
    26. return the test outcome
  
Test Input: None.
Test Output: 
    The cancelation of each request must be done successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Startup2.Cancel.HasRequest.Ongoing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>941</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>995</internalId></specobject>
    <specobject>
      <id>Ts_Fee_Cancel_Behavior_JobOngoing_SectionSwitch_Imp01</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_01/source/application/Tests.c</sourcefile>
      <sourceline>713</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: Test the call of Fee_Cancel when Fee has a job ongoing and in Section Switch.
Test Description: 
    This test verifies the Fee behavior when Fee_Cancel is called while Fee has an
    upper layer request PENDING and started, when in Section Switch.
  
Test Object: Fee_Cancel()
Test Precondition: 
    - The flash must be erased
  
Test Execution: 
    01. set the test result to indicate success - failures are set throughout the test
    02. The flash must be erased
    03. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    04. Perform initialization, (Startup1 and Startup2)
    05. Perform reset
    06. Initialize flash driver and test stubs for Nvm and Det
    07. Initialize Fee module
    08. Perform initialization, (Startup1, Startup2 and Switch). Switch starts immediately after initialization.
        There is no need for a trigger.
    09. Wait untill startup2 starts
    10. Now all the sections shall be valid and empty. Get the empty space value in a section.
    11. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    12. request the Standard Read
    13. cancel it
    14. Check that Fee is IDLE
    15. request the Standard Write
    16. cancel it
    17. Check that Fee is IDLE
    18. request the Immediate Write
    19. cancel it
    20. Check that Fee is IDLE
    21. request the Invalidate
    22. cancel it
    23. Check that Fee is IDLE
    24. request the Erase for an immediate block
    25. cancel it
    26. Check that Fee is IDLE
    27. Get the test case result
    28. return the test outcome
  
Test Input: None.
Test Output: 
    The cancelation of each request must be done successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.SectonSwitch.Cancel.HasRequest.Ongoing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>945</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>996</internalId></specobject>
    <specobject>
      <id>Ts_Fee_Cancel_Behavior_JobPending_SectionSwitch_Imp01</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_01/source/application/Tests.c</sourcefile>
      <sourceline>923</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: Test the call of Fee_Cancel when Fee has a job pending while Section Switch.
Test Description: 
    This test verifies the Fee behavior when Fee_Cancel is called while Fee has an
    upper layer request PENDING but not started, when in Section Switch.
  
Test Object: Fee_Cancel()
Test Precondition: 
    - Fee initialization must be complete, including Startup2
    - Fee must be in a Section Switch
  
Test Execution: 
    01. set the test result to indicate success - failures are set throughout the test
    02. The flash must be erased
    03. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    04. Perform initialization, (Startup1 and Startup2)
    05. Perform reset
    06. Initialize flash driver and test stubs for Nvm and Det
    07. Initialize Fee module
    08. Perform initialization, (Startup1, Startup2 and Switch). Switch starts immediately after initialization.
        There is no need for a trigger.
    09. Wait untill startup2 starts
    10. Now all the sections shall be valid and empty. Get the empty space value in a section.
    11. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    12. request the Standard Read
    13. cancel it
    14. Check that Fee is IDLE
    15. request the Standard Write
    16. cancel it
    17. Check that Fee is IDLE
    18. request the Immediate Write
    19. cancel it
    20. Check that Fee is IDLE
    21. request the Invalidate
    22. cancel it
    23. Check that Fee is IDLE
    24. request the Erase for an immediate block
    25. cancel it
    26. Check that Fee is IDLE
    27. Get the test case result
    28. return the test outcome
  
Test Input: None.
Test Output: 
    The cancelation of each request must be done successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.SectonSwitch.Cancel.HasRequest.Pending</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>944</internalId></provcov>
        <provcov>
          <linksto>Fee_FEE_080_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>204</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>997</internalId></specobject>
    <specobject>
      <id>Ts_Fee_Cancel_Behavior_WrittenMarkerOngoing_Imp01</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_01/source/application/Tests.c</sourcefile>
      <sourceline>1139</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: Test the call of Fee_Cancel when Fee is writing the WRITTEN marker.
Test Description: 
    This test verifies the Fee behavior when Fee_Cancel is called while Fee is writing
    the WRITTEN marker for a block.
  
Test Object: Fee_Cancel()
Test Precondition: 
    - The flash must be erased
  
Test Execution: 
    01. set the test result to indicate success - failures are set throughout the test
    02. The flash must be erased
    03. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    04. Perform initialization, (Startup1 and Startup2)
    05. request the Standard Write
    06. cancel it
    07. Check that Fee is IDLE
    08. check that the write for the WRITTEN marker is canceled at Fls level
    09. Get the test case result
    10. return the test outcome
  
Test Input: None.
Test Output: 
    - The cancelation of each request must be done successfully
    - The WRITTEN marker of each request must be stored successfully
    - For each cancellation, the JobError is passed to NvM after writing the WRITTEN marker
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Cancel.Behaviour.WriteJob.WriteWrittenMarker</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>890</internalId></provcov>
        <provcov>
          <linksto>Fee_FEE_080_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>206</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>998</internalId></specobject>
    <specobject>
      <id>Ts_Fee_Cancel_Behavior_WritingSectionHeader_Imp01</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_01/source/application/Tests.c</sourcefile>
      <sourceline>1240</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: Test the call of Fee_Cancel when Fee is writing each section header.
Test Description: 
    This test verifies the Fee behavior when Fee_Cancel is called while Fee is writing
    each of the two section headers.
  
Test Object: Fee_Cancel()
Test Precondition: 
    - The flash must be erased
  
Test Execution: 
    01. set the test result to indicate success - failures are set throughout the test
    02. The flash must be erased
    03. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    04. cancel it
    05. Check that Fee is IDLE
    06. check that the write for the section header is ongoing at Fls level
    07. allow the Fls to complete the write of the WRITTEN marker
    08. Get the test case result
    09. return the test outcome
  
Test Input: None.
Test Output: 
    - The cancellations must not disrupt the writing of the two section headers
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Cancel.Behaviour.InternalOperations</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>891</internalId></provcov>
        <provcov>
          <linksto>Fee_FEE_080_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>206</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>999</internalId></specobject>
    <specobject>
      <id>Ts_Fee_Jobs_Idle</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_01/source/application/Tests.c</sourcefile>
      <sourceline>1333</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: Test the call of Fee_Cancel when Fee is writing each section header.
Test Description: 
    This test verifies that read, write, invalidate, erase immediate jobs are performed correctly during Idle.
  
Test Object: Fee_Cancel()
Test Precondition: 
    - The flash must be erased
  
Test Execution: 
    01. set the test result to indicate success - failures are set throughout the test
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform initialization
    04. Check that a read job is processed successfully in idle
    05. Check that a write job is processed successfully in idle (immediate block)
    06. Check that a write job is processed successfully in idle
    07. Check that a read job is processed successfully in idle (immediate block)
    08. Check that an erase immediate job is processed successfully in idle
    09. Check that a read job returns MEMIF_BLOCK_INCONSISTENT if the block was previously erased
    10. Check that an invalidate job is processed successfully in idle
    11. Check that a read job returns MEMIF_BLOCK_INVALID if the block was previously invalidated
    12. Get the test case result
    13. return the test outcome
  
Test Input: None.
Test Output: 
    - The cancellations must not disrupt the writing of the two section headers
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Read.Behaviour.IDLE</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>871</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Invalidate.Behaviour.IDLE.IsSpace</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>875</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.EraseImmediate.Behaviour.IDLE.IsSpace</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>880</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Write.Behaviour.IDLE.IsSpace</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>865</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Read.Behaviour.BlockInvalid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>873</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Read.Behaviour.BlockInconsistent</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>874</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Idle</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>862</internalId></provcov>
        <provcov>
          <linksto>Fee.WriteMultipleOfVP</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>223</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1000</internalId></specobject>
    <specobject>
      <id>TS_FEE_CancelSectionErase_01</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_01/source/application/Tests.c</sourcefile>
      <sourceline>1513</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Test FeeCancelSectionErase() cancels the ongoing section erase, and that the section erase is restarted later.  
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  None.

Test Execution: 
01. Initialize the stubs, simulate hardware reset, erase the entire flash and initialize Fee
02. Fill the source buffer
03. Wait for delay timer to expire
04. Wait for Fee to finish startup
05. Check that Startup2 is not pending
06. Fill Section 0  completely
07. Trigger a write of the last block in order to start a section switch
08. Wait for Fee to finish processing the write job
09. Wait for Fee to reach ERASE_SECTION state
10. Start the erase (one step)
11. VP (Fee.Dsn.CancelSectionErase):
     - Request a section erase cancelation and return value is E_OK;
     - Check that the Erase was cancelled;
     - Check that Fls is Idle now and it can accept jobs.
12. Perform a main function in order to update Fee state and check that Fee is Idle
13. VP (Fee.FeeCancelSectionErase_Restart):
     - Check that the next state will be FEE_SS_ERASE_SECTION,
     - meaning that Fee will retry to erase the section.
14. Wait for Fee to reach idle state
15. Check the value of the flash erase counter after Section 0 is erased
16. Check that the active section is Section 1
17. Check that Section 0 is EMPTY and Section 1 is ACTIVE

Test Input: 
  None.

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.CancelSectionErase</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>870</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1001</internalId></specobject>
    <specobject>
      <id>TS_FEE_CancelSectionErase_02</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_01/source/application/Tests.c</sourcefile>
      <sourceline>1699</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Test that after section switch cancellation the jobs can be processed by Fee before retrying the erase.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  None.

Test Execution: 
  01. Initialize the stubs, simulate hardware reset, erase the entire flash and initialize Fee
  02. Fill the source buffer
  03. Wait for delay timer to expire
  04. Check that Startup2 is pending
  05. Wait for Fee to finish startup2
  06. Check that Startup2 is not pending
  07. Fill Section 0 completely
  08. Wait for Fee to finish processing the write job
  09. Wait for Fee to mark Section 0 as COPIED
  10. Check the value of the flash erase counter before Section 0 is erased
  11. Wait for Fee to reach the section erase state
  12. Start the erase (one step)
  13. VP (Fee.Dsn.CancelSectionErase):
      - Request a section erase cancelation and return value is E_OK;
      - Check that the Erase was cancelled;
      - Check that Fls is Idle now and it can accept jobs.
  
  14. Perform a main function in order to update Fee state and check that Fee is Idle
  15. Wait for Fee to finish processing the write job
  16. VP (Fee.FeeCancelSectionErase_Restart):
      Check that the next state will be FEE_SS_ERASE_SECTION,
      meaning that Fee will retry to erase the section.
  
  17. Wait for Fee to reach idle state
  18. Check the value of the flash erase counter after Section 0 is erased

Test Input: 
  None.

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.CancelSectionErase</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>870</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeCancelSectionErase_Restart</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>277</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1002</internalId></specobject>
    <specobject>
      <id>TS_FEE_CancelSectionErase_03</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_01/source/application/Tests.c</sourcefile>
      <sourceline>1901</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Check FeeCancelSectionErase() returns E_NOT_OK when erase is not ongoing,
   then performs correctly when erase ongoing
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  None.

Test Execution: 
01. Initialize the stubs, simulate hardware reset, erase the entire flash and initialize Fee
02. Fill the source buffer
03. Wait for delay timer to expire
04. Check that IDLE state is reached
05. Check that Startup2 is not pending
06. VP (Fee.Dsn.CancelSectionErase):
     - Request a section erase cancelation and return value is E_NOT_OK;
     -  operation not ongoing
Perform one call the SectionErase funtion:
07. Fill Section 0  completely
08. Wait for Fee to finish processing the write job
09. Wait for Fee to mark Section 0 as ERASABLE
10. Check the value of the flash erase counter before Section 0 is erased
11. Wait for Fee to reach the section erase state
12. Start the erase (one step)
13. Perform a main function in order to update Fee state and check that Fee is Idle
14. Wait for Fee to finish processing the write job
15. VP (Fee.FeeCancelSectionErase_Restart):
   *     Check that the next state will be FEE_SS_ERASE_SECTION,
   *     meaning that Fee will retry to erase the section.
16. Wait for Fee to reach idle state
17. VP  Check the value of the flash erase counter after Section 0 is erased
Counter increments each time erase section starts

Test Input: 
  None.

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.CancelSectionErase</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>870</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1003</internalId></specobject>
    <specobject>
      <id>TS_FEE_CancelSectionErase_04</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_01/source/application/Tests.c</sourcefile>
      <sourceline>2097</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Test that Fee_CancelSectionErase() does not cancel the erase if called on Fee main function interruption.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  None.

Test Execution: 
  01. Initialize the stubs, simulate hardware reset, erase the entire flash and init
  02. Fill the source buffer  ialize Fee  
  03. Wait for delay timer to expire  
  04. Check that IDLE state is reached  
  05. Check that Startup2 is not pending  
  06. Fill Section 0  completely  
  07. Trigger a write of the last block in order to start a section switch  
  08. Wait for Fee to finish processing the write job  
  09. Wait for Fee to mark Section 0 as ERASABLE  
  10. Check the value of the flash erase counter before Section 0 is erased  
  11. Wait for Fee to reach the section erase state  
  12. Start the erase (one step)  
  13. Simulate the Fee main function entrance  
  14. VP (Fee.Dsn.CancelSectionErase):
   *     - Request a section erase cancelation and return value is E_NOT_OK;
    
  15. Simulate the Fee main function exit  
  16. Perform a main function in order to update Fee state and check that Fee is Idle  
  17. Wait for Fee to finish processing the write job  
  18. VP (Fee.FeeCancelSectionErase_Restart):
   *     Check that the next state will be FEE_ERASE_SECTION,
   *     meaning that Fee will retry to erase the section.
    
  19. Wait for Fee to reach idle state  
  20. VP  Check the value of the flash erase counter after Section 0 is erased  
    Counter increments each time erase section starts  

Test Input: 
  None.

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.CancelSectionErase</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>870</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1004</internalId></specobject>
    <specobject>
      <id>TS_FEE_CancelSectionErase_05</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_01/source/application/Tests.c</sourcefile>
      <sourceline>2301</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Test that Fee_CancelSectionErase() does not cancel the erase and returns E_NOT_OK 
  if Fee_State is different than FEE_ERASE_SECTION
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  None.

Test Execution: 
01. Initialize the stubs, simulate hardware reset, erase the entire flash and initialize Fee
02. Perform Startup1
03. Wait for delay timer to expire.
04. Check that IDLE state is reached
05. Check that Startup2 is not pending
06. Fill Section 0  completely
07. Wait for Fee to mark Section 0 as ERASABLE
08. Perform a couple of switch steps.
09. VP (Fee.Dsn.CancelSectionErase):
    *     - Request a section erase cancelation and return value is E_NOT_OK;
10. Check that the block was successfully written.
11. Check that Fls Cancel was called once to cancel the pending section erase
12. Check for flash errors

Test Input: 
  None.

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.CancelSectionErase</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>870</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1005</internalId></specobject>
    <specobject>
      <id>Ts_Fee_LegacyConfigId</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_01/source/application/Tests.c</sourcefile>
      <sourceline>2471</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: Test the call of Fee_Cancel when Fee has a job pending and in NORMAL mode.
Test Description: 
    This test verifies that Fee validates a section whether the FEE_CONFIG_ID or FEE_LEGACY_CONFIG_ID
    is found in flash.
  
Test Object: None.
Test Precondition: 
    - The flash must be erased
  
Test Execution: 
    01. Prepair the section management elements for the first 2 sections
    02. Set the initial test result
    03. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    04. Initialize StatusArrays for first section
    05. Generate section management objects for first section
    06. Initialize StatusArrays for second section
    07. The second section will have the legacy config id in flash
    08. Generate section management objects for second section
    09. Perform Startup1
    10. Check that both the sections are found ACTIVE
    11. Get the test case result
    12. return the test outcome
  
Test Input: None.
Test Output: 
    The cancelation of each request must be done successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.03</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>824</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1006</internalId></specobject>
    <specobject>
      <id>Ts_Fee_Cancel_Behavior_JobOngoing_Normal_01</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_01/source/application/Tests.c</sourcefile>
      <sourceline>2587</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: Test the call of Fee_Cancel when Fee has a job ongoing and in NORMAL mode.
Test Description: 
    This test verifies the Fee behavior when Fee_Cancel is called while Fee has an
    upper layer request PENDING and started, when in NORMAL mode.
  
Test Object: Fee_Cancel()
Test Precondition: 
    - The flash must be erased
  
Test Execution: 
    01. set the test result to indicate success - failures are set throughout the test
    02. The flash must be erased
    03. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    04. Perform initialization, (Startup1 and Startup2)
    05. request the Standard Read
    06. cancel it
    07. Check that Fee is IDLE
    08. request the Standard Write
    09. cancel it
    10. Check that Fee is IDLE
    11. request the Immediate Write
    12. cancel it
    13. Check that Fee is IDLE
    14. request the Invalidate
    15. cancel it
    16. Check that Fee is IDLE
    17. request the Erase for an immediate block
    18. cancel it
    19. Check that Fee is IDLE
    20. Get the test case result
    21. return the test outcome
  
Test Input: None.
Test Output: 
    The cancelation of each request must be done successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Normal.Cancel.HasRequest.Pending</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>942</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Normal.Cancel.HasRequest.Ongoing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>943</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1007</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>Ts_Fee_Cancel_Behavior_JobPending_Normal_NoJobPending</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_02/source/application/Tests.c</sourcefile>
      <sourceline>58</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: Test the call of Fee_Cancel when Fee has a job pending and in NORMAL mode.
Test Description: 
    This test verifies the Fee behavior when Fee_Cancel is called while Fee has an
    upper layer request PENDING but not yet started, when in NORMAL mode.
  
Test Object: Fee_Cancel()
Test Precondition: 
    - The flash must be erased
  
Test Execution: 
    01. set the test result to indicate success - failures are set throughout the test
    02. The flash must be erased
    03. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    04. Perform initialization, (Startup1 and Startup2)
    05. Call Cancel when no job
    06. Check that Fee is IDLE
    07. request the Standard Read
    08. cancel it
    09. Check that Fee is IDLE
    10. request the Standard Write
    11. cancel it
    12. Check that Fee is IDLE
    13. request the Immediate Write
    14. cancel it
    15. Check that Fee is IDLE
    16. request the Invalidate
    17. cancel it
    18. Check that Fee is IDLE
    19. request the Erase for an immediate block
    20. cancel it
    21. Check that Fee is IDLE
    22. Get the test case result
    23. return the test outcome
  
Test Input: None.
Test Output: 
    The cancelation of each request must be done successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Normal.Cancel.HasRequest.Pending</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>942</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Normal.Cancel.HasRequest.Ongoing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>943</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Cancel.Behaviour.NoJobPending</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>885</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1008</internalId></specobject>
    <specobject>
      <id>Ts_Fee_Cancel_Behavior_JobOngoing_Normal_02</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_02/source/application/Tests.c</sourcefile>
      <sourceline>216</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: Test the call of Fee_Cancel when Fee has a job ongoing and in NORMAL mode.
Test Description: 
    This test verifies the Fee behavior when Fee_Cancel is called while Fee has an
    upper layer request PENDING and started, when in NORMAL mode.
  
Test Object: Fee_Cancel()
Test Precondition: 
    - The flash must be erased
  
Test Execution: 
    01. set the test result to indicate success - failures are set throughout the test
    02. The flash must be erased
    03. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    04. Perform initialization, (Startup1 and Startup2)
    05. request the Standard Write
    06. cancel it during writing the block info
    07. Check that Fee is IDLE
    08. Check that the block was not written
    09. request the Standard Write
    10. cancel it during writing the block data
    11. Check that Fee is IDLE
    12. Check that the block was not written
    13. request the Standard Write
    14. cancel it during writing the block written marker
    15. Check that Fee is IDLE
    16. Check that the block was not written
    17. First make a write
    18. Clear the destination buffer
    19. request the Standard Read
    20. cancel it
    21. Check that Fee is IDLE
    22. Check that the block content hasn't got to DestinationBuffer
    23. request the Immediate Write
    24. cancel it
    25. Check that Fee is IDLE
    26. request the Invalidate
    27. cancel it
    28. Check that Fee is IDLE
    29. request the Erase for an immediate block
    30. cancel it
    31. Check that Fee is IDLE
    32. Check the Nvm notification calls and DET error is reported once if configured
    33. Get the test case result
    34. return the test outcome
  
Test Input: None.
Test Output: 
    The cancelation of each request must be done successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Normal.Cancel.HasRequest.Pending</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>942</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Normal.Cancel.HasRequest.Ongoing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>943</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Cancel.Behaviour.ReadJob</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>886</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Cancel.Behaviour.WriteJob.WriteBlockInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>887</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Cancel.Behaviour.WriteBlockData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>888</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Cancel.Behaviour.InvalidateJob.WriteBlockInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>889</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Cancel.Behaviour.WriteJob.WriteWrittenMarker</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>890</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Cancel.Behaviour.ReportNvm</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>892</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1009</internalId></specobject>
    <specobject>
      <id>Ts_Fee_Cancel_Behavior_JobPending_Startup1</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_02/source/application/Tests.c</sourcefile>
      <sourceline>442</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: Test the call of Fee_Cancel when Fee has a job pending while in Startup1.
Test Description: 
    This test verifies the Fee behavior when Fee_Cancel is called while Fee has an
    upper layer request PENDING, when in Startup1.
  
Test Object: Fee_Cancel()
Test Precondition: 
    - The flash must be erased
  
Test Execution: 
    01. set the test result to indicate success - failures are set throughout the test
    02. The flash must be erased
    03. initialize the Fee module
    04. allow the Startup1 to run for a while
    05. request the Standard Read
    06. cancel it
    07. Check that Fee is IDLE
    08. request the Standard Write
    09. cancel it
    10. Check that Fee is IDLE
    11. request the Immediate Write
    12. cancel it
    13. Check that Fee is IDLE
    14. request the Invalidate
    15. cancel it
    16. Check that Fee is IDLE
    17. request the Erase for an immediate block
    18. cancel it
    19. Check that Fee is IDLE
    20. Get the test case result
    21. return the test outcome
  
Test Input: None.
Test Output: 
    The cancelation of each request must be done successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Startup1.Cancel.HasRequest</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>938</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1010</internalId></specobject>
    <specobject>
      <id>Ts_Fee_Cancel_Behavior_JobPending_Startup2</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_02/source/application/Tests.c</sourcefile>
      <sourceline>608</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: Test the call of Fee_Cancel when Fee has a job pending while in Startup2.
Test Description: 
    This test verifies the Fee behavior when Fee_Cancel is called while Fee has an
    upper layer request PENDING, when in Startup2.
  
Test Object: Fee_Cancel()
Test Precondition: 
    - The flash must be erased
  
Test Execution: 
    01. set the test result to indicate success - failures are set throughout the test
    02. The flash must be erased
    03. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    04. Perform initialization, (Startup1 and Startup2)
    05. Perform reset
    06. Initialize flash driver and test stubs for Nvm and Det
    07. Initialize Fee module
    08. Perform initialization, (Startup1, Startup2 and Switch). Switch starts immediately after initialization.
        There is no need for a trigger.
    09. Wait untill startup2 starts
    10. request the Standard Read
    11. cancel it
    12. Check that Fee is IDLE
    13. request the Standard Write
    14. cancel it
    15. Check that Fee is IDLE
    16. request the Immediate Write
    17. cancel it
    18. Check that Fee is IDLE
    19. request the Invalidate
    20. cancel it
    21. Check that Fee is IDLE
    22. request the Erase for an immediate block
    23. cancel it
    24. Check that Fee is IDLE
    25. Get the test case result
    26. return the test outcome
  
Test Input: None.
Test Output: 
    The cancelation of each request must be done successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Startup2.Cancel.HasRequest.Pending</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>940</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1011</internalId></specobject>
    <specobject>
      <id>Ts_Fee_Cancel_Behavior_JobOngoing_Startup2</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_02/source/application/Tests.c</sourcefile>
      <sourceline>793</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: Test the call of Fee_Cancel when Fee has a job ongoing and in Startup2.
Test Description: 
    This test verifies the Fee behavior when Fee_Cancel is called while Fee has an
    upper layer request PENDING and started, when in Startup2.
  
Test Object: Fee_Cancel()
Test Precondition: 
    - The flash must be erased
  
Test Execution: 
    01. set the test result to indicate success - failures are set throughout the test
    02. The flash must be erased
    03. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    04. Perform initialization, (Startup1 and Startup2)
    05. Perform reset
    06. Initialize flash driver and test stubs for Nvm and Det
    07. Initialize Fee module
    08. Perform initialization, (Startup1, Startup2 and Switch). Switch starts immediately after initialization.
        There is no need for a trigger.
    09. Wait untill startup2 starts
    10. request the Standard Read
    11. cancel it
    12. Check that Fee is IDLE
    13. request the Standard Write
    14. cancel it
    15. Check that Fee is IDLE
    16. request the Immediate Write
    17. cancel it
    18. Check that Fee is IDLE
    19. request the Invalidate
    20. cancel it
    21. Check that Fee is IDLE
    22. request the Erase for an immediate block
    23. cancel it
    24. Check that Fee is IDLE
    25. Get the test case result
    26. return the test outcome
  
Test Input: None.
Test Output: 
    The cancelation of each request must be done successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Startup2.Cancel.HasRequest.Ongoing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>941</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1012</internalId></specobject>
    <specobject>
      <id>Ts_Fee_Cancel_Behavior_JobOngoing_SectionSwitch</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_02/source/application/Tests.c</sourcefile>
      <sourceline>980</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: Test the call of Fee_Cancel when Fee has a job ongoing and in Section Switch.
Test Description: 
    This test verifies the Fee behavior when Fee_Cancel is called while Fee has an
    upper layer request PENDING and started, when in Section Switch.
  
Test Object: Fee_Cancel()
Test Precondition: 
    - The flash must be erased
  
Test Execution: 
    01. set the test result to indicate success - failures are set throughout the test
    02. The flash must be erased
    03. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    04. Perform initialization, (Startup1 and Startup2)
    05. Perform reset
    06. Initialize flash driver and test stubs for Nvm and Det
    07. Initialize Fee module
    08. Perform initialization, (Startup1, Startup2 and Switch). Switch starts immediately after initialization.
        There is no need for a trigger.
    09. Wait untill startup2 starts
    10. Now all the sections shall be valid and empty. Get the empty space value in a section.
    11. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    12. request the Standard Read
    13. cancel it
    14. Check that Fee is IDLE
    15. request the Standard Write
    16. cancel it
    17. Check that Fee is IDLE
    18. request the Immediate Write
    19. cancel it
    20. Check that Fee is IDLE
    21. request the Invalidate
    22. cancel it
    23. Check that Fee is IDLE
    24. request the Erase for an immediate block
    25. cancel it
    26. Check that Fee is IDLE
    27. Get the test case result
    28. return the test outcome
  
Test Input: None.
Test Output: 
    The cancelation of each request must be done successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.SectonSwitch.Cancel.HasRequest.Ongoing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>945</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1013</internalId></specobject>
    <specobject>
      <id>Ts_Fee_Cancel_Behavior_JobPending_SectionSwitch</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_02/source/application/Tests.c</sourcefile>
      <sourceline>1190</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: Test the call of Fee_Cancel when Fee has a job pending while Section Switch.
Test Description: 
    This test verifies the Fee behavior when Fee_Cancel is called while Fee has an
    upper layer request PENDING but not started, when in Section Switch.
  
Test Object: Fee_Cancel()
Test Precondition: 
    - Fee initialization must be complete, including Startup2
    - Fee must be in a Section Switch
  
Test Execution: 
    01. set the test result to indicate success - failures are set throughout the test
    02. The flash must be erased
    03. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    04. Perform initialization, (Startup1 and Startup2)
    05. Perform reset
    06. Initialize flash driver and test stubs for Nvm and Det
    07. Initialize Fee module
    08. Perform initialization, (Startup1, Startup2 and Switch). Switch starts immediately after initialization.
        There is no need for a trigger.
    09. Wait untill startup2 starts
    10. Now all the sections shall be valid and empty. Get the empty space value in a section.
    11. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    12. Fill one section at a time by writing a different block, until Fee enters switch.
    13. request the Standard Read
    14. cancel it
    15. Check that Fee is IDLE
    16. request the Standard Write
    17. cancel it
    18. Check that Fee is IDLE
    19. request the Immediate Write
    20. cancel it
    21. Check that Fee is IDLE
    22. request the Invalidate
    23. cancel it
    24. Check that Fee is IDLE
    25. request the Erase for an immediate block
    26. cancel it
    27. Check that Fee is IDLE
    28. Get the test case result
    29. return the test outcome
  
Test Input: None.
Test Output: 
    The cancelation of each request must be done successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.SectonSwitch.Cancel.HasRequest.Pending</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>944</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1014</internalId></specobject>
    <specobject>
      <id>Ts_Fee_Cancel_Behavior_WrittenMarkerOngoing</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_02/source/application/Tests.c</sourcefile>
      <sourceline>1425</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: Test the call of Fee_Cancel when Fee is writing the WRITTEN marker.
Test Description: 
    This test verifies the Fee behavior when Fee_Cancel is called while Fee is writing
    the WRITTEN marker for a block.
  
Test Object: Fee_Cancel()
Test Precondition: 
    - The flash must be erased
  
Test Execution: 
    01. set the test result to indicate success - failures are set throughout the test
    02. The flash must be erased
    03. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    04. Perform initialization, (Startup1 and Startup2)
    05. request the Standard Write
    06. cancel it
    07. Check that Fee is IDLE
    08. check that the write for the WRITTEN marker is canceled at Fls level
    09. Get the test case result
    10. return the test outcome
  
Test Input: None.
Test Output: 
    - The cancelation of each request must be done successfully
    - The WRITTEN marker of each request must be stored successfully
    - For each cancellation, the JobError is passed to NvM after writing the WRITTEN marker
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Cancel.Behaviour.WriteJob.WriteWrittenMarker</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>890</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1015</internalId></specobject>
    <specobject>
      <id>Ts_Fee_Cancel_Behavior_WritingSectionHeader</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_02/source/application/Tests.c</sourcefile>
      <sourceline>1531</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: Test the call of Fee_Cancel when Fee is writing each section header.
Test Description: 
    This test verifies the Fee behavior when Fee_Cancel is called while Fee is writing
    each of the two section headers.
  
Test Object: Fee_Cancel()
Test Precondition: 
    - The flash must be erased
  
Test Execution: 
    01. set the test result to indicate success - failures are set throughout the test
    02. The flash must be erased
    03. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    04. Run until the state is FEE_WRITE_SECTION_HEADER
    05. cancel it
    06. Check that Fee is IDLE
    07. check that the write for the section header is ongoing at Fls level
    08. Get the test case result
    09. return the test outcome
  
Test Input: None.
Test Output: 
    - The cancellations must not disrupt the writing of the two section headers
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Cancel.Behaviour.InternalOperations</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>891</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1016</internalId></specobject>
    <specobject>
      <id>Ts_Fee_FreezeActivities_NoInit</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_02/source/application/Tests.c</sourcefile>
      <sourceline>1629</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: Test the call of FEE_FreezeActivities when Fee is not initialized.
Test Description: 
    This test verifies the Fee behavior when Fee_Cancel is called while Fee is writing
    each of the two section headers.
  
Test Object: Fee_Cancel()
Test Precondition: 
    - The flash must be erased
  
Test Execution: 
    01. fee return value
    02. set the test result to indicate success - failures are set throughout the test
    03. Simulate h/w reset
    04. Get the test case result
    05. return the test outcome
  
Test Input: None.
Test Output: 
    - Expected call result is E_NO_OK.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.FreezeActivities.API</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>273</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1017</internalId></specobject>
    <specobject>
      <id>Ts_Fee_GetEraseCounter</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_02/source/application/Tests.c</sourcefile>
      <sourceline>1681</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: Test the call of Fee_GetEraseCounterValue.
Test Description: 
    This test verifies the Fee_GetEraseCounterValue() Api, that it returns the correct value.
  
Test Object: Fee_GetEraseCounterValue()
Test Precondition: 
    - The flash must be erased
  
Test Execution: 
    01. set the test result to indicate success - failures are set throughout the test
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Check Erase Counter is 4, 3 sections will have 2,3,4
    07. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    08. Read the blocks and check their consistency
    09. Fill one section at a time by writing a different block, until Fee enters switch.
    10. Perform the switch (&gt;2 sections) / Just stay IDLE (2 sections)
    11. Check Erase Counter is 5 after a section was switched and then erased(previous 4)
    12. Get the test case result
    13. return the test outcome
  
Test Input: None.
Test Output: 
    - Expected call result is the value of the erase counter.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.EraseCounter.API</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>267</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1018</internalId></specobject>
    <specobject>
      <id>TS_Fee_AbortErase_DuringSwitch</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_02/source/application/Tests.c</sourcefile>
      <sourceline>1815</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This tests the Abort Erase functionality during an erase trigger by a section switch.
  A section erase shall be aborted if a immediate writing comes during this erase.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Read the blocks and check their consistency
    08. Fill one section at a time by writing a different block, until Fee enters switch.
    09. Update the oldest section index
    10. Perform the switch (&gt;2 sections) / Just stay IDLE (2 sections)
    11. Reset FlsCancel stub to check if the Immediate write triggers a Fls_Cancel of Erase
    12. Erase all the sections except the current Active section.
        Request the Immediate Write
    13. Process Write Job
    14. Check that the block was successfully written.
    15. Get over the delay timer
    16. Check that the erase is restarted after job completion
    17. Check that Fls Cancel was called once to cancel the pending section erase
    18. Check for flash errors
    19. Update the oldest section index
    20. Perform the switch (&gt;2 sections) / Just stay IDLE (2 sections)
    21. Reset FlsCancel stub to check if the Immediate write triggers a Fls_Cancel of Erase
    22. Test write job.
    23. Process Write Job
    24. Check that the block was successfully written.
    25. Get over the delay timer
    26. Check that the erase is restarted after job completion
    27. Check that Fls Cancel was called once to cancel the pending section erase
    28. Check for flash errors
    29. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.EnableAbortErase.NormalOperation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>274</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.SS.Behaviour.SSResume.BlockSwitching.SectionErase</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>903</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00009</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1019</internalId></specobject>
    <specobject>
      <id>TS_Fee_AbortErase_HighPrioritySwitch</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_02/source/application/Tests.c</sourcefile>
      <sourceline>2062</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This tests the Abort Erase functionality during an erase trigger by a section switch with high priority.
  A section erase shall not be aborted if a immediate writing comes during this erase.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block. Keep writing the block until Fee enters high priority switch.
    08. A high priority switch has started.
        Perform a couple of switch steps.
    09. Fill the section
    10. Perform a couple of switch steps.
    11. Reset FlsCancel stub to check if the Immediate write triggers a Fls_Cancel of Erase
    12. Process Write Job
    13. Check that the block was succesfull writen.
    14. Check that Fls Cancel was called once to cancel the pending section erase
    15. Check for flash errors
    16. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.EnableAbortErase.HighestInternalPriority</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>275</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00009</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1020</internalId></specobject>
    <specobject>
      <id>TS_Fee_AbortErase_NormalStartup2</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_02/source/application/Tests.c</sourcefile>
      <sourceline>2214</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: Test Abort erase feature.
Test Description: 
    This tests the Abort Erase functionality during an erase trigger by startup2 detecting an erasable footer.
    A section erase shall be aborted if a immediate writing comes during this erase.
  
Test Object: Fee_Cancel()
Test Precondition: 
    - The flash must be erased
  
Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Initialize StatusArrays
    04. initialize section 0
    05. initialize section 1
    06. Perform initialization, (Startup1 and Startup2)
    07. Check section 0 status
    08. Check section 1 status
    09. request the Standard Read
    10. Perform the switch (&gt;2 sections) / Just stay IDLE (2 sections)
    11. Reset FlsCancel stub to check if the Immediate write triggers a Fls_Cancel of Erase
    12. Erase all the sections except the current Active section.
        Request the Immediate Write
    13. Process Write Job
    14. Check that the block was succesfull writen.
    15. Check that Fls Cancel was called once to cancel the pending section erase
    16. Check for flash errors
    17. Get the test case result
    18. return the test outcome
  
Test Input: None.
Test Output: 
    The cancelation of each request must be done successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.EnableAbortErase.NormalOperation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>274</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.ErasableBitFlip</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>963</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00009</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1021</internalId></specobject>
    <specobject>
      <id>TS_Fee_AbortErase_HighestPrioStartup2</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_02/source/application/Tests.c</sourcefile>
      <sourceline>2364</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: Test Abort erase feature.
Test Description: 
    This tests the Abort Erase functionality during an erase trigger by startup2 when in highest internal priority.
    A section erase shall not be aborted because the internal module is in highest internal priority.
  
Test Object: Fee_Cancel()
Test Precondition: 
    - The flash must be erased
  
Test Execution: 
    01. Set the initial test result
    02. Prepare header/footer data
    03. Initialize StatusArrays set to Active
    04. Initialize section 0
    05. initialize section 1
    06. Perform initialization, (Startup1 and Startup2)
    07. Check section 0 status
    08. Check section 1 status
    09. request the Standard Read
    10. Perform the switch (&gt;2 sections) / Just stay IDLE (2 sections)
    11. Reset FlsCancel stub to check if the Immediate write triggers a Fls_Cancel of Erase
    12. Erase all the sections except the current Active section.
        Process Write Job
    13. Check that the block was successfully written.
    14. Check that Fls Cancel was not called to cancel the pending section erase
    15. Check for flash errors
    16. Get the test case result
    17. return the test outcome
  
Test Input: None.
Test Output: 
    The cancelation of each request must be done successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.EnableAbortErase.HighestInternalPriority</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>275</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.ErasableBitFlip</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>963</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00009</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1022</internalId></specobject>
    <specobject>
      <id>TS_Fee_InconsitentHeaderFooter</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_02/source/application/Tests.c</sourcefile>
      <sourceline>2511</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: Test Abort erase feature.
Test Description: 
    This tests the Abort Erase functionality during an erase trigger by startup2 when in highest internal priority.
    A section erase shall not be aborted because the internal module is in highest internal priority.
  
Test Object: Fee_Cancel()
Test Precondition: 
    - The flash must be erased
  
Test Execution: 
    01. Set the initial test result
    02. Prepare header/footer data
    03. Initialize StatusArrays set to Active
    04. Initialize section 0
    05. initialize section 1
    06. Initialize section 2
    07. Perform initialization, (Startup1 and Startup2)
    08. Check section 0 status
    09. Check section 1 status
    10. Check section 2 status
    11. Get the test case result
    12. return the test outcome
  
Test Input: None.
Test Output: 
    The cancelation of each request must be done successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.01</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>822</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1023</internalId></specobject>
    <specobject>
      <id>TS_Fee_AbortErase_LeadsToHPSwitch</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_02/source/application/Tests.c</sourcefile>
      <sourceline>2642</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This tests the Abort Erase functionality during an erase in multiple moments of a high priority switch.
  When the erase is requested, it will be interrupted in the same way, for a second time.
  The second interruption will trigger a high priority switch as the banks will become full.
  After completing the high priority switch another erase is requested that gets cancelled by
  one more immediate write. Fee gets back to high internal priority.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Read the blocks and check their consistency
    08. Fill one section at a time by writing a different block, until Fee enters switch.
    09. Perform the switch (&gt;2 sections) / Just stay IDLE (2 sections)
    10. Reset FlsCancel stub to check if the Immediate write triggers a Fls_Cancel of Erase
    11. Erase all the sections except the current Active section.
    12. request the Immediate Write that should cancel the section erase
    13. Process Write Job
    14. Check that the block was written successfully
    15. Fill the section
    16. Get over the delay timer
    17. Check that the erase is restarted after job completion
    18. Request immediate write for the second time. The section erase shall be canceled one more time.
        This time high priority switch shall start
    19. Process Write Job
    20. Fill the section
    21. Get over the delay timer
    22. Check that the erase is restarted after job completion
    23. Request immediate write for the third time. The section erase shall be canceled one more time.
        This time high priority switch shall start again, but only due to section erase.
    24. Check that the erase is done before the job due to high internal priority
    25. Process Write Job
    26. Get over the delay timer
    27. Check that the switch is also finished
    28. Check that Fee erases the other section, for the second high priority switch.
    29. The fact that Fee erases a different section is proved by verifying the erase cancel count
        (so we know that the there was no unpredicted erase cancel that would lead to another erase attempt for the same section).
        Check that Fls Cancel was called once to cancel the pending section erase
    30. Check for flash errors
    31. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.EnableAbortErase.HighestInternalPriority</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>275</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00009</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1024</internalId></specobject>
    <specobject>
      <id>TS_Fee_AbortErase_LeadsToHPStartup2</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_02/source/application/Tests.c</sourcefile>
      <sourceline>2900</sourceline>
      <version>1</version>
      <description>Test Synopsis: Test Abort erase feature.
Test Description: 
    This tests the Abort Erase functionality during an erase triggered by startup2. This erase interruption will 
    send Fee to highest internal priority. Startup2 shall restart the erase, and after section revalidation the job shall take priority.
    After job completion Fee shall transition from Startup2 to Switch directly, when the delay timer expires.
  
Test Object: None.
Test Precondition: 
    - The flash must be erased
  
Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Initialize StatusArrays
    04. initialize section 0
    05. initialize section 1
    06. Perform initialization, (Startup1 and Startup2)
    07. Check section 0 status
    08. Check section 1 status
    09. request the Standard Read
    10. Wait until Startup2 triggers section erase
    11. Reset FlsCancel stub to check if the Immediate write triggers a Fls_Cancel of Erase
    12. Request an immediate write that leads to high priority startup2 by interrupting the section erase
    13. Erase all the sections except the current Active section.
    14. Process Write Job
    15. Check that the block was successfully written.
    16. Get over the delay timer
    17. Startup2 shall erase the section now
    18. After section erase is complete, switch shall start, with one more erase to be done
    19. Go to Idle state
    20. Check that Fls Cancel was not called to cancel the pending section erase
    21. Check for flash errors
    22. Get the test case result
    23. return the test outcome
  
Test Input: None.
Test Output: 
    The cancelation of each request must be done successfully.
  </description>
      <providescoverage>
        <provcov>
          <linksto>Fee.EnableAbortErase.HighestInternalPriority</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>275</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.ErasableBitFlip</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>963</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00009</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1025</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_Fee_BufferCalculation</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_BufferCalc/source/application/Tests.c</sourcefile>
      <sourceline>81</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch works correctly when FeeEnableSmallSectionSize is enabled.
  Tests that during initialization the Fee uses the configured Init Read Size.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform initialization, (Startup1 and Startup2)
    04. Write all block once writing the block id in the first byte of the data
    05. VP: Check the number of Fls_MainFunction and Fls_Write
    06. Reset Fls_MainFunction counter
    07. VP: Simulate ECU reset and make sure the initialization is done correctly
    08. Wait for Init Fill Cache to start for Fee to start reading Block informations
    09. VP: Verify  that during read block information the Fee uses the configured Init Read Size(truncated to multiple of block information size 44-&gt;32 bytes)
    10. VP: Check the number of Fls_MainFunction and Fls_Read
    11. Reset Fls_MainFunction counter and Fls_Read
    12. Check for flash errors
    13. Write blocks till switch is started
    14. Reset Fls_MainFunction counter, Fls_Read and Fls_Write
    15. Wait for switch to finish
    16. VP: Check the number of Fls_MainFunction, Fls_Write and Fls_Read
    17. Check for flash errors
    18. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeBufferCalculation.SmallestBuffer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>301</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeBufferCalculation.DefaultBuffer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>302</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeBufferCalculation.InitBuffer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>304</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeBufferCalculation.ConfiguredInitBuffer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>303</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1026</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_Fee_Critical_CriticalSectionFail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_CriticalBlock_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>60</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests that if the critical write fails in the reserved space in critical section
  Fee is not able to immediately write the critical block again.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Initialization
    04. Write a block
    05. Write the critical block
    06. Erase the critical block in order to unfreeze Fee
    07. Measure the time for writing 4 different blocks, that have to be switched later
    08. Count the number of block writes of the same block, until Fee enters in highest priority switch.
        (switching all the blocks will always take longer than the write of one of them)
    09. Reconstitute the whole scenario from Fee point of view, up to the last write that causes highest internal priority
    10. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    11. Perform Initialization
    12. Write a block
    13. Write critical block
    14. Erase the critical block in order to unfreeze Fee
    15. Write the blocks to be switched
    16. Write the block as many times as it was written in the original scenario
    17. Request the write to enter highest priority switch
    18. Request the write of the critical block
    19. Simulate a Fls failure
    20. Let Fee deal with failure
    21. Unlock Fls, and let it accept jobs
    22. Request the write of the critical block, and check that it is accepted
    23. Check that the critical write failed though
    24. Finish the switch
    25. Request the write of the critical block, and check that it can be performed
    26. Check for flash errors
    27. Set test case result

Test Input: 
  None.

Test Output: 
  Fee shall mark Section 0 as ACTIVE.

  Section status after start-up:
   - Section 0: Active
   - Section 1: Erased
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeCriticalBlock.Fail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>288</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1027</internalId></specobject>
    <specobject>
      <id>TS_Fee_Critical_BehaviorAtStartUp_2s</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_CriticalBlock_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>307</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests that the critical write during startup1 is reported as failed.
  Tests that the write of the critical block can not interrupt a pending write of critical block.
  Tests that the write of critical block is reported as failed when in Startup2 and there is no space available.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Request the critical write while Fee is in Startup1 mode, and check that it fails
    04. Start Startup1 but do not finish it
    05. Request the critical write while Fee is in Startup1 mode, and check that it fails
    06. Perform Initialization
    07. Write blocks
    08. Measure the time for writing the regular block
    09. Count the number of block writes of the same block, until Fee enters in highest priority switch.
        (switching all the blocks will always take longer than the write of one of them)
    10. Reconstitute the whole scenario from Fee point of view, up to the last write that causes highest internal priority
    11. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    12. Write blocks
    13. Write the block as many times as it was written in the original scenario
    14. Request the write of the critical block
    15. Request the write of the critical block and check that it can not interrupt itself
    16. Simulate RESET
    17. Perform Startup1
    18. Request erase the critical block in order to unfreeze Fee
    19. Request the write of the critical block and check that it fails due to lack of space at Startup2
    20. Check for flash errors
    21. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeCriticalBlock.Fail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>288</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeCriticalBlock.Priority</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>281</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1028</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_CopyBlocks_c2s</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_CriticalBlock_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>510</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch works correctly. 
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Read the blocks and check their consistency
    08. Fill one section at a time by writing a different block, until Fee enters switch.
    09. VP(Fee.Dns.SS.TriggeringTheSwitch.WriteRequest): This write job will have started the switch when the while loop is left.
    10. On 2 sections, by the time when the processing is over, the switch is also over.
    11. Update the oldest section index
    12. Perform the switch (&gt;2 sections) / Just stay IDLE (2 sections)
    13. Erase all the sections except the current Active section.
    14. VP(Fee.Dns.SS.CopyBlocks): Read the blocks and validate them once more.
    15. Check for flash errors
    16. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.CopyBlocks</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>895</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.SS.TriggeringTheSwitch.WriteRequest</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>897</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1029</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_CopyCopiedBlocks_c2s</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_CriticalBlock_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>676</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch works correctly and copies not only the written blocks 
  but the already copied ones too. 
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block, until Fee enters switch.
    08. On 2 sections, by the time when the processing is over, the switch is also over.
    09. Perform the switch (&gt;2 sections) / Just stay IDLE (2 sections)
    10. Perform switches in order to make sure that the interesting blocks are switched again.
        (Considering the switch trigger condition, Fee will carry the same block every FEE_NUMBER_OF_SECTIONS / 2 times)
    11. Perform the switch again.
    12. Erase all the sections except the current Active section.
    13. VP(Fee.Dns.SS.CopyBlocks): Read the blocks and validate them once more.
    14. Check for flash errors
    15. Set test case result

Test Input: 
  None.

Test Output: 
  Fee shall mark Section 0 as ACTIVE.

  Section status after start-up:
   - Section 0: Active
   - Section 1: Erased
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.CopyBlocks</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>895</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1030</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_RevalidateOldSection_c2s</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_CriticalBlock_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>853</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch works correctly and after the section is copied 
  the section is revalidated.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block, until Fee gets round to the same Active section index.
        By then the section shall be empty and consistent.
    08. Exclusively write/invalidate blocks in the section that was supposed to be revalidated by switch.
    09. Simulate RESET
    10. Perform initialization, (Startup1)
    11. Read the exclusive blocks and validate them.
    12. Check for flash errors
    13. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.RevalidateOldSection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>896</internalId></provcov>
        <provcov>
          <linksto>Fee.ConsistencyPatterns.SectionHeader.Write</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>271</internalId></provcov>
        <provcov>
          <linksto>Fee.ConsistencyPatterns.SectionHeader.Read.Startup</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>270</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1031</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_ImmediatelyAfterInit_c2s</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_CriticalBlock_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>999</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch is triggered correctly.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block, until Fee enters switch.
    08. Perform a couple of switch steps.
    09. Simulate RESET
    10. Perform initialization, (Startup1)
    11. VP(Fee.Dsn.Initialization.Startup2.07): Request a job to trigger Startup2 and make sure that Startup2 is triggered and not Switch
    12. Get over the delay timer
    13. Check that Startup2 started.
    14. Finish Startup2. If also the Switch that was interrupted by reset is finished,
        it means that the Switch started directly after Startup2 and there was no need of a triggering job.
    15. Erase all the sections except the current Active section.
    16. VP(Fee.Dns.SS.TriggeringTheSwitch.AfterInit): Check that the switch had finished indeed.
    17. Check for flash errors
    18. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.TriggeringTheSwitch.AfterInit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>900</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup2.07</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>856</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1032</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_HP_ImmediatelyAfterInit_c2s</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_CriticalBlock_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>1183</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch is triggered correctly even in highest priority. 
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block. Keep writing the block until Fee enters high priority switch.
    08. Perform a couple of switch steps.
    09. Simulate RESET
    10. Request a write for resuming high priority switch
    11. Perform the high priority switch
    12. Erase all the sections except the current Active section.
    13. Check that the switch had finished indeed.
    14. Check for flash errors
    15. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.TriggeringTheSwitch.AfterInit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>900</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1033</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_ReadNoTrigger_c2s</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_CriticalBlock_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>1339</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch is never triggered by read job request. 
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block, until Fee is write before entering switch.
    08. Read blocks that haven't been written. They shouldn't be found and they shall not trigger switch
    09. Read blocks that have been written. They should be found and they shall not trigger switch
    10. VP(Fee.SS.TriggeringTheSwitch.ReadRequest): Check that Fee is in idle and the switch has not started
    11. Request a write that should trigger switch
    12. Get over the delay timer
    13. Check that Fee is in idle now
    14. Check for flash errors
    15. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.SS.TriggeringTheSwitch.ReadRequest</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>259</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1034</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_Fee_Critical_ReadInIdle</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_CriticalBlock_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>62</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests critical block read works correctly in different situations relative to critical write.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Initialization
    04. Write some blocks in the active section
    05. Check that Fee is idle
    06. Write the critical block when Fee is idle.
    07. Request a read for critical block and check that it's accepted only via regular interface 
    08. Request a write of critical block during read and check that it is not accepted
    09. Run a cycle
    10. Check that the read for critical block is still pending
    11. Request a write of critical block during read and check that it is not accepted
    12. Read again to check the content too
    13. Check that Fee is not busy
    14. Check that the job result is OK
    15. Request jobs for normal blocks and check that they are rejected
    16. Request erase immediate for critical block and check that the job is accepted and processed
    17. Request a read again for critical block. This time the block is erased.
    18. Request a write of critical block and check that it is accepted, meaning it cancels the read
    19. Finalize the write
    20. Request a read for critical block (should be accepted via regular interface only) and make it fail.
    21. Handle failure
    22. Check that Fee still doesn't accept jobs, as it should be frozen.
    23. Request jobs for normal blocks and check that they are rejected
    24. Not even the critical write
    25. Simulate RESET
    26. Request a read for critical block and check that it is accepted.
    27. Process the read (Startup1 first)
    28. Check that Fee still doesn't accept jobs, as it should be frozen because critical block is found at init.
    29. Request jobs for normal blocks and check that they are rejected
    30. Not even the critical write
    31. Erase the critical block.
    32. Read the blocks and check their consistency
    33. Request a write of critical block and check that it is accepted
    34. Erase the critical block.
    35. Request a custom write of the critical block and check that it is not accepted
    36. Check for flash errors
    37. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeCriticalBlock.WriteFreeze</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>283</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeCriticalBlock.InitFreeze</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>284</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeCriticalBlock.ReadBlock</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>286</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeCriticalBlock.StopBlockJobs</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>285</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Critical.InterruptItself</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>949</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeWriteCustom.ConfiguredBlock</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>240</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeReadCustom.BlockNumber</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>250</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1035</internalId></specobject>
    <specobject>
      <id>TS_Fee_Critical_CriticalSectionS2</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_CriticalBlock_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>455</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests that Fee reserves space in critical section for critical write, at startup2.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Write a block
    04. Measure the time for writing the critical block
    05. Erase the critical block in order to unfreeze Fee
    06. Measure the time for writing the standard block
    07. Count the number of block writes of the same block, until Fee enters in highest priority switch.
        (switching all the blocks will always take longer than the write of one of them)
    08. Reconstitute the whole scenario from Fee point of view, up to the last write that causes highest internal priority
    09. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    10. Write a block
    11. Write critical block
    12. Erase the critical block in order to unfreeze Fee
    13. Write the standard block
    14. Write the block as many times as it was written in the original scenario
    15. Request a write that requires changing section
    16. Request the write of the critical block that interrupts the standard write
    17. Check that there is space in critical section only for critical block and that it
        will be written in time.
    18. Simulate RESET
    19. Critical block should be found. Other blocks should not be able to be read.
    20. Erase the critical block. Job will be done after the highest priority startup2
    21. Read the blocks and check their consistency
    22. Check for flash errors
    23. Set test case result

Test Input: 
  None.

Test Output: 
  Fee shall mark Section 0 as ACTIVE.

  Section status after start-up:
   - Section 0: Active
   - Section 1: Erased
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeCriticalBlock.WriteFreeze</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>283</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1036</internalId></specobject>
    <specobject>
      <id>TS_Fee_Critical_BehaviorAtStartUp_4s</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_CriticalBlock_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>699</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests that the critical write during startup1 is reported as failed.
  Tests that the write of the critical block can not interrupt a pending write of critical block.
  Tests that the write of critical block is reported as failed when in Startup2 and there is no space available.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Request the critical write while Fee is in Startup1 mode, and check that it fails
    04. Start Startup1 but do not finish it
    05. Request the critical write while Fee is in Startup1 mode, and check that it fails
    06. Perform Initialization
    07. Write blocks
    08. Measure the time for writing the regular block
    09. Count the number of block writes of the same block, until Fee enters in highest priority switch.
        (switching all the blocks will always take longer than the write of one of them, even 2 times)
        while ((i &lt;= Stopwatch*2U) &amp;&amp; (WritesCounter &lt; 1000U))
    10. Reconstitute the whole scenario from Fee point of view, up to the last write that causes highest internal priority
    11. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    12. Perform Initialization
    13. Write blocks
    14. Write the block as many times as it was written in the original scenario
    15. Request the write of the critical block
    16. Request the write of the critical block and check that it can not interrupt itself
    17. Let the critical block be written
    18. Simulate RESET
    19. Perform Startup1
    20. Request erase for critical block in order to unfreeze Fee
    21. Request the write of the critical block and check that it fails due to lack of space at Startup2
    22. Perform Startup2
    23. Request the write of the critical block and check that it is processed.
    24. Simulate RESET
    25. Request a job that is accepted even though the critical block is written. (because Startup1 is not done)
    26. Perform Startup1
    27. Check that NvM's job was reported as failed
    28. Simulate the check for job result requested by NvM
    29. Check for flash errors
    30. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeCriticalBlock.Fail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>288</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeCriticalBlock.Priority</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>281</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Critical.InterruptItself</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>949</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1037</internalId></specobject>
    <specobject>
      <id>TS_Fee_Critical_ChangeSection</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_CriticalBlock_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>966</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests that the critical block changes section correctly when the active section is not the critical one.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1 and the validation of the first section as parto of Startup2
    04. Write a block
    05. Perform Startup2
    06. Measure the time for writing the critical block
    07. Erase the critical block in order to unfreeze Fee
    08. Fill the active section with some blocks smaller than the critical block
    09. Request the write of the critical block that should be done in the next section.
        This would prove that Fee does not save space for critical block in the first section.
    10. Assume the the active section has changed
    11. Check that the write of the critical block will be done in time. No Active marking takes place.
    12. Erase the first section. Critical block should not be in this section.
    13. Simulate RESET
    14. Check that the critical block was indeed written in the next section
    15. Check for flash errors
    16. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Critical.SectionChange</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>946</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Critical.CriticalSection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>948</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1038</internalId></specobject>
    <specobject>
      <id>TS_Fee_Critical_FailureChangeSection</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_CriticalBlock_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>1119</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests that if the block info for the critical block that changes section fails, Fee will change the section again.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1 and the validation of the first section as parto of Startup2
    04. Write a block
    05. Perform Startup2
    06. Measure the time for writing the critical block
    07. Erase the critical block in order to unfreeze Fee
    08. Fill the active section with some blocks smaller than the critical block
    09. Request the write of the critical block that should be done in the next section.
        This would prove that Fee does not save space for critical block in the first section.
    10. Assume the the active section has changed
    11. Simulate a Fls failure
    12. Let Fee deal with failure
    13. Unlock Fls, and let it accept jobs
    14. Request the write of the critical block that should be done in the next section.
    15. Assume that Fee changes the section again, this time because of block info failure
    16. Check that the write of the critical block will be done in time. No Active marking takes place.
    17. Erase the first and the second section. Critical block should not be in this section.
    18. Simulate RESET
    19. Check that the critical block was indeed written in the next section
    20. Erase the critical block in order to unfreeze Fee
    21. Finish any internal operation
    22. Fail 3 times the critical write and check that the section is changed
    23. Simulate a Fls failure
    24. Let Fee deal with failure
    25. Unlock Fls, and let it accept jobs
    26. Assume the the active section has changed
    27. Erase all the sections except the current Active section.
    28. Check that the critical block is written in the last section
    29. Request an erase for critical block.
    30. Check that the resuming state is FEE_MARK_HEADER_ACTIVE
    31. Wait for the erase immediate job to start
    32. Fail the erase immediate job.
    33. Check that the critical block is still consistent
    34. Check for flash errors
    35. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Critical.SectionChange</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>946</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Critical.SectionFull</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>947</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1039</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_Failures_c4s</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_CriticalBlock_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>1404</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests that if Fls fails read and write jobs during switch blocks will still end up being switched.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Read the blocks and check their consistency
    08. Fill one section at a time by writing a different block, until Fee enters switch.
    09. Go to Idle
    10. Check that the next step is to start switching the block all over again
    11. Go to Idle
    12. Check that the next step is to start switching the block all over again
    13. Reach the switch read phase for the same block
    14. Go to Idle
    15. Perform a retry for switch read
    16. Check that the read retry happened indeed
    17. The retry fails
    18. Go to Idle
    19. Check that the next step is to start switching the block all over again
    20. Go to copy data step
    21. Go to Idle
    22. Check that the next step is to start switching the block all over again
    23. Go to Idle
    24. Check that the next step is to start switching the block all over again
    25. Reach the switch read phase for the same block
    26. Go to copy data step
    27. Go to Idle
    28. Check that the next step is to start switching the block all over again
    29. Simulate a Fls failure 4 times and check that the active section must be changed at next operation
    30. Let the block be copy successfully
    31. Check that this copy block info changed the section
    32. Perform the switch (&gt;2 sections) / Just stay IDLE (2 sections)
    33. Erase all the sections except the current Active section.
    34. Read the blocks and validate them once more.
    35. Check Dem reports for failures
    36. Check for flash errors
    37. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.SectionSwitch.WriteBlockInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>930</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.SectionSwitch.BlockDataWrite</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>931</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.SectionSwitch.BlockWrittenMarkerWrite</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>932</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.SectionSwitch.BlockDataRead</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>933</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.SectionSwitch.BlockInfoMargin</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>934</internalId></provcov>
        <provcov>
          <linksto>Fee.FailureHandling.Behaviour.ProductionError.FEE_E_FLASH_ACCESSIBLE</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>261</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1040</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_CopyBlocks_c4s</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_CriticalBlock_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>1742</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch works correctly. 
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Read the blocks and check their consistency
    08. Fill one section at a time by writing a different block, until Fee enters switch.
    09. Update the oldest section index
    10. Perform the switch (&gt;2 sections) / Just stay IDLE (2 sections)
    11. Erase all the sections except the current Active section.
    12. Read the blocks and validate them once more.
    13. Check for flash errors
    14. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.CopyBlocks</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>895</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.SS.TriggeringTheSwitch.WriteRequest</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>897</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1041</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_CopyCopiedBlocks_c4s</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_CriticalBlock_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>1904</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch works correctly and copies not only the written blocks 
but the already copied ones too. 
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block, until Fee enters switch.
    08. Perform the switch (&gt;2 sections) / Just stay IDLE (2 sections)
    09. Perform switches in order to make sure that the interesting blocks are switched again.
        Considering the switch trigger condition, Fee will carry the same block every FEE_NUMBER_OF_SECTIONS / 2 times
    10. Erase all the sections except the current Active section.
    11. Read the blocks and validate them once more.
    12. Check for flash errors
    13. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.CopyBlocks</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>895</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1042</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_OnlyOldSection_c4s</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_CriticalBlock_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>2074</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch works correctly and switches only one section at a time. 
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform initialization, (Startup1 and Startup2)
    04. Now all the sections shall be valid and empty. Get the empty space value in a section.
    05. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill the Active section and go to the second section
    08. Monitor the section index.
    09. Get over the delay timer
    10. Exclusively write a block in the second section
    11. Fill one section at a time by writing a different block, until Fee enters switch.
    12. Perform the switch.
    13. Erase all the sections except the current Active section.
    14. Check that the block in the second section were not copied at first switch
    15. Check for flash errors
    16. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.CopyBlocks</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>895</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1043</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_RevalidateOldSection_c4s</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_CriticalBlock_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>2256</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch works correctly and after the section is copied 
the section is revalidated.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block, until Fee gets round to the same Active section index
        By then the section shall be empty and consistent.
    08. Exclusively write/invalidate blocks in the section that was supposed to be revalidated by switch.
    09. Simulate RESET
    10. Perform initialization, (Startup1)
    11. Read the exclusive blocks and validate them.
    12. Check for flash errors
    13. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.RevalidateOldSection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>896</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1044</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_ImmediatelyAfterInit_c4s</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_CriticalBlock_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>2399</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch is triggered correctly.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block, until Fee enters switch.
    08. Perform a couple of switch steps.
    09. Simulate RESET
    10. Perform initialization, (Startup1)
    11. Request a job to trigger Startup2 and make sure that Startup2 is triggered and not Switch
    12. Get over the delay timer
    13. Check that Startup2 started.
    14. Finish Startup2. If also the Switch that was interrupted by reset is finished,
        it means that the Switch started directly after Startup2 and there was no need of a triggering job.
    15. Erase all the sections except the current Active section.
    16. Check that the switch had finished indeed.
    17. Check for flash errors
    18. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.TriggeringTheSwitch.AfterInit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>900</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup2.07</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>856</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1045</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_Timer_c4s</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_CriticalBlock_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>2583</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the timer is respected in case of interruptions durring switch. 
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block, until Fee enters switch.
    08. Perform a couple of switch steps.
    09. Request a write
    10. Check that Fee is temporarily idle
    11. Get over the delay timer
    12. Check that the switch is resumed
    13. Perform a couple of switch steps.
    14. Request a read
    15. Check that Fee is temporarily idle
    16. Get over the delay timer
    17. Check that the switch is resumed
    18. Perform a couple of switch steps.
    19. Request a invalidation
    20. Check that Fee is temporarily idle
    21. Get over the delay timer
    22. Check that the switch is resumed
    23. Perform a couple of switch steps.
    24. Request a erase imm
    25. Check that Fee is temporarily idle
    26. Get over the delay timer
    27. Check that the switch is resumed
    28. Perform switch.
    29. Check that the switch had finished indeed.
    30. Check for flash errors
    31. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Timer.UserJobRequests</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>859</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Timer.InternalOperation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>861</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1046</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_WriteResumed_c4s</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_CriticalBlock_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>2834</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch resumes the interrupted write operation.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block, until Fee enters switch.
    08. Take the current free space in the active section after only one block copied.
    09. Until Switch performs read data
    10. Until Switch performs write data
    11. Finish the write of the first buffer. (this is a case of a big block, but it should work for a small block too,
        since the block switching is not finished until the written marker is completed)
    12. Request a write that interrupts the switch right after a switch data write has been done.
    13. Finish the switch.
    14. Check that switch resumed the data writing of the block that was being switched instead of restarting it.
        Now that the switch is over the occupied size in active section shall be
        by the switched blocks and the block that interrupted the switch, taken only once.
    15. Check that the switch had finished indeed.
    16. Check for flash errors
    17. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.Behaviour.SSResume.BlockSwitching.Writing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>901</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1047</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_JobInterrupts_1_c4s</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_CriticalBlock_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>3005</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch behaves correctly if interrupted by user job requests. 
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block, until Fee enters switch.
    08. Take the current free space in the active section after only one block copied.
    09. The block info of the invalidated block is copied here
    10. Request a write that interrupts the switch right after a switch block info has been done.
    11. The second block switch starts by copying block info
    12. Request a write that interrupts the switch right after a switch block info has been done.
    13. Until Switch performs read data
    14. Fee has requested a read data (first buffer) for the block that is being switched
    15. Request a write that interrupts the switch right after a switch read data has been done.
    16. Until Switch performs write data
    17. Finish the write of the first buffer. (this is a case of a big block, but it should work for a small block too,
        since the block switching is not finished until the written marker is completed)
    18. Request a write that interrupts the switch right after a switch data write has been done.
    19. Get over the delay timer
    20. Finish the switch.
    21. Check that switch resumed the data writing of the block that was being switched instead of restarting it.
        Now that the switch is over the occupied size in active section shall be
        by the switched blocks and the block that interrupted the switch, taken only once.
    22. Check that the switch had finished indeed.
    23. Check for flash errors
    24. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.Behaviour.SSResume.BlockSwitching.Writing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>901</internalId></provcov>
        <provcov>
          <linksto>Fee.SS.UserJobRequests</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>260</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1048</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_JobInterrupts_2_c4s</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_CriticalBlock_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>3240</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch behaves correctly if interrupted by user job requests. 
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block, until Fee enters switch.
    08. Take the current free space in the active section after only one block copied.
    09. First step in switching a block is done here: copying block info
    10. Request a write that interrupts the switch right during a switch block info.
    11. Finish the block info copy job at Fls level.
    12. Process the user requested job
    13. Run until Switch starts to perform read data
    14. Check that Fee did not transmit the user interruptions to Fls during block info switch
    15. Request a write that interrupts the switch right during a switch data reading.
    16. Check that Fee did canceled the switch reading by transmitting the interruption to Fls
    17. Now, instead of continuing the switch reading, Fee sent a new job to Fls (the user invalidation)
    18. Process the user requested job
    19. Fee restarts the switch reading
    20. Run until Switch starts to perform write data
    21. Request a write that interrupts the switch right during a switch data write.
    22. Finish the write of the first buffer. (this is a case of a big block, but it should work for a small block too,
        since the block switching is not finished until the written marker is completed)
    23. Process the user requested job
    24. Get over the delay timer
    25. Finish the switch.
    26. Check that switch resumed the data writing of the block that was being switched instead of restarting it.
        Now that the switch is over the occupied size in active section shall be
        by the switched blocks and the block that interrupted the switch, taken only once.
    27. Check that the switch had finished indeed.
    28. Check if Fee transmit the user interruptions to Fls others than for switch reading.
    29. Check for flash errors
    30. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.Behaviour.SSResume.BlockSwitching.Writing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>901</internalId></provcov>
        <provcov>
          <linksto>Fee.SS.UserJobRequests</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>260</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1049</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_ReadRestarted_c4s</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_CriticalBlock_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>3495</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch restarts the interrupted read operation. 
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block, until Fee enters switch.
    08. Until Switch performs read data
    09. Request a write that interrupts the switch right in the moment of reading data to be switch.
    10. Check that Fee is in idle now
    11. Resume the switch
    12. Check that Switch restarts the reading and not writing whatever is in internal buffer
    13. Finish the switch.
    14. Check that the switch had finished indeed.
    15. Check for flash errors
    16. Set test case result

Test Input: 
  None.

Test Output: 
 None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.Behaviour.SSResume.BlockSwitching.Reading</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>902</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1050</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_ReadNoTrigger_c4s</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_CriticalBlock_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>3656</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch is never triggered by read job request. 
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block, until Fee is write before entering switch.
    08. Read blocks that haven't been written. They shouldn't be found and they shall not trigger switch
    09. Read blocks that have been written. They should be found and they shall not trigger switch
    10. Check that Fee is in idle and the switch has not started
    11. Request a write that should trigger switch
    12. Get over the delay timer
    13. Check that Fee is in idle now
    14. Check for flash errors
    15. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.SS.TriggeringTheSwitch.ReadRequest</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>259</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1051</internalId></specobject>
    <specobject>
      <id>TS_Fee_DataInfoMarginFail_c4s</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_CriticalBlock_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>3805</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    Tests Fee behaviour in case Fls fails the write of the forth consecutive block info.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write some blocks
    05. Simulate a Fls refusal while Fls is not busy
    06. Request a write
    07. In this case the job is considered just like it failed
    08. Unlock Fls, and let it accept jobs
    09. Request a write
    10. Simulate a Fls failure
    11. Check that the job fails
    12. Request a write
    13. Simulate a Fls failure
    14. Check that the job fails
    15. Request an invalidation
    16. Simulate a Fls failure
    17. Check that the job fails
    18. Request an erase immediate
    19. Simulate a Fls failure
    20. Check that the job fails
    21. Any write job shall change the Active section
    22. The job shall pass
    23. Check that the active section is changed
    24. Check for flash errors
    25. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.StoreReqFailure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>917</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Job</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>916</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.BlockInfoMargin</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>918</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1052</internalId></specobject>
    <specobject>
      <id>Ts_Fee_Cancel_Behavior_JobOngoing_Normal_c4s</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_CriticalBlock_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>3987</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: Test the call of Fee_Cancel when Fee has a job ongoing and in NORMAL mode.
Test Description: 
    This test verifies the Fee behavior when Fee_Cancel is called while Fee has an
    upper layer request PENDING and started, when in NORMAL mode.
  
Test Object: Fee_Cancel()
Test Precondition: 
    - The flash must be erased
  
Test Execution: 
    01. set the test result to indicate success - failures are set throughout the test
    02. The flash must be erased
    03. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    04. Perform initialization, (Startup1 and Startup2)
    05. request the Standard Read
    06. cancel it
    07. Check that Fee is IDLE
    08. request the Standard Write
    09. cancel it
    10. Check that Fee is IDLE
    11. request the Immediate Write
    12. cancel it
    13. Check that Fee is IDLE
    14. request the Invalidate
    15. cancel it
    16. Check that Fee is IDLE
    17. request the Erase for an immediate block
    18. cancel it
    19. Check that Fee is IDLE
    20. Get the test case result
    21. return the test outcome
  
Test Input: None.
Test Output: 
    The cancelation of each request must be done successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Normal.Cancel.HasRequest.Pending</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>942</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Normal.Cancel.HasRequest.Ongoing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>943</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1053</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_Fee_Switch_ChangingActive_5s</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_FailureHandling_Init/source/application/Tests.c</sourcefile>
      <sourceline>58</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch changes the section if there is no more space in the current one. 
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block, until Fee enters switch.
    08. Update the oldest section index
    09. Get over the delay timer(&gt;2 sections)
    10. Finish the switch.
    11. Only the first 3 blocks are switched in the current section and the other 3 will be switched in the next section
    12. Erase all the sections except the current Active section.
    13. Read the blocks that are supposed to be switched in the last section.
        Therefore Switch must have changed the active section since there was no more space for switching all the blocks
    14. Check for flash errors
    15. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.Behaviour.ChangingActiveSection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>904</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1054</internalId></specobject>
    <specobject>
      <id>TS_Fee_Init_BlankCheckRefusals_H_and_F</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_FailureHandling_Init/source/application/Tests.c</sourcefile>
      <sourceline>235</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests Fee behovior in case of Fls failures regarding section header and footer operations.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
  01. Set the initial test result
  02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
  03. Write some blocks and let Startup2 to finish
  04. Simulate RESET
  05. Simulate a Fls refusal while Fls is not busy
  06. Check that the first state is to blankcheck the header's Erasable marker
  07. Check that the next state is to blankcheck the header's Active marker
  08. Check that the next state is to blankcheck the header's management data
  09. Check that the first state is to blankcheck the footer's Erasable marker
  10. Check that the next state is to blankcheck the footer's Active marker
  11. Check that the next state is to blankcheck the footer's management data
  12. Check that the footer reading refusal triggers a header check for the next section,
      and the current section is considered inconsistent
  13. Release Fls from refusals
  14. Wait until the header of the next section is prepared to be read
  15. Simulate a Fls refusal while Fls is not busy
  16. Check that the state with job refusal is FEE_INIT_READ_HEADER
  17. Check that the next state is to blankcheck the header's Active marker
  18. Wait until the header of the next section is prepared to be read
  19. Check that the state with job refusal is FEE_INIT_READ_FOOTER
  20. Check that the next state is to blankcheck the header's Active marker
  21. Release Fls from refusals
  22. Finalize Startup1
  23. Check for flash errors
  24. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>913</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal.Failed</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>914</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.SectionManagement</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>954</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.SectionMarkers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>955</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.SectionManagementRefused</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>956</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.ErasableRefused</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>957</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.ActiveRefused</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>958</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1055</internalId></specobject>
    <specobject>
      <id>TS_Fee_Init_BlockBlankCheck_RefuseFail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_FailureHandling_Init/source/application/Tests.c</sourcefile>
      <sourceline>449</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests Fee behavior in case of block cashing refusals and failures.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
  01. Set the initial test result
  02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
  03. Write some blocks and let Startup2 to finish
  04. Simulate RESET
  05. Finalize the section management reading
  06. Check that the state is FEE_BLANK_CHECK_W_MARKER
      It will pass because the first job in section was an invalidation.
  07. Simulate a Fls refusal for blank checking the block stamp
  08. Check that the block stamp was being checked
  09. Fee blank checks the next written marker and Fls refuses the job
  10. Check that the previous blank check refusal triggers a blank check on
      the written marker again, but for the next block info.
      This time Fls will not refuse the job
  11. Simulate a Fls refusal for reading the block stamp
  12. Release the driver from refusal
  13. Finish initialization
  14. Check that only the forth block written is found
  15. Simulate RESET
  16. Finalize the section management reading
  17. Simulate a Fls refusal for blank checking the written marker
  18. Check that the written marker was being checked
  19. Release the driver from refusal
  20. Go to the block reading
  21. Simulate flash failure
  23. Check that only the last 2 blocks can be recovered.
  24. Check for flash errors
  25. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.WrittenMarker</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>959</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.WrittenMarkerBlank</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>960</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.BlockStamp</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>961</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.BlockStampBlank</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>962</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.Retention</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>964</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1056</internalId></specobject>
    <specobject>
      <id>TS_Fee_Init_Failures_H_and_F</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_FailureHandling_Init/source/application/Tests.c</sourcefile>
      <sourceline>717</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests Fee behovior in case of Fls failures regarding section header and footer operations.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Write some blocks and let Startup2 to finish
    04. Simulate RESET
    05. Simulate a Fls refusal while Fls is not busy
    06. Check that the first state is to read the section header
    07. Check that the header reading refusal triggers a footer check
    08. Check that the footer reading refusal triggers a header check for the next section,
        and the current section is considered inconsistent
    09. Simulate flash failure
    10. Check that if the header reading fails the next step is to read the footer
    11. Simulate flash failure
    12. Check that the footer reading failure triggers a header check for the next section,
        and the current section is considered inconsistent
    13. Check that all the blocks are lost
    14. Check for flash errors
    15. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>913</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal.Failed</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>914</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal.Failed.Det</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>915</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.FailureHandling.Behaviour.Startup1.HeaderFailed</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>921</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.Startup1.FooterFailed</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>922</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.Startup1.BothSectionManagementObjectsFailed</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>923</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1057</internalId></specobject>
    <specobject>
      <id>TS_Fee_Init_BlockCache_RefuseFail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_FailureHandling_Init/source/application/Tests.c</sourcefile>
      <sourceline>872</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests Fee behavior in case of block cashing refusals and failures.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Write some blocks and let Startup2 to finish
    04. Simulate RESET
    05. Finalize the section management reading
    06. Simulate a Fls refusal while Fls is not busy
    07. Check that the first state is to read the section header
    08. Release Fls reading
    09. Check that the buffer block info refusal triggers a block by block reading
    10. Finish initialization
    11. Check that all the blocks are found
    12. Simulate RESET
    13. Go to the block reading
    14. Simulate flash failure
    15. Simulate a Fls refusal while Fls is not busy
    16. Check that the buffer block info failure triggers a block by block reading
    17. Check that block by block reading refusal doesn't change the state,
        since there are more block infos to be read.
        Release Fls reading in order to let Fee start the reading of the second block info
    18. Simulate flash failure
    19. Block info reading failed.
        Now make Fls to refuse one more block
    20. First 3 blocks written could not be recovered (one due to refusal and the other due to failure
        and the third due to refusal again).
        Let Fee read one more buffer (the one with empty block infos that will trigger changing section to be cached).
        (Meanwhile the third block must have been cached already)
    21. Simulate flash failure in order for Fee to go to block by block mode
    22. Check that the forth block can be recovered as no other refusals or failures will occur.
    23. Check for flash errors
    24. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>913</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal.Failed</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>914</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal.Failed.Det</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>915</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.FlashRead.BlockInfos.Fails</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>919</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1058</internalId></specobject>
    <specobject>
      <id>TS_Fee_Init_Cache_SectionTotalRefusal</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_FailureHandling_Init/source/application/Tests.c</sourcefile>
      <sourceline>1099</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests Fee behavior in case Fls continues to refuse writes of block infos beyound the predefined limit.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. If Consistency patterns are Off, perform only 6 writes of biggest block, otherwise only 5 writes
    02. Set the initial test result
    03. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    04. Perform Startup1
    05. Perform writes of a big block 6 times to almost fill the section
    06. Write a bunch of small blocks right at the end of the section
    07. Write the big block again until the section is changed
    08. Simulate RESET
    09. Perform Startup2
    10. Cache all the small blocks in one MF, but block Fls read for the last block.
    11. By now there is only one block not cached
    12. Check that even if the second section is mostly empty, because of read refusals,
        Fee will consider it Full to be on the safe side. The next write shall change the section.
    13. Release Fls read now.
    14. Read the blocks and validate them once more.
    15. Check for flash errors
    16. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>913</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal.Failed</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>914</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal.Failed.Det</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>915</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.FlashRead.BlockInfoByBlockInfo.Fails</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>920</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.InvalidLastBlockInfos</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>843</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1059</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_Fee_WriteRefused</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_FailureHandling_Internal/source/application/Tests.c</sourcefile>
      <sourceline>58</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests Fee behaviour in case Fls refusals during user writes.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Simulate a Fls refusal while Fls is not busy
    05. Request a write
    06. In this case the job is considered just like it failed
    07. Check that FlsWrite was called only once
    08. Check that the job has failed
    09. Unlock Fls, and let it accept jobs
    10. Perform the same job again
    11. This time the write will be performed
    12. Check for flash errors
    13. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>913</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal.Failed</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>914</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal.Failed.Det</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>915</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Job</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>916</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1060</internalId></specobject>
    <specobject>
      <id>TS_Fee_ReadRefused</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_FailureHandling_Internal/source/application/Tests.c</sourcefile>
      <sourceline>186</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests Fee behaviour in case Fls refusals during user reads.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write a block
    05. Simulate a Fls refusal while Fls is not busy
    06. Request a read
    07. In this case the job is considered just like it failed
    08. Check that FlsRead was called only once
    09. Check that the job has failed
    10. Unlock Fls, and let it accept jobs
    11. Perform the same job again
    12. This time the read will be performed
    13. Check for flash errors
    14. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>913</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal.Failed</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>914</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal.Failed.Det</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>915</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Job</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>916</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1061</internalId></specobject>
    <specobject>
      <id>TS_Fee_InvalidateRefused</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_FailureHandling_Internal/source/application/Tests.c</sourcefile>
      <sourceline>339</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests Fee behaviour in case Fls refusals during user invalidations.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write a block
    05. Simulate a Fls refusal while Fls is not busy
    06. Request an invalidation
    07. In this case the job is considered just like it failed
    08. Check that FlsRead was called only once
    09. Check that the job has failed
    10. Unlock Fls, and let it accept jobs
    11. Perform the same job again
    12. This time the read will be performed
    13. Check for flash errors
    14. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>913</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal.Failed</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>914</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal.Failed.Det</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>915</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Job</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>916</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1062</internalId></specobject>
    <specobject>
      <id>TS_Fee_EraseImmediateRefused</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_FailureHandling_Internal/source/application/Tests.c</sourcefile>
      <sourceline>478</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests Fee behaviour in case Fls refusals during user erase immediates.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write a block
    05. Simulate a Fls refusal while Fls is not busy
    06. Request an invalidation
    07. In this case the job is considered just like it failed
    08. Check that FlsRead was called only once
    09. Check that the job has failed
    10. Unlock Fls, and let it accept jobs
    11. Perform the same job again
    12. This time the read will be performed
    13. Check for flash errors
    14. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>913</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal.Failed</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>914</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal.Failed.Det</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>915</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Job</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>916</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1063</internalId></specobject>
    <specobject>
      <id>TS_Fee_WriteRefusedRetries</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_FailureHandling_Internal/source/application/Tests.c</sourcefile>
      <sourceline>617</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests Fee behaviour in case Fls refusals and retries during user writes.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Simulate a Fls refusal while Fls is busy
    05. Request a write
    06. If Fee gets to Idle state it means that a finite number of retries occurred
    07. Check that FlsWrite was called at least another time
    08. The retries expired and the job failed
    09. Unlock Fls, and let it accept jobs
    10. Request the write one more time (just like NvM would do)
    11. This time the write will be performed
    12. The retries have not expired, and the job passes
    13. Request a write
    14. Check that a write job starts with block info
    15. Finish the block info write
    16. Simulate a Fls refusal while Fls is busy
    17. If Fee gets to Idle state it means that a finite number of retries occurred
    18. Check that FlsWrite was called at least another time
    19. The retries expired and the job failed
    20. Request the write one more time (just like NvM would do)
    21. Finish the block info write
    22. Simulate a Fls refusal while Fls is busy
    23. Unlock Fls, and let it accept jobs
    24. This block is written in 2 steps because its size is not multiple of VP
    25. Finish the first data write step
    26. Simulate a Fls refusal while Fls is busy
    27. Unlock Fls, and let it accept jobs
    28. This time the write will be performed
    29. The retries have not expired, and the job passes
    30. Request a write
    31. Finish the block info write
    32. Finish the block data write
    33. Simulate a Fls refusal while Fls is busy
    34. If Fee gets to Idle state it means that a finite number of retries occurred
    35. Check that FlsWrite was called at least another time
    36. The retries expired and the job failed
    37. Request the write one more time (just like NvM would do)
    38. Finish the block info write
    39. Finish the block data write
    40. Simulate a Fls refusal while Fls is busy
    41. Unlock Fls, and let it accept jobs
    42. This time the write will be performed
    43. The retries have not expired, and the job passes
    44. Check for flash errors
    45. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>913</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal.Failed</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>914</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal.Failed.Det</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>915</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Job</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>916</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInfoValidity.WrittenMarker</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>820</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.WriteBlockInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>863</internalId></provcov>
        <provcov>
          <linksto>Fee.WriteMultipleOfVP</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>223</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1064</internalId></specobject>
    <specobject>
      <id>TS_Fee_ReadRefusedRetries</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_FailureHandling_Internal/source/application/Tests.c</sourcefile>
      <sourceline>956</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests Fee behaviour in case Fls refusals and retries during user reads.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write a block
    05. Simulate a Fls refusal while Fls is busy
    06. Request a read
    07. If Fee gets to Idle state it means that a finite number of retries occurred
    08. Check that FlsRead was called at least another time
    09. The retries expired and the job failed
    10. Unlock Fls, and let it accept jobs
    11. Request the write one more time (just like NvM would do)
    12. This time the read will be performed
    13. The retries have not expired, and the job passes
    14. Check for flash errors
    15. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>913</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal.Failed</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>914</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal.Failed.Det</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>915</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Job</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>916</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1065</internalId></specobject>
    <specobject>
      <id>TS_Fee_InvalidateRefusedRetries</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_FailureHandling_Internal/source/application/Tests.c</sourcefile>
      <sourceline>1115</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests Fee behaviour in case Fls refusals and retries during user invalidations.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write a block
    05. Simulate a Fls refusal while Fls is busy
    06. Request an invalidation
    07. If Fee gets to Idle state it means that a finite number of retries occurred
    08. Check that FlsWrite was called at least another time
    09. The retries expired and the job failed
    10. Unlock Fls, and let it accept jobs
    11. Request the invalidation one more time (just like NvM would do)
    12. This time the write will be performed
    13. The retries have not expired, and the job passes
    14. Check for flash errors
    15. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>913</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal.Failed</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>914</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal.Failed.Det</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>915</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Job</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>916</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1066</internalId></specobject>
    <specobject>
      <id>TS_Fee_EraseImmRefusedRetries</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_FailureHandling_Internal/source/application/Tests.c</sourcefile>
      <sourceline>1257</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests Fee behaviour in case Fls refusals and retries during user erase immediates.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write a block
    05. Simulate a Fls refusal while Fls is busy
    06. Request an invalidation
    07. If Fee gets to Idle state it means that a finite number of retries occurred
    08. Check that FlsWrite was called at least another time
    09. The retries expired and the job failed
    10. Unlock Fls, and let it accept jobs
    11. Request the invalidation one more time (just like NvM would do)
    12. This time the write will be performed
    13. The retries have not expired, and the job passes
    14. Check for flash errors
    15. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>913</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal.Failed</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>914</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal.Failed.Det</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>915</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Job</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>916</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1067</internalId></specobject>
    <specobject>
      <id>TS_Fee_WriteFail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_FailureHandling_Internal/source/application/Tests.c</sourcefile>
      <sourceline>1398</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests Fee behaviour in case Fls fails during user writes.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Request a write
    05. Simulate a Fls failure
    06. Check that the job fails
    07. Unlock Fls, and let it accept jobs
    08. Request the invalidation one more time (just like NvM would do)
    09. The job shall be performed successfully
    10. Request a write
    11. Finish the block info write
    12. Start writing data
    13. Simulate a Fls failure
    14. Check that the job fails
    15. Unlock Fls, and let it accept jobs
    16. Request the invalidation one more time (just like NvM would do)
    17. Check that the job is processed successfully
    18. Request a write
    19. Start writing written marker
    20. Simulate a Fls failure
    21. Check that the job fails
    22. Unlock Fls, and let it accept jobs
    23. Request the invalidation one more time (just like NvM would do)
    24. Check that the job is processed successfully
    25. Check for flash errors
    26. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Job</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>916</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInfoValidity.WrittenMarker</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>820</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInfoValidity.WrittenMarkerValidity</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>821</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.WrittenMarker</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>864</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1068</internalId></specobject>
    <specobject>
      <id>TS_Fee_ReadFail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_FailureHandling_Internal/source/application/Tests.c</sourcefile>
      <sourceline>1579</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests Fee behaviour in case Fls fails during user reads.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write a block
    05. Check that the job is processed sucessfully
    06. Request a read
    07. Simulate a Fls failure
    08. Check that the job fails
    09. Unlock Fls, and let it accept jobs
    10. Request the invalidation one more time (just like NvM would do)
    11. Check that the job is processed successfully
    12. Check for flash errors
    13. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Job</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>916</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1069</internalId></specobject>
    <specobject>
      <id>TS_Fee_InvalidateFail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_FailureHandling_Internal/source/application/Tests.c</sourcefile>
      <sourceline>1689</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    Tests Fee behaviour in case Fls fails during user invalidations.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write a block
    05. Check that the job is processed successfully
    06. Request an invalidation
    07. Simulate a Fls failure
    08. Check that the job fails
    09. Unlock Fls, and let it accept jobs
    10. Request the invalidation one more time (just like NvM would do)
    11. Check that the job is processed successfully
    12. Check for flash errors
    13. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.StoreReqFailure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>917</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Job</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>916</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1070</internalId></specobject>
    <specobject>
      <id>TS_Fee_EraseImmediateFail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_FailureHandling_Internal/source/application/Tests.c</sourcefile>
      <sourceline>1800</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests Fee behaviour in case Fls fails during user erase immediates.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write an immediate block
    05. Check that the job is processed successfully
    06. Request an erase immediate
    07. Simulate a Fls failure
    08. Check that the job fails
    09. Unlock Fls, and let it accept jobs
    10. Request the invalidation one more time (just like NvM would do)
    11. The job shall pass
    12. Check for flash errors
    13. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.StoreReqFailure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>917</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Job</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>916</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1071</internalId></specobject>
    <specobject>
      <id>TS_Fee_DataInfoMarginFail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_FailureHandling_Internal/source/application/Tests.c</sourcefile>
      <sourceline>1911</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    Tests Fee behaviour in case Fls fails the write of the forth consecutive block info.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write some blocks
    05. Simulate a Fls refusal while Fls is not busy
    06. Request a write
    07. In this case the job is considered just like it failed
    08. Unlock Fls, and let it accept jobs
    09. Request a write
    10. Simulate a Fls failure
    11. Check that the job fails
    12. Request a write
    13. Simulate a Fls failure
    14. Check that the job fails
    15. Request an invalidation
    16. Simulate a Fls failure
    17. Check that the job fails
    18. Request an erase immediate
    19. Simulate a Fls failure
    20. Check that the job fails
    21. Any write job shall change the Active section
    22. The job shall pass
    23. Check that the active section is changed
    24. Check for flash errors
    25. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.StoreReqFailure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>917</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Job</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>916</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.BlockInfoMargin</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>918</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1072</internalId></specobject>
    <specobject>
      <id>TS_Fee_UserBufferUnaligned</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_FailureHandling_Internal/source/application/Tests.c</sourcefile>
      <sourceline>2094</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests Fee behaviour in the user source/destination address is unaligned to 32b.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Check that Fls stub verifies the buffer alignment for read and write jobs
    04. Perform Startup1
    05. Request a write from unaligned RAM address
    06. Check that the write job is finished with success
    07. Clear the buffer
    08. Read the block to unaligned RAM address
    09. Check that the read job is finished with success
    10. Check that the content is correct
    11. Check for flash errors
    12. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeUseBufferForJobs.Config</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>219</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1073</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_Fee_Switch_Refusals</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_FailureHandling_SS/source/application/Tests.c</sourcefile>
      <sourceline>58</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests that if Fls refuse read and write jobs during switch blocks will still end up being switched.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Read the blocks and check their consistency
    08. Fill one section at a time by writing a different block, until Fee enters switch.
    09. Simulate a Fls refusal while Fls is not busy
    10. Unlock Fls, and let it accept jobs
    11. Finish the block info write
    12. Simulate a Fls refusal while Fls is not busy
    13. Unlock Fls, and let it accept jobs
    14. Finish the block info write
    15. Simulate a Fls refusal while Fls is not busy
    16. Unlock Fls, and let it accept jobs
    17. Check that the block info is written again because the read was refused
    18. Finish the read step this time
    19. Simulate a Fls refusal while Fls is not busy
    20. Unlock Fls, and let it accept jobs
    21. Data write was refused. Therefore start all over again with the current block switching
        Finish the read step
    22. Finish the copy data step this time
    23. Simulate a Fls refusal while Fls is not busy
    24. Unlock Fls, and let it accept jobs
    25. Data write was refused. Therefore start all over again with the current block switching.
        Finish the read step
    26. Finish the copy data step
    27. Finish the written marker step this time
    28. Perform the switch (&gt;2 sections) / Just stay IDLE (2 sections)
    29. Erase all the sections except the current Active section.
    30. Read the blocks and validate them once more.
    31. Check for flash errors
    32. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>913</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal.Failed</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>914</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal.Failed.Det</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>915</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.SectionSwitch.WriteBlockInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>930</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.SectionSwitch.BlockDataWrite</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>931</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.SectionSwitch.BlockWrittenMarkerWrite</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>932</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.SectionSwitch.BlockDataRead</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>933</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1074</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_Failures</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_FailureHandling_SS/source/application/Tests.c</sourcefile>
      <sourceline>361</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests that if Fls fails read and write jobs during switch blocks will still end up being switched.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Read the blocks and check their consistency
    08. Fill one section at a time by writing a different block, until Fee enters switch.
    09. Go to Idle
    10. Check that the next step is to start switching the block all over again
    11. Go to Idle
    12. Check that the next step is to start switching the block all over again
    13. Reach the switch read phase for the same block
    14. Go to Idle
    15. Perform a retry for switch read
    16. Check that the read retry happened indeed
    17. The retry fails
    18. Go to Idle
    19. Check that the next step is to start switching the block all over again
    20. Go to copy data step
    21. Go to Idle
    22. Check that the next step is to start switching the block all over again
    23. Go to Idle
    24. Check that the next step is to start switching the block all over again
    25. Reach the switch read phase for the same block
    26. Go to copy data step
    27. Go to Idle
    28. Check that the next step is to start switching the block all over again
    29. Simulate a Fls failure 4 times and check that the active section must be changed at next operation
    30. Let the block be copy successfully
    31. Check that this copy block info changed the section
    32. Perform the switch (&gt;2 sections) / Just stay IDLE (2 sections)
    33. Erase all the sections except the current Active section.
    34. Read the blocks and validate them once more.
    35. Check Dem reports for failures
    36. Check for flash errors
    37. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.SectionSwitch.WriteBlockInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>930</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.SectionSwitch.BlockDataWrite</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>931</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.SectionSwitch.BlockWrittenMarkerWrite</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>932</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.SectionSwitch.BlockDataRead</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>933</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.SectionSwitch.BlockInfoMargin</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>934</internalId></provcov>
        <provcov>
          <linksto>Fee.FailureHandling.Behaviour.ProductionError.FEE_E_FLASH_ACCESSIBLE</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>261</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1075</internalId></specobject>
    <specobject>
      <id>TS_Fee_Section_Refusals_FlsError</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_FailureHandling_SS/source/application/Tests.c</sourcefile>
      <sourceline>697</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
  The purpose is to simulate flash driver error being reported in various phases of the Fee sections operations
&lt;para&gt;
This test can be run on &gt;=3.. sections.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block, until Fee enters switch.
    08. Only one block has to be switched. Let it be switched.
    09. The next switch step is to mark the oldest section as erasable.
        Simulate flash write error
    10. The marking for erase will be refused
    11. Check that FEE_E_DATA_RECOVERED has been reported as PASSED
    12. Simulate flash write error
    13. Check that FEE_E_DATA_RECOVERED has been reported as PASSED
    14. Simulate flash write error
    15. Check that FEE_E_FLASH_ACCESSIBLE_DEM_EVENT_ID has been reported as DEM_EVENT_STATUS_FAILED by Fee_FlsJobFailed()
    16. Simulate flash write error
    17. Check that FEE_E_FLASH_ACCESSIBLE_DEM_EVENT_ID has been reported as DEM_EVENT_STATUS_FAILED by Fee_FlsJobFailed()
    18. Simulate flash write error
    19. Check that FEE_E_FLASH_ACCESSIBLE_DEM_EVENT_ID has been reported as DEM_EVENT_STATUS_FAILED by Fee_FlsJobFailed().
        Test is also run in P0, so below check makes sense
    20. Simulate flash write error
    21. Check that FEE_E_FLASH_ACCESSIBLE_DEM_EVENT_ID has been reported as DEM_EVENT_STATUS_FAILED by Fee_FlsJobFailed()
    22. Simulate flash write error
    23. Check that FEE_E_FLASH_ACCESSIBLE_DEM_EVENT_ID has been reported as DEM_EVENT_STATUS_FAILED by Fee_FlsJobFailed().
        Test is also run in P0, so below check makes sense
    24. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>913</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal.Failed</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>914</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal.Failed.Det</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>915</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.WritingSectionHeader.Failure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>924</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.WritingSectionFooter.Failure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>925</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.MarkingHeaderActive.Failure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>926</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.MarkingFooterActive.Failure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>927</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.MarkingHeaderErasable.Failure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>928</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.MarkingFooterErasable.Failure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>929</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.Failure.SectionErase.LowPrio</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>936</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1076</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_RetentionBlockInfo</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_FailureHandling_SS/source/application/Tests.c</sourcefile>
      <sourceline>924</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests that if Fls fails the writing of the retention dummy block info it retries to write it before
  switching the first block.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
  01. Set the initial test result
  02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
  03. Perform Startup1
  04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
  05. Perform Startup2
  06. Memorize the Active section index and verify that all the other sections are empty.
    (All sections shall be empty now, except the Active section)
  07. Read the blocks and check their consistency
  08. Fill one section at a time by writing a different block, until Fee enters switch.
  09. Simulate RESET
  10. Request a read job so the switch can start
  11. Simulate the failure of the retention dummy block info
  12. Go to Idle
  13. Check that the next step is to start writing the retention dummy block info again
  14. Check that the next step is to start switching the block all over again.
   (only one block needed to be switched)
  15. Perform the switch (&gt;2 sections) / Just stay IDLE (2 sections)
  16. Erase all the sections except the current Active section.
  17. Check Dem reports for failures
  18. Simulate RESET
  19. Read the blocks and validate them once more.
  20. Check for flash errors
  21. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.Retention</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>964</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1077</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_Fee_Section_Refusals_S2</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_FailureHandling_Sections/source/application/Tests.c</sourcefile>
      <sourceline>58</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests that Startup2 recovers correctly if Fls refusals occur.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Startup2 shall start immediately after Startup1 in case of blank memory.
        Let Startup2 validate the first section.
    04. When writing section footer is finished, the next step is to mark as active.
    05. Simulate a Fls refusal while Fls is not busy
    06. Check that the header marking for active refusal triggers a footer marking for active
    07. Check that the footer marking for active refusal triggers a header marking for erasable
    08. Check that the header marking for erasable refusal triggers a footer marking for erasable
    09. Check that the footer marking for erasable refusal triggers a section erase
    10. Check that the erase refusal triggers a section erase again
    11. Partially release Fls and let it accept only erase jobs but not write jobs.
    12. Finish the section erase.
    13. Check that after successful erase a header write comes
    14. Check that after successful header write, a consistency pattern comes
    15. Check that the header writing refusal triggers a footer writing
    16. Check that after successful footer write, a consistency pattern comes
    17. Check that the footer writing refusal triggers a header marking for erasable
    18. Fully release Fls
    19. Do the refusal cycle back just before the header is marked as active, and it's refused
    20. Block Fls again for footer marking as active
    21. Check that the header is attempted to be marked as active
    22. Fully release Fls
    23. Check that the footer is attempted to be marked as active (because of header marking refusal)
        and it succeeds this time
    24. In case of successful footer marking as active the next step shall not be the erasable marking
    25. Perform Startup2
    26. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    27. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    28. Read the blocks and validate them once more.
    29. Check for flash errors
    30. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>913</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal.Failed</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>914</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal.Failed.Det</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>915</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.WritingSectionHeader.Failure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>924</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.WritingSectionFooter.Failure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>925</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.MarkingHeaderActive.Failure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>926</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.MarkingFooterActive.Failure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>927</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.MarkingHeaderErasable.Failure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>928</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.MarkingFooterErasable.Failure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>929</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.Failure.SectionErase.HighPrio</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>935</internalId></provcov>
        <provcov>
          <linksto>Fee.FailureHandling.Behaviour.Startup1.ProductionError</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>263</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1078</internalId></specobject>
    <specobject>
      <id>TS_Fee_Section_Refusals_Swap</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_FailureHandling_Sections/source/application/Tests.c</sourcefile>
      <sourceline>334</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests that if during section change refusals occur Fee recovers correctly.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform initialization, (Startup1 and Startup2)
    04. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    05. The next request will trigger a section change, starting by marking the next section as active.
        Simulate a Fls refusal while Fls is not busy
    06. Check that the header marking for active refusal triggers a footer marking for active
    07. Check that the footer marking for active refusal triggers a header marking for erasable
    08. Check that the header marking for erasable refusal triggers a footer marking for erasable
    09. Check that the footer marking for erasable refusal triggers a section erase
    10. Check that the erase refusal triggers a section erase again
    11. Partially release Fls and let it accept only erase jobs but not write jobs.
    12. Finish the section erase.
    13. Check that after successful erase a header write comes
    14. Check that the header writing refusal triggers a footer writing
    15. Check that the footer writing refusal triggers a header marking for erasable
    16. Fully release Fls
    17. Finish the write that changed the section.
    18. Monitor the section index.
    19. Read the blocks and validate them once more.
    20. Erase all the sections except the current Active section.
    21. Check for flash errors
    22. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>913</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal.Failed</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>914</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal.Failed.Det</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>915</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.WritingSectionHeader.Failure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>924</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.WritingSectionFooter.Failure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>925</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.MarkingHeaderActive.Failure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>926</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.MarkingFooterActive.Failure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>927</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.MarkingHeaderErasable.Failure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>928</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.MarkingFooterErasable.Failure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>929</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.Failure.SectionErase.HighPrio</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>935</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1079</internalId></specobject>
    <specobject>
      <id>TS_Fee_Section_Refusals_SS</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_FailureHandling_Sections/source/application/Tests.c</sourcefile>
      <sourceline>546</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests that Fee recovers correctly from Fls refusals during section management operations in the context of section switch.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block, until Fee enters switch.
    08. The next request will trigger a section change, starting by marking the next section as active.
        Simulate a Fls refusal while Fls is not busy
    09. Check that the header marking for active refusal triggers a footer marking for active
    10. Check that the footer marking for active refusal triggers a header marking for erasable
    11. Check that the header marking for erasable refusal triggers a footer marking for erasable
    12. Check that the footer marking for erasable refusal triggers a section erase
    13. Check that the erase refusal triggers a section erase again
    14. Partially release Fls and let it accept only erase jobs but not write jobs.
    15. Finish the section erase.
    16. Check that after successful erase a header write comes
    17. Check that after successful header write, a consistency pattern comes
    18. Check that the header writing refusal triggers a footer writing
    19. Check that after successful footer write, a consistency pattern comes
    20. Check that the footer writing refusal triggers a header marking for erasable
    21. Fully release Fls
    22. Perform the switch (&gt;2 sections) / Just stay IDLE (2 sections)
    23. Get over the delay timer
    24. Erase all the sections except the current Active section.
    25. Read the blocks and validate them once more.
    26. Check for flash errors
    27. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>913</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal.Failed</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>914</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal.Failed.Det</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>915</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.WritingSectionHeader.Failure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>924</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.WritingSectionFooter.Failure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>925</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.MarkingHeaderActive.Failure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>926</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.MarkingFooterActive.Failure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>927</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.MarkingHeaderErasable.Failure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>928</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.MarkingFooterErasable.Failure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>929</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.Failure.SectionErase.HighPrio</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>935</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1080</internalId></specobject>
    <specobject>
      <id>TS_Fee_Section_Refusals_SS_OldS</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_FailureHandling_Sections/source/application/Tests.c</sourcefile>
      <sourceline>812</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests that Fee recovers correctly from Fls refusals during section management operations in the context of section switch.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block, until Fee enters switch.
    08. Only one block has to be switched. Let it be switched.
    09. The next switch step is to mark the oldest section as erasable.
        Simulate a Fls refusal while Fls is not busy
    10. The marking for erase will be refused
    11. Check that the header marking for erasable refusal triggers a footer marking for erasable
    12. Check that the footer marking for erasable refusal triggers a section erase
    13. Check that the erase refusal triggers a section erase again
    14. Partially release Fls and let it accept only erase jobs but not write jobs.
    15. Finish the section erase.
    16. Check that after successful erase a header write comes
    17. Check that the header writing refusal triggers a footer writing
    18. Check that the footer writing refusal triggers a header marking for erasable
    19. Fully release Fls
    20. Request a write that shall be done after the marking for erase.
    21. Check that the state is still FEE_MARK_FOOTER_ERASABLE
    22. Get over the delay timer
    23. Check that after the job is finished Fee erases the oldest section.
    24. Finish the switch (erase and revalidation)
    25. Erase all the sections except the current Active section.
    26. Read the blocks and validate them once more.
    27. Check for flash errors
    28. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>913</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal.Failed</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>914</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal.Failed.Det</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>915</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.WritingSectionHeader.Failure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>924</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.WritingSectionFooter.Failure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>925</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.MarkingHeaderActive.Failure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>926</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.MarkingFooterActive.Failure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>927</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.MarkingHeaderErasable.Failure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>928</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.MarkingFooterErasable.Failure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>929</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.Failure.SectionErase.LowPrio</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>936</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1081</internalId></specobject>
    <specobject>
      <id>TS_Fee_Section_Refusals_HP_SS</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_FailureHandling_Sections/source/application/Tests.c</sourcefile>
      <sourceline>1059</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests that Fee recovers correctly from Fls refusals during section management operations in the context of high priority section switch.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block, until Fee enters switch.
    08. Only one block has to be switched. Let it be switched.
    09. The next switch step is to mark the oldest section as erasable.
        Simulate a Fls refusal while Fls is not busy
    10. The marking for erase will be refused
    11. Check that the header marking for erasable refusal triggers a footer marking for erasable
    12. Check that the footer marking for erasable refusal allows the job to be done.(it will be refused anyway)
    13. Get over the delay timer
    14. Check that after the job refusal Fee remembers to erase the oldest section
    15. Check that the erase refusal triggers a section erase again
    16. Partially release Fls and let it accept only erase jobs but not write jobs.
    17. Finish the section erase.
    18. Check that after successful erase a header write comes
    19. Check that the header writing refusal triggers a footer writing
    20. Check that the footer writing refusal triggers a header marking for erasable
    21. Fully release Fls
    22. Request a write that shall be done after the marking for erase.
    23. Check that the state is still FEE_MARK_FOOTER_ERASABLE
    24. Get over the delay timer
    25. Check that after the job is finished Fee erases the oldest section.
    26. Finish the switch (erase and revalidation)
    27. Erase all the sections except the current Active section.
    28. Read the blocks and validate them once more.
    29. Check for flash errors
    30. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>913</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal.Failed</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>914</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal.Failed.Det</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>915</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.WritingSectionHeader.Failure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>924</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.WritingSectionFooter.Failure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>925</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.MarkingHeaderActive.Failure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>926</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.MarkingFooterActive.Failure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>927</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.MarkingHeaderErasable.Failure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>928</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.MarkingFooterErasable.Failure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>929</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.Failure.SectionErase.LowPrio</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>936</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1082</internalId></specobject>
    <specobject>
      <id>TS_Fee_Section_Refusals_HP_Reset</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_FailureHandling_Sections/source/application/Tests.c</sourcefile>
      <sourceline>1319</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests that Fee recovers correctly from Fls refusals during section management operations in the context of high priority section switch.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block, until Fee enters switch.
    08. Only one block has to be switched. Let it be switched.
    09. Simulate RESET
    10. The next switch step is to mark the oldest section as erasable.
        Simulate a Fls refusal while Fls is not busy
    11. The marking for erase will be refused
    12. Check that the header marking for erasable refusal triggers a footer marking for erasable
    13. Check that the footer marking for erasable refusal allows the job to be done.
        Release Fls write
    14. Fill the section
    15. Get over the delay timer
    16. Request a write that triggers highest internal priority as there is no more space.
    17. Block Fls write again.
    18. Check that after the job refusal Fee remembers to erase the oldest section
    19. Check that the erase refusal triggers a section erase again
    20. Partially release Fls and let it accept only erase jobs but not write jobs.
    21. Finish the section erase.
    22. Check that after successful erase a header write comes
    23. Check that after successful header write, a consistency pattern comes
    24. Check that the header writing refusal triggers a footer writing
    25. Check that after successful footer write, a consistency pattern comes
    26. Check that the footer writing refusal triggers a header marking for erasable
    27. Check that the header marking refusal triggers a footer marking for erasable
    28. Fully release Fls
    29. Erase and revalidation of the section is done.
    30. Block Fls write again.
    31. The section will be attempted to be marked as active but it will be refused.
    32. Check that the header marking refusal triggers a footer marking as active
    33. Fully release Fls
    34. Finish the write after section revalidation.
    35. Get over the delay timer
    36. Finish the switch (erase and revalidation)
    37. Simulate RESET
    38. Perform startup.
    39. Read the blocks and validate them once more.
    40. Check for flash errors
    41. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>913</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal.Failed</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>914</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal.Failed.Det</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>915</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.WritingSectionHeader.Failure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>924</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.WritingSectionFooter.Failure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>925</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.MarkingHeaderActive.Failure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>926</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.MarkingFooterActive.Failure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>927</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.MarkingHeaderErasable.Failure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>928</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.MarkingFooterErasable.Failure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>929</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.Failure.SectionErase.HighPrio</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>935</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1083</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_ChangingActive_s</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_FailureHandling_Sections/source/application/Tests.c</sourcefile>
      <sourceline>1662</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch changes the section if there is no more space in the current one.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Check if the section is empty (BlackBox)
    08. Save the current Active section
    09. Fill one section at a time by writing a different block, until Fee enters switch.
    10. Update the oldest section index
    11. Get over the delay timer(&gt;2 sections)
    12. Finish the switch.
    13. Only the first 3 blocks are switched in the current section and the other 3 will be switched in the next section
    14. Erase all the sections except the current Active section.
    15. Read the blocks that are supposed to be switched in the last section.
        Therefore Switch must have changed the active section since there was no more space for switching all the blocks
    16. Check for flash errors
    17. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.Behaviour.ChangingActiveSection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>904</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1084</internalId></specobject>
    <specobject>
      <id>TS_Fee_Section_Refusals_HeaderWriteError</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_FailureHandling_Sections/source/application/Tests.c</sourcefile>
      <sourceline>1839</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests that in case of active merking failure the footer will be marked as active.
&lt;para&gt;
This test can be run on &gt;=4.. sections.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block, until Fee enters switch.
    08. The next request will trigger a section change, starting by marking the next section as active.
        Simulate a Fls refusal while Fls is not busy
    09. Simulate flash write error
    10. Check that the header marking for active refusal triggers a footer marking for active
    11. Finish the section erase.
    12. Fully release Fls
    13. Perform the switch (&gt;2 sections) / Just stay IDLE (2 sections)
    14. Get over the delay timer
    15. Erase all the sections except the current Active section.
    16. Read the blocks and validate them once more.
    17. Check for flash errors
    18. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>913</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal.Failed</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>914</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.FlashRefusal.Failed.Det</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>915</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.WritingSectionHeader.Failure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>924</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.MarkingHeaderActive.Failure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>926</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1085</internalId></specobject>
    <specobject>
      <id>TS_Fee_Section_PostponeErase_LowPrio</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_FailureHandling_Sections/source/application/Tests.c</sourcefile>
      <sourceline>2014</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests that if section erase fails during low internal priority, the erase will be restarted after performing user jobs.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Prepare a flash that starts to perform a regular priority section switch
    03. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    04. Cause a normal priority section erase
    05. Call the main functions until erase section is reached
    06. Request read block
    07. Simulate a flash error
    08. Expected result is transition directly to read block as the erase operation has failed
    09. Expected result is Read operation performed correctly
    10. Erase section restarted
    11. Check for flash errors
    12. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.Failure.SectionErase.LowPrio</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>936</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1086</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_Fee_Imm_SectionEraseRS</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Immediate_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>58</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests that Fee interrupts a restart switch erasing in order to write the immediate block in the reserved space.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
  01. Set the initial test result
  02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
  03. Perform Startup1 and the validation of the first section as parto of Startup2
  04. Write a block
  05. Measure the time for writing the regular block
  06. Measure the time for writing an immediate block
  06. Perform writes until the section is changed (Fee spends time also for marking the section)
  07. The job has not finishe
  08. Trigger a Restart Switch with failures
  09. Start the section erasing
  10. Cancel the pending standard job
  11. Request the write of the immediate block
  12. Check that the immediate block is written immediately.
  13. Trigger the write of a standard block
  14. Check that the Restart Swtich's erase is restarted
  15. Finalize the switch
  16. Erase the first section in order to verify that the switch completed
  17. Simulate RESET
  18. Perform Initialization
  19. Check that the switch completed
  20. Check for flash errors
  21. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.ImmediateSpaceReserved.Runtime</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>966</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1087</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_CopyBlocks_i2s</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Immediate_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>272</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch works correctly. 
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Read the blocks and check their consistency
    08. Fill one section at a time by writing a different block, until Fee enters switch.
    09. VP(Fee.Dns.SS.TriggeringTheSwitch.WriteRequest): This write job will have started the switch when the while loop is left.
    10. On 2 sections, by the time when the processing is over, the switch is also over.
    11. Update the oldest section index
    12. Perform the switch (&gt;2 sections) / Just stay IDLE (2 sections)
    13. Erase all the sections except the current Active section.
    14. VP(Fee.Dns.SS.CopyBlocks): Read the blocks and validate them once more.
    15. Check for flash errors
    16. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.CopyBlocks</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>895</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.SS.TriggeringTheSwitch.WriteRequest</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>897</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1088</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_CopyCopiedBlocks_i2s</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Immediate_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>438</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch works correctly and copies not only the written blocks 
  but the already copied ones too. 
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block, until Fee enters switch.
    08. On 2 sections, by the time when the processing is over, the switch is also over.
    09. Perform the switch (&gt;2 sections) / Just stay IDLE (2 sections)
    10. Perform switches in order to make sure that the interesting blocks are switched again.
        (Considering the switch trigger condition, Fee will carry the same block every FEE_NUMBER_OF_SECTIONS / 2 times)
    11. Perform the switch again.
    12. Erase all the sections except the current Active section.
    13. VP(Fee.Dns.SS.CopyBlocks): Read the blocks and validate them once more.
    14. Check for flash errors
    15. Set test case result

Test Input: 
  None.

Test Output: 
  Fee shall mark Section 0 as ACTIVE.

  Section status after start-up:
   - Section 0: Active
   - Section 1: Erased
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.CopyBlocks</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>895</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1089</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_RevalidateOldSection_i2s</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Immediate_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>615</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch works correctly and after the section is copied 
  the section is revalidated.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block, until Fee gets round to the same Active section index.
        By then the section shall be empty and consistent.
    08. Exclusively write/invalidate blocks in the section that was supposed to be revalidated by switch.
    09. Simulate RESET
    10. Perform initialization, (Startup1)
    11. Read the exclusive blocks and validate them.
    12. Check for flash errors
    13. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.RevalidateOldSection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>896</internalId></provcov>
        <provcov>
          <linksto>Fee.ConsistencyPatterns.SectionHeader.Write</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>271</internalId></provcov>
        <provcov>
          <linksto>Fee.ConsistencyPatterns.SectionHeader.Read.Startup</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>270</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1090</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_ImmediatelyAfterInit_i2s</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Immediate_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>761</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch is triggered correctly.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block, until Fee enters switch.
    08. Perform a couple of switch steps.
    09. Simulate RESET
    10. Perform initialization, (Startup1)
    11. VP(Fee.Dsn.Initialization.Startup2.07): Request a job to trigger Startup2 and make sure that Startup2 is triggered and not Switch
    12. Get over the delay timer
    13. Check that Startup2 started.
    14. Finish Startup2. If also the Switch that was interrupted by reset is finished,
        it means that the Switch started directly after Startup2 and there was no need of a triggering job.
    15. Erase all the sections except the current Active section.
    16. VP(Fee.Dns.SS.TriggeringTheSwitch.AfterInit): Check that the switch had finished indeed.
    17. Check for flash errors
    18. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.TriggeringTheSwitch.AfterInit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>900</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup2.07</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>856</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1091</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_HP_ImmediatelyAfterInit_i2s</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Immediate_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>945</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch is triggered correctly even in highest priority. 
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block. Keep writing the block until Fee enters high priority switch.
    08. Perform a couple of switch steps.
    09. Simulate RESET
    10. Request a write for resuming high priority switch
    11. Perform the high priority switch
    12. Erase all the sections except the current Active section.
    13. Check that the switch had finished indeed.
    14. Check for flash errors
    15. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.TriggeringTheSwitch.AfterInit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>900</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1092</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_ReadNoTrigger_i2s</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Immediate_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>1101</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch is never triggered by read job request. 
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block, until Fee is write before entering switch.
    08. Read blocks that haven't been written. They shouldn't be found and they shall not trigger switch
    09. Read blocks that have been written. They should be found and they shall not trigger switch
    10. VP(Fee.SS.TriggeringTheSwitch.ReadRequest): Check that Fee is in idle and the switch has not started
    11. Request a write that should trigger switch
    12. Get over the delay timer
    13. Check that Fee is in idle now
    14. Check for flash errors
    15. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.SS.TriggeringTheSwitch.ReadRequest</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>259</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1093</internalId></specobject>
    <specobject>
      <id>TS_Fee_Imm_SwitchFromRS</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Immediate_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>1246</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests that Fee switches immediate blocks from the reserved space in case they are written later on and the
  Section Switch passed by their indexes.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1 and the validation of the first section as parto of Startup2
    04. Write a block
    05. Measure the time for writing the regular block
    06. Measure the time for writing an immediate block
    07. Erase the immediate block in order not to be switched
    08. Perform writes until the section is changed (Fee spends time also for marking the section)
    09. The job has not finished
    10. Wait for Fee to do some switch steps
    11. Cancel the pending standard job
    12. Request the write of the immediate block.
        It has an index smaller than the blocks that need switching.
    13. Check that the immediate block is written immediately.
    14. Trigger the write of a standard block
    15. Check that the Switch is resumed
    16. Finalize the switch
    17. Simulate RESET
    18. Perform Initialization
    19. Check that the switch did not lost the immediate block written in the reserved space
    20. Check for flash errors
    21. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.ImmediateSpaceReserved.Runtime</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>966</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1094</internalId></specobject>
    <specobject>
      <id>TS_Fee_Imm_RestartSwitchFromRS</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Immediate_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>1450</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests that Fee switches immediate blocks from the reserved space in case they are written later on and the
  Section Switch passed by their indexes during a restarted switch.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1 and the validation of the first section as parto of Startup2
    04. Write a block
    05. Measure the time for writing the regular block
    06. Measure the time for writing an immediate block
    07. Erase the immediate block in order not to be switched
    08. Perform writes until the section is changed (Fee spends time also for marking the section)
    09. The job has not finished
    10. Trigger a Restart Switch with failures
    11. Copy data fail
    12. Wait for Fee to do some switch steps
    13. Cancel the pending standard job
    14. Request the write of the immediate block.
        It has an index smaller than the blocks that need switching.
    15. Check that the immediate block is written immediately.
    16. Trigger the write of a standard block
    17. Check that the Switch is resumed
    18. Finalize the switch
    19. Simulate RESET
    20. Perform Initialization
    21. Check that the switch did not lost the immediate block written in the reserved space
    22. Check for flash errors
    23. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.CopyBlocks</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>895</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.SS.TriggeringTheSwitch.WriteRequest</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>897</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1095</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_Fee_Imm_ChangeSection</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Immediate_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>61</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests that Fee does not reserve space for immediate blocks in any section.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
  01. Set the initial test result
  02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
  03. Perform Startup1 and the validation of the first section as parto of Startup2
  04. Write a block
  05. Measure the time for writing the regular block
  06. Measure the time for writing an immediate block
  07. Perform writes until the section is changed (Fee spends time also for marking the section)
  08. The job has not finished
  09. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
  10. Perform Startup1 and the validation of the first section as parto of Startup2
  11. Write the immediate block
  12. Write the measured number of writings before section is changed
      (+ the 2 writes at the beginning of the measuring scenario)
  13. Request the write of the immediate block
  14. Check that the immediate block is written with the delay of marking the section as active.
      This proves that the immediate block is written in the next section and not in a reserved space.
  15. Check for flash errors
  16. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.ImmediateSpaceReserved.Runtime</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>966</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1096</internalId></specobject>
    <specobject>
      <id>TS_Fee_Imm_SectionEraseS2</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Immediate_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>237</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests that Fee interrupts a startup2 high priority erasing in order to write the immediate block in the reserved space.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
  01. Set the initial test result
  02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
  03. Write a block
  04. Measure the time for writing the regular block
  05. Measure the time for writing an immediate block
  06. Perform writes until the section is changed (Startup2 takes over with highest priority)
  07. The job has not finished
  08. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
  09. Write the immediate block
  10. Write the measured number of writings before section is changed
      (+ the 2 writes at the beginning of the measuring scenario)
  11. Request the write of a standard block in order to trigger section change (HP Startup2)
  12. Wait for Startup2 to trigger section erasing
  13. Cancel the pending standard job
  13. Request the write of the immediate block
  14. Check that the immediate block is written immediately in the reserved space.
  15. Trigger the write of a standard block
  16. Check that the Startup2's erase is restarted
  17. Check for flash errors
  18. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.ImmediateSpaceReserved.Runtime</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>966</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1097</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_Failures_i4s</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Immediate_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>437</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests that if Fls fails read and write jobs during switch blocks will still end up being switched.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Read the blocks and check their consistency
    08. Fill one section at a time by writing a different block, until Fee enters switch.
    09. Go to Idle
    10. Check that the next step is to start switching the block all over again
    11. Go to Idle
    12. Check that the next step is to start switching the block all over again
    13. Reach the switch read phase for the same block
    14. Go to Idle
    15. Perform a retry for switch read
    16. Check that the read retry happened indeed
    17. The retry fails
    18. Go to Idle
    19. Check that the next step is to start switching the block all over again
    20. Go to copy data step
    21. Go to Idle
    22. Check that the next step is to start switching the block all over again
    23. Go to Idle
    24. Check that the next step is to start switching the block all over again
    25. Reach the switch read phase for the same block
    26. Go to copy data step
    27. Go to Idle
    28. Check that the next step is to start switching the block all over again
    29. Simulate a Fls failure 4 times and check that the active section must be changed at next operation
    30. Let the block be copy successfully
    31. Check that this copy block info changed the section
    32. Perform the switch (&gt;2 sections) / Just stay IDLE (2 sections)
    33. Erase all the sections except the current Active section.
    34. Read the blocks and validate them once more.
    35. Check Dem reports for failures
    36. Check for flash errors
    37. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.SectionSwitch.WriteBlockInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>930</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.SectionSwitch.BlockDataWrite</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>931</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.SectionSwitch.BlockWrittenMarkerWrite</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>932</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.SectionSwitch.BlockDataRead</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>933</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.SectionSwitch.BlockInfoMargin</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>934</internalId></provcov>
        <provcov>
          <linksto>Fee.FailureHandling.Behaviour.ProductionError.FEE_E_FLASH_ACCESSIBLE</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>261</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1098</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_CopyBlocks_i4s</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Immediate_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>775</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch works correctly. 
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Read the blocks and check their consistency
    08. Fill one section at a time by writing a different block, until Fee enters switch.
    09. Update the oldest section index
    10. Perform the switch (&gt;2 sections) / Just stay IDLE (2 sections)
    11. Erase all the sections except the current Active section.
    12. Read the blocks and validate them once more.
    13. Check for flash errors
    14. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.CopyBlocks</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>895</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.SS.TriggeringTheSwitch.WriteRequest</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>897</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1099</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_CopyCopiedBlocks_i4s</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Immediate_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>937</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch works correctly and copies not only the written blocks 
but the already copied ones too. 
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block, until Fee enters switch.
    08. Perform the switch (&gt;2 sections) / Just stay IDLE (2 sections)
    09. Perform switches in order to make sure that the interesting blocks are switched again.
        Considering the switch trigger condition, Fee will carry the same block every FEE_NUMBER_OF_SECTIONS / 2 times
    10. Erase all the sections except the current Active section.
    11. Read the blocks and validate them once more.
    12. Check for flash errors
    13. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.CopyBlocks</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>895</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1100</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_OnlyOldSection_i4s</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Immediate_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>1107</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch works correctly and switches only one section at a time. 
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform initialization, (Startup1 and Startup2)
    04. Now all the sections shall be valid and empty. Get the empty space value in a section.
    05. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill the Active section and go to the second section
    08. Monitor the section index.
    09. Get over the delay timer
    10. Exclusively write a block in the second section
    11. Fill one section at a time by writing a different block, until Fee enters switch.
    12. Perform the switch.
    13. Erase all the sections except the current Active section.
    14. Check that the block in the second section were not copied at first switch
    15. Check for flash errors
    16. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.CopyBlocks</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>895</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1101</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_RevalidateOldSection_i4s</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Immediate_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>1289</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch works correctly and after the section is copied 
the section is revalidated.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block, until Fee gets round to the same Active section index
        By then the section shall be empty and consistent.
    08. Exclusively write/invalidate blocks in the section that was supposed to be revalidated by switch.
    09. Simulate RESET
    10. Perform initialization, (Startup1)
    11. Read the exclusive blocks and validate them.
    12. Check for flash errors
    13. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.RevalidateOldSection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>896</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1102</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_ImmediatelyAfterInit_i4s</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Immediate_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>1432</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch is triggered correctly.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block, until Fee enters switch.
    08. Perform a couple of switch steps.
    09. Simulate RESET
    10. Perform initialization, (Startup1)
    11. Request a job to trigger Startup2 and make sure that Startup2 is triggered and not Switch
    12. Get over the delay timer
    13. Check that Startup2 started.
    14. Finish Startup2. If also the Switch that was interrupted by reset is finished,
        it means that the Switch started directly after Startup2 and there was no need of a triggering job.
    15. Erase all the sections except the current Active section.
    16. Check that the switch had finished indeed.
    17. Check for flash errors
    18. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.TriggeringTheSwitch.AfterInit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>900</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup2.07</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>856</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1103</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_Timer_i4s</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Immediate_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>1616</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the timer is respected in case of interruptions durring switch. 
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block, until Fee enters switch.
    08. Perform a couple of switch steps.
    09. Request a write
    10. Check that Fee is temporarily idle
    11. Get over the delay timer
    12. Check that the switch is resumed
    13. Perform a couple of switch steps.
    14. Request a read
    15. Check that Fee is temporarily idle
    16. Get over the delay timer
    17. Check that the switch is resumed
    18. Perform a couple of switch steps.
    19. Request a invalidation
    20. Check that Fee is temporarily idle
    21. Get over the delay timer
    22. Check that the switch is resumed
    23. Perform a couple of switch steps.
    24. Request a erase imm
    25. Check that Fee is temporarily idle
    26. Get over the delay timer
    27. Check that the switch is resumed
    28. Perform switch.
    29. Check that the switch had finished indeed.
    30. Check for flash errors
    31. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Timer.UserJobRequests</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>859</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Timer.InternalOperation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>861</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1104</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_WriteResumed_i4s</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Immediate_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>1867</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch resumes the interrupted write operation.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block, until Fee enters switch.
    08. Take the current free space in the active section after only one block copied.
    09. Until Switch performs read data
    10. Until Switch performs write data
    11. Finish the write of the first buffer. (this is a case of a big block, but it should work for a small block too,
        since the block switching is not finished until the written marker is completed)
    12. Request a write that interrupts the switch right after a switch data write has been done.
    13. Finish the switch.
    14. Check that switch resumed the data writing of the block that was being switched instead of restarting it.
        Now that the switch is over the occupied size in active section shall be
        by the switched blocks and the block that interrupted the switch, taken only once.
    15. Check that the switch had finished indeed.
    16. Check for flash errors
    17. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.Behaviour.SSResume.BlockSwitching.Writing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>901</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1105</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_JobInterrupts_1_i4s</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Immediate_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>2038</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch behaves correctly if interrupted by user job requests. 
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block, until Fee enters switch.
    08. Take the current free space in the active section after only one block copied.
    09. The block info of the invalidated block is copied here
    10. Request a write that interrupts the switch right after a switch block info has been done.
    11. The second block switch starts by copying block info
    12. Request a write that interrupts the switch right after a switch block info has been done.
    13. Until Switch performs read data
    14. Fee has requested a read data (first buffer) for the block that is being switched
    15. Request a write that interrupts the switch right after a switch read data has been done.
    16. Until Switch performs write data
    17. Finish the write of the first buffer. (this is a case of a big block, but it should work for a small block too,
        since the block switching is not finished until the written marker is completed)
    18. Request a write that interrupts the switch right after a switch data write has been done.
    19. Get over the delay timer
    20. Finish the switch.
    21. Check that switch resumed the data writing of the block that was being switched instead of restarting it.
        Now that the switch is over the occupied size in active section shall be
        by the switched blocks and the block that interrupted the switch, taken only once.
    22. Check that the switch had finished indeed.
    23. Check for flash errors
    24. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.Behaviour.SSResume.BlockSwitching.Writing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>901</internalId></provcov>
        <provcov>
          <linksto>Fee.SS.UserJobRequests</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>260</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1106</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_JobInterrupts_2_i4s</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Immediate_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>2273</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch behaves correctly if interrupted by user job requests. 
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block, until Fee enters switch.
    08. Take the current free space in the active section after only one block copied.
    09. First step in switching a block is done here: copying block info
    10. Request a write that interrupts the switch right during a switch block info.
    11. Finish the block info copy job at Fls level.
    12. Process the user requested job
    13. Run until Switch starts to perform read data
    14. Check that Fee did not transmit the user interruptions to Fls during block info switch
    15. Request a write that interrupts the switch right during a switch data reading.
    16. Check that Fee did canceled the switch reading by transmitting the interruption to Fls
    17. Now, instead of continuing the switch reading, Fee sent a new job to Fls (the user invalidation)
    18. Process the user requested job
    19. Fee restarts the switch reading
    20. Run until Switch starts to perform write data
    21. Request a write that interrupts the switch right during a switch data write.
    22. Finish the write of the first buffer. (this is a case of a big block, but it should work for a small block too,
        since the block switching is not finished until the written marker is completed)
    23. Process the user requested job
    24. Get over the delay timer
    25. Finish the switch.
    26. Check that switch resumed the data writing of the block that was being switched instead of restarting it.
        Now that the switch is over the occupied size in active section shall be
        by the switched blocks and the block that interrupted the switch, taken only once.
    27. Check that the switch had finished indeed.
    28. Check if Fee transmit the user interruptions to Fls others than for switch reading.
    29. Check for flash errors
    30. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.Behaviour.SSResume.BlockSwitching.Writing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>901</internalId></provcov>
        <provcov>
          <linksto>Fee.SS.UserJobRequests</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>260</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1107</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_ReadRestarted_i4s</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Immediate_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>2528</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch restarts the interrupted read operation. 
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block, until Fee enters switch.
    08. Until Switch performs read data
    09. Request a write that interrupts the switch right in the moment of reading data to be switch.
    10. Check that Fee is in idle now
    11. Resume the switch
    12. Check that Switch restarts the reading and not writing whatever is in internal buffer
    13. Finish the switch.
    14. Check that the switch had finished indeed.
    15. Check for flash errors
    16. Set test case result

Test Input: 
  None.

Test Output: 
 None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.Behaviour.SSResume.BlockSwitching.Reading</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>902</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1108</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_ReadNoTrigger_i4s</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Immediate_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>2689</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch is never triggered by read job request. 
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block, until Fee is write before entering switch.
    08. Read blocks that haven't been written. They shouldn't be found and they shall not trigger switch
    09. Read blocks that have been written. They should be found and they shall not trigger switch
    10. Check that Fee is in idle and the switch has not started
    11. Request a write that should trigger switch
    12. Get over the delay timer
    13. Check that Fee is in idle now
    14. Check for flash errors
    15. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.SS.TriggeringTheSwitch.ReadRequest</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>259</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1109</internalId></specobject>
    <specobject>
      <id>TS_Fee_DataInfoMarginFail_i4s</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Immediate_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>2838</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    Tests Fee behaviour in case Fls fails the write of the forth consecutive block info.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write some blocks
    05. Simulate a Fls refusal while Fls is not busy
    06. Request a write
    07. In this case the job is considered just like it failed
    08. Unlock Fls, and let it accept jobs
    09. Request a write
    10. Simulate a Fls failure
    11. Check that the job fails
    12. Request a write
    13. Simulate a Fls failure
    14. Check that the job fails
    15. Request an invalidation
    16. Simulate a Fls failure
    17. Check that the job fails
    18. Request an erase immediate
    19. Simulate a Fls failure
    20. Check that the job fails
    21. Any write job shall change the Active section
    22. The job shall pass
    23. Check that the active section is changed
    24. Check for flash errors
    25. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.StoreReqFailure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>917</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Job</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>916</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.BlockInfoMargin</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>918</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1110</internalId></specobject>
    <specobject>
      <id>Ts_Fee_Cancel_Behavior_JobOngoing_Normal_i4s</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Immediate_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>3020</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: Test the call of Fee_Cancel when Fee has a job ongoing and in NORMAL mode.
Test Description: 
    This test verifies the Fee behavior when Fee_Cancel is called while Fee has an
    upper layer request PENDING and started, when in NORMAL mode.
  
Test Object: Fee_Cancel()
Test Precondition: 
    - The flash must be erased
  
Test Execution: 
    01. set the test result to indicate success - failures are set throughout the test
    02. The flash must be erased
    03. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    04. Perform initialization, (Startup1 and Startup2)
    05. request the Standard Read
    06. cancel it
    07. Check that Fee is IDLE
    08. request the Standard Write
    09. cancel it
    10. Check that Fee is IDLE
    11. request the Immediate Write
    12. cancel it
    13. Check that Fee is IDLE
    14. request the Invalidate
    15. cancel it
    16. Check that Fee is IDLE
    17. request the Erase for an immediate block
    18. cancel it
    19. Check that Fee is IDLE
    20. Get the test case result
    21. return the test outcome
  
Test Input: None.
Test Output: 
    The cancelation of each request must be done successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Normal.Cancel.HasRequest.Pending</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>942</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Normal.Cancel.HasRequest.Ongoing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>943</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1111</internalId></specobject>
    <specobject>
      <id>TS_Fee_AbortErase_DuringSwitch_i4s</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Immediate_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>3168</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This tests the Abort Erase functionality during an erase trigger by a section switch.
  A section erase shall be aborted if a immediate writing comes during this erase.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Read the blocks and check their consistency
    08. Fill one section at a time by writing a different block, until Fee enters switch.
    09. Update the oldest section index
    10. Perform the switch (&gt;2 sections) / Just stay IDLE (2 sections)
    11. Reset FlsCancel stub to check if the Immediate write triggers a Fls_Cancel of Erase
    12. Erase all the sections except the current Active section.
        Request the Immediate Write
    13. Process Write Job
    14. Check that the block was successfully written.
    15. Get over the delay timer
    16. Check that the erase is restarted after job completion
    17. Check that Fls Cancel was called once to cancel the pending section erase
    18. Check for flash errors
    19. Update the oldest section index
    20. Perform the switch (&gt;2 sections) / Just stay IDLE (2 sections)
    21. Reset FlsCancel stub to check if the Immediate write triggers a Fls_Cancel of Erase
    22. Test write job.
    23. Process Write Job
    24. Check that the block was successfully written.
    25. Get over the delay timer
    26. Check that the erase is restarted after job completion
    27. Check that Fls Cancel was called once to cancel the pending section erase
    28. Check for flash errors
    29. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.EnableAbortErase.NormalOperation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>274</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.SS.Behaviour.SSResume.BlockSwitching.SectionErase</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>903</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00009</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1112</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_Fee_CustomWriteInterruptingWrite</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Interruptions/source/application/Tests.c</sourcefile>
      <sourceline>130</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether Fee detects preemption occurring if during a Fee_Write call a Fee_WriteCustom is called on interruption.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Setting the interruption call parameters
    05. Requesting standard write job
    06. The previous call was interrupted by Fee_WriteCustom call.
        Check that the preemption was detected.
    07. Check that FEE_E_BUSY is reported to Det if Fee is BUSY while calling write custom
    08. Check for flash errors
    09. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.PreemptionProtection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>290</internalId></provcov>
        <provcov>
          <linksto>Fee.PreemptionProtection.DET</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>291</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1113</internalId></specobject>
    <specobject>
      <id>TS_Fee_CustomWriteInterruptingRead</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Interruptions/source/application/Tests.c</sourcefile>
      <sourceline>232</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether Fee detects preemption occurring if during a Fee_Read call a Fee_WriteCustom is called on interruption.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Setting the interruption call parameters
    05. Requesting standard read job
    06. The previous call was interrupted by Fee_WriteCustom call.
        Check that the preemption was detected.
    07. Check that FEE_E_BUSY is reported to Det if Fee is BUSY while calling write custom
    08. Check for flash errors
    09. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.PreemptionProtection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>290</internalId></provcov>
        <provcov>
          <linksto>Fee.PreemptionProtection.DET</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>291</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1114</internalId></specobject>
    <specobject>
      <id>TS_Fee_CustomWriteInterruptingInvalidate</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Interruptions/source/application/Tests.c</sourcefile>
      <sourceline>334</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether Fee detects preemption occurring if during a Fee_InvalidateBlock call a Fee_WriteCustom is called on interruption.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Setting the interruption call parameters
    05. Requesting invalidate job
    06. The previous call was interrupted by Fee_WriteCustom call.
        Check that the preemption was detected.
    07. Check that FEE_E_BUSY is reported to Det if Fee is BUSY while calling write custom
    08. Check for flash errors
    09. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.PreemptionProtection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>290</internalId></provcov>
        <provcov>
          <linksto>Fee.PreemptionProtection.DET</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>291</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1115</internalId></specobject>
    <specobject>
      <id>TS_Fee_CustomWriteInterruptingEraseI</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Interruptions/source/application/Tests.c</sourcefile>
      <sourceline>436</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether Fee detects preemption occurring if during a Fee_EraseImmediateBlock call a Fee_WriteCustom is called on interruption.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Setting the interruption call parameters
    05. Requesting erase immediate job
    06. The previous call was interrupted by Fee_WriteCustom call.
        Check that the preemption was detected.
    07. Check that FEE_E_BUSY is reported to Det if Fee is BUSY while calling write custom
    08. Check for flash errors
    09. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.PreemptionProtection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>290</internalId></provcov>
        <provcov>
          <linksto>Fee.PreemptionProtection.DET</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>291</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1116</internalId></specobject>
    <specobject>
      <id>TS_Fee_CustomReadInterruptingWrite</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Interruptions/source/application/Tests.c</sourcefile>
      <sourceline>538</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether Fee detects preemption occurring if during a Fee_Write call a Fee_ReadCustom is called on interruption.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Setting the interruption call parameters
    05. Requesting standard write job
    06. The previous call was interrupted by Fee_WriteCustom call.
        Check that the preemption was detected.
    07. Check that FEE_E_BUSY is reported to Det if Fee is BUSY while calling write custom
    08. Check for flash errors
    09. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.PreemptionProtection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>290</internalId></provcov>
        <provcov>
          <linksto>Fee.PreemptionProtection.DET</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>291</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1117</internalId></specobject>
    <specobject>
      <id>TS_Fee_CustomReadInterruptingRead</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Interruptions/source/application/Tests.c</sourcefile>
      <sourceline>640</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether Fee detects preemption occurring if during a Fee_Read call a Fee_ReadCustom is called on interruption.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Setting the interruption call parameters
    05. Requesting read job
    06. The previous call was interrupted by Fee_WriteCustom call.
        Check that the preemption was detected.
    07. Check that FEE_E_BUSY is reported to Det if Fee is BUSY while calling write custom
    08. Check for flash errors
    09. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.PreemptionProtection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>290</internalId></provcov>
        <provcov>
          <linksto>Fee.PreemptionProtection.DET</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>291</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1118</internalId></specobject>
    <specobject>
      <id>TS_Fee_CustomReadInterruptingInvalidate</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Interruptions/source/application/Tests.c</sourcefile>
      <sourceline>742</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether Fee detects preemption occurring if during a Fee_InvalidateBlock call a Fee_ReadCustom is called on interruption.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Setting the interruption call parameters
    05. Requesting invalidate job
    06. The previous call was interrupted by Fee_WriteCustom call.
        Check that the preemption was detected.
    07. Check that FEE_E_BUSY is reported to Det if Fee is BUSY while calling write custom
    08. Check for flash errors
    09. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.PreemptionProtection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>290</internalId></provcov>
        <provcov>
          <linksto>Fee.PreemptionProtection.DET</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>291</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1119</internalId></specobject>
    <specobject>
      <id>TS_Fee_CustomReadInterruptingEraseI</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Interruptions/source/application/Tests.c</sourcefile>
      <sourceline>844</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether Fee detects preemption occurring if during a Fee_EraseImmediateBlock call a Fee_ReadCustom is called on interruption.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Setting the interruption call parameters
    05. Requesting erase immediate job
    06. The previous call was interrupted by Fee_WriteCustom call.
        Check that the preemption was detected.
    07. Check that FEE_E_BUSY is reported to Det if Fee is BUSY while calling write custom
    08. Check for flash errors
    09. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.PreemptionProtection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>290</internalId></provcov>
        <provcov>
          <linksto>Fee.PreemptionProtection.DET</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>291</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1120</internalId></specobject>
    <specobject>
      <id>TS_Fee_ReadInterruptingCustomWrite</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Interruptions/source/application/Tests.c</sourcefile>
      <sourceline>946</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether Fee detects preemption occurring if during a Fee_CustomWrite call a Fee_Read is called on interruption.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Setting the interruption call parameters
    05. Requesting custom write job
    06. The previous call was interrupted by Fee_WriteCustom call.
        Check that the preemption was detected.
    07. Check that FEE_E_BUSY is reported to Det if Fee is BUSY while calling write custom
    08. Check for flash errors
    09. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.PreemptionProtection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>290</internalId></provcov>
        <provcov>
          <linksto>Fee.PreemptionProtection.DET</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>291</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1121</internalId></specobject>
    <specobject>
      <id>TS_Fee_ReadInterruptingCustomRead</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Interruptions/source/application/Tests.c</sourcefile>
      <sourceline>1049</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether Fee detects preemption occurring if during a Fee_CustomRead call a Fee_Read is called on interruption.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write a not-configured block
    05. Setting the interruption call parameters
    06. Requesting custom read job
    07. The previous call was interrupted by Fee_WriteCustom call.
        Check that the preemption was detected.
    08. Check that FEE_E_BUSY is reported to Det if Fee is BUSY while calling write custom
    09. Check for flash errors
    10. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.PreemptionProtection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>290</internalId></provcov>
        <provcov>
          <linksto>Fee.PreemptionProtection.DET</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>291</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1122</internalId></specobject>
    <specobject>
      <id>TS_Fee_WriteInterruptingCustomWrite</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Interruptions/source/application/Tests.c</sourcefile>
      <sourceline>1162</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether Fee detects preemption occurring if during a Fee_CustomWrite call a Fee_Write is called on interruption.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Setting the interruption call parameters
    05. Requesting custom write job
    06. The previous call was interrupted by Fee_WriteCustom call.
        Check that the preemption was detected.
    07. Check that FEE_E_BUSY is reported to Det if Fee is BUSY while calling write custom
    08. Check for flash errors
    09. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.PreemptionProtection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>290</internalId></provcov>
        <provcov>
          <linksto>Fee.PreemptionProtection.DET</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>291</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1123</internalId></specobject>
    <specobject>
      <id>TS_Fee_WriteInterruptingCustomRead</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Interruptions/source/application/Tests.c</sourcefile>
      <sourceline>1264</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether Fee detects preemption occurring if during a Fee_CustomRead call a Fee_Write is called on interruption.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write a not-configured block
    05. Setting the interruption call parameters
    06. Requesting custom read job
    07. The previous call was interrupted by Fee_WriteCustom call.
        Check that the preemption was detected.
    08. Check that FEE_E_BUSY is reported to Det if Fee is BUSY while calling write custom
    09. Check for flash errors
    10. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.PreemptionProtection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>290</internalId></provcov>
        <provcov>
          <linksto>Fee.PreemptionProtection.DET</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>291</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1124</internalId></specobject>
    <specobject>
      <id>TS_Fee_InvalidateInterruptingCustomWrite</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Interruptions/source/application/Tests.c</sourcefile>
      <sourceline>1378</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether Fee detects preemption occurring if during a Fee_CustomWrite call a Fee_InvalidateBlock is called on interruption.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Setting the interruption call parameters
    05. Requesting custom write job
    06. The previous call was interrupted by Fee_WriteCustom call.
        Check that the preemption was detected.
    07. Check that FEE_E_BUSY is reported to Det if Fee is BUSY while calling write custom
    08. Check for flash errors
    09. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.PreemptionProtection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>290</internalId></provcov>
        <provcov>
          <linksto>Fee.PreemptionProtection.DET</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>291</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1125</internalId></specobject>
    <specobject>
      <id>TS_Fee_InvalidateInterruptingCustomRead</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Interruptions/source/application/Tests.c</sourcefile>
      <sourceline>1480</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether Fee detects preemption occurring if during a Fee_CustomRead call a Fee_InvalidateBlock is called on interruption.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write a not-configured block
    05. Setting the interruption call parameters
    06. Requesting custom read job
    07. The previous call was interrupted by Fee_WriteCustom call.
        Check that the preemption was detected.
    08. Check that FEE_E_BUSY is reported to Det if Fee is BUSY while calling write custom
    09. Check for flash errors
    10. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.PreemptionProtection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>290</internalId></provcov>
        <provcov>
          <linksto>Fee.PreemptionProtection.DET</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>291</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1126</internalId></specobject>
    <specobject>
      <id>TS_Fee_EraseIInterruptingCustomWrite</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Interruptions/source/application/Tests.c</sourcefile>
      <sourceline>1594</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether Fee detects preemption occurring if during a Fee_CustomWrite call a Fee_EraseImmediateBlock is called on interruption.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Setting the interruption call parameters
    05. Requesting custom write job
    06. The previous call was interrupted by Fee_WriteCustom call.
        Check that the preemption was detected.
    07. Check that FEE_E_BUSY is reported to Det if Fee is BUSY while calling write custom
    08. Check for flash errors
    09. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.PreemptionProtection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>290</internalId></provcov>
        <provcov>
          <linksto>Fee.PreemptionProtection.DET</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>291</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1127</internalId></specobject>
    <specobject>
      <id>TS_Fee_EraseIInterruptingCustomRead</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Interruptions/source/application/Tests.c</sourcefile>
      <sourceline>1697</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether Fee detects preemption occurring if during a Fee_CustomRead call a Fee_EraseImmediateBlock is called on interruption.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write a not-configured block
    05. Setting the interruption call parameters
    06. Requesting custom read job
    07. The previous call was interrupted by Fee_WriteCustom call.
        Check that the preemption was detected.
    08. Check that FEE_E_BUSY is reported to Det if Fee is BUSY while calling write custom
    09. Check for flash errors
    10. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.PreemptionProtection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>290</internalId></provcov>
        <provcov>
          <linksto>Fee.PreemptionProtection.DET</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>291</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1128</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_Fee_StartUp_InvalidBlockInfoWrongDataAddress</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_StartUp_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>56</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests that Fee detects inconsistent(block data address is located inside the 4 block margin infos) block infos during startup.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
  01. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee.
  02. Perform initialization, (Startup1 and Startup2)
  03. Write a block that will be simulated to be reconfigured.
  04. Write a block that will be simulated to be written at invalid address.
  05. Corrupt the written block information with an invalid address located inside the 4 block info margin
  06. Simulate RESET.
  07. Perform Initialization.
  08. Check that the reconfigured block could not be read.
  09. Check that the out of bounds block could not be cached.

Test Input: 
  None.

Test Output: 
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInconsistent.02</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>846</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInfoValidity.SwitchNotConfiguredBlocksOFF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>818</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInfoValidity.WrittenMarkerValidity</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>821</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1129</internalId></specobject>
    <specobject>
      <id>TS_Fee_StartUp_InvalidBlockInfo</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_StartUp_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>162</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
This test can be run on 2,3,4.. sections.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
  01. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee.
  02. Perform initialization, (Startup1 and Startup2)
  03. Now all the sections shall be valid and empty. Get the empty space value in a section.
  04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
  05. Memorize the Active section index and verify that all the oter sections are empty.
  06. Read the blocks and check their consistency.
  07. Fill one section at a time by writing a different block, until Fee enters switch.
  08. Perform the switch.
  09. Erase all the sections except the current Active section.
  10. Read the blocks and validate them once more. In case any of the above operation returns failure/unexpected value
  or if a timeout occurs, set result as failure.

Test Input: 
  None.

Test Output: 
  Fee shall mark Section 0 as ACTIVE. Section status after start-up:
   - Section 0: Active
   - Section 1: Erased
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInconsistent.02</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>846</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInfoValidity.SwitchNotConfiguredBlocksOFF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>818</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInfoValidity.WrittenMarkerValidity</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>821</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1130</internalId></specobject>
    <specobject>
      <id>TS_Fee_StartUp_BlockNotFresh</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_StartUp_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>273</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Verifies that a block info that does not have the write section counter is not cached.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
  01. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee.
  02. Perform initialization, (Startup1 and Startup2)
  03. Corrupt the section counter written inside block info
  04. Simulate RESET
  05. Perform Startup1
  06. Check that the block is not cached

Test Input: 
  None.

Test Output: 
  Fee shall mark Section 0 as ACTIVE. Section status after start-up:
   - Section 0: Active
   - Section 1: Erased
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.FreshBlock</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>965</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1131</internalId></specobject>
    <specobject>
      <id>TS_Fee_StartUp_Erasable_Erasable</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_StartUp_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>357</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Tests whether the Startup1 identifies an erasable section correctly even if only one byte is correct in the marker
and Startup2 waits for a triggereing job.
In the other section (active) check that if a block is written twice only the newer instance is cached.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 


Test Input: 
  None.

Test Output: 
  Fee shall mark Section 0 as ACTIVE. Section status after start-up:
   - Section 0: Active
   - Section 1: Erased
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Idle</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>860</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.08</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>828</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInfoCacheIfNewer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>849</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.MarkerValidity</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>817</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1132</internalId></specobject>
    <specobject>
      <id>TS_Fee_StartUp_Empty_Empty</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_StartUp_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>520</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Tests whether Fee behaves corrently at Startup2 when it finds 2 empty sections. If a couple of blocks are written,
check that at Startup1 Fee performes the caching correctlly.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
  01. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee.
  02. Perform initialization, (Startup1 and Startup2)
  03. Now all the sections shall be valid and empty. Get the empty space value in a section.
  04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
  05. Memorize the Active section index and verify that all the oter sections are empty.
  06. Read the blocks and check their consistency.
  07. Fill one section at a time by writing a different block, until Fee enters switch.
  08. Perform the switch.
  09. Erase all the sections except the current Active section.
  10. Read the blocks and validate them once more. In case any of the above operation returns failure/unexpected value
  or if a timeout occurs, set result as failure.

Test Input: 
  None.

Test Output: 
  Fee shall mark Section 0 as ACTIVE. Section status after start-up:
   - Section 0: Active
   - Section 1: Erased
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInfos.01</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>836</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInfoFound</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>844</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup2.03</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>852</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInfoValidity.SwitchNotConfiguredBlocksOFF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>818</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.FillCacheWithBlockInfos</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>840</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInfosSearch</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>841</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup2.09</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>858</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00187</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>185</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.SectionManagement</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>954</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.SectionMarkers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>955</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.15</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>835</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1133</internalId></specobject>
    <specobject>
      <id>TS_Fee_StartUp_ConsistentActiveX_Empty</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_StartUp_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>716</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
Tests the scenario:
  - Fee marks the header as Active and during the marking a reset occurs in such a way that the Active marker is completely corrupted;
  - At StartUp2 Fee tries to mark the header as Active and it fails since the marker is corrupted;
  - Consequently Fee shall attempt to mark the footer as Active;
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
  01. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee.
  02. Perform initialization, (Startup1 and Startup2)
  03. Now all the sections shall be valid and empty. Get the empty space value in a section.
  04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
  05. Memorize the Active section index and verify that all the oter sections are empty.
  06. Read the blocks and check their consistency.
  07. Fill one section at a time by writing a different block, until Fee enters switch.
  08. Perform the switch.
  09. Erase all the sections except the current Active section.
  10. Read the blocks and validate them once more. In case any of the above operation returns failure/unexpected value
  or if a timeout occurs, set result as failure.

Test Input: 
  None.

Test Output: 
  Fee shall mark Section 0 as ACTIVE. Section status after start-up:
   - Section 0: Active
   - Section 1: Erased
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.MarkingHeaderActive.Failure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>926</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1134</internalId></specobject>
    <specobject>
      <id>TS_Fee_StartUp_Active_Empty</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_StartUp_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>854</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests that Fee startup2 behaves correctly in normal case when the first section is Active and the other is empty.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
  01. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee.
  02. Perform initialization, (Startup1 and Startup2)
  03. Now all the sections shall be valid and empty. Get the empty space value in a section.
  04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
  05. Memorize the Active section index and verify that all the oter sections are empty.
  06. Read the blocks and check their consistency.
  07. Fill one section at a time by writing a different block, until Fee enters switch.
  08. Perform the switch.
  09. Erase all the sections except the current Active section.
  10. Read the blocks and validate them once more. In case any of the above operation returns failure/unexpected value
  or if a timeout occurs, set result as failure.

Test Input: 
  None.

Test Output: 
  Fee shall mark Section 0 as ACTIVE. Section status after start-up:
   - Section 0: Active
   - Section 1: Erased
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInfos.03</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>838</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInconsistent.01</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>845</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlocksSearchStop.SwNotConfigBlocksOFF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>847</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.SectionManagement</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>954</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.SectionMarkers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>955</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1135</internalId></specobject>
    <specobject>
      <id>TS_Fee_BlankCheckFls</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_StartUp_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>1036</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test is a negative test and it checks that Fls driver behaves correctly with regard to blank-check.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
  01. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
  02. Verify that the first 64B are erased
  03. Verify that the reading of the first 64B that are empty will fail
  04. Check that read error was set

Test Input: 
  None.

Test Output: 
  Fee shall mark Section 0 as ACTIVE. Section status after start-up:
   - Section 0: Active
   - Section 1: Erased
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00187</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>185</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1136</internalId></specobject>
    <specobject>
      <id>TS_Fee_BlockCacheFlowBlankCheck</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_StartUp_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>1119</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests the correct block caching flow with blank check and consistency patterns.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
  01. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
  02. Perform Startup1
  03. Check that Fee status is still IDLE (it shall be stuck in Idle until a job comes)
  04. Request a job
  05. Finalize the job
  06. Check that Fee status is IDLE imediately after a job ends in Startup2
  07. Start another block writing job
  08. This time the block will not be fully written
  09. Simulate RESET
  10. Check the correct caching flow
      The first thing checked is the first written marker. It's the dummy one (for retention).
  11. Because the written marker was found, the dummy block stamp is read directly.
  10. Check the correct caching flow
      The first thing checked is the first written marker. It should be there.
  11. Because the written marker was found, the block stamp is read directly.
      The block will be cached. This will be verified later, by reading the block.
  12. Fee will continue the caching by blank-checking the next block info's written marker.
      The written marker will be found not-written. (the reset came while the data was being written)
  13. Block stamp must be blank-checked as Fee couldn't know whether it's there or not
  14. Now that the block stamp was found written, it will be read.
  15. The next written marker will be found not written because there are no other block
      info's written in section. This checks repeat 4 times before considering the section as
      fully cached.
  16. Finalize the Fls job and check that Fee goes Idle.
  17. Check that the first block was cached and the second one not.

Test Input: 
  None.

Test Output: 
  Fee shall mark Section 0 as ACTIVE. Section status after start-up:
   - Section 0: Active
   - Section 1: Erased
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.WrittenMarker</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>959</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.WrittenMarkerBlank</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>960</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.BlockStamp</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>961</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.BlockStampBlank</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>962</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.Retention</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>964</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1137</internalId></specobject>
    <specobject>
      <id>TS_Fee_StartUp_Empty_Inconsistent</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_StartUp_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>1319</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
This test can be run on 2,3,4.. sections.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
  01. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee.
  02. Perform initialization, (Startup1 and Startup2)
  03. Now all the sections shall be valid and empty. Get the empty space value in a section.
  04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
  05. Memorize the Active section index and verify that all the oter sections are empty.
  06. Read the blocks and check their consistency.
  07. Fill one section at a time by writing a different block, until Fee enters switch.
  08. Perform the switch.
  09. Erase all the sections except the current Active section.
  10. Read the blocks and validate them once more. In case any of the above operation returns failure/unexpected value
  or if a timeout occurs, set result as failure.

Test Input: 
  None.

Test Output: 
  Fee shall mark Section 0 as ACTIVE. Section status after start-up:
   - Section 0: Active
   - Section 1: Erased
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup2.01</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>850</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1138</internalId></specobject>
    <specobject>
      <id>TS_Fee_StartUp_Active_Active</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_StartUp_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>1427</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
This test can be run on 2,3,4.. sections.$$
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
  01. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee.
  02. Perform initialization, (Startup1 and Startup2)
  03. Now all the sections shall be valid and empty. Get the empty space value in a section.
  04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
  05. Memorize the Active section index and verify that all the oter sections are empty.
  06. Read the blocks and check their consistency.
  07. Fill one section at a time by writing a different block, until Fee enters switch.
  08. Perform the switch.
  09. Erase all the sections except the current Active section.
  10. Read the blocks and validate them once more. In case any of the above operation returns failure/unexpected value
  or if a timeout occurs, set result as failure.

Test Input: 
  None.

Test Output: 
  Fee shall mark Section 0 as ACTIVE. Section status after start-up:
   - Section 0: Active
   - Section 1: Erased
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.07</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>827</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.09</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>829</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.10</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>830</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.11</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>831</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.SectionManagement</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>954</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.SectionMarkers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>955</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1139</internalId></specobject>
    <specobject>
      <id>TS_Fee_StartUp_Active_EmptyNoFooter</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_StartUp_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>1570</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
This test can be run on 2,3,4.. sections.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
  01. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee.
  02. Perform initialization, (Startup1 and Startup2)
  03. Now all the sections shall be valid and empty. Get the empty space value in a section.
  04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
  05. Memorize the Active section index and verify that all the oter sections are empty.
  06. Read the blocks and check their consistency.
  07. Fill one section at a time by writing a different block, until Fee enters switch.
  08. Perform the switch.
  09. Erase all the sections except the current Active section.
  10. Read the blocks and validate them once more. In case any of the above operation returns failure/unexpected value
  or if a timeout occurs, set result as failure.

Test Input: 
  None.

Test Output: 
  Fee shall mark Section 0 as ACTIVE. Section status after start-up:
   - Section 0: Active
   - Section 1: Erased
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.CacheInit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>839</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup2.04</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>853</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.01</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>822</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.SectionManagement</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>954</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.SectionMarkers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>955</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1140</internalId></specobject>
    <specobject>
      <id>TS_Fee_StartUp_Active_ErasableHeader</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_StartUp_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>1715</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests the startup when the first section is marked as Active and the other one is marked
  as Erasable only in header.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
  01. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee.
  02. Perform initialization, (Startup1 and Startup2)
  03. Now all the sections shall be valid and empty. Get the empty space value in a section.
  04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
  05. Memorize the Active section index and verify that all the oter sections are empty.
  06. Read the blocks and check their consistency.
  07. Fill one section at a time by writing a different block, until Fee enters switch.
  08. Perform the switch.
  09. Erase all the sections except the current Active section.
  10. Read the blocks and validate them once more. In case any of the above operation returns failure/unexpected value
  or if a timeout occurs, set result as failure.

Test Input: 
  None.

Test Output: 
  Fee shall mark Section 0 as ACTIVE. Section status after start-up:
   - Section 0: Active
   - Section 1: Erased
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.08</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>828</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup2.02</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>851</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup2.05</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>854</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup2.06</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>855</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup2.09</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>858</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.ErasableBitFlip</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>963</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1141</internalId></specobject>
    <specobject>
      <id>TS_Fee_StartUp_Active_ErasableFooter</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_StartUp_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>1877</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
This test can be run on 2,3,4.. sections.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
  01. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee.
  02. Perform initialization, (Startup1 and Startup2)
  03. Now all the sections shall be valid and empty. Get the empty space value in a section.
  04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
  05. Memorize the Active section index and verify that all the oter sections are empty.
  06. Read the blocks and check their consistency.
  07. Fill one section at a time by writing a different block, until Fee enters switch.
  08. Perform the switch.
  09. Erase all the sections except the current Active section.
  10. Read the blocks and validate them once more. In case any of the above operation returns failure/unexpected value
  or if a timeout occurs, set result as failure.

Test Input: 
  None.

Test Output: 
  Fee shall mark Section 0 as ACTIVE. Section status after start-up:
   - Section 0: Active
   - Section 1: Erased
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.08</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>828</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup2.02</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>851</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup2.06</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>855</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup2.09</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>858</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1142</internalId></specobject>
    <specobject>
      <id>TS_Fee_StartUp_Active_Erasable</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_StartUp_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>2014</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
This test can be run on 2,3,4.. sections.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
  01. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee.
  02. Perform initialization, (Startup1 and Startup2)
  03. Now all the sections shall be valid and empty. Get the empty space value in a section.
  04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
  05. Memorize the Active section index and verify that all the oter sections are empty.
  06. Read the blocks and check their consistency.
  07. Fill one section at a time by writing a different block, until Fee enters switch.
  08. Perform the switch.
  09. Erase all the sections except the current Active section.
  10. Read the blocks and validate them once more. In case any of the above operation returns failure/unexpected value
  or if a timeout occurs, set result as failure.

Test Input: 
  None.

Test Output: 
  Fee shall mark Section 0 as ACTIVE. Section status after start-up:
   - Section 0: Active
   - Section 1: Erased
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.08</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>828</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup2.02</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>851</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup2.06</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>855</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.SectionManagement</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>954</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.SectionMarkers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>955</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1143</internalId></specobject>
    <specobject>
      <id>TS_Fee_StartUp_Erasable_Inconsistent</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_StartUp_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>2130</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
This test can be run on 2,3,4.. sections.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
  01. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee.
  02. Perform initialization, (Startup1 and Startup2)
  03. Now all the sections shall be valid and empty. Get the empty space value in a section.
  04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
  05. Memorize the Active section index and verify that all the oter sections are empty.
  06. Read the blocks and check their consistency.
  07. Fill one section at a time by writing a different block, until Fee enters switch.
  08. Perform the switch.
  09. Erase all the sections except the current Active section.
  10. Read the blocks and validate them once more. In case any of the above operation returns failure/unexpected value
  or if a timeout occurs, set result as failure.

Test Input: 
  None.

Test Output: 
  Fee shall mark Section 0 as ACTIVE. Section status after start-up:
   - Section 0: Active
   - Section 1: Erased
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.08</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>828</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup2.02</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>851</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup2.06</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>855</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup2.09</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>858</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.SectionManagement</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>954</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.SectionMarkers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>955</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1144</internalId></specobject>
    <specobject>
      <id>TS_Fee_StartUp_Inconsistent_Inconsistent</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_StartUp_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>2247</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
This test can be run on 2,3,4.. sections.$$
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 


Test Input: 
  None.

Test Output: 
  Fee shall mark Section 0 as ACTIVE. Section status after start-up:
   - Section 0: Active
   - Section 1: Erased
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Initialization.EmptyFlash</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>257</internalId></provcov>
        <provcov>
          <linksto>Fee.Initializaion.UserJobRequests</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>258</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Timer.UserJobRequests</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>859</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.02</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>823</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup2.06</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>855</internalId></provcov>
        <provcov>
          <linksto>Fee.FailureHandling.Behaviour.ProductionError.FEE_E_DATA_RECOVERED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>262</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1145</internalId></specobject>
    <specobject>
      <id>TS_Fee_StartUp_Active_Inconsisntent_CID</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_StartUp_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>2378</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
This test can be run on 2,3,4.. sections.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
  01. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee.
  02. Perform initialization, (Startup1 and Startup2)
  03. Now all the sections shall be valid and empty. Get the empty space value in a section.
  04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
  05. Memorize the Active section index and verify that all the oter sections are empty.
  06. Read the blocks and check their consistency.
  07. Fill one section at a time by writing a different block, until Fee enters switch.
  08. Perform the switch.
  09. Erase all the sections except the current Active section.
  10. Read the blocks and validate them once more. In case any of the above operation returns failure/unexpected value
  or if a timeout occurs, set result as failure.

Test Input: 
  None.

Test Output: 
  Fee shall mark Section 0 as ACTIVE. Section status after start-up:
   - Section 0: Active
   - Section 1: Erased
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup2.01</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>850</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup2.06</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>855</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1146</internalId></specobject>
    <specobject>
      <id>TS_Fee_StartUp_Active_InconsisntentEmptyFooter</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_StartUp_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>2486</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
This test can be run on 2,3,4.. sections.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
  01. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee.
  02. Perform initialization, (Startup1 and Startup2)
  03. Now all the sections shall be valid and empty. Get the empty space value in a section.
  04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
  05. Memorize the Active section index and verify that all the oter sections are empty.
  06. Read the blocks and check their consistency.
  07. Fill one section at a time by writing a different block, until Fee enters switch.
  08. Perform the switch.
  09. Erase all the sections except the current Active section.
  10. Read the blocks and validate them once more. In case any of the above operation returns failure/unexpected value
  or if a timeout occurs, set result as failure.

Test Input: 
  None.

Test Output: 
  Fee shall mark Section 0 as ACTIVE. Section status after start-up:
   - Section 0: Active
   - Section 1: Erased
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup2.01</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>850</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup2.06</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>855</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1147</internalId></specobject>
    <specobject>
      <id>TS_Fee_StartUp_Active_InconsisntentErasableFooter</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_StartUp_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>2598</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
This test can be run on 2,3,4.. sections.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
  01. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee.
  02. Perform initialization, (Startup1 and Startup2)
  03. Now all the sections shall be valid and empty. Get the empty space value in a section.
  04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
  05. Memorize the Active section index and verify that all the oter sections are empty.
  06. Read the blocks and check their consistency.
  07. Fill one section at a time by writing a different block, until Fee enters switch.
  08. Perform the switch.
  09. Erase all the sections except the current Active section.
  10. Read the blocks and validate them once more. In case any of the above operation returns failure/unexpected value
  or if a timeout occurs, set result as failure.

Test Input: 
  None.

Test Output: 
  Fee shall mark Section 0 as ACTIVE. Section status after start-up:
   - Section 0: Active
   - Section 1: Erased
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup2.01</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>850</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup2.02</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>851</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup2.06</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>855</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1148</internalId></specobject>
    <specobject>
      <id>TS_Fee_StartUp_Active_InconsisntenErasableEmptyFooter</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_StartUp_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>2729</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
This test can be run on 2,3,4.. sections.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
  01. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee.
  02. Perform initialization, (Startup1 and Startup2)
  03. Now all the sections shall be valid and empty. Get the empty space value in a section.
  04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
  05. Memorize the Active section index and verify that all the oter sections are empty.
  06. Read the blocks and check their consistency.
  07. Fill one section at a time by writing a different block, until Fee enters switch.
  08. Perform the switch.
  09. Erase all the sections except the current Active section.
  10. Read the blocks and validate them once more. In case any of the above operation returns failure/unexpected value
  or if a timeout occurs, set result as failure.

Test Input: 
  None.

Test Output: 
  Fee shall mark Section 0 as ACTIVE. Section status after start-up:
   - Section 0: Active
   - Section 1: Erased
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup2.01</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>850</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup2.06</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>855</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1149</internalId></specobject>
    <specobject>
      <id>TS_Fee_StartUp_Active_InconsisntenErasableErasableFooter</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_StartUp_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>2859</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
This test can be run on 2,3,4.. sections.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
  01. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee.
  02. Perform initialization, (Startup1 and Startup2)
  03. Now all the sections shall be valid and empty. Get the empty space value in a section.
  04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
  05. Memorize the Active section index and verify that all the oter sections are empty.
  06. Read the blocks and check their consistency.
  07. Fill one section at a time by writing a different block, until Fee enters switch.
  08. Perform the switch.
  09. Erase all the sections except the current Active section.
  10. Read the blocks and validate them once more. In case any of the above operation returns failure/unexpected value
  or if a timeout occurs, set result as failure.

Test Input: 
  None.

Test Output: 
  Fee shall mark Section 0 as ACTIVE. Section status after start-up:
   - Section 0: Active
   - Section 1: Erased
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup2.01</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>850</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup2.06</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>855</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1150</internalId></specobject>
    <specobject>
      <id>TS_Fee_StartUp_Active_Inconsisntent_CIDCrc</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_StartUp_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>2988</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
This test can be run on 2,3,4.. sections.$$
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
  01. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee.
  02. Perform initialization, (Startup1 and Startup2)
  03. Now all the sections shall be valid and empty. Get the empty space value in a section.
  04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
  05. Memorize the Active section index and verify that all the oter sections are empty.
  06. Read the blocks and check their consistency.
  07. Fill one section at a time by writing a different block, until Fee enters switch.
  08. Perform the switch.
  09. Erase all the sections except the current Active section.
  10. Read the blocks and validate them once more. In case any of the above operation returns failure/unexpected value
  or if a timeout occurs, set result as failure.

Test Input: 
  None.

Test Output: 
  Fee shall mark Section 0 as ACTIVE. Section status after start-up:
   - Section 0: Active
   - Section 1: Erased
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Idle</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>860</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Timer.UserJobRequests</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>859</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.07</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>827</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup2.01</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>850</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1151</internalId></specobject>
    <specobject>
      <id>TS_Fee_StartUp_Active_Active_WrongEraseCntCrc</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_StartUp_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>3127</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
This test can be run on 2,3,4.. sections.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
  01. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee.
  02. Perform initialization, (Startup1 and Startup2)
  03. Now all the sections shall be valid and empty. Get the empty space value in a section.
  04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
  05. Memorize the Active section index and verify that all the oter sections are empty.
  06. Read the blocks and check their consistency.
  07. Fill one section at a time by writing a different block, until Fee enters switch.
  08. Perform the switch.
  09. Erase all the sections except the current Active section.
  10. Read the blocks and validate them once more. In case any of the above operation returns failure/unexpected value
  or if a timeout occurs, set result as failure.

Test Input: 
  None.

Test Output: 
  Fee shall mark Section 0 as ACTIVE. Section status after start-up:
   - Section 0: Active
   - Section 1: Erased
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.04</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>825</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.12</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>832</internalId></provcov>
        <provcov>
          <linksto>Fee.SectionEraseCounter</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>266</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1152</internalId></specobject>
    <specobject>
      <id>TS_Fee_StartUp_ActiveHeader_InconsistentFooter_CIDCrc</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_StartUp_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>3241</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
This test can be run on 2,3,4.. sections.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
  01. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee.
  02. Perform initialization, (Startup1 and Startup2)
  03. Now all the sections shall be valid and empty. Get the empty space value in a section.
  04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
  05. Memorize the Active section index and verify that all the oter sections are empty.
  06. Read the blocks and check their consistency.
  07. Fill one section at a time by writing a different block, until Fee enters switch.
  08. Perform the switch.
  09. Erase all the sections except the current Active section.
  10. Read the blocks and validate them once more. In case any of the above operation returns failure/unexpected value
  or if a timeout occurs, set result as failure.

Test Input: 
  None.

Test Output: 
  Fee shall mark Section 0 as ACTIVE. Section status after start-up:
   - Section 0: Active
   - Section 1: Erased
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.03</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>824</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.07</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>827</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup2.01</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>850</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1153</internalId></specobject>
    <specobject>
      <id>TS_Fee_StartUp_InconsistentHeader_ActiveFooter_CIDCrc</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_StartUp_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>3336</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
This test can be run on 2,3,4.. sections.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
  01. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee.
  02. Perform initialization, (Startup1 and Startup2)
  03. Now all the sections shall be valid and empty. Get the empty space value in a section.
  04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
  05. Memorize the Active section index and verify that all the oter sections are empty.
  06. Read the blocks and check their consistency.
  07. Fill one section at a time by writing a different block, until Fee enters switch.
  08. Perform the switch.
  09. Erase all the sections except the current Active section.
  10. Read the blocks and validate them once more. In case any of the above operation returns failure/unexpected value
  or if a timeout occurs, set result as failure.

Test Input: 
  None.

Test Output: 
  Fee shall mark Section 0 as ACTIVE. Section status after start-up:
   - Section 0: Active
   - Section 1: Erased
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.03</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>824</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.07</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>827</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.06</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>826</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup2.01</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>850</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1154</internalId></specobject>
    <specobject>
      <id>TS_Fee_StartUp_ActiveNoHeader</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_StartUp_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>3434</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
This test can be run on 2,3,4.. sections.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
  01. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee.
  02. Perform initialization, (Startup1 and Startup2)
  03. Now all the sections shall be valid and empty. Get the empty space value in a section.
  04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
  05. Memorize the Active section index and verify that all the oter sections are empty.
  06. Read the blocks and check their consistency.
  07. Fill one section at a time by writing a different block, until Fee enters switch.
  08. Perform the switch.
  09. Erase all the sections except the current Active section.
  10. Read the blocks and validate them once more. In case any of the above operation returns failure/unexpected value
  or if a timeout occurs, set result as failure.

Test Input: 
  None.

Test Output: 
  Fee shall mark Section 0 as ACTIVE. Section status after start-up:
   - Section 0: Active
   - Section 1: Erased
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.07</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>827</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1155</internalId></specobject>
    <specobject>
      <id>TS_Fee_StartUp_ActiveNoFooter</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_StartUp_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>3524</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
This test can be run on 2,3,4.. sections.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
  01. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee.
  02. Perform initialization, (Startup1 and Startup2)
  03. Now all the sections shall be valid and empty. Get the empty space value in a section.
  04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
  05. Memorize the Active section index and verify that all the oter sections are empty.
  06. Read the blocks and check their consistency.
  07. Fill one section at a time by writing a different block, until Fee enters switch.
  08. Perform the switch.
  09. Erase all the sections except the current Active section.
  10. Read the blocks and validate them once more. In case any of the above operation returns failure/unexpected value
  or if a timeout occurs, set result as failure.

Test Input: 
  None.

Test Output: 
  Fee shall mark Section 0 as ACTIVE. Section status after start-up:
   - Section 0: Active
   - Section 1: Erased
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.CopyBlocks</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>895</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1156</internalId></specobject>
    <specobject>
      <id>TS_Fee_StartUp_ActiveWrongConsisntencyPattern</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_StartUp_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>3615</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
This test can be run on 2,3,4.. sections.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
  01. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee.
  02. Perform initialization, (Startup1 and Startup2)
  03. Now all the sections shall be valid and empty. Get the empty space value in a section.
  04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
  05. Memorize the Active section index and verify that all the oter sections are empty.
  06. Read the blocks and check their consistency.
  07. Fill one section at a time by writing a different block, until Fee enters switch.
  08. Perform the switch.
  09. Erase all the sections except the current Active section.
  10. Read the blocks and validate them once more. In case any of the above operation returns failure/unexpected value
  or if a timeout occurs, set result as failure.

Test Input: 
  None.

Test Output: 
  Fee shall mark Section 0 as ACTIVE. Section status after start-up:
   - Section 0: Active
   - Section 1: Erased
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.CopyBlocks</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>895</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1157</internalId></specobject>
    <specobject>
      <id>TS_Fee_StartUp_CacheFullSection</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_StartUp_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>3709</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that the last written block in a section that fills the section completely is cached correctly.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
  01. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee.
  02. Perform initialization, (Startup1 and Startup2)
  03. Write the smallest block until the available space in section is a multiple of one block size
  04. Check whether is possible to completely fill the section or not.
  05. Completely fill the section by writing the same block.
  06. Simulate RESET
  07. Perform Startup1
  08. Check that the last written block in the section was found (validate the latest data)

Test Input: 
  None.

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInfosSearch</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>841</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1158</internalId></specobject>
    <specobject>
      <id>TS_Fee_StartUp_ImplausibleBigSize_LowerBoundary</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_StartUp_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>3811</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that Fee validates correctly a block info that has a corrupted block length
  one byte larger than the available size for block data, and by chance the checksum matches.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
  01. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
  02. Perform Startup1. The current active section shall be the section 0.
  03. Write a block that is supposed to corrupt the block size during BlockInfo writing.
  04. Simulate the corruption of block size with the CRC matching by chance.
  05. Simulate RESET
  06. Perform Startup1. The size of the written block is detected as overlapping the margin so it is considered invalid,
      therefore the Data Address should be updated with the biggest block size configured.
      The section shall still have plenty of space for writing.
  07. Write a block that shall be written at a valid address in the same section
      as there is plenty of space in the section.
  08. Erase the next section (section 1) for verification. No block should have been written there.
  09. Simulate RESET
  10. Perform Startup1
  11. Check that the block was found consistent
  12. Check that the corrupted block cannot be read

Test Input: 
  None.

Test Output: 
  Fee shall mark Section 0 as ACTIVE. Section status after start-up:
   - Section 0: Active
   - Section 1: Erased
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInconsistent.02</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>846</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInfoValidity.SwitchNotConfiguredBlocksOFF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>818</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1159</internalId></specobject>
    <specobject>
      <id>TS_Fee_StartUp_ImplausibleBigSize_SectionOverflow</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_StartUp_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>3961</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that Fee validates correctly a block info that has a corrupted block length
  higher that the section size, and by chance the checksum matches.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
  01. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
  02. Perform Startup1. The current active section shall be the section 0.
  03. Write a block that is supposed to corrupt the block size during BlockInfo writing.
  04. Simulate the corruption of block size with the CRC matching by chance.
  05. Simulate RESET
  06. Perform Startup1. The data size is exceeding the section size, therefore the Data Address
      should be updated with the biggest block size configured. The section shall still have plenty of space
      for writing.
  07. Write a block that shall be written at a valid address in the same section
      as there is plenty of space in the section.
  08. Erase the next section (section 1) for verification. No block should have been written there.
  09. Simulate RESET
  10. Perform Startup1
  11. Check that the block was found consistent
  12. Check that the corrupted block cannot be read

Test Input: 
  None.

Test Output: 
  Fee shall mark Section 0 as ACTIVE. Section status after start-up:
   - Section 0: Active
   - Section 1: Erased
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInconsistent.02</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>846</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInfoValidity.SwitchNotConfiguredBlocksOFF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>818</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1160</internalId></specobject>
    <specobject>
      <id>TS_Fee_StartUp_ImplausibleSmallAddress</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_StartUp_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>4105</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether if the last block written in section has a corrupted address in block info
  and a matching checksum by chance, in such a way that the address value is small enough to
  point to an already written area, Fee will not end up overwriting that area.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
  01. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
  02. Perform Startup1. The current active section shall be the section 0.
  03. Write two blocks in section 0.
  04. Set the corrupted address to be 1 byte overlaping the data of the first block written
  05. Simulate the corruption of block address with the CRC matching by chance.
  06. Simulate RESET
  07. Perform Startup1.
  08. Try to read the corrupted block
  09. Check that the block was not cached because of implausible address
  10. A write job shall be correctly performed
  11. Check that the job did not overwrite already written area

Test Input: 
  None.

Test Output: 
  Fee shall mark Section 0 as ACTIVE. Section status after start-up:
   - Section 0: Active
   - Section 1: Erased
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInconsistent.02</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>846</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInfoValidity.SwitchNotConfiguredBlocksOFF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>818</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInfosSearch</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>841</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1161</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_Fee_NotConfigBlocks_StandardSwitch</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_SwitchNotConfBlocks/source/application/Tests.c</sourcefile>
      <sourceline>61</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch copies the not configured blocks found in the configured cuantum. And for the others a Det is reported.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Write the simulated not configured blocks
    06. Modify the block numbers to simulate not configured blocks
    07. Simulate the write of a not configured block that can not be memorized by Fee,
        and therefore it won't be switched either.
    08. Modify the block numbers to simulate not configured blocks
    09. Simulate RESET
    10. When this block is written Fee must have already taken into consideration the size of
        the "extra" not configured block, and no overwrite shall occur.
    11. By now the initialization must have finished. Check that extra not configured block was found
    12. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    13. Fill one section at a time by writing a different block, until Fee enters switch.
    14. Perform the switch
    15. Modify back the block numbers for verification
    16. Simulate RESET
    17. Check that the not configured blocks were found
    18. Check that the extra not configured blocks could not be found
    19. Read the blocks and validate them once more.
    20. Check for flash errors
    21. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Configuration.TotalBlocksSize.SwitchNotConfiguredBlocks</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>232</internalId></provcov>
        <provcov>
          <linksto>Fee.Configuration.FeeNumberOfNotConfigBlocks</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>233</internalId></provcov>
        <provcov>
          <linksto>Fee.Configuration.FeeDataSizeNotConfiguredBlocks</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>235</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInfos.02</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>837</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.SwitchNotConfiguredBlocks</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>842</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlocksSearchStop.SwNotConfigBlocksON</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>848</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInfoValidity.SwitchNotConfiguredBlocksON</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>819</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeNumberOfNotConfigBlocks.BlocksLost</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>234</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1162</internalId></specobject>
    <specobject>
      <id>TS_Fee_NotConfigBlocks_SS_NotNeeded</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_SwitchNotConfBlocks/source/application/Tests.c</sourcefile>
      <sourceline>285</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch copies only the old instances of not configured blocks.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Write the simulated not configured blocks
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block, until Fee enters switch.
    08. Modify the block numbers to simulate not configured blocks
    09. Simulate RESET
    10. Finish Startup1 and trigger startup2
    11. Get over the delay timer
    12. Perform the switch
    13. Modify back the block numbers for verification
    14. Simulate RESET
    15. Check that the simulated not configured blocks were found
    16. Validate the configured blocks.
    17. Check for flash errors
    18. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Configuration.TotalBlocksSize.SwitchNotConfiguredBlocks</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>232</internalId></provcov>
        <provcov>
          <linksto>Fee.Configuration.FeeNumberOfNotConfigBlocks</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>233</internalId></provcov>
        <provcov>
          <linksto>Fee.Configuration.FeeDataSizeNotConfiguredBlocks</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>235</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1163</internalId></specobject>
    <specobject>
      <id>TS_Fee_NotConfigBlocks_HPSS</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_SwitchNotConfBlocks/source/application/Tests.c</sourcefile>
      <sourceline>472</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the not configured blocks are identified and copied correctly during high priority switch.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Write the simulated not configured blocks
    06. Modify the block numbers to simulate not configured blocks
    07. Simulate RESET
    08. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    09. Fill one section at a time by writing a different block. Keep writing the block until Fee enters high priority switch.
    10. Run until Switch performs read data for the first block that is being switched
    11. Run until Switch performs copy data
    12. By now Fee shall be in high priority switch with the first block to be switched started. Simulate RESET
    13. Perform the switch
    14. Modify back the block numbers for verification
    15. Simulate RESET
    16. Check that the simulated not configured blocks were found
    17. Validate the configured blocks.
    18. Check for flash errors
    19. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Configuration.TotalBlocksSize.SwitchNotConfiguredBlocks</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>232</internalId></provcov>
        <provcov>
          <linksto>Fee.Configuration.FeeNumberOfNotConfigBlocks</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>233</internalId></provcov>
        <provcov>
          <linksto>Fee.Configuration.FeeDataSizeNotConfiguredBlocks</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>235</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1164</internalId></specobject>
    <specobject>
      <id>TS_Fee_NotConfigBlocks_RestartSwitch</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_SwitchNotConfBlocks/source/application/Tests.c</sourcefile>
      <sourceline>667</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the configured blocks are copied correctly during a restart switch.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Write the simulated not configured blocks
    06. Modify the block numbers to simulate not configured blocks
    07. Simulate RESET
    08. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    09. Fill one section at a time by writing a different block. Keep writing the block until Fee enters high priority switch.
    10. Run until Switch performs read data for the first block that is being switched (the only one configured that needs to be switched)
    11. Run until Switch performs copy data
    12. Run until Switch performs read data for the first not configured block that is being switched.
    13. Run until Switch performs copy data
    14. Run until Switch performs read data for the third not configured block.
        The second not configured block that was invalidated will also be copied in this step.
        (The data for this block won't get to be copied)
    15. Fail the block switching until there is no more space to switch all the blocks
    16. Simulate RESET
    17. Perform the restart switch and the high priority switch
    18. Modify back the block numbers for verification
    19. Simulate RESET
    20. Check that the simulated not configured blocks were found
    21. Validate the configured blocks.
    22. Check for flash errors
    23. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Configuration.TotalBlocksSize.SwitchNotConfiguredBlocks</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>232</internalId></provcov>
        <provcov>
          <linksto>Fee.Configuration.FeeNumberOfNotConfigBlocks</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>233</internalId></provcov>
        <provcov>
          <linksto>Fee.Configuration.FeeDataSizeNotConfiguredBlocks</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>235</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1165</internalId></specobject>
    <specobject>
      <id>TS_Fee_ConfigBlocks_RestartSwitch_AllBlocks</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_SwitchNotConfBlocks/source/application/Tests.c</sourcefile>
      <sourceline>939</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the configured blocks are copied correctly during a restart switch.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block. Keep writing the block until Fee enters high priority switch.
    08. Simulate RESET
    09. Request a read that after completion shall resume high priority switch
    10. Finish the read request
    11. Get over the delay timer
    12. Check that high priority switch is started.
    13. Start the high priority switch
    14. Request one more read that shall not interrupt the high priority switch
    15. Go to the first flash read operation. It should be a switch read.
    16. Perform the high priority switch
    17. Finish the read job
    18. Perform the switch
    19. Erase all the sections except the current Active section.
    20. Check for flash errors
    21. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Configuration.TotalBlocksSize.SwitchNotConfiguredBlocks</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>232</internalId></provcov>
        <provcov>
          <linksto>Fee.Configuration.FeeNumberOfNotConfigBlocks</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>233</internalId></provcov>
        <provcov>
          <linksto>Fee.Configuration.FeeDataSizeNotConfiguredBlocks</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>235</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1166</internalId></specobject>
    <specobject>
      <id>TS_Fee_WriteCustom_FullSlots</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_SwitchNotConfBlocks/source/application/Tests.c</sourcefile>
      <sourceline>1136</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether Fee_WriteCustom API does not refuse repeated writes of already written not configured blocks
  when all the not configured blocks slots are occupied. But it refuses the first new not configured block.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write custom all the not configured blocks
    05. Check that the not configured blocks can be written again.
    06. Check that no Det is reported
    07. Simulate RESET
    08. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    09. Check that the not configured blocks can be written again.
    10. Check that no Det is reported
    11. Check that custom write is refused for a new not-configured block that can not be memorized any more
    12. Check for flash errors
    13. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Configuration.FeeWriteCustomApi</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>237</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeWriteCustom</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>238</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.WriteCustom.TooManyBlocks</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>869</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1167</internalId></specobject>
    <specobject>
      <id>TS_Fee_WriteCustom_Refusals</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_SwitchNotConfBlocks/source/application/Tests.c</sourcefile>
      <sourceline>1335</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether Fee_WriteCustom API refuses the write jobs with wrong parameters or if the requested not-configured block can not be memorized.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Write the simulated not configured blocks
    06. Modify the block numbers to simulate not configured blocks
    07. Simulate RESET
    08. Check that custom write is refused when Fee is UNINIT
    09. Check that FEE_E_UNINIT is reported to Det if Fee is UNINIT while calling write custom
    10. Initialize flash driver and test stubs for Nvm and Det
    11. Initialize Fee module
    12. Finish the initialization with a write job
    13. Request a read job, so Fee gets busy
    14. Check that custom write is refused when Fee is BUSY
    15. Check that FEE_E_BUSY is reported to Det if Fee is BUSY while calling write custom
    16. Finish the current read job
    17. Check that custom write is refused for an invalid block number
    18. Check that FEE_E_INVALID_BLOCK_NO is reported to Det if write custom is called with invalid block number
    19. Check that custom write is refused for an invalid data pointer
    20. Check that FEE_E_INVALID_DATA_PTR is reported to Det if write custom is called with invalid data pointer
    21. Check that custom write is refused for an invalid block size of a new not-configured block
    22. Check that custom write is refused for a valid block size of a new not-configured block
        but overflowing the total reserved size for not cfg blocks
    23. Check that custom write is refused for an invalid block size of a configured block
    24. Write 2 more not-configured blocks
    25. Finish the write jobs
    26. Check that custom write is refused for a new not-configured block that can not be memorized any more
    27. Check that custom write is refused for a 0 block size of a written not-configured block
    28. Check that custom write is refused for an invalid block size of a written not-configured block
    29. Check for flash errors
    30. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Configuration.FeeWriteCustomApi</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>237</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeWriteCustom</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>238</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeWriteCustom.UninitOrBusy</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>239</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeWriteCustom.ConfiguredBlock</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>240</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeWriteCustom.Det.Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>241</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeWriteCustom.Det.Busy</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>242</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeWriteCustom.Det.BlockNumber.Invalid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>243</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeWriteCustom.Det.BlockNumber.ConfiguredBlock</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>244</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeWriteCustom.Det.DataPointer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>245</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeWriteCustom.Det.BlockSize</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>246</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.WriteCustom.TooManyBlocks</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>869</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1168</internalId></specobject>
    <specobject>
      <id>TS_Fee_WriteCustom_Acceptance</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_SwitchNotConfBlocks/source/application/Tests.c</sourcefile>
      <sourceline>1744</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether Fee_WriteCustom API accepts the job and the configured/not-configured block is correctly written and copied by the switch mechanism.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Write the simulated not configured blocks
    06. Modify the block numbers to simulate not configured blocks
    07. Simulate RESET
    08. Perform Startup1
    09. Write the first not-configured block. (it's already written)
    10. Finish the job
    11. Write the second not-configured block. (not written)
    12. Finish the job
    13. Fill one section at a time by writing a different block, until Fee enters switch.
    14. Write the third not-configured block during switch. (not written)
    15. Finish the job
    16. Keep writing the block until Fee enters high priority switch.
    17. Write the forth not-configured block that causes highest internal priority. (not written)
    18. Finish the job
    19. Modify back the block numbers for verification
    10. Simulate RESET
    21. Check that the not configured blocks are written with the correct data
    22. Modify the block numbers to simulate not configured blocks
    23. Simulate RESET
    24. Wait till all operations finish
    25. Validate that Fee_WriteCustom is accepted with size more than the existing size
    26. Finish the job
    27. Validate that Fee_WriteCustom is accepted with size less than the existing size
    28. Finish the job
    29. Check that the not configured blocks are written with the correct data
    30. Simulate RESET
    31. Wait till all operations finish
    32. Check that the not configured blocks are written with the correct data
    33. Check for flash errors
    34. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Configuration.FeeWriteCustomApi</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>237</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeWriteCustom</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>238</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInfos.02</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>837</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.SwitchNotConfiguredBlocks</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>842</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInfoValidity.SwitchNotConfiguredBlocksON</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>819</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1169</internalId></specobject>
    <specobject>
      <id>TS_Fee_ReadCustom_Refusals</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_SwitchNotConfBlocks/source/application/Tests.c</sourcefile>
      <sourceline>2117</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether Fee_ReadCustom API refuses the read jobs with wrong parameters when DET is ON or if Fee is Busy or Uninit.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Write the simulated not configured blocks
    06. Modify the block numbers to simulate not configured blocks
    07. Simulate RESET
    08. Initialize flash driver and test stubs for Nvm and Det
    09. Check that custom read is refused when Fee is UNINIT
    10. Check that FEE_E_UNINIT is reported to Det if Fee is UNINIT while calling read custom
    11. Initialize Fee module
    12. Finish the initialization with a write job
    13. Request a write job, so Fee gets busy
    14. Check that custom read is refused when Fee is BUSY
    15. Check that FEE_E_BUSY is reported to Det if Fee is BUSY while calling write custom
    16. Finish the current write job
    17. Check that custom read is refused for an invalid block number
    18. Check that FEE_E_INVALID_BLOCK_NO is reported to Det if read custom is called with invalid block number
    19. Check that custom read is refused for an invalid data pointer
    20. Check that FEE_E_INVALID_DATA_PTR is reported to Det if read custom is called with invalid data pointer
    21. Check that custom read is refused for an invalid block offset of an already written not-configured block
    22. Check that custom read is refused for an invalid block length of an already written not-configured block
    23. Check that custom read is refused for a valid block length of an already written configured block
    24. Check for flash errors
    25. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Configuration.FeeReadCustomApi</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>247</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeReadCustom</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>248</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeReadCustom.BlockNumber</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>250</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeReadCustom.UninitOrBusy</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>249</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeReadCustom.Det.Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>251</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeReadCustom.Det.Busy</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>252</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeReadCustom.Det.BlockNumber</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>253</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeReadCustom.Det.DataPointer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>254</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeReadCustom.Det.WrongLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>255</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeReadCustom.Det.WrongOffset</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>256</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1170</internalId></specobject>
    <specobject>
      <id>TS_Fee_ReadCustom_Acceptance</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_SwitchNotConfBlocks/source/application/Tests.c</sourcefile>
      <sourceline>2377</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether Fee_ReadCustom API accepts the job and the not-configured block is correctly read.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks. These blocks will never be written again in the test.
    05. Write the simulated not configured blocks
    06. Modify the block numbers to simulate not configured blocks
    07. Simulate RESET
    08. Perform Startup1
    09. Read the first not-configured block.
    10. Finish the job
    11. Read the second not configured block. (it's erased)
    12. Read the third not configured block. (it's invalidated)
    13. Finish the job
    14. Read the first configured block. (it's written)
    15. Finish the job
    16. Read the second configured block. (it's erased)
    17. Finish the job
    18. Read the third configured block. (it's invalidated)
    19. Finish the job
    20. Fill one section at a time by writing a different block, until Fee enters switch.
    21. Read the first not-configured block during switch. (read not all the data)
    22. Finish the job
    23. Check that only the length requested is read
    24. Finish the switch
    25. Read the first not-configured block after the switch. (read not all the data)
    26. Finish the job
    27. Check that only the length requested is read
    28. Check for flash errors
    29. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Configuration.FeeReadCustomApi</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>247</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeReadCustom</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>248</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1171</internalId></specobject>
    <specobject>
      <id>TS_Fee_NotConfigBlocks_ReconfSizeSmaller</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_SwitchNotConfBlocks/source/application/Tests.c</sourcefile>
      <sourceline>2668</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether Fee initialization finds and caches a not-configured block with reconfigured size as smaller than before.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
  01. Set the initial test result
  02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
  03. Perform Startup1
  04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
  05. Write the simulated not configured blocks
  06. Simulate the write of not-configured block 20
  07. Simulate the write of block 20 but with greater size
  08. Simulate the write of not-configured block 21
  09. Simulate the write of block 21 but with smaller size
  10. Simulate RESET
  11. When this block is written Fee must have already taken into consideration the size of
      the "extra" not configured block, and no overwrite shall occur.
  12. Memorize the Active section index and verify that all the other sections are empty.
      All sections shall be empty now, except the Active section)
  13. Fill one section at a time by writing a different block, until Fee enters switch.
  14. Perform the switch
  15. Modify back the block 20 who's instance is the greater sized one,
      with the block Id of the first instance (smaller size)
  16. Modify back the block 21 who's instance is the smaller sized one,
      with the block Id of the second instance (smaller size)
  17. Simulate RESET
  18. Finish init
  19. Check that only the instance with smaller size of simulated block 21 is found.
  20. Check that older instances are not found.
  21. Read the blocks and validate them once more.
  22. Check for flash errors
  23. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Configuration.FeeNumberOfNotConfigBlocks</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>233</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeNotConfigBlocks.SizeReconfigured</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>236</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1172</internalId></specobject>
    <specobject>
      <id>TS_Fee_NotConfigBlocks_ReconfSizeBigger</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_SwitchNotConfBlocks/source/application/Tests.c</sourcefile>
      <sourceline>2884</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether Fee initialization finds and caches a not-configured block with reconfigured size as bigger than before.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
  01. Set the initial test result
  02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
  03. Perform Startup1
  04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
  05. Write the simulated not configured blocks
  06. Simulate the write of not-configured block 20
  07. Simulate the write of block 20 but with greater size
  08. Simulate the write of block 20 but with size &gt; FEE_NOT_CONFIGURED_BLOCKS_DATA_SIZE
  09. Simulate the write of not-configured block 21
  10. Simulate the write of block 21 but with smaller size
  11. Simulate the write of block 20 that will not fit reserved size when caching
  12. Simulate the write of block 22 that will not fit reserved size when caching
  13. Simulate RESET
  14. When this block is written Fee must have already taken into consideration the size of
      the "extra" not configured block, and no overwrite shall occur.
  15. Memorize the Active section index and verify that all the other sections are empty.
      All sections shall be empty now, except the Active section)
  16. Fill one section at a time by writing a different block, until Fee enters switch.
  17. Perform the switch
  18. Modify back the block 20 who's instance is the greater sized one,
      with the block Id of the second instance (greater size)
  19. Modify back the block 21 who's instance is the smaller sized one,
      with the block Id of the second instance (bigger size)
  20. Try to modify back the block 22; it should not be found, not being cached
  21. Modify back the block 23
  22. Simulate RESET
  23. Finish init
  24. Check that only the instance with bigger size of simulated block 20 is found.
  25. Check that older instance are not found.
  26. Read the blocks and validate them once more.
  27. Check for flash errors
  28. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Configuration.FeeNumberOfNotConfigBlocks</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>233</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeNotConfigBlocks.SizeReconfigured</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>236</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1173</internalId></specobject>
    <specobject>
      <id>TS_Fee_CustomBlkErasedWrittenInSection0</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_SwitchNotConfBlocks/source/application/Tests.c</sourcefile>
      <sourceline>3115</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether an erased immediate block in section 0 is correctly cached if written again.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    05. Keep writing until there is no more space to write but in the last section.
    06. Write the immediate block of interest in the last section. (The reason for this
        is to test a real case scenario when an immediate block is erased only if it
        was previously written)
    07. Fill the last section
    08. Write the filling block in order to make the transition to the first section.
        (This step should also finalize a postponed switch erase)
    08. Erase the immediate block in the first section. (The previous writing of this block
        is in an older section, therefore not cached yet)
    09. Write the immediate block again in the first section.
    10. Convert the immediate block into an not-configured block, through simulation
    11. Simulate RESET
    03. Perform Startup1
    12. Check that custom read is performed successfully
    13. Check for flash errors
    14. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Configuration.FeeReadCustomApi</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>247</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeReadCustom</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>248</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInfoCacheIfNewer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>849</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1174</internalId></specobject>
    <specobject>
      <id>TS_Fee_NotConfigBlocks_InvalidatedBlock</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_SwitchNotConfBlocks/source/application/Tests.c</sourcefile>
      <sourceline>3297</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether Fee will find all the blocks during init, even though they are written after a block is invalidated
  and then a reset comes and the invalidated block is a not-configured block that cannot be stored.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write the simulated not configured blocks
    05. Write a block multiple times, until there would be space for only one block info in the init buffer
    06. Modify the block numbers to simulate not configured blocks
    07. Simulate the invalidation of a not configured block that can not be memorized by Fee
    08. Modify the block number to simulate not configured block
    09. Write 2 blocks that need to be found at startup.
    10. Simulate RESET
    11. Read the blocks and validate them.
    12. Check for flash errors
    13. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInfosSearch</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>841</internalId></provcov>
        <provcov>
          <linksto>Fee.Configuration.FeeNumberOfNotConfigBlocks</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>233</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1175</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_Fee_Switch_HP_ImmediatelyAfterInit_2s</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Switch_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>57</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch is triggered correctly even in highest priority. 
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block. Keep writing the block until Fee enters high priority switch.
    08. Perform a couple of switch steps.
    09. Simulate RESET
    10. Request a write for resuming high priority switch
    11. Perform the high priority switch
    12. Erase all the sections except the current Active section.
    13. Check that the switch had finished indeed.
    14. Check for flash errors
    15. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.TriggeringTheSwitch.AfterInit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>900</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1176</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_Restart_DueToFailures_2s</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Switch_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>222</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch is restarted in case of failure causing no more space for switch. 
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Fill the section
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Keep writing the block until Fee is right before high priority switch.
    08. This job will trigger the high priority switch, and it will be performed after the switch.
    09. A high priority switch has started.
        Fee will start to switch the block. Run until Switch performs read data
    10. Until Switch performs copy data
    11. Fail the block switching until there is no more space to switch all the blocks
    12. Copy data fail
    13. Fee will retry to switch the block. Run until Switch performs read data
    14. Run until Switch performs copy data
    15. Last operation performed was a copy data of the last failing block switch in order to be left with no space for switching.
        Therefore simulate write fail.
    16. Now Fee is busy due to the requested write. It shall stay busy as long as the restart switch is ongoing,
        till the read is finally processed.
    17. Perform Restart Switch
    18. By now the switch shall be finished.
    19. Erase all the sections except the current Active section.
    20. Check that the switch had finished indeed.
    21. Check for flash errors
    22. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.RestartSwitch</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>912</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.SS.RestartSwitch.ConditionForRestart</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>909</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.SS.RestartSwitch.Priority</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>911</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1177</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_Restart_DueToResets_2s</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Switch_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>429</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch is restarted in case of resets causing no more space for switch. 
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Fill the section
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block. Keep writing the block until Fee enters high priority switch.
    08. Let a block to be switched
        Until Switch performs read data
    09. Fail the block switching until there is no more space to switch all the blocks
    10. Simulate RESET
    11. Request a read for high priority switch resuming
    12. Perform initialization
    13. Get over the delay timer after read job completion
    14. Now the blocks to be switched can not fit in the section. Perform Restart Switch
    15. Erase all the sections except the current Active section.
    16. Check that the switch had finished indeed.
    17. Check for flash errors
    18. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.RestartSwitch</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>912</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.SS.RestartSwitch.TriggerAfterInit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>910</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.SS.RestartSwitch.ConditionForRestart</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>909</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1178</internalId></specobject>
    <specobject>
      <id>TS_Fee_Section_PostponeErase_HighPrio</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Switch_2Sections/source/application/Tests.c</sourcefile>
      <sourceline>680</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section erase at the end of high priority switch will not have priority as long as there is still space for jobs. 
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Fill the section
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Keep writing the block until Fee is right before high priority switch.
    08. Wait for job to be processed
    09. Fill other section
    10. Request new write: this shall be finished after high prio switch is done
    11. Check FEE_ERASE_SECTION is reached
    12. Simulate Flash error
    13. Check FEE_ERASE_SECTION is reached again
    14. It shall stay busy as long as the section erase is ongoing as a high priority internal operation, till the write is finally processed.
    15. Wait for write block to be completed
    16. By now the switch shall be finished.
    17. Check that the switch had finished indeed
    18. Check for flash errors
    19. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.Failure.SectionErase.HighPrio</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>935</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1179</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_Fee_Switch_JobInterrupts_1_3s</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Switch_3Sections/source/application/Tests.c</sourcefile>
      <sourceline>57</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch behaves correctly if interrupted by user job requests.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block, until Fee enters switch.
    08. Take the current free space in the active section after only one block copied.
    09. The block info of the invalidated block is copied here
    10. Request a write that interrupts the switch right after a switch block info has been done.
    11. The second block switch starts by copying block info
    12. Request a read that interrupts the switch right after a switch block info has been done.
    13. Until Switch performs read data
    14. Fee has requested a read data (first buffer) for the block that is being switched
    15. Request a write that interrupts the switch right after a switch read data has been done.
    16. Until Switch performs write data
    17. Finish the write of the first buffer. (this is a case of a big block, but it should work for a small block too,
        since the block switching is not finished until the written marker is completed)
    18. Request a write that interrupts the switch right after a switch data write has been done.
    19. Get over the delay timer
    20. Finish the switch.
    21. Check that switch resumed the data writing of the block that was being switched instead of restarting it.
        Now that the switch is over the occupied size in active section shall be
        by the switched blocks and the block that interrupted the switch, taken only once.
    22. Check that the switch had finished indeed.
    23. Check for flash errors
    24. Set test case result

Test Input: 
  None.

Test Output: 
 None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.Behaviour.SSResume.BlockSwitching.Writing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>901</internalId></provcov>
        <provcov>
          <linksto>Fee.SS.UserJobRequests</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>260</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Write.Behaviour.SSOngoing.SwapNeeded</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>868</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Write.Behaviour.SSOngoing.IsSpace</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>867</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Read.Behaviour.SSOngoing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>872</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Invalidate.Behaviour.SSOngoing.IsSpace</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>877</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.EraseImmediate.Behaviour.SSOngoing.IsSpace</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>882</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00192</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1180</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_TrigBy_Invalidation</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Switch_3Sections/source/application/Tests.c</sourcefile>
      <sourceline>303</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch is triggered by invalidation. 
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Fill the section
    05. Perform an invalidation that should change the section as it has no more space
    06. Check that the section is changed
    07. Fill this section too
    08. Perform an invalidation that should trigger highest priority switch
    09. Check that the switch is over
    10. Check that the active section changed
    11. Check for flash errors
    12. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Invalidate.Behaviour.IDLE.NoSpace</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>876</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Invalidate.Behaviour.SSOngoing.SwapNeeded</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>878</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Invalidate.Behaviour.SSOngoing.NoSpace</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>879</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1181</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_TrigBy_EraseImm</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Switch_3Sections/source/application/Tests.c</sourcefile>
      <sourceline>423</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch is triggered by erase immediate. 
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Fill the section
    05. Perform an invalidation that should change the section as it has no more space
    06. Check that the section is changed
    07. Fill this section too
    08. Perform an invalidation that should trigger highest priority switch
    09. Check that the switch is over
    10. Check that the active section changed
    11. Check for flash errors
    12. Set test case result

Test Input: 
  None.

Test Output: 
 None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.EraseImmediate.Behaviour.IDLE.NoSpace</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>881</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.EraseImmediate.Behaviour.SSOngoing.SwapNeeded</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>883</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.EraseImmediate.Behaviour.SSOngoing.NoSpace</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>884</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1182</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_Interruptions_01</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Switch_3Sections/source/application/Tests.c</sourcefile>
      <sourceline>543</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that Fee correctly switches the block, if the following situation occurs:
  - a block (B) is to be switched
  - a write request is made for it (standard write)
  - before Fee finishes the request, it is cancelled
  - an immediate write request is made
  - that request causes Fee to go to high priority switch
  In this case, the already written instance of (B) is correctly switched
  by Fee, the switch is completed, the immediate write is performed and
  then the standard write (which is requested again upon completion of the
  immediate write).
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block, until the Active section is second to last section empty
    08. Fill the last section before entering high priority switch, being in interrupted switch
    09. Request a write of the block to be switch
    10. Let it start the writing (the block info)
    11. Cancel the standard job for a coming immediate one
    12. Request the immediate write that triggers high internal priority switch
    13. Update the current active section
    14. Get the space available of the last empty section
    15. Finish the immediate write that follows the switch completion
    16. Simulate that on immediate write JobEnd callback the standard write of the block
        that should have already been switch is requested again
    17. Finish the standard write
    18. Check that the current active section does contain only the block to be switch, the immediate block and
        the same standard block that was supposed to be switched.
        Now, in the section where the switch starts, only the block that triggered the switch is written.
    19. Check that the switch had finished indeed.
    20. Check for flash errors
    21. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.SwitchPriority</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>905</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.SS.SwitchPriority.JobLosesPriority</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>908</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1183</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_Interruptions_02</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Switch_3Sections/source/application/Tests.c</sourcefile>
      <sourceline>750</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that Fee correctly switches the block, if the following situation occurs:
  - a block (B) is to be switched
  - a write request is made for it (standard write)
  - before Fee finishes the request, it is cancelled
  - an immediate write request is made
  - the request completes
  - the standard write is requested again
  - the requests and all subsequent retries fail
  In this case, Fee will switch the already written instance of (B) and
  perform all related switch activities until successful completion. It
  will NOT decrement the switch required size for any of the
  write requests made for (B).
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block, until the Active section is second to last section empty
    08. Request a write of the block to be switch
    09. Let it start the writing (the block info)
    10. Cancel the standard job for a coming immediate one
    11. Request the immediate write
    12. Finish the immediate write
    13. Request 4 writes of the standard block to be switched, all of them failing
    14. Get over the delay timer
    15. Finish the switch
    16. Switch will be performed in the next section due to the fact that 4 BI fails change the section
    17. Erase all the sections except the current Active section.
    18. Check that the switch had finished indeed.
    19. Check for flash errors
    20. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.SS.UserJobRequests</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>260</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Write.Behaviour.SSOngoing.SwapNeeded</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>868</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Write.Behaviour.SSOngoing.IsSpace</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>867</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1184</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_Interruptions_03</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Switch_3Sections/source/application/Tests.c</sourcefile>
      <sourceline>955</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that Fee correctly switches the block, if the following
  situation occurs:
  - a block (B) is to be switched
  - a write request is made for it (standard write)
  - before Fee finishes the request, it is cancelled
  - an immediate write request is made
  - the request completes
  - the standard write is requested again
  - the requests fails
  - all subsequent retries fail, except the last retry which is successful
  In this case, Fee will NOT decrement the switch required size for any
  of the write requests made for (B) except the last one, which is successful.
  Then, it will proceed with the remaining switch operations, until completion.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block, until the Active section is second to last section empty
    08. Request a write of the block to be switch
    09. Let it start the writing (the block info)
    10. Cancel the standard job for a coming immediate one
    11. Request the immediate write
    12. Finish the immediate write
    13. Request 3 writes of the standard block to be switched, all of them failing
    14. Request a write of the block to be switched
    15. Finish the write
    16. Get over the delay timer
    17. Finish the switch
    18. Erase all the sections except the current Active section.
    19. Check that the switch had finished indeed.
    20. Check for flash errors
    21. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.SS.UserJobRequests</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>260</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Write.Behaviour.SSOngoing.SwapNeeded</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>868</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Write.Behaviour.SSOngoing.IsSpace</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>867</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1185</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_Interruptions_04</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Switch_3Sections/source/application/Tests.c</sourcefile>
      <sourceline>1171</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  The test scenario is the following:
  - there is an ongoing switch with Fls busy with a read request for the switch
  - a write request is made for a standard block
  - the standard block is small enough to interrupt the switch
  - before the first Fee_MainFunction, a cancel is requested
  - in the JobError notification NvM requests a write for an immediate block
  - the write causes Fee to enter highest internal priority
  - the Fee_MainFunction is executed
  In this case, Fee shall not see the cancellation as the failure of the read of the
  switch but as the interruption of the standard write by the immediate write. 

  In this test, the cancellation occurs before Fee passes the job to Fls. Before
  the cancellation, the first part of block is moved by the switch.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block, until the Active section is second to last section empty
    08. Fill the last section before entering high priority switch, being in interrupted switch
    09. Until Switch performs read data
    10. Request an invalidation of the block to be switch
    11. Cancel the standard job for a coming immediate one
    12. Fls read job requested by switch shall not be canceled yet, only the user job shall be cleared
    13. Request the immediate write that triggers high internal priority switch
    14. Finish the immediate write that follows the switch completion
    15. Finish the switch
    16. Check that the switch had finished indeed.
    17. Check for flash errors
    18. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.SS.UserJobRequests</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>260</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Write.Behaviour.SSOngoing.SwapNeeded</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>868</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Write.Behaviour.SSOngoing.IsSpace</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>867</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.SS.SwitchPriority.JobLosesPriority</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>908</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1186</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_CacheAll_InvalidatedWritten</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Switch_3Sections/source/application/Tests.c</sourcefile>
      <sourceline>1365</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether Fee will find all the blocks during init, even though they are written after a block is invalidated
  and then written during section switch before a reset comes.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. This block needs to be written as many times as it's needed in order for the initialization to
        fill an initialization buffer with all the block infos of this block, in order to force the
    02. Set the initial test result
    03. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    04. Perform Startup1
    05. Write a block multiple times, until there would be space for only one block info in the init buffer
    06. Invalidate a block. This block info will be the first in the init buffer during caching.
    07. Write 2 blocks that must be found by Fee startup.
    08. Finish Startup2
    09. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    10. Save the current Active section
    11. Read the blocks and check their consistency
    12. Fill one section at a time by writing a different block, until Fee enters switch.
    13. Get over the delay timer(&gt;2 sections)
    14. Monitor the section index.
    15. Update the oldest section index
    16. Interrupt Switch by writing the block that was invalidated
    17. Simulate RESET
    18. Perform initialization, (Startup1)
    19. Read the blocks and validate them once more.
    20. Check for flash errors
    21. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInfosSearch</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>841</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1187</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_CacheAll_InvalidatedWrittenCopied</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Switch_3Sections/source/application/Tests.c</sourcefile>
      <sourceline>1559</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether Fee will find all the blocks during init, even though they are written after a block is invalidated,
  written in the same section and then copied before a reset comes.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. This block needs to be written as many times as it's needed in order for the initialization to
        fill an initialization buffer with all the block infos of this block, in order to force the
    02. Set the initial test result
    03. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    04. Perform Startup1
    05. Write a block multiple times, until there would be space for only one block info in the init buffer
    06. Invalidate a block. This block info will be the first in the init buffer during caching.
    07. Write the same block.
    08. Write 2 blocks that must be found by Fee startup.
    09. Perform Startup2
    10. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    11. Save the current Active section
    12. Read the blocks and check their consistency
    13. Fill one section at a time by writing a different block, until Fee enters switch.
    14. Get over the delay timer(&gt;2 sections)
    15. Monitor the section index.
    16. Update the oldest section index
    17. Wait for Fee to switch the block that has also an older invalidated instance
    18. Simulate RESET
    19. Perform initialization, (Startup1)
    20. Read the blocks and validate them once more.
    21. Check for flash errors
    22. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInfosSearch</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>841</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1188</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_CacheAll_InvalidatedCopied</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Switch_3Sections/source/application/Tests.c</sourcefile>
      <sourceline>1758</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether Fee will find all the blocks during init, even though they are written after a block is invalidated,
  and then copied before a reset comes.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. This block needs to be written as many times as it's needed in order for the initialization to
        fill an initialization buffer with all the block infos of this block, in order to force the
    02. Set the initial test result
    03. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    04. Perform Startup1
    05. Write a block multiple times, until there would be space for only one block info in the init buffer
    06. Invalidate a block. This block info will be the first in the init buffer during caching.
    07. Write 2 blocks that must be found by Fee startup.
    08. Perform Startup2
    09. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    10. Save the current Active section
    11. Read the blocks and check their consistency
    12. Fill one section at a time by writing a different block, until Fee enters switch.
    13. Get over the delay timer(&gt;2 sections)
    14. Monitor the section index.
    15. Update the oldest section index
    16. Wait for Fee to switch the invalidation of the block
    17. Simulate RESET
    18. Perform initialization, (Startup1)
    19. Read the blocks and validate them once more.
    20. Check for flash errors
    21. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInfosSearch</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>841</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1189</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_NoConfInvalidatedBlock_Sections3</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Switch_3Sections/source/application/Tests.c</sourcefile>
      <sourceline>1946</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether Fee will find all the blocks during init, even though they are written after a block is invalidated
  and then a reset comes, and the configuration changes so that the Id of block is not in the configuration any more.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. This block needs to be written as many times as it's needed in order for the initialization to
        fill an initialization buffer with all the block infos of this block, in order to force the
    02. Set the initial test result
    03. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    04. Perform Startup1
    05. Write a block multiple times, until there would be space for only one block info in the init buffer
    06. Invalidate a block. This block info will be the first in the init buffer during caching.
    07. Simulate a reconfiguration by changing the Id of the invalidated block
    08. Write 2 blocks that must be found by Fee startup.
    09. Simulate RESET
    10. Perform initialization, (Startup1)
    11. Read the blocks and validate them once more.
    12. Check for flash errors
    13. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInfosSearch</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>841</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1190</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_NoConfErasedBlock_Sections3</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Switch_3Sections/source/application/Tests.c</sourcefile>
      <sourceline>2073</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether an erase immediate will not cause flash to be overwritten because of wrong data address update.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. This block needs to be written as many times as it's needed in order for the initialization to
        fill an initialization buffer with all the block infos of this block, in order to force the
    02. Set the initial test result
    03. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    04. Perform Startup1
    05. Write a block multiple times, until there would be space for only one block info in the init buffer
    06. Erase a block. This block info will be the first in the init buffer during caching.
    07. Simulate a reconfiguration by changing the Id of the invalidated block
    08. Simulate RESET
    09. Perform initialization, (Startup1)
    10. Write a block and the write shall not fail because of memory overlap
    11. Check for flash errors
    12. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.NoFlashPageOverriden</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>222</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1191</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_Fee_Switch_OnlyOldSection</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Switch_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>62</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch works correctly and switches only one section at a time. 
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform initialization, (Startup1 and Startup2)
    04. Now all the sections shall be valid and empty. Get the empty space value in a section.
    05. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill the Active section and go to the second section
    08. Monitor the section index.
    09. Get over the delay timer
    10. Exclusively write a block in the second section
    11. Fill one section at a time by writing a different block, until Fee enters switch.
    12. Perform the switch.
    13. Erase all the sections except the current Active section.
    14. Check that the block in the second section were not copied at first switch
    15. Check for flash errors
    16. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.CopyBlocks</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>895</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1192</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_RevalidateOldSection_AllBlocks</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Switch_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>246</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Perform revalidate section test with all the blocks written at least once
&lt;para&gt;
Tests whether the section switch works correctly and after the section is copied 
the section is revalidated.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write all the blocks. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block, until Fee gets round to the same Active section index
        By then the section shall be empty and consistent.
    08. Exclusively write/invalidate blocks in the section that was supposed to be revalidated by switch.
    09. Simulate RESET
    10. Perform initialization, (Startup1)
    11. Read the exclusive blocks and validate them.
    12. Check for flash errors
    13. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.RevalidateOldSection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>896</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1193</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_HP_ImmediatelyAfterInit_AllBlocks</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Switch_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>395</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch is triggered correctly even in highest priority.
This test is simulating all the blocks are present in flash 
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write all the configured blocks. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block. Keep writing the block until Fee enters high priority switch.
    08. Perform a switch step.
    09. Simulate RESET
    10. Request a read that after completion shall resume high priority switch
    11. Finish the read request
    12. Get over the delay timer
    13. Check that high priority switch is started.
    14. Start the high priority switch
    15. Request one more read that shall not interrupt the high priority switch
    16. Go to the first flash read operation. It should be a switch read.
    17. Perform the high priority switch
    18. Finish the read job
    19. Perform the switch
    20. Erase all the sections except the current Active section.
    21. Check for flash errors
    22. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.11</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>831</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup2.07</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>856</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1194</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_JobInterrupts_1_4s</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Switch_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>602</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch behaves correctly if interrupted by user job requests. 
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block, until Fee enters switch.
    08. Take the current free space in the active section after only one block copied.
    09. The block info of the invalidated block is copied here
    10. Request a write that interrupts the switch right after a switch block info has been done.
    11. The second block switch starts by copying block info
    12. Request a write that interrupts the switch right after a switch block info has been done.
    13. Until Switch performs read data
    14. Fee has requested a read data (first buffer) for the block that is being switched
    15. Request a write that interrupts the switch right after a switch read data has been done.
    16. Until Switch performs write data
    17. Finish the write of the first buffer. (this is a case of a big block, but it should work for a small block too,
        since the block switching is not finished until the written marker is completed)
    18. Request a write that interrupts the switch right after a switch data write has been done.
    19. Get over the delay timer
    20. Finish the switch.
    21. Check that switch resumed the data writing of the block that was being switched instead of restarting it.
        Now that the switch is over the occupied size in active section shall be
        by the switched blocks and the block that interrupted the switch, taken only once.
    22. Check that the switch had finished indeed.
    23. Check for flash errors
    24. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.Behaviour.SSResume.BlockSwitching.Writing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>901</internalId></provcov>
        <provcov>
          <linksto>Fee.SS.UserJobRequests</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>260</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1195</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_SwitchPriority_2_4s</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Switch_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>845</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch works correctly in highest priority regarding comming jobs. 
  It also tests that any section change during Startup2 puts Fee in highest internal priority if the next section is not Empty.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Start Startup1 but do not finish it
    04. Request some jobs. Startup1 shall continue and finish before performing the jobs.
        Also as part of Startup2 one section is validated. Startup2 is not finished. All the other sections must be erased.
    05. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    06. Fill one section at a time by writing a different block. Keep writing the block until Fee enters high priority switch directly from Startup2
    07. Any job that triggers section change puts Fee in highest internal priority.
        Check that the next state triggered by high priority Startup2 is Erase
    08. A high priority switch has started.
        Perform a couple of switch steps.
    09. Finish the requested write that caused high priority switch.
    10. Check that when the write is over the switch is also over. Therefore the job must have been done after the switch.
    11. Erase all the sections except the current Active section.
    12. Check that the switch had finished indeed.
    13. Check for flash errors
    14. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.SwitchPriority</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>905</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup2.08</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>857</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1196</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_ReadNoTrigger_4s</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Switch_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>1009</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch is never triggered by read job request. 
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block, until Fee is write before entering switch.
    08. Read blocks that haven't been written. They shouldn't be found and they shall not trigger switch
    09. Read blocks that have been written. They should be found and they shall not trigger switch
    10. Check that Fee is in idle and the switch has not started
    11. Request a write that should trigger switch
    12. Get over the delay timer
    13. Check that Fee is in idle now
    14. Check for flash errors
    15. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.SS.TriggeringTheSwitch.ReadRequest</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>259</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1197</internalId></specobject>
    <specobject>
      <id>TS_Fee_SectionStatus_00</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Switch_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>1159</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This tests the Abort Erase functionality during an erase trigger by startup2 when in highest internal priority.
  A section erase shall not be aborted because the internal module is in highest internal priority.
&lt;/para&gt;

Test Object: Fee_DecideSectionStatus()
Test Precondition: 
  - The flash must be erased
  - Insturment header and footer to explore header/Footer combinations 
  - Section 0 Header erased / Footer Active inconsistent Expected Section Inconsistent 
  - Section 1 Header erased / Footer Erasable inconsistent Expected Section Inconsistent 
  - Section 2 Header Empty / Footer Active inconsistent Expected Section Active 
  - Section 3 Header Empty / Footer Inconsistent Expected Section Empty 

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Initialize StatusArrays
    04. initialize section 0
    05. initialize section 1 header
    06. initialize section 1 footer
    07. initialize section 2 Header Empty
    08. initialize section 2 Footer Active inconsistent
    09. initialize section 3 Header Empty
    10. initialize section 3 Footer Inconsistent
    11. Perform initialization, (Startup1 and Startup2)
    12. Check section 1 status
    13. Check section 2 status
    14. Check section 3 status
    15. Set test case result

Test Input: 
  None.

Test Output: 
  The cancelation of each request must be done successfully.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.03</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>824</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.Startup1.BothSectionManagementObjectsFailed</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>923</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.07</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>827</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1198</internalId></specobject>
    <specobject>
      <id>TS_Fee_SectionStatus_01</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Switch_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>1363</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This tests the Abort Erase functionality during an erase trigger by startup2 when in highest internal priority.
  A section erase shall not be aborted because the internal module is in highest internal priority.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  - The flash must be erased
  - Insturment header and footer to explore header/Footer combinations
  - Section 0 Header erased / Footer Active inconsistent Expected Section Inconsistent
  - Section 1 Header erased / Footer Erasable inconsistent Expected Section Inconsistent
  - Section 2 Header Empty / Footer Active inconsistent Expected Section Active
  - Section 3 Header Empty / Footer Inconsistent Expected Section Empty

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Initialize StatusArrays
    04. initialize section 0 Header
    05. initialize section 0 Footer
    06. initialize section 1 header
    07. initialize section 1 footer
    08. initialize section 2 Header Erasable
    09. initialize section 2 Footer Active inconsistent
    10. initialize section 3 Header Erasable inconosistent
    11. initialize section 3 Footer Inconsistent
    12. Perform initialization, (Startup1 and Startup2)
    13. Check section 1 status
    14. Check section 2 status
    15. Check section 3 status
    16. Set test case result

Test Input: 
  None.

Test Output: 
  The cancelation of each request must be done successfully.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.03</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>824</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.Startup1.BothSectionManagementObjectsFailed</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>923</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.07</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>827</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.BlankCheck.ErasableBitFlip</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>963</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1199</internalId></specobject>
    <specobject>
      <id>TS_Fee_SectionStatus_02</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Switch_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>1583</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  ???
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  - The flash must be erased
  - Insturment header and footer to explore header/Footer combinations
  - Section 0 Header Section Inconsistent / Footer Empty Expected Empty
  - Section 1 Header Section Inconsistent / Footer Erasable Expected Erasable

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Initialize StatusArrays
    04. initialize section 0 Header
    05. initialize section 0 Footer
    06. initialize section 1 header
    07. initialize section 1 footer
    08. Perform initialization, (Startup1 and Startup2)
    09. Check section 1 status
    10. Set test case result

Test Input: 
  None.

Test Output: 
  The cancelation of each request must be done successfully.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.03</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>824</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.FailureHandling.Behaviour.Startup1.BothSectionManagementObjectsFailed</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>923</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.07</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>827</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1200</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_Inconsistent_InTheMiddle</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Switch_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>1721</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether Fee does not lose blocks during high priority switch (continuous over 3 sections) when 
  init founds an inconsistent section surrounded by full and consistent sections right before Fee enters
  in high priority switch.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Fill the section
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Keep writing the block until Fee is right before high priority switch.
    08. Corrupt second section, which is sarounded by 2 consistent and full sections
    09. Simulate RESET
    10. This job triggers high priority switch
	11. Check that this last job always trigger the highest priority erase
    12. Finish the switch
    13. Check that the switch had finished indeed.
    14. Check that the block that filled the first section is not lost
    15. Check that the block that filled the third section is not lost
    16. Check that the block that filled the second section is not lost, because the second section got corrupted
    17. Check for flash errors
    18. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup2.07</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>856</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.SS.SwitchPriority</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>905</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.SS.ErasePriority</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>906</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1201</internalId></specobject>
    <specobject>
      <id>TS_Fee_SectionUpperHalfErased</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Switch_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>1942</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests the following scenario:
  - Write a couple of blocks in the first section, then fill the section;
  - Write one of these blocks in the second section (this block, X, will not be written again), then fill the section;
  - Request writes until Fee enters in high priority switch; the switch will not switch block X;
  - Simulate failure for footer marking for erase;
  - Simulate partial erase of the first section (contains block X); only the first half of the section is erased (block X data);
  - Simulate corruption for second section;
  - Simulate reset;
  - Check that Fee init won't find block X, even though the block info is valid in the first section, but no more data;
  It would have been problematic if Fee had considered the block as consistent and gave wrong data to NvM;
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Fill the section
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Keep writing the block until Fee is right before high priority switch.
    08. Let Fls terminate its current job
    09. Corrupt second section, which is sarounded by 2 consistent and full sections
    10. Wait until Fee is marking the oldest section for erase in footer, after finishing the high priority switch
    11. Finish the header marking for erase
    12. Simulate a Fls refusal while Fls is not busy
    13. Wait until Fee is trying to erase the section without being marked for erase in footer
    14. Unlock Fls
    15. Erase only the first part of the section. (just like a reset interrupted it)
    16. Simulate RESET
    17. Check that all the blocks are consistent, except the block that was not switched because its last instance
        was found in the second section that will have got corrupted. The block have its block info valid
        in the first section though
    18. Check for flash errors
    19. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInfos.03</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>838</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup2.06</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>855</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1202</internalId></specobject>
    <specobject>
      <id>TS_Fee_InitBlockErasedInFirstSection</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Switch_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>2174</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether Fee caches all the blocks in case an immediate block is written and erased in the first section.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Memorize the Active section index and verify that all the other sections are empty.
        All sections shall be empty now, except the Active section)
    05. Keep writing until there is no more space to write but in the last section
    06. Write the block to be found. This block will not be present in the first section
    07. Finish the switch
    08. Fill the last section
    09. This block will be written in the first section.
    10. Write and invalidate an immediate block in the first section
    11. Write all the blocks except one, which is present in the previous section.
        The immediate block is written again.
    12. Simulate RESET
    13. Check that all the blocks are cached at startup.
    14. Check that the block that is written in the last section is also found.
    15. Check for flash errors
    16. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInfoCacheIfNewer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>849</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.CacheInit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>839</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlockInfoFound</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>844</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.BlocksSearchStop.SwNotConfigBlocksOFF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>847</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1203</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_RepairInBetween</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Switch_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>2349</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests that an inconsistent section preceded and followed by active sections is not repaired at Startup2,
  but let for Section Switch to do it when the time comes. Fee will have to find the correct most recent
  Active section in this situation, also the correct oldest section.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
  01. Set the initial test result
  02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
  03. Initialize StatusArrays
  04. Generate header and footer the the only active section in the current iteration
  05. Write a block in order to finish the Startup
  06. Get over the delay timer
  07. Finish initialization, (Startup2)
  08. Start with the first Active section (the oldest/reference one)
  09. Fill one section at a time by writing the same block, until Fee enters switch.
  10. Fill the section with the block specific to this section index
  11. Change the section by writing the block specific to the next section index
  12. Monitor the section index.
  13. Get over the delay timer
  14. Erase the second active section in the current iteration to simulate
       an inconsistent active section preceded and followed by consistent active sections.
  15. Simulate reset
  16. Request a read job in order to unlock Fee (that is waiting indefinitely after Startup1)
  17. Process the read job
  18. Get over the delay timer and a cycle for Fee to change the mode.
  19. Check that Fee doesn't get to Startup2 mode in order to repair the inconsistent section,
       but let the Section Switch do it when the time comes.
  20. Simulate reset again as an extra measure of stressing Fee
  21. Check that Fee found the latest instance of the only block written
  22. Check for flash errors
  23. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup2.01</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>850</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.09</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>829</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.10</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>830</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1204</internalId></specobject>
    <specobject>
      <id>TS_Fee_Init_CorruptedSectionNotEmpty_First</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Switch_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>2550</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether Fee does not consider the corrupted section as Empty in case:
  - After a section switch, the writing of the erasable marker in the footer fails without writing anything in the NVRAM.
  - A reset comes during the process of erasing the section marked for erase in the header,
    in such a way that the header is erased, but not the footer.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  The corrupted section has the highest index.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write all the blocks. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Save the current Active section
    08. Fill one section at a time by writing a different block,
        until Fee gets round back to having the section 0 as the active section.
        This means that the oldest section is section with index 3.
    09. Monitor the section index.
    10. Get over the delay timer
    11. Perform the switch if needed.
    12. Perform one more switch cycle in order to have the oldest section index 0
    13. Get over the delay timer
    14. Perform the switch if needed.
    15. Fill the current active section S1
    16. Wait until Fee is marking the oldest section for erase in footer S3
        (this happens after switching the S0 to S2)
    17. Simulate the failure of the ERASABLE marker. It's also noting written.
    18. Wait until Fee is starting to erase the oldest section S0
    19. Run a cycle of MFs in order to erase the header of the oldest section S0
    20. Simulate RESET
    21. Perform initialization, (Startup1)
    22. Check section 2 status
    23. Check section 3 status
    24. Check section 0 status
    25. Fill the current active section S2
    26. Write a block in section S3, in order to have 3 active sections
    27. Check that section 0 is still inconsistent
    28. Simulate RESET
    29. Perform initialization, (Startup1)
    30. Check that section 0 is still inconsistent
    31. Write a block in order to start Startup2
    32. Get over the delay timer
    33. Perform the switch.
    34. Check that the switch had finished indeed.
    35. Check for flash errors
    36. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.13</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>833</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.14</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>834</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1205</internalId></specobject>
    <specobject>
      <id>TS_Fee_Init_CorruptedSectionNotEmpty_Last</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Switch_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>2836</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether Fee does not consider the corrupted section as Empty in case:
  - After a section switch, the writing of the erasable marker in the footer fails without writing anything in the NVRAM.
  - A reset comes during the process of erasing the section marked for erase in the header,
    in such a way that the header is erased, but not the footer.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  The corrupted section has the highest index.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write all the blocks. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Save the current Active section
    08. Fill one section at a time by writing a different block,
        until Fee gets round back to having the section 0 as the active section.
        This means that the oldest section is section with index 3.
    09. Monitor the section index.
    10. Get over the delay timer
    11. Perform the switch if needed.
    12. Fill the current active section S0
    13. Wait until Fee is marking the oldest section for erase in footer S3
        (this happens after switching the S3 to S1)
    14. Simulate the failure of the ERASABLE marker. It's also noting written.
    15. Wait until Fee is starting to erase the oldest section S3
    16. Run a cycle of MFs in order to erase the header of the oldest section S3
    17. Simulate RESET
    18. Perform initialization, (Startup1)
    19. Check section 1 status
    20. Check section 2 status
    21. Check section 3 status
    22. Fill the current active section S1
    23. Write a block in section S2, in order to have 3 active sections
    24. Check that section 3 is still inconsistent
    25. Simulate RESET
    26. Perform initialization, (Startup1)
    27. Check that section 3 is still inconsistent
    28. Write a block in order to start Startup2
    29. Get over the delay timer
    30. Perform the switch.
    31. Check that the switch had finished indeed.
    32. Check for flash errors
    33. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.13</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>833</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.14</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>834</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1206</internalId></specobject>
    <specobject>
      <id>TS_Fee_SectionCounterOverflow_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Switch_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>3101</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Verifies that when the section counter overflow occurs, 255 -&gt; 0, and the section with counter 0 is only filled with blocks that exist
  in the section with counter 255, the blocks from section with counter 0 are not lost, and Fee behaves normally.
  For section order see precondition.
&lt;/para&gt;

Test Object: Fee_DecideSectionStatus()
Test Precondition: 
  - The flash must be erased
  - Insturment header and footer to explore header/Footer combinations 
  - Section 0 Inconsistent
  - Section 1 Inconsistent
  - Section 2 Inconsistent
  - Section 3 Active with counter 255

Test Execution: 
  01. Set the initial test result
  02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
  03. Simulate the section 3 as Active with counter 255
  04. Perform Startup2
  05. Write the blocks that we don't want to lose with the first values.
  06. Fill the section and transition to the new section
  07. Write a block in the new active section, the one with counter 0
  08. Write the blocks that we don't want to lose with the new values.
  09. Simulate RESET
  10. Perform initialization, (Startup1)
  11. Read the exclusive blocks and validate them. The new values should be read.
  12. Set test case result

Test Input: 
  None.

Test Output: 
  No blocks are lost.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.09</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>829</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.10</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>830</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1207</internalId></specobject>
    <specobject>
      <id>TS_Fee_SectionCounterOverflow_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Switch_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>3244</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Verifies that when the section counter overflow occurs, 255 -&gt; 0, and the section with counter 0 contains at least one block that doesn't exist
  in the section with counter 255, Fee doesn't lose the blocks from the section with counter 255 by erasing it.
  For section order see precondition.
&lt;/para&gt;

Test Object: Fee_DecideSectionStatus()
Test Precondition: 
  - The flash must be erased
  - Insturment header and footer to explore header/Footer combinations 
  - Section 0 Inconsistent
  - Section 1 Inconsistent
  - Section 2 Inconsistent
  - Section 3 Active with counter 255

Test Execution: 
  01. Set the initial test result
  02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
  03. Simulate the section 3 as Active with counter 255
  04. Perform Startup2
  05. Write the blocks that we don't want to lose with the first values.
  06. Write a block that only exists in section with counter 255.
  07. Fill the section and transition to the new section
  08. Write a block in the new active section, the one with counter 0
  09. Write the blocks that we don't want to lose with the new values.
  10. Write a block that only exists in section with counter 0.
  11. Simulate RESET
  12. Perform initialization, (Startup1)
  13. Read a block to start Section Switch.
  14. Get over the delay timer
  15. Finish the switch
  16. All the blocks should be found
  17. Set test case result

Test Input: 
  None.

Test Output: 
  No blocks are lost.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.09</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>829</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.10</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>830</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1208</internalId></specobject>
    <specobject>
      <id>TS_Fee_SectionCounterOverflow_3</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Switch_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>3423</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Verifies that when the section counter overflow occurs, 255 -&gt; 0, and the section with counter 0 is only filled with blocks that exist
  in the section with counter 255, the blocks from section with counter 0 are not lost, and Fee behaves normally.
  For section order see precondition.
&lt;/para&gt;

Test Object: Fee_DecideSectionStatus()
Test Precondition: 
  - The flash must be erased
  - Insturment header and footer to explore header/Footer combinations
  - Section 0 Active with counter 255
  - Section 1 Inconsistent
  - Section 2 Inconsistent
  - Section 3 Inconsistent

Test Execution: 
  01. Set the initial test result
  02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
  03. Simulate the section 0 as Active with counter 255
  04. Perform Startup2
  05. Write the blocks that we don't want to lose with the first values.
  06. Fill the section and transition to the new section
  07. Write a block in the new active section, the one with counter
  08. Write the blocks that we don't want to lose with the new values.
  09. Simulate RESET
  10. Perform initialization, (Startup1)
  11. Read the exclusive blocks and validate them. The new values should be read.
  12. Set test case result

Test Input: 
  None.

Test Output: 
  No blocks are lost.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.09</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>829</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.10</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>830</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1209</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_Fee_Switch_SmallSections</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Switch_Small_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>81</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch works correctly when FeeEnableSmallSectionSize is enabled.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform initialization, (Startup1 and Startup2)
    04. Write all block once writing the block id in the first byte of the data
    05. Write all block once writing the block id in the first byte of the data
    06. Write all block once writing the block id in the first byte of the data
    07. Write all block once writing the block id in the first byte of the data
    08. VP: Simulate ECU reset and make sure the initialization is done correctly
    09. VP: Read all the blocks and make sure the block ID stored in the data is read correctly
    10. Check for flash errors
    11. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeEnableSmallSectionSize.Size</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>298</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeEnableSmallSectionSize.Enable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>297</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1210</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_SmallSections_Retry</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Implementation/IN/Fee_ImpTest_Switch_Small_4Sections/source/application/Tests.c</sourcefile>
      <sourceline>173</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch works correctly when FeeEnableSmallSectionSize is enabled
  with multiple reset scenario.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform initialization, (Startup1 and Startup2)
    04. Write all block once writing the block id in the first byte of the data
    05. VP: Simulate ECU reset and make sure the initialization is done correctly
    06. Write all block once writing the block id in the first byte of the data
    07. VP: Simulate ECU reset and make sure the initialization is done correctly
    08. Write all block once writing the block id in the first byte of the data
    09. VP: Simulate ECU reset and make sure the initialization is done correctly
    10. Write all block once writing the block id in the first byte of the data
    11. VP: Simulate ECU reset and make sure the initialization is done correctly
    12. VP: Read all the blocks and make sure the block ID stored in the data is read correctly
    13. Check for flash errors
    14. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeEnableSmallSectionSize.Size</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>298</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeEnableSmallSectionSize.Enable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>297</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1211</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_FEE_30031</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Conformance_Common/source/application/GetVersionInfo_test.c.m4</sourcefile>
      <sourceline>44</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
To test the Fee GetVersionInfo API with valid pointer as parameter
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 
  Initialize the flash, Nvm and Det stubs if configured.
  Set the Version information values to invalid value before the call of Fee_GetVersionInfo.
  Call Fee GetVersionInfo with a valid address.
  Check the version parameters.

Test Input: 
None

Test Output: 
The version information returned are those that are configured/hardcoded in
the module.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00093</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>130</internalId></provcov>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00064</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>34</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1212</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_FEE_30001</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Conformance_Common/source/application/Tests.c</sourcefile>
      <sourceline>48</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Testing the Fee_Init functionality.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
FEE is not initialized.

Test Execution: 

Note: Unless otherwise stated, whenever an Fee Job is requested, Fee_MainFunction and
Fls_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize flash driver and test stubs for Nvm and Det if configured.
  Erase flash memory.
  Check the status of Fee is MEMIF_UNINIT.

Initialize FEE:
  Initialize Fee module by calling Fee_Init.
  Check the status of Fee is not MEMIF_UNINIT.
  Wait till the initialization is complete.
  Check the status of Fee is MEMIF_IDLE.

Check the Nvm notification calls and DET errors if configured.
Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 
None

Test Output: 

On Init test:
  Fee_GetStatus returns MEMIF_UNINIT.

After FEE initialization:
  Fee_GetStatus shall not return MEMIF_UNINIT.

Nvm Job error Notification and Nvm Job End Notification are not called.
Det error is reported once if configured.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00085</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>38</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00034</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>101</internalId></provcov>
        <provcov>
          <linksto>Fee.FreezeActivities.API</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>273</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1213</internalId></specobject>
    <specobject>
      <id>TS_FEE_TestStatusUninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Conformance_Common/source/application/Tests.c</sourcefile>
      <sourceline>181</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Testing Fee_GetStatus() to retrieve the FEE status MEMIF_UNINIT.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
FEE is not initialized.

Test Execution: 

Status before initialization:
  Initialize flash driver and test stubs for Nvm and Det if configured.
  Check the status by calling Fee_GetStatus().
  Check that Fls_GetStatus is not called.

Check the Nvm notification calls and DET errors if configured.
Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 

Test Output: 

Status before initialization:
  The Fee_GetStatus() returns MEMIF_UNINIT.
  Fls_GetStatus is not called.

Nvm Job End Notification is not called.
Nvm Job Error Notification is not called.
Det error is reported once if configured.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00090</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>127</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1214</internalId></specobject>
    <specobject>
      <id>TS_FEE_TestStatusResults</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Conformance_Common/source/application/Tests.c</sourcefile>
      <sourceline>270</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Testing Fee_GetStatus() to retrieve the different possible FEE status except MEMIF_UNINIT.
(MEMIF_BUSY_INTERNAL shall be tested under implementation tests).
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None.

Test Execution: 

Status after initialization:
  Initialize flash driver and test stubs for Nvm and Det if configured.
  Erase the flash.
  Call Fee_Init().
  Check the status by calling Fee_GetStatus().
  Check that Fls_GetStatus is not called.

Status when a write job is called:
  Call Fee_Write() with valid block number.
  Check the status by calling Fee_GetStatus().
  Check that Fls_GetStatus is not called.

Status after write job is complete:
  Wait till the write job is complete.
  Check the status by calling Fee_GetStatus().
  Check that Fls_GetStatus is not called.

Check the Nvm notification calls and DET errors if configured.
Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 

Test Output: 

Status after initialization:
  The Fee_GetStatus() shall not return MEMIF_UNINIT.
  Fls_GetStatus is not called.

Status when a write job is called:
  The Fee_GetStatus() returns MEMIF_BUSY.
  Fls_GetStatus is not called.

Status after write job is complete:
  The Fee_GetStatus() returns MEMIF_IDLE.
  Fls_GetStatus is not called.

Nvm Job End Notification is called once.
Nvm Job Error Notification is not called.
No Det error is reported if configured.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00128</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00129</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>148</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1215</internalId></specobject>
    <specobject>
      <id>TS_FEE_30002</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Conformance_Common/source/application/Tests.c</sourcefile>
      <sourceline>444</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Testing block read for a block which has not been written.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Fee Job is requested, Fee_MainFunction and
Fls_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize flash driver and test stubs for Nvm and Det if configured.

Read data:
  Request read.
  
Prepare test scenario:
  Erase the flash.
  Initialize Fee module.

Read data:
  Read a block from the flash that has not been written.

Verify read:
  Check the Fee status and job result after the completion of the read job.

Check the Nvm notification calls and DET errors if configured.
Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 
None

Test Output: 

Read data:
  Request read =&gt; Returns NOt_OK because the module is not initalized.
  
On Init:
  The return of initialization need not be verified since initialization is already tested.

On test scenario preparation:
  Both sections of the flash are erased.

On Read data:
  Fee_Read returns E_OK

 
On verification of read:
  Fee_GetJobResult returns MEMIF_BLOCK_INCONSISTENT.
  Fee_GetStatus returns MEMIF_IDLE.
  Nvm Job error Notification is called once.
  Nvm Job End Notification is not called.
  No Det errors reported if configured.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00023</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>97</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00022</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>96</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00073</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>115</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00056</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>109</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00087</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>124</internalId></provcov>
        <provcov>
          <linksto>Fee.FreezeActivities.API</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>273</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1216</internalId></specobject>
    <specobject>
      <id>TS_FEE_30003</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Conformance_Common/source/application/Tests.c</sourcefile>
      <sourceline>590</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Testing the Fee read functionality.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Fee Job is requested, Fee_MainFunction and
Fls_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize flash driver and test stubs for Nvm and Det if configured.
  Erase flash memory
  Initialize Fee module.

Prepare test scenario:
  Write a block of data into the flash.
  Wait till the block is written completely.

Read data:
  Read the same block written before, from the flash.

Verify Read:
  Check the Fee status and job result just after read.
  Check the Fee status after the completion of the read job.
  Check Fls_Read() is called.
  Compare source and destination buffers for equality.

Check the Nvm notification calls and DET errors if configured.
Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 
None

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On test scenario preparation:
  Write function should return E_OK.

On Read data :
  Read function should return E_OK.

On Verification of read :
  After read call Fee_GetStatus should return MEMIF_BUSY and Fee_GetJobResult should return
  MEMIF_JOB_PENDING.
  On completion of read Fee_GetStatus should return MEMIF_IDLE and Fee_GetJobResult should
  return MEMIF_JOB_OK.
  Fls_Read() is called at least once.
  The source and destination buffers should be equal.

Nvm Job End Notification is called twice.
No Det errors are reported if configured.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00022</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>96</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00172</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>180</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00073</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>115</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00055</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>108</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00087</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>124</internalId></provcov>
        <provcov>
          <linksto>Fee.FreezeActivities.API</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>273</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1217</internalId></specobject>
    <specobject>
      <id>TS_FEE_30030</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Conformance_Common/source/application/Tests.c</sourcefile>
      <sourceline>771</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Testing the Fee write functionality.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Fee Job is requested, Fee_MainFunction and
Fls_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize flash driver and test stubs for Nvm and Det if configured.
  Erase flash memory.
  Initialize Fee module.

Write data:
  Write a block of data into the flash.

Verify Write:
  Check the Fee status and job result just after write call.
  Check the Fee status after the completion of the write job.
  Check Fls_Write() is called.

Check the Nvm notification calls and DET errors if configured.
Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 
None

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On Write data:
  Write function should return E_OK.

On verification of write:
  After write call Fee_GetStatus should return MEMIF_BUSY and Fee_GetJobResult should return
  MEMIF_JOB_PENDING.
  On completion of write Fee_GetStatus should return MEMIF_IDLE and Fee_GetJobResult should
  return MEMIF_JOB_OK.
  Fls_Write is called at least once.

Nvm Job End Notification is called once.
No Det errors are reported if configured.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00025</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>99</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00174</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>181</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00026</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>100</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00055</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>108</internalId></provcov>
        <provcov>
          <linksto>Fee.FreezeActivities.API</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>273</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1218</internalId></specobject>
    <specobject>
      <id>TS_FEE_30004</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Conformance_Common/source/application/Tests.c</sourcefile>
      <sourceline>921</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Testing the Fee_InvalidateBlock functionality and read the invalidate block.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Fee Job is requested, Fee_MainFunction and
Fls_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize flash driver and test stubs for Nvm and Det if configured.
  Erase flash memory.

 Call Fee_InvalidateBlock
   Check the Fee status and job result just after invalidate function call.

  Initialize Fee module.

Write data:
  Write a block of data into the flash.
  Check the Fee status.

Read Data after write:
  Read flash with same block number written before.
  Check the Fee status and job result after the completion of the read job.
  Compare source and destination buffers for equality.

Invalidate the block:
  Invalidate the block which is written.
  Check the Fee status and job result just after invalidate function call.
  Check the Fee status and job result after the completion of the invalidate job.

Read Data after invalidate:
  Read flash with same block number invalidated before.
  Check the Fee status and job result after the completion of the read job.

Check the Nvm notification calls and DET errors if configured.
Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 
None

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On Call Fee_InvalidateBlock:
  The request shall be rejected, Fee_InvalidateBlock returns E_NOT_OK and shall not change 
  the current module status or job result.
  
On Write data:
  Write function should return E_OK.
  On completion of write job, GetStatus function should return MEMIF_IDLE and
  GetJobResult should return MEMIF_JOB_OK.

On read data after write:
  Read function should return E_OK.
  On completion of read job, Fee status should return MEMIF_IDLE and GetJobResult
  should return MEMIF_JOB_OK.
  The source and destination buffers should be equal.

On Invalidate the block:
  Invalidate function should return E_OK
  After invalidate Fee_GetStatus should return MEMIF_BUSY and Fee_GetJobResult should return
  MEMIF_JOB_PENDING
  On completion of invalidate job, Fee_GetStatus should return MEMIF_IDLE and GetJobResult return
  MEMIF_JOB_OK.

On read data after invalidate:
  Read function should return E_OK.
  On completion of read job, Fee status should return MEMIF_IDLE and GetJobResult
  should return MEMIF_BLOCK_INVALID.
  
On Invalidate the block (the second one):
  Invalidate function should return E_OK
  After invalidate Fee_GetStatus should return MEMIF_BUSY and Fee_GetJobResult should return
  MEMIF_JOB_PENDING
  On completion of invalidate job, Fee_GetStatus should return MEMIF_IDLE and GetJobResult return
  MEMIF_JOB_OK.
  This second invalidation is only processed at Fee level.

Nvm Job End Notification is called thrice.
Nvm Job Error Notification is called once.
No Det errors are reported if configured.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00055</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>108</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00092</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>129</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00056</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>109</internalId></provcov>
        <provcov>
          <linksto>Fee.FreezeActivities.API</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>273</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1219</internalId></specobject>
    <specobject>
      <id>TS_FEE_30007</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Conformance_Common/source/application/Tests.c</sourcefile>
      <sourceline>1225</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Testing the Fee_Cancel functionality during a read job.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None.

Test Execution: 

Note: Unless otherwise stated, whenever an Fee Job is requested, Fee_MainFunction and
Fls_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize flash driver and test stubs for Nvm and Det if configured.
  Erase flash memory.
  Initialize Fee module.

Prepare test scenario:
  Write a block of data into the flash.
  Check the Fee status and job result after the completion of the write job.
  Read flash with same block number(main functions are not called here).

Cancel the read operation:
  Call Cancel.

Verify read(The operation which is cancelled):
  Check the Fee status and the Job Result.

Read data :
  Read flash with same block number.
  Check the Fee status and job result just after read call.
  Check the Fee status and job result after the completion of the read job.
  Compare source and destination buffers for equality.

Check the Nvm notification calls and DET errors if configured.
Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 
None

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On test scenario preparation:
  Write function should return E_OK.
  Fee Status should be MEMIF_IDLE.
  Job Result should be MEMIF_JOB_OK.
  Read function should return E_OK

On Cancel of read operation:
  After cancellation Fee status should not be MEMIF_BUSY and
  Job Result should be MEMIF_JOB_CANCELED.

On Read data:
  Read function should return E_OK
  After read call Fee_GetStatus should return MEMIF_BUSY and Fee_GetJobResult should return
  MEMIF_JOB_PENDING.
  On completion of read Fee_GetStatus should return MEMIF_IDLE and Fee_GetJobResult return
  MEMIF_JOB_OK.
  Read/write buffer comparison should be successful.

Nvm Job End Notification is called twice
Nvm Job Error Notification is called once
No Det errors are reported if configured.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00089</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>126</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00081</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00056</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>109</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1220</internalId></specobject>
    <specobject>
      <id>TS_FEE_30008</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Conformance_Common/source/application/Tests.c</sourcefile>
      <sourceline>1428</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Testing the Fee_Cancel functionality while invalidating a block.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Fee Job is requested, Fee_MainFunction and
Fls_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize flash driver and test stubs for Nvm and Det if configured.
  Erase flash memory.
  Initialize Fee module.

Prepare test scenario:
  Write a block to the flash.
  Wait till the job is complete.
  Invalidate the block which is written.(Do not call Main Functions)

Cancel the invalidation operation:
  Call Cancel.

Verify Invalidation(The operation which is canceled):
  Check the Fee status and Job Result.

Check the Nvm notification calls and DET errors if configured.
Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 
None

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On test scenario preparation:
  Write function should return E_OK.
  Job Result should be MEMIF_JOB_OK.
  Invalidate function should return E_OK.

On Cancel the invalidate operation:
  After cancellation Fee status should not be MEMIF_BUSY and
  Job Result should be MEMIF_JOB_CANCELED.

Nvm Job End Notification is called once.
Nvm Job Error Notification is called once.
No Det errors are reported if configured.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00089</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>126</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00081</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00056</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>109</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00193</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>190</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1221</internalId></specobject>
    <specobject>
      <id>TS_FEE_30009</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Conformance_Common/source/application/Tests.c</sourcefile>
      <sourceline>1582</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Testing the Fee_EraseImmediateBlock functionality when module is idle.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Fee Job is requested, Fee_MainFunction and
Fls_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize flash driver and test stubs for Nvm and Det if configured.
  Erase flash memory.

  Call Erase immediate block.

  Initialize Fee module.

Erase immediate block:
  Call Fee_EraseImmediateBlock a logical block.
  Check the Fee status and job result after the completion of the Erase immediate block job.

Write data:
  Write a block of data into the flash.
  Check the Fee status and job result after the completion of the write job.

Check the Nvm notification calls and DET errors if configured.
Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 
None

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

  On Erase immediate block:
    Erase immediate block function should return E_NOT_OK.

(Call Fee_init)

On Erase immediate block:
  Erase immediate block function should return E_OK.
  Job Result should be MEMIF_JOB_OK.
  Status should not be MEMIF_BUSY.

On Write data:
  Write function should return E_OK
  On completion of write job, Job Result should return MEMIF_JOB_OK and
  Fee_GetStatus should return MEMIF_IDLE

Nvm Job End Notification is called twice.
Nvm Job Error Notification is not called.
No Det errors are reported if configured.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00094</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00055</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>108</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1222</internalId></specobject>
    <specobject>
      <id>TS_FEE_30014</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Conformance_Common/source/application/Tests.c</sourcefile>
      <sourceline>1756</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
To test the Fee_SetMode API with mode as parameter for both MEMIF_MODE_SLOW and MEMIF_MODE_FAST.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None.

Test Execution: 

Init test:
  Initialize flash driver.
  Erase flash memory.
Set Mode slow:
  Set the operation mode of the flash driver as MEMIF_MODE_SLOW.
  Check Fls_SetMode is called.
  Check the operation mode of the flash driver It should not change as Fee was not initialized.
Set Mode fast:
  Set the operation mode of the flash driver as MEMIF_MODE_FAST.
  Check Fls_SetMode is called.
  Check the operation mode of the flash driver. Fee was not initialized.

  Initialize Fee module.

Set Mode slow:
  Set the operation mode of the flash driver as MEMIF_MODE_SLOW.
  Check Fls_SetMode is called.
  Check the operation mode of the flash driver.

Set Mode fast:
  Set the operation mode of the flash driver as MEMIF_MODE_FAST.
  Check Fls_SetMode is called.
  Check the operation mode of the flash driver.

Set Mode slow while status is MEMIF_BUSY_INTERNAL:
  Set the operation mode of the flash driver as MEMIF_MODE_SLOW.
  Check Fls_SetMode is called.
  Check the operation mode of the flash driver.
  Note: MEMIF_BUSY_INTERNAL shall not be reported for 2 sections durring switch.
  
  Set Mode Fast while status is MEMIF_BUSY:
  Set the operation mode of the flash driver as MEMIF_MODE_SLOW.
  Check Fls_SetMode is called.
  Check the operation mode of the flash driver.

Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 
None

Test Output: 

Before Fee_Init, the module shall not change the mode of the flash driver 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On Set mode slow:
  Fls_SetMode is called, if it is available.
  Operation mode of the flash driver should be MEMIF_MODE_SLOW.

On Set mode fast :
  Fls_SetMode is called, if it is available.
  The operation mode of the flash driver should be MEMIF_MODE_FAST if
  Fls_SetMode is available, else MEMIF_MODE_SLOW.

On Set Mode slow while status is MEMIF_BUSY_INTERNAL:
  Check Fls_SetMode is  called, if it is available.
  Operation mode of the flash driver should be MEMIF_MODE_SLOW.
  
On Set Mode fast while status is MEMIF_BUSY:
  Check Fls_SetMode is  not called, even if it is available.
  Operation mode of the flash driver should be MEMIF_MODE_SLOW.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00190</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>187</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00086</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1223</internalId></specobject>
    <specobject>
      <id>TS_FEE_30015</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Conformance_Common/source/application/Tests.c</sourcefile>
      <sourceline>1997</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Testing the Fee_Write, Fee_Read, Fee_GetJobResult and Fee_GetStatus functionalities
to see behaviour on different combination of function calls.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Fee Job is requested, Fee_MainFunction and
Fls_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize flash driver and test stubs for Nvm and Det if configured.
  Erase flash memory.
  Initialize Fee module.

Write data:
  Write a block of data into the flash.
  Check the Fee status and job result just after write.
  Check the Fee status and job result after the completion of the write job.

Read data:
  Read flash with same block number written before.
  Check the Fee status and job result just after read.
  Check the Fee status and job result after the completion of the read job.
  Compare source and destination buffers for equality.

Check the Nvm notification calls and DET errors if configured.
Incase any of the above operation returns unexpected value, set result as failure.

Test Input: 
None

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On Write data:
  Write function should return E_OK.
  After write Fee_GetStatus should return MEMIF_BUSY and Fee_GetJobResult should return
  MEMIF_JOB_PENDING.
  On completion of write job i.e., Fee_GetJobResult no longer returns MEMIF_JOB_PENDING,
  Fee_GetStatus should return MEMIF_IDLE.

On Read data :
  Read function should return E_OK.
  After read Fee_GetStatus should return MEMIF_BUSY and Fee_GetJobResult should return
  MEMIF_JOB_PENDING.
  On completion of read job i.e., Fee_GetJobResult no longer returns MEMIF_JOB_PENDING,
  Fee_GetStatus should return MEMIF_IDLE.
  Read/write buffer comparison should be successful.

Nvm Job End Notification is called twice.
No Det errors are reported if configured.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00087</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>124</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1224</internalId></specobject>
    <specobject>
      <id>TS_FEE_TestJobResults</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Conformance_Common/source/application/Tests.c</sourcefile>
      <sourceline>2174</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Testing Fee_GetJobResult() to retrieve the different possible FEE Job Results.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 
Note: Unless otherwise stated, whenever an Fee Job is requested, Fee_MainFunction and
Fls_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize flash driver and test stubs for Nvm and Det if configured.
  Erase flash memory.
  Initialize Fee module.

JobResult when a invalidate job is called:
  Call Fee_InvaldateBlock() with valid block number.
  Check the job result by calling Fee_GetJobResult().
  Check that Fls_GetJobResult is not called.

JobResult after invalidate job is complete:
  Wait till the invalidate job is complete.
  Check the job result by calling Fee_GetJobResult().
  Check that Fls_GetJobResult is not called.

JobResult after read job for invalidated block:
  Call Fee_Read for the invalidated block.
  Wait till the read job is complete.
  Check the job result by calling Fee_GetJobResult().
  Check that Fls_GetJobResult is not called.

JobResult after a write job is canceled:
  Call Fee_Write() with different block number than invalidated.
  Call Fee_Cancel().
  Check the job result by calling Fee_GetJobResult().
  Check that Fls_GetJobResult is not called.

JobResult after read job for the block which is inconsistent in flash:
  Call Fee_Read for the block which is inconsistent in flash.
  Wait till the read job is complete.
  Check the job result by calling Fee_GetJobResult().
  Check that Fls_GetJobResult is not called.

JobResult after read job for the block which is not written:
  Call Fee_Read for the block which is not written.
  Wait till the read job is complete.
  Check the job result by calling Fee_GetJobResult().
  Check that Fls_GetJobResult is not called.

JobResult after a write job failed:
  Call Fee_Write().
  Check Fee_Write() returns E_OK.
  Set the Return value of Fls_Write() to E_NOT_OK.
  Wait till the write job is complete.
  Check the job result by calling Fee_GetJobResult().
  Check that Fls_GetJobResult is not called.

Check the Nvm notification calls and DET errors if configured.
Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

JobResult when a invalidate job is called:
  The Fee_GetJobResult() returns MEMIF_JOB_PENDING.
  Fls_GetJobResult is not called.

JobResult after invalidate job is complete:
  The Fee_GetJobResult() returns MEMIF_JOB_OK.
  Fls_GetJobResult is not called.

JobResult after read job for invalidated block:
  The Fee_GetJobResult() returns MEMIF_BLOCK_INVALID.
  Fls_GetJobResult is not called.

JobResult after write job is canceled:
  The Fee_GetJobResult() returns MEMIF_JOB_CANCELED.
  Fls_GetJobResult is not called.

JobResult after read job for the block which is inconsistent in flash:
  The Fee_GetJobResult() returns MEMIF_BLOCK_INCONSISTENT.
  Fls_GetJobResult is not called.

JobResult after read job for the block which is not written:
  The Fee_GetJobResult() returns MEMIF_BLOCK_INCONSISTENT.
  Fls_GetJobResult is not called.

JobResult after a write job failed:
  Fee_Write returns E_OK.
  The Fee_GetJobResult() returns MEMIF_JOB_FAILED.
  Fls_GetJobResult is not called.

Nvm Job End Notification is called once.
Nvm Job Error Notification is called four times.
No Det errors to be reported if configured.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00091</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>128</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00035</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>102</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00156</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>167</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00157</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>168</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00158</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>169</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00159</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>170</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00160</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>171</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00155</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>166</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1225</internalId></specobject>
    <specobject>
      <id>TS_FEE_JobEndNotification</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Conformance_Common/source/application/Tests.c</sourcefile>
      <sourceline>2574</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
  Test that flash job result shall be set to proper value when Fee job end notification
  is called in different situations.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  None
  
Test Execution: 

  Test scenario:
    01: Reset the Fee module to simulate hardware reset.
    Initialize test result
    Simulate hardware reset
    Set the result to invalid value
    Call Fee job end notification
    05: VP Check that if Fee is not initialized the flash job result does not change
    Initialize Fee
    Call Fee job end notification
    Check that the result is not changed
    Call Fee job end notification
    Check that the result is not changed
    Call Fee job end notification
    Check that the result is not changed
    Call Fee job end notification
    Check that the result is not changed
    Call Fee job end notification
    Check that the result is not changed
    Call Fee job end notification
    Check that the result is changed to MEMIF_JOB_OK
    Set the test result as Success
    Set test case result

    Initialize Fee module.
    Set the Flash job result as MEMIF_JOB_PENDING.

  Call Fee job end notification:
    Call Fee job end notification.

  In case any of the above operation returns failure/unexpected value or if a timeout occurs,
  set result as failure.

  
Test Input: 
  None
  
Test Output: 

  On test scenario preparation:
    The return of initialization need not be verified since initialization is already tested.

  On calling Fee job end notification:
    Flash job result shall be MEMIF_JOB_OK if the module is initialized and the current job result
    is pending, otherwise it shall not change the result.

  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00095</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>132</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00142</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>158</internalId></provcov>
        <provcov>
          <linksto>Fee.JobNotification.InitCheck</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>265</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1226</internalId></specobject>
    <specobject>
      <id>TS_FEE_JobErrorNotification</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Conformance_Common/source/application/Tests.c</sourcefile>
      <sourceline>2752</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
  Test that flash job result shall be set to proper value when Fee job error notification
  is called in different situations.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  None
  
Test Execution: 

  Prepare test scenario:
    Reset the Fee module to simulate hardware reset.
    Initialize flash driver and test stubs for Nvm and Det.
    Erase flash memory and the flash mirror.
    Initialize Fee module.
    Set the Flash job result as MEMIF_JOB_PENDING.

  Call Fee job end notification:
    Call Fee job end notification.

  In case any of the above operation returns failure/unexpected value or if a timeout occurs,
  set result as failure.

  
Test Input: 
  None
  
Test Output: 

  On test scenario preparation:
    The return of initialization need not be verified since initialization is already tested.

  On calling Fee job end notification:
    Flash job result shall be MEMIF_JOB_FAILED if the module is initialized and the current job result
    is pending, otherwise it shall not change the result.

  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00096</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00143</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>159</internalId></provcov>
        <provcov>
          <linksto>Fee.JobNotification.InitCheck</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>265</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1227</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_FEE_DetFeeUninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Det_Common/source/application/tests_Det.c</sourcefile>
      <sourceline>45</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
The sequence calls all API-functions except Fee_Init() and Fee_MainFunction() while the FEE
is not initialized and checks that FEE_E_UNINIT is reported to the DET.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
FEE is not initialized.

Test Execution: 

Init test:
  Initialize Det stub.

Call Fee_Write:
  Call Fee_Write() with a valid block number.
  Check Det_ReportError() is called.
  Check Fee_Write() returns E_NOT_OK.
  Check Fls_Write() is not called.

Call Fee_Read:
  Call Fee_Read() with valid parameters.
  Check Det_ReportError() is called.
  Check Fee_Read() returns E_NOT_OK.
  Check Fls_Read() is not called.

Call Fee_InvalidateBlock:
  Call Fee_InvalidateBlock() with a valid block number.
  Check Det_ReportError() is called.
  Check Fee_InvalidateBlock() returns E_NOT_OK.
  Check Fls_Write() is not called.

Call Fee_EraseImmediateBlock:
  Call Fee_EraseImmediateBlock() with a valid block number.
  Check Det_ReportError() is called.
  Check Fee_EraseImmediateBlock() returns E_NOT_OK.
  Check Fls_Erase() is not called.

Call Fee_SetMode:
  Call Fee_SetMode() with valid mode.
  Check Det_ReportError() is called.
  Check Fls_SetMode() is not called.

Call Fee_GetJobResult:
  Call Fee_GetJobResult().
  Check Det_ReportError() is called.
  Check Fee_GetJobResult() returns MEMIF_JOB_FAILED.
  Check Fls_GetJobResult() is not called.

Call Fee_Cancel:
  Call Fee_Cancel().
  Check Det_ReportError() is called.
  Check Fls_Cancel() is not called.


Test Input: 

Test Output: 

On Fee_Write Call:
  Fee_Write() calls Det_ReportError() with the error value FEE_E_UNINIT;
  returns E_NOT_OK.
  Fls_Write() is not called

On Fee_Read Call:
  Fee_Read() calls Det_ReportError() with the error value FEE_E_UNINIT;
  returns E_NOT_OK.
  Fls_Read() is not called

On Fee_InvalidateBlock Call:
  Fee_InvalidateBlock() calls Det_ReportError() with the error value
  FEE_E_UNINIT; returns E_NOT_OK.
  Fls_Write() is not called

On Fee_EraseImmediateBlock Call:
  Fee_EraseImmediateBlock() calls Det_ReportError() with the error value
  FEE_E_UNINIT; returns E_NOT_OK.
  Fls_Erase() is not called

On Fee_SetMode Call:
  Fee_SetMode() calls Det_ReportError() with the error value
  FEE_E_UNINIT; Fls_SetMode() is not called

On Fee_GetStatus Call:
  Fee_GetStatus() calls Det_ReportError() with the error value
  FEE_E_UNINIT; returns MEMIF_UNINIT.
  Fls_GetStatus() is not called.

On Fee_GetJobResult Call:
  Fee_GetJobResult() calls Det_ReportError() with the error value
  FEE_E_UNINIT; returns MEMIF_JOB_FAILED.
  Fls_GetStatus() is not called.

On Fee_Cancel Call:
  Fee_Cancel() calls Det_ReportError() with the error value
  FEE_E_UNINIT; Fls_Cancel is not called.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00121</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>140</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00122</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>141</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00123</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>142</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00124</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>143</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00125</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>144</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00126</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>145</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00127</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>146</internalId></provcov>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00062</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>32</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1228</internalId></specobject>
    <specobject>
      <id>TS_FEE_DetInvalidDataPtr</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Det_Common/source/application/tests_Det.c</sourcefile>
      <sourceline>326</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
The sequence calls Fee_Read() and Fee_Write() with DataBufferPtr parameter
as NULL pointer and checks that FEE_E_INVALID_DATA_PTR is reported to the DET.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
Note: Unless otherwise stated, whenever an Fee Job is requested, Fee_MainFunction and
Fls_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize Det stub.
  Initialize Fee module.

Call Fee_Write:
  Call Fee_Write() with DataBufferPtr as NULL pointer.
  Check Det_ReportError() is called.
  Check Fee_Write() returns E_NOT_OK.
  Check Fls_Write() is not called.

Call Fee_Read:
  Call Fee_Read() with DataBufferPtr as NULL pointer.
  Check Det_ReportError() is called.
  Check Fee_Read() returns E_NOT_OK.
  Check Fls_Read() is not called.


Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On Fee_Write Call:
  Fee_Write() calls Det_ReportError() with the error value FEE_E_INVALID_DATA_PTR;
  returns E_NOT_OK.
  Fls_Write() is not called.

On Fee_Read Call:
  Fee_Read() calls Det_ReportError() with the error value FEE_E_INVALID_DATA_PTR;
  returns E_NOT_OK.
  Fls_Read() is not called.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00136</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>49</internalId></provcov>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00139</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>50</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00162</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>172</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00163</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>173</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1229</internalId></specobject>
    <specobject>
      <id>TS_FEE_DetInvalidBlockOffset</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Det_Common/source/application/tests_Det.c</sourcefile>
      <sourceline>455</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Call Fee_Read() with BlockOffset parameter invalid value and
checks that FEE_E_INVALID_BLOCK_OFS is reported to the DET.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
Note: Unless otherwise stated, whenever an Fee Job is requested, Fee_MainFunction and
Fls_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize Det stub.
  Initialize Fee module.

Call Fee_Read:
  Call Fee_Read() with BlockOffset parameter as invalid value.
  Check Det_ReportError() is called.
  Check Fee_Read() returns E_NOT_OK.
  Check Fls_Read() is not called.


Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On Fee_Read Call:
  Fee_Read() calls Det_ReportError() with the error value FEE_E_INVALID_BLOCK_OFS;
  returns E_NOT_OK.
  Fls_Read() is not called.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00135</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>151</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1230</internalId></specobject>
    <specobject>
      <id>TS_FEE_DetInvalidBlockLen</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Det_Common/source/application/tests_Det.c</sourcefile>
      <sourceline>550</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Calls Fee_Read() with Length parameter as invalid value and
checks that FEE_E_INVALID_BLOCK_LEN is reported to the DET.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
Note: Unless otherwise stated, whenever an Fee Job is requested, Fee_MainFunction and
Fls_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize Det stub.
  Initialize Fee module.

Call Fee_Read:
  Call Fee_Read() with Length parameter as invalid value.
  Check Det_ReportError() is called.
  Check Fee_Read() returns E_NOT_OK.
  Check Fls_Read() is not called.


Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On Fee_Read Call:
  Fee_Read() calls Det_ReportError() with the error value FEE_E_INVALID_BLOCK_LEN;
  returns E_NOT_OK.
  Fls_Read() is not called.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00137</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1231</internalId></specobject>
    <specobject>
      <id>TS_FEE_DetMemIfBusy</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Det_Common/source/application/tests_Det.c</sourcefile>
      <sourceline>644</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Testing a job requested when the module status is MEMIF_BUSY gets rejected.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Fee Job is requested, Fee_MainFunction and
Fls_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize flash driver and test stubs for Nvm and Det if configured.
  Erase flash memory.
  Initialize Fee module.

Prepare test scenario:
  Call Fee_Write() to make the module busy.
  Check the Fee status is MEMIF_BUSY by calling Fee_GetStatus().
  Do not call Fee_MainFunction and Fls_MainFunction.

Call Fee_Write:
  Call Fee_Write with a valid block number.
  Check write is rejected by giving a return value E_NOT_OK.
  Check Fls_Write() is not called.

Call Fee_Read:
  Call Fee_Read with a valid block number.
  Check read is rejected by giving a return value E_NOT_OK.
  Check Fls_Read() is not called.

Call Fee_InvalidateBlock:
  Call Fee_InvalidateBlock with a valid block number.
  Check invalidate is rejected by giving a return value E_NOT_OK.
  Check Fls_Write() is not called.

  Call Fee_EraseImmediateBlock:
  Call Fee_EraseImmediateBlock with a valid block number.
  Check EraseImmediate is rejected by giving a return value E_NOT_OK.
  Check Fls_Erase() is not called.

Check the Nvm notification calls and DET errors if configured.
Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 
None

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On test scenario preparation:
  Fee_Write() returns E_OK.
  Fee_GetStatus returns MEMIF_BUSY.

On call of Fee_Write:
  Fee_Write() returns E_NOT_OK.

On call of Fee_Read:
  Fee_Read() returns E_NOT_OK.

On call of Fee_InvalidateBlock:
  Fee_InvalidateBlock() returns E_NOT_OK.


On call of Fee_EraseImmediateBlock:
  Fee_EraseImmediateBlock() returns E_NOT_OK.

Nvm Job End Notification is not called.
Nvm Job Error Notification is not called.
No Det errors are reported if configured.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00146</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>53</internalId></provcov>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00145</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>52</internalId></provcov>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00144</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>51</internalId></provcov>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00133</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>48</internalId></provcov>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00170</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>58</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00165</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>175</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00166</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>176</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_91002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>192</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1232</internalId></specobject>
    <specobject>
      <id>TS_FEE_DetInternalBusy</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Det_Common/source/application/tests_Det.c</sourcefile>
      <sourceline>869</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Test the DET is reported when calling Fee_Write with invalid block.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Fee Job is requested, Fee_MainFunction and
Fls_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize flash driver and test stubs for Nvm and Det if configured.
  Erase flash memory.
  Initialize Fee module.

Prepare test scenario:
  Write a block continuously till the module becomes MEMIF_BUSY_INTERNAL.
  Reset Nvm notifications count.


Call Fee_Write:
  Call Fee_Write with an invalid block number when Fee state is BUSY_INTERNAL.
  Check Write is rejected by giving a return value E_NOT_OK.
  VP(SWS_Fee_00138)Check whether Det is reported with error id FEE_E_INVALID_BLOCK_NO.
   


Test Input: 
None

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00138</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>154</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1233</internalId></specobject>
    <specobject>
      <id>TS_FEE_30032</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Det_Common/source/application/tests_Det.c</sourcefile>
      <sourceline>992</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
To test that DET reports error for the API calls with invalid block number.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
Init test:
  Initialize Det stub.
  Initialize Fee module.

DET check for Fee_Read:
  Call Fee_Read with block number which are not configured.
  Check Det_ReportError() is called.
  Check Fee_Read() returns E_NOT_OK.
  Check Fls_Read() is not called.

DET check for Fee_Write:
  Call Fee_Write() with block number which are not configured.
  Check Det_ReportError() is called.
  Check Fee_Write() returns E_NOT_OK.
  Check Fls_Write() is not called.

DET check for Fee_InvalidateBlock:
  Call Fee_InvalidateBlock() with block number which are not configured.
  Check Det_ReportError() is called.
  Check Fee_InvalidateBlock() returns E_NOT_OK.
  Check Fls_Write() is not called.

DET check for Fee_EraseImmediateBlock:
  Call Fee_EraseImmediateBlock() with block number which are not configured.
  Check Det_ReportError() is called.
  Check Fee_EraseImmediateBlock() returns E_NOT_OK.
  Check Fls_Erase() is not called.

DET check for Fee_EraseImmediateBlock for non-immediate block:
  Call Fee_EraseImmediateBlock() with block number which are not configured as "Immediate".
  Check Det_ReportError() is called.
  Check Fee_EraseImmediateBlock() returns E_NOT_OK.
  Check Fls_Erase() is not called.


Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested

DET check for Fee_Read:
  Fee_Read() calls Det_ReportError() with the error value FEE_E_INVALID_BLOCK_NO;
  returns E_NOT_OK.
  Fls_Read() is not called.

DET check for Fee_Write:
  Fee_Write() calls Det_ReportError() with the error value FEE_E_INVALID_BLOCK_NO;
  returns E_NOT_OK.
  Fls_Write() is not called.

DET check for Fee_InvalidateBlock:
  Fee_InvalidateBlock() calls Det_ReportError() with the error value FEE_E_INVALID_BLOCK_NO;
  returns E_NOT_OK.
  Fls_Write() is not called.

DET check for Fee_EraseImmediateBlock:
  Fee_EraseImmediateBlock() calls Det_ReportError() with the error value FEE_E_INVALID_BLOCK_NO;
  returns E_NOT_OK.
  Fls_Erase() is not called.

DET check for Fee_EraseImmediateBlock for non-immediate block:
  Fee_EraseImmediateBlock() calls Det_ReportError() with the error value FEE_E_INVALID_BLOCK_NO;
  returns E_NOT_OK.
  Fls_Erase() is not called.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00010</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>23</internalId></provcov>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00045</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>27</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00068</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>113</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00134</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00138</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>154</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00140</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>156</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00141</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>157</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1234</internalId></specobject>
    <specobject>
      <id>TS_FEE_30033</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Det_Common/source/application/tests_Det.c</sourcefile>
      <sourceline>1230</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
To test that DET errors are reported for all unconfigured blocks.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Init test:
  Initialize Det stub.
  Initialize Fee.

Read Data:
  Call Fee_Read() for all possible block numbers (0 .. 65535).

Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On Read Data:
  DET errors will be reported for all unconfigured blocks (0 .. 65535).

Expected behavior is met.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00010</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>23</internalId></provcov>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00045</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>27</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1235</internalId></specobject>
    <specobject>
      <id>TS_FEE_DetInvalidCancel</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Det_Common/source/application/tests_Det.c</sourcefile>
      <sourceline>1366</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Verify whether Fee_Cancel() reports development error
FEE_E_INVALID_CANCEL, if current module status is not MEMIF_BUSY.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
Common configuration parameter FeeDevErrorDetect set to true.

Test Execution: 
01. Initialize Flash, DET stubs and initialize Fee 
02. Call Fee_Cancel()
03. VP(FEE184): Check that error FEE_E_INVALID_CANCEL is reported by Fee_cancel to DET

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00184</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>70</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_91002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>192</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1236</internalId></specobject>
    <specobject>
      <id>TS_FEE_DetGetVersionInfo</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Det_Common/source/application/tests_Det.c</sourcefile>
      <sourceline>1433</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
To test the Fee GetVersionInfo API with valid pointer as parameter
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 
  Initialize the flash, Nvm and Det stubs if configured.
  Set the Version information values to invalid value before the call of Fee_GetVersionInfo.
  Call Fee GetVersionInfo with a NULL_PTR.
  Check the det report.

Test Input: 
None

Test Output: 
The version information returned are those that are configured/hardcoded in
the module.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00147</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>54</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1237</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_FEE_30052</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_EB_Conformance_Common/source/application/EB_tests.c</sourcefile>
      <sourceline>45</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
To check the call of Fee_MainFunction() without module initialization, does not report DET
if configured and does not perform any functionality.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
FEE is not initialized.

Test Execution: 

Init test:
  Initialize test stubs for flash driver and Det if configured.

Call Fee_MainFunction:
  Call Fee_MainFunction().
  Check if Det_ReportError() is called, if DET is configured.
  Check if Flash functions are called.


Test Input: 

Test Output: 

On Fee_MainFunction Call:
  Fee_MainFunction() shall not call Det_ReportError() if configured.
  No Flash functions are called.


&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.MainFunction.InitCheck</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>210</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1238</internalId></specobject>
    <specobject>
      <id>TS_FEE_30006</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_EB_Conformance_Common/source/application/EB_tests.c</sourcefile>
      <sourceline>134</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Testing the Fee_Cancel functionality during a write job.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Fee Job is requested, Fee_MainFunction and
Fls_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize flash driver and test stubs for Nvm and Det if configured.
  Erase flash memory.
  Initialize Fee module.

Prepare test scenario:
  Write a block of data into the flash.

Cancel the write operation:
  Call Cancel.

Verify write(The operation which is canceled):
  Check the Fee status and job result.

Write data:
  Wait till the Fee status is MEMIF_IDLE.
  Write a block of data into the flash.
  Check the Fee status and job result just after write.
  Check the Fee status and job result after the completion of the write job.
  Check Fls_Write() is called.

Read data :
  Read flash with same block number written before.
  Check the Fee status and job result just after read.
  Check the Fee status and job result after the completion of the read job.
  Check Fls_Read() is called.
  Compare source and destination buffers for equality.

Check the Nvm notification calls and DET errors if configured.
Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 
None

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On test scenario preparation:
  Write function should return E_OK.

On Cancel the write operation:
  After cancellation Fee status should not be MEMIF_BUSY and
  Job Result should be MEMIF_JOB_CANCELED.

On Write data:
  Write function should return E_OK
  After write Fee_GetStatus should return MEMIF_BUSY and Fee_GetJobResult should return
  MEMIF_JOB_PENDING.
  On completion of write job, Fee_GetStatus should return MEMIF_IDLE and Fee_GetJobResult return
  MEMIF_JOB_OK.
  Fls_Write() is called at least once.

On Read data:
  Read function should return E_OK.
  On completion of read, job result should be MEMIF_JOB_OK.
  After read Fee_GetStatus should return MEMIF_BUSY and Fee_GetJobResult should return
  MEMIF_JOB_PENDING.
  On completion of read job, Fee_GetStatus should return MEMIF_IDLE and Fee_GetJobResult return
  MEMIF_JOB_OK.
  Fls_Read() is called at least once.
  Read/write buffer comparison should be successful

Nvm Job End Notification is called twice.
Nvm Job Error Notification is called once.
No Det errors are reported if configured.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee_FEE_080_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>204</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00164</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>174</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1239</internalId></specobject>
    <specobject>
      <id>TS_FEE_30010</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_EB_Conformance_Common/source/application/EB_tests.c</sourcefile>
      <sourceline>357</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Testing a job requested when the module status is MEMIF_BUSY gets rejected.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Fee Job is requested, Fee_MainFunction and
Fls_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize flash driver and test stubs for Nvm and Det if configured.
  Erase flash memory.
  Initialize Fee module.

Prepare test scenario:
  Call Fee_Write() to make the module busy.
  Check the Fee status is MEMIF_BUSY by calling Fee_GetStatus().
  Do not call Fee_MainFunction and Fls_MainFunction.

Call Fee_Write:
  Call Fee_Write with a valid block number.
  Check write is rejected by giving a return value E_NOT_OK.
  Check Fls_Write() is not called.

Call Fee_Read:
  Call Fee_Read with a valid block number.
  Check read is rejected by giving a return value E_NOT_OK.
  Check Fls_Read() is not called.

Call Fee_InvalidateBlock:
  Call Fee_InvalidateBlock with a valid block number.
  Check invalidate is rejected by giving a return value E_NOT_OK.
  Check Fls_Write() is not called.

  Call Fee_EraseImmediateBlock:
  Call Fee_EraseImmediateBlock with a valid block number.
  Check EraseImmediate is rejected by giving a return value E_NOT_OK.
  Check Fls_Erase() is not called.

Check the Nvm notification calls and DET errors if configured.
Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 
None

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On test scenario preparation:
  Fee_Write() returns E_OK.
  Fee_GetStatus returns MEMIF_BUSY.

On call of Fee_Write:
  Fee_Write() returns E_NOT_OK.
  Fls_Write() is not called.

On call of Fee_Read:
  Fee_Read() returns E_NOT_OK.
  Fls_Read() is not called.

On call of Fee_InvalidateBlock:
  Fee_InvalidateBlock() returns E_NOT_OK.
  Fls_Write() is not called.

On call of Fee_EraseImmediateBlock:
  Fee_EraseImmediateBlock() returns E_NOT_OK.
  Fls_Erase() is not called.

Nvm Job End Notification is not called.
Nvm Job Error Notification is not called.
No Det errors are reported if configured.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00172</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>180</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00174</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>181</internalId></provcov>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00145</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>52</internalId></provcov>
        <provcov>
          <linksto>Fee.ASR40.SWS_Fee_00146</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>53</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1240</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_FEE_30054</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_EB_Conformance_Immediate/source/application/EB_tests_immediate.c</sourcefile>
      <sourceline>47</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Test the immediate block is written when the module is MEMIF_BUSY_INTERNAL.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Fee Job is requested, Fee_MainFunction and
Fls_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize flash driver and test stubs for Nvm and Det if configured.
  Erase flash memory.
  Initialize Fee module.

Prepare test scenario:
  Write a block continuously till the module becomes MEMIF_BUSY_INTERNAL.
  Reset Nvm notifications count.

Call Fee_Write:
  Call Fee_Write with an immediate block number.
  Check write is accepted.
  Wait till the write is complete.

Call Fee_Read:
  Wait till the module is MEMIF_IDLE.
  Call Fee_Read with an immediate block number which is written.
  Wait till the read is complete.
  Check the data written and read is same.

Check the Nvm notification calls and DET errors if configured.
Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 
None

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On test scenario preparation:
  For each write Fee_Write() returns E_OK.
  Wait till each write is complete by checking the job result is MEMIF_JOB_OK.
  After some particular number of writes, the module status shall be MEMIF_BUSY_INTERNAL.

On call of Fee_Write:
  Fee_Write() returns E_OK.
  On completion of write job i.e., Fee_GetJobResult returns MEMIF_JOB_OK.

On call of Fee_Read:
  Fee_Read() returns E_OK.
  On completion of read job i.e., Fee_GetJobResult returns MEMIF_JOB_OK.
  The data written and read shall be same.

Nvm Job End Notification is called twice.
Nvm Job Error Notification is not called.
No Det errors are reported if configured.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00025</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>99</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1241</internalId></specobject>
    <specobject>
      <id>TS_FEE_30011</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_EB_Conformance_Immediate/source/application/EB_tests_immediate.c</sourcefile>
      <sourceline>246</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Testing the Fee_Cancel functionality while erasing
an immediate block (the job is accepted, but not started).
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Fee Job is requested, Fee_MainFunction and
Fls_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize flash driver and test stubs for Nvm and Det if configured.
  Erase flash memory.
  Initialize Fee module.

Prepare test scenario:
  Write a block to the flash.
  Wait till the job is complete.
  Erase the block which is written.(Do not call Main Functions)

Cancel the invalidation operation:
  Call Cancel.

Verify Erase (The operation which is canceled):
  Check the Fee status and Job Result.

Check the Nvm notification calls and DET errors if configured.
Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 
None

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On test scenario preparation:
  Write function should return E_OK.
  Job Result should be MEMIF_JOB_OK.
  Erase function should return E_OK.

On Cancel the invalidate operation:
  After cancellation Fee status should not be MEMIF_BUSY and
  Job Result should be MEMIF_JOB_CANCELED.

Nvm Job End Notification is called once.
Nvm Job Error Notification is called once.
No Det errors are reported if configured.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.SWS_Fee_00089</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>126</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00081</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00056</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>109</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1242</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_FEE_30040</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_EB_Det_Common/source/application/EB_tests_Det.c</sourcefile>
      <sourceline>44</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
The sequence calls all API-functions except Fee_Init() and Fee_MainFunction() while the FEE
is not initialized and checks that FEE_E_UNINIT is reported to the DET.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
FEE is not initialized.

Test Execution: 

Init test:
  Initialize Det stub.

Call Fee_GetStatus:
  Call Fee_GetStatus().
  Check Det_ReportError() is called.
  Check Fee_GetStatus() returns MEMIF_UNINIT.
  Check Fls_GetStatus() is not called.


Test Input: 

Test Output: 

On Fee_GetStatus Call:
  Fee_GetStatus() calls Det_ReportError() with the error value
  FEE_E_UNINIT; returns MEMIF_UNINIT.
  Fls_GetStatus() is not called.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.GetStatus.InitCheck</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>211</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1243</internalId></specobject>
    <specobject>
      <id>TS_FEE_30044</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_EB_Det_Common/source/application/EB_tests_Det.c</sourcefile>
      <sourceline>140</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Calls Fee_SetMode() with invalid value for Mode parameter;
checks that FEE_E_INVALID_MODE is reported to the DET.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
Note: Unless otherwise stated, whenever an Fee Job is requested, Fee_MainFunction and
Fls_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize Det stub.
  Initialize Fee module.

Call Fee_SetMode:
  Call Fee_SetMode() with invalid value for Mode.
  Check Det_ReportError() is called.
  Check Fls_SetMode() is not called.


Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On Fee_SetMode Call:
  Fee_SetMode() calls Det_ReportError() with the error value FEE_E_INVALID_MODE.
  Fls_SetMode() is not called.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Mode.DET</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>212</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1244</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_Fee_Critical_BehaviorInIdle</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Impl_Critical_Common/source/application/tests_Critical_Common.c</sourcefile>
      <sourceline>44</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests critical block write job and erase immediate job while Fee is Idle.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Initialization
    04. Write some blocks in the active section
    05. Check that Fee is idle
    06. Write the critical block when Fee is idle.
    07. Count the current number of Fls job calls
    08. Check that Fee is not busy
    09. Check that the job result is OK
    10. Request jobs for normal blocks and check that they are rejected
    11. Verify that Fee have not transmit any job to Fls while frozen
    12. Request erase immediate for critical block and check that the job is accepted and processed
    13. Check that Fee is not frozen any more and it can accept jobs
    14. Request a write for an immediate block that will never be performed
    15. Write the critical block again
    16. Verify that critical write can not be canceled
    17. Finalize the critical write
    18. Request erase immediate for critical block and do not finish the job
    19. Verify that this job can not canceled even though it is a standard job
    20. Simulate RESET
    21. Critical block should be found. Other blocks should not be able to be read.
    22. Erase the critical block.
    23. Read the blocks and check their consistency
    24. Check for flash errors
    25. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeCriticalBlock.WriteFreeze</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>283</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeCriticalBlock.StopBlockJobs</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>285</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeCriticalBlock.Cancel</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>282</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1245</internalId></specobject>
    <specobject>
      <id>TS_Fee_Critical_CriticalSection</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Impl_Critical_Common/source/application/tests_Critical_Common.c</sourcefile>
      <sourceline>316</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests that Fee reserves space in critical section for critical write, that will be written in time.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Initialization
    04. Write a block
    05. Measure the time for writing the critical block
    06. Erase the critical block in order to unfreeze Fee
    07. Measure the time for writing 4 different blocks, that have to be switched later
    08. Count the number of block writes of the same block, until Fee enters in highest priority switch.
        (switching all the blocks will always take longer than the write of one of them)
    09. Reconstitute the whole scenario from Fee point of view, up to the last write that causes highest internal priority
    10. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    11. Perform Initialization
    12. Write a block
    13. Write critical block
    14. Erase the critical block in order to unfreeze Fee
    15. Write the blocks to be switched
    16. Write the block as many times as it was written in the original scenario
    17. Request the write of the critical block
    18. Check that there is space in critical section only for critical block and that it
        will be written in time.
    19. Simulate RESET
    20. Critical block should be found. Other blocks should not be able to be read.
    21. Erase the critical block. Job will be done after the highest priority switch
    22. Write the block that will be written after the highest priority switch
    23. Read the blocks and check their consistency
    24. Check for flash errors
    25. Set test case result

Test Input: 
  None.

Test Output: 
  Fee shall mark Section 0 as ACTIVE.

  Section status after start-up:
   - Section 0: Active
   - Section 1: Erased
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeCriticalBlock.WriteFreeze</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>283</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1246</internalId></specobject>
    <specobject>
      <id>TS_Fee_Critical_InterfaceWithNvM</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Impl_Critical_Common/source/application/tests_Critical_Common.c</sourcefile>
      <sourceline>572</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests that NvM receives correct results in case critical write interferes with NvM jobs.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Initialization
    04. Write a block
    05. Request 4 different block jobs that are canceled by critical block
    06. Request the write of the critical block
    07. Check that NvM's job was reported as failed
    08. Reinitialize the value for testing purposes
    09. Process the critical block
    10. Erase the critical block in order to unfreeze Fee
    11. Simulate the check for job result requested by NvM
    12. Erase the block that was written first
    13. Check that all the blocks are inconsistent
    14. Get only absolute values for all the blocks to be checked
    15. Check for flash errors
    16. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeCriticalBlock.CancelNvMJob</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>280</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeCriticalBlock.Priority</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>281</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeCriticalBlock.GetJobResult</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>289</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1247</internalId></specobject>
    <specobject>
      <id>TS_Fee_Critical_WriteTime_HP</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Impl_Critical_Common/source/application/tests_Critical_Common.c</sourcefile>
      <sourceline>730</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests that the critical block is written in time if requested during highest priority switch.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
        const uint8 SwitchSteps = 5U * FLS_WRITE_BLOCK_SIZE;
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Initialization
    04. Write a block
    05. Measure the time for writing the regular block
    06. Measure the time for writing the critical block
    07. Erase the critical block in order to unfreeze Fee
    08. Write the blocks to be switched
    09. Perform writes until the time of a write takes longer than double.
        This means Fee enters in high priority switch
        while (i &lt; 2*RegularStopwatch)
    10. The job has not finished
    11. Perform a couple of switch steps.
    12. Request the write of the critical block
    13. Check that there the space for critical block was kept in critical section and the write
        will be done in time.
    14. Simulate RESET
    15. Critical block should be found. Other blocks should not be able to be read.
    16. Erase the critical block in order to unfreeze Fee
    17. Read the blocks and check their consistency
    18. Check for flash errors
    19. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeCriticalBlock.Priority</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>281</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeCriticalBlock.WriteFreeze</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>283</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Critical.SwitchRequiredSize</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>951</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1248</internalId></specobject>
    <specobject>
      <id>TS_Fee_Critical_FrozenState_HP</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Impl_Critical_Common/source/application/tests_Critical_Common.c</sourcefile>
      <sourceline>942</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests the frozen state after writing critical in highest internal priority switch.
  Tests that critical write fails in highest priority switch due to lack of space.
  Tests erase immediate of critical block is accepted as standard job and it can be interrupted by critical write.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
        const uint8 SwitchSteps = 5U * FLS_WRITE_BLOCK_SIZE;
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Initialization
    04. Write a block
    05. Measure the time for writing the regular block
    06. Measure the time for erasing immediate job
    07. Write the blocks to be switched
    08. Perform writes until the time of a write takes longer than double.
        This means Fee enters in high priority switch
    09. The job has not finished
    10. Perform a couple of switch steps.
    11. Write the critical block
    12. Count the current number of Fls job calls
    13. Check that Fee is busy internal because of the switch
    14. Check that the job result is OK
    15. Request jobs for normal blocks and check that they are rejected
    16. Verify that Fee have not transmit any job to Fls while frozen
    17. Request erase for critical block in order to unfreeze Fee. The state FEE_SS_COPY_DATA will be resumed.
    18. Check that Fee is busy with the erase job
    19. The standard job erase immediate is processed, as usually, after the highest priority switch
    20. Check that the job result is still pending
    21. Request write for critical block when there is no more space
    22. Check that the job is considered failed
    23. Critical block should be found. Other blocks should not be able to be read.
    24. Erase the critical block in order to unfreeze Fee
    25. Read the blocks and check their consistency
    26. Finish the switch
    27. Check that Fee managed to make room for another critical write
    28. Check for flash errors
    29. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeCriticalBlock.StopBlockJobs</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>285</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeCriticalBlock.HealInternaly</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>287</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeCriticalBlock.Fail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>288</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Critical.ResumeFailed</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>950</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1249</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_Fee_Imm_HPNoReadAndErase</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Impl_Immediate_Common/source/application/tests_Imm_Common.c</sourcefile>
      <sourceline>44</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests that Fee does not interrupt highest priority switch for jobs like read and erase
  of an immediate block.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
  01. Set the initial test result
  02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
  03. Perform Initialization
  04. Write a block
  05. Measure the time for writing the regular block while changing section
  06. Measure the time for reading the written immediate block
  07. Measure the time for erasing the written immediate block
  08. Write the blocks to be switched
  09. Perform writes until the time of a write takes much longer than regular block writing
      This means Fee enters in high priority switch
  10. The job has not finished
  11. Cancel the write request that triggered the highest priority switch
  12. Finalize any ongoing internal operation, in order for the next measurements to be precise
  13. Request a read of the immediate block
  14. Check that the immediate block is not read immediately.
  15. Cancel the read request that triggered the highest priority switch
  16. Request an erase of the immediate block
  17. Check that the immediate block is not erased immediately.
  18. Check for flash errors
  19. Set test case result

Test Input: 
  None.

Test Output: 
  Fee shall mark Section 0 as ACTIVE.

  Section status after start-up:
   - Section 0: Active
   - Section 1: Erased
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeImmediateSpaceReserved.Config</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>305</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1250</internalId></specobject>
    <specobject>
      <id>TS_Fee_Imm_HPrioSwitchOk</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Impl_Immediate_Common/source/application/tests_Imm_Common.c</sourcefile>
      <sourceline>250</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests that Fee finalizes the highest priority switch correctly after being interrupted by
  immediate block that are written immediately.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
  01. Set the initial test result
  02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
  03. Perform Initialization
  04. Write a block
  05. Measure the time for writing the regular block while changing section
  06. Measure the time for writing an immediate block
  07. Measure the time for writing a different immediate block
  08. Measure the time for writing a different immediate block
  09. Write the blocks to be switched
  10. Perform writes until the time of a write takes much longer than regular block writing
      This means Fee enters in high priority switch
  11. The job has not finished
  12. Perform a couple of switch steps.
  13. Cancel the write request that triggered the highest priority switch
  14. Finalize any ongoing internal operation, in order for the next measurements to be precise
  15. Request the write of an immediate block
  16. Check that the immediate block is written immediately.
  17. Request the write of the next immediate block
  18. Check that the immediate block is written immediately.
  19. Request the write of the next immediate block
  20. Check that the immediate block is written immediately.
  21. Request the write of an immediate block again
  22. Check that there is no more reserved space for this job
  23. Finish the highest priority switch
  24. Simulate RESET
  25. Perform Initialization
  26. Check that all the blocks are found, including the immediate ones.
  27. Check for flash errors
  28. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeImmediateSpaceReserved.Behavior</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>306</internalId></provcov>
        <provcov>
          <linksto>Fee.SWS_Fee_00009</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1251</internalId></specobject>
    <specobject>
      <id>TS_Fee_Imm_HPSpaceReserved</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Impl_Immediate_Common/source/application/tests_Imm_Common.c</sourcefile>
      <sourceline>532</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests that the Fee writes the immediate blocks that interrupt the highest priority switch
  in the reserved space.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
  01. Set the initial test result
  02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
  03. Perform Initialization
  04. Write a block
  05. Measure the time for writing the regular block
  06. Measure the time for writing an immediate block
  07. Measure the time for writing a different immediate block
  08. Measure the time for writing a different immediate block
  09. Write the blocks to be switched
  10. Erase all the immediate blocks, to make sure they can't be found in the first section
  11. Perform writes until the time of a write takes much longer than regular block writing
      This means Fee enters in high priority switch
  12. The job has not finished
  13. Perform a couple of switch steps.
  14. Cancel the write request that triggered the highest priority switch
  15. Finalize any ongoing internal operation, in order for the next measurements to be precise
  16. Request the write of an immediate block
  17. Check that the immediate block is written immediately.
  18. Request the write of the next immediate block
  19. Check that the immediate block is written immediately.
  20. Request the write of the next immediate block
  21. Check that the immediate block is written immediately.
  22. Request the write of an immediate block again
  23. Check that there is no more reserved space for this job
  24. Erase the last section (highest priority switch section), in order to show that the immediate blocks are not written here
  25. Simulate RESET
  26. Perform Initialization
  27. Check that the immediate blocks can be found. Being erased prior to their latest write
      demonstrate that they must be written in the penultimate section
  28. Check for flash errors
  29. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.ImmediateSpaceReserved.Runtime</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>966</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1252</internalId></specobject>
    <specobject>
      <id>TS_Fee_Imm_StartupFindsReserved</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Impl_Immediate_Common/source/application/tests_Imm_Common.c</sourcefile>
      <sourceline>822</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests that the immediate blocks that interrupt the highest priority switch are written in the reserved
  space found at startup.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
  01. Set the initial test result
  02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
  03. Perform Initialization
  04. Write a block
  05. Measure the time for writing the regular block
  06. Measure the time for writing an immediate block
  07. Measure the time for writing a different immediate block
  08. Measure the time for writing a different immediate block
  09. Write the blocks to be switched
  10. Erase all the immediate blocks, to make sure they can't be found in the first section
  11. Perform writes until the time of a write takes much longer than regular block writing
      This means Fee enters in high priority switch
  12. The job has not finished
  13. Perform a couple of switch steps.
  14. Simulate RESET
  15. Perform Initialization
  16. Request the write of the first immediate block
  17. Check that the immediate block is written immediately.
  18. Request the write of the next immediate block
  19. Check that the immediate block is written immediately.
  20. Request the write of the next immediate block
  21. Check that the immediate block is written immediately.
  22. Request the write of the normal immediate block again
  23. Check that there is no more reserved space for this job
  24. Erase the last section (highest priority switch section), in order to show that the immediate blocks are not written here
  25. Simulate RESET
  26. Perform Initialization
  27. Check that the immediate blocks can be found. Being erased prior to their latest write
      demonstrate that they must be written in the penultimate section
  28. Check for flash errors
  29. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.ImmediateSpaceReserved.Init</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>967</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1253</internalId></specobject>
    <specobject>
      <id>TS_Fee_Imm_ReserveSpace</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Impl_Immediate_Common/source/application/tests_Imm_Common.c</sourcefile>
      <sourceline>1114</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests that only the immediate blocks are written in the reserved space before entering
  the highest priority switch.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
  01. Set the initial test result
  02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
  03. Perform Initialization
  04. Write a block
  05. Measure the time for writing the regular block
  06. Measure the time for writing an immediate block
  07. Write the blocks to be switched
  08. Perform writes until the time of a write takes much longer than regular block writing
      This means Fee enters in high priority switch
  09. The job has not finished
  10. Repeat the scenario
  11. Perform Initialization
  12. Write the immediate block
  13. Write the blocks to be switched
  14. Add also the first 2 writings from the measuring scenario
  15. Stop the writings with a step before entering highest prio switch
  16. Request the write of the next immediate block
  17. Check that the immediate block is written immediately.
  18. Erase the last section (highest priority switch section), in order to show that the immediate blocks are not written here
  19. Simulate RESET
  20. Perform Initialization
  21. Check that the immediate blocks can be found
  22. Check for flash errors
  23. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.ImmediateSpaceReserved.Runtime</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>966</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1254</internalId></specobject>
    <specobject>
      <id>TS_Fee_Imm_TriggerHP</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Impl_Immediate_Common/source/application/tests_Imm_Common.c</sourcefile>
      <sourceline>1336</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests that the repeated immediate jobs can trigger the highest priority switch if the
  space in the section cannot acomodate the immediate blocks any more.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
  01. Set the initial test result
  02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
  03. Perform Initialization
  04. Write a block
  05. Measure the time for writing the regular block
  06. Measure the time for writing an immediate block
  07. Write the blocks to be switched
  08. Perform writes until the time of a write takes much longer than regular block writing
      This means Fee enters in high priority switch
  09. The job has not finished
  10. Repeat the scenario
  11. Perform Initialization
  12. Write the immediate block
  13. Write the blocks to be switched
  14. Add also the first 2 writings from the measuring scenario
  15. Stop the writings with a step before entering highest prio switch
  16. Write the immediate blocks again, they should fit in the section
  17. Request the write of an immediate block one more time. This job should trigger HP Switch
  18. Check that the immediate block is not written immediately as the reserved space is not enough.
  19. Finish the job. The switch must have been finished first
  20. Simulate RESET
  21. Perform Initialization
  22. Check that the immediate block can be found with the latest data
  23. Check for flash errors
  24. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.ImmediateSpaceReserved.Runtime</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>966</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1255</internalId></specobject>
    <specobject>
      <id>TS_Fee_Imm_Failure</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Impl_Immediate_Common/source/application/tests_Imm_Common.c</sourcefile>
      <sourceline>1570</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests that the failure of an immediate job that is performed in the reserved space compromises the reserved space.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
  01. Set the initial test result
  02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
  03. Perform Initialization
  04. Write blocks
  05. Measure the time for writing the regular block
  06. Measure the time for writing an immediate block
  07. Perform writes until the time of a write takes much longer than regular block writing
      This means Fee enters in high priority switch
  08. The job has not finished
  09. Perform a couple of switch steps.
  10. Cancel the write request that triggered the highest priority switch
  11. Finalize any ongoing internal operation, in order for the next measurements to be precise
  12. Request the write of the next immediate block
  13. Simulate a Fls failure
  14. Let Fee deal with failure
  15. Check that the writing failed
  16. Clear the failure at Fls level
  17. Request the write of the first immediate block
  18. Check that the immediate block is not written immediately. The space is compromised
  19. Check for flash errors
  20. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.ImmediateSpaceReserved.Fail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>968</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1256</internalId></specobject>
    <specobject>
      <id>TS_Fee_Imm_ReservedSpaceReset</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Impl_Immediate_Common/source/application/tests_Imm_Common.c</sourcefile>
      <sourceline>1760</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests that Fee does not keep the reserved space after the Section switch copied all the blocks.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
  01. Set the initial test result
  02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
  03. Perform Startup1 and the validation of the first section as parto of Startup2
  04. Write a block
  05. Measure the time for writing the regular block
  06. Measure the time for writing an immediate block
  07. Perform writes until the time of a write takes much longer than regular block writing
      This means Fee enters in high priority switch
  08. The job has not finished
  09. Wait for the copy process to finish. Meaning Fee is not in highest internal priority any more
  10. Cancel the pending standard job
  11. Request the write of the immediate block
  12. Check that the immediate block is written immediately.
  13. Trigger the write of a standard block
  14. Check that the Restart Swtich's erase is restarted
  15. Finalize the switch
  16. Erase the first section in order to verify that the switch completed
  17. Simulate RESET
  18. Perform Initialization
  19. Check that the switch completed
  20. Check for flash errors
  21. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.ImmediateSpaceReserved.Runtime</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>966</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1257</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_Fee_Switch_SwitchPriority_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Impl_Switch_Common_2_3/source/application/tests_Switch23s_Common.c</sourcefile>
      <sourceline>44</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch works correctly in highest priority regarding comming jobs. 
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Start Startup1 but do not finish it
    04. Request some jobs. Startup1 shall continue and finish before performing the jobs.
        Also as part of Startup2 one section is validated. Startup2 is not finished. All the other sections must be erased.
    05. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    06. Fill one section at a time by writing a different block.
        Keep writing the block until Fee enters high priority switch directly from Startup2
    07. A high priority switch has started.
        Perform a couple of switch steps.
    08. Finish the requested write that caused high priority switch.
    09. VP(Fee.Dns.SS.SwitchPriority): Check that when the write is over the switch is also over.
        Therefore the job must have been done after the switch.
    10. Erase all the sections except the current Active section.
    11. Check that the switch had finished indeed.
    12. Check for flash errors
    13. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.SwitchPriority</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>905</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1258</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_ReadNoTrigger</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Impl_Switch_Common_2_3/source/application/tests_Switch23s_Common.c</sourcefile>
      <sourceline>201</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch is never triggered by read job request. 
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block, until Fee is write before entering switch.
    08. Read blocks that haven't been written. They shouldn't be found and they shall not trigger switch
    09. Read blocks that have been written. They should be found and they shall not trigger switch
    10. VP(Fee.SS.TriggeringTheSwitch.ReadRequest): Check that Fee is in idle and the switch has not started
    11. Request a write that should trigger switch
    12. Get over the delay timer
    13. Check that Fee is in idle now
    14. Check for flash errors
    15. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.SS.TriggeringTheSwitch.ReadRequest</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>259</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1259</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_Fee_Switch_CopyBlocks</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Impl_Switch_Common_2_3_4/source/application/tests_Switch234s_Common.c</sourcefile>
      <sourceline>44</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch works correctly. 
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Read the blocks and check their consistency
    08. Fill one section at a time by writing a different block, until Fee enters switch.
    09. VP(Fee.Dns.SS.TriggeringTheSwitch.WriteRequest): This write job will have started the switch when the while loop is left.
    10. On 2 sections, by the time when the processing is over, the switch is also over.
    11. Update the oldest section index
    12. Perform the switch (&gt;2 sections) / Just stay IDLE (2 sections)
    13. Erase all the sections except the current Active section.
    14. VP(Fee.Dns.SS.CopyBlocks): Read the blocks and validate them once more.
    15. Check for flash errors
    16. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.CopyBlocks</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>895</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.SS.TriggeringTheSwitch.WriteRequest</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>897</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Write.Behaviour.IDLE.NoSpace</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>866</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1260</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_CopyCopiedBlocks</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Impl_Switch_Common_2_3_4/source/application/tests_Switch234s_Common.c</sourcefile>
      <sourceline>210</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch works correctly and copies not only the written blocks 
  but the already copied ones too. 
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block, until Fee enters switch.
    08. On 2 sections, by the time when the processing is over, the switch is also over.
    09. Perform the switch (&gt;2 sections) / Just stay IDLE (2 sections)
    10. Perform switches in order to make sure that the interesting blocks are switched again.
        (Considering the switch trigger condition, Fee will carry the same block every FEE_NUMBER_OF_SECTIONS / 2 times)
    11. Perform the switch again.
    12. Erase all the sections except the current Active section.
    13. VP(Fee.Dns.SS.CopyBlocks): Read the blocks and validate them once more.
    14. Check for flash errors
    15. Set test case result

Test Input: 
  None.

Test Output: 
  Fee shall mark Section 0 as ACTIVE.

  Section status after start-up:
   - Section 0: Active
   - Section 1: Erased
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.CopyBlocks</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>895</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1261</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_RevalidateOldSection</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Impl_Switch_Common_2_3_4/source/application/tests_Switch234s_Common.c</sourcefile>
      <sourceline>387</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch works correctly and after the section is copied 
  the section is revalidated.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block, until Fee gets round to the same Active section index.
        By then the section shall be empty and consistent.
    08. Exclusively write/invalidate blocks in the section that was supposed to be revalidated by switch.
    09. Simulate RESET
    10. Perform initialization, (Startup1)
    11. Read the exclusive blocks and validate them.
    12. Check for flash errors
    13. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.RevalidateOldSection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>896</internalId></provcov>
        <provcov>
          <linksto>Fee.ConsistencyPatterns.SectionHeader.Write</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>271</internalId></provcov>
        <provcov>
          <linksto>Fee.ConsistencyPatterns.SectionHeader.Read.Startup</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>270</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1262</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_ImmediatelyAfterInit</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Impl_Switch_Common_2_3_4/source/application/tests_Switch234s_Common.c</sourcefile>
      <sourceline>533</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch is triggered correctly.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block, until Fee enters switch.
    08. Perform a couple of switch steps.
    09. Simulate RESET
    10. Perform initialization, (Startup1)
    11. VP(Fee.Dsn.Initialization.Startup2.07): Request a job to trigger Startup2 and make sure that Startup2 is triggered and not Switch
    12. Get over the delay timer
    13. Check that Startup2 started.
    14. Finish Startup2. If also the Switch that was interrupted by reset is finished,
        it means that the Switch started directly after Startup2 and there was no need of a triggering job.
    15. Erase all the sections except the current Active section.
    16. VP(Fee.Dns.SS.TriggeringTheSwitch.AfterInit): Check that the switch had finished indeed.
    17. Check for flash errors
    18. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.TriggeringTheSwitch.AfterInit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>900</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup2.07</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>856</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1263</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_SwitchPriority_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Impl_Switch_Common_2_3_4/source/application/tests_Switch234s_Common.c</sourcefile>
      <sourceline>716</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch works correctly in highest priority regarding comming jobs. 
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block. Keep writing the block until Fee enters high priority switch.
    08. A high priority switch has started.
        Perform a couple of switch steps.
    09. Finish the requested write that caused high priority switch.
    10. VP(Fee.Dns.SS.SwitchPriority.JobLosesPriority): Check that when the write is over the switch is also over.
        Therefore the job must have been done after the switch.
    11. Erase all the sections except the current Active section.
    12. Check that the switch had finished indeed.
    13. Check for flash errors
    14. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.SwitchPriority</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>905</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.SS.SwitchPriority.JobLosesPriority</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>908</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1264</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_InvalidateTrigger</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Impl_Switch_Common_2_3_4/source/application/tests_Switch234s_Common.c</sourcefile>
      <sourceline>873</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch is triggered by invalidation job requests. 
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write the block that will be monitored for switch
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block, until Fee is write before entering switch.
    08. Check that Fee is in idle and the switch has not started
    09. Invalidate a bunch of blocks and check that Fee starts to perform a switch
    10. Get over the delay timer
    11. Finish the switch
    12. Erase all the sections except the current Active section.
    13. Check that the switch has been performed.
    14. Check for flash errors
    15. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.TriggeringTheSwitch.InvalidateRequest</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>898</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1265</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_EraseImmTrigger</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Impl_Switch_Common_2_3_4/source/application/tests_Switch234s_Common.c</sourcefile>
      <sourceline>1026</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch is triggered by erase immediate job requests. 
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write the block that will be monitored for switch
    05. These imm blocks shall not be switched because we erase them when starting switch
    06. Perform Startup2
    07. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    08. Fill one section at a time by writing a different block, until Fee is write before entering switch.
    09. Check that Fee is in idle and the switch has not started
    10. Erase a bunch of imm blocks and check that Fee starts to perform a switch
    11. Get over the delay timer
    12. Finish the switch
    13. Erase all the sections except the current Active section.
    14. Check that the switch has been performed.
    15. Check that the erased immediate blocks were not switched
    16. Check for flash errors
    17. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.TriggeringTheSwitch.EraseRequest</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>899</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1266</internalId></specobject>
    <specobject>
      <id>TS_Fee_ReconfWrite</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Impl_Switch_Common_2_3_4/source/application/tests_Switch234s_Common.c</sourcefile>
      <sourceline>1195</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests that if a block is found first written with an old length and in the same section
  the same block is found in the same section written with the current configured length,
  Fee ignores the older version of the block, and the user can successfully read the latest block instance.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
  01. Set the initial test result
  02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
  03. Perform Startup1
  04. Simulate the write of two blocks with an older configuration:
   one with a smaller size than currently configured and the other with a larger size
  05. Write the same blocks with the current configuration in the same section
  06. Simulate RESET

  07. Check that the blocks are read correctly with the current configuration
    (startup is implicitly done in this step)
  08. Check for flash errors
  09. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeDynamicBlockLength.Config</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>292</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeDynamicBlockLength.Write</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>296</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1267</internalId></specobject>
    <specobject>
      <id>TS_Fee_ReconfWriteSwitch</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Impl_Switch_Common_2_3_4/source/application/tests_Switch234s_Common.c</sourcefile>
      <sourceline>1302</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests if the reconfigured blocks are written with the new configuration, the switch copies them by
  the new configuration.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write the blocks with the current configuration
    05. Write the blocks that are supposed to be the same blocks but with different sizes,
        by simulation
    09. Simulate RESET
    10. Perform initialization, (Startup1)
    11. Write the blocks with the current configuration again
    12. Memorize the Active section index and verify that all the other sections are empty.
       (All sections shall be empty now, except the Active section)
    13. Fill one section at a time by writing a different block, until Fee is write before entering switch.
    14. Start the switch15. Finish the switch
    16. Check that the blocks were switched with the current configuration
    17. Check for flash errors
    18. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeDynamicBlockLength.Config</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>292</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeDynamicBlockLength.Write</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>296</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1268</internalId></specobject>
    <specobject>
      <id>TS_Fee_ReconfReadWrite</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Impl_Switch_Common_2_3_4/source/application/tests_Switch234s_Common.c</sourcefile>
      <sourceline>1457</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the reconfigure blocks are read correctly, the one that turned bigger is read truncated and
  the one that is turned smaller is filled at the end with the last data byte reversed.
  The job result values are also checked to be MEMIF_JOB_OK_SIZE_DECREASED and MEMIF_JOB_OK_SIZE_INCREASED respectively.
  One the blocks are written everything returns to standard behavior.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write the blocks with the current configuration
    05. Write the blocks that are supposed to be the same blocks but with different sizes,
        by simulation
    06. Simulate RESET
    07. Perform initialization, (Startup1)
    08. Read the first reconfigured block
    09. Call with dummy value, just to make sure that the destination buffer is cleared
    10. Verify that MEMIF_JOB_OK_SIZE_DECREASED is reported to the upper layer
    11. Verify the content (step1):
        The first block was bigger before. Check that only the old length of bytes was read..
    12. Verify the content (step2):
        ..and no overflow of the application's buffer occurs. The in flash was truncated.
    13. Read the second reconfigured block
    14. Verify that MEMIF_JOB_OK_SIZE_INCREASED is reported to the upper layer
    15. Verify the content (step1):
        The second block was smaller before. Check that only the old length of bytes was read..
    16. Verify the content (step2):
        ..and according to the new configuration, the extra bytes are filled with the last data byte reversed.
    17. Read a random byte of the second reconfigured block
    18. Verify that MEMIF_JOB_OK_SIZE_INCREASED is reported even in this case
    19. Verify the content (step1):
        The second block was smaller before. Check that only the old length of bytes was read..
    20. Write the blocks with the current configuration
    21. Check that the blocks were indeed updated with the new configuration
    22. Check for flash errors
    23. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeDynamicBlockLength.Config</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>292</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeDynamicBlockLength.IncreasedSizePedding</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>293</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeDynamicBlockLength.IncreasedSizeResult</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>294</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeDynamicBlockLength.DecreasedSizeResult</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>295</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.DynamicBlockLength.Switch</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>953</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1269</internalId></specobject>
    <specobject>
      <id>TS_Fee_ReconfSwitchRead</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Impl_Switch_Common_2_3_4/source/application/tests_Switch234s_Common.c</sourcefile>
      <sourceline>1666</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the reconfigure blocks are read correctly after a section switch, the one that turned bigger
  is read truncated and the one that is turned smaller is filled at the end with the last data byte reversed.
  The job result values are also checked to be MEMIF_JOB_OK_SIZE_DECREASED and MEMIF_JOB_OK_SIZE_INCREASED respectively.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write the blocks with the current configuration
    05. Write the blocks that are supposed to be the same blocks but with different sizes,
        by simulation
    06. Simulate RESET
    07. Perform initialization, (Startup1)
    08. Memorize the Active section index and verify that all the other sections are empty.
       (All sections shall be empty now, except the Active section)
    09. Fill one section at a time by writing a different block, until Fee is write before entering switch.
    10. Trigger the switch
    11. Finish the switch
    12. Check that the first reconfigured blocks are correctly copied by the switch
    13. Call with dummy value, just to make sure that the destination buffer is cleared
    14. Verify that MEMIF_JOB_OK_SIZE_DECREASED is reported to the upper layer
    15. Verify the content (step1):
        The first block was bigger before. Check that only the old length of bytes was read..
    16. Verify the content (step2):
        ..and no overflow of the application's buffer occurs. The in flash was truncated.
    17. Check that the second reconfigured blocks are correctly copied by the switch
    18. Verify that MEMIF_JOB_OK_SIZE_INCREASED is reported to the upper layer
    19. Verify the content (step1):
        The second block was smaller before. Check that only the old length of bytes was read..
    20. Verify the content (step2):
        ..and according to the new configuration, the extra bytes are filled with the last data byte reversed.
    21. Check for flash errors
    22. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.FeeDynamicBlockLength.Config</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>292</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeDynamicBlockLength.IncreasedSizePedding</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>293</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeDynamicBlockLength.IncreasedSizeResult</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>294</internalId></provcov>
        <provcov>
          <linksto>Fee.FeeDynamicBlockLength.DecreasedSizeResult</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>295</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.DynamicBlockLength.Switch</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>953</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1270</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_Fee_Switch_Restart_DueToFailures</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Impl_Switch_Common_3_4/source/application/tests_Switch34s_Common.c</sourcefile>
      <sourceline>45</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch is restarted in case of failure causing no more space for switch. 
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Fill the section
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Keep writing the block until Fee is right before high priority switch.
    08. A high priority switch has started.
        Fee will start to switch the block. Run until Switch performs read data
    09. Until Switch performs copy data
    10. Fail the block switching until there is no more space to switch all the blocks
    11. Last operation performed was a copy data of the last failing block switch in order to be left with no space for switching.
        Therefore simulate write fail.
    12. Now the blocks to be switched can not fit in the section. The switch is restarted after section revalidation
        Restart switch has the highest priority, therefore the next requested job will be processed after the switch.
    13. Now Fee is busy due to the read requested. It shall stay busy as long as the restart switch is ongoing,
        till the read is finaly processed. Perform Restart Switch
    14. By now the switch shall be finished. Erase all the sections except the current Active section.
    15. Check that the switch had finished indeed.
    16. Check for flash errors
    17. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.RestartSwitch</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>912</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.SS.RestartSwitch.ConditionForRestart</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>909</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.SS.RestartSwitch.Priority</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>911</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.SS.RestartSwitch.TriggerAfterInit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>910</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1271</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_Restart_DueToResets</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Impl_Switch_Common_3_4/source/application/tests_Switch34s_Common.c</sourcefile>
      <sourceline>244</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch is restarted in case of resets causing no more space for switch. 
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Fill the section
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block. Keep writing the block until Fee enters high priority switch.
    08. Fail the block switching until there is no more space to switch all the blocks
    09. Simulate RESET
    10. Request a write in order to resume high priority switch
    11. Now the blocks to be switched can not fit in the section. The switch is restarted after section revalidation.
        FeeBlock_NormalImm must be also switched by normal switch from the second section into the third section.
    12. Erase all the sections except the current Active section.
    13. Check that the switch had finished indeed.
    14. Check for flash errors
    15. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.RestartSwitch</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>912</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.SS.RestartSwitch.TriggerAfterInit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>910</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.SS.RestartSwitch.ConditionForRestart</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>909</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1272</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_HP_ImmediatelyAfterInit</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Impl_Switch_Common_3_4/source/application/tests_Switch34s_Common.c</sourcefile>
      <sourceline>446</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch is triggered correctly even in highest priority. 
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block. Keep writing the block until Fee enters high priority switch.
    08. Perform a couple of switch steps.
    09. Simulate RESET
    10. Request a read that after completion shall resume high priority switch
    11. Finish the read request
    12. Get over the delay timer
    13. Check that high priority switch is started.
    14. Start the high priority switch
    15. Request one more read that shall not interrupt the high priority switch
    16. Go to the first flash read operation. It should be a switch read.
    17. Check that the user read job is still pending
    18. Perform the high priority switch
    19. Finish the read job
    20. Get over the delay timer
    21. Check that normal switch is started.
    22. Perform the switch
    23. Erase all the sections except the current Active section.
    24. Check that the switch had finished indeed.
    25. Check for flash errors
    26. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.Sections.11</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>831</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup2.07</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>856</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1273</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_Timer</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Impl_Switch_Common_3_4/source/application/tests_Switch34s_Common.c</sourcefile>
      <sourceline>670</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the timer is respected in case of interruptions durring switch. 
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block, until Fee enters switch.
    08. Perform a couple of switch steps.
    09. Request a write
    10. Check that Fee is temporarily idle
    11. Get over the delay timer
    12. Check that the switch is resumed
    13. Perform a couple of switch steps.
    14. Request a read
    15. Check that Fee is temporarily idle
    16. Get over the delay timer
    17. Check that the switch is resumed
    18. Perform a couple of switch steps.
    19. Request a invalidation
    20. Check that Fee is temporarily idle
    21. Get over the delay timer
    22. Check that the switch is resumed
    23. Perform a couple of switch steps.
    24. Request a erase imm
    25. Check that Fee is temporarily idle
    26. Get over the delay timer
    27. Check that the switch is resumed
    28. Perform switch.
    29. Check that the switch had finished indeed.
    30. Check for flash errors
    31. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Timer.UserJobRequests</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>859</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Timer.InternalOperation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>861</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1274</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_WriteResumed</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Impl_Switch_Common_3_4/source/application/tests_Switch34s_Common.c</sourcefile>
      <sourceline>921</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch resumes the interrupted write operation.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block, until Fee enters switch.
    08. Take the current free space in the active section after only one block copied.
    09. Until Switch performs read data
    10. Until Switch performs write data
    11. Finish the write of the first buffer. (this is a case of a big block, but it should work for a small block too,
        since the block switching is not finished until the written marker is completed)
    12. Request a write that interrupts the switch right after a switch data write has been done.
    13. Finish the switch.
    14. Check that switch resumed the data writing of the block that was being switched instead of restarting it.
        Now that the switch is over the occupied size in active section shall be
        by the switched blocks and the block that interrupted the switch, taken only once.
    15. Check that the switch had finished indeed.
    16. Check for flash errors
    17. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.Behaviour.SSResume.BlockSwitching.Writing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>901</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1275</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_JobInterrupts_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Impl_Switch_Common_3_4/source/application/tests_Switch34s_Common.c</sourcefile>
      <sourceline>1100</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch behaves correctly if interrupted by user job requests. 
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block, until Fee enters switch.
    08. Take the current free space in the active section after only one block copied.
    09. First step in switching a block is done here: copying block info
    10. Request a write that interrupts the switch right during a switch block info.
    11. Finish the block info copy job at Fls level.
    12. Process the user requested job
    13. Until Switch starts to perform read data
    14. Check that Fee did not transmit the user interruptions to Fls during block info switch
    15. Request a write that interrupts the switch right during a switch data reading.
    16. Check that Fee did canceled the switch reading by transmitting the interruption to Fls
    17. Now, instead of continuing the switch reading, Fee sent a new job to Fls (the user invalidation)
    18. Process the user requested job
    19. Fee restarts the switch reading
    20. Until Switch starts to perform write data
    21. Request a write that interrupts the switch right during a switch data write.
    22. Finish the write of the first buffer. (this is a case of a big block, but it should work for a small block too,
        since the block switching is not finished until the written marker is completed)
    23. Process the user requested job
    24. Get over the delay timer
    25. Finish the switch.
    26. Check that switch resumed the data writing of the block that was being switched instead of restarting it.
        Now that the switch is over the occupied size in active section shall be
        by the switched blocks and the block that interrupted the switch, taken only once.
    27. Check that the switch had finished indeed.
    28. Check if Fee transmit the user interruptions to Fls others than for switch reading.
    29. Check for flash errors
    30. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.Behaviour.SSResume.BlockSwitching.Writing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>901</internalId></provcov>
        <provcov>
          <linksto>Fee.SS.UserJobRequests</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>260</internalId></provcov>
        <provcov>
          <linksto>Fee.Dsn.Read.Behaviour.SSOngoing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>872</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1276</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_ReadRestarted</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Impl_Switch_Common_3_4/source/application/tests_Switch34s_Common.c</sourcefile>
      <sourceline>1366</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch restarts the interrupted read operation. 
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block, until Fee enters switch.
    08. Until Switch performs read data
    09. Request a write that interrupts the switch right in the moment of reading data to be switch.
    10. Check that Fee is in idle now
    11. Resume the switch
    12. Check that Switch restarts the reading and not writing whatever is in internal buffer
    13. Finish the switch.
    14. Check that the switch had finished indeed.
    15. Check for flash errors
    16. Set test case result

Test Input: 
  None.

Test Output: 
 None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.Behaviour.SSResume.BlockSwitching.Reading</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>902</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1277</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_ChangingActive</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Impl_Switch_Common_3_4/source/application/tests_Switch34s_Common.c</sourcefile>
      <sourceline>1535</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch changes the section if there is no more space in the current one. 
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block, until Fee enters switch.
    08. Update the oldest section index
    09. Write until the space in section gets smaller than first 3 blocks in BlocksToBeSwitched
    10. Get over the delay timer(&gt;2 sections)
    11. Finish the switch.
    12. Only the first 3 blocks are switched in the current section and the other 3 will be switched in the next section
    13. Erase all the sections except the current Active section.
    14. Read the blocks that are supposed to be switched in the last section.
        Therefore Switch must have changed the active section since there was no more space for switching all the blocks
    15. Check for flash errors
    16. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.Behaviour.ChangingActiveSection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>904</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1278</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_SwitchPriority_3</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Impl_Switch_Common_3_4/source/application/tests_Switch34s_Common.c</sourcefile>
      <sourceline>1712</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch works correctly in highest priority regarding comming jobs. 
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block. Keep writing the block until Fee enters high priority switch.
    08. Now let the switch to trigger itself the highest priority
        Perform a couple of switch steps.
    09. Request a read that must be accepted during high priority switch since there is no job memorised.
    10. Finish the requested read. When the read is finished switch must also has been finished.
    11. Check that when the read is over the switch is also over. Therefore the job must have been done right after the switch.
    12. Erase all the sections except the current Active section.
    13. Check that the switch had finished indeed.
    14. Check for flash errors
    15. Set test case result

Test Input: 
  None.

Test Output: 
  None.
</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.SwitchPriority</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>905</internalId></provcov>
        <provcov>
          <linksto>Fee.Dns.SS.SwitchPriority.JobLosesPriority</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>908</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1279</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_BlockToSwitch</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Impl_Switch_Common_3_4/source/application/tests_Switch34s_Common.c</sourcefile>
      <sourceline>1871</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests whether the section switch does not copy the blocks that are successfully written(by user) 
in the active section. 
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform Startup1
    04. Write 2 blocks and invalidate one. These blocks will never be written again in the test.
    05. Perform Startup2
    06. Memorize the Active section index and verify that all the other sections are empty.
        (All sections shall be empty now, except the Active section)
    07. Fill one section at a time by writing a different block, until Fee enters switch.
    08. Now, in the section where the switch starts, only the block that triggered the switch is written.
    09. Request to write all the blocks that need to be switch
    10. Finish the switch.
    11. Check that switch does not copy the old instances
    12. Check that the switch had finished indeed.
    13. Check for flash errors
    14. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dns.SS.SwitchPriority.BlockToSwitch</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>907</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1280</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_BigLostSectionSize</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Impl_Switch_Common_3_4/source/application/tests_Switch34s_Common.c</sourcefile>
      <sourceline>2020</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests that in case multiple corrupted block infos are found at initialization,
  when a Section Switch was interrupted, Fee will not misscalculate the section
  data address considering the huge lost section size found,
  and it will switch the blocks correctly. No blocks should be lost. 
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform initialization, (Startup1 and Startup2)
    04. Write some blocks.
    05. Write a block until Fee enters switch.
    06. Monitor the section index.
    07. Get over the delay timer
    08. Roughly calculate how many consecutive block infos must be found corrupted (x block infos)
        in order to have a sufficiently large FeeLostSectionSize to overflow to the next section.
    09. Simulate the corruption of x consecutive block info in the Active section.
        Leave the written block info untouched, to have at least o valid block info.
    10. Simulate RESET
    11. Perform initialization, (Startup1 and Startup2)
    12. Initiate a read job.
    13. Finish the read job. This will resume the switch.
    14. Get over the delay timer
    15. Perform section switching
    16. Simulate RESET
    17. Check that the blocks are switched correctly as they can be found valid at init.
    18. Check for flash errors
    19. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.InvalidLastBlockInfos</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>843</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1281</internalId></specobject>
    <specobject>
      <id>TS_Fee_Switch_BigInvalidBlockAddress</id>
      <status>approved</status>
      <source>EB test case specification (asc_Fee)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Fee/test/ts5/Include/Fee_Impl_Switch_Common_3_4/source/application/tests_Switch34s_Common.c</sourcefile>
      <sourceline>2191</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Tests that while in section switch, if a reset comes during the writing of a block info
  so that the data address has the erased value and the checksum matches by chance,
  Fee will not update the data address with the invalid address, going outside the section range.
  No blocks should be lost.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  All sections are inconsistent.

Test Execution: 
    01. Set the initial test result
    02. Initialize the stubs, simulate hardware reset, erase flash and initialize Fee
    03. Perform initialization, (Startup1 and Startup2)
    04. Write some blocks.
    05. Write a block until Fee enters switch.
    06. Monitor the section index.
    07. Get over the delay timer
    08. Simulate the fail of writing the address of the block data
    09. Simulate a checksum that matches by chance for this corrupted block info
    10. Simulate RESET
    11. Perform initialization, (Startup1 and Startup2)
    12. Initiate a read job.
    13. Finish the read job. This will resume the switch.
    14. Get over the delay timer
    15. Perform section switching
    16. Simulate RESET
    17. Check that the blocks are switched correctly as they can be found valid at init.
    18. Check that the BlockToFillSection was also switched.
    19. Check for flash errors
    20. Set test case result

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Fee.Dsn.Initialization.Startup1.InvalidLastBlockInfos</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>843</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1282</internalId></specobject>
  </specobjects>
  </specdocument>
  <violations/>
  <oreqmViolations/>
</tracingresults>
