<?xml version="1.0" encoding="UTF-8"?>
<tracingresults>
  <environment>
    <toolname>ReqM2</toolname>
    <toolversion>1.30.0 (stable)</toolversion>
    <toolcopyright>Copyright 2010 - 2018 Elektrobit Automotive GmbH</toolcopyright>
    <libxmlversion>2.0207</libxmlversion>
    <libxml2compileversion>2.9.10</libxml2compileversion>
    <libxml2runtimeversion>20912</libxml2runtimeversion>
    <perlversion>v5.32.1</perlversion>
    <perlptrsize>64</perlptrsize>
    <commandline>-t -q -o asc_CanTp_tracing_cmdb.oreqm -O /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/TestProtocols/LogBase/requirements -c /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_PluginBuildEnv/common/config/AutoCoreReqM2Rules_RMP4_0.xml -s approved,rejected --wfatal WDUPLICATEID,WDUPLICATEIDANDVER /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/build/reqm/ReqM2_Native/asc_CanTp_public_modulereference_integration_req.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/build/reqm/ReqM2_Native/asc_CanTp_requirements_CanTp_4_0_3.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/build/reqm/ReqM2_Native/asc_CanTp_requirements_CanTp_Design_Requirements.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/build/reqm/ReqM2_Native/asc_CanTp_requirements_CanTp_R20-11.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/build/reqm/ReqM2_Native/asc_CanTp_requirements_CanTp_TpAPI-refinement.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/build/reqm/ReqM2_Native/asc_CanTp_requirements_EB_requirements.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/build/reqm/ReqM2_Native/asc_CanTp_requirements_iso15765.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/build/reqm/ReqM2_Native/asc_CanTp_requirements_jumptable.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/build/reqm/ReqM2_Native/asc_CanTp_test_manConfTests.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/build/reqm/common_req/CanTp_DbgInst_EB_Extension.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/build/reqm/common_req/CanTp_PbcfgM_EB_Extension.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/build/reqm/common_req/CanTp_PduLengthType_EB_Extension.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/build/reqm/common_req/CanTp_VerifyStub_EB_Extension.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/build/reqm/ReqM2_GenericImporter/reqm_DEV.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/build/reqm/ReqM2_GenericImporter/reqm_IMPL.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/build/reqm/ReqM2_GenericImporter/reqm_IMPLXML.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/build/reqm/ReqM2_DocBookImporter/reqm_SWDD.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/build/reqm/ReqM2_OldCImporter/reqm_SWUTS_LEGACY.reqm</commandline>
    <timestamp>Mon Jun 17 21:46:07 2024</timestamp>
  </environment>
  <cmdline>
    <cmdparam>
      <name>I</name>
      <values>
        <value>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/TestProtocols/LogBase/requirements</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>O</name>
      <values>
        <value>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/TestProtocols/LogBase/requirements</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>c</name>
      <values>
        <value>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_PluginBuildEnv/common/config/AutoCoreReqM2Rules_RMP4_0.xml</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>o</name>
      <values>
        <value>asc_CanTp_tracing_cmdb.oreqm</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>q</name>
    </cmdparam>
    <cmdparam>
      <name>s</name>
      <values>
        <value>approved</value>
        <value>rejected</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>t</name>
    </cmdparam>
    <cmdparam>
      <name>wfatal</name>
      <values>
        <value>WDUPLICATEID</value>
        <value>WDUPLICATEIDANDVER</value>
      </values>
    </cmdparam>
  </cmdline>
  <inputfiles>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/build/reqm/ReqM2_Native/asc_CanTp_public_modulereference_integration_req.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/build/reqm/ReqM2_Native/asc_CanTp_requirements_CanTp_4_0_3.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/build/reqm/ReqM2_Native/asc_CanTp_requirements_CanTp_Design_Requirements.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/build/reqm/ReqM2_Native/asc_CanTp_requirements_CanTp_R20-11.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/build/reqm/ReqM2_Native/asc_CanTp_requirements_CanTp_TpAPI-refinement.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/build/reqm/ReqM2_Native/asc_CanTp_requirements_EB_requirements.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/build/reqm/ReqM2_Native/asc_CanTp_requirements_iso15765.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/build/reqm/ReqM2_Native/asc_CanTp_requirements_jumptable.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/build/reqm/ReqM2_Native/asc_CanTp_test_manConfTests.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/build/reqm/common_req/CanTp_DbgInst_EB_Extension.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/build/reqm/common_req/CanTp_PbcfgM_EB_Extension.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/build/reqm/common_req/CanTp_PduLengthType_EB_Extension.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/build/reqm/common_req/CanTp_VerifyStub_EB_Extension.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/build/reqm/ReqM2_GenericImporter/reqm_DEV.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/build/reqm/ReqM2_GenericImporter/reqm_IMPL.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/build/reqm/ReqM2_GenericImporter/reqm_IMPLXML.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/build/reqm/ReqM2_DocBookImporter/reqm_SWDD.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/build/reqm/ReqM2_OldCImporter/reqm_SWUTS_LEGACY.reqm</inputfile>
  </inputfiles>
  <configuration>
    <doctypes>
    <regexs>
      <!-- external level -->
      <regex>creq</regex>       <!-- since 10/1018: introduced for updated tracing model-->

      <!-- product line level -->
      <regex>fea</regex>
      <regex>swpad</regex>      <!-- since 10/1018: introduced for updated tracing model-->
      <regex>swts</regex>

      <!-- bundle level -->
      <regex>swrs</regex>
      <regex>swad</regex>
      <regex>swintts</regex>

      <!-- module level -->
      <regex>swdd</regex>
      <regex>swurs</regex>      <!-- since 10/1018: introduced for updated tracing model-->
      <regex>swmts</regex>      <!-- since 01/1010: introduced for updated tracing model RMP4.0-->
      <regex>swuts</regex>
      <regex>impl</regex>

      <!-- legacy items -->
      <regex>dev</regex>
      <regex>man</regex>
      <regex>lim</regex>
    </regexs>
  </doctypes>
    <rules>
    <!-- The Ruleset for RMP4.0 is currently identical to the previous rule set. This rule is
        intoduce to show that the right file is uses. It will be removed when the RMP4.0 rule set is
    reworked -->
    <rule>
      <name>INFO.Rule set RMP4.0</name>
      <description>This rules indicates that RMP4.0 rule set is used.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status!='approved') and (./status!='rejected')]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>WRN.general.doctypes</name>
      <description>The used doctype is not part of the tracing model</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobjects/@doctype</applyto>
          <condition>((. != 'creq') or (. != 'fea') or (. != 'swpad') or (. != 'swts') or (. != 'swrs') or (. !='swad') or (. != 'swintts') or (.!= 'swdd') or (. != 'swurs') or (. != 'swmts') or (. != 'swuts') or (. != 'impl') or (. != 'dev') or (. != 'man') or (. != 'lim'))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.status</name>
      <description>All specification objects must be either in status=approved or in status=rejected. Other
        statuses are not allowed. How to fix: Set status to rejected or approved.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status!='approved') and (./status!='rejected')]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.rejected</name>
      <description>Status status=rejected is only allowed for requirements. How to fix: set to approved for specification object that are not requirements.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype!='swrs')  and (../@doctype!='swmrs') and (../@doctype!='swurs') and (./status='rejected')]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.comment</name>
      <description>Specification objects with status=rejected shall have a comment or rationale that
        starts with on of the following texts: "This requirement is informational only", "This requirement is not applicable".
        How to fix: Add some text starting with "This requirement is informational only"
        or "This requirement is not applicable" to either the comment or to the rationale.
        Comment: Implementation of check checks for contains instead of starts-with since there is
        no trim function in the used XPATH engine.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status='rejected')]</applyto>
          <condition>contains(./comment,"This requirement is informational only") or contains(./rationale,"This requirement is informational only") or contains(./comment,"This requirement is not applicable") or contains(./rationale,"This requirement is not applicable")</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.rejected.coverage</name>
      <description>Specification objects with status=rejected shall not need coverage. How to fix: remove need for coverage.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status='rejected')]</applyto>
          <condition>count(./needscoverage)=0</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swurs.needscoverage.count</name>
      <description>Unit requirements with status=approved need to be covered, exceptions from
      this rule: configuration requirements (postfix "_CONF" or "_Conf" or prefix "ECUC_") and requirements with
      a comment starting with "The adherence to this requirement is ensured by the following
      release check (URL to the checklist template plus ID of the check):".
      How to fix: Provide a needsobj element for those specobjects or comment according to the rule.
      </description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swurs') and (./status='approved') and count(./needscoverage/needsobj)=0 and count(./fulfilledby/ffbObj)=0]</applyto>
          <!--This condition is false if the id of a specification object does not end with '_Conf' or '_CONF' or does not start with ECUC_ -->
          <condition>substring-after(./id,"ECUC_")!="" or substring-before(./id,"_Conf")!="" or substring-before(./id,"_CONF")!="" or contains(./comment,"The adherence to this requirement is ensured by the following release check (URL to the checklist template plus ID of the check):")</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swurs.needscoverage.rationale</name>
      <description>Requirements with status=approved and without coverage needs that are
        configuration requirements (postfix "_CONF" or "_Conf" or prefix "ECUC_") shall have a comment or rationale
        with the following text: "This is a configuration parameter requirement without functional
        specification.". How to fix: Add some text starting with "This is a configuration parameter
        requirements without functional specification" to either the comment or to the rationale.</description>
      <regexchecks>
        <regexcheck>
          <applyto>//specobject[(../@doctype='swurs') and (./status='approved') and count(./needscoverage/needsobj)=0 and (substring-after(./id,"ECUC_")!="" or substring-before(./id,"_CONF")!="" or substring-before(./id,"_Conf")!="")]</applyto>
          <regex>This is a configuration parameter requirement without functional specification.</regex>
        </regexcheck>
      </regexchecks>
    </rule>

    <rule>
      <name>ERR.swrs.needscoverage.rationale</name>
      <description>Requirements with status=approved and without coverage needs that are
        configuration requirements (postfix "_CONF" or "_Conf" or prefix "ECUC_") shall have a comment or rationale
        with the following text: "This is a configuration parameter requirement without functional
        specification.". How to fix: Add some text starting with "This is a configuration parameter
        requirements without functional specification" to either the comment or to the rationale.</description>
      <regexchecks>
        <regexcheck>
          <applyto>//specobject[(../@doctype='swrs') and (./status='approved') and count(./needscoverage/needsobj)=0 and (substring-after(./id,"ECUC_")!="" or substring-before(./id,"_CONF")!="" or substring-before(./id,"_Conf")!="")]</applyto>
          <regex>This is a configuration parameter requirement without functional specification.</regex>
        </regexcheck>
      </regexchecks>
    </rule>

    <rule>
      <name>ERR.swurs.releases</name>
      <description>Requirements which originates from AUTOSAR (source tag contains term 'AUTOSAR_SWS', 'AUTOSAR_TPS',
        'AUTOSAR_ASWS' or 'AUTOSAR_TR') shall have their release tag set to 'AUTOSAR {major}.{minor}.{patch}' (e.g. 'AUTOSAR 4.3.0').
        Other requirements (including refinements of AUTOSAR requirements) must not contain any of the listed prefixes as
        part of the source tag.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swurs') and (contains(./source,'AUTOSAR_SWS') or contains(./source,'AUTOSAR_TPS') or contains(./source,'AUTOSAR_ASWS') or contains(./source,'AUTOSAR_TR'))]</applyto>
          <condition>contains(./releases/release,'AUTOSAR')</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swrs.releases</name>
      <description>Requirements which originates from AUTOSAR (source tag contains term 'AUTOSAR_SWS', 'AUTOSAR_TPS',
        'AUTOSAR_ASWS' or 'AUTOSAR_TR') shall have their release tag set to 'AUTOSAR {major}.{minor}.{patch}' (e.g. 'AUTOSAR 4.3.0').
        Other requirements (including refinements of AUTOSAR requirements) must not contain any of the listed prefixes as
        part of the source tag.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swrs') and (contains(./source,'AUTOSAR_SWS') or contains(./source,'AUTOSAR_TPS') or contains(./source,'AUTOSAR_ASWS') or contains(./source,'AUTOSAR_TR'))]</applyto>
          <condition>contains(./releases/release,'AUTOSAR')</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swdd.needscoverage.count</name>
      <description>Design elements with status=approved need to be covered.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swdd') and (./status='approved') and count(./needscoverage/needsobj)=0]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swurs.needscoverage.doctypes</name>
      <description>Requirements can be covered only by swurs, swad, dev, lim, swdd, impl, swuts, swmts, or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swurs')]</applyto>
          <condition>(./needscoverage/needsobj="swurs" or ./needscoverage/needsobj="swad" or ./needscoverage/needsobj="dev" or ./needscoverage/needsobj="lim" or ./needscoverage/needsobj="swdd" or ./needscoverage/needsobj="impl" or ./needscoverage/needsobj="swuts" or ./needscoverage/needsobj="swmts" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swrs.needscoverage.doctypes</name>
      <description>Requirements of type swrs can be covered only by swrs, swurs, swad, swintts or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swrs')]</applyto>
          <condition>(./needscoverage/needsobj="swrs" or ./needscoverage/needsobj="swurs" or ./needscoverage/needsobj="swad" or ./needscoverage/needsobj="swuts" or ./needscoverage/needsobj="swintts" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swdd.needscoverage.doctypes</name>
      <description>Design elements of type swdd can only be covered by swdd, swurs, impl, swuts, lim or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swdd')]</applyto>
          <condition>(./needscoverage/needsobj="swdd" or ./needscoverage/needsobj="swurs" or ./needscoverage/needsobj="impl" or ./needscoverage/needsobj="swuts" or ./needscoverage/needsobj="swmts" or ./needscoverage/needsobj="lim" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.dev.needscoverage.count</name>
      <description>Deviations shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='dev')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swuts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swuts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swmts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swmts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swintts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swintts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.man.needscoverage.count</name>
      <description>Manual test cases shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='man')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.impl.needscoverage.count</name>
      <description>Source code shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='impl')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.lim.needscoverage.count</name>
      <description>Limitations shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='lim')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.fea.needscoverage.test</name>
      <description>Features shall be tested by software test ('swts') or manuel test ('man'). If no test is planned a justification shall be given.
                   A justification can be given in the futherinfo tag. The justification shall start with this rule name.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='fea')]</applyto>
          <condition>(
               ./needscoverage/needsobj="swts" or ./needscoverage/needsobj="man" or ./fulfilledby/ffbObj/ffbType="swts" or ./fulfilledby/ffbObj/ffbType="man" or contains(./furtherinfo,"fea.needscoverage.test") or contains(./furtherinfo,"fea.needscoverage.doctypes"))</condition>
        </conditioncheck>
      </conditionchecks>
          </rule>

    <rule>
      <name>WRN.fea.needscoverage.impl</name>
      <description>Features shall be covered by implementation fea, swrs, swad, swpad, swurs, man and swts. For lagacy features a justification is acceppted. A justification can be given in the futherinfo tag. The justification shall start with this rule name.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='fea')]</applyto>
          <condition>( ./needscoverage/needsobj="swrs" or ./fulfilledby/ffbObj/ffbType="swrs" or ./fulfilledby/ffbObj/ffbType="swad" or ./needscoverage/needsobj="swpad" or ./fulfilledby/ffbObj/ffbType="swpad" or ./needscoverage/needsobj="swurs" or ./fulfilledby/ffbObj/ffbType="swurs" or ./needscoverage/needsobj="fea" or ./fulfilledby/ffbObj/ffbType="fea" or contains(./furtherinfo,"fea.needscoverage.impl"))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>


    <rule>
      <name>ERR.swad.fulfilledby.doctypes</name>
      <description>Architectural design objects of type swad can only be covered by swurs, swad, swdd, swintts, man, otherwise they should be refined with swrs</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swad')]</applyto>
          <condition>(./fulfilledby/ffbObj/ffbType="swurs" or ./needscoverage/needsobj="swurs" or ./fulfilledby/ffbObj/ffbType="req" or ./needscoverage/needsobj="req" or ./fulfilledby/ffbObj/ffbType="swad" or ./needscoverage/needsobj="swad" or ./fulfilledby/ffbObj/ffbType="swdd" or ./fulfilledby/ffbObj/ffbType="swintts" or ./needscoverage/needsobj="swintts" or ./fulfilledby/ffbObj/ffbType="man" or ./needscoverage/needsobj="man") </condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swmts.providescoverage.doctypes</name>
      <description>Test case specifications (tcs) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='tcs')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.man.providescoverage.doctypes</name>
      <description>Manual test case specification (man) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='man')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

   <rule>
      <name>ERR.swuts.providescoverage.doctypes</name>
      <description>Software unit test case specification (swuts) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swuts')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

   <rule>
      <name>ERR.swintts.providescoverage.doctypes</name>
      <description>Software integration test case specification (swintts) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swintts')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

   <rule>
      <name>ERR.swts.providescoverage.doctypes</name>
      <description>Software test case specification (swts) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swts')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

  </rules>
    <oreqmRules>

        <rule>
            <name>WRN.swts.needscoverage.count</name>
            <description>Violated if there are more than 10 swts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
        <rule>
            <name>WRN.man.needscoverage.count</name>
            <description>Violated if there are more than 10 man specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='man']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='man']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>man.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
        <rule>
            <name>WRN.swintts.needscoverage.count</name>
            <description>Violated if there are more than 10 swintts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swintts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swintts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swintts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
        <rule>
            <name>WRN.swmts.needscoverage.count</name>
            <description>Violated if there are more than 10 swmts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swmts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swmts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swmts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swuts.needscoverage.count</name>
            <description>Violated if there are more than 10 swuts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swuts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swuts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swuts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swpad.needscoverage.count</name>
            <description>Violated if there are more than 10 swpad specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swpad']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swpad']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swpad.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swrs.needscoverage.count</name>
            <description>Violated if there are more than 10 swrs specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swrs']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swrs']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swrs.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swad.needscoverage.count</name>
            <description>Violated if there are more than 10 swad specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swad']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swad']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swad.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swurs.needscoverage.count</name>
            <description>Violated if there are more than 10 swurs specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swurs']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swurs']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swurs.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swdd.needscoverage.count</name>
            <description>Violated if there are more than 10 swdd specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swdd']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swdd']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swdd.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.impl.needscoverage.count</name>
            <description>Violated if there are more than 10 impl specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='impl']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='impl']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>impl.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swrs.fulfilledby.count</name>
            <description>Violated if there are more than 10 swrs specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swrs'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swrs'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swrs.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swad.fulfilledby.count</name>
            <description>Violated if there are more than 10 swad specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swad'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swad'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swad.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swurs.fulfilledby.count</name>
            <description>Violated if there are more than 10 swurs specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swurs'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swurs'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swurs.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swdd.fulfilledby.count</name>
            <description>Violated if there are more than 10 swdd specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swdd'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swdd'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swdd.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
  </oreqmRules>
  </configuration>
  <specdocument>
    <specobjects doctype="lim">
    <specobject>
      <id>lim.CanTp.EB_INTREQ_CanTp_0001</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
      Limitation on multiple invocations of functions
      The module postpones invocations of <code>CanTp_RxIndication</code>,
      <code>CanTp_TxConfirmation</code> or the Gpt callback function in case that the
      channel is occupied to handle a previous call of these functions. In this case the incoming
      call is postponed. In case of multiple calls on an occupied channel only the last
      call is stored and all previous pending calls are discarded.
     </description>
     <rationale>
      API functions have to occupy the CanTp Channel for consistent operations. During execution
      the API function might get interrupted. Especially the three functions
      <code>CanTp_RxIndication</code>, <code>CanTp_TxConfirmation</code> and the
      Gpt callback function are relevant because they are most likely called in interrupt mode.
      The CanTp addresses this issue. One incoming call of
      <code>CanTp_RxIndication</code>, <code>CanTp_TxConfirmation</code>
      and the Gpt callback function per channel are stored and resolved at the end of the
      initial API function call. In the unlikely event of multiple calls take place while the
      channel is occupied. The last incoming frame is stored. Discarded frames segmented
      messages are detected through the sequence number check provided for this type of
      frames.
     </rationale>
      <providescoverage>
        <provcov>
          <linksto>dsn.CanTp.API.Limitation1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1091</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>0</internalId></specobject>
    <specobject>
      <id>lim.CanTp.EB_INTREQ_CanTp_0002</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
      <!-- lim.CanTp.CancellationPrecondition --><!-- ASCCANTP-825 -->
      Limitation on API <code>CanTp_CancelReceive</code> and
      <code>CanTp_CancelTransmit</code>
      The API services <code>CanTp_CancelReceive</code> and
      <code>CanTp_CancelTransmit</code> do not cancel an
      ongoing reception/transmission of a message if the API call interrupts
      data processing. In this case the APIs signalize the disability to
      cancel the communication by returning <code>E_NOT_OK</code>.

      For a successful receive cancellation following preconditions must be fulfilled:<pre>
      - Related N-SDU is in state of reception.
      - Receive cancellation is applied to a segmented message.
      - Channel is not locked.
      - CanTp is not waiting for the last consecutive frame.</pre>

      Channel is not waiting for a TX confirmation response from lower layer.

      For a successful transmit cancellation following preconditions must be fulfilled:<pre>
      - Related N-SDU is in state of transmission.
      - Channel is not locked.</pre>

      Channel is not waiting for a TX confirmation response from lower layer.
      
      Channel is not waiting for a flow control message.
      </description>
      <rationale>
      To ensure internal data consistency of a communication channel it is
      advisable to wait with the cancellation until the data handling
      mechanism frees (unlocks) the channel. A storage of the cancellation
      event to process it after the channel unlock is not possible because
      the API service shall return immediately with the correct return status
      which is not yet known.
     </rationale>
      <providescoverage>
        <provcov>
          <linksto>dsn.CanTp.API.Limitation2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1092</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1</internalId></specobject>
     <specobject>
      <id>lim.CanTp.EB_INTREQ_CanTp_0003</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
      <!-- lim.CanTp.STminAccuracy --><!-- ASCCANTP-886 -->
      The effect of CanTpGeneral/CanTpMainFunctionPeriod
      on the accuracy of the callback functions

      If CanTpSTminTimeoutHandling is configured to
      <code>CanTpMainFunction</code>, the module uses an internal counter to
      trigger the callback routine used for the STmin delay.
      Note that the accuracy of this method depends highly on the time between subsequent
      <code>CanTp_MainFunction</code> calls as specified in
      CanTpGeneral/CanTpMainFunctionPeriod. This value is also used to
      calculate the counter values for the <code>CanTp_MainFunction</code> timer.
     </description>
     <rationale/>
      <providescoverage>
        <provcov>
          <linksto>dsn.CanTp.API.Limitation3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1093</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2</internalId></specobject>
    <specobject>
      <id>lim.CanTp.EB_INTREQ_CanTp_0004</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
      <!-- lim.CanTp.ReInit --><!-- ASCCANTP-901 -->
      The reinitialization process must not interrupt other module functions
      If reinitialization of the module is required, the call of
      <code>CanTp_Init</code> must not interrupt other module functions.
     </description>
     <rationale>
     The reinitialization process resets all internal variables. Continuing and interrupted
     module function after reinitialization can lead to undefined module behavior.
     </rationale>
      <providescoverage>
        <provcov>
          <linksto>dsn.CanTp.API.Limitation4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1094</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>3</internalId></specobject>
    <specobject>
      <id>lim.CanTp.EB_INTREQ_CanTp_0005</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
      <!-- lim.CanTp.Init.Preemption --><!-- ASCCANTP-1023 -->
      <code>CanTp_Init()</code> shall not be preempted by any other module API calls.
      It needs to be ensured that the function call <code>CanTp_Init()</code> is not
      preempted by any other module API calls.
     </description>
     <rationale>
     During the call of <code>CanTp_Init()</code> global variables and pointers get
     initialized. It is easy for the integrator to avoid this preemption, thus no data protection
     mechanism has been implemented for function <code>CanTp_Init()</code>.
     </rationale>
      <providescoverage>
        <provcov>
          <linksto>dsn.CanTp.Preemption1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1090</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>4</internalId></specobject>
    <specobject>
      <id>lim.CanTp.EB_INTREQ_CanTp_0006</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
      <!-- lim.CanTp.Init.Preemption --><!-- ASCCANTP-1023 -->
      Functions <code>Gpt_StopTimer()</code> and <code>Gpt_StartTimer()</code> must be concurrently 
      callable from different partitions/cores for different Gpt channels if Gpt (CanTpGptUsageEnable) 
      is used with the multicore channel distribution feature (CanTpMultiCoreSupport).
     </description>
     <rationale/>
      <providescoverage>
        <provcov>
          <linksto>dsn.CanTp.Preemption1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1090</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>5</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs">

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00157</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        The file CanTp.h shall only contain 'external' declarations of constants, global
        data, type definitions and services that are specified in the CAN
        Transport Protocol SWS. (BSW00302)
      </description>
         <comment>
        Correctness of implementation only detectable via manual review.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
        <!-- Linked to TS_CANTP_Manual_CanTpHeaderFile -->
        <needscov><needsobj>man</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_Manual_CanTpHeaderFile</srcid><srcstatus/><internalId>952</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>6</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00266</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        Header file of the CanTp module shall provide the possibility of version
        identification of the CAN Transport module by the following macro
        definitions:
        CANTP_SW_MAJOR_VERSION,
        CANTP_SW_MINOR_VERSION,
        CANTP_SW_PATCH_VERSION,
        CANTP_AR_RELEASE_MAJOR_VERSION,
        CANTP_AR_RELEASE_MINOR_VERSION,
        CANTP_AR_RELEASE_REVISION_VERSION.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_40048</srcid><srcstatus/><internalId>1597</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>7</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00155</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        The CanTp module shall not define global data in header files (If global
        variables have to be used, the definition should take place in the C
        file) (BSW00308)
      </description>
         <comment>
        Correctness of implementation only detectable via manual review.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
        <!-- Linked to TS_CANTP_Manual_GlobalVariables -->
        <needscov><needsobj>man</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_Manual_GlobalVariables</srcid><srcstatus/><internalId>953</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>8</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00075</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
            If the transmit confirmation is not received after a maximum time (equal to
            N_As), the CanTp module shall act as if it had received an unsuccessful
            transmission confirmation and any late confirmation shall be ignored. The
            CanTp module shall cancel (internally) the failed transmission.
         </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00075_1</srcid><srcstatus/><internalId>10</internalId></linkedfrom><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00075_2</srcid><srcstatus/><internalId>11</internalId></linkedfrom><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00075_3</srcid><srcstatus/><internalId>12</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>9</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00075_1</id>
         <status>approved</status>
         <source>EB refinement</source>
         <version>1</version>
         <description>
            If the transmit confirmation is not received after a maximum time (equal
            to N_As), the CanTp module shall act as if it had received an
            unsuccessful transmission confirmation.
         </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <!-- Requirement is covered by CanTp.SWS_CanTp_00310 -->
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00310</srcid><srcstatus/><internalId>209</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.ASR40.SWS_CanTp_00075</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>9</internalId></provcov>
            <provcov>
               <linksto>CanTp.SWS_CanTp_00075</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>10</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00075_2</id>
         <status>approved</status>
         <source>EB refinement</source>
         <version>1</version>
         <description>
        If the transmit confirmation is not received after a maximum time (equal
        to N_As), the CanTp module shall cancel (internally) the failed transmission.
      </description>
         <comment>
        Internal cancellation is indicated by the call of PduR_CanTpTxConfirmation() with
        the corresponding error code.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
        <!-- Requirement is covered by CanTp.SWS_CanTp_00310 -->
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00310</srcid><srcstatus/><internalId>209</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.ASR40.SWS_CanTp_00075</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>9</internalId></provcov>
            <provcov>
               <linksto>CanTp.SWS_CanTp_00075</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>11</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00075_3</id>
         <status>approved</status>
         <source>EB refinement</source>
         <version>1</version>
         <description>
        If the transmit confirmation is not received after a maximum time (equal
        to N_As), any late confirmation shall be ignored.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30077</srcid><srcstatus/><internalId>1237</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_TimeoutFF</srcid><srcstatus/><internalId>1238</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.ASR40.SWS_CanTp_00075</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>9</internalId></provcov>
            <provcov>
               <linksto>CanTp.SWS_CanTp_00075</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>12</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00166</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        At the reception of a FF, last CF of a block or a SF, the CanTp module shall
        start a time-out N_Br before requesting an Rx buffer.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00166_1</srcid><srcstatus/><internalId>14</internalId></linkedfrom><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00166_2</srcid><srcstatus/><internalId>15</internalId></linkedfrom><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00166_3</srcid><srcstatus/><internalId>16</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.SWS_CanTp_00166</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>161</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>13</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00166_1</id>
         <status>approved</status>
         <source>EB refinement</source>
         <version>1</version>
         <description>
      At the reception of a FF, the CanTp module shall start a time-out
      N_Br before requesting a Rx buffer.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30099</srcid><srcstatus/><internalId>1222</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_ZeroBrForFF</srcid><srcstatus/><internalId>1372</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30447</srcid><srcstatus/><internalId>1667</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.ASR40.SWS_CanTp_00166</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>13</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>14</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00166_2</id>
         <status>approved</status>
         <source>EB refinement</source>
         <version>1</version>
         <description>
        At the reception of a SF, the CanTp module shall start a time-out
        N_Br before requesting a Rx buffer.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30340</srcid><srcstatus/><internalId>1234</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.ASR40.SWS_CanTp_00166</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>13</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>15</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00166_3</id>
         <status>approved</status>
         <source>EB refinement</source>
         <version>1</version>
         <description>
        At the reception of a last CF of a block, the CanTp module shall start a time-out
        N_Br before requesting a Rx buffer.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_N_Br_CFEOB</srcid><srcstatus/><internalId>1352</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_ZeroBrForBlockLF</srcid><srcstatus/><internalId>1373</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.ASR40.SWS_CanTp_00166</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>13</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>16</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00318</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        After the reception of a First Frame, if the function
        PduR_CanTpStartOfReception() returns BUFREQ_E_OVFL to the CanTp module,
        the CanTp module shall send a Flow Control N-PDU with overflow status
        (FC(OVFLW)) and abort the N-SDU reception. If the error occurs after a
        Consecutive Frame reception, the Flow Control frame shall not be sent. In
        case of Consecutive Frame the buffer status is returned by the
        PduR_CanTpCopyRxData() function.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00318_1</srcid><srcstatus/><internalId>18</internalId></linkedfrom><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00318_2</srcid><srcstatus/><internalId>19</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.SWS_CanTp_00277</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>188</internalId></provcov>
            <provcov>
               <linksto>CanTp.SWS_CanTp_00064</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
            <provcov>
               <linksto>CanTp.SWS_CanTp_00318</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>164</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>17</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00318_1</id>
         <status>approved</status>
         <source>EB refinement</source>
         <version>1</version>
         <description>
        After the reception of a First Frame, if the function
        PduR_CanTpStartOfReception() returns BUFREQ_E_OVFL to the CanTp module,
        the CanTp module shall send a Flow Control N-PDU with overflow status
        (FC(OVFLW)) and abort the N-SDU reception.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30086</srcid><srcstatus/><internalId>1224</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_31105</srcid><srcstatus/><internalId>1419</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_SF_Transmission_Pending_FC_Overflow</srcid><srcstatus/><internalId>1490</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_FC_Overflow_Transmission_Pending_SF</srcid><srcstatus/><internalId>1492</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_FF_Transmission_Pending_FC_OVERFLOW</srcid><srcstatus/><internalId>1494</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_CF_Transmission_Pending_FC_OVERFLOW</srcid><srcstatus/><internalId>1496</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30427</srcid><srcstatus/><internalId>1664</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.ASR40.SWS_CanTp_00318</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>17</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>18</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00318_2</id>
         <status>approved</status>
         <source>EB refinement</source>
         <version>1</version>
         <description>
        If the error occurs after a Consecutive Frame reception, the Flow
        Control frame shall not be sent and the reception shall be aborted.
        In case of Consecutive Frame the buffer
        status is returned by the PduR_CanTpCopyRxData() function.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_31106</srcid><srcstatus/><internalId>1420</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.ASR40.SWS_CanTp_00318</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>17</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>19</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00082</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        If the function PduR_CanTpStartOfReception() returns BUFREQ_E_BUSY or BUFREQ_OK
        with a smaller available buffer size than needed for the next block, the
        CanTp module shall suspend the N-SDU reception by sending the next Flow
        Control N-PDU with status WAIT (i.e. FC(WT)), when the N_Br timer expires.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00082_1</srcid><srcstatus/><internalId>21</internalId></linkedfrom><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00082_2</srcid><srcstatus/><internalId>22</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.SWS_CanTp_00277</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>188</internalId></provcov>
            <provcov>
               <linksto>CanTp.SWS_CanTp_00064</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
            <provcov>
               <linksto>CanTp.SWS_CanTp_00082</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>167</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>20</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00082_1</id>
         <status>approved</status>
         <source>EB refinement</source>
         <version>1</version>
         <description>
        If the function PduR_CanTpStartOfReception() returns BUFREQ_E_BUSY
        CanTp module shall suspend the N-SDU reception by sending the next Flow
        Control N-PDU with status WAIT (i.e. FC(WT)), when the N_Br timer expires.
      </description>
         <comment>
        This requirement is not only valid for PduR_CanTpStartOfReception() but also for
        PduR_CanTpCopyRxData() when copying FF data.
        Note:
        This requirement implies that FF and SF data is buffered in CanTp if data can not be
        copied in the context of the CanTp_RxIndication(). Suspending a reception requires buffering
        of not copied data.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
        <!-- Refined by CanTp.EB.StartOfReception.BUFREQ_E_BUSY.LL -->
        <!-- Refined by CanTp.EB.FF.Buffering -->
        <!-- Refined by CanTp.EB.SF.Buffering -->
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.EB.StartOfReception.BUFREQ_E_BUSY.LL</srcid><srcstatus/><internalId>476</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.FF.Buffering</srcid><srcstatus/><internalId>546</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.SF.Buffering</srcid><srcstatus/><internalId>547</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.ASR40.SWS_CanTp_00082</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>20</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>21</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00082_2</id>
         <status>approved</status>
         <source>EB refinement</source>
         <version>1</version>
         <description>
        If the function PduR_CanTpStartOfReception() returns BUFREQ_OK
        with a smaller available buffer size than needed for the next block, the
        CanTp module shall suspend the N-SDU reception by sending the next Flow
        Control N-PDU with status WAIT (i.e. FC(WT)), when the N_Br timer expires.
      </description>
         <comment>
        Clarification:
        The available buffer returned by PduR_CanTpStartOfReception() only needs be big enough
        for the first frame data. The available buffer returned by PduR_CanTpCopyRxData()
        when the first frame data are copied successfully, is the relevant information for
        calculating the block size. In both cases if not enough buffer available the
        CanTp module shall suspend the N-SDU reception by sending the next Flow
        Control N-PDU with status WAIT (i.e. FC(WT)), when the N_Br timer expires.
        Note:
        This requirement implies that FF and SF data is buffered in CanTp if data can not be
        copied in the context of the CanTp_RxIndication().
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30329</srcid><srcstatus/><internalId>1371</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_31104</srcid><srcstatus/><internalId>1417</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_SF_Transmission_Pending_FC_Wait</srcid><srcstatus/><internalId>1489</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_FC_Wait_Transmission_Pending_SF</srcid><srcstatus/><internalId>1491</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_FF_Transmission_Pending_FC_WAIT</srcid><srcstatus/><internalId>1493</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_CF_Transmission_Pending_FC_WAIT</srcid><srcstatus/><internalId>1495</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30447</srcid><srcstatus/><internalId>1667</internalId></linkedfrom></coveredby></needscov>
            <!-- Refined by CanTp.EB.FF.Buffering -->
        <!-- Refined by CanTp.EB.SF.Buffering -->
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.EB.FF.Buffering</srcid><srcstatus/><internalId>546</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.SF.Buffering</srcid><srcstatus/><internalId>547</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.ASR40.SWS_CanTp_00082</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>20</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>22</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00268</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        If the function PduR_CanTpCopyRxData() called after reception of the last
        Consecutive Frame of a block returns BUFREQ_E_BUSY the CanTp module shall
        suspend the N-SDU reception by sending the next Flow Control N-PDU with
        status WAIT (i.e. FC(WT)).
      </description>
         <comment>
        For each block transmission the upper layer has committed to receive the
        whole block (including the last CF of the block). Therefore an extra
        treatment of the last CF of a block is not required. The last CF of a block
        shall be treated equal to all other CF.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <!-- Covered by CanTp.SWS_CanTp_00271_2 -->
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00271_2</srcid><srcstatus/><internalId>185</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>23</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00270</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
            In case that remaining buffer is too small for the next Consecutive Frame
            reception the CanTp might call PduR_CanTpCopyRxData() with a data length
            0 (zero) and NULL_PTR as data buffer until the available buffer size is
            big enough. These calls might be performed in the time limit of STmin.
         </description>
         <comment>
            This requirement is not applicable.
            Rationale:
            Consecutive frames will only be sent in blocks and only when the upper layer
            provides enough buffer for the whole block. If consecutive frames within a
            block can not be processed due to lack of buffer, then CanTp.SWS_CanTp_00271_1 or
            CanTp.SWS_CanTp_00271_1 takes place.
         </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>24</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00226</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        After a transmission request from the upper layer, the CanTp module shall call
        PduR_CanTpCopyTxData at least once to request the necessary transmit
        buffer.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_RequestNewTransmissionFromTxConfirmation_SF</srcid><srcstatus/><internalId>1180</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30048</srcid><srcstatus/><internalId>1193</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30054</srcid><srcstatus/><internalId>1197</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_Normal_Functional</srcid><srcstatus/><internalId>1368</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_Mixed_Functional_1</srcid><srcstatus/><internalId>1393</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_ReceptionInterrupts_SegmentedTransmission</srcid><srcstatus/><internalId>1640</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>25</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00185</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
            If no buffer is available before the expiration of the N_Cs timer (ISO 15765-2
            specification defines the following performance requirement: (N_Cs+N_As)
            &lt; 0.9*N_Cr timeout), the CanTp module shall abort this transmission
            session.
         </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30451</srcid><srcstatus/><internalId>1671</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>26</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00093</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
            If a multiple segmented session occurs (on both receiver and sender side) with a
            handle whose communication type is functional, the CanTp module shall
            reject the request and generate, if the development error detection is
            enabled, a development error CANTP_E_INVALID_TATYPE.
         </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00093_1</srcid><srcstatus/><internalId>28</internalId></linkedfrom><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00093_2</srcid><srcstatus/><internalId>29</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.SWS_CanTp_00093</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>223</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>27</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00093_1</id>
         <status>approved</status>
         <source>EB refinement</source>
         <version>1</version>
         <description>
            If a multiple segmented session occurs on receiver side with a
            handle whose communication type is functional, the CanTp module shall
            reject the request and generate, if the development error detection is
            enabled, a development error SWS_CanTp_00_E_INVALID_TATYPE.
         </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30113</srcid><srcstatus/><internalId>1259</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.ASR40.SWS_CanTp_00093</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>27</internalId></provcov>
            <provcov>
               <linksto>CanTp.SWS_CanTp_00293_11</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>333</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>28</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00093_2</id>
         <status>approved</status>
         <source>EB refinement</source>
         <version>1</version>
         <description>
            If a multiple segmented session occurs on sender side with a
            handle whose communication type is functional, the CanTp module shall
            reject the request and generate, if the development error detection is
            enabled, a development error CANTP_E_INVALID_TATYPE.
         </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30066</srcid><srcstatus/><internalId>1251</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.ASR40.SWS_CanTp_00093</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>27</internalId></provcov>
            <provcov>
               <linksto>CanTp.SWS_CanTp_00293_11</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>333</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>29</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00248</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        A Tx N-PDU Id shall not be used on two or more different connection channels. An
        Rx N-PDU Id can only be used on two or more different connection channels
        if extended addressing is used in relation with this N-PDU Id.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00248_1</srcid><srcstatus/><internalId>31</internalId></linkedfrom><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00248_2</srcid><srcstatus/><internalId>32</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>30</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00248_1</id>
         <status>approved</status>
         <source>EB refinement</source>
         <version>1</version>
         <description>
        A Tx N-PDU Id shall not be used on two or more different connection channels.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
        <!-- Shall be tested with a generic test -->
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01001_Err_TxNPduId_NotUnique_Standard</srcid><srcstatus/><internalId>1526</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.ASR40.SWS_CanTp_00248</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>30</internalId></provcov>
            <provcov>
               <linksto>CanTp.SWS_CanTp_00248</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>252</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>31</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00248_2</id>
         <status>approved</status>
         <source>EB refinement</source>
         <version>1</version>
         <description>
        An Rx N-PDU Id can only be used on two or more different connection channels
        if extended addressing is used in relation with this N-PDU Id.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
        <!-- Shall be tested with a generic test -->
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01002_Err_RxNPduId_NotUnique_Standard</srcid><srcstatus/><internalId>1527</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.ASR40.SWS_CanTp_00248</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>30</internalId></provcov>
            <provcov>
               <linksto>CanTp.SWS_CanTp_00248</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>252</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>32</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00040</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>2</version>
         <description>
        If the CanTpTxPaddingActivation parameter is set to ON, the CanTp module shall
        only transfer N-PDU with a length of eight bytes (i.e. DLC = 8) between
        the CanTp and the CanIf, unused bytes in N-PDU shall be updated with
        CANTP_PADDING_BYTE. Thus, a received N-PDU shorter than 8 bytes will be
        considered corrupt by CanTp. (BSW01073)
       </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00040_1</srcid><srcstatus/><internalId>34</internalId></linkedfrom><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00040_2</srcid><srcstatus/><internalId>35</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.SWS_CanTp_00351</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>285</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>33</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00040_1</id>
         <status>approved</status>
         <source>EB refinement</source>
         <version>2</version>
         <description>
        If the CanTpTxPaddingActivation parameter is set to ON, the CanTp module shall
        only transfer N-PDU with a length of eight bytes (i.e. DLC = 8) between
        the CanTp and the CanIf.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30188</srcid><srcstatus/><internalId>1284</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_PAD_FC_OVFLW</srcid><srcstatus/><internalId>1340</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_PAD_FC_CTS</srcid><srcstatus/><internalId>1341</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_PAD_FC_WAIT</srcid><srcstatus/><internalId>1342</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_PAD_CF</srcid><srcstatus/><internalId>1343</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30418</srcid><srcstatus/><internalId>1661</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30454</srcid><srcstatus/><internalId>1674</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.ASR40.SWS_CanTp_00040</linksto>
               <dstversion>2</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>33</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>34</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00040_2</id>
         <status>approved</status>
         <source>EB refinement</source>
         <version>2</version>
         <description>
        If the CanTpTxPaddingActivation parameter is set to ON, a received
        N-PDU shorter than 8 bytes will be considered corrupt by CanTp.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30193</srcid><srcstatus/><internalId>1285</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30479</srcid><srcstatus/><internalId>1677</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30481</srcid><srcstatus/><internalId>1679</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30483</srcid><srcstatus/><internalId>1681</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.ASR40.SWS_CanTp_00040</linksto>
               <dstversion>2</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>33</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>35</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00290</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        Those tables consider the actual CanTp internal status (CanTp status). Table 1
        specifies the behavior on the half duplex implementation while table 2
        defines the behavior for full duplex channels. (BSW01117, BSW01149)

        It must be understood, that the received N-PDU contains the same address
        information (N_AI) as the reception or transmission, which may be in
        progress at the time the N_PDU is received.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00057_HalfDuplex</srcid><srcstatus/><internalId>289</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00057_FullDuplex</srcid><srcstatus/><internalId>305</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>36</internalId></specobject>

      <specobject>
        <id>CanTp.ASR40.SWS_CanTp_00006</id>
        <status>approved</status>
        <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
        <version>1</version>
        <description>
        The detection of development errors is configurable (ON / OFF)
        at pre-compile time.
        The switch CanTpDevErrorDetect (see chapter 10) should activate
        or deactivate the detection of all development errors.
        </description>
        <releases>
          <release>AUTOSAR 4.0.3</release>
        </releases>
        <needscoverage>
          <!-- Requires multiple tests with multiple configurations -->
          <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_49017</srcid><srcstatus/><internalId>1647</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_49002</srcid><srcstatus/><internalId>1649</internalId></linkedfrom></coveredby></needscov>
        <containerCovstatus>covered</containerCovstatus></needscoverage>
        <providescoverage>
          <provcov>
            <linksto>CanTp.ECUC_CanTp_00239</linksto>
            <dstversion>1</dstversion>
          <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>421</internalId></provcov>
        </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>37</internalId></specobject>

      <specobject>
        <id>CanTp.ASR40.SWS_CanTp_00134</id>
        <status>approved</status>
        <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
        <version>1</version>
        <description>
        Detected development errors will be reported to the error hook of the
        Development Error Tracer (DET) if the pre-processor switch CanTpDevErrorDetect
        is set.
        </description>
        <releases>
          <release>AUTOSAR 4.0.3</release>
        </releases>
        <needscoverage>
          <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30175</srcid><srcstatus/><internalId>1288</internalId></linkedfrom></coveredby></needscov>
        <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>38</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00115</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        The header file of the CanTp module, CanTp.h, shall provide a module ID, called
        CANTP_MODULE_ID, sets to the value 0x23.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30143</srcid><srcstatus/><internalId>1185</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_40048</srcid><srcstatus/><internalId>1597</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>39</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00320</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        If DET is enabled the function CanTp_Init shall rise
        CANTP_E_PARAM_POINTER error if the argument is a NULL pointer and return
        without any action.
      </description>
         <comment>
        Covering this requirement shall also include testing the service id used for the Det report.
        Note:
        This behavior can be provoked when PbcfgM does not provide a configuration.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_INIT_NULLPTR</srcid><srcstatus/><internalId>1304</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.SWS_CanTp_00293_3</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>327</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>40</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00162</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        The function CanTp_GetVersionInfo shall return the version information of this
        module. The version information includes:
        - Module Id
        - Vendor Id
        - Vendor specific version numbers (BSW00407). (BSW407)
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30047</srcid><srcstatus/><internalId>1190</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>41</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00163</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        The function CanTp_GetVersionInfo shall be pre compile time configurable
        (On/Off) by the configuration parameter: CANTP_VERSION_INFO_API. (BSW407)
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_49049</srcid><srcstatus/><internalId>1120</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>42</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00212</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        CanTp_Transmit
        Service name: CanTp_Transmit
        Syntax: Std_ReturnType CanTp_Transmit( PduIdType CanTpTxSduId, const PduInfoType* CanTpTxInfoPtr )
        Service ID[hex]: 0x03
        Sync/Async: Asynchronous
        Reentrancy: Reentrant
        Parameters (in):
        CanTpTxSduId This parameter contains the unique CanTp module identifier of the
        CAN N-SDU to be transmitted. Range: 0..(maximum number of L-PDU IDs
        received) - 1
        CanTpTxInfoPtr An indicator of a structure with CAN N-SDU related data: indicator
        of a CAN N-SDU buffer and the length of this buffer.
        Parameters (inout): None
        Parameters (out): None
        Return value: Std_ReturnType
        E_OK: The request can be started successfully
        E_NOT_OK: The request cannot be started (e.g. a transmit request is in progress
        with the same N-SDU identifier)
        Description: This service is used to request the transfer of segmented
        data.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
        <!-- Syntax shall be tested with a compile test only. -->
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_49017</srcid><srcstatus/><internalId>1647</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.ASR40.Transmit</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>498</internalId></provcov>
            <provcov>
               <linksto>CanTp.SWS_CanTp_00212</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>351</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>43</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00321</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        If DET is enabled the function CanTp_Transmit shall rise
        CANTP_E_PARAM_POINTER error if the argument CanTpTxInfoPtr is a NULL
        pointer and return without any action.
      </description>
         <comment>
        Covering this requirement shall also include testing the service id used for the Det report.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30175</srcid><srcstatus/><internalId>1288</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30252</srcid><srcstatus/><internalId>1292</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.SWS_CanTp_00293_3</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>327</internalId></provcov>
            <provcov>
               <linksto>CanTp.SWS_CanTp_00321</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>366</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>44</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00246</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        CanTp_CancelTransmit
        Service name: CanTp_CancelTransmit
        Syntax: Std_ReturnType CanTp_CancelTransmit( PduIdType CanTpTxSduId )
        Sync/Async: Synchronous
        Service ID[hex]: 0x08
        Reentrancy: Non Reentrant
        Parameters (in):
        CanTpTxSduId
          This parameter contains the unique CanTp module identifier of the
          N-SDU to be cancelled for transmission. Range: 0..(maximum number of
          L-PDU IDs received) - 1
        Parameters (inout): None
        Parameters (out): None
        Return value: Std_ReturnType
        - E_OK: Cancellation request of the specified N-SDU is accepted.
        - E_NOT_OK: Cancellation request is rejected; the reason can be
                    that request is issued for an N-SDU that is not segmented,
                    request is issued after the last CF has been requested for transmission
                    or cancellation is not possible for the related N-SDU  due to configuration.
        Description:
          This service primitive is used to cancel the
          transfer of a pending CAN N-SDU.  When the function returns, no
          transmission is in progress anymore with the given  N-SDU identifier.
          This service cancels the transmission of an N-SDU that has already
          requested for transmission by calling CanTp_Transmit service.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
        <!-- Syntax shall be tested with a compile test only. -->
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_49017</srcid><srcstatus/><internalId>1647</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.ASR40.CancelTransmit</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>524</internalId></provcov>
            <provcov>
               <linksto>CanTp.SWS_CanTp_00246</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>367</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>45</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00246_1</id>
         <status>approved</status>
         <source>EB refinement</source>
         <version>1</version>
         <description>
         Cancellation request is rejected if the request is issued for an N-SDU that is not
         segmented.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30361</srcid><srcstatus/><internalId>1325</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>46</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00254</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        If development error detection is enabled the function
        CanTp_CancelTransmit shall check the validity of CanTpTxSduId
        parameter. If the parameter value is invalid, the
        CanTp_CancelTransmit function shall raise the development error
        CANTP_E_PARAM_ID and return E_NOT_OK. If the parameter value indicates a
        cancel transmission request for an N-SDU that it is not on transmission
        process the CanTp module shall raise the DET error
        CANTP_E_OPER_NOT_SUPPORTED and the service shall return E_NOT_OK.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00254_1</srcid><srcstatus/><internalId>48</internalId></linkedfrom><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00254_2</srcid><srcstatus/><internalId>49</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>47</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00254_1</id>
         <status>approved</status>
         <source>EB refinement</source>
         <version>1</version>
         <description>
        If development error detection is enabled the function
        CanTp_CancelTransmit shall check the validity of CanTpTxSduId
        parameter. If the parameter value is invalid, the
        CanTp_CancelTransmit function shall raise the development error
        CANTP_E_PARAM_ID and return E_NOT_OK.
      </description>
         <comment>
        Covering this requirement shall also include testing the service id used for the Det report.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_CancelTxReq_DetParamId</srcid><srcstatus/><internalId>1320</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.ASR40.SWS_CanTp_00254</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>47</internalId></provcov>
            <provcov>
               <linksto>CanTp.SWS_CanTp_00254</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>368</internalId></provcov>
            <provcov>
               <linksto>CanTp.ASR40.CancelTransmit.E_OK</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>526</internalId></provcov>
            <provcov>
               <linksto>CanTp.SWS_CanTp_00293_2</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>325</internalId></provcov>
            <provcov>
               <linksto>CanTp.SWS_CanTp_00294</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>336</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>48</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00254_2</id>
         <status>approved</status>
         <source>EB refinement</source>
         <version>1</version>
         <description>
        If the parameter value indicates a cancel transmission request for an N-SDU that it
        is not on transmission process the CanTp module shall raise the DET error
        CANTP_E_OPER_NOT_SUPPORTED and the service shall return E_NOT_OK.
      </description>
         <comment>
        Covering this requirement shall also include testing the service id used for the Det report.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanTp_CancelTransmit.c_140</srcid><srcstatus/><internalId>1015</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/CanTp_CancelTransmit.c_227</srcid><srcstatus/><internalId>1016</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/CanTp_CancelTransmit.c_254</srcid><srcstatus/><internalId>1018</internalId></linkedfrom></coveredby></needscov>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_CancelTxReqRepToDet_1</srcid><srcstatus/><internalId>1344</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_CancelTxReqRepToDet_2</srcid><srcstatus/><internalId>1345</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_CancelTx_WhileRx</srcid><srcstatus/><internalId>1346</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.ASR40.SWS_CanTp_00254</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>47</internalId></provcov>
            <provcov>
               <linksto>CanTp.SWS_CanTp_00254</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>368</internalId></provcov>
            <provcov>
               <linksto>CanTp.ASR40.CancelTransmit.E_OK</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>526</internalId></provcov>
            <provcov>
               <linksto>CanTp.SWS_CanTp_00293_12</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>334</internalId></provcov>
            <provcov>
               <linksto>CanTp.SWS_CanTp_00294</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>336</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>49</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00257</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        CanTp_CancelReceive
        Service name: CanTp_CancelReceive
        Syntax: Std_ReturnType CanTp_CancelReceive( PduIdType CanTpRxSduId )
        Sync/Async: Synchronous
        Service ID[hex]: 0x09
        Reentrancy: Non Reentrant
        Parameters (in): CanTpRxSduId Identifier of the received N-SDU.
        Parameters (inout): None
        Parameters (out): None
        Return value: Std_ReturnType
        E_OK: Cancellation request of the specified N-SDU is accepted.
        E_NOT_OK: Cancellation request is rejected; the reason can be that request is
        issued for an N-SDU that is not segmented or request is issued for an
        N-SDU that is not in the reception process.
        Description: This service is used to cancel the reception of an ongoing N-SDU.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
        <!-- Syntax shall be tested with a compile test only. -->
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_RCV_CANCL_ERR</srcid><srcstatus/><internalId>1336</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_SF_RECEPTION_POSTONED</srcid><srcstatus/><internalId>1369</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_49017</srcid><srcstatus/><internalId>1647</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.SWS_CanTp_00257</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>371</internalId></provcov>
            <provcov>
               <linksto>CanTp.ASR40.CancelReceive</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>520</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>50</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00260</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        If development error detection is enabled the function
        CanTp_CancelReceive shall check the validity of CanTpRxSduId
        parameter. If the parameter value is invalid, the
        CanTp_CancelReceive function shall raise the development error
        CANTP_E_PARAM_ID and return E_NOT_OK. If the parameter value indicates a
        cancel reception request for an N-SDU that it is not on reception process
        the CanTp module shall raise the DET error
        CANTP_E_OPER_NOT_SUPPORTED and the service shall return E_NOT_OK.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00260_1</srcid><srcstatus/><internalId>52</internalId></linkedfrom><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00260_2</srcid><srcstatus/><internalId>53</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>51</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00260_1</id>
         <status>approved</status>
         <source>EB refinement</source>
         <version>1</version>
         <description>
        If development error detection is enabled the function
        CanTp_CancelReceive shall check the validity of CanTpRxSduId
        parameter. If the parameter value is invalid, the
        CanTp_CancelReceive function shall raise the development error
        CANTP_E_PARAM_ID and return E_NOT_OK.
      </description>
         <comment>
        Covering this requirement shall also include testing the service id used for the Det report.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_RCV_CANCL_DET</srcid><srcstatus/><internalId>1334</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.ASR40.SWS_CanTp_00260</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>51</internalId></provcov>
            <provcov>
               <linksto>CanTp.SWS_CanTp_00260</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>372</internalId></provcov>
            <provcov>
               <linksto>CanTp.ASR40.CancelReceive.E_OK</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>522</internalId></provcov>
            <provcov>
               <linksto>CanTp.SWS_CanTp_00293_2</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>325</internalId></provcov>
            <provcov>
               <linksto>CanTp.SWS_CanTp_00294</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>336</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>52</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00260_2</id>
         <status>approved</status>
         <source>EB refinement</source>
         <version>1</version>
         <description>
        If the parameter value indicates a cancel reception request for an N-SDU
        that it is not on reception process the CanTp module shall raise the DET error
        CANTP_E_OPER_NOT_SUPPORTED and the service shall return E_NOT_OK.
      </description>
         <comment>
        Covering this requirement shall also include testing the service id used for the Det report.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanTp_CancelReceive.c_154</srcid><srcstatus/><internalId>1011</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/CanTp_CancelReceive.c_275</srcid><srcstatus/><internalId>1013</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/CanTp_CancelReceive.c_300</srcid><srcstatus/><internalId>1014</internalId></linkedfrom></coveredby></needscov>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_RCV_CANCL_NOT_SUPPORT</srcid><srcstatus/><internalId>1335</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_CancelRx_INTCF</srcid><srcstatus/><internalId>1354</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.ASR40.SWS_CanTp_00260</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>51</internalId></provcov>
            <provcov>
               <linksto>CanTp.SWS_CanTp_00260</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>372</internalId></provcov>
            <provcov>
               <linksto>CanTp.ASR40.CancelReceive.E_OK</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>522</internalId></provcov>
            <provcov>
               <linksto>CanTp.SWS_CanTp_00293_12</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>334</internalId></provcov>
            <provcov>
               <linksto>CanTp.SWS_CanTp_00294</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>336</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>53</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00302</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        CanTp_ChangeParameter
        Service name: CanTp_ChangeParameter
        Syntax: Std_ReturnType CanTp_ChangeParameter
        (
          PduIdType id,
          TPParameterType parameter,
          uint16 value
        )
        Sync/Async: Synchronous
        Service ID[hex]: 0x0a
        Reentrancy: Non Reentrant
        Parameters (in):
        id Identifier of the received N-SDU on which the reception parameter has to be
        changed.
        parameter Specify the parameter to which the value has to be changed (BS or STmin).
        value The new value of the parameter.
        Parameters (inout): None
        Parameters (out): None
        Return value: Std_ReturnType
        E_OK: request is accepted.
        E_NOT_OK: request is not accepted.
        Description: This service is used to request the change of reception parameters BS
        and STmin for a specified N-SDU.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
        <!-- Syntax shall be tested with a compile test only. -->
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_49017</srcid><srcstatus/><internalId>1647</internalId></linkedfrom></coveredby></needscov>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00302_E_OK_BS</srcid><srcstatus/><internalId>55</internalId></linkedfrom><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00302_E_OK_STmin</srcid><srcstatus/><internalId>56</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.SWS_CanTp_00091_1</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
            <provcov>
               <linksto>CanTp.SWS_CanTp_00302</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>378</internalId></provcov>
            <provcov>
               <linksto>CanTp.ASR40.ChangeParameter</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>528</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>54</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00302_E_OK_BS</id>
         <status>approved</status>
         <source>EB refinement</source>
         <version>1</version>
         <description>
        If CanTp_ChangeParameter(BS) is successfully called the API shall return E_OK and the new
        BS value shall be used instead of the configured value.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_Conf07002_Change_Read_BS</srcid><srcstatus/><internalId>1429</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_Conf07006_ChangeRx_Read_BS</srcid><srcstatus/><internalId>1433</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.ASR40.SWS_CanTp_00302</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>54</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>55</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00302_E_OK_STmin</id>
         <status>approved</status>
         <source>EB refinement</source>
         <version>1</version>
         <description>
        If CanTp_ChangeParameter(STmin) is successfully called the API shall return E_OK and the new
        STmin value shall be used instead of the configured value.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_Conf07001_Change_Read_STmin</srcid><srcstatus/><internalId>1428</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_Conf07005_ChangeRx_Read_STmin</srcid><srcstatus/><internalId>1432</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.ASR40.SWS_CanTp_00302</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>54</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>56</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00233</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        The CanTp module shall provide the function prototypes of the callback functions
        in the file CanTp_Cbk.h
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/CanTp_Cbk.h_5</srcid><srcstatus/><internalId>1008</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>57</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.ECUC_CanTp_00289</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        Name: CanTpChannelMode
        Description:
          The CAN Transport Layer supports half and full duplex
          channel modes.
        Multiplicity 1
        Type EcucEnumerationParamDef
        Range
        - CANTP_MODE_FULL_DUPLEX Full duplex channel.
        - CANTP_MODE_HALF_DUPLEX Half duplex channel.
        ConfigurationClass
          Pre-compile time  X All Variants
          Link time         -
          Post-build time   -
        Scope / Dependency
      </description>
         <comment>
        This is a configuration parameter requirement without functional specification.
        The behavior of full and half duplex channels are defined in CanTp.ASR40.SWS_CanTp_00290.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>58</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00326</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
      The standardized common published parameters as required by BSW00402 in the
      General Requirements on Basic Software Modules [3] shall be published
      within the header file of this module and need to be provided in the BSW
      Module Description. The according module abbreviation can be found in the
      List of Basic Software Modules [1].
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
        <!--Covered by CanTp.EB.PublishedInformation -->
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.EB.PublishedInformation</srcid><srcstatus/><internalId>548</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>59</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00215</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        CanTp_TxConfirmation
        Service name: CanTp_TxConfirmation
        Syntax: void CanTp_TxConfirmation( PduIdType TxPduId )
        Sync/Async: Synchronous
        Service ID [hex]: 0x40
        Reentrancy: Reentrant for different PduIds. Non reentrant for the same PduId.
        Parameters (in):
        TxPduId ID of the I-PDU that has been transmitted.
        Parameters (inout): None
        Parameters (out): None
        Return value: None
        Description: The lower layer communication module confirms the transmission of an
        I-PDU.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
        <!-- Syntax shall be tested with a compile test only. -->
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_49017</srcid><srcstatus/><internalId>1647</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.SWS_CanTp_00215</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>400</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>60</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00293</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        The CanTp module shall be able to detect the following errors and exceptions
        depending on its configuration (development/production).
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00293_7</srcid><srcstatus/><internalId>62</internalId></linkedfrom><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00293_8</srcid><srcstatus/><internalId>63</internalId></linkedfrom><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00293_13</srcid><srcstatus/><internalId>64</internalId></linkedfrom><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00293_14</srcid><srcstatus/><internalId>65</internalId></linkedfrom><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00293_15</srcid><srcstatus/><internalId>66</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>61</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00293_7</id>
         <status>approved</status>
         <source>EB refinement</source>
         <version>1</version>
         <description>
        Type or error: Invalid Transmit buffer address
        (e.g. the Tx buffer address is inaccessible or NULL)
        Relevance: Development
        Related error code: CANTP_E_INVALID_TX_BUFFER
        Value [hex]: 0x50
      </description>
         <comment>
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
        <!-- Linked to deviation dev.CanTp.DetInvalidBuffer -->
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.DetInvalidBuffer</srcid><srcstatus/><internalId>973</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.ASR40.SWS_CanTp_00293</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>61</internalId></provcov>
            <provcov>
               <linksto>CanTp.ASR40.SWS_CanTp_00101</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>89</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>62</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00293_8</id>
         <status>approved</status>
         <source>EB refinement</source>
         <version>1</version>
         <description>
        Type or error: Invalid Receive buffer address
        (e.g. the Rx buffer address is inaccessible or NULL)
        Relevance: Development
        Related error code: CANTP_E_INVALID_RX_BUFFER
        Value [hex]: 0x60
      </description>
         <comment>
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
        <!-- Linked to deviation dev.CanTp.DetInvalidBuffer -->
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.DetInvalidBuffer</srcid><srcstatus/><internalId>973</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.ASR40.SWS_CanTp_00293</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>61</internalId></provcov>
            <provcov>
               <linksto>CanTp.ASR40.SWS_CanTp_00101</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>89</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>63</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00293_13</id>
         <status>approved</status>
         <source>EB refinement</source>
         <version>1</version>
         <description>
        Type or error: Event reported on completion of a reception operation
        Relevance: Development
        Related error code: CANTP_E_RX_COM
        Value [hex]: 0xC0
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
        <!-- Linked to dev.CanTp.Det.E_xx_COM -->
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.Det.E_xx_COM</srcid><srcstatus/><internalId>976</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.ASR40.SWS_CanTp_00293</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>61</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>64</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00293_14</id>
         <status>approved</status>
         <source>EB refinement</source>
         <version>1</version>
         <description>
      Type or error: Event reported on completion of a transmission operation
      Relevance: Development
      Related error code: CANTP_E_TX_COM
      Value [hex]: 0xD0
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
        <!-- Linked to dev.CanTp.Det.E_xx_COM -->
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.Det.E_xx_COM</srcid><srcstatus/><internalId>976</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.ASR40.SWS_CanTp_00293</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>61</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>65</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00293_15</id>
         <status>approved</status>
         <source>EB refinement</source>
         <version>1</version>
         <description>
        Type or error: Another error occurred during a reception or a
        transmission: any protocol timeout error or implementation specific
        error
        Relevance: Development
        Related error code: CANTP_E_COM
        Value [hex]: 0xB0
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
        <!-- Linked to dev.CanTp.Det.E_xx_COM -->
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.Det.E_xx_COM</srcid><srcstatus/><internalId>976</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.ASR40.SWS_CanTp_00293</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>61</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>66</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00249</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        Each variable that shall be accessible by AUTOSAR Debugging, shall be defined as
        global variable.
      </description>
         <comment>
        AUTOSAR debugging as defined here will not be supported.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
        <!-- Linked to dev.CanTp.Debugging -->
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.Debugging</srcid><srcstatus/><internalId>975</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>67</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00250</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        All type definitions of variables that shall be debugged shall be accessible by
        the header file CanTp.h.
      </description>
         <comment>
        AUTOSAR debugging as defined here will not be supported.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
        <!-- Linked to dev.CanTp.Debugging -->
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.Debugging</srcid><srcstatus/><internalId>975</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>68</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00251</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        The declaration of variables in the header file shall be such, that it is
        possible to calculate the size of the variables by C-"sizeof".
      </description>
         <comment>
        This requirement is part of the AUTOSAR debugging concept.
        AUTOSAR debugging as defined here will not be supported.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
        <!-- Linked to dev.CanTp.Debugging -->
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.Debugging</srcid><srcstatus/><internalId>975</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>69</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00252</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
      Variables available for debugging shall be described in the CanTp Software
      Module Description.
      </description>
         <comment>
        This requirement is part of the AUTOSAR debugging concept.
        AUTOSAR debugging as defined here will not be supported.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
        <!-- Linked to dev.CanTp.Debugging -->
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.Debugging</srcid><srcstatus/><internalId>975</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>70</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00253</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        The CANTP_OFF and CANTP_ON states shall be available for debugging
        (chapter 7.7 in the SWS details implementation of debugging concept).
      </description>
         <comment>
        AUTOSAR debugging as defined here will not be supported.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
        <!-- Linked to dev.CanTp.Debugging -->
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.Debugging</srcid><srcstatus/><internalId>975</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>71</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00229</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        If the task was aborted due to As, Bs, Cs, Ar, Br, Cr timeout, the CanTp module
        shall raise the DET error CANTP_E_RX_COM (in case of a reception
        operation) or CANTP_E_TX_COM (in case of a transmission operation). If
        the task was aborted due to any other protocol error, the CanTp module
        shall raise the DET error CANTP_E_COM.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
        <!-- Linked to dev.CanTp.Det.E_xx_COM -->
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.Det.E_xx_COM</srcid><srcstatus/><internalId>976</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>72</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00156</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        The CanTp module shall implement the file structure as shown in Figure 3.
      </description>
         <comment>
        This requirement is not applicable.
        Rationale:
        The include structure given in the CanTp SWS will not be used.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>73</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00265</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        Global data types and functions that are only used internally by the CAN
        Transport Protocol, are given in CanTp.c.
      </description>
         <comment>
        This requirement is not applicable.
        Rationale:
        The file structure given in the CanTp SWS will not be used. It is however
        the aim of the new structure to not provide internal symbols to other
        modules via include files, if this can be prevented.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>74</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00219</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
      File CanTp.c shall include CanTp_Cfg.h, CanTp_Cbk.h, CanTp.h, MemMap.h and
      SchM_CanTp.h.
      </description>
         <comment>
        This requirement is not applicable.
        Rationale:
        The file structure given in the CanTp SWS will not be used.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>75</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00221</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
      CanTp.c shall include CanTp_Cfg.h.
      </description>
         <comment>
        This requirement is not applicable.
        Rationale:
        The file structure given in the CanTp SWS will not be used.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>76</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00153</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        The CanTp module may use macros (instead of functions) where source code is used
        and runtime is critical. (BSW00330)
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        This is a recommendation and no requirement. Functions are more safe than function
        like macros and depending on the compiler function like macros don't have speed
        advantages against inlined functions.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>77</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00133</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        The detection of production code errors cannot be switched off.
      </description>
         <comment>
        This requirement is not applicable.
        Rationale:
        EB specific decision: The handling of production errors shall be
        configurable including disabling the handling (ticket ASCCANTP-360).
        Note: With ASR 4.0.3 no production error exists. Therefore this
        requirement is obsolete.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>78</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00193</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        Production errors shall be reported to Diagnostic Event Manager.
      </description>
         <comment>
        This requirement is not applicable.
        Rationale:
        This requirement is obsolete since no production errors are specified.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>79</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00003</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        The following provides the API Naming convention for the CanTp services:
        - The service name format is CanTp_&lt;ServiceName&gt;(...)
        - &lt;ServiceName&gt; is the name of the service primitive with first
        letter of each word upper case and consecutive letters lower case (BSW00310)
      </description>
         <comment>
        This requirement is not applicable.
        Rationale:
        For external APIs this is a requirement for the SWS defined APIs.
        Internal used functions have no external impacts and will follow the EB C-style guidelines.
        See C_STYLE_506
        http://qms.ebgroup.elektrobit.com/qms/instructions/operative/software-entwicklung/progr-richtl/C_Style_Guide.pdf
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>80</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00218</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        If source code for caller and callee of CanTp_GetVersionInfo is available, the
        CanTp module should realize CanTp_GetVersionInfo as a macro, defined in
        the module's header file.
      </description>
         <comment>
        This requirement is not applicable.
        Rationale:
        Since it is unknown if module is available for caller as source code or as library,
        the CanTp_GetVersionInfo is provided as function. This way it will work in both cases.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>81</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00301</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        Configuration rules and constraints for plausibility checks will be performed
        where possible, during configuration time.
      </description>
         <comment>
        This requirement is not applicable.
        Rationale:
        This is a requirement for the configuration tool which is not part of the module
        development.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>82</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00307</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        The CanTp module shall perform Inter Module Checks to avoid integration of
        incompatible files. The imported included files shall be checked by
        preprocessing directives. The following version numbers shall be
        verified:
        - &lt;MODULENAME&gt;_AR_RELEASE_MAJOR_VERSION
        - &lt;MODULENAME&gt;_AR_RELEASE_MINOR_VERSION,
        where &lt;MODULENAME&gt; is the module short name of the other (external)
        modules which provide header files included by the CanTp module.
      </description>
         <comment>
        http://wiki.elektrobit.com/index.php/Project:EB_tresos/Engineering_AutoCore/Software_Construction/Coding_Guidelines
        Coding guideline BSWM_CHK_401:
        Although required by the SRS General, BSW004, inter-module version-checks SHALL NOT be done.
        A deviation is documented globally for all BSW modules within the release notes and SHALL NOT
        be documented for each module.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
        <!-- Linked to dev.CanTp.ConsChck -->
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.ConsChck</srcid><srcstatus/><internalId>977</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>83</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00308</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        If the values are not identical to the expected values, an error shall be
        reported.
      </description>
         <comment>
        http://wiki.elektrobit.com/index.php/Project:EB_tresos/Engineering_AutoCore/Software_Construction/Coding_Guidelines
        Coding guideline BSWM_CHK_401:
        Although required by the SRS General, BSW004, inter-module version-checks SHALL NOT be done.
        A deviation is documented globally for all BSW modules within the release notes and SHALL NOT
        be documented for each module.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
        <!-- Linked to dev.CanTp.ConsChck -->
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.ConsChck</srcid><srcstatus/><internalId>977</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>84</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00001</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        CanTp_Cfg.h shall define constant and customizable data for module configuration
        at pre-compile time.(BSW00345, BSW381, BSW158)
      </description>
         <comment>
        This requirement is covered by EB coding guidelines.
        See
        http://wiki.elektrobit.com/index.php/Project:EB_tresos/Engineering_AutoCore/Software_Construction/Coding_Guidelines#Summary_of_files
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/include/CanTp_Cfg.h.m4_9</srcid><srcstatus/><internalId>995</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>85</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00021</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        The CanTp module shall use the Development Error Tracer service [8]:
        Std_ReturnType Det_ReportError(ModuleId, InstanceId, ApiId, ErrorId) to
        report development errors. (BSW00369)
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest12_006_InvalidRxLength_CANTP_ON_CAN_CAN_FD_CANFD_frames</srcid><srcstatus/><internalId>1173</internalId></linkedfrom><linkedfrom><srcid>CanTp_ConTest12_007_InvalidRxLength_CANTP_ON_CAN_CAN_FD_CAN20_frames</srcid><srcstatus/><internalId>1174</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30250</srcid><srcstatus/><internalId>1290</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30251</srcid><srcstatus/><internalId>1291</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30252</srcid><srcstatus/><internalId>1292</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30253</srcid><srcstatus/><internalId>1293</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30254</srcid><srcstatus/><internalId>1294</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30262</srcid><srcstatus/><internalId>1295</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30260</srcid><srcstatus/><internalId>1305</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30261</srcid><srcstatus/><internalId>1306</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30266</srcid><srcstatus/><internalId>1307</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30272</srcid><srcstatus/><internalId>1310</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_CancelTxReq_DetParamId</srcid><srcstatus/><internalId>1320</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30477</srcid><srcstatus/><internalId>1675</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30478</srcid><srcstatus/><internalId>1676</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30479</srcid><srcstatus/><internalId>1677</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30480</srcid><srcstatus/><internalId>1678</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30481</srcid><srcstatus/><internalId>1679</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30482</srcid><srcstatus/><internalId>1680</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30483</srcid><srcstatus/><internalId>1681</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30255</srcid><srcstatus/><internalId>1682</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations><ruleid>WRN.swuts.needscoverage.count</ruleid></oreqmViolations><covstatus>covered</covstatus><internalId>86</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00024</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        Source file of the CanTp module shall provide the possibility of version
        identification of the CAN Transport module by CANTP_SW_MAJOR_VERSION,
        CANTP_SW_MINOR_VERSION and CANTP_SW_PATCH_VERSION.  (BSW004, BSW003)
      </description>
         <comment>
        The strategy from the coding guideline BSWM_CHK_400 will be used.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanTp.c.m4_10</srcid><srcstatus/><internalId>1010</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>87</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00098</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        If the CanTpRxPaddingActivation parameter is set to OFF, the CanTp module shall
        check the frame data length. If a frame is received with an unexpected
        datalength (check only for too short DLCs), the frame shall be ignored.
        (BSW01073)
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_ConTest16_001_CAN20_FC_Lengths_NoPadding_NormalPadding_CanFDPadding</srcid><srcstatus/><internalId>1183</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_ConTest16_002_CANFD_FC_Lengths_NoPadding_NormalPadding_CanFDPadding</srcid><srcstatus/><internalId>1184</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30187</srcid><srcstatus/><internalId>1250</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30200</srcid><srcstatus/><internalId>1261</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30478</srcid><srcstatus/><internalId>1676</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30480</srcid><srcstatus/><internalId>1678</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30482</srcid><srcstatus/><internalId>1680</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>88</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00101</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        Development error values are of type uint8.
       (BSW385, BSW386, BSW00337, BSW00327, BSW00331)
      </description>
         <comment>
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
        <!-- This requirement needs coverage of all requirements defining development error values -->
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00293_7</srcid><srcstatus/><internalId>62</internalId></linkedfrom><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00293_8</srcid><srcstatus/><internalId>63</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00293_1</srcid><srcstatus/><internalId>324</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00293_2</srcid><srcstatus/><internalId>325</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00293_3</srcid><srcstatus/><internalId>327</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00293_4</srcid><srcstatus/><internalId>328</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00293_5</srcid><srcstatus/><internalId>329</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00293_6</srcid><srcstatus/><internalId>330</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00293_9</srcid><srcstatus/><internalId>331</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00293_10</srcid><srcstatus/><internalId>332</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00293_11</srcid><srcstatus/><internalId>333</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00293_12</srcid><srcstatus/><internalId>334</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations><ruleid>WRN.swurs.needscoverage.count</ruleid></oreqmViolations><covstatus>covered</covstatus><internalId>89</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00114</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        The CanTp module shall allow configuration of the padding activation at
        pre-compile time, by using parameter CanTpRxPaddingActivation. The
        configuration parameter is specific on individual received or sent N-SDU.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00114_1</srcid><srcstatus/><internalId>91</internalId></linkedfrom><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00114_2</srcid><srcstatus/><internalId>92</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>90</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00114_1</id>
         <status>approved</status>
         <source>EB refinement</source>
         <version>1</version>
         <description>
        The CanTp module shall allow configuration of the padding activation at
        pre-compile time, by using parameter CanTpRxPaddingActivation.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30201</srcid><srcstatus/><internalId>1262</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30188</srcid><srcstatus/><internalId>1284</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.ASR40.SWS_CanTp_00114</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>90</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>91</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00114_2</id>
         <status>approved</status>
         <source>EB refinement</source>
         <version>1</version>
         <description>
        The configuration parameter is specific on individual received or sent N-SDU.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30201</srcid><srcstatus/><internalId>1262</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30188</srcid><srcstatus/><internalId>1284</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.ASR40.SWS_CanTp_00114</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>90</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>92</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00132</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        If the CanTpDevErrorDetect switch is enabled API parameter checking is enabled.
        The detailed description of the detected errors can be found in chapter
        7.4 and chapter 8. (BSW00323)
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest12_006_InvalidRxLength_CANTP_ON_CAN_CAN_FD_CANFD_frames</srcid><srcstatus/><internalId>1173</internalId></linkedfrom><linkedfrom><srcid>CanTp_ConTest12_007_InvalidRxLength_CANTP_ON_CAN_CAN_FD_CAN20_frames</srcid><srcstatus/><internalId>1174</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30250</srcid><srcstatus/><internalId>1290</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30251</srcid><srcstatus/><internalId>1291</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30477</srcid><srcstatus/><internalId>1675</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30478</srcid><srcstatus/><internalId>1676</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30479</srcid><srcstatus/><internalId>1677</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30480</srcid><srcstatus/><internalId>1678</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30481</srcid><srcstatus/><internalId>1679</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30482</srcid><srcstatus/><internalId>1680</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30483</srcid><srcstatus/><internalId>1681</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30255</srcid><srcstatus/><internalId>1682</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations><ruleid>WRN.swuts.needscoverage.count</ruleid></oreqmViolations><covstatus>covered</covstatus><internalId>93</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00150</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        The CanTp module's source (as long as it is written in C) shall conform to the
        HIS subset of the MISRA C Standard. (BSW007)
      </description>
         <comment>
        The adherence to this requirement is ensured by the following release check (URL to the checklist template plus ID of the check):
        http://svn.ebgroup.elektrobit.com/svn/autosar/asc_Project/trunk/doc/project/templates/Module_RFI_Checklist_template.xltx,
        rev 1357, Checks='MISRA'
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>94</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00151</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        The CanTp module's source shall not use compiler and platform specific
        keywords (BSW00306)
      </description>
         <comment>
        The adherence to this requirement is ensured by the following release check (URL to the checklist template plus ID of the check):
        http://svn.ebgroup.elektrobit.com/svn/autosar/asc_Project/trunk/doc/project/templates/Module_RFI_Checklist_template.xltx,
        rev 1357 Checks='CMDB Test run result WINDOWS', 'CMDB Test run result lead platform'
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>95</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00152</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        The CanTp module's source shall indicate all global data with read only
        properties by explicitly assigning the keyword const. (BSW00309)
      </description>
         <comment>
        This requirement makes sense for global configuration, which shall not be changed.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate_var/xgen/CanTp.xgen_651</srcid><srcstatus/><internalId>1088</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>96</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00158</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        The CanTp module's source shall not be processor and compiler dependent.
        (BSW006)
      </description>
         <comment>
        The adherence to this requirement is ensured by the following release check (URL to the checklist template plus ID of the check):
        http://svn.ebgroup.elektrobit.com/svn/autosar/asc_Project/trunk/doc/project/templates/Module_RFI_Checklist_template.xltx,
        rev 1357 Checks='CMDB Test run result WINDOWS', 'CMDB Test run result lead platform'
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>97</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00159</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        The code file structure will not be completely defined within this
        specification. The CanTp module code file structure should include
        CanTp_Lcfg.c containing the link time configurable parameters. (BSW380)
      </description>
         <comment>
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
        <!-- Decision of coverage improvement is open. -->
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/src/CanTp_Lcfg.c_3</srcid><srcstatus/><internalId>1004</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>98</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00160</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        References to c-configuration parameters (link time and post-build time) will be
        placed in a separate h-file. The h-file should be the same as
        pre-compilation parameters.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00160_1</srcid><srcstatus/><internalId>100</internalId></linkedfrom><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00160_2</srcid><srcstatus/><internalId>101</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>99</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00160_1</id>
         <status>approved</status>
         <source>EB refinement</source>
         <version>1</version>
         <description>
        References to c-configuration parameters (link time) will be
        placed in a separate h-file (CanTp_Lcfg.h).
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/include/CanTp_Lcfg.h_6</srcid><srcstatus/><internalId>998</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.ASR40.SWS_CanTp_00160</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>99</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>100</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00160_2</id>
         <status>approved</status>
         <source>EB refinement</source>
         <version>1</version>
         <description>
        References to c-configuration parameters (post-build time) will be
        placed in a separate h-file (CanTp_PBcfg.h).
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate_var/xgen/CanTp.xgen_586</srcid><srcstatus/><internalId>1086</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.ASR40.SWS_CanTp_00160</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>99</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>101</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00165</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        BSW scheduler information is included via SchM_CanTp.h.
      </description>
         <comment>
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/src/CanTp_ExitTable.c_12</srcid><srcstatus/><internalId>1002</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/include/CanTp_Internal.h.m4_44</srcid><srcstatus/><internalId>1009</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>102</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00259</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        The CanTp module code file structure should include CanTp_PBcfg.c containing the
        post-build time configurable parameters.
      </description>
         <comment>
        The sentence "These files will contain all link time
        and post-build configurable parameters." has been removed form the description
        of this requirement. This sentence is a conclusion of CanTp.ASR40.CANTP159
        and CanTp.ASR40.CANTP259 and is therefore not part of this requirement.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
        <!-- Decision for coverage improvement is open. -->
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate_var/xgen/CanTp.xgen_588</srcid><srcstatus/><internalId>1087</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>103</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00264</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        File CanTp.h shall include ComStack_Types.h and Det.h (optional, if development
        error detection is configured as ON).
      </description>
         <comment>
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/CanTp.h_23</srcid><srcstatus/><internalId>1006</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/include/CanTp.h_26</srcid><srcstatus/><internalId>1007</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>104</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00279</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        If upper layer temporarily has no Tx buffer available, the
        PduR_CanTpCopyTxData() function returns BUFREQ_E_BUSY.
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        This is a requirement to the upper layer (PduR). The requirement of how to handle
        this situation from modules point of view is CanTp.ASR40.CANTP184.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>105</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.SWS_CanTp_00297</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.0.0</source>
         <version>1</version>
         <description>
        CANTP_VERSION_INFO_API shall be used to switch CanTp_GetVersionInfo API On or
        OFF.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_49017</srcid><srcstatus/><internalId>1647</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>106</internalId></specobject>

  </specobjects>
    <specobjects doctype="swurs">

    <!-- Design part channel lock -->
    <specobject>
      <id>CanTp.Design.ChannelLock</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        To avoid concurrency effects during channel processing, a
        channel lock mechanism shall be implemented. This channel lock
        shall protect channel variable inconsistency.
      </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.Design.ChannelLock.RxCancellation</srcid><srcstatus/><internalId>108</internalId></linkedfrom><linkedfrom><srcid>CanTp.Design.ChannelLock.TxCancellation</srcid><srcstatus/><internalId>109</internalId></linkedfrom><linkedfrom><srcid>CanTp.Design.ChannelLock.TxConfirmation</srcid><srcstatus/><internalId>110</internalId></linkedfrom><linkedfrom><srcid>CanTp.Design.ChannelLock.MainFunction</srcid><srcstatus/><internalId>111</internalId></linkedfrom><linkedfrom><srcid>CanTp.Design.ChannelLock.MainFunctionTimeout</srcid><srcstatus/><internalId>112</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>107</internalId></specobject>

    <specobject>
      <id>CanTp.Design.ChannelLock.RxCancellation</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If CanTp_CancelReceive() is called while requested channel is
        in process and locked, then the module shall reject the cancel
        request and return E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_CancelRx_CHLOCK</srcid><srcstatus/><internalId>1608</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.Design.ChannelLock</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>107</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.CancelReceive.E_OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>522</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>108</internalId></specobject>

    <specobject>
      <id>CanTp.Design.ChannelLock.TxCancellation</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If CanTp_CancelTransmit() is called while requested channel is
        in process and locked, then the module shall reject the cancel
        request and return E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_CancelTx_CHLOCK</srcid><srcstatus/><internalId>1610</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.Design.ChannelLock</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>107</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.CancelTransmit.E_OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>526</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>109</internalId></specobject>

    <specobject>
      <id>CanTp.Design.ChannelLock.TxConfirmation</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If CanTp_TxConfirmation() is called while requested channel is in process and locked,
        CanTp shall process the confirmation only after channel gets unlocked and if it was
        awaited. Otherwise, ignore the call.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_40045</srcid><srcstatus/><internalId>1603</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_TxConfirm</srcid><srcstatus/><internalId>1609</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.Design.ChannelLock</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>107</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>110</internalId></specobject>

    <specobject>
      <id>CanTp.Design.ChannelLock.MainFunction</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If CanTp_MainFunction() is called while requested channel is
        in process and locked, then the module shall suspend the process
        of this channel until the next main function call.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_ChannelLock_MF</srcid><srcstatus/><internalId>1611</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.Design.ChannelLock</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>107</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>111</internalId></specobject>

    <specobject>
      <id>CanTp.Design.ChannelLock.MainFunctionTimeout</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If CanTp_MainFunction() is called while requested channel is
        in process and locked, then the module shall remember the elapsed
        main function calls to provide accurate timeout behavior.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_40052</srcid><srcstatus/><internalId>1606</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.Design.ChannelLock</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>107</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>112</internalId></specobject>

    <specobject>
      <id>CanTp.Design.CopyRxData.BufferSize</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        CanTp shall handle an UL buffer &gt; 4095 provided by PduR_CanTpCopyRxData.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_Rx_MaxDataLength</srcid><srcstatus/><internalId>1403</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>113</internalId></specobject>

    <specobject>
      <id>CanTp.Design.CopyTxData.BufferSize</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        CanTp shall handle an UL buffer &gt; 4095 provided by PduR_CanTpCopyTxData.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_MaxBuffSize</srcid><srcstatus/><internalId>1407</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>114</internalId></specobject>

    <specobject>
      <id>CanTp.Design.StartOfReception.BufferSize</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        CanTp shall handle an UL buffer &gt; 4095 provided by PduR_CanTpStartOfReception.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_Rx_MaxDataLength</srcid><srcstatus/><internalId>1403</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>115</internalId></specobject>

    <specobject>
      <id>CanTp.Design.Rx.WaitTxConfirmation_FC_CTS</id>
      <status>approved</status>
      <source>EB Design State Diagram: ASCCANTP-988</source>
      <version>1</version>
      <description>
        For segmented reception and after sending of FC(CTS):
        If next CF is received before the sent FC(CTS) was confirmed, CanTp shall process the CF and
        ignore the subsequent call of CanTp_TxConfirmation() for the FC(CTS).
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_RxCF_Before_TxConfCTS</srcid><srcstatus/><internalId>1233</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>116</internalId></specobject>

    <specobject>
      <id>CanTp.Design.Tx.WaitTxConfirmation_FF</id>
      <status>approved</status>
      <source>EB Design State Diagram: ASCCANTP-988</source>
      <version>2</version>
      <description>
        For segmented transmission:
        If FC(CTS) is received before the sent FF was confirmed, CanTp shall process the FC(CTS)
        and wait the subsequent call of CanTp_TxConfirmation() for the FF before sending the next CF.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_RxCTS_Before_TxConfFF</srcid><srcstatus/><internalId>1228</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_RxCTS_And_MF_Before_TxConfFF</srcid><srcstatus/><internalId>1229</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>117</internalId></specobject>

    <specobject>
      <id>CanTp.Design.Tx.WaitTxConfirmation_CF</id>
      <status>approved</status>
      <source>EB Design State Diagram: ASCCANTP-988</source>
      <version>2</version>
      <description>
        For segmented transmission:
        If FC(CTS) is received before the sent last CF of block was confirmed, CanTp shall process
        the FC(CTS) and wait for the the subsequent call of CanTp_TxConfirmation() before sending the next CF.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_RxCTS_Before_TxConfCF</srcid><srcstatus/><internalId>1230</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_RxCTS_And_MF_Before_TxConfCF</srcid><srcstatus/><internalId>1231</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>118</internalId></specobject>

    <specobject>
      <id>CanTp.Design.Tx.WaitTxConfirmation_UnexpFC_CTS</id>
      <status>approved</status>
      <source>EB Design State Diagram: ASCCANTP-988</source>
      <version>1</version>
      <description>
        For segmented transmission:
        If an unexpected FC(CTS) is received before a sent intermediated CF was confirmed, CanTp
        shall ignore the FC.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_RxCTS_Interblock</srcid><srcstatus/><internalId>1232</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>119</internalId></specobject>

    <specobject>
      <id>CanTp.Design.AllowCanTp_Transmit_FromContext_PduR_CanTpTxConfirmation</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The CanTp module shall support a transmission request via CanTp_Transmit called within the
        context of PduR_CanTpTxConfirmation for the same TxPduId.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_RequestNewTransmissionFromTxConfirmation_SF</srcid><srcstatus/><internalId>1180</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_RequestNewTransmissionFromTxConfirmation_MultiFrame</srcid><srcstatus/><internalId>1181</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>120</internalId></specobject>

  </specobjects>
    <specobjects doctype="swurs">

    <specobject>
      <id>CanTp.SWS_CanTp_00267</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Version number macros can be used for checking and reading out
      the software version of a software module, during compile-time and runtime.
      </description>
      <comment>
      Proposed tests:
      - For compile time: #if checks of the version number.
      - For runtime: if checks of the version number.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_40048</srcid><srcstatus/><internalId>1597</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_49017</srcid><srcstatus/><internalId>1647</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>121</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00033</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If a recommendation of ISO 15765-2 is not explicitly excluded in the SWS, the
      CanTp module shall follow this recommendation.
      </description>
      <comment>
      This requirement is informational only.
      Rationale:
      ISO 15765-2 requirements will be included via another requirement document.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>122</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00027</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The CanTp module shall have two internal states, CANTP_OFF and CANTP_ON.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
      <!-- Behavior covered by CanTp.SWS_CanTp_00168 and CanTp.SWS_CanTp_00170 -->
      <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00168</srcid><srcstatus/><internalId>124</internalId></linkedfrom></coveredby></needscov>
       <containerCovstatus>covered</containerCovstatus></needscoverage>
       <providescoverage>
          <provcov>
             <linksto>CanTp.SWS_CanTp_00161</linksto>
             <dstversion>1</dstversion>
          <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>345</internalId></provcov>
       </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>123</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00168</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The CanTp module shall be in the CANTP_OFF state after power up.
      </description>
      <comment>
      Can be tested when API calls report a Det when module is uninitialized.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
          <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30039</srcid><srcstatus/><internalId>1186</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00161</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>345</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00027</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>124</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00169</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      In the state CANTP_OFF, the CanTp shall allow an update of the postbuild
      configuration.
      </description>
      <comment>
      Loading of post build configuration is only possible during the call of CanTp_Init().
      Due to deviation dev.CanTp.Shutdown the module will only be at CANTP_OFF at startup and
      return to this state for reinitialization of the module to protect the reinitialization
      process. An update of the post build configuration will take place for every CanTp_Init()
      calls independent of the previous state.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanTp_Init.c_206</srcid><srcstatus/><internalId>1023</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>125</internalId></specobject>

    <specobject>
       <id>CanTp.SWS_CanTp_00170</id>
       <status>approved</status>
       <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
       <version>1</version>
       <description>
      The CanTp module shall change to the internal state CANTP_ON when the CanTp has
      been successfully initialized with CanTp_Init().
    </description>
       <releases>
          <release>AUTOSAR R20-11</release>
       </releases>
       <needscoverage>
      <!--Covered by CanTp.SWS_CanTp_00030_3 -->
      <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00030_3</srcid><srcstatus/><internalId>137</internalId></linkedfrom></coveredby></needscov>
       <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>126</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00238</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The CanTp module shall perform segmentation and reassembly tasks only when the
      CanTp is in the CANTP_ON state.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30039</srcid><srcstatus/><internalId>1186</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30053</srcid><srcstatus/><internalId>1196</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30135</srcid><srcstatus/><internalId>1206</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>127</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00030</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The function CanTp_Init shall initialize all global variables of the module and
      sets all transport protocol connections in a sub-state of CANTP_ON, in
      which neither segmented transmission nor segmented reception are in
      progress (Rx thread in state CANTP_RX_WAIT and Tx thread in state
      CANTP_TX_WAIT).
      </description>
      <comment>
      The requirements define the states CANTP_RX_WAIT and CANTP_TX_WAIT.
      These states are used for the connection channel. Since one channel can
      handle both directions, the channel state only distinguishes between idle
      and reserved.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00030_1</srcid><srcstatus/><internalId>129</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00030_2</srcid><srcstatus/><internalId>136</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00030_3</srcid><srcstatus/><internalId>137</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>128</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00030_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The function CanTp_Init shall initialize all global variables of the module.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
      <!--Covered by CanTp.SWS_CanTp_00030_1a -->
      <!--Covered by CanTp.SWS_CanTp_00030_1b -->
      <!--Covered by CanTp.SWS_CanTp_00030_1c -->
      <!--Covered by CanTp.SWS_CanTp_00030_1d -->
      <!--Covered by CanTp.SWS_CanTp_00030_1e -->
      <!--Covered by CanTp.SWS_CanTp_00030_1f -->
      <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00030_1a</srcid><srcstatus/><internalId>130</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00030_1b</srcid><srcstatus/><internalId>131</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00030_1c</srcid><srcstatus/><internalId>132</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00030_1d</srcid><srcstatus/><internalId>133</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00030_1e</srcid><srcstatus/><internalId>134</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00030_1f</srcid><srcstatus/><internalId>135</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.SWS_CanTp_00030_1g</srcid><srcstatus/><internalId>709</internalId></linkedfrom></coveredby></needscov>
       <containerCovstatus>covered</containerCovstatus></needscoverage>
       <providescoverage>
         <provcov>
           <linksto>CanTp.SWS_CanTp_00030</linksto>
           <dstversion>1</dstversion>
         <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>129</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00030_1a</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      After the function call CanTp_Init, the module shall use the configuration parameter
      CanTpBs as maximum block size value.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30085</srcid><srcstatus/><internalId>1208</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00030_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>129</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>130</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00030_1b</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      After the function call CanTp_Init, the module shall use the configuration parameter
      CanTpSTmin as the minimum duration between the transmission of two CF N-PDUs.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30401</srcid><srcstatus/><internalId>1409</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00030_1</linksto>
           <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>129</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>131</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00030_1c</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      After the function call CanTp_Init, the module shall use the configuration parameter
      CanTpNTa as the target address for extended addressing.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30416</srcid><srcstatus/><internalId>1660</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00030_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>129</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>132</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00030_1d</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      After the function call CanTp_Init, the module shall use the configuration parameter
      CanTpNAe as the address extension value for mixed addressing format.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_SegRxMixedAdr</srcid><srcstatus/><internalId>1683</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00030_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>129</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>133</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00030_1e</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      After the function call CanTp_Init, the module shall use the configuration parameter
      CanTpRxAddressingFormat as the communication addressing mode of Rx N-SDU.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_SegRxMixedAdr</srcid><srcstatus/><internalId>1683</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00030_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>129</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>134</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00030_1f</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      After the function call CanTp_Init, the module shall use the configuration parameter
      CanTpPaddingByte (CAN 2.0) as the value of unused bytes in transmitted frames if padding is enabled.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30188</srcid><srcstatus/><internalId>1284</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00030_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>129</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>135</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00030_2</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The function CanTp_Init shall set all transport protocol connections
      in a sub-state of CANTP_ON.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <!--Covered by CanTp.SWS_CanTp_00030_3 -->
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00030_3</srcid><srcstatus/><internalId>137</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00030</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>136</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00030_3</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      After the function CanTp_Init has initialized the module, all
      transport protocol connections be set to a state, in
      which neither segmented transmission nor segmented reception are in
      progress (Rx thread in state CANTP_RX_WAIT and Tx thread in state
      CANTP_TX_WAIT).
      </description>
      <comment>
      After the function call CanTp_Init, the module shall be ready to establish connections to
      receive and transmit messages.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <!-- Requires multiple tests cases -->
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30136</srcid><srcstatus/><internalId>1191</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_RX_WAIT</srcid><srcstatus/><internalId>1192</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00030</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>128</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00030_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>136</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00170</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>126</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>137</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00031</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If development error detection for the CanTp module is enabled the CanTp module
      shall raise an error (CANTP_E_UNINIT) when the PDU Router or CAN
      Interface tries to use any function (except CanTp_GetVersionInfo) before
      the function CanTp_Init has been called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30039</srcid><srcstatus/><internalId>1186</internalId></linkedfrom></coveredby></needscov>
        <!--Covered by CanTp.EB.GetVersionInfo -->
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.EB.GetVersionInfo</srcid><srcstatus/><internalId>550</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293_4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>328</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00161</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>345</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>138</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00111</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If called when the CanTp module is in the global state CANTP_ON, the function
      CanTp_Init shall return the module to state Idle (state = CANTP_ON, but
      neither transmission nor reception are in progress).
      </description>
      <comment>
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30136</srcid><srcstatus/><internalId>1191</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_RX_WAIT</srcid><srcstatus/><internalId>1192</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>139</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00273</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The CanTp module shall loose all current connections if CanTp_Init is called
      when CanTp module is in the global state CANTP_ON.
      </description>
      <comment>
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30136</srcid><srcstatus/><internalId>1191</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_RX_WAIT</srcid><srcstatus/><internalId>1192</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>140</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00010</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The function CanTp_Shutdown shall stop the CanTp module properly.
      </description>
      <comment>
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <!-- Linked to deviation dev.CanTp.Shutdown -->
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.Shutdown</srcid><srcstatus/><internalId>974</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>141</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00176</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The function CanTp_Transmit() shall be asynchronous.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30048</srcid><srcstatus/><internalId>1193</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30053</srcid><srcstatus/><internalId>1196</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30055</srcid><srcstatus/><internalId>1198</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>142</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00177</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      After the transmit request was accepted, the CanTp module shall
      notify its upper layer if the N-SDU transfer is fully processed
      (successfully or not).
    </description>
       <releases>
          <release>AUTOSAR R20-11</release>
       </releases>
       <needscoverage>
      <!-- Requires multiple tests cases -->
      <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_RequestNewTransmissionFromTxConfirmation_SF</srcid><srcstatus/><internalId>1180</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_RequestNewTransmissionFromTxConfirmation_MultiFrame</srcid><srcstatus/><internalId>1181</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30048</srcid><srcstatus/><internalId>1193</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30053</srcid><srcstatus/><internalId>1196</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30055</srcid><srcstatus/><internalId>1198</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_SegMixed_PaddingOff</srcid><srcstatus/><internalId>1199</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30101</srcid><srcstatus/><internalId>1241</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_N_Bs_LastCF</srcid><srcstatus/><internalId>1350</internalId></linkedfrom></coveredby></needscov>
       <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>143</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00242</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      This feature shall be (de)activated by static
      configuration (parameter CanTpTc).
      </description>
      <comment>
      With "This feature" transmit cancellation is meant and the feature is activated using
      configuration parameter CanTpCancelTransmitApi.
      According to RfC 46392 CanTp_CancelTransmit() shall return E_NOT_OK if CanTpTc is FALSE.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30366</srcid><srcstatus/><internalId>1326</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_CanTpTc</srcid><srcstatus/><internalId>1327</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>144</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00274</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Transmit Cancellation is triggered by the call of CanTp_CancelTransmit().
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30367</srcid><srcstatus/><internalId>1319</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30339</srcid><srcstatus/><internalId>1321</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30376</srcid><srcstatus/><internalId>1322</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30379</srcid><srcstatus/><internalId>1323</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30363</srcid><srcstatus/><internalId>1324</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30361</srcid><srcstatus/><internalId>1325</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30366</srcid><srcstatus/><internalId>1326</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30365</srcid><srcstatus/><internalId>1328</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30362</srcid><srcstatus/><internalId>1329</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_STmin_MF_CLBK</srcid><srcstatus/><internalId>1382</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_CancelTx_CHLOCK</srcid><srcstatus/><internalId>1610</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_WaitingSTmin_CancelTransmit_Ignored</srcid><srcstatus/><internalId>1642</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations><ruleid>WRN.swuts.needscoverage.count</ruleid></oreqmViolations><covstatus>covered</covstatus><internalId>145</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00243</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      After the call of the service CanTp_CancelTransmit(), the transfer on
      this connection shall be aborted.
      </description>
      <comment>
      This requirement shall be tested under the consideration of
      limitation lim.CanTp.CancellationPrecondition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30367</srcid><srcstatus/><internalId>1319</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30363</srcid><srcstatus/><internalId>1324</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30366</srcid><srcstatus/><internalId>1326</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30365</srcid><srcstatus/><internalId>1328</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30362</srcid><srcstatus/><internalId>1329</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_STmin_MF_CLBK</srcid><srcstatus/><internalId>1382</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_FC_Transmission_TxCancellation</srcid><srcstatus/><internalId>1505</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_WaitingSTmin_CancelTransmit_Ignored</srcid><srcstatus/><internalId>1642</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>146</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00075</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      When the transmit confirmation is not received after a maximum time
      (equal to N_As), the CanTp module shall abort the corresponding session.
      The N-PDU remains unavailable to other concurrent sessions until the TxConfirmation
      is received, successful or not.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.TxConfirmation</srcid><srcstatus/><internalId>980</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00075_1</srcid><srcstatus/><internalId>10</internalId></linkedfrom><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00075_2</srcid><srcstatus/><internalId>11</internalId></linkedfrom><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00075_3</srcid><srcstatus/><internalId>12</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>147</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00076</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      For confirmation calls, the CanTp module shall provide the function
      CanTp_TxConfirmation().
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <!-- Requirement shall be tested with a compile test only. -->
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_49017</srcid><srcstatus/><internalId>1647</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>148</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00355</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      CanTp shall abort the corrensponding session, when CanTp_TxConfirmation()
      is called with the result E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.TxConfirmation</srcid><srcstatus/><internalId>980</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>149</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00078</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      For reception indication, the CanTp module shall provide CanTp_RxIndication().
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <!-- Requirement shall be tested with a compile test only. -->
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_49017</srcid><srcstatus/><internalId>1647</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>150</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00079</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      When receiving an SF or an FF N-PDU, the CanTp module shall notify
      the upper layer (PDU Router) about this reception using the PduR_CanTpStartOfReception
      function.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30079</srcid><srcstatus/><internalId>1254</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_RxSF_NOTOK</srcid><srcstatus/><internalId>1361</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30406</srcid><srcstatus/><internalId>1475</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_BurstOfCF_Reception</srcid><srcstatus/><internalId>1646</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>151</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00329</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      CanTp shall provide the content of the FF/SF to PduR using the parameter
      TpSduInfoPtr of PduR_CanTpStartOfReception().
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <!-- Linked to dev.CanTp.StartOfReceptionWithoutData -->
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.StartOfReceptionWithoutData</srcid><srcstatus/><internalId>979</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>152</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00350</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The received data link layer data length (RX_DL) shall be derived from
      the first received payload length of the CAN frame/PDU (CAN_DL) as follows:
      - For CAN_DL values less than or equal to eight bytes the RX_DL value shall be eight.
      - For CAN_DL values greater than eight bytes the RX_DL value equals the CAN_DL value.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00350_1</srcid><srcstatus/><internalId>154</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00350_2</srcid><srcstatus/><internalId>155</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>153</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00350_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The received data link layer data length (RX_DL) shall be derived from
      the first received payload length of the CAN frame/PDU (CAN_DL) and shall
      be eight CAN_DL values less than or equal to eight bytes.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest09012_CanFD_Rx_FF_CF_LastCF</srcid><srcstatus/><internalId>1152</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00350</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>154</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00350_2</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The received data link layer data length (RX_DL) shall be derived from
      the first received payload length of the CAN frame/PDU (CAN_DL) and shall equal the
      CAN_DL value for CAN_DL values greater than eight bytes.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest09012_CanFD_Rx_FF_CF_LastCF</srcid><srcstatus/><internalId>1152</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00350</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>155</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00330</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      When CanTp_RxIndication is called for a SF or FF N-PDU with MetaData
      (indicating a generic connection), the CanTp module shall store the
      addressing information contained in the MetaData of the PDU and use this
      information for the initiation of the connection to the upper layer,
      for transmission of FC N-PDUs and for identification of CF N-PDUs.
      The addressing information in the MetaData depends on the addressing format:
      - Normal, Extended, Mixed 11 bit: none
      - Normal fixed, Mixed 29 bit: N_SA, N_TA
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.MetaData.AddresingFormats</srcid><srcstatus/><internalId>982</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00330_1</srcid><srcstatus/><internalId>157</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.MetaData.GetRxNTaFromCanId</srcid><srcstatus/><internalId>774</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.MetaData.GetRxNSaGenConnectionOn</srcid><srcstatus/><internalId>775</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>156</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00330_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      When CanTp_RxIndication is called for a SF or FF N-PDU with MetaData
      (indicating a generic connection), the CanTp module shall store the
      addressing information contained in the MetaData of the PDU and use this
      information for the initiation of the connection to the upper layer,
      for transmission of FC N-PDUs and for identification of CF N-PDUs.
      N_SA and N_TA addressing information are stored in the MetaData
      when Normal fixed addressing format is used.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.EB.MetaData.CheckRxNTa</srcid><srcstatus/><internalId>779</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.MetaData.CheckRxNSa</srcid><srcstatus/><internalId>780</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00330</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>156</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>157</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00331</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      When calling PduR_CanTpStartOfReception() for a generic connection
      (N-SDU with MetaData), the CanTp module shall forward the extracted
      addressing information via the MetaData of the N-SDU. The addressing
      information in the MetaData depends on the addressing format:
      - Normal: none
      - Extended: N_TA
      - Mixed 11 bit: N_AE
      - Normal fixed: N_SA, N_TA
      - Mixed 29 bit: N_SA, N_TA, N_AE
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.MetaData.AddresingFormats</srcid><srcstatus/><internalId>982</internalId></linkedfrom><linkedfrom><srcid>dev.CanTp.MetaDataForward</srcid><srcstatus/><internalId>983</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>158</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00332</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      When calling CanIf_Transmit() for an FC on a generic connection
      (N-PDU with MetaData), the CanTp module shall provide the stored
      addressing information via the MetaData of the N-PDU.
      The addressing information in the MetaData depends on the addressing format:
      - Normal, Extended, Mixed 11 bit: none
      - Normal fixed, Mixed 29 bit: N_SA (saved N_TA), N_TA (saved N_SA)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.MetaData.AddresingFormats</srcid><srcstatus/><internalId>982</internalId></linkedfrom><linkedfrom><srcid>dev.CanTp.MetaDataForward</srcid><srcstatus/><internalId>983</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>159</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00333</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      When CanTp_RxIndication is called for a CF on a generic connection
      (N-PDU with MetaData), the CanTp module shall check the addressing
      information contained in the MetaData of the N-PDU against the stored
      values from the FF.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.EB.MetaData.CheckRxNTa</srcid><srcstatus/><internalId>779</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.MetaData.CheckRxNSa</srcid><srcstatus/><internalId>780</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>160</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00166</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      At the reception of a FF or last CF of a block, the CanTp module
      shall start a time-out N_Br before calling PduR_CanTpStartOfReception
      or PduR_CanTpCopyRxData.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.SF.NBr</srcid><srcstatus/><internalId>990</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00166</srcid><srcstatus/><internalId>13</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>161</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00080</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The available Rx buffer size is reported to the CanTp in the output
      pointer parameter of the PduR_CanTpStartOfReception() service.
      The available Rx buffer can be smaller than the expected N-SDU data length. 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_SegExtRxMultBuf_1</srcid><srcstatus/><internalId>1256</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_BS_Unlimited_1</srcid><srcstatus/><internalId>1406</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_SegExtRxMultBufStBs_1</srcid><srcstatus/><internalId>1425</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>162</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00081</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      After the reception of a First Frame or Single Frame, if the function
      PduR_CanTpStartOfReception()returns BUFREQ_E_NOT_OK to the CanTp module,
      the CanTp module shall abort the reception of this N-SDU.
      No Flow Control will be sent and PduR_CanTpRxIndication() will not be
      called in this case.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30164</srcid><srcstatus/><internalId>1257</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>163</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00318</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      After the reception of a First Frame, if the function
      PduR_CanTpStartOfReception()returns BUFREQ_E_OVFL to the CanTp module,
      the CanTp module shall send a Flow Control N-PDU with overflow status
      (FC(OVFLW)) and abort the N-SDU reception.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00318</srcid><srcstatus/><internalId>17</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>164</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00353</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      After the reception of a Single Frame, if the function
      PduR_CanTpStartOfReception()returns BUFREQ_E_OVFL to the CanTp module,
      the CanTp module shall abort the N-SDU reception.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_Conf01_SF_StartOfReception_BUFREQ_E_OVFL</srcid><srcstatus/><internalId>1225</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00064</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>165</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00339</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      After the reception of a First Frame or Single Frame, if the function
      PduR_CanTpStartOfReception() returns BUFREQ_OK with a smaller available
      buffer size than needed for the already received data, the CanTp module
      shall abort the reception of the N-SDU and call PduR_CanTpRxIndication()
      with the result E_NOT_OK. 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.StartOfReception.BufferSize</srcid><srcstatus/><internalId>984</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>166</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00082</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      After the reception of a First Frame, if the function PduR_CanTpStartOfReception()
      returns BUFREQ_OK with a smaller available buffer size than needed for the next block,
      the CanTp module shall start the timer N_Br.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.StartOfReception.BUSY</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00082</srcid><srcstatus/><internalId>20</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>167</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00325</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If the function PduR_CanTpCopyRxData() called after reception of
      the last Consecutive Frame of a block returns BUFREQ_OK, but the
      remaining buffer is not sufficient for the reception of the next block,
      the CanTp module shall start the timer N_Br.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_ZeroBrForBlockLF</srcid><srcstatus/><internalId>1373</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_31110</srcid><srcstatus/><internalId>1422</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>168</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00222</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      While the timer N_Br is active, the CanTp module shall call
      the service PduR_CanTpCopyRxData() with a data length 0 (zero)
      and NULL_PTR as data buffer during each processing of the MainFunction.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30288</srcid><srcstatus/><internalId>1243</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_ReqestMoreBuffer</srcid><srcstatus/><internalId>1418</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_31110</srcid><srcstatus/><internalId>1422</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.11240</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>896</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>169</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00341</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If the N_Br timer expires and the available buffer size is still
      not big enough, the CanTp module shall send a new FC(WAIT) to
      suspend the N-SDU reception and reload the N_Br timer.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30148</srcid><srcstatus/><internalId>1221</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>170</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00223</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The CanTp module shall send a maximum of WFTmax consecutive
      FC(WAIT) N-PDU. If this number is reached, the CanTp module
      shall abort the reception of this N-SDU (the receiver did not
      send any FC N-PDU, so the N_Bs timer expires on the sender side
      and then the transmission is aborted) and a receiving indication
      with E_NOT_OK occurs.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00223_1</srcid><srcstatus/><internalId>172</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00223_2</srcid><srcstatus/><internalId>173</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
           <linksto>CanTp.11253</linksto>
           <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>835</internalId></provcov>
        <provcov>
           <linksto>CanTp.11277</linksto>
           <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>836</internalId></provcov>
     </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>171</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00223_1</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
     The CanTp module shall send a maximum of WFTmax consecutive FC(WAIT) N-PDU.
   </description>
      <releases>
         <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
         <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30099</srcid><srcstatus/><internalId>1222</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_ZeroBrForFF</srcid><srcstatus/><internalId>1372</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_ZeroBrForBlockLF</srcid><srcstatus/><internalId>1373</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_31110</srcid><srcstatus/><internalId>1422</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30453</srcid><srcstatus/><internalId>1673</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
         <provcov>
            <linksto>CanTp.SWS_CanTp_00223</linksto>
            <dstversion>1</dstversion>
         <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>171</internalId></provcov>
      </providescoverage>
   <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>172</internalId></specobject>

   <specobject>
      <id>CanTp.SWS_CanTp_00223_2</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
     If this number is reached, the CanTp module shall abort the reception of
     this N-SDU (the receiver did not send any FC N-PDU, so the N_Bs timer
     expires on the sender side and then the transmission is aborted) and a
     receiving indication with E_NOT_OK occurs.
   </description>
      <releases>
         <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
         <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30099</srcid><srcstatus/><internalId>1222</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30322</srcid><srcstatus/><internalId>1223</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_N_Br_CFEOB</srcid><srcstatus/><internalId>1352</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_ZeroBrForFF</srcid><srcstatus/><internalId>1372</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_ZeroBrForBlockLF</srcid><srcstatus/><internalId>1373</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30453</srcid><srcstatus/><internalId>1673</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
         <provcov>
            <linksto>CanTp.SWS_CanTp_00223</linksto>
            <dstversion>1</dstversion>
         <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>171</internalId></provcov>
         <provcov>
            <linksto>CanTp.SWS_CanTp_00084</linksto>
            <dstversion>1</dstversion>
         <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>187</internalId></provcov>
      </providescoverage>
   <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>173</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00311</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      In case of N_Ar timeout occurrence (no confirmation from CAN
      driver for any of the FC frame sent) the CanTp module shall
      abort reception and notify the upper layer of this failure
      by calling the indication function PduR_CanTpRxIndication()
      with the result E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30102</srcid><srcstatus/><internalId>1242</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_31109</srcid><srcstatus/><internalId>1421</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_FC_Transmission_Timeout_Pending_SF</srcid><srcstatus/><internalId>1486</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_FC_Transmission_Timeout_Pending_FF</srcid><srcstatus/><internalId>1487</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_FC_Transmission_Timeout_Pending_CF</srcid><srcstatus/><internalId>1488</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_SF_Transmission_Pending_FC_Wait_Timeout</srcid><srcstatus/><internalId>1498</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_Timeout_FC_Transmission_Nothing_Pending</srcid><srcstatus/><internalId>1500</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30446</srcid><srcstatus/><internalId>1666</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
           <linksto>CanTp.SWS_CanTp_00084</linksto>
           <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>187</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>174</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00224</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      When the Rx buffer is large enough for the next block (directly
      after the First Frame or the last Consecutive Frame of a block,
      or after repeated calls to PduR_CanTpCopyRxData() according to
      SWS_CanTp_00222), the CanTp module shall send a Flow Control N-PDU
      with ClearToSend status (FC(CTS)) and shall then expect the reception
      of Consecutive Frame N-PDUs.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_SegExtRxMultBuf_1</srcid><srcstatus/><internalId>1256</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30170</srcid><srcstatus/><internalId>1258</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_SegExtRxMultBufStBs_1</srcid><srcstatus/><internalId>1425</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_SegExtRxMultBufStBs_2</srcid><srcstatus/><internalId>1426</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_FC_Transmission_Pending_SF</srcid><srcstatus/><internalId>1483</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_FC_Transmission_Pending_FF</srcid><srcstatus/><internalId>1484</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_FC_Transmission_Pending_CF</srcid><srcstatus/><internalId>1485</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_FC_Transmission_Pending_SF_Smaller_NCS</srcid><srcstatus/><internalId>1499</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_FF_Reception_FF_Transmission</srcid><srcstatus/><internalId>1502</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_CF_Reception_FF_Transmission</srcid><srcstatus/><internalId>1503</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_ParallelChannels_FF_Reception</srcid><srcstatus/><internalId>1506</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_ParallelChannels_CF_Reception</srcid><srcstatus/><internalId>1507</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations><ruleid>WRN.swuts.needscoverage.count</ruleid></oreqmViolations><covstatus>covered</covstatus><internalId>175</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00269</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      After reception of each Consecutive Frame the CanTp module
      shall call the PduR_CanTpCopyRxData() function with a PduInfo
      pointer containing data buffer and data length:
      - 6 or 7 bytes or less in case of the last CF for CAN 2.0 frames
      - DLC-1 or DLC-2 bytes for CAN FD frames (see Figure 5 and SWS_CanTp_00351).
      The output pointer parameter provides CanTp with available Rx buffer size
      after data have been copied.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00269_1</srcid><srcstatus/><internalId>177</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00269_2</srcid><srcstatus/><internalId>178</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>176</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00269_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      After reception of each Consecutive Frame the CanTp shall call the
      PduR_CanTpCopyRxData() function with a PduInfo pointer containing data
      buffer and 6 or 7 data length (or less in case of the last CF) for CAN
      2.0 frames.
      The output pointer parameter provides CanTp with available Rx buffer
      size after data have been copied.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_SegExtRxMultBuf_1</srcid><srcstatus/><internalId>1256</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_CF_PduRInvalidReturn</srcid><srcstatus/><internalId>1359</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_RxCancel_2</srcid><srcstatus/><internalId>1424</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_ParallelChannels_CF_Reception</srcid><srcstatus/><internalId>1507</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_BurstOfCF_Reception</srcid><srcstatus/><internalId>1646</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00269</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>176</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>177</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00269_2</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      After reception of each Consecutive Frame the CanTp shall call the
      PduR_CanTpCopyRxData() function with a PduInfo pointer containing data
      buffer and DLC-1 or DLC-2 bytes for CAN FD frames.
      The output pointer parameter provides CanTp with available Rx buffer
      size after data have been copied.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.EB.Rx_CF_STANDARD_CanIdType</srcid><srcstatus/><internalId>685</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.Rx_CF_EXTENDED_CanIdType</srcid><srcstatus/><internalId>686</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.Rx_lastCF_STANDARD_CanIdType</srcid><srcstatus/><internalId>687</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.Rx_lastCF_EXTENDED_CanIdType</srcid><srcstatus/><internalId>688</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00269</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>176</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>178</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00312</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The CanTp module shall start a time-out N_Cr at each indication
      of CF reception (except the last one in a block) and at each
      confirmation of a FC transmission that initiate a CF transmission
      on the sender side (FC with FS=CTS).
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <!-- Covered by requirement CanTp.SWS_CanTp_00312_1 -->
        <!-- Covered by requirement CanTp.SWS_CanTp_00312_2 -->
        <!-- Covered by requirement CanTp.SWS_CanTp_00313 -->
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00312_1</srcid><srcstatus/><internalId>180</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00312_2</srcid><srcstatus/><internalId>181</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00313</srcid><srcstatus/><internalId>182</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>179</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00312_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The CanTp module shall start a time-out N_Cr at each indication
      of CF reception (except the last one in a block).
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_N_Cr_CFReception</srcid><srcstatus/><internalId>1348</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_N_Cr_LASTCF</srcid><srcstatus/><internalId>1351</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00312</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>179</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>180</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00312_2</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The CanTp module shall start a time-out N_Cr at each confirmation
      of a FC transmission that initiate a CF transmission on the sender
      side (FC with FS=CTS).
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30104</srcid><srcstatus/><internalId>1244</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_CF_Reception_Pending_FC_Transmission</srcid><srcstatus/><internalId>1497</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30448</srcid><srcstatus/><internalId>1668</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00312</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>179</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>181</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00313</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      In case of N_Cr timeout occurrence the CanTp module shall abort
      reception and notify the upper layer of this failure by calling
      the indication function PduR_CanTpRxIndication() with the result
      E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30104</srcid><srcstatus/><internalId>1244</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30448</srcid><srcstatus/><internalId>1668</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
           <linksto>CanTp.SWS_CanTp_00084</linksto>
           <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>187</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00312</linksto>
          <dstversion>1</dstversion>
       <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>179</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>182</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00271</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
        If the PduR_CanTpCopyRxData() returns BUFREQ_E_NOT_OK after
        reception of a Consecutive Frame in a block the CanTp shall
        abort the reception of N-SDU and notify the PduR module by
        calling the PduR_CanTpRxIndication() with the result E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00271_1</srcid><srcstatus/><internalId>184</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00271_2</srcid><srcstatus/><internalId>185</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>183</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00271_1</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
        If the PduR_CanTpCopyRxData() returns BUFREQ_E_NOT_OK after reception of
        a Consecutive Frame in a block the CanTp shall abort the reception of N-SDU.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30359</srcid><srcstatus/><internalId>1312</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00271</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>183</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.CopyRxData.BufferNotReserved.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>482</internalId></provcov>
      </providescoverage>
   <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>184</internalId></specobject>

   <specobject>
      <id>CanTp.SWS_CanTp_00271_2</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
        If the PduR_CanTpCopyRxData() returns BUFREQ_E_BUSY after reception of a
        Consecutive Frame in a block the CanTp shall abort the reception of N-SDU.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <!-- Covered by requirement CanTp.ASR40.RxNoBuffer_1 -->
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.ASR40.RxNoBuffer_1</srcid><srcstatus/><internalId>544</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00271</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>183</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00268</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>23</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>185</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00314</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The CanTp shall check the correctness of each SN received
      during a segmented reception. In case of wrong SN received
      the CanTp module shall abort reception and notify the upper
      layer of this failure by calling the indication function
      PduR_CanTpRxIndication() with the result E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30091</srcid><srcstatus/><internalId>1209</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
           <linksto>CanTp.SWS_CanTp_00084</linksto>
           <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>187</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>186</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00084</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      When the transport reception session is completed (successfully
      or not) the CanTp module shall call the upper layer notification
      service PduR_CanTpRxIndication().
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <!-- Covered by requirement CanTp.SWS_CanTp_00311 -->
        <!-- Covered by requirement CanTp.SWS_CanTp_00313 -->
        <!-- Covered by requirement CanTp.SWS_CanTp_00314 -->
        <!-- Covered by requirement CanTp.ASR40.CopyRxData.BufferNotReserved.1 -->
        <!-- Covered by requirement CanTp.ASR40.CopyRxData.BufferNotReserved.2b -->
        <!-- Covered by requirement CanTp.ASR40.CopyRxData.BufferNotReserved.3 -->
        <!-- Covered by requirement CanTp.ASR40.CancelReceive.RxIndication -->
        <!-- Covered by requirement CanTp.SWS_CanTp_00223_2 -->
        <!-- Covered by requirement CanTp.ASR40.RxNoBuffer -->
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00223_2</srcid><srcstatus/><internalId>173</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00311</srcid><srcstatus/><internalId>174</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00313</srcid><srcstatus/><internalId>182</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00314</srcid><srcstatus/><internalId>186</internalId></linkedfrom><linkedfrom><srcid>CanTp.ASR40.CopyRxData.BufferNotReserved.1</srcid><srcstatus/><internalId>482</internalId></linkedfrom><linkedfrom><srcid>CanTp.ASR40.CopyRxData.BufferNotReserved.2a</srcid><srcstatus/><internalId>483</internalId></linkedfrom><linkedfrom><srcid>CanTp.ASR40.CopyRxData.BufferNotReserved.2b</srcid><srcstatus/><internalId>484</internalId></linkedfrom><linkedfrom><srcid>CanTp.ASR40.CopyRxData.BufferNotReserved.3</srcid><srcstatus/><internalId>486</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>187</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00277</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      With regard to FF N-PDU reception, the content of the Flow
      Control N-PDU depends on the PduR_CanTpStartOfReception()
      service result.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <!-- Refined by CanTp.ASR40.SWS_CanTp_00318,1 and CanTp.ASR40.SWS_CanTp_00082,1 -->
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00318</srcid><srcstatus/><internalId>17</internalId></linkedfrom><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00082</srcid><srcstatus/><internalId>20</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>188</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00064</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Furthermore, it should be noted that when receiving a FF N-PDU,
      the Flow Control shall only be sent after having the result of
      the PduR_CanTpStartOfReception() service.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <!-- Covered by requirement CanTp.ASR40.SWS_CanTp_00318 -->
        <!-- Covered by requirement CanTp.SWS_CanTp_00081 -->
        <!-- Covered by requirement CanTp.ASR40.SWS_CanTp_00082 -->
        <!-- Covered by requirement CanTp.EB.StartofRx.InvalidReturn -->
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00318</srcid><srcstatus/><internalId>17</internalId></linkedfrom><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00082</srcid><srcstatus/><internalId>20</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00353</srcid><srcstatus/><internalId>165</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.StartofRx.InvalidReturn</srcid><srcstatus/><internalId>650</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>189</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00278</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      It is important to note that FC N-PDU will only be sent after
      every block, composed of a number BS (Block Size) of consecutive frames.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_ConfigBS</srcid><srcstatus/><internalId>1410</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_RX_InitialBS</srcid><srcstatus/><internalId>1416</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>190</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00067</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The CanTp shall use the same value for the BS and STmin parameters
      on each FC sent during a segmented reception. Different values of
      these parameters can be used on different N-SDUs reception.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00067_BS</srcid><srcstatus/><internalId>192</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00067_STmin</srcid><srcstatus/><internalId>193</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>191</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00067_BS</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The CanTp shall use the same value for the BS parameter on each FC sent
      during a segmented reception. Different values of these parameters can be
      used on different N-SDUs reception.
      </description>
      <comment>
        The BS shall be calculated before sending FC(CTS) as a response to the
        FF only and shall stay the same during the whole segmented reception.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_SegExtRxMultBuf_1</srcid><srcstatus/><internalId>1256</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_BS_Limited_1</srcid><srcstatus/><internalId>1405</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_ConfigBS</srcid><srcstatus/><internalId>1410</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_RX_InitialBS</srcid><srcstatus/><internalId>1416</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30415</srcid><srcstatus/><internalId>1659</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00067</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>191</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>192</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00067_STmin</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The CanTp shall use the same value for the STmin parameter on each FC sent
      during a segmented reception. Different values of these parameters can be
      used on different N-SDUs reception.
      </description>
      <comment>
      The only possibility to change the STmin value during runtime is the new
      API function CanTp_ChangeParameter(). This function may not be
      called for an Rx N-SDU during an ongoing reception (compare
      CanTp.SWS_CanTp_00303 and CanTp.SWS_CanTp_00304).
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_Conf07004_DenyChangeParameter</srcid><srcstatus/><internalId>1431</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00067</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>191</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>193</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00342</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      CanTp shall terminate the current reception connection when
      CanIf_Transmit() returns E_NOT_OK when transmitting an FC.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.EB.11310_2</srcid><srcstatus/><internalId>560</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>194</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00225</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      For specific connections that do not use MetaData, the function
      CanTp_Transmit shall only use the full SduLength information and
      shall not use the available N-SDU data buffer in order to prepare
      Single Frame or First Frame PCI.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30176</srcid><srcstatus/><internalId>1289</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>195</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00334</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      When CanTp_Transmit is called for an N-SDU with MetaData,
      the CanTp module shall store the addressing information contained
      in the MetaData of the N-SDU and use this information for transmission
      of SF, FF, and CF N-PDUs and for identification of FC N-PDUs.
      The addressing information in the MedataData depends on the addressing format:
      - Normal: none
      - Extended: N_TA
      - Mixed 11 bit: N_AE
      - Normal fixed: N_SA, N_TA
      - Mixed 29 bit: N_SA, N_TA, N_AE.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.MetaData.AddresingFormats</srcid><srcstatus/><internalId>982</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00334_1</srcid><srcstatus/><internalId>197</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>196</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00334_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      When CanTp_Transmit is called for an N-SDU with MetaData,
      the CanTp module shall store the addressing information contained
      in the MetaData of the N-SDU and use this information for transmission
      of SF, FF, and CF N-PDUs and for identification of FC N-PDUs when
      Normal fixed addressing format is used.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.EB.MetaData.CheckRxFcNTa</srcid><srcstatus/><internalId>789</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00334</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>196</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>197</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00335</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      When calling CanIf_Transmit() for an SF, FF, or CF of a generic
      connection (N-PDU with MetaData), the CanTp module shall provide
      the stored addressing information via MetaData of the N-PDU.
      The addressing information in the MetaData depends on the addressing format:
      - Normal, Extended, Mixed 11 bit: none
      - Normal fixed, Mixed 29 bit: N_SA, N_TA.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.MetaData.AddresingFormats</srcid><srcstatus/><internalId>982</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.EB.MetaData.GetTxNSa</srcid><srcstatus/><internalId>784</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>198</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00336</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      When CanTp_RxIndication is called for an FC on a generic connection
      (N-PDU with MetaData), the CanTp module shall check the addressing
      information contained in the MetaData against the stored values.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.EB.MetaData.CheckRxFcNSa</srcid><srcstatus/><internalId>788</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.MetaData.CheckRxFcNTa</srcid><srcstatus/><internalId>789</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>199</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00167</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      After a transmission request from upper layer, the CanTp
      module shall start time-out N_Cs before the call of PduR_CanTpCopyTxData.
      If no data is available before the timer elapsed, the CanTp module shall
      abort the communication.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00167_1</srcid><srcstatus/><internalId>201</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00167_2</srcid><srcstatus/><internalId>202</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>200</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00167_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      After a transmission request from upper layer, the CanTp
      module shall start time-out N_Cs before the call of PduR_CanTpCopyTxData.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30451</srcid><srcstatus/><internalId>1671</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00167</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>200</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>201</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00167_2</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If no data is available before the timer elapsed, the CanTp module shall
      abort the communication.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30156</srcid><srcstatus/><internalId>1248</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_N_Cs_SmallerBuffer</srcid><srcstatus/><internalId>1367</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_ReceptionInterrupts_SegmentedTransmission</srcid><srcstatus/><internalId>1640</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00167</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>200</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>202</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00086</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The CanTp module shall call the PduR_CanTpCopyTxData service
      for each segment that is sent (SF, FF and CF).
      The upper layer copy the transmit data on the PduInfoType structure.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30151</srcid><srcstatus/><internalId>1249</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30206</srcid><srcstatus/><internalId>1252</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30304</srcid><srcstatus/><internalId>1399</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30326</srcid><srcstatus/><internalId>1400</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_SF_Transmission_Pending_FC</srcid><srcstatus/><internalId>1477</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_FF_Transmission_Pending_FC</srcid><srcstatus/><internalId>1479</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_CF_Transmission_Pending_FC</srcid><srcstatus/><internalId>1481</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>203</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00272</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The API PduR_CanTpCopyTxData() contains a parameter used
      for the recovery mechanism – ‘retry’. Because ISO 15765-2 does
      not support such a mechanism, the CAN Transport Layer does not
      implement any kind of recovery. 
      Thus, the parameter is always set to NULL pointer.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_RequestNewTransmissionFromTxConfirmation_SF</srcid><srcstatus/><internalId>1180</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30048</srcid><srcstatus/><internalId>1193</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>204</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00087</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If PduR_CanTpCopyTxData() returns BUFREQ_E_NOT_OK, the CanTp
      module shall abort the transmit request and notify the upper
      layer of this failure by calling the callback function
      PduR_CanTpTxConfirmation() with the result E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30343</srcid><srcstatus/><internalId>1311</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>205</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00184</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If the PduR_CanTpCopyTxData() function returns BUFREQ_E_BUSY,
      the CanTp module shall later (implementation specific) retry
      to copy the data.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30156</srcid><srcstatus/><internalId>1248</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_N_Cs_SmallerBuffer</srcid><srcstatus/><internalId>1367</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>206</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00280</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If data is not available within N_Cs timeout the CanTp module
      shall notify the upper layer of this failure by calling the
      callback function PduR_CanTpTxConfirmation with the result E_NOT_OK.
      </description>
      <comment>
        Coverage is TEST only because CanTp.ASR40.SWS_CanTp_00185 already covers the aborted
        transmission in this case.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_40052</srcid><srcstatus/><internalId>1606</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_ReceptionInterrupts_SegmentedTransmission</srcid><srcstatus/><internalId>1640</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30451</srcid><srcstatus/><internalId>1671</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>207</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00089</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      When Tx data is available, the CanTp module shall resume the
      transmission of the N-SDU.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30151</srcid><srcstatus/><internalId>1249</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>208</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00310</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      In case of N_As timeout occurrence (no confirmation from CAN driver)
      the CanTp module shall notify the upper layer by calling the callback
      function PduR_CanTpTxConfirmation() with the result E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30077</srcid><srcstatus/><internalId>1237</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_TimeoutFF</srcid><srcstatus/><internalId>1238</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_SF_Transmission_Timeout_Pending_FC</srcid><srcstatus/><internalId>1478</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_FF_Transmission_Timeout_Pending_FC</srcid><srcstatus/><internalId>1480</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_CF_Transmission_Timeout_Pending_FC</srcid><srcstatus/><internalId>1482</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_Timeout_SF_Transmission_Nothing_Pending</srcid><srcstatus/><internalId>1501</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30449</srcid><srcstatus/><internalId>1669</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
           <linksto>CanTp.ASR40.SWS_CanTp_00075_1</linksto>
           <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>10</internalId></provcov>
        <provcov>
           <linksto>CanTp.ASR40.SWS_CanTp_00075_2</linksto>
           <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>11</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>209</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00309</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If a FC frame is received with the FS set to OVFLW the CanTp module
      shall abort the transmit request and notify the upper layer by calling
      the callback function PduR_CanTpTxConfirmation() with the result E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30141</srcid><srcstatus/><internalId>1226</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>210</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00317</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If a FC frame is received with an invalid FS the CanTp module
      shall abort the transmission of this message and notify the
      upper layer by calling the callback function PduR_CanTpTxConfirmation()
      with the result E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30092</srcid><srcstatus/><internalId>1220</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>211</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00315</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The CanTp module shall start a timeout observation for N_Bs time
      at confirmation of the FF transmission, last CF of a block transmission
      and at each indication of FC with FS=WT (i.e. time until reception of
      the next FC).
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00315_1</srcid><srcstatus/><internalId>213</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00315_2</srcid><srcstatus/><internalId>214</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00315_3</srcid><srcstatus/><internalId>215</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>212</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00315_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The CanTp module shall start a timeout observation for N_Bs time
      at confirmation of the FF transmission.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30100</srcid><srcstatus/><internalId>1239</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00315</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>212</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>213</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00315_2</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The CanTp module shall start a timeout observation for N_Bs time
      at confirmation of the last CF of a block transmission.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_N_Bs_LastCF</srcid><srcstatus/><internalId>1350</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00315</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>212</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>214</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00315_3</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The CanTp module shall start a timeout observation for N_Bs time at each
      indication of FC with FS=WT (i.e. time until reception of the next FC).
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_N_Bs_FCWAIT</srcid><srcstatus/><internalId>1349</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00315</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>212</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>215</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00316</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      In case of N_Bs timeout occurrence the CanTp module shall abort
      transmission of this message and notify the upper layer by calling
      the callback function PduR_CanTpTxConfirmation() with the result E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30100</srcid><srcstatus/><internalId>1239</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30450</srcid><srcstatus/><internalId>1670</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>216</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00090</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      When the transport transmission session is successfully completed,
      the CanTp module shall call a notification service of the upper layer,
      PduR_CanTpTxConfirmation(), with the result E_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30054</srcid><srcstatus/><internalId>1197</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30187</srcid><srcstatus/><internalId>1250</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_SF_Transmission_Pending_FC</srcid><srcstatus/><internalId>1477</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>217</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00343</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      CanTp shall terminate the current transmission connection when
      CanIf_Transmit() returns E_NOT_OK when transmitting an SF, FF, of CF.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanTp_TransmitFrame.c_133</srcid><srcstatus/><internalId>1050</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30268</srcid><srcstatus/><internalId>1245</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>218</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00091</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The CanTp module shall support optional primitives (proposed
      in ISO 15765-2 specification) for the dynamic setting of some transport
      protocol internal parameters (STmin and BS) by application.
      The BS value is only a maximum value. For reasons of buffer length, the CAN
      Transport Layer can adapt the BS value within the limit of the configured
      maximum value.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00091_1</srcid><srcstatus/><internalId>220</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00091_2</srcid><srcstatus/><internalId>221</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>219</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00091_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The CanTp module shall support optional primitives (proposed
      in ISO 15765-2 specification) for the dynamic setting of some transport
      protocol internal parameters (STmin and BS) by application.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <!-- Covered by CanTp.ASR40.SWS_CanTp_00302 -->
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00302</srcid><srcstatus/><internalId>54</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00091</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>219</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>220</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00091_2</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The BS value is only a maximum value. For reasons of buffer length, the CAN
      Transport Layer can adapt the BS value within the limit of the configured
      maximum value.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <!--
          Test cases:
          - Configured BS is used even if calculated BS is higher: TS_CANTP_ConfigBS
          - Calculated BS is used if smaller than configured BS: TS_CANTP_SegExtRxMultBuf_1
        -->
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_SegExtRxMultBuf_1</srcid><srcstatus/><internalId>1256</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_ConfigBS</srcid><srcstatus/><internalId>1410</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00091</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>219</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>221</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00092</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The CanTp module shall provide 1 to n communication (i.e. functional
      addressing [14]), in the form of functionality to SF N-PDUs (and only
      SF N-SDU).
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30066</srcid><srcstatus/><internalId>1251</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30113</srcid><srcstatus/><internalId>1259</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_Mixed_Functional_2</srcid><srcstatus/><internalId>1394</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>222</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00093</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If a multiple segmented session occurs (on both receiver and sender
      side) with a handle whose communication type is functional, the CanTp
      module shall reject the request and report the runtime error code
      CANTP_E_INVALID_TATYPE to the Default Error Tracer.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.Errors</srcid><srcstatus/><internalId>978</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00093</srcid><srcstatus/><internalId>27</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>223</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00035</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      A CAN NSduId shall only be linked to one CAN LSduId that is
      used to transmit SF, FF, FC and CF frames.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01003_Err_CanTpTxNPduRef_NotUnique_Standard</srcid><srcstatus/><internalId>1528</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>224</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00281</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      However, if the message is configured to use an extended or a
      mixed addressing format, the CanTp module must fill the first
      byte of each transmitted segment (SF, FF and CF) with the N_TA
      (in case of extended addressing) or N_AE (in case of mixed
      addressing) value.
      Therefore a CAN NSduId may also be related to a N_TA or N_AE value.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00281_ExtendedAdr</srcid><srcstatus/><internalId>226</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00281_MixedAdr</srcid><srcstatus/><internalId>227</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>225</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00281_ExtendedAdr</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      However, if the message is configured to use an extended addressing
      format, the CanTp module must fill the first byte of each transmitted
      segment (SF, FF and CF) with the N_TA value. Therefore a CAN NSduId may
      also be related to a N_TA value.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_RequestNewTransmissionFromTxConfirmation_MultiFrame</srcid><srcstatus/><internalId>1181</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30054</srcid><srcstatus/><internalId>1197</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30055</srcid><srcstatus/><internalId>1198</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30406</srcid><srcstatus/><internalId>1475</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30416</srcid><srcstatus/><internalId>1660</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30424</srcid><srcstatus/><internalId>1662</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30426</srcid><srcstatus/><internalId>1663</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30428</srcid><srcstatus/><internalId>1665</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00281</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>225</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>226</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00281_MixedAdr</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      However, if the message is configured to use a mixed addressing
      format, the CanTp module must fill the first byte of each transmitted
      segment (SF, FF and CF) with the N_AE value. Therefore a CAN NSduId may
      also be related to a N_AE value.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30414</srcid><srcstatus/><internalId>1658</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30418</srcid><srcstatus/><internalId>1661</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_SegRxMixedAdr</srcid><srcstatus/><internalId>1683</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_SegRxOvflwMixedAdr</srcid><srcstatus/><internalId>1684</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_SegRxWithWaitMixedAdr</srcid><srcstatus/><internalId>1685</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_SegTxMixedAdr</srcid><srcstatus/><internalId>1686</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00281</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>225</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>227</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00282</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      FC protocol data units give receivers the possibility of controlling
      senders’ data flow by authorizing or delaying transmission of
      subsequent CF N-PDUs.
      </description>
      <comment>
      This requirement is informational only.
      Rationale:
      This is just a general description. The necessary behavior of the protocol based
      on the FC frames is covered by other requirements (e.g. CanTp.ASR40.SWS_CanTp_00082).
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>228</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00283</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      For extended addressing format, the first data byte of the FC
      also contains the N_TA value or a unique combination of N_TA
      and N_TAtype value.
      For mixed addressing format, the first data byte of the FC
      contains the N_AE value.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00283_ExtendedAdr</srcid><srcstatus/><internalId>230</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00283_MixedAdr</srcid><srcstatus/><internalId>231</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>229</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00283_ExtendedAdr</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      For extended addressing format, the first data byte of the FC also
      contains the N_TA value or a unique combination of N_TA and N_TAtype value.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_SegExtRxMultBuf_1</srcid><srcstatus/><internalId>1256</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00283</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>229</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>230</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00283_MixedAdr</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      For mixed addressing format, the first data byte of the FC
      contains the N_AE value.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30418</srcid><srcstatus/><internalId>1661</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_SegRxMixedAdr</srcid><srcstatus/><internalId>1683</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_SegRxOvflwMixedAdr</srcid><srcstatus/><internalId>1684</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_SegRxWithWaitMixedAdr</srcid><srcstatus/><internalId>1685</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_SegTxMixedAdr</srcid><srcstatus/><internalId>1686</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00283</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>229</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>231</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00094</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Thus the CAN LSduId of a FC frame combined with its N_TA value
      (e.g. the N_AI) or with N_AE value shall only identify one CAN NSduId.
      </description>
      <comment>
      How to test:
      1)Check that it is not possible to configure two Tx NSduIds using FC frames with extended
      addressing format and with different RxFcNPduIds and same N_TA pointing to the
      same CanIf LSdu.
      2)Check that it is not possible to configure two Tx NSduIds using FC frames with extended
      addressing format and with same RxFcNPduIds and same N_TA pointing to the same CanIf LSdu.
      3)Check that it is not possible to configure two Tx NSduIds using FC frames with mixed
      addressing format and with different RxFcNPduIds and same N_AE pointing to the
      same CanIf LSdu.
      4)Check that it is not possible to configure two Tx NSduIds using FC frames with mixed
      addressing format and with same RxFcNPduIds and same N_AE pointing to the same CanIf LSdu.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <!-- Shall be tested with a generic test -->
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01004_Err_CanTpRxFcNPduId_Same_CanTpNAe_Same_Mixed</srcid><srcstatus/><internalId>1529</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_01005_Err_CanTpRxFcNPduId_Differ_CanTpNAe_Same_Mixed</srcid><srcstatus/><internalId>1530</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_01006_Err_CanTpRxFcNPduId_Same_CanTpNSa_Same_Extended</srcid><srcstatus/><internalId>1531</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_01007_Err_CanTpRxFcNPduId_Differ_CanTpNSa_Same_Extended</srcid><srcstatus/><internalId>1532</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_01008_Err_CanTpTxFcNPduRef_Same_CanTpNAe_Same_Mixed</srcid><srcstatus/><internalId>1533</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_01009_Err_CanTpTxFcNPduRef_Same_CanTpNTa_Same_Extended</srcid><srcstatus/><internalId>1534</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>232</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00284</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      In the reception direction, the first data byte value of each
      (SF, FF or CF) transport protocol data unit will be used to
      determine the relevant N-SDU.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00095_ExtendedAdr</srcid><srcstatus/><internalId>235</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00095_MixedAdr</srcid><srcstatus/><internalId>236</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>233</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00095</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Therefore, in extended addressing N-PDU reception, the CanTp
      module shall extract the N_TA value to establish the related N-SDU.
      The same process shall be applied for mixed addressing mode in relation
      with N_AE value.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00095_ExtendedAdr</srcid><srcstatus/><internalId>235</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00095_MixedAdr</srcid><srcstatus/><internalId>236</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>234</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00095_ExtendedAdr</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      In the reception direction, the first data byte value of each (SF, FF or CF)
      transport protocol data unit will be used to determine the relevant
      N-SDU.
      Therefore, in extended addressing N-PDU reception, the CanTp module shall
      extract the N_TA value from the first data byte value of each (SF, FF or CF)
      transport protocol data unit to establish the related N-SDU.
      </description>
      <comment>
      Reception of a frame (SF, FF or CF) with invalid N_TA shall be ignored.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30201</srcid><srcstatus/><internalId>1262</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30203</srcid><srcstatus/><internalId>1263</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30406</srcid><srcstatus/><internalId>1475</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00095</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>234</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00284</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>233</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>235</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00095_MixedAdr</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      In the reception direction, the first data byte value of each (SF, FF or CF)
      transport protocol data unit will be used to determine the relevant N-SDU.
      Therefore, in mixed addressing N-PDU reception, the CanTp module shall
      extract the N_AE value from the first data byte value of each (SF, FF or CF)
      transport protocol data unit to establish the related N-SDU.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30414</srcid><srcstatus/><internalId>1658</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30418</srcid><srcstatus/><internalId>1661</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_SegRxMixedAdr</srcid><srcstatus/><internalId>1683</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_SegRxOvflwMixedAdr</srcid><srcstatus/><internalId>1684</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_SegRxWithWaitMixedAdr</srcid><srcstatus/><internalId>1685</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_SegTxMixedAdr</srcid><srcstatus/><internalId>1686</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00095</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>234</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00284</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>233</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>236</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00096</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The CanTp module shall support several connections simultaneously.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30248</srcid><srcstatus/><internalId>1253</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30249</srcid><srcstatus/><internalId>1264</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>237</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00120</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      It shall be possible to configure concurrent connections in
      the CanTp module.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30248</srcid><srcstatus/><internalId>1253</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_CONCURRENT_RX</srcid><srcstatus/><internalId>1347</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30441</srcid><srcstatus/><internalId>1476</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>238</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00285</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The connection channels are only destined for CAN TP internal
      use, so they are not accessible externally.
      </description>
      <comment>
      This requirement is informational only.
      Rationale:
      External access shall only be possible via API and depends on the API requirements.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>239</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00286</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      All the necessary information (Channel number, Timing
      parameter …) is configured inside the CAN Transport Layer module.
      </description>
      <comment>
      This requirement is informational only.
      Rationale:
      This is a statement about the content of the configuration but no specific
      requirement.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>240</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00121</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Each N-SDU is statically linked to one connection channel.
      This connection channel represents an internal path, for the
      transmission or receiving of the N-SDU.
      A connection channel is attached to one or more N-SDU.
      </description>
      <comment>
      This requirement is informational only.
      Rationale:
      This requirement gives an overview of the configuration structure of the channels and
      their relation to the N-SDU.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>241</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00122</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Each connection channel is independent of the other connection channels.
      This means that a connection channel uses its own resources, such as
      internal buffer, timer, or state machine.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30248</srcid><srcstatus/><internalId>1253</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30249</srcid><srcstatus/><internalId>1264</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30401</srcid><srcstatus/><internalId>1409</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_40148</srcid><srcstatus/><internalId>1604</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>242</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00190</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The CanTp module shall route the N-SDU through the correctly
      configured connection channel.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_Check_ChannelIdx_Type</srcid><srcstatus/><internalId>1182</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30249</srcid><srcstatus/><internalId>1264</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30401</srcid><srcstatus/><internalId>1409</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>243</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00287</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The CanTp module shall not accept the receiving or the transmission
      of N-SDU with the same identifier in parallel, because otherwise the
      received frames cannot be assigned to the correct connection.
      When only specific connections (without MetaData) are used, this
      requirement is enforced by the configuration, because each N-SDU is
      linked to only one connection channel.
      </description>
      <comment>
      This requirement is not applicable.
      Rationale:
      An Rx and a Tx N-SDU that have the same ID (due to different namespaces for Tx and
      Rx) can be assigned to different channels (compare the configuration). Therefore it
      should also be possible to use them in parallel.
      As each N-SDU is assigned to a single channel it can furthermore not happen, that
      the same N-SDU is received/transmitted through different channels at the same time.
      Note: This behavior is an improvement.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>244</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00288</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If a connection channel is assigned to multiple N-SDUs, then
      resources are shared between different N-SDUs, and the CAN
      Transport Layer will reject transmission or abort receiving,
      if no free connection channels are available.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30245</srcid><srcstatus/><internalId>1247</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>245</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00289</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The number of connection channels is not directly configurable.
      It will be determined by the configuration tools during the
      configuration process, by analyzing the N-SDU/Channel routing table.
      </description>
      <comment>
      This requirement is informational only.
      Rationale:
      This requirement informs about the way the number of connection channels shall be
      calculated by the configuration tool.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>246</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00123</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If the configured transmit connection channel is in use (state
      CANTP_TX_PROCESSING), the CanTp module shall reject new transmission
      requests linked to this channel. To reject a transmission, CanTp returns
      E_NOT_OK when the upper layer asks for a transmission with the CanTp_Transmit()
      function.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30245</srcid><srcstatus/><internalId>1247</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>247</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00124</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      When an SF or FF N-PDU without MetaData is received, and the
      corresponding connection channel is currently receiving the same
      connection (state CANTP_RX_PROCESSING, same N_AI), the CanTp module
      shall abort the reception in progress and shall process the received
      frame as the start of a new reception.
      When an SF or FF N-PDU without MetaData is received for another
      connection (different N_AI) on an active connection channel, the SF
      or FF shall be ignored.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00124_Same_N_AI</srcid><srcstatus/><internalId>249</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00124_Diff_N_AI</srcid><srcstatus/><internalId>250</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>248</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00124_Same_N_AI</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      When an SF or FF is received, and the corresponding connection
      channel is currently receiving the same connection (state
      CANTP_RX_PROCESSING, same N_AI), the CanTp module shall abort the
      reception in progress and shall process the received frame as the
      start of a new reception.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30130</srcid><srcstatus/><internalId>1278</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_40040</srcid><srcstatus/><internalId>1599</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_40041</srcid><srcstatus/><internalId>1600</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00124</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>248</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>249</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00124_Diff_N_AI</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, V4.2.2</source>
      <version>1</version>
      <description>
      When an SF or FF is received for another connection (different N_AI)
      on an active connection channel, the SF or FF shall be ignored.
      </description>
      <releases>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_FullDuplex_Different_N_AI</srcid><srcstatus/><internalId>1622</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00124</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>248</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>250</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00337</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      When an SF or FF N-PDU with MetaData (indicating a generic
      connection) is received, and the corresponding connection
      channel is currently receiving, the SF or FF shall be ignored.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.Metadata.OngoingReception</srcid><srcstatus/><internalId>985</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>251</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00248</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      When a Tx N-PDU is used by two or more different connections
      on different channels, access to this N-PDU shall be serialized
      by using the TxConfirmation.
      An Rx N-PDU can only be used on two or more different connection
      channels if extended or mixed addressing is used in relation with
      this N-PDU or when it has MetaData (and thus belongs to a generic
      connection).
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.MetaData.AddresingFormats</srcid><srcstatus/><internalId>982</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00248_1</srcid><srcstatus/><internalId>31</internalId></linkedfrom><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00248_2</srcid><srcstatus/><internalId>32</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>252</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00116</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      In both padding and no padding modes, the CanTp module shall
      only transfer used data bytes to the upper layer.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00116_1</srcid><srcstatus/><internalId>254</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00116_2</srcid><srcstatus/><internalId>255</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00116_3</srcid><srcstatus/><internalId>256</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00116_4</srcid><srcstatus/><internalId>257</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>253</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00116_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If padding is enabled for a segmented transfer the CanTp module
      shall only transfer used data bytes to the upper layer.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30481</srcid><srcstatus/><internalId>1679</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00116</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>253</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>254</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00116_2</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If padding is enabled for an unsegmented transfer the CanTp
      module shall only transfer used data bytes to the upper layer.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30190</srcid><srcstatus/><internalId>1286</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00116</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>253</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>255</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00116_3</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If padding is disabled for a segmented transfer the CanTp module
      shall only transfer used data bytes to the upper layer.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30085</srcid><srcstatus/><internalId>1208</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30480</srcid><srcstatus/><internalId>1678</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00116</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>253</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>256</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00116_4</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If padding is disabled for a segmented transfer the CanTp module
      shall only transfer used data bytes to the upper layer.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30189</srcid><srcstatus/><internalId>1260</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00116</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>253</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>257</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00059</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The value used for padding bytes is configurable via configuration
      parameter CANTP_PADDING_BYTE (see ECUC_CanTp_00298).
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <!-- Requires multiple tests with multiple configurations -->
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00059_1</srcid><srcstatus/><internalId>259</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00059_2</srcid><srcstatus/><internalId>260</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>258</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00059_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The value used for padding bytes for CAN 2.0 frames is configurable
      via configuration parameter CANTP_PADDING_BYTE (see ECUC_CanTp_00298).
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <!-- Requires multiple tests with multiple configurations -->
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30188</srcid><srcstatus/><internalId>1284</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_PAD_FC_OVFLW</srcid><srcstatus/><internalId>1340</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_PAD_FC_CTS</srcid><srcstatus/><internalId>1341</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_PAD_FC_WAIT</srcid><srcstatus/><internalId>1342</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_PAD_CF</srcid><srcstatus/><internalId>1343</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30454</srcid><srcstatus/><internalId>1674</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00059</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>258</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>259</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00059_2</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The value used for padding bytes for CAN-FD is configurable via configuration
      parameter CANTP_PADDING_BYTE_CANFD (see CanTp.EB.CanTpPaddingByteCanFD_Conf).
      If parameter not configured, CanTp shall use CANTP_PADDING_BYTE (see CanTp.ECUC_CanTp_00298).
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <!-- Requires multiple tests with multiple configurations -->
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest10_005_CANFD_SF_lastCF_CANFD_PADDING_VALUE</srcid><srcstatus/><internalId>1163</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00059</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>258</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>260</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00344</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If frames with a payload &lt;= 8 (either CAN 2.0 frames or small
      CAN FD frames) are used for a Rx N-SDU and CanTpRxPaddingActivation
      is equal to CANTP_ON, then CanTp shall only accept SF Rx N-PDUs or
      last CF Rx N-PDUs, belonging to that N-SDU, with a length of eight
      bytes (i.e. PduInfoPtr.SduLength = 8).
      </description>
      <comment>
      The requirement is tested in case CanTpFlexibleDataRateSupport == false
      by older tests (e.g. CanTp.EB.Rx.Padding.InvalidRxLength).
      </comment>
      <verifycrit>
        Precondition:
        * CanTpFlexibleDataRateSupport = {true, false}
        * Addressing = {standard, extended, mixed}
        * Frame type: SF, last CF
        Result:
        Data are correctly passed to PduR.
      </verifycrit>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest09001_CAN_FD_SWS_CanTp_00344_00345_00346</srcid><srcstatus/><internalId>1157</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00344.CANTP_ON_CAN_CAN_FD.CAN-FD_frames</srcid><srcstatus/><internalId>262</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00344.CANTP_ON_CAN_CAN_FD.CAN2.0_frames</srcid><srcstatus/><internalId>263</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.Rx.Padding.InvalidRxLength</srcid><srcstatus/><internalId>627</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>261</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00344.CANTP_ON_CAN_CAN_FD.CAN-FD_frames</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If frames with a payload &lt;= 64 (CAN-FD frames) are used for a Rx N-SDU and
      CanTpRxPaddingActivation is equal to CANTP_ON_CAN_CAN_FD, then CanTp shall
      only accept SF Rx N-PDUs or last CF Rx N-PDUs, belonging to that N-SDU, with
      a length of 64 bytes (i.e. PduInfoPtr.SduLength = 64).
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.EB.Rx.Padding.CANTP_ON_CAN_CAN_FD.InvalidRxLength.CAN-FD_frame</srcid><srcstatus/><internalId>628</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest12_006_InvalidRxLength_CANTP_ON_CAN_CAN_FD_CANFD_frames</srcid><srcstatus/><internalId>1173</internalId></linkedfrom><linkedfrom><srcid>CanTp_ConTest12_008_InvalidRxLength_LastCF_frame</srcid><srcstatus/><internalId>1175</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00344</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>261</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>262</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00344.CANTP_ON_CAN_CAN_FD.CAN2.0_frames</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If frames with a payload = 8 (CAN 2.0 frames) are used for a Rx N-SDU and
      CanTpRxPaddingActivation is equal to CANTP_ON_CAN_CAN_FD, then CanTp shall
      only accept SF Rx N-PDUs or last CF Rx N-PDUs, belonging to that N-SDU, with
      a length of eight bytes (i.e. PduInfoPtr.SduLength = 8).
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.EB.Rx.Padding.CANTP_ON_CAN_CAN_FD.InvalidRxLength.CAN2.0_frame</srcid><srcstatus/><internalId>629</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest12_007_InvalidRxLength_CANTP_ON_CAN_CAN_FD_CAN20_frames</srcid><srcstatus/><internalId>1174</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00344</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>261</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>263</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00345</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If frames with a payload &lt;= 8 (either CAN 2.0 frames or
      small CAN FD frames) are used for a Rx N-SDU and CanTpRxPaddingActivation
      is equal to CANTP_ON, then CanTp receives by means of CanTp_RxIndication()
      call an SF Rx N-PDU belonging to that N-SDU, with a length smaller than
      eight bytes (i.e. PduInfoPtr.SduLength &lt; 8), CanTp shall reject the reception.
      The runtime error code CANTP_E_PADDING shall be reported to the Default Error Tracer.
      </description>
      <comment>
      * CANTP_E_INVALID_RX_LENGTH is reported.
      * The requirement is tested in case CanTpFlexibleDataRateSupport == false by older
        tests (e.g. CanTp.EB.Rx.Padding.InvalidRxLength).
      </comment>
      <verifycrit>
      Precondition:
      * CanTpFlexibleDataRateSupport = {true, false}
      * N-SDU length = {0, 1, 2, 3, 4, 5, 6, 7}
      </verifycrit>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.Errors</srcid><srcstatus/><internalId>978</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00345.CANTP_ON_CAN_CAN_FD.CAN-FD_frames</srcid><srcstatus/><internalId>265</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00345.CANTP_ON_CAN_CAN_FD.CAN2.0_frames</srcid><srcstatus/><internalId>266</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.Rx.Padding.InvalidRxLength</srcid><srcstatus/><internalId>627</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest09001_CAN_FD_SWS_CanTp_00344_00345_00346</srcid><srcstatus/><internalId>1157</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>264</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00345.CANTP_ON_CAN_CAN_FD.CAN-FD_frames</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If frames with a payload &lt;= 64 (CAN-FD frames) are used for a Rx N-SDU and
      CanTpRxPaddingActivation is equal to CANTP_ON_CAN_CAN_FD, then CanTp receives by
      means of CanTp_RxIndication() call an SF Rx N-PDU belonging to that N-SDU,
      with a length smaller than 64 bytes (i.e. PduInfoPtr.SduLength = 64), CanTp
      shall reject the reception. If the development error detection is enabled, a
      development error CANTP_E_PADDING shall be triggered.
      </description>
      <comment>
      * The CANTP_E_INVALID_RX_LENGTH development error is reported instead of
        CANTP_E_PADDING runtime error.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.EB.Rx.Padding.CANTP_ON_CAN_CAN_FD.InvalidRxLength.CAN-FD_frame</srcid><srcstatus/><internalId>628</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest12_006_InvalidRxLength_CANTP_ON_CAN_CAN_FD_CANFD_frames</srcid><srcstatus/><internalId>1173</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00345</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>264</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>265</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00345.CANTP_ON_CAN_CAN_FD.CAN2.0_frames</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If frames with a payload = 8 (CAN 2.0 frames) are used for a Rx N-SDU and
      CanTpRxPaddingActivation is equal to CANTP_ON_CAN_CAN_FD, then CanTp receives by
      means of CanTp_RxIndication() call an SF Rx N-PDU belonging to that N-SDU,
      with a length smaller than eight bytes (i.e. PduInfoPtr.SduLength = 8), CanTp
      shall reject the reception. If the development error detection is enabled, a
      development error CANTP_E_PADDING shall be triggered.
      </description>
      <comment>
      * The CANTP_E_INVALID_RX_LENGTH development error is reported instead of
        CANTP_E_PADDING runtime error.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.EB.Rx.Padding.CANTP_ON_CAN_CAN_FD.InvalidRxLength.CAN2.0_frame</srcid><srcstatus/><internalId>629</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest12_007_InvalidRxLength_CANTP_ON_CAN_CAN_FD_CAN20_frames</srcid><srcstatus/><internalId>1174</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00345</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>264</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>266</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00346</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If frames with a payload &lt;= 8 (either CAN 2.0 frames or small
      CAN FD frames) are used for a Rx N-SDU and CanTpRxPaddingActivation
      is equal to CANTP_ON, and CanTp receives by means of CanTp_RxIndication()
      call a last CF Rx N-PDU belonging to that N-SDU, with a length smaller
      than eight bytes (i.e. PduInfoPtr. SduLength != 8), CanTp shall abort
      the ongoing reception by calling PduR_CanTpRxIndication() with the result
      E_NOT_OK.
      The runtime error code CANTP_E_PADDING shall be reported to the Default
      Error Tracer.
      </description>
      <comment>
      * The CANTP_E_INVALID_RX_LENGTH development error is reported instead of
        CANTP_E_PADDING runtime error.
      * The requirement is tested in case CanTpFlexibleDataRateSupport == false by older tests
        (e.g. CanTp.EB.Rx.Padding.InvalidRxLength).
      </comment>
      <verifycrit>
      Precondition:
      * CanTpFlexibleDataRateSupport = {true, false}
      * N-SDU length = {0, 1, 2, 3, 4, 5, 6, 7}
      </verifycrit>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.Errors</srcid><srcstatus/><internalId>978</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00346.CANTP_ON_CAN_CAN_FD.CAN-FD_frames</srcid><srcstatus/><internalId>268</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00346.CANTP_ON_CAN_CAN_FD.CAN2.0_frames</srcid><srcstatus/><internalId>269</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.Rx.Padding.InvalidRxLength</srcid><srcstatus/><internalId>627</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest09001_CAN_FD_SWS_CanTp_00344_00345_00346</srcid><srcstatus/><internalId>1157</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>267</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00346.CANTP_ON_CAN_CAN_FD.CAN-FD_frames</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If frames with a payload &lt;= 64 (CAN FD frames) are used for a Rx N-SDU and
      CanTpRxPaddingActivation is equal to CANTP_ON_CAN_CAN_FD, and CanTp receives by
      means of CanTp_RxIndication() call a last CF Rx N-PDU belonging to that N-
      SDU, with a length smaller than 64 bytes (i.e. PduInfoPtr. SduLength != 64),
      CanTp shall abort the ongoing reception by calling PduR_CanTpRxIndication()
      with the result E_NOT_OK. If the development error detection is enabled, a
      development error CANTP_E_PADDING shall be triggered.
      </description>
      <comment>
      * The CANTP_E_INVALID_RX_LENGTH development error is reported instead of
          CANTP_E_PADDING runtime error.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.EB.Rx.Padding.CANTP_ON_CAN_CAN_FD.InvalidRxLength.CAN-FD_frame</srcid><srcstatus/><internalId>628</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest12_006_InvalidRxLength_CANTP_ON_CAN_CAN_FD_CANFD_frames</srcid><srcstatus/><internalId>1173</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00346</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>267</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>268</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00346.CANTP_ON_CAN_CAN_FD.CAN2.0_frames</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If frames with a payload = 8 (CAN 2.0 frames) are used for a Rx N-SDU and
      CanTpRxPaddingActivation is equal to CANTP_ON_CAN_CAN_FD, and CanTp receives by
      means of CanTp_RxIndication() call a last CF Rx N-PDU belonging to that N-
      SDU, with a length smaller than eight bytes (i.e. PduInfoPtr. SduLength != 8),
      CanTp shall abort the ongoing reception by calling PduR_CanTpRxIndication()
      with the result E_NOT_OK. If the development error detection is enabled, a
      development error CANTP_E_PADDING shall be triggered.
      </description>
      <comment>
      * The CANTP_E_INVALID_RX_LENGTH development error is reported instead of
        CANTP_E_PADDING runtime error.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.EB.Rx.Padding.CANTP_ON_CAN_CAN_FD.InvalidRxLength.CAN2.0_frame</srcid><srcstatus/><internalId>629</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest12_007_InvalidRxLength_CANTP_ON_CAN_CAN_FD_CAN20_frames</srcid><srcstatus/><internalId>1174</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00346</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>267</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>269</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00347</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If CanTpRxPaddingActivation is equal to CANTP_ON for an Rx N-SDU,
      the CanTp module shall transmit FC N-PDUs with a length of eight
      bytes.
      Unused bytes in N-PDU shall be updated with CANTP_PADDING_BYTE (see
      CanTp.ECUC_CanTp_00298).
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00347_CAN2.0</srcid><srcstatus/><internalId>271</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00347_CANFD</srcid><srcstatus/><internalId>272</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00347.CANTP_ON_CAN_CAN_FD.CAN20_frames</srcid><srcstatus/><internalId>273</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00347.CANTP_ON_CAN_CAN_FD.CANFD_frames</srcid><srcstatus/><internalId>274</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>270</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00347_CAN2.0</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If CanTpRxPaddingActivation is equal to CANTP_ON for a Rx N-SDU, the CanTp
      module shall transmit FC N-PDUs with a length of eight bytes. Unused bytes
      in the FC N-PDU shall be updated with CANTP_PADDING_BYTE for CAN 2.0 messages.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest10_002_CAN20_and_CANFD_Rx_FF_Format_Standard_Addr</srcid><srcstatus/><internalId>1164</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00347</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>270</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>271</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00347_CANFD</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If CanTpRxPaddingActivation is equal to CANTP_ON for a Rx N-SDU, the CanTp
      module shall transmit FC N-PDUs with a length of eight bytes. For CAN-FD messages,
      unused bytes in the FC N-PDU shall be updated with CANTP_PADDING_BYTE_CANFD if
      configured; otherwise CanTp shall use CANTP_PADDING_BYTE.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest10_002_CAN20_and_CANFD_Rx_FF_Format_Standard_Addr</srcid><srcstatus/><internalId>1164</internalId></linkedfrom><linkedfrom><srcid>CanTp_ConTest10_003_BigData_Rx_FF_Format_Mixed_Addr</srcid><srcstatus/><internalId>1165</internalId></linkedfrom><linkedfrom><srcid>CanTp_ConTest12_009_FC_CANFD_8bytes_PADDING_CANTP_ON</srcid><srcstatus/><internalId>1176</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00347</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>270</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>272</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00347.CANTP_ON_CAN_CAN_FD.CAN20_frames</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If CanTpRxPaddingActivation is equal to CANTP_ON_CAN_CAN_FD for a Rx N-SDU,
      the CanTp module shall transmit FC N-PDUs with a length of 8 bytes, for
      CAN 2.0 frames.
      Unused bytes in the FC N-PDU shall be updated with CANTP_PADDING_BYTE.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest12_001_Rx_FF_CAN20_CANTP_ON_CAN_CAN_FD</srcid><srcstatus/><internalId>1168</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00347</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>270</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>273</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00347.CANTP_ON_CAN_CAN_FD.CANFD_frames</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If CanTpRxPaddingActivation is equal to CANTP_ON_CAN_CAN_FD for a Rx N-SDU,
      the CanTp module shall transmit FC N-PDUs with a length of 64 bytes for
      CAN-FD frames.
      Unused bytes in the FC N-PDU shall be updated with CANTP_PADDING_BYTE_CANFD
      if configured; otherwise CanTp shall use CANTP_PADDING_BYTE.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest12_005_Rx_FF_CANFD_CANTP_ON_CAN_CAN_FD</srcid><srcstatus/><internalId>1172</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00347</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>270</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>274</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00348</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If frames with a payload &lt;= 8 (either CAN 2.0 frames or small
      CAN FD frames) are used for a Tx N-SDU and if CanTpTxPaddingActivation
      is equal to CANTP_ON, CanTp shall transmit by means of CanIf_Transmit()
      call, SF Tx N-PDU or last CF Tx N-PDU that belongs to that Tx N-SDU
      with the length of eight bytes(i.e. PduInfoPtr.SduLength = 8).
      Unused bytes in N-PDU shall be updated with CANTP_PADDING_BYTE (see
      CanTp.ECUC_CanTp_00298).
      </description>
      <comment>
      'Rx' does not make sense in this requirement. 'Tx' is meant here.
      </comment>
      <verifycrit>
        Precondition:
        * CanTpFlexibleDataRateSupport = {true, false}
        * Addressing = {standard, extended, mixed}
        * Frame type: SF, last CF
        Result:
        Data are correctly passed to CanIf.
      </verifycrit>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00348_1</srcid><srcstatus/><internalId>276</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00348_2</srcid><srcstatus/><internalId>277</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00348.CANTP_ON_CAN_CAN_FD.CAN-FD_frames</srcid><srcstatus/><internalId>278</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00348.CANTP_ON_CAN_CAN_FD.CAN2.0_frames</srcid><srcstatus/><internalId>279</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>275</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00348_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If frames with a payload = 8, CAN 2.0 frames are used for a Tx N-SDU
      and if CanTpTxPaddingActivation is equal to CANTP_ON, CanTp shall transmit by
      means of CanIf_Transmit() call, SF Rx N-PDU or last CF Rx N-PDU that
      belongs to that Tx N-SDU with the length of eight bytes(i.e.
      PduInfoPtr.SduLength = 8). Unused bytes in N-PDU shall be updated with
      CANTP_PADDING_BYTE (see ECUC_CanTp_00298).
      </description>
      <comment>
      'Rx' does not make sense in this requirement. 'Tx' is meant here.
      </comment>
      <verifycrit>
      Precondition:
      * CanTpFlexibleDataRateSupport = {true, false}
      * Addressing = {standard, extended, mixed}
      * Frame type: SF, last CF
      Result:
      Data are correctly passed to CanIf.
      </verifycrit>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest10_004_NO_CANFD_SF_lastCF_CLASSIC_PADDING_VALUE</srcid><srcstatus/><internalId>1162</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00348</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>275</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>276</internalId></specobject>

    <specobject>
       <id>CanTp.SWS_CanTp_00348_2</id>
       <status>approved</status>
       <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
       <version>1</version>
       <description>
      If frames with a payload = 8, small CAN FD frames are used for a Tx N-SDU and if
      CanTpTxPaddingActivation is equal to CANTP_ON, CanTp shall transmit by
      means of CanIf_Transmit() call, SF Rx N-PDU or last CF Rx N-PDU that
      belongs to that Tx N-SDU with the length of eight bytes(i.e.
      PduInfoPtr.SduLength = 8). Unused bytes in N-PDU shall be updated with
      CANTP_PADDING_BYTE_CANFD (see CanTp.EB.CanTpPaddingByteCanFD_Conf) if configured,
      otherwise it shall use CANTP_PADDING_BYTE (see CanTp.ECUC_CanTp_00298).
    </description>
       <comment>
      'Rx' does not make sense in this requirement. 'Tx' is meant here.
    </comment>
       <verifycrit>
      Precondition:
      * CanTpFlexibleDataRateSupport = {true, false}
      * Addressing = {standard, extended, mixed}
      * Frame type: SF, last CF
      Result:
      Data are correctly passed to CanIf.
    </verifycrit>
       <releases>
          <release>AUTOSAR R20-11</release>
       </releases>
       <needscoverage>
          <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest09002_CAN_FD_SWS_CanTp_00348</srcid><srcstatus/><internalId>1146</internalId></linkedfrom><linkedfrom><srcid>CanTp_ConTest10_005_CANFD_SF_lastCF_CANFD_PADDING_VALUE</srcid><srcstatus/><internalId>1163</internalId></linkedfrom><linkedfrom><srcid>CanTp_ConTest12_010_lastCF_CANFD_8bytes_PADDING_CANTP_ON</srcid><srcstatus/><internalId>1177</internalId></linkedfrom></coveredby></needscov>
       <containerCovstatus>covered</containerCovstatus></needscoverage>
       <providescoverage>
          <provcov>
             <linksto>CanTp.SWS_CanTp_00348</linksto>
             <dstversion>1</dstversion>
          <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>275</internalId></provcov>
       </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>277</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00348.CANTP_ON_CAN_CAN_FD.CAN-FD_frames</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If frames with a payload &lt;= 64 (CAN-FD frames) are used for a Tx N-SDU and if
      CanTpTxPaddingActivation is equal to CANTP_ON_CAN_CAN_FD, CanTp shall transmit by
      means of CanIf_Transmit() call, SF Rx N-PDU or last CF Rx N-PDU that
      belongs to that Tx N-SDU with the length of 64 bytes(i.e.
      PduInfoPtr.SduLength = 64). Unused bytes in N-PDU shall be updated with
      CANTP_PADDING_BYTE_CANFD (see CanTp.EB.CanTpPaddingByteCanFD_Conf) if configured,
      otherwise it shall use CANTP_PADDING_BYTE (see ECUC_CanTp_00298).
      </description>
      <comment>
      'Rx' does not make sense in this requirement. 'Tx' is meant here.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest12_003_Tx_SF_CANFD_CANTP_ON_CAN_CAN_FD</srcid><srcstatus/><internalId>1170</internalId></linkedfrom><linkedfrom><srcid>CanTp_ConTest12_004_Tx_FF_RxFC_lastCF_CAN20_CANFD_CANTP_ON_CAN_CAN_FD</srcid><srcstatus/><internalId>1171</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
          <provcov>
             <linksto>CanTp.SWS_CanTp_00348</linksto>
             <dstversion>1</dstversion>
          <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>275</internalId></provcov>
       </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>278</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00348.CANTP_ON_CAN_CAN_FD.CAN2.0_frames</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If frames with a payload = 8 (CAN 2.0 frames) are used for a Tx N-SDU
      and if CanTpTxPaddingActivation is equal to CANTP_ON_CAN_CAN_FD, CanTp shall transmit by
      means of CanIf_Transmit() call, SF Rx N-PDU or last CF Rx N-PDU that
      belongs to that Tx N-SDU with the length of eight bytes(i.e.
      PduInfoPtr.SduLength = 8). Unused bytes in N-PDU shall be updated with
      CANTP_PADDING_BYTE (see ECUC_CanTp_00298).
      </description>
      <comment>
      'Rx' does not make sense in this requirement. 'Tx' is meant here.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest12_002_Tx_SF_CAN20_CANTP_ON_CAN_CAN_FD</srcid><srcstatus/><internalId>1169</internalId></linkedfrom><linkedfrom><srcid>CanTp_ConTest12_004_Tx_FF_RxFC_lastCF_CAN20_CANFD_CANTP_ON_CAN_CAN_FD</srcid><srcstatus/><internalId>1171</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
          <provcov>
             <linksto>CanTp.SWS_CanTp_00348</linksto>
             <dstversion>1</dstversion>
          <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>275</internalId></provcov>
       </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>279</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00349</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If CanTpTxPaddingActivation is equal to CANTP_ON for a Tx N-SDU,
      and if a FC N-PDU is received for that Tx N-SDU on a ongoing
      transmission, by means of CanTp_RxIndication() call, and the
      length of this FC is smaller than eight bytes (i.e. PduInfoPtr.SduLength &lt;8)
      the CanTp module shall abort the transmission session by calling
      PduR_CanTpTxConfirmation() with the result E_NOT_OK.
      The runtime error code CANTP_E_PADDING shall be reported to
      the Default Error Tracer.
      </description>
      <comment>
      * The CANTP_E_INVALID_RX_LENGTH development error is reported instead of
        CANTP_E_PADDING runtime error.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.Errors</srcid><srcstatus/><internalId>978</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00349.CANTP_ON.Receiving.CAN20_RxFC.AcceptedLength</srcid><srcstatus/><internalId>281</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00349.CANTP_ON_CAN_CAN_FD.Receiving.CAN20_RxFC.AcceptedLength</srcid><srcstatus/><internalId>282</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00349.CANTP_ON.Receiving.CANFD.RxFC.AcceptedLengths</srcid><srcstatus/><internalId>283</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00349.CANTP_ON_CAN_CAN_FD.Receiving.CANFD_RxFC.AcceptedLength</srcid><srcstatus/><internalId>284</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>280</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00349.CANTP_ON.Receiving.CAN20_RxFC.AcceptedLength</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If frames with a payload &lt;= 8 (CAN 2.0 frames) are used for a Tx N-SDU and if
      CanTpTxPaddingActivation is equal to CANTP_ON, CanTp shall accept by means of
      CanIf_RxIndication() call, only CAN 2.0 FC N-PDU that belongs to that Tx N-SDU
      with length equal to 8 bytes.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_ConTest16_001_CAN20_FC_Lengths_NoPadding_NormalPadding_CanFDPadding</srcid><srcstatus/><internalId>1183</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00349</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>280</internalId></provcov>
       </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>281</internalId></specobject>
    
    <specobject>
      <id>CanTp.SWS_CanTp_00349.CANTP_ON_CAN_CAN_FD.Receiving.CAN20_RxFC.AcceptedLength</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If frames with a payload &lt;= 8 (CAN 2.0 frames) are used for a Tx N-SDU and if
      CanTpTxPaddingActivation is equal to CANTP_ON_CAN_CAN_FD, CanTp shall accept by
      means of CanIf_RxIndication() call, only CAN 2.0 FC N-PDU that belongs to that Tx
      N-SDU with length equal to 8 bytes.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_ConTest16_001_CAN20_FC_Lengths_NoPadding_NormalPadding_CanFDPadding</srcid><srcstatus/><internalId>1183</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00349</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>280</internalId></provcov>
       </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>282</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00349.CANTP_ON.Receiving.CANFD.RxFC.AcceptedLengths</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If frames with a payload &gt; 8 (CAN FD frames) are used for a Tx N-SDU and
      if CanTpTxPaddingActivation is equal to CANTP_ON, CanTp shall accept by means
      of CanIf_RxIndication() call, only CAN-FD FC N-PDU that belongs to that Tx N-SDU
      with the length equal with PduLength configured in EcuC (12,16,24,32,48,64).
      (i.e. PduLength = 12 =&gt; accepted PduInfoPtr.SduLength = 12
            PduLength = 16 =&gt; accepted PduInfoPtr.SduLength = 16
            PduLength = 24 =&gt; accepted PduInfoPtr.SduLength = 24
            PduLength = 32 =&gt; accepted PduInfoPtr.SduLength = 32
            PduLength = 48 =&gt; accepted PduInfoPtr.SduLength = 48
            PduLength = 64 =&gt; accepted PduInfoPtr.SduLength = 64)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_ConTest16_002_CANFD_FC_Lengths_NoPadding_NormalPadding_CanFDPadding</srcid><srcstatus/><internalId>1184</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00349</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>280</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>283</internalId></specobject>


    <specobject>
      <id>CanTp.SWS_CanTp_00349.CANTP_ON_CAN_CAN_FD.Receiving.CANFD_RxFC.AcceptedLength</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If frames with a payload &gt;= 8 (CAN FD frames) are used for a Tx N-SDU and if
      CanTpTxPaddingActivation is equal to CANTP_ON_CAN_CAN_FD, CanTp shall accept by
      means of CanIf_RxIndication() call, only CAN FD FC N-PDU that belongs to that Tx N-SDU
      with length equal to 64 bytes.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_ConTest16_002_CANFD_FC_Lengths_NoPadding_NormalPadding_CanFDPadding</srcid><srcstatus/><internalId>1184</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00349</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>280</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>284</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00351</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If the data length which shall be transmitted via CanIf_Transmit()
      does not match possible DLC values (0..8, 12, 16, 20, 24, 32, 48,
      or 64), CanTp shall use the next higher valid DLC for transmission with
      initialization of unused bytes to the value of CANTP_PADDING_BYTE (see
      CanTp.ECUC_CanTp_00298).
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00040</srcid><srcstatus/><internalId>33</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00351.CANTP_ON_CAN_CAN_FD.CAN_20</srcid><srcstatus/><internalId>286</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00351.CANTP_ON_CAN_CAN_FD.CAN_FD</srcid><srcstatus/><internalId>287</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest09003_CAN_FD_ON_8_BYTES_SWS_CanTp_00351</srcid><srcstatus/><internalId>1147</internalId></linkedfrom><linkedfrom><srcid>CanTp_ConTest09004_CAN_FD_ON_SWS_CanTp_00351</srcid><srcstatus/><internalId>1148</internalId></linkedfrom><linkedfrom><srcid>CanTp_ConTest10_001_CANFD_SF_CANFD_PADDING_VALUE</srcid><srcstatus/><internalId>1161</internalId></linkedfrom><linkedfrom><srcid>CanTp_ConTest10_004_NO_CANFD_SF_lastCF_CLASSIC_PADDING_VALUE</srcid><srcstatus/><internalId>1162</internalId></linkedfrom><linkedfrom><srcid>CanTp_ConTest10_005_CANFD_SF_lastCF_CANFD_PADDING_VALUE</srcid><srcstatus/><internalId>1163</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_ConTest16_001_CAN20_FC_Lengths_NoPadding_NormalPadding_CanFDPadding</srcid><srcstatus/><internalId>1183</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_ConTest16_002_CANFD_FC_Lengths_NoPadding_NormalPadding_CanFDPadding</srcid><srcstatus/><internalId>1184</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>285</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00351.CANTP_ON_CAN_CAN_FD.CAN_20</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If padding activation is equal to CANTP_ON_CAN_CAN_FD and data
      length which shall be transmitted  via CanIf_Transmit() does not
      match 8 bytes for CAN 2.0 frames, CanTp shall initialize unused
      bytes to the value of CANTP_PADDING_BYTE for CAN 2.0 frames.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest12_001_Rx_FF_CAN20_CANTP_ON_CAN_CAN_FD</srcid><srcstatus/><internalId>1168</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00351</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>285</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>286</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00351.CANTP_ON_CAN_CAN_FD.CAN_FD</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If padding activation is equal to CANTP_ON_CAN_CAN_FD and data length
      which shall be transmitted via CanIf_Transmit() does not match 64 bytes
      for CAN-FD frames, CanTp shall initialize unused bytes to the value of
      CANTP_PADDING_BYTE_CANFD for CAN-FD frames if configured; otherwise
      CANTP_PADDING_BYTE.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest12_003_Tx_SF_CANFD_CANTP_ON_CAN_CAN_FD</srcid><srcstatus/><internalId>1170</internalId></linkedfrom><linkedfrom><srcid>CanTp_ConTest12_004_Tx_FF_RxFC_lastCF_CAN20_CANFD_CANTP_ON_CAN_CAN_FD</srcid><srcstatus/><internalId>1171</internalId></linkedfrom><linkedfrom><srcid>CanTp_ConTest12_005_Rx_FF_CANFD_CANTP_ON_CAN_CAN_FD</srcid><srcstatus/><internalId>1172</internalId></linkedfrom><linkedfrom><srcid>CanTp_ConTest12_008_InvalidRxLength_LastCF_frame</srcid><srcstatus/><internalId>1175</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00351</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>285</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>287</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00057</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If unexpected frames are received, the CanTp module shall behave
      according to the tables below.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00057_HalfDuplex</srcid><srcstatus/><internalId>289</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00057_FullDuplex</srcid><srcstatus/><internalId>305</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>288</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00057_HalfDuplex</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      Table 1: Handling of N-PDU arrivals for half duplex channels
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00057_HalfDuplex_1</srcid><srcstatus/><internalId>290</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00057_HalfDuplex_2</srcid><srcstatus/><internalId>291</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00057_HalfDuplex_3</srcid><srcstatus/><internalId>292</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00057_HalfDuplex_4</srcid><srcstatus/><internalId>293</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00057_HalfDuplex_5</srcid><srcstatus/><internalId>294</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00057_HalfDuplex_6</srcid><srcstatus/><internalId>295</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00057_HalfDuplex_7</srcid><srcstatus/><internalId>296</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00057_HalfDuplex_8</srcid><srcstatus/><internalId>297</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00057_HalfDuplex_9</srcid><srcstatus/><internalId>298</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00057_HalfDuplex_10</srcid><srcstatus/><internalId>299</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00057_HalfDuplex_11</srcid><srcstatus/><internalId>300</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00057_HalfDuplex_12</srcid><srcstatus/><internalId>301</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00057_HalfDuplex_13</srcid><srcstatus/><internalId>302</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00057_HalfDuplex_14</srcid><srcstatus/><internalId>303</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00057_HalfDuplex_15</srcid><srcstatus/><internalId>304</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>288</internalId></provcov>
        <provcov>
         <linksto>CanTp.ASR40.SWS_CanTp_00290</linksto>
         <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>36</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations><ruleid>WRN.swurs.needscoverage.count</ruleid></oreqmViolations><covstatus>covered</covstatus><internalId>289</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00057_HalfDuplex_1</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      Table 1 (Half duplex):
      Segmented Transmit in progress, Reception of SF N-PDU: Ignore
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30118</srcid><srcstatus/><internalId>1272</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_HalfDuplex</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>289</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>290</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00057_HalfDuplex_2</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      Table 1 (Half duplex):
      Segmented Transmit in progress, Reception of FF N-PDU: Ignore
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30120</srcid><srcstatus/><internalId>1273</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_HalfDuplex</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>289</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>291</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00057_HalfDuplex_3</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      Table 1 (Half duplex):
      Segmented Transmit in progress, Reception of CF N-PDU: Ignore
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30121</srcid><srcstatus/><internalId>1274</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_HalfDuplex</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>289</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>292</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00057_HalfDuplex_4</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      Table 1 (Half duplex):
      Segmented Transmit in progress, Reception of FC N-PDU: If awaited, process
      the FC N-PDU, otherwise ignore it.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30320</srcid><srcstatus/><internalId>1212</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30123</srcid><srcstatus/><internalId>1275</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30507</srcid><srcstatus/><internalId>1276</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_HalfDuplex</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>289</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>293</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00057_HalfDuplex_5</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      Table 1 (Half duplex):
      Segmented Transmit in progress, Reception of Unknown N-PDU: Ignore
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30127</srcid><srcstatus/><internalId>1283</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_HalfDuplex</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>289</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>294</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00057_HalfDuplex_6</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      Table 1 (Half duplex):
      Segmented Receive in progress, Reception of SF N-PDU: Terminate the
      current reception, report an indication, with parameter Result set to
      E_NOT_OK, to the upper layer, and process the SF N-PDU as
      the start of a new reception.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanTp_RxIndication.c_701</srcid><srcstatus/><internalId>1027</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30129</srcid><srcstatus/><internalId>1277</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ReceiveMultiframeOngoing_HalfDuplex</srcid><srcstatus/><internalId>1463</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_HalfDuplex</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>289</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>295</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00057_HalfDuplex_7</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      Table 1 (Half duplex):
      Segmented Receive in progress, Reception of FF N-PDU: Terminate the
      current reception, report an indication, with parameter Result set to
      E_NOT_OK, to the upper layer, and process the FF N-PDU as
      the start of a new reception.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanTp_RxIndication.c_701</srcid><srcstatus/><internalId>1027</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30130</srcid><srcstatus/><internalId>1278</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ReceiveMultiframeOngoing_HalfDuplex</srcid><srcstatus/><internalId>1463</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_HalfDuplex</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>289</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>296</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00057_HalfDuplex_8</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      Table 1 (Half duplex):
      Segmented Receive in progress, Reception of CF N-PDU: Process the CF N-PDU
      in the ongoing reception and perform the required checks (e.g. SN in
      right order).
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30131</srcid><srcstatus/><internalId>1279</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_HalfDuplex</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>289</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>297</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00057_HalfDuplex_9</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      Table 1 (Half duplex):
      Segmented Receive in progress, Reception of FC N-PDU: Ignore
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30132</srcid><srcstatus/><internalId>1280</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_HalfDuplex</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>289</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>298</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00057_HalfDuplex_10</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      Table 1 (Half duplex):
      Segmented Receive in progress, Reception of Unknown N-PDU: Ignore
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30127</srcid><srcstatus/><internalId>1283</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_HalfDuplex</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>289</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>299</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00057_HalfDuplex_11</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      Table 1 (Half duplex):
      Idle, Reception of SF N-PDU: Process the SF N-PDU as the start of a new
      reception.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30356</srcid><srcstatus/><internalId>1318</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_HalfDuplex</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>289</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>300</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00057_HalfDuplex_12</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      Table 1 (Half duplex):
      Idle, Reception of FF N-PDU: Process the FF N-PDU as the start of a new
      reception.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30325</srcid><srcstatus/><internalId>1287</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_HalfDuplex</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>289</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>301</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00057_HalfDuplex_13</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      Table 1 (Half duplex):
      Idle, Reception of CF N-PDU: Ignore
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30126</srcid><srcstatus/><internalId>1281</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_RCV_CANCL_OK1</srcid><srcstatus/><internalId>1337</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_HalfDuplex</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>289</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>302</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00057_HalfDuplex_14</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      Table 1 (Half duplex):
      Idle, Reception of FC N-PDU: Ignore
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30508</srcid><srcstatus/><internalId>1240</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30125</srcid><srcstatus/><internalId>1282</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_HalfDuplex</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>289</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>303</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00057_HalfDuplex_15</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      Table 1 (Half duplex):
      Idle, Reception of Unknown N-PDU: Ignore
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30127</srcid><srcstatus/><internalId>1283</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_HalfDuplex</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>289</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>304</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00057_FullDuplex</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      Table 2: Handling of N-PDU arrivals for full duplex channels
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00057_FullDuplex_1</srcid><srcstatus/><internalId>306</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00057_FullDuplex_2</srcid><srcstatus/><internalId>307</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00057_FullDuplex_3</srcid><srcstatus/><internalId>308</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00057_FullDuplex_4</srcid><srcstatus/><internalId>309</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00057_FullDuplex_5</srcid><srcstatus/><internalId>310</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00057_FullDuplex_6</srcid><srcstatus/><internalId>311</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00057_FullDuplex_7</srcid><srcstatus/><internalId>312</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00057_FullDuplex_8</srcid><srcstatus/><internalId>313</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00057_FullDuplex_9</srcid><srcstatus/><internalId>314</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00057_FullDuplex_10</srcid><srcstatus/><internalId>315</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00057_FullDuplex_11</srcid><srcstatus/><internalId>316</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00057_FullDuplex_12</srcid><srcstatus/><internalId>317</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00057_FullDuplex_13</srcid><srcstatus/><internalId>318</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00057_FullDuplex_14</srcid><srcstatus/><internalId>319</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00057_FullDuplex_15</srcid><srcstatus/><internalId>320</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>288</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00290</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>36</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations><ruleid>WRN.swurs.needscoverage.count</ruleid></oreqmViolations><covstatus>covered</covstatus><internalId>305</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00057_FullDuplex_1</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      Table 2 (Full duplex):
      Segmented Transmit in progress, Reception of SF N-PDU:
      If a reception is in progress process it according to
      CanTp.SWS_CanTp_00057_FullDuplex_6, otherwise process
      the SF N-PDU as the start of a new reception.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_31001</srcid><srcstatus/><internalId>1438</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_31006</srcid><srcstatus/><internalId>1443</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_ReceptionInterrupts_SegmentedTransmission</srcid><srcstatus/><internalId>1640</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_FullDuplex</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>305</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>306</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00057_FullDuplex_2</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      Table 2 (Full duplex):
      Segmented Transmit in progress, Reception of FF N-PDU:
      If a reception is in progress process it according to
      CanTp.SWS_CanTp_00057_FullDuplex_7, otherwise process
      the FF N-PDU as the start of a new reception.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_31002</srcid><srcstatus/><internalId>1439</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_31007</srcid><srcstatus/><internalId>1444</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_FullDuplex</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>305</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>307</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00057_FullDuplex_3</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      Table 2 (Full duplex):
      Segmented Transmit in progress, Reception of CF N-PDU:
      If a reception is in progress process it according to
      CanTp.SWS_CanTp_00057_FullDuplex_8, otherwise ignore it.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_31002</srcid><srcstatus/><internalId>1439</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_31003</srcid><srcstatus/><internalId>1440</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_FullDuplex</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>305</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>308</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00057_FullDuplex_4</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      Table 2 (Full duplex):
      Segmented Transmit in progress, Reception of FC N-PDU:
      If awaited, process the FC N-PDU, otherwise ignore it.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_31001</srcid><srcstatus/><internalId>1438</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_31002</srcid><srcstatus/><internalId>1439</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_31004</srcid><srcstatus/><internalId>1441</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_FullDuplex</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>305</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>309</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00057_FullDuplex_5</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      Table 2 (Full duplex):
      Segmented Transmit in progress, Reception of Unknown N-PDU:
      Ignore
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_31005</srcid><srcstatus/><internalId>1442</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_FullDuplex</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>305</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>310</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00057_FullDuplex_6</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      Table 2 (Full duplex):
      Segmented Receive in progress, Reception of SF N-PDU:
      - Terminate the current reception,
      - report an indication, with parameter Result set to E_NOT_OK, to
        the upper layer, and
      - process the SF N-PDU as the start of a new reception.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanTp_RxIndication.c_689</srcid><srcstatus/><internalId>1026</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_31006</srcid><srcstatus/><internalId>1443</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ReceiveMultiframeOngoing_FullDuplex</srcid><srcstatus/><internalId>1464</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_FullDuplex</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>305</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>311</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00057_FullDuplex_7</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      Segmented Receive in progress, Reception of FF N-PDU:
      - Terminate the current reception,
      - report an indication, with parameter Result set to E_NOT_OK, to
        the upper layer, and
      - process the FF N-PDU as the start of a new reception.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanTp_RxIndication.c_689</srcid><srcstatus/><internalId>1026</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_31007</srcid><srcstatus/><internalId>1444</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ReceiveMultiframeOngoing_FullDuplex</srcid><srcstatus/><internalId>1464</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_FullDuplex</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>305</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>312</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00057_FullDuplex_8</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      Segmented Receive in progress, Reception of CF N-PDU:
      Process the CF N-PDU in the on-going reception and perform the required
      checks (e.g. SN in right order).
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_31002</srcid><srcstatus/><internalId>1439</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_31007</srcid><srcstatus/><internalId>1444</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_31008</srcid><srcstatus/><internalId>1445</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_31009</srcid><srcstatus/><internalId>1446</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_FullDuplex</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>305</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>313</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00057_FullDuplex_9</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      Segmented Receive in progress, Reception of FC N-PDU:
      If a transmission is in progress process it according to
      CanTp.SWS_CanTp_00057_FullDuplex_4, otherwise ignore it.
      </description>
      <comment>
      Due to different name spaces for Rx and Tx it is possible that
      reception and transmission with the same N-SDU id can take place
      at the same time.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_31002</srcid><srcstatus/><internalId>1439</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_31007</srcid><srcstatus/><internalId>1444</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_31008</srcid><srcstatus/><internalId>1445</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_FullDuplex</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>305</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>314</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00057_FullDuplex_10</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      Segmented Receive in progress, Reception of Unknown N-PDU:
      Ignore
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_31009</srcid><srcstatus/><internalId>1446</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_FullDuplex</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>305</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>315</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00057_FullDuplex_11</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      Idle, Reception of SF N-PDU:
      Process the SF N-PDU as the start of a new reception.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_RxSF_NOTOK</srcid><srcstatus/><internalId>1361</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_31010</srcid><srcstatus/><internalId>1447</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_FullDuplex</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>305</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>316</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00057_FullDuplex_12</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      Idle, Reception of FF N-PDU:
      Process the FF N-PDU as the start of a new reception.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_31008</srcid><srcstatus/><internalId>1445</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_31009</srcid><srcstatus/><internalId>1446</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_FullDuplex</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>305</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>317</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00057_FullDuplex_13</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      Idle, Reception of CF N-PDU:
      Ignore
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_31011</srcid><srcstatus/><internalId>1448</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_FullDuplex</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>305</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>318</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00057_FullDuplex_14</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      Idle, Reception of FC N-PDU:
      Ignore
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_31012</srcid><srcstatus/><internalId>1449</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_FullDuplex</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>305</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>319</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00057_FullDuplex_15</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      Idle, Reception of Unknown N-PDU:
      Ignore
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_31013</srcid><srcstatus/><internalId>1450</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_FullDuplex</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>305</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>320</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00008</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      On errors and exceptions, the CanTp module shall not modify its
      current module state (see Figure 4: CAN Transport Layer life cycle)
      but shall simply report the error event.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <!-- Requires multiple tests with multiple configurations -->
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30176</srcid><srcstatus/><internalId>1289</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>321</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00291</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      In case of production error, the Diagnostic Event Manager module
      (via the Function Inhibition Manager) will perform the appropriate
      action (e.g. status modification of the calling module).
      </description>
      <comment>
        This requirement is not applicable.
        Rationale:
        According to SWS_CanTp_00293 no production errors exist. Therefore this requirement
        is obsolete.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.DemErrors</srcid><srcstatus/><internalId>981</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>322</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00293</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Type of error             Related error code    Error value
      - API service called with wrong parameter(s): When CanTp_Transmit
        is called for a none configured PDU identifier or with an identifier
        for a received PDU.
        CANTP_E_PARAM_CONFIG  0x01
      - API service called with wrong parameter(s): When CanTp_Transmit is called
        for a none configured PDU identifier or with an identifier for a received PDU.
        CANTP_E_PARAM_ID      0x02
      - API service called with a NULL pointer. In case of this error, the API service
        shall return immediately without any further action, besides reporting this
        development error.
        CANTP_E_PARAM_POINTER 0x03
      - Module initialization has failed, e.g. CanTp_Init() called with an invalid
        pointer in postbuild.
        CANTP_E_INIT_FAILED   0x04
      - API service used without module initialization : On any API call except
        CanTp_Init(), CanTp_GetVersionInfo() and CanTp_MainFunction() if CanTp is in
        state CANTP_OFF
        CANTP_E_UNINIT        0x20
      - Invalid Transmit PDU identifier (e.g. a service is called with an inexistent
        Tx PDU identifier)
        CANTP_E_INVALID_TX_ID 0x30
      - Invalid Receive PDU identifier (e.g. a service is called with an inexistent
        Rx PDU identifier)
        CANTP_E_INVALID_RX_ID 0x40
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00293_1</srcid><srcstatus/><internalId>324</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00293_2</srcid><srcstatus/><internalId>325</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00293_3</srcid><srcstatus/><internalId>327</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00293_4</srcid><srcstatus/><internalId>328</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00293_5</srcid><srcstatus/><internalId>329</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00293_6</srcid><srcstatus/><internalId>330</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00293_9</srcid><srcstatus/><internalId>331</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00293_10</srcid><srcstatus/><internalId>332</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00293_11</srcid><srcstatus/><internalId>333</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00293_12</srcid><srcstatus/><internalId>334</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00293_16</srcid><srcstatus/><internalId>335</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations><ruleid>WRN.swurs.needscoverage.count</ruleid></oreqmViolations><covstatus>covered</covstatus><internalId>323</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00293_1</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      Type or error: API service called with wrong parameter(s):
      When CanTp_Transmit is called for a none configured PDU
      identifier or with an identifier for a received PDU.
      Relevance: Development
      Related error code: CANTP_E_PARAM_CONFIG
      Value [hex]: 0x01
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <!-- Covered by CanTp.EB.Init.ParamConfig -->
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.EB.Init.ParamConfig</srcid><srcstatus/><internalId>642</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>323</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00101</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>89</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>324</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00293_2</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      Type or error: API service called with wrong parameter(s):
      CWhen CanTp_Transmit is called for a none configured PDU
      identifier or with an identifier for a received PDU.
      Relevance: Development
      Related error code: CANTP_E_PARAM_ID
      Value [hex]: 0x02
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <!-- Covered by CanTp.ASR40.SWS_CanTp_00254_1 -->
        <!-- Covered by CanTp.ASR40.SWS_CanTp_00260_1 -->
        <!-- Covered by CanTp.SWS_CanTp_00305_1 -->
        <!-- Covered by CanTp.SWS_CanTp_00305_2 -->
        <!-- Covered by CanTp.SWS_CanTp_00324_Invalid_Id -->
        <!-- Covered by CanTp.SWS_CanTp_00324_Invalid_Parameter -->        
        <!-- Covered by CanTp.SWS_CanTp_00305_3 -->
        <!-- Covered by CanTp.SWS_CanTp_00293_2a -->
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00254_1</srcid><srcstatus/><internalId>48</internalId></linkedfrom><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00260_1</srcid><srcstatus/><internalId>52</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00293_2a</srcid><srcstatus/><internalId>326</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00305_1</srcid><srcstatus/><internalId>383</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00305_2</srcid><srcstatus/><internalId>384</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00305_3</srcid><srcstatus/><internalId>385</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00324_Invalid_Id</srcid><srcstatus/><internalId>390</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00324_Invalid_Parameter</srcid><srcstatus/><internalId>391</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>323</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00101</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>89</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>325</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00293_2a</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      When CanTp_Transmit is called for a none configured PDU identifier or with an identifier
      for a received PDU, the function shall report Det error CANTP_E_PARAM_ID.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30251</srcid><srcstatus/><internalId>1291</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>325</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>326</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00293_3</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      Type or error: API service called with a NULL pointer. In case of this
      error, the API service shall return immediately without any further
      action, besides reporting this development error.
      Relevance: Development
      Related error code: CANTP_E_PARAM_POINTER
      Value [hex]: 0x03
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <!-- Covered by CanTp.ASR40.SWS_CanTp_00320 -->
        <!-- Covered by CanTp.SWS_CanTp_00319 -->
        <!-- Covered by CanTp.ASR40.SWS_CanTp_00321 -->
        <!-- Covered by CanTp.SWS_CanTp_00322 -->
        <!-- Covered by CanTp.EB.11576 -->
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00320</srcid><srcstatus/><internalId>40</internalId></linkedfrom><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00321</srcid><srcstatus/><internalId>44</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00319</srcid><srcstatus/><internalId>347</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00322</srcid><srcstatus/><internalId>399</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.11576</srcid><srcstatus/><internalId>579</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.RxIndication.ParamPointer</srcid><srcstatus/><internalId>649</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>323</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00101</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>89</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>327</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00293_4</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      Type or error: API service used without module initialization:
      On any API call except CanTp_Init() and CanTp_GetVersionInfo() if CanTp
      is in state CANTP_OFF
      Relevance: Development
      Related error code: CANTP_E_UNINIT
      Value [hex]: 0x20
      </description>
      <comment>
      Covering this requirement shall also include testing the service id used for the Det report.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <!-- Covered by CanTp.SWS_CanTp_00031 -->
        <!-- Covered by CanTp.EB.11569 -->
        <!-- Covered by CanTp.EB.11574 -->
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00031</srcid><srcstatus/><internalId>138</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.11569</srcid><srcstatus/><internalId>568</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.11574</srcid><srcstatus/><internalId>577</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>323</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00101</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>89</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>328</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00293_5</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      Type or error: Invalid Transmit PDU identifier
      (e.g. a service is called with an inexistent Tx PDU identifier)
      Relevance: Development
      Related error code: CANTP_E_INVALID_TX_ID
      Value [hex]: 0x30
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <!-- Covered by CanTp.EB.11571 -->
        <!-- Covered by CanTp.EB.11577 -->
        <!-- Covered by CanTp.EB.TxConfirmation.InvalidTxId -->
        <!-- Covered by CanTp.EB.SetNSa_TxNotExtendedAddr -->
        <!-- Covered by CanTp.EB.GetNSa_TxNotExtendedAddr -->
        <!-- Covered by CanTp.EB.SetNSa_TxFunctionalAddr -->
        <!-- Covered by CanTp.EB.GetNSa_TxFunctionalAddr -->
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.EB.11571</srcid><srcstatus/><internalId>570</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.SetNSa_TxNotExtendedAddr</srcid><srcstatus/><internalId>573</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.SetNSa_TxFunctionalAddr</srcid><srcstatus/><internalId>574</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.11577</srcid><srcstatus/><internalId>580</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.GetNSa_TxNotExtendedAddr</srcid><srcstatus/><internalId>583</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.GetNSa_TxFunctionalAddr</srcid><srcstatus/><internalId>584</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.TxConfirmation.InvalidTxId</srcid><srcstatus/><internalId>643</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>323</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00101</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>89</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>329</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00293_6</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      Type or error: Invalid Receive PDU identifier
      (e.g. a service is called with an inexistent Rx PDU identifier)
      Relevance: Development
      Related error code: CANTP_E_INVALID_RX_ID
      Value [hex]: 0x40
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <!-- Covered by CanTp.EB.11573 -->
        <!-- Covered by CanTp.EB.11578 -->
        <!-- Covered by CanTp.EB.RxIndication.InvalidRxId -->
        <!-- Covered by CanTp.EB.SetNSa_RxNotExtendedAddr -->
        <!-- Covered by CanTp.EB.GetNSa_RxNotExtendedAddr -->
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.EB.11573</srcid><srcstatus/><internalId>571</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.SetNSa_RxNotExtendedAddr</srcid><srcstatus/><internalId>572</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.11578</srcid><srcstatus/><internalId>581</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.GetNSa_RxNotExtendedAddr</srcid><srcstatus/><internalId>582</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.RxIndication.InvalidRxId</srcid><srcstatus/><internalId>644</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.RxIndication.InvalidRxId_1</srcid><srcstatus/><internalId>645</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.RxIndication.InvalidRxId_2</srcid><srcstatus/><internalId>646</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.RxIndication.InvalidRxId_3</srcid><srcstatus/><internalId>647</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>323</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00101</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>89</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>330</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00293_9</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      Type or error: Invalid data length of the transmit PDU
      (e.g. a transmit N-SDU has a length equal to zero)
      Relevance: Development
      Related error code: CANTP_E_INVALID_TX_LENGTH
      Value [hex]: 0x70
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <!-- Covered by CanTp.EB.Transmit.InvalidTxLength -->
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.EB.Transmit.InvalidTxLength</srcid><srcstatus/><internalId>648</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>323</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00101</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>89</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>331</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00293_10</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      Type or error: Invalid data length of the receive PDU
      (e.g. a receive FF N-PDU has a FF_DL equal to zero)
      Relevance: Development
      Related error code: CANTP_E_INVALID_RX_LENGTH
      Value [hex]: 0x80
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <!-- Covered by requirement CanTp.EB.IntFrame.InvalidRxLength -->
        <!-- Covered by requirement CanTp.EB.RxIndication.InvalidRxLength -->
        <!-- Covered by requirement CanTp.EB.Rx.Padding.InvalidRxLength -->
        <!-- Covered by requirement CanTp.EB.SF.InvalidRxLength -->
        <!-- Covered by requirement CanTp.EB.SF.InvalidRxLength_1 -->
        <!-- Covered by requirement CanTp.EB.SF.InvalidRxLength_2 -->
        <!-- Covered by requirement CanTp.EB.SF.InvalidRxLength_3 -->
        <!-- Covered by requirement CanTp.EB.SF.InvalidRxLength_4 -->
        <!-- Covered by requirement CanTp.EB.FF.InvalidRxLength_1 -->
        <!-- Covered by requirement CanTp.EB.FF.InvalidRxLength_2 -->
        <!-- Covered by requirement CanTp.EB.FF.InvalidRxLength_3 -->
        <!-- Covered by requirement CanTp.EB.FF.InvalidRxLength_4 -->
        <!-- Covered by requirement CanTp.EB.FF.InvalidRxLength_5 -->
        <!-- Covered by requirement CanTp.EB.LastFrame.InvalidRxLength -->
        <!-- Covered by requirement CanTp.EB.FC.InvalidRxLength -->
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.EB.IntFrame.InvalidRxLength</srcid><srcstatus/><internalId>625</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.RxIndication.InvalidRxLength</srcid><srcstatus/><internalId>626</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.Rx.Padding.InvalidRxLength</srcid><srcstatus/><internalId>627</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.Rx.Padding.CANTP_ON_CAN_CAN_FD.InvalidRxLength.CAN-FD_frame</srcid><srcstatus/><internalId>628</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.Rx.Padding.CANTP_ON_CAN_CAN_FD.InvalidRxLength.CAN2.0_frame</srcid><srcstatus/><internalId>629</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.SF.InvalidRxLength</srcid><srcstatus/><internalId>630</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.SF.InvalidRxLength_1</srcid><srcstatus/><internalId>631</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.SF.InvalidRxLength_2</srcid><srcstatus/><internalId>632</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.SF.InvalidRxLength_3</srcid><srcstatus/><internalId>633</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.SF.InvalidRxLength_4</srcid><srcstatus/><internalId>634</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.FF.InvalidRxLength_1</srcid><srcstatus/><internalId>635</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.FF.InvalidRxLength_2</srcid><srcstatus/><internalId>636</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.FF.InvalidRxLength_3</srcid><srcstatus/><internalId>637</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.FF.InvalidRxLength_4</srcid><srcstatus/><internalId>638</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.FF.InvalidRxLength_5</srcid><srcstatus/><internalId>639</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.LastFrame.InvalidRxLength</srcid><srcstatus/><internalId>640</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>323</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00101</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>89</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations><ruleid>WRN.swurs.needscoverage.count</ruleid></oreqmViolations><covstatus>covered</covstatus><internalId>332</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00293_11</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      Type or error: CanTp_Transmit() is called for a configured Tx I-Pdu with
      functional addressing and the length parameter indicates, that the
      message can not be sent with a SF
      Relevance: Development
      Related error code: CANTP_E_INVALID_TATYPE
      Value [hex]: 0x90
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <!-- Covered by requirement CanTp.SWS_CanTp_00293_1 -->
        <!-- Covered by requirement CanTp.SWS_CanTp_00293_2 -->
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00093_1</srcid><srcstatus/><internalId>28</internalId></linkedfrom><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00093_2</srcid><srcstatus/><internalId>29</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>323</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00101</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>89</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>333</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00293_12</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      Type or error: Requested operation is not supported - a cancel
      transmission/reception request for an N-SDU that it is not on
      transmission/reception process
      Relevance: Development
      Related error code: CANTP_E_OPER_NOT_SUPPORTED
      Value [hex]: 0xA0
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <!-- Covered by requirement CanTp.ASR40.SWS_CanTp_00254_2 -->
        <!-- Covered by requirement CanTp.ASR40.SWS_CanTp_00260_2 -->
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00254_2</srcid><srcstatus/><internalId>49</internalId></linkedfrom><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00260_2</srcid><srcstatus/><internalId>53</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>323</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00101</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>89</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>334</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00293_16</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      Type or error: Module initialization has failed, e.g. CanTp_Init()
      called with an invalid pointer in postbuild.
      Relevance: Development
      Related error code: CANTP_E_INIT_FAILED
      Value [hex]: 0x04
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.Errors</srcid><srcstatus/><internalId>978</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>323</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>335</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00294</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If a development error occurs, the CanTp module shall return
      the value E_NOT_OK and report the error via the Default Error
      Tracer module (if development error detection is enabled).
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <!-- Covered by CanTp.ASR40.SWS_CanTp_00254_1 -->
        <!-- Covered by CanTp.ASR40.SWS_CanTp_00254_2 -->
        <!-- Covered by CanTp.ASR40.SWS_CanTp_00260_1 -->
        <!-- Covered by CanTp.ASR40.SWS_CanTp_00260_2 -->
        <!-- Covered by CanTp.SWS_CanTp_00305_1 -->
        <!-- Covered by CanTp.SWS_CanTp_00305_2 -->
        <!-- Covered by CanTp.SWS_CanTp_00305_3 -->
        <!-- Covered by CanTp.SWS_CanTp_00324_Invalid_Id -->
        <!-- Covered by CanTp.SWS_CanTp_00324_Invalid_Parameter -->
        <!-- Covered by CanTp.ASR40.Transmit.E_NOT_OK1 -->
        <!-- Covered by CanTp.ASR40.CancelTransmit.E_NOT_OK -->
        <!-- Covered by CanTp.ASR40.ChangeParameter.E_NOT_OK -->
        <!-- Covered by CanTp.ASR40.ReadParameter.E_NOT_OK-->
        <!-- Covered by CanTp.EB.11578 -->
        <!-- Covered by CanTp.EB.11577 -->
        <!-- Covered by CanTp.EB.11576 -->
        <!-- Covered by CanTp.EB.11575 -->
        <!-- Covered by CanTp.EB.11573 -->
        <!-- Covered by CanTp.EB.11571 -->
        <!-- Covered by CanTp.EB.11570 -->
        <!-- Covered by CanTp.EB.SetNSa_RxNotExtendedAddr -->
        <!-- Covered by CanTp.EB.GetNSa_RxNotExtendedAddr -->
        <!-- Covered by CanTp.EB.SetNSa_TxFunctionalAddr -->
        <!-- Covered by CanTp.EB.GetNSa_TxFunctionalAddr -->
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00254_1</srcid><srcstatus/><internalId>48</internalId></linkedfrom><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00254_2</srcid><srcstatus/><internalId>49</internalId></linkedfrom><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00260_1</srcid><srcstatus/><internalId>52</internalId></linkedfrom><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00260_2</srcid><srcstatus/><internalId>53</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00305_1</srcid><srcstatus/><internalId>383</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00305_2</srcid><srcstatus/><internalId>384</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00305_3</srcid><srcstatus/><internalId>385</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00324_Invalid_Id</srcid><srcstatus/><internalId>390</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00324_Invalid_Parameter</srcid><srcstatus/><internalId>391</internalId></linkedfrom><linkedfrom><srcid>CanTp.ASR40.Transmit.E_NOT_OK1</srcid><srcstatus/><internalId>499</internalId></linkedfrom><linkedfrom><srcid>CanTp.ASR40.CancelTransmit.E_NOT_OK</srcid><srcstatus/><internalId>525</internalId></linkedfrom><linkedfrom><srcid>CanTp.ASR40.ChangeParameter.E_NOT_OK</srcid><srcstatus/><internalId>529</internalId></linkedfrom><linkedfrom><srcid>CanTp.ASR40.ReadParameter.E_NOT_OK</srcid><srcstatus/><internalId>532</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.11570</srcid><srcstatus/><internalId>569</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.11571</srcid><srcstatus/><internalId>570</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.11573</srcid><srcstatus/><internalId>571</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.SetNSa_RxNotExtendedAddr</srcid><srcstatus/><internalId>572</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.SetNSa_TxNotExtendedAddr</srcid><srcstatus/><internalId>573</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.SetNSa_TxFunctionalAddr</srcid><srcstatus/><internalId>574</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.11575</srcid><srcstatus/><internalId>578</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.11576</srcid><srcstatus/><internalId>579</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.11577</srcid><srcstatus/><internalId>580</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.11578</srcid><srcstatus/><internalId>581</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.GetNSa_RxNotExtendedAddr</srcid><srcstatus/><internalId>582</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.GetNSa_TxNotExtendedAddr</srcid><srcstatus/><internalId>583</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.GetNSa_TxFunctionalAddr</srcid><srcstatus/><internalId>584</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations><ruleid>WRN.swurs.needscoverage.count</ruleid></oreqmViolations><covstatus>covered</covstatus><internalId>336</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00352</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Type of error      Related error code            Error value
      PDU received with a length smaller than 8 bytes. (i.e. PduInfo
      Ptr.SduLength &lt; 8)
      CANTP_E_PADDING            0x70
      CanTp_Transmit() is called for a configured Tx I-Pdu with
      functional addressing and the length parameter indicates, that
      the message can not be sent with a SF
      CANTP_E_INVALID_TATYPE     0x90
      Requested operation is not supported - a cancel transmission/
      reception request for an N-SDU that it is not on transmission/
      reception process
      CANTP_E_OPER_NOT_SUPPORTED 0xA0
      Event reported in case of an implementation specific error other
      than a protocol timeout error during a reception or a transmission
      CANTP_E_COM                0xB0
      Event reported in case of a protocol timeout error during reception
      CANTP_E_RX_COM             0xC0
      Event reported in case of a protocol timeout error during transmission
      CANTP_E_TX_COM             0xD0
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.Errors</srcid><srcstatus/><internalId>978</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>337</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00229</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If the task was aborted due to As, Bs, Cs, Ar, Br, Cr timeout,
      the CanTp module shall raise the DET error CANTP_E_RX_COM (in
      case of a reception operation) or CANTP_E_TX_COM (in case of a
      transmission operation).
      If the task was aborted due to any other protocol error, the CanTp
      module shall raise the runtime error code CANTP_E_COM to the Default
      Error Tracer.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <!-- Linked to dev.CanTp.Det.E_xx_COM -->
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.Errors</srcid><srcstatus/><internalId>978</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>338</internalId></specobject>

    <specobject>
       <id>CanTp.SWS_CanTp_00209</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
       <version>1</version>
       <description>
      Module            Header File           Imported Type
      ComStack_Types    ComStack_Types.h      BufReq_ReturnType
                        ComStack_Types.h      PduIdType
                        ComStack_Types.h      PduInfoType
                        ComStack_Types.h      PduLengthType
                        ComStack_Types.h      RetryInfoType
                        ComStack_Types.h      TPParameterType
                        ComStack_Types.h      TpDataStateType
      Std_Types         Std_Types.h           Std_ReturnType
                        Std_Types.h           Std_VersionInfoType
    </description>
       <comment>
      This requirement is informational only.
      Rationale:
      Table of include files, no requirement.
    </comment>
       <releases>
          <release>AUTOSAR R20-11</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>339</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00002</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If, for implementation reasons, some additional types have to be defined, the
      CanTp module shall label these types as follows: CanTp_&lt;TypeName&gt;Type,
      where &lt;TypeName&gt; is the name of this type adhering to the rules:
      - No underscore usage
      - First letter of each word upper case, consecutive letters lower case. (BSW00353)
      </description>
      <comment>
      This requirement is not applicable.
      Rationale:
      Internal used types have no external impacts and will follow the EB C-style guidelines.
      See C_STYLE_506
      http://qms.ebgroup.elektrobit.com/qms/instructions/operative/software-entwicklung/progr-richtl/C_Style_Guide.pdf
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>340</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00296</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The CanTp module shall ensure that implementation-specific types are not
      "visible" outside of CanTp. Otherwise, the complete architecture would be
      corrupted.
      </description>
      <comment>
      Correctness of implementation only detectable via manual review.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <!-- Linked to TS_CANTP_Manual_CanTpHeaderFile -->
        <needscov><needsobj>man</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_Manual_CanTpHeaderFile</srcid><srcstatus/><internalId>952</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>341</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00340</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Name CanTp_ConfigType
      Kind Structure
      Description Data structure type for the post-build configuration
                  parameters.
      Available via CanTp.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate_var/xgen/CanTp.xgen_116</srcid><srcstatus/><internalId>1085</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>342</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00208</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Service name: CanTp_Init
      Syntax: void CanTp_Init( const CanTp_ConfigType* CfgPtr )
      Service ID[hex]: 0x01
      Sync/Async: Synchronous
      Reentrancy: Non Reentrant
      Parameters (in):
        CfgPtr Pointer to the CanTp post-build configuration data.
      Parameters (inout): None
      Parameters (out): None
      Return value: None
      Description: This function initializes the CanTp module.
      Available via CanTp.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <!-- Syntax shall be tested with a compile test only. -->
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_49017</srcid><srcstatus/><internalId>1647</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>343</internalId></specobject>

    <specobject>
       <id>CanTp.SWS_CanTp_00199</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
       <version>1</version>
       <description>
      The CanTp module's environment shall call CanTp_Init before
      using the CanTp module for further processing.
    </description>
       <comment>
      This requirement is informational only.
      Rationale:
      Requirement for upper layer, not for CanTp.
    </comment>
       <releases>
          <release>AUTOSAR R20-11</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>344</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00161</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      A static status variable, denoting whether a BSW module is initialized,
      should be initialized with value 0 before any APIs of the BSW module are called.
      The initialization function of the BSW modules will set the static status variable
      to a value not equal to 0.
      This variable is used to check if the module has been initialized before calling an API.
      </description>
      <comment>
      This requirement is covered by other requirements. CanTp provides the
      internal states CANTP_OFF (module not initialized) and CANTP_ON
      (module initialized).
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <!-- Covered by requirement CanTp.ASR40.SWS_CanTp_00027 -->
        <!-- Covered by requirement CanTp.ASR40.SWS_CanTp_00168 -->
        <!-- Covered by requirement CanTp.SWS_CanTp_00031 -->
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00027</srcid><srcstatus/><internalId>123</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00168</srcid><srcstatus/><internalId>124</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00031</srcid><srcstatus/><internalId>138</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>345</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00210</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      CanTp_GetVersionInfo
      Service name: CanTp_GetVersionInfo
      Syntax: void CanTp_GetVersionInfo( Std_VersionInfoType* versioninfo )
      Service ID[hex]: 0x07
      Sync/Async: Synchronous
      Reentrancy: Non Reentrant
      Parameters (in): None
      Parameters (inout): None
      Parameters (out):
        versioninfo Indicator as to where to store the version information
                    of this module.
      Return value: None
      Description: This function returns the version information of the CanTp
      module.
      Available via CanTp.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <!-- Syntax shall be tested with a compile test only. -->
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_49017</srcid><srcstatus/><internalId>1647</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>346</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00319</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If DET is enabled the function CanTp_GetVersionInfo shall rise
      CANTP_E_PARAM_POINTER error if the argument is a NULL pointer and return
      without any action.
      </description>
      <comment>
      Covering this requirement shall also include testing the service id used for the Det report.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30250</srcid><srcstatus/><internalId>1290</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>327</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>347</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00211</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Service name: CanTp_Shutdown
      Syntax: void CanTp_Shutdown(void)
      Service ID[hex]: 0x02
      Sync/Async: Synchronous
      Reentrancy: Non Reentrant
      Parameters (in): None
      Parameters (inout): None
      Parameters (out): None
      Return value: None
      Description: This function is called to shutdown the CanTp module.
      Available via CanTp.h
      </description>
      <comment>
      The support for CanTp_Shutdown() was rejected (ASCCCB-1585).
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <!-- Linked to dev.CanTp.Shutdown -->
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.Shutdown</srcid><srcstatus/><internalId>974</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>348</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00202</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The function CanTp_Shutdown shall close all pending transport protocol
      connections, free all resources and set the CanTp module into the
      CANTP_OFF state.
      </description>
      <comment>
      The support for CanTp_Shutdown() was rejected (ASCCCB-1585).
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <!-- Linked to dev.CanTp.Shutdown -->
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.Shutdown</srcid><srcstatus/><internalId>974</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>349</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00200</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The function CanTp_Shutdown shall not raise a notification about the pending
      frame transmission or reception.
      </description>
      <comment>
      The support for CanTp_Shutdown() was rejected (ASCCCB-1585).
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <!-- Linked to dev.CanTp.Shutdown -->
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.Shutdown</srcid><srcstatus/><internalId>974</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>350</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00212</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Service name: CanTp_Transmit
      Syntax: Std_ReturnType CanTp_Transmit( PduIdType TxPduId, const PduInfoType* PduInfoPtr )
      Service ID[hex]: 0x49
      Sync/Async: Synchronous
      Reentrancy: Reentrant for different PduIds. Non reentrant for the same PduId.
      Parameters (in):
      TxPduId Identifier of the PDU to be transmitted
      PduInfoPtr Length of and pointer to the PDU data and pointer to Meta Data.
      Parameters (inout): None
      Parameters (out): None
      Return value: Std_ReturnType
      E_OK: Transmit request can be accepted.
      E_NOT_OK: Transmit request has not been accepted.
      Description: Requests transmission of a PDU.
      Available via CanTp.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.Signature.ServiceID</srcid><srcstatus/><internalId>992</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00212</srcid><srcstatus/><internalId>43</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>351</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00231</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If data does fit into the associated N-PDU, the function CanTp_Transmit()
      shall send a SF N-PDU.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00231_1</srcid><srcstatus/><internalId>353</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00231_2</srcid><srcstatus/><internalId>354</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00231_3</srcid><srcstatus/><internalId>355</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00231_4</srcid><srcstatus/><internalId>356</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>352</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00231_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If data length is less than 7 (normal addressing format),
      the function CanTp_Transmit shall send a SF N-PDU (CAN 2.0 format).
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_RequestNewTransmissionFromTxConfirmation_SF</srcid><srcstatus/><internalId>1180</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30048</srcid><srcstatus/><internalId>1193</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30187</srcid><srcstatus/><internalId>1250</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MaxBuffSize</srcid><srcstatus/><internalId>1407</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00231</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>352</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>353</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00231_2</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If data length is less than 6 (extended/mixed addressing
      format), the function CanTp_Transmit shall send a SF N-PDU
      (CAN 2.0 format).
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30054</srcid><srcstatus/><internalId>1197</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00231</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>352</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>354</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00231_3</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If 7 &lt; data length &lt; 62 (normal addressing format),
      the function CanTp_Transmit shall send a SF N-PDU (CAN-FD format).
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.ISO2016.SF_DL_Standard_64</srcid><srcstatus/><internalId>909</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00231</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>352</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>355</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00231_4</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If 6 &lt; data length &lt; 61 (extended/mixed addressing
      format), the function CanTp_Transmit shall send a SF N-PDU
      (CAN-FD format).
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest09007_CanFD_Tx_SF__EcuC_PduLength__Format</srcid><srcstatus/><internalId>1144</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00231</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>352</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>356</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00232</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If data does not fit into the associated N-PDU, the function
      CanTp_Transmit() shall initiate a multiple frame transmission session.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_RequestNewTransmissionFromTxConfirmation_MultiFrame</srcid><srcstatus/><internalId>1181</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30053</srcid><srcstatus/><internalId>1196</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30055</srcid><srcstatus/><internalId>1198</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>357</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00354</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The maximum Tx length of the N-PDU shall be derived from the
      PduLength configuration parameter of EcuC. This parameter is
      equivalent to TX_DL of ISO 15765-2.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.EB.Xdm.TxNSduRef.MaxPduLength</srcid><srcstatus/><internalId>711</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>358</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00204</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The CanTp module shall notify the upper layer by calling the
      PduR_CanTpTxConfirmation callback when the transmit request has
      been completed.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_RequestNewTransmissionFromTxConfirmation_SF</srcid><srcstatus/><internalId>1180</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30048</srcid><srcstatus/><internalId>1193</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>359</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00205</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The CanTp module shall abort the transmit request and call
      the PduR_CanTpTxConfirmation callback function with the appropriate
      error result value if an error occurred (over flow, N_As timeout, N_Bs
      timeout and so on).
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <!-- Requires multiple tests with multiple configurations -->
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30077</srcid><srcstatus/><internalId>1237</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_TimeoutFF</srcid><srcstatus/><internalId>1238</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30100</srcid><srcstatus/><internalId>1239</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30101</srcid><srcstatus/><internalId>1241</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30288</srcid><srcstatus/><internalId>1243</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>360</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00206</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The function CanTp_Transmit shall reject a request if the
      CanTp_Transmit service is called for a N-SDU identifier which
      is being used in a currently running CAN Transport Layer session.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30368</srcid><srcstatus/><internalId>1313</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30377</srcid><srcstatus/><internalId>1314</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30369</srcid><srcstatus/><internalId>1315</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30370</srcid><srcstatus/><internalId>1316</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30371</srcid><srcstatus/><internalId>1330</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30378</srcid><srcstatus/><internalId>1331</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30372</srcid><srcstatus/><internalId>1332</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30373</srcid><srcstatus/><internalId>1333</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>361</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00298</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      CanTp has limited buffering capability, and hence the N-SDU payload to be
      transmitted is not copied internally. The CAN Transport Layer works on
      the memory area referenced by the CAN N-SDU pointer obtained within the
      PduR_CanTpCopyTxData service.
      </description>
      <comment>
      This requirement is not applicable.
      Rationale:
      This requirement comes from text 8without id) of former CanTp specification and only the API
      name was replaced. With the change of the API to PduR_CanTpCopyTxData() the buffer
      usage has changed. CanTp does not work with memory area of upper layer any more,
      but provides an internal buffer to the upper layer to be used to copy the payload
      of the next transmission.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>362</internalId></specobject>


    <specobject>
      <id>CanTp.SWS_CanTp_00299</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      When the upper layer calls this function for an N-SDU without MetaData,
      only the data length information of the structure indicated by PduInfoPtr
      has to be used. Its value indicates the payload length of the N-SDU,
      which is to be transmitted.
      For an N-SDU with MetaData, besides the length information also the MetaData
      provided via the PduInfoPtr is relevant. To obtain actual Tx data, the CAN
      Transport Layer shall call the PduR_CanTpCopyTxData service.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00299_1</srcid><srcstatus/><internalId>364</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00299_2</srcid><srcstatus/><internalId>365</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>363</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00299_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      When the upper layer calls this function for an N-SDU without MetaData,
      only the data length information of the structure indicated by PduInfoPtr
      has to be used. Its value indicates the payload length of the N-SDU,
      which is to be transmitted.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_RequestNewTransmissionFromTxConfirmation_SF</srcid><srcstatus/><internalId>1180</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30048</srcid><srcstatus/><internalId>1193</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MaxBuffSize</srcid><srcstatus/><internalId>1407</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00299</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>363</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>364</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00299_2</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      For an N-SDU with MetaData, besides the length information also the MetaData
      provided via the PduInfoPtr is relevant. To obtain actual Tx data, the CAN
      Transport Layer shall call the PduR_CanTpCopyTxData service.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.Metadata.NoTransmitForward</srcid><srcstatus/><internalId>988</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00299</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>363</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>365</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00321</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If DET is enabled the function CanTp_Transmit shall rise
      CANTP_E_PARAM_POINTER error if the argument PduInfoPtr is a NULL
      pointer and return without any action.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.Signature.ServiceID</srcid><srcstatus/><internalId>992</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00321</srcid><srcstatus/><internalId>44</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>366</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00246</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Service name: CanTp_CancelTransmit
      Syntax: Std_ReturnType CanTp_CancelTransmit( PduIdType TxPduId )
      Service ID[hex]: 0x4a
      Sync/Async: Synchronous
      Reentrancy: Reentrant for different PduIds. Non reentrant for the same PduId.
      Parameters (in): TxPduId  Identification of the PDU to be cancelled.
      Parameters (inout): None
      Parameters (out): None
      Return value: Std_ReturnType
      - E_OK: Cancellation was executed successfully by the destination module.
      - E_NOT_OK: Cancellation was rejected by the destination module.
      Description:
        Requests cancellation of an ongoing transmission of a PDU in a lower layer
        communication module.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.Signature.ServiceID</srcid><srcstatus/><internalId>992</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00246</srcid><srcstatus/><internalId>45</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>367</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00254</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If development error detection is enabled the function CanTp_CancelTransmit
      shall check the validity of TxPduId parameter. If the parameter value is invalid,
      the CanTp_CancelTransmit function shall raise the development error CANTP_E_PARAM_ID
      and return E_NOT_OK (see SWS_CanTp_00294).
      If the parameter value indicates a cancel transmission request for an N-SDU that it
      is not on transmission process the CanTp module shall report a runtime error code
      CANTP_E_OPER_NOT_SUPPORTED to the Default Error Tracer and the service shall return
      E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.Errors</srcid><srcstatus/><internalId>978</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00254_1</srcid><srcstatus/><internalId>48</internalId></linkedfrom><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00254_2</srcid><srcstatus/><internalId>49</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>368</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00256</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The CanTp shall abort the transmission of the current N-SDU if
      the service returns E_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanTp_CancelTransmit.c_243</srcid><srcstatus/><internalId>1017</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30367</srcid><srcstatus/><internalId>1319</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30366</srcid><srcstatus/><internalId>1326</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>369</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00255</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If the CanTp_CancelTransmit service has been successfully executed
      the CanTp shall call the PduR_CanTpTxConfirmation with notification
      result E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanTp_StopChannel.c_115</srcid><srcstatus/><internalId>1047</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>370</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00257</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Service name: CanTp_CancelReceive
      Syntax: Std_ReturnType CanTp_CancelReceive( PduIdType RxPduId )
      Service ID[hex]: 0x4c
      Sync/Async: Synchronous
      Reentrancy: Non Reentrant
      Parameters (in): RxPduId Identification of the PDU to be cancelled.
      Parameters (inout): None
      Parameters (out): None
      Return value: Std_ReturnType
      E_OK:  Cancellation was executed successfully by the destination module.
      E_NOT_OK: Cancellation was rejected by the destination module.
      Description: Requests cancellation of an ongoing reception of a PDU in a
      lower layer transport protocol module.
      Available via CanTp.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.Signature.ServiceID</srcid><srcstatus/><internalId>992</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00257</srcid><srcstatus/><internalId>50</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>371</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00260</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If development error detection is enabled the function
      CanTp_CancelReceive shall check the validity of RxPduId parameter.
      If the parameter value is invalid, the CanTp_CancelReceive function
      shall raise the development error CANTP_E_PARAM_ID and return E_NOT_OK
      (see SWS_CanTp_00294).
      If the parameter value indicates a cancel reception request for an N-SDU
      that it is not on reception process the CanTp module shall report the runtime
      error code CANTP_E_OPER_NOT_SUPPORTED to the Default Error Tracer and the
      service shall return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.Errors</srcid><srcstatus/><internalId>978</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00260_1</srcid><srcstatus/><internalId>52</internalId></linkedfrom><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00260_2</srcid><srcstatus/><internalId>53</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>372</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00261</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The CanTp shall abort the reception of the current N-SDU if the
      service returns E_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_RCV_CANCL_OK1</srcid><srcstatus/><internalId>1337</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_RCV_CANCL_OK2</srcid><srcstatus/><internalId>1338</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_CancelRx_INTCF</srcid><srcstatus/><internalId>1354</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_CancelRx_BlkRequest</srcid><srcstatus/><internalId>1355</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_RxCancel_1</srcid><srcstatus/><internalId>1423</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_FF_Transmission_RxCancellation</srcid><srcstatus/><internalId>1504</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.CancelReceive.E_OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>522</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>373</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00262</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The CanTp shall reject the request for receive cancellation in
      case of a Single Frame reception or if the CanTp is in the process
      of receiving the last Consecutive Frame of the N-SDU (i.e. the service
      is called after N-Cr timeout is started for the last Consecutive Frame).
      In this case the CanTp shall return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00262_1</srcid><srcstatus/><internalId>375</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00262_2</srcid><srcstatus/><internalId>376</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>374</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00262_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The CanTp shall reject the request for receive cancellation
      in case of a Single Frame reception In this case the CanTp
      shall return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanTp_CancelReceive.c_220</srcid><srcstatus/><internalId>1012</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_RCV_CANCL_ERR</srcid><srcstatus/><internalId>1336</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_SF_RECEPTION_POSTONED</srcid><srcstatus/><internalId>1369</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00262</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>374</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.CancelReceive.E_OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>522</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>375</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00262_2</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The CanTp shall reject the request for receive cancellation in case
      if the CanTp is in the process of receiving the last
      Consecutive Frame of the N-SDU (i.e. the service is called after N-Cr
      timeout is started for the last Consecutive Frame). In this case the
      CanTp shall return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_RCV_CANCL_ERR</srcid><srcstatus/><internalId>1336</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_CancelRx_LF</srcid><srcstatus/><internalId>1353</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_CancelRx_LF_1</srcid><srcstatus/><internalId>1356</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_SF_RECEPTION_POSTONED</srcid><srcstatus/><internalId>1369</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_RxCancel_2</srcid><srcstatus/><internalId>1424</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00262</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>374</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.CancelReceive.E_OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>522</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>376</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00263</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If the CanTp_CancelReceive service has been successfully executed
      the CanTp shall call the PduR_CanTpRxIndication with notification
      result E_NOT_OK. 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanTp_StopChannel.c_74</srcid><srcstatus/><internalId>1046</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>377</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00302</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Service name: CanTp_ChangeParameter
      Syntax: Std_ReturnType CanTp_ChangeParameter
      (
        PduIdType id,
        TPParameterType parameter,
        uint16 value
      )
      Service ID[hex]: 0x4b
      Sync/Async: Synchronous
      Reentrancy: Non Reentrant
      Parameters (in):
      id Identification of the PDU which the parameter change shall affect.
      parameter ID of the parameter that shall be changed.
      value The new value of the parameter.
      Parameters (inout): None
      Parameters (out): None
      Return value: Std_ReturnType
      E_OK: The parameter was changed successfully.
      E_NOT_OK: The parameter change was rejected.
      Description: Request to change a specific transport protocol parameter (e.g. block size).
      Available via CanTp.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.Signature.ServiceID</srcid><srcstatus/><internalId>992</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00302</srcid><srcstatus/><internalId>54</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>378</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00303</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      A parameter change is only possible if the related N-SDU is not in
      the process of reception – i.e. a change of parameter value it is
      not possible after reception of FF until indication for last CF reception
      of the related N-SDU.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <!-- Requirement fully covered by CanTp.SWS_CanTp_00304 -->
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00304</srcid><srcstatus/><internalId>380</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>379</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00304</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If the change of a parameter is requested for an N-SDU that
      is on reception process the service CanTp_ChangeParameter immediately
      returns E_NOT_OK and no parameter value is changed
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <!-- Requires multiple tests cases -->
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_Conf07004_DenyChangeParameter</srcid><srcstatus/><internalId>1431</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanTp_ChangeParameter.c_127</srcid><srcstatus/><internalId>1020</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00303</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>379</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>380</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00338</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      When CanTp_ChangeParameter is called for an N-SDU with MetaData
      (indicating a generic connection), the change shall be applied to
      all generic connections, so that it is used for all following receptions.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanTp_ChangeParameter.c_149</srcid><srcstatus/><internalId>1021</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ChangeParameter</srcid><srcstatus/><internalId>1472</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>381</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00305</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If development error detection is enabled, the function
      CanTp_ChangeParameter shall check the validity of function parameters
      (Identifier, Parameter and requested value). If any of the parameter
      value is invalid, the CanTp_ChangeParameter function shall raise the
      development error CANTP_E_PARAM_ID and return E_NOT_OK (see SWS_CanTp_00294).
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00305_1</srcid><srcstatus/><internalId>383</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00305_2</srcid><srcstatus/><internalId>384</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00305_3</srcid><srcstatus/><internalId>385</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>382</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00305_1</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      If development error detection is enabled the function
      CanTp_ChangeParameter shall check the validity of the function
      parameter "Identifier". If the
      parameter value is invalid, the CanTp_ChangeParameter function
      shall raise the development error CANTP_E_PARAM_ID and return E_NOT_OK.
      </description>
      <comment>
      Covering this requirement shall also include testing the service id used for the Det report.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_CHANGEPARA_INV_PDUID</srcid><srcstatus/><internalId>1296</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00305</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>382</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>325</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00294</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>336</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>383</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00305_2</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      If development error detection is enabled the function
      CanTp_ChangeParameter shall check the validity of the function
      parameter "Parameter". If the
      parameter value is invalid, the CanTp_ChangeParameter function
      shall raise the development error CANTP_E_PARAM_ID and return E_NOT_OK.
      </description>
      <comment>
      Covering this requirement shall also include testing the service id used for the Det report.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_CHANGEPARA_INV_TPID</srcid><srcstatus/><internalId>1297</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00305</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>382</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>325</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00294</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>336</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>384</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00305_3</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      If development error detection is enabled the function
      CanTp_ChangeParameter shall check the validity of the function
      parameter "Value". If the
      parameter value is invalid, the CanTp_ChangeParameter function
      shall raise the development error CANTP_E_PARAM_ID and return E_NOT_OK.
      </description>
      <comment>
      Covering this requirement shall also include testing the service id used for the Det report.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanTp_ChangeParameter.c_86</srcid><srcstatus/><internalId>1019</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_CHANGEPARA_BSVAL</srcid><srcstatus/><internalId>1298</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_CHANGEPARA_STMINVAL1</srcid><srcstatus/><internalId>1299</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_CHANGEPARA_STMINVAL2</srcid><srcstatus/><internalId>1300</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_CHANGEPARA_STMINVAL3</srcid><srcstatus/><internalId>1301</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00305</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>382</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>325</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00294</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>336</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>385</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00323</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Service name: CanTp_ReadParameter
      Syntax: Std_ReturnType CanTp_ReadParameter
      (
        PduIdType id,
        TPParameterType parameter,
        uint16* value
      )
      Service ID 0x0b
      Sync/Async: Synchronous
      Reentrancy: Non Reentrant
      Parameters (in):
      id Identifier of the received N-SDU on which the reception parameter are read.
      parameter Specify the parameter to which the value has to be read (BS or STmin).
      Parameters (inout): None
      Parameters (out):
      value Pointer where the parameter value will be provided.
      Return Value: Std_ReturnType
      E_OK: request is accepted.
      E_NOT_OK: request is not accepted.
      Description:
      This service is used to read the current value of reception parameters
      BS and STmin for a specified N-SDU.
      Available via CanTp.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <!-- Syntax shall be tested with a compile test only. -->
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_49017</srcid><srcstatus/><internalId>1647</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00323_E_OK_BS</srcid><srcstatus/><internalId>387</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00323_E_OK_STmin</srcid><srcstatus/><internalId>388</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.ReadParameter</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>531</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>386</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00323_E_OK_BS</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      If CanTp_ReadParameter(BS) is successfully called the API shall return E_OK
      and the new BS value shall be read.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_Conf07002_Change_Read_BS</srcid><srcstatus/><internalId>1429</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_Conf07006_ChangeRx_Read_BS</srcid><srcstatus/><internalId>1433</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00323</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>386</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.ReadParameter.E_OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>533</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>387</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00323_E_OK_STmin</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      If CanTp_ReadParameter(STmin) is successfully called the API shall return E_OK
      and the new STmin value shall be read.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_Conf07001_Change_Read_STmin</srcid><srcstatus/><internalId>1428</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_Conf07005_ChangeRx_Read_STmin</srcid><srcstatus/><internalId>1432</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00323</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>386</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.ReadParameter.E_OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>533</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>388</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00324</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If development error detection is enabled the function CanTp_ReadParameter
      shall check the validity of function parameters (Id and Parameter).
      If any of the parameter value is invalid, the CanTp_ReadParameter function
      shall raise the development error CANTP_E_PARAM_ID and return E_NOT_OK
      (see SWS_CanTp_00294).
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00324_Invalid_Id</srcid><srcstatus/><internalId>390</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00324_Invalid_Parameter</srcid><srcstatus/><internalId>391</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.CanTp_ReadParameter.CheckAgainstValueNULL_PTR</srcid><srcstatus/><internalId>759</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>389</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00324_Invalid_Id</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      If development error detection is enabled the function CanTp_ReadParameter shall
      check the validity of function parameter "Id". If the parameter value is invalid,
      the CanTp_ReadParameter function shall raise the development error CANTP_E_PARAM_ID
      and return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_READPARA_INV_PDUID</srcid><srcstatus/><internalId>1302</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00324</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>389</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>325</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00294</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>336</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>390</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00324_Invalid_Parameter</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      If development error detection is enabled the function CanTp_ReadParameter shall
      check the validity of function parameters (Id and Parameter). If any of
      the parameter value is invalid, the CanTp_ReadParameter function shall
      raise the development error CANTP_E_PARAM_ID and return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_READPARA_INV_PARAMETER</srcid><srcstatus/><internalId>1303</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00324</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>389</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>325</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00294</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>336</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>391</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00213</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Service name: CanTp_MainFunction
      Syntax: void CanTp_MainFunction(void)
      Service ID [hex]: 0x06
      Description: The main function for scheduling the CAN TP.
      Available via SchM_CanTp.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <!-- Syntax shall be tested with a compile test only. -->
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_49017</srcid><srcstatus/><internalId>1647</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>392</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00164</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The main function for scheduling the CAN TP (Entry point for
      scheduling)
      The main function will be called by the Schedule Manager or by the
      Free Running Timer module according of the call period needed.
      CanTp_MainFunction is involved in handling of CAN TP timeouts N_As,
      N_Bs, N_Cs, N_Ar, N_Br, N_Cr and STMmin.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00164_1</srcid><srcstatus/><internalId>394</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00164_2</srcid><srcstatus/><internalId>395</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>393</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00164_1</id>
      <status>rejected</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      The main function for scheduling the CAN TP (Entry point for scheduling) The main function
      will be called by the Schedule Manager or by the Free Running Timer
      module according of the call period needed.
      </description>
      <comment>
      This requirement is informational only.
      Rationale:
      The scheduling of the main function call out of scope of the CanTp module implementation
      and can not be influenced by this module.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00164</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>393</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>394</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00164_2</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      CanTp_MainFunction shall handle the CAN TP
      timeouts N_As, N_Bs, N_Cs, N_Ar, N_Br, N_Cr and STMmin.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <!-- Requires multiple tests cases -->
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30077</srcid><srcstatus/><internalId>1237</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_TimeoutFF</srcid><srcstatus/><internalId>1238</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30101</srcid><srcstatus/><internalId>1241</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30102</srcid><srcstatus/><internalId>1242</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30104</srcid><srcstatus/><internalId>1244</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00164</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>393</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>395</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00300</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The function CanTp_MainFunction is affected by configuration parameter
      CanTpMainFunctionPeriod.
      </description>
      <comment>
      This requirement is informational only.
      Rationale:
      This requirement gives information about the call of the function,
      which is not part of the implementation of this module.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>396</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00214</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      CanTp_RxIndication
      Service name: CanTp_RxIndication
      Syntax: void CanTp_RxIndication( PduIdType RxPduId, const PduInfoType* PduInfoPtr )
      Service ID [hex]: 0x42
      Sync/Async: Synchronous
      Reentrancy: Reentrant for different PduIds. Non reentrant for the same PduId.
      Parameters (in):
      RxPduId ID of the received I-PDU.
      PduInfoPtr Contains the length (SduLength) of the received I-PDU and a
      pointer to  a buffer (SduDataPtr) containing the PDU, and the MetaData related to this PDU.
      Parameters (inout): None
      Parameters (out): None
      Return value: None
      Description: Indication of a received PDU from a lower layer communication module.
      Available via CanTp.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <!-- Syntax shall be tested with a compile test only. -->
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_49017</srcid><srcstatus/><internalId>1647</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>397</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00235</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The function CanTp_RxIndication shall be callable in interrupt context (it could
      be called from the CAN receive interrupt).
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <!-- Linked to TS_CANTP_Manual_InterruptCallable -->
        <needscov><needsobj>man</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_Manual_InterruptCallable</srcid><srcstatus/><internalId>951</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>398</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00322</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      If DET is enabled the function CanTp_RxIndication shall rise
      CANTP_E_PARAM_POINTER error if the argument PduInfoPtr is a NULL pointer
      and return without any action.
      </description>
      <comment>
      Covering this requirement shall also include testing the service id used for the Det report.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30175</srcid><srcstatus/><internalId>1288</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30254</srcid><srcstatus/><internalId>1294</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>327</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>399</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00215</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Service name: CanTp_TxConfirmation
      Syntax: void CanTp_TxConfirmation( PduIdType TxPduId, Std_ReturnType result )
      Service ID [hex]: 0x40
      Sync/Async: Synchronous
      Reentrancy: Reentrant for different PduIds. Non reentrant for the same PduId.
      Parameters (in):
      TxPduId ID of the PDU that has been transmitted.
      result E_OK: The PDU was transmitted. E_NOT_OK: Transmission of the PDU failed.
      Parameters (inout): None
      Parameters (out): None
      Return value: None
      Description: The lower layer communication module confirms the transmission of an
      PDU, or the failure to transmit a PDU.
      Available via CanTp.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.Signature.ServiceID</srcid><srcstatus/><internalId>992</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00215</srcid><srcstatus/><internalId>60</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>400</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00236</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The function CanTp_TxConfirmation shall be callable in interrupt context (it
      could be called from the CAN transmit interrupt).
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <!-- Linked to TS_CANTP_Manual_InterruptCallable -->
        <needscov><needsobj>man</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_Manual_InterruptCallable</srcid><srcstatus/><internalId>951</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>401</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00216</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      API function                  Header File    Description
      CanIf_Transmit                CanIf.h        Requests transmission of a PDU.
      Det_ReportRuntimeError        Det.h          Service to report runtime errors.
                                                   If a callout has been configured then
                                                   this callout shall be called.
      PduR_CanTpCopyRxData          PduR_CanTp.h   This function is called to provide the
                                                   received data of an I-PDU segment (N-PDU)
                                                   to the upper layer. Each call to this
                                                   function provides the next part of the I-PDU
                                                   data. The size of the remaining buffer is
                                                   written to the position indicated by bufferSizePtr.
      PduR_CanTpCopyTxData          PduR_CanTp.h   This function is called to acquire the transmit
                                                   data of an I-PDU segment (N-PDU). Each call to
                                                   this function provides the next part of the I-PDU
                                                   data unless retry-&gt;TpDataState is TP_DATARETRY.
                                                   In this case the function restarts to copy the data
                                                   beginning at the offset from the current position
                                                   indicated by retry-&gt;TxTpDataCnt. The size of the
                                                   remaining data is written to the position indicated
                                                   by availableDataPtr.
      PduR_CanTpRxIndication        PduR_CanTp.h   Called after an I-PDU has been received via the TP API,
                                                   the result  indicates whether the transmission was successful
                                                   or not.
      PduR_CanTpStartOfReception    PduR_CanTp.h   This function is called at the start of receiving an N-SDU.
                                                   The N-SDU might be fragmented into multiple N-PDUs (FF with
                                                   one or more following CFs) or might consist of a single N-PDU
                                                   (SF). The service shall provide the currently available maximum
                                                   buffer size when invoked with TpSduLength equal to 0.
      PduR_CanTpTxConfirmation      PduR_CanTp.h   This function is called after the I-PDU has been transmitted on
                                                   its network, the result indicates whether the transmission was
                                                   successful or not.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.Errors</srcid><srcstatus/><internalId>978</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00216_1</srcid><srcstatus/><internalId>403</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00216_4</srcid><srcstatus/><internalId>404</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00216_5</srcid><srcstatus/><internalId>405</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00216_6</srcid><srcstatus/><internalId>407</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00216_7</srcid><srcstatus/><internalId>408</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00216_8</srcid><srcstatus/><internalId>409</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>402</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00216_1</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      API function                  Header File    Description
      CanIf_Transmit                CanIf.h        Requests transmission of a PDU.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_RequestNewTransmissionFromTxConfirmation_SF</srcid><srcstatus/><internalId>1180</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30048</srcid><srcstatus/><internalId>1193</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30054</srcid><srcstatus/><internalId>1197</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30056</srcid><srcstatus/><internalId>1200</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_Normal_Functional</srcid><srcstatus/><internalId>1368</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_Mixed_Functional_1</srcid><srcstatus/><internalId>1393</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00216</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>402</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>403</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00216_4</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      API function                  Header File    Description
      PduR_CanTpCopyRxData          PduR_CanTp.h   This function is called to provide the
                                                   received data of an I-PDU segment (N-PDU)
                                                   to the upper layer. Each call to this
                                                   function provides the next part of the I-PDU
                                                   data. The size of the remaining buffer is
                                                   written to the position indicated by bufferSizePtr.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30085</srcid><srcstatus/><internalId>1208</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30148</srcid><srcstatus/><internalId>1221</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30356</srcid><srcstatus/><internalId>1318</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00216</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>402</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>404</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00216_5</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      API function                  Header File    Description
      PduR_CanTpCopyTxData          PduR_CanTp.h   This function is called to acquire the transmit
                                                   data of an I-PDU segment (N-PDU). Each call to
                                                   this function provides the next part of the I-PDU
                                                   data unless retry-&gt;TpDataState is TP_DATARETRY.
                                                   In this case the function restarts to copy the data
                                                   beginning at the offset from the current position
                                                   indicated by retry-&gt;TxTpDataCnt. The size of the
                                                   remaining data is written to the position indicated
                                                   by availableDataPtr.
    </description>
       <releases>
          <release>AUTOSAR R20-11</release>
       </releases>
       <needscoverage>
          <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_RequestNewTransmissionFromTxConfirmation_SF</srcid><srcstatus/><internalId>1180</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30048</srcid><srcstatus/><internalId>1193</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30093</srcid><srcstatus/><internalId>1210</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30156</srcid><srcstatus/><internalId>1248</internalId></linkedfrom></coveredby></needscov>
       <containerCovstatus>covered</containerCovstatus></needscoverage>
       <providescoverage>
          <provcov>
             <linksto>CanTp.SWS_CanTp_00216</linksto>
             <dstversion>1</dstversion>
          <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>402</internalId></provcov>
       </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>405</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00216_5_1</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      The TpTxSduId passed to PduR_CanTpCopyTxData shall be read from configuration
      parameter PduRDestPduHandleId if the related PduRDestPduRef and CanTpTxNSduRef reference the
      same EcuC Pdu-container.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30053</srcid><srcstatus/><internalId>1196</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_01017_Err_PduRDestPduHandleId_Non_Existing</srcid><srcstatus/><internalId>1542</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>406</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00216_6</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      API function                  Header File    Description
      PduR_CanTpRxIndication        PduR_CanTp.h   Called after an I-PDU has been received via the TP API,
                                                   the result  indicates whether the transmission was successful
                                                   or not.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30085</srcid><srcstatus/><internalId>1208</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30091</srcid><srcstatus/><internalId>1209</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30099</srcid><srcstatus/><internalId>1222</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30366</srcid><srcstatus/><internalId>1326</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00216</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>402</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>407</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00216_7</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      API function                  Header File    Description
      PduR_CanTpStartOfReception    PduR_CanTp.h   This function is called at the start of receiving an N-SDU.
                                                   The N-SDU might be fragmented into multiple N-PDUs (FF with
                                                   one or more following CFs) or might consist of a single N-PDU
                                                   (SF). The service shall provide the currently available maximum
                                                   buffer size when invoked with TpSduLength equal to 0.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_RX_WAIT</srcid><srcstatus/><internalId>1192</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30340</srcid><srcstatus/><internalId>1234</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00216</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>402</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>408</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00216_8</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      API function                  Header File    Description
      PduR_CanTpTxConfirmation      PduR_CanTp.h   This function is called after the I-PDU has been transmitted on
                                                   its network, the result indicates whether the transmission was
                                                   successful or not.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_RequestNewTransmissionFromTxConfirmation_SF</srcid><srcstatus/><internalId>1180</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30048</srcid><srcstatus/><internalId>1193</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30092</srcid><srcstatus/><internalId>1220</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30141</srcid><srcstatus/><internalId>1226</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30077</srcid><srcstatus/><internalId>1237</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_TimeoutFF</srcid><srcstatus/><internalId>1238</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00216</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>402</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>409</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00216_8_1</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
      The TpTxSduId passed to PduR_CanTpTxConfirmation shall be read from configuration
      parameter PduRDestPduHandleId if the related PduRDestPduRef and CanTpTxNSduRef reference the
      same EcuC Pdu-container.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30053</srcid><srcstatus/><internalId>1196</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>410</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00217</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      API function     Header File    Description
      Det_ReportError  Det.h          Service to report development errors.
      </description>
      <comment>
      This requirement is informational only.
      Rationale:
      This requirement only states the interfaces to be used to fulfill optional functionality of CanTp.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>411</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00146</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The listed configuration items can be derived from a network description database,
      which is based on the EcuConfigurationTemplate.
      The configuration tool should extract all information to configure the CAN Transport Protocol.
      </description>
      <comment>
      This requirement is informational only.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>412</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00147</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The consistency of the configuration must be checked by the configuration
      tool at configuration time.
      </description>
      <comment>
      This requirement is informational only.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>413</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00328</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      The same NPdu may only be referenced by more than one NSdu (RxNSdu or
      TxNSdu, via CanTpRxNPdu, CanTpTxFcNPdu, CanTpTxNPdu, or CanTpRxFcNPdu),
      when either the NSdu has addressing format extended or mixed (29 or 11 bit),
      or when the NPdu has MetaData.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.NPduRef</srcid><srcstatus/><internalId>993</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>414</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00306</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Module Name CanTp
      Module Description  Configuration of the CanTp (CAN Transport Protocol) module.
      Post-Build Variant Support true
      Supported Config Variants  VARIANT-POST-BUILD, VARIANT-PRE-COMPILE
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanTp_EBParameters.xdm.m4_13</srcid><srcstatus/><internalId>1059</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>415</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00290</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Container Name CanTpConfig
      Parent Container CanTp
      Description
        This container contains the configuration parameters and sub containers
        of the AUTOSAR CanTp module.
      Configuration Parameters
      </description>
      <comment>
      This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>416</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00240</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Name CanTpMainFunctionPeriod
      Parent Container CanTpConfig
      Description
        Allow to configure the time for the MainFunction (as float in seconds).
        The CanTpMainFunctionPeriod should be assigned a value which is optimal
        regarding all of the timers configured for CanTp in TX and RX data transfer
        i.e. the differences from the configured timing should be as small as possible.
        Please note: This period shall be the same as call cycle time of the periodic
        task were CanTp Main function is called.
      Multiplicity 1
      Type EcucFloatParamDef
      Range ]0..INF[
      Default value --
      Post-Build Variant Value false
      Value Configuration Class
        Pre-compile time X All Variants
        Link time --
        Post-build time --
      Scope / Dependency scope: ECU
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.MainFunctionRange</srcid><srcstatus/><internalId>994</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>417</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00304</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Name CanTpMaxChannelCnt
      Parent Container CanTpConfig
      Description
        Maximum number of channels. This parameter is needed only in case of
        post-build loadable implementation using static memory allocation.
      Multiplicity 0..1
      Type EcucIntegerParamDef
      Range 0..18446744073709551615
      Default value --
      Post-Build Variant Multiplicity false
      Post-Build Variant Value false
      Multiplicity Configuration Class
        Pre-compile time X All Variants
        Link time --
        Post-build time --
      Value Configuration Class
        Pre-compile time X All Variants
        Link time --
        Post-build time --
      Scope / Dependency scope: local
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.MaxChannelCnt</srcid><srcstatus/><internalId>986</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>418</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00278</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Container Name CanTpGeneral
      Parent Container CanTp
      Description
        This container contains the general configuration parameters
        of the CanTp module.
      Configuration Parameters
      </description>
      <comment>
      This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>419</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00299</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Name CanTpChangeParameterApi
      Parent Container CanTpGeneral
      Description
        This parameter, if set to true, enables the
        CanTp_ChangeParameterRequest Api for this Module.
      Multiplicity 1
      Type EcucBooleanParamDef
      Default value --
      Post-Build Variant Value false
      Value Configuration Class
        Pre-compile time  X All Variants
        Link time         -
        Post-build time   -
      Scope / Dependency: scope: local
      </description>
      <comment>
      This is a configuration parameter requirement with functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_CHANGEPARA_API_OFF</srcid><srcstatus/><internalId>1108</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>420</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00239</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Name CanTpDevErrorDetect
      Parent Container CanTpGeneral
      Description
        Switches the development error detection and notification on or off.
        - true: detection and notification is enabled.
        - false: detection and notification is disabled.
      Multiplicity 1
      Type EcucBooleanParamDef
      Default value false
      Post-Build Variant Value false
      Value Configuration Class
        Pre-compile time  X All Variants
        Link time         -
        Post-build time   -
      Scope / Dependency: scope: local
      </description>
      <comment>
      This is a configuration parameter requirement with functional specification.
      Coverage required.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <!-- Covered by CanTp.SWS_CanTp_00006 -->
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00006</srcid><srcstatus/><internalId>37</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>421</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00302</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Name CanTpDynIdSupport
      Parent Container CanTpGeneral
      Description
        Enable support for dynamic ID handling via N-PDU MetaData.
      Multiplicity 0..1
      Type EcucBooleanParamDef
      Default value false
      Post-Build Variant Multiplicity false
      Post-Build Variant Value false
      Multiplicity Configuration Class
        Pre-compile time  X    All variants
        Link time         --
        Post-build time   --
      Value Configuration Class
        Pre-compile time  X    All variants
        Link time         --
        Post-build time   --
      Scope / Dependency
        scope: local
      </description>
      <comment>
      MetaData is supported only for Normal fixed addressing.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.MetaData.AddresingFormats</srcid><srcstatus/><internalId>982</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanTp_Extension.xdm.m4_383</srcid><srcstatus/><internalId>1066</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01001_Err_CANTP_NORMALFIXED_CanTpDynIdSupportOFF</srcid><srcstatus/><internalId>1538</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>422</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00305</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Name CanTpFlexibleDataRateSupport
      Parent Container CanTpGeneral
      Description Enable support for CAN FD frames.
      Multiplicity 0..1
      Type EcucBooleanParamDef
      Default value true
      Value Configuration Class
        Pre-compile time X All Variants
        Link time --
        Post-build time --
      Scope / Dependency scope: local
      </description>
      <comment>
      Multiplicity is set to 1 in the implementation.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanTp_Extension.xdm.m4_416</srcid><srcstatus/><internalId>1067</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>423</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00303</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Name CanTpGenericConnectionSupport
      Parent Container CanTpGeneral
      Description Enable support for the handling of generic connections
                  using N-SDUs with MetaData. Requires CanTpDynIdSupport.
      Multiplicity 0..1
      Type EcucBooleanParamDef
      Default value false
      Post-Build Variant Multiplicity false
      Post-Build Variant Value false
      Multiplicity Configuration Class
        Pre-compile time X All Variants
        Link time --
        Post-build time --
      Value Configuration Class
        Pre-compile time X All Variants
        Link time --
        Post-build time --
      Scope / Dependency scope: Requires CanTpDynIdSupport.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanTp_Extension.xdm.m4_449</srcid><srcstatus/><internalId>1068</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ReceiveSF</srcid><srcstatus/><internalId>1461</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ReceiveMultiframe</srcid><srcstatus/><internalId>1462</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_TransmitSF</srcid><srcstatus/><internalId>1465</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_TransmitMultiframe</srcid><srcstatus/><internalId>1466</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ChangeParameter</srcid><srcstatus/><internalId>1472</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>424</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00298</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Name CanTpPaddingByte
      Parent Container CanTpGeneral
      Description Used for the initialization of unused bytes with
                  a certain value
      Multiplicity 1
      Type EcucIntegerParamDef
      Range 0..255
      Default value --
      Post-Build Variant Value false
      Value Configuration Class
        Pre-compile time X All Variants
        Link time --
        Post-build time --
      Scope / Dependency scope: local
      </description>
      <comment>
      This is a configuration parameter requirement without functional specification.
      Functional behavior covered by CanTp.ASR40.CanTp040_1
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>425</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00300</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Name CanTpReadParameterApi
      Parent Container CanTpGeneral
      Description This parameter, if set to true, enables the CanTp_ReadParameterApi
                  for this module.
      Multiplicity 1
      Type EcucBooleanParamDef
      Default value --
      Post-Build Variant Value false
      Value Configuration Class
        Pre-compile time X All Variants
        Link time --
        Post-build time --
      Scope / Dependency scope: local
      </description>
      <comment>
      This is a configuration parameter requirement with functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_READPARA_API_OFF</srcid><srcstatus/><internalId>1109</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>426</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00283</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Name CanTpVersionInfoApi
      Parent Container CanTpGeneral
      Description The function CanTp_GetVersionInfo is configurable (On/Off)
                  by this configuration parameter.
      Multiplicity 1
      Type EcucBooleanParamDef
      Default value false
      Post-Build Variant Value false
      Value Configuration Class
        Pre-compile time X All Variants
        Link time --
        Post-build time --
      Scope / Dependency scope: local
      </description>
      <comment>
      This is a configuration parameter requirement without functional specification.
      Functional behavior covered by CanTp.ASR40.CanTp163
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>427</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00288</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Container Name CanTpChannel
      Parent Container CanTpConfig
      Description This container contains the configuration parameters
                  of the CanTp channel.
      Post-Build Variant Multiplicity true
      Multiplicity Configuration Class
        Pre-compile time X VARIANT-PRE-COMPILE
        Link time --
        Post-build time X VARIANT-POST-BUILD
      Scope / Dependency scope: local
      </description>
      <comment>
      This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>428</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00137</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Container Name CanTpRxNSdu
      Parent Container CanTpChannel
      Description The following parameters needs to be configured for
                  each CAN N-SDU that the CanTp module receives via the
                  CanTpChannel. This N-SDU produces meta data items of type
                  SOURCE_ADDRESS_16, TARGET_ADDRESS_16 and ADDRESS_EXTENSION_8.
      Post-Build Variant Multiplicity true
      Multiplicity Configuration Class
        Pre-compile time X VARIANT-PRE-COMPILE
        Link time --
        Post-build time X VARIANT-POST-BUILD
      Scope / Dependency scope: local
      </description>
      <comment>
      This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>429</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00276</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Name CanTpBs
      Parent Container CanTpRxNSdu
      Description Sets the number of N-PDUs the CanTp receiver allows the sender to send,
                  before waiting for an authorization to continue transmission of the
                  following N-PDUs.For further details on this parameter value see 
                  ISO 15765-2 specification.
      Multiplicity 0..1
      Type EcucIntegerParamDef
      Default value --
      Post-Build Variant Multiplicity true
      Post-Build Variant Value true
      Multiplicity Configuration Class
        Pre-compile time X VARIANT-PRE-COMPILE
        Link time --
        Post-build time X VARIANT-POST-BUILD
      Value Configuration Class
        Pre-compile time X VARIANT-PRE-COMPILE
        Link time --
        Post-build time X VARIANT-POST-BUILD
      Scope / Dependency scope: local
      </description>
      <comment>
      This is a configuration parameter requirement with functional specification.
      Coverage required.
      Please consider that according to CanTp.SWS_CanTp_00091_2 this configuration value is
      a maximum limit.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30415</srcid><srcstatus/><internalId>1659</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30416</srcid><srcstatus/><internalId>1660</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_SegRxMixedAdr</srcid><srcstatus/><internalId>1683</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>430</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00277</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Name CanTpNar
      Parent Container CanTpRxNSdu
      Description Value in seconds of the N_Ar timeout. N_Ar is the time for
                  transmission of a CAN frame (any N_PDU) on the receiver side.
      Multiplicity 0..1
      Type EcucFloatParamDef
      Range [0..INF]
      Default value --
      Post-Build Variant Multiplicity true
      Post-Build Variant Value true
      Multiplicity Configuration Class
        Pre-compile time X VARIANT-PRE-COMPILE
        Link time --
        Post-build time X VARIANT-POST-BUILD
      Value Configuration Class
        Pre-compile time X VARIANT-PRE-COMPILE
        Link time --
        Post-build time X VARIANT-POST-BUILD
      Scope / Dependency scope: local
      </description>
      <comment>
      This is a configuration parameter requirement without functional specification.
      Behavior is covered by CanTp.SWS_CanTp_00311.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>431</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00245</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Name CanTpNbr
      Parent Container CanTpRxNSdu
      Description Value in seconds of the performance requirement for (N_Br + N_Ar).
                  N_Br is the elapsed time between the receiving indication of a
                  FF or CF or the transmit confirmation of a FC, until the transmit
                  request of the next FC.
      Multiplicity 0..1
      Type EcucFloatParamDef
      Range [0..INF]
      Default value --
      Post-Build Variant Value true
      Value Configuration Class
        Pre-compile time X VARIANT-PRE-COMPILE
        Link time --
        Post-build time X VARIANT-POST-BUILD
      Scope / Dependency scope: local
      </description>
      <comment>
      This is a configuration parameter requirement without functional specification.
      Behavior is covered by CanTp.ASR40.SWS_CanTp_00166 and CanTp.ASR40.SWS_CanTp_00082.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>432</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00279</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Name CanTpNcr
      Parent Container CanTpRxNSdu
      Description Value in seconds of the N_Cr timeout. N_Cr is the time until
                  reception of the next Consecutive Frame N_PDU.
      Multiplicity 0..1
      Type EcucFloatParamDef
      Range [0..INF]
      Default value --
      Post-Build Variant Multiplicity true
      Post-Build Variant Value true
      Multiplicity Configuration Class
        Pre-compile time X VARIANT-PRE-COMPILE
        Link time --
        Post-build time X VARIANT-POST-BUILD
      Value Configuration Class
        Pre-compile time X VARIANT-PRE-COMPILE
        Link time --
        Post-build time X VARIANT-POST-BUILD
      Scope / Dependency scope: local
      </description>
      <comment>
      This is a configuration parameter requirement without functional specification.
      Behavior is covered by CanTp.SWS_CanTp_00312 and CanTp.SWS_CanTp_00313.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>433</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00281</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Name CanTpRxAddressingFormat
      Parent Container CanTpRxNSdu
      Description Declares which communication addressing mode is supported
                  for this RxNSdu.
                  Definition of Enumeration values:
                  CanTpStandard to use normal addressing format.
                  CanTpExtended to use extended addressing format.
                  CanTpMixed to use mixed 11 bit addressing format.
                  CanTpNormalFixed to use normal fixed addressing format.
                  CanTpMixed29Bit to use mixed 29 bit addressing format.
      Multiplicity 1
      Type EcucEnumerationParamDef
      Range CANTP_EXTENDED Extended addressing format
            CANTP_MIXED Mixed 11 bit addressing format
            CANTP_MIXED29BIT Mixed 29 bit addressing format
            CANTP_NORMALFIXED Normal fixed addressing format
            CANTP_STANDARD Normal addressing format
      Post-Build Variant Value false
      Value Configuration Class
        Pre-compile time X All Variants
        Link time --
        Post-build time --
      Scope / Dependency scope: local
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.MetaData.AddresingFormats</srcid><srcstatus/><internalId>982</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.EB.RxAddressingFormat_Conf</srcid><srcstatus/><internalId>772</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>434</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00301</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Name CanTpRxNSduId
      Parent Container CanTpRxNSdu
      Description Unique identifier user by the upper layer to call CanTp_CancelReceive,
                  CanTp_ChangeParameter and CanTp_ReadParameter.
      Multiplicity 1
      Type EcucIntegerParamDef (Symbolic Name generated for this parameter)
      Range 0..65535
      Default value --
      Post-Build Variant Value false
      Value Configuration Class
        Pre-compile time X All Variants
        Link time --
        Post-build time --
      Scope / Dependency scope: local
      </description>
      <comment>
      This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>435</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00249</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Name CanTpRxPaddingActivation
      Parent Container CanTpRxNSdu
      Description Defines if the receive frame uses padding or not.
                  This parameter is restricted to 8 byte N-PDUs.
                  Definition of enumeration values:
                  CanTpOn:
                    The N-PDU received uses padding for SF, FC and the last CF.
                    (N-PDU length is always ≥ 8 bytes in case of CAN 2.0)
                  CanTpOff:
                    The N-PDU received does not use padding for SF, CF and the
                    last CF. (N-PDU length is dynamic - any valid DLC value).
                  Note: The mandatory mapping to the next higher valid DLC value
                  for N-PDUs with a length &gt; 8 bytes is not affected by this parameter.
      Multiplicity 1
      Type EcucEnumerationParamDef
      Range CANTP_OFF Padding is not used
            CANTP_ON  Padding is used
      Post-Build Variant Value false
      Value Configuration Class
        Pre-compile time X VARIANT-PRE-COMPILE
        Link time --
        Post-build time X VARIANT-POST-BUILD
      Scope / Dependency scope: local
      </description>
      <comment>
      This is a configuration parameter requirement without functional specification.
      The behavior is covered by CanTp.ASR40.SWS_CanTp_00040.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.EB.Rx_CANTP_ON_CAN_CAN_FD_Conf</srcid><srcstatus/><internalId>736</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>436</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00250</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Name CanTpRxTaType
      Parent Container CanTpRxNSdu
      Description Declares the communication type of this Rx N-SDU.
      Multiplicity 1
      Type EcucEnumerationParamDef
      Range CANTP_FUNCTIONAL Functional request type
            CANTP_PHYSICAL   Physical request type
      Post-Build Variant Value false
      Value Configuration Class
        Pre-compile time X All Variants
        Link time --
        Post-build time --
      Scope / Dependency scope: local
      </description>
      <comment>
      This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>437</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00251</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Name CanTpRxWftMax
      Parent Container CanTpRxNSdu
      Description This parameter indicates how many Flow Control wait N-PDUs can be
                  consecutively transmitted by the receiver. It is local to the node
                  and is not transmitted inside the FC protocol data unit.
                  CanTpRxWftMax is used to avoid sender nodes being potentially
                  hooked-up in case of a temporarily reception inability on the
                  part of the receiver nodes, whereby the sender could be waiting
                  continuously.
      Multiplicity 0..1
      Type EcucIntegerParamDef
      Range 0..65535
      Default value --
      Post-Build Variant Multiplicity true
      Post-Build Variant Value true
      Multiplicity Configuration Class
        Pre-compile time X VARIANT-PRE-COMPILE
        Link time --
        Post-build time X VARIANT-POST-BUILD
      Value Configuration Class
        Pre-compile time X VARIANT-PRE-COMPILE
        Link time --
        Post-build time X VARIANT-POST-BUILD
      Scope / Dependency scope: local
      </description>
      <comment>
      This is a configuration parameter requirement without functional specification.
      The behavior is covered by CanTp.SWS_CanTp_00223.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>438</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00252</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Name CanTpSTmin
      Parent Container CanTpRxNSdu
      Description Sets the duration of the minimum time the CanTp sender
                  shall wait between the transmissions of two CF N-PDUs.
                  For further details on this parameter value see ISO 15765-2
                  specification.
      Multiplicity 0..1
      Type EcucFloatParamDef
      Range [0..INF]
      Default value --
      Post-Build Variant Multiplicity true
      Post-Build Variant Value true
      Multiplicity Configuration Class
        Pre-compile time X VARIANT-PRE-COMPILE
        Link time --
        Post-build time X VARIANT-POST-BUILD
      Value Configuration Class
        Pre-compile time X VARIANT-PRE-COMPILE
        Link time --
        Post-build time X VARIANT-POST-BUILD
      Scope / Dependency scope: local
      </description>
      <comment>
      This is a configuration parameter requirement with functional specification.
      Coverage required.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30452</srcid><srcstatus/><internalId>1672</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>439</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00241</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Name CanTpRxNSduRef
      Parent Container CanTpRxNSdu
      Description Reference to a Pdu in the COM-Stack.
      Multiplicity 1
      Type Reference to [ Pdu ]
      Post-Build Variant Value true
      Value Configuration Class
        Pre-compile time X VARIANT-PRE-COMPILE
        Link time --
        Post-build time X VARIANT-POST-BUILD
      Scope / Dependency scope: local
      </description>
      <comment>
      This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>440</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00256</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Container Name CanTpRxNPdu
      Parent Container CanTpRxNSdu
      Description Used for grouping of the ID of a PDU and the Reference to a PDU.
                  This N-PDU consumes a meta data item of type CAN_ID_32.
      Configuration Parameters
      </description>
      <comment>
      This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>441</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00258</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Name CanTpRxNPduId
      Parent Container CanTpRxNPdu
      Description The N-PDU identifier attached to the RxNsdu is identified
                  by CanTpRxNSduId.
                  Each RxNsdu identifier is linked to only one SF/FF/CF N-PDU identifier.
                  Nevertheless, in the case of extended or mixed addressing format, the
                  same N-PDU identifier can be used for several N-SDU identifiers.
                  The distinction is made by the N_TA or N_AE value (first data byte
                  of SF or FF frames).
      Multiplicity 1
      Type EcucIntegerParamDef
      Range 0..65535
      Default value --
      Post-Build Variant Value false
      Value Configuration Class
        Pre-compile time X All Variants
        Link time --
        Post-build time --
      Scope / Dependency scope: local
      </description>
      <comment>
      This is a configuration parameter requirement without functional specification.
      The behavior is covered by CanTp.ASR40.SWS_CanTp_00248.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>442</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00257</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Name CanTpRxNPduRef
      Parent Container CanTpRxNPdu
      Description Reference to a Pdu in the COM-Stack.
      Multiplicity 1
      Type Reference to [ Pdu ]
      Post-Build Variant Value true
      Value Configuration Class
        Pre-compile time X All Variants
        Link time --
        Post-build time --
      Scope / Dependency
      </description>
      <comment>
      This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>443</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00259</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Container Name CanTpTxFcNPdu
      Parent Container CanTpRxNSdu
      Description Used for grouping of the ID of a PDU and the Reference
                  to a PDU. This N-PDU produces a meta data item of type CAN_ID_32.
      Configuration Parameters
      </description>
      <comment>
      This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>444</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00287</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Name CanTpTxFcNPduConfirmationPduId
      Parent Container CanTpTxFcNPdu
      Description Handle Id to be used by the CanIf to confirm the
                  transmission of the CanTpTxFcNPdu to the CanIf module.
      Multiplicity 1
      Type EcucIntegerParamDef (Symbolic Name generated for this parameter)
      Range 0..65535
      Default value --
      Post-Build Variant Value false
      Value Configuration Class
        Pre-compile time X All Variants
        Link time --
        Post-build time --
      Scope / Dependency scope: local
      </description>
      <comment>
      This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>445</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00260</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Name CanTpTxFcNPduRef
      Parent Container CanTpTxFcNPdu
      Description Reference to a Pdu in the COM-Stack.
      Multiplicity 1
      Type Reference to [ Pdu ]
      Post-Build Variant Value true
      Value Configuration Class
        Pre-compile time X VARIANT-PRE-COMPILE
        Link time --
        Post-build time X VARIANT-POST-BUILD
      Scope / Dependency
      </description>
      <comment>
      This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>446</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00138</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Container Name CanTpTxNSdu
      Parent Container CanTpChannel
      Description The following parameters needs to be configured for each
                  CAN N-SDU that the CanTp module transmits via the CanTpChannel.
                  This N-SDU consumes meta data items of type SOURCE_ADDRESS_16,
                  TARGET_ADDRESS_16 and ADDRESS_EXTENSION_8.
      Post-Build Variant Multiplicity true
      Multiplicity Configuration Class
        Pre-compile time X VARIANT-PRE-COMPILE
        Link time --
        Post-build time X VARIANT-POST-BUILD
      Configuration Parameters
      </description>
      <comment>
      ADDRESS_EXTENSION_8 is not consumed via meta data.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.Metadata.AddressExtension8</srcid><srcstatus/><internalId>987</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>447</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00263</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Name CanTpNas
      Parent Container CanTpTxNSdu
      Description Value in second of the N_As timeout. N_As is the time
                  for transmission of a CAN frame (any N_PDU) on the part
                  of the sender.
      Multiplicity 1
      Type EcucFloatParamDef
      Range [0..INF]
      Default value --
      Post-Build Variant Value true
      Value Configuration Class
        Pre-compile time X VARIANT-PRE-COMPILE
        Link time --
        Post-build time X VARIANT-POST-BUILD
      Scope / Dependency scope: local
      </description>
      <comment>
      This is a configuration parameter requirement without functional specification.
      The behavior is covered by CanTp.SWS_CanTp_00310.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>448</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00264</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Name CanTpNbs
      Parent Container CanTpTxNSdu
      Description Value in seconds of the N_Bs timeout. N_Bs is the time of
                  transmission until reception of the next Flow Control N_PDU.
      Multiplicity 0..1
      Type EcucFloatParamDef
      Range [0..INF]
      Default value --
      Post-Build Variant Multiplicity true
      Post-Build Variant Value true
      Multiplicity Configuration Class
        Pre-compile time X VARIANT-PRE-COMPILE
        Link time --
        Post-build time X VARIANT-POST-BUILD
      Value Configuration Class
        Pre-compile time X VARIANT-PRE-COMPILE
        Link time --
        Post-build time X VARIANT-POST-BUILD
      Scope / Dependency scope: local
      </description>
      <comment>
      This is a configuration parameter requirement without functional specification.
      The behavior is covered by CanTp.SWS_CanTp_00316.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>449</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00265</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Name CanTpNcs
      Parent Container CanTpTxNSdu
      Description Value in seconds of the performance requirements relating to N_Cs.
                  CanTpNcs is the time in which CanTp is allowed to request from
                  PduR the Tx data of a Consecutive Frame N_PDU.
      Multiplicity 0..1
      Type EcucFloatParamDef
      Range [0..INF]
      Default value --
      Post-Build Variant Multiplicity true
      Post-Build Variant Value true
      Multiplicity Configuration Class
        Pre-compile time X VARIANT-PRE-COMPILE
        Link time --
        Post-build time X VARIANT-POST-BUILD
      Value Configuration Class
        Pre-compile time X VARIANT-PRE-COMPILE
        Link time --
        Post-build time X VARIANT-POST-BUILD
      Scope / Dependency scope: local
      </description>
      <comment>
      Multiplicity mandatory in the implementation according to ASR 4.0.3.
      Post-Build Variant Multiplicity disabled.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.NCs</srcid><srcstatus/><internalId>989</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>450</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00282</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Name CanTpTc
      Parent Container CanTpTxNSdu
      Description Switch for enabling Transmit Cancellation.
      Multiplicity 1
      Type EcucBooleanParamDef
      Default value --
      Post-Build Variant Value false
      Value Configuration Class
        Pre-compile time X All Variants
        Link time --
        Post-build time --
      Scope / Dependency scope: local
      </description>
      <comment>
      This is a configuration parameter requirement without functional specification.
      The behavior is covered by CanTp.SWS_CanTp_00242.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>451</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00262</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Name CanTpTxAddressingFormat
      Parent Container CanTpTxNSdu
      Description Declares which communication addressing format is
                  supported for this TxNSdu.
                  Definition of Enumeration values:
                  CanTpStandard to use normal addressing format.
                  CanTpExtended to use extended addressing format.
                  CanTpMixed to use mixed 11 bit addressing format.
                  CanTpNormalFixed to use normal fixed addressing format.
                  CanTpMixed29Bit to use mixed 29 bit addressing format.
      Multiplicity 1
      Type EcucEnumerationParamDef
      Range CANTP_EXTENDED     Extended addressing format
            CANTP_MIXED        Mixed 11 bit addressing format
            CANTP_MIXED29BIT   Mixed 29 bit addressing format
            CANTP_NORMALFIXED  Normal fixed addressing format
            CANTP_STANDARD     Normal addressing format
      Post-Build Variant Value false
      Value Configuration Class
        Pre-compile time X All Variants
        Link time --
        Post-build time --
      Scope / Dependency scope: local
      </description>
      <comment>
      This is a configuration parameter requirement without functional specification.
      The behavior is covered by CanTp.ASR40.SWS_CanTp_00281.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.MetaData.AddresingFormats</srcid><srcstatus/><internalId>982</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.EB.TxAddressingFormat_Conf</srcid><srcstatus/><internalId>773</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>452</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00268</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Name CanTpTxNSduId
      Parent Container CanTpTxNSdu
      Description Unique identifier to a structure that contains all
                  useful information to process the transmission of a TxNsdu.
      Multiplicity 1
      Type EcucIntegerParamDef (Symbolic Name generated for this parameter)
      Range 0..65535
      Post-Build Variant Value false
      Value Configuration Class
        Pre-compile time X All Variants
        Link time --
        Post-build time --
      Scope / Dependency scope: local
      </description>
      <comment>
      This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>453</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00269</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Name CanTpTxPaddingActivation
      Parent Container CanTpTxNSdu
      Description Defines if the transmit frame use padding or not.
                  This parameter is restricted to 8 byte N-PDUs.
                  Definition of Enumeration values:
                  CanTpOn
                    The transmit N-PDU uses padding for SF, FC and the last CF.
                    (N-PDU length is always 8 bytes in case of CAN 2.0)
                  CanTpOff
                    The transmit N-PDU does not use padding for SF, CF and the last CF.
                    (N-PDU length is dynamic - any valid DLC value).
                  Note: The mandatory mapping to the next higher valid DLC value for
                  N-PDUs with a length &gt; 8 bytes is not affected by this parameter.
      Multiplicity 1
      Type EcucEnumerationParamDef
      Range CANTP_OFF  Padding is not used
            CANTP_ON   Padding is used
      Post-Build Variant Value true
      Value Configuration Class
        Pre-compile time X VARIANT-PRE-COMPILE
        Link time --
        Post-build time X VARIANT-POST-BUILD
      Scope / Dependency scope: local
      </description>
      <comment>
      This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.EB.Tx_CANTP_ON_CAN_CAN_FD_Conf</srcid><srcstatus/><internalId>737</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>454</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00270</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Name CanTpTxTaType
      Parent Container CanTpTxNSdu
      Description Declares the communication type of this TxNsdu.
                  Enumeration values:
                  CanTpPhysical. Used for 1:1 communication.
                  CanTpFunctional. Used for 1:n communication.
      Multiplicity 1
      Type EcucEnumerationParamDef
      Range CANTP_FUNCTIONAL  Functional request type
            CANTP_PHYSICAL    Physical request type
      Post-Build Variant Value false
      Value Configuration Class
        Pre-compile time X All Variants
        Link time --
        Post-build time --
      Scope / Dependency scope: local
      </description>
      <comment>
      This is a configuration parameter requirement without functional specification.
      The behavior is covered by CanTp.SWS_CanTp_00092 and CanTp.ASR40.SWS_CanTp_00093.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>455</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00261</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Name CanTpTxNSduRef
      Parent Container CanTpTxNSdu
      Description Reference to a Pdu in the COM-Stack.
      Multiplicity 1
      Type Reference to [ Pdu ]
      Post-Build Variant Value true
      Value Configuration Class
        Pre-compile time X VARIANT-PRE-COMPILE
        Link time --
        Post-build time X VARIANT-POST-BUILD
      Scope / Dependency
      </description>
      <comment>
      This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>456</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00274</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Container Name CanTpTxNPdu
      Parent Container CanTpTxNSdu
      Description Used for grouping of the ID of a PDU and the Reference to a PDU.
                  This N-PDU produces a meta data item of type CAN_ID_32.
      Configuration Parameters
      </description>
      <comment>
      This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>457</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00286</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Name CanTpTxNPduConfirmationPduId
      Parent Container CanTpTxNPdu
      Description Handle Id to be used by the CanIf to confirm the transmission of
                  the CanTpTxNPdu to the CanIf module.
      Multiplicity 1
      Type EcucIntegerParamDef (Symbolic Name generated for this parameter)
      Range 0..65535
      Default value --
      Post-Build Variant Value false
      Value Configuration Class
        Pre-compile time X All Variants
        Link time --
        Post-build time --
      Scope / Dependency scope: local
      </description>
      <comment>
      This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>458</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00275</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Name CanTpTxNPduRef
      Parent Container CanTpTxNPdu
      Description Reference to a Pdu in the COM-Stack.
      Multiplicity 1
      Type Reference to [ Pdu ]
      Post-Build Variant Value true
      Value Configuration Class
        Pre-compile time X VARIANT-PRE-COMPILE
        Link time --
        Post-build time X VARIANT-POST-BUILD
      Scope / Dependency scope: local
      </description>
      <comment>
      This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>459</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00271</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Container Name CanTpRxFcNPdu
      Parent Container CanTpTxNSdu
      Description Used for grouping of the ID of a PDU and the Reference
                  to a PDU. This N-PDU consumes a meta data item of type
                  CAN_ID_32.
      Configuration Parameters
      </description>
      <comment>
      This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>460</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00273</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Name CanTpRxFcNPduId
      Parent Container CanTpRxFcNPdu
      Description N-PDU identifier attached to the FC N-PDU of this TxNsdu
                  identified by CanTpTxNSduId.
                  Each TxNsdu identifier is linked to one Rx FC N-PDU identifier only.
                  However, in the case of extended addressing format, the same FC N-PDU
                  identifier can be used for several N-SDU identifiers.
                  The distinction is made by means of the N_TA value (first data byte of
                  FC frames).
      Multiplicity 1
      Type EcucIntegerParamDef (Symbolic Name generated for this parameter)
      Range 0..65535
      Default value --
      Post-Build Variant Value false
      Value Configuration Class
        Pre-compile time X All Variants
        Link time --
        Post-build time --
      Scope / Dependency scope: local
      </description>
      <comment>
      This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>461</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00272</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Name CanTpRxFcNPduRef
      Parent Container CanTpRxFcNPdu
      Description Reference to a Pdu in the COM-Stack.
      Multiplicity 1
      Type Reference to [ Pdu ]
      Post-Build Variant Value true
      Value Configuration Class
        Pre-compile time X VARIANT-PRE-COMPILE
        Link time --
        Post-build time X VARIANT-POST-BUILD
      Scope / Dependency
      </description>
      <comment>
      This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>462</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00139</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Container Name CanTpNTa
      Parent Container CanTpRxNSdu, CanTpTxNSdu
      Description This container is required for each RxNSdu and TxNSdu with
                  AddressingFormat CANTP_EXTENDED. When DynIdSupport is enabled,
                  this container is also required for each RxNSdu with AddressingFormat
                  CANTP_NORMALFIXED or CANTP_MIXED29BIT.
                  When DynIdSupport is enabled and GenericConnectionSupport is not
                  enabled, this container is also required for each TxNSdu with
                  AddressingFormat CANTP_NORMALFIXED or CANTP_MIXED29BIT.
      Configuration Parameters
      </description>
      <comment>
      This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.MetaData.AddresingFormats</srcid><srcstatus/><internalId>982</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanTp_Extension.xdm.m4_1251</srcid><srcstatus/><internalId>1076</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/config/CanTp_Extension.xdm.m4_1887</srcid><srcstatus/><internalId>1084</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ReceiveMultiframe</srcid><srcstatus/><internalId>1462</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_TransmitMultiframe</srcid><srcstatus/><internalId>1466</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_IgnoreCF_DifferentTA</srcid><srcstatus/><internalId>1467</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_IgnoreFC_DifferentSA</srcid><srcstatus/><internalId>1469</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_IgnoreFC_DifferentTA</srcid><srcstatus/><internalId>1470</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>463</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00255</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Name CanTpNTa
      Parent Container CanTpNTa
      Description This parameter contains the transport protocol target
                  address value.
      Multiplicity 1
      Type EcucIntegerParamDef
      Range 0..255
      Default value --
      Post-Build Variant Value false
      Value Configuration Class
        Pre-compile time X All Variants
        Link time --
        Post-build time --
      Scope / Dependency scope: local
      </description>
      <comment>
      This is a configuration parameter requirement without functional specification.
      The behavior is covered by CanTp.ASR40.SWS_CanTp_00281.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.EB.CanTpNADescription.CanTpNTa</srcid><srcstatus/><internalId>826</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>464</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00253</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Container Name CanTpNSa
      Parent Container CanTpRxNSdu, CanTpTxNSdu
      Description This container is required for each RxNSdu and TxNSdu with RxTaType
                  CANTP_PHYSICAL and CanTpAddressingFormat CANTP_EXTENDED.
                  When DynIdSupport is enabled, this container is also required for each
                  TxNSdu with AddressingFormat CANTP_NORMALFIXED or CANTP_MIXED29BIT.
                  When DynIdSupport is enabled and GenericConnectionSupport is not enabled,
                  this container is also required for each RxNSdu with AddressingFormat
                  CANTP_NORMALFIXED or CANTP_MIXED29BIT.
      Configuration Parameters
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanTp_Extension.xdm.m4_1199</srcid><srcstatus/><internalId>1074</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/config/CanTp_Extension.xdm.m4_1837</srcid><srcstatus/><internalId>1082</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ReceiveMultiframe</srcid><srcstatus/><internalId>1462</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_TransmitMultiframe</srcid><srcstatus/><internalId>1466</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_IgnoreCF_DifferentTA</srcid><srcstatus/><internalId>1467</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_IgnoreFC_DifferentSA</srcid><srcstatus/><internalId>1469</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_IgnoreFC_DifferentTA</srcid><srcstatus/><internalId>1470</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.MetaData.AddresingFormats</srcid><srcstatus/><internalId>982</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>465</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00254</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Name CanTpNSa
      Parent Container CanTpNSa
      Description This parameter contains the transport protocol source
                  address value.
      Multiplicity 1
      Type EcucIntegerParamDef
      Range 0..255
      Default value --
      Post-Build Variant Value false
      Value Configuration Class
        Pre-compile time X All Variants
        Link time --
        Post-build time --
      Scope / Dependency scope: local
      </description>
      <comment>
      This is a configuration parameter requirement without functional specification.
      The behavior is covered by CanTp.EB.NPduNSaFiltering and CanTp.EB.FcNPduNSaFiltering.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.EB.CanTpNADescription.CanTpNSa</srcid><srcstatus/><internalId>824</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>466</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00284</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Container Name CanTpNAe
      Parent Container CanTpRxNSdu, CanTpTxNSdu
      Description This container is required for each RxNSdu and TxNSdu with
                  AddressingFormat CANTP_MIXED or CANTP_MIXED29BIT.
      Configuration Parameters
      </description>
      <comment>
      This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTp.MetaData.AddresingFormats</srcid><srcstatus/><internalId>982</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>467</internalId></specobject>

    <specobject>
      <id>CanTp.ECUC_CanTp_00285</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      Name CanTpNAe
      Parent Container CanTpNAe
      Description This parameter contains the transport protocol address
                  extension value.
      Multiplicity 1
      Type EcucIntegerParamDef
      Range 0..255
      Default value --
      Post-Build Variant Value false
      Value Configuration Class
        Pre-compile time X All Variants
        Link time --
        Post-build time --
      Scope / Dependency scope: local
      </description>
      <comment>
      This is a configuration parameter requirement without functional specification.
      The behavior is covered by CanTp.EB.NPduNAeFiltering and CanTp.EB.FcNPduNAeFiltering.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.EB.CanTpNADescription.CanTpNAe</srcid><srcstatus/><internalId>825</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>468</internalId></specobject>

    <specobject>
      <id>CanTp.SWS_CanTp_00327</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANTransportLayer.pdf, R20-11</source>
      <version>1</version>
      <description>
      These requirements are not applicable to this specification.
      </description>
      <comment>
      This requirement is informational only.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>469</internalId></specobject>

  </specobjects>
    <specobjects doctype="swurs">

 <!-- Autosar 4.0 TP API Reception -->
    <specobject>
         <id>CanTp.ASR40.StartOfReception</id>
         <status>rejected</status>
         <source>Specification of PDU Router V3.2.0</source>
         <creationdate>2012-08-07</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        UL shall provide an API function with the following signature:
        BufReq_ReturnType UL_[LL]StartOfReception
        (
          PduIdType RxPduId, 
          PduLengthType TpSduLength,
          PduLengthType *BufferSizePtr
        )
        UL: Upper layer module prefix - see related SWS.
        LL: Lower layer module prefix (optional) - see related SWS.
        RxPduId [in]: identifies the Rx connection
        TpSduLength [in]: length of the total message to be transported via this connection
        *BufferSizePtr [out]: available length of the reserved buffer
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        Requirement for upper layer. No implementation requirement for CanTp.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>470</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.StartOfReception.BUFREQ_OK</id>
         <status>rejected</status>
         <source>EB</source>
         <creationdate>2012-08-07</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        UL_[LL]StartOfReception() shall reserve a buffer for the 'RxPduId', set output parameter
        'BufferSizePtr' to the size of the reserved buffer and return BUFREQ_E_OK.
        Note: If a buffer has already been reserved for this 'RxPduId'
        it shall be cleared and stay reserved for this 'RxPduId'.
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        Requirement for upper layer. No implementation requirement for CanTp.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>471</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.StartOfReception.BUFREQ_E_NOT_OK</id>
         <status>rejected</status>
         <source>Specification of PDU Router V3.2.0</source>
         <creationdate>2012-08-07</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        UL_[LL]StartOfReception() shall perform the module-API specific DET checks (module 
        initialization, argument values) and return BUFREQ_E_NOT_OK if any check fails.
        UL_[LL]StartOfReception() shall discard the buffer if already reserved for this 'RxPduId'.
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        Requirement for upper layer. No implementation requirement for CanTp.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>472</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.StartOfReception.BUFREQ_E_OVFL</id>
         <status>rejected</status>
         <source>Specification of PDU Router V3.2.0</source>
         <creationdate>2012-08-07</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        UL_[LL]StartOfReception() shall set return BUFREQ_E_OVFL if the requested 'TpSduLength'
        exceeds the UL module's message length limitations (if available).
        UL_[LL]StartOfReception() shall discard the buffer if already reserved for this 'RxPduId'.
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        Requirement for upper layer. No implementation requirement for CanTp.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>473</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.StartOfReception.NoBuffer</id>
         <status>rejected</status>
         <source>AUTOSAR Bugzilla 52007</source>
         <creationdate>2012-08-07</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        If buffer allocation temporary fails for this 'RxPduId', then UL_[LL]StartOfReception()
        shall set output parameter 'buffersize' to 0 and return BUFREQ_OK.
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        Requirement for upper layer. No implementation requirement for CanTp.
        http://www.autosar.org/bugzilla/show_bug.cgi?id=52007
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>474</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.StartOfReception.BUFREQ_E_BUSY</id>
         <status>rejected</status>
         <source>AUTOSAR Bugzilla 52007</source>
         <creationdate>2012-08-07</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        UL_[LL]StartOfReception() shall never return BUFREQ_E_BUSY
        (see TpApi.UL.StartOfReception.NoBuffer instead).
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        Requirement for upper layer. No implementation requirement for CanTp.
        http://www.autosar.org/bugzilla/show_bug.cgi?id=52007
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>475</internalId></specobject>

      <specobject>
         <id>CanTp.EB.StartOfReception.BUFREQ_E_BUSY.LL</id>
         <status>approved</status>
         <source>EB</source>
         <creationdate>2012-10-04</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description> If UL_[LL]StartOfReception() accidentally returns
        BUFREQ_E_BUSY, the LL shall treat it like BUFREQ_OK with available
        buffer size 0U.
      </description>
         <comment>
        This requirement was introduced to stay compatible with previous
        UL implementations.
      </comment>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_BS_Unlimited</srcid><srcstatus/><internalId>1401</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.ASR40.SWS_CanTp_00082_1</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>21</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>476</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.CopyRxData</id>
         <status>rejected</status>
         <source>AUTOSAR Bugzilla 56021</source>
         <creationdate>2012-08-07</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        UL shall provide a API function with the following signature:
        BufReq_ReturnType UL_[LL]CopyRxData
        (
          PduIdType RxPduId, 
          const PduInfoType* PduInfoPtr, 
          PduLengthType* BufferSizePtr
        )
        UL: Upper layer module prefix - see related SWS.
        LL: Lower layer module prefix (optional) - see related SWS.
        RxPduId [in]: identifies the Rx connection
        PduInfoPtr [in]: payload and length the received pdu
        BufferSizePtr [out]: available length of the buffer (after copying the pdu to the buffer)
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        Requirement for upper layer. No implementation requirement for CanTp.
        http://www.autosar.org/bugzilla/show_bug.cgi?id=56021
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>477</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.CopyRxData.BUFREQ_E_NOT_OK</id>
         <status>rejected</status>
         <source>Specification of PDU Router V3.2.0</source>
         <creationdate>2012-08-07</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        UL_[LL]CopyRxData() shall return BUFREQ_E_NOT_OK if any of the module-API specific DET 
        checks (module initialization, argument values) fails.
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        Requirement for upper layer. No implementation requirement for CanTp.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>478</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.CopyRxData.BUFREQ_E_NOT_OK2</id>
         <status>rejected</status>
         <source>EB</source>
         <creationdate>2012-08-21</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        If UL_[LL]CopyRxData() is called and there is no reception already ongoing
        for the requested NPdu (see  ASR40.StartOfReception.BUFREQ_OK), then UL_[LL]CopyRxData()
        doesn't perform any further operation (beside Det reporting if required by the particular
        SWS) but returns BUFREQ_E_NOT_OK.
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        Requirement for upper layer. No implementation requirement for CanTp.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>479</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.CopyRxData.BufferAllocation</id>
         <status>rejected</status>
         <source>EB</source>
         <creationdate>2012-08-07</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        UL_[LL]CopyRxData() shall reserve a buffer if no buffer has been reserved for this 'RxPduId'.
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        Requirement for upper layer. No implementation requirement for CanTp.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>480</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.CopyRxData.BufferSize</id>
         <status>rejected</status>
         <source>EB</source>
         <creationdate>2012-08-07</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        UL_[LL]CopyRxData() shall return BUFREQ_OK and write the available size of the reserved
        buffer to output parameter 'BufferSizePtr' for this 'RxPduId'.
        If the 'PduInfoPtr-&gt;SduDataPtr' is NULL_PTR, no data shall be copied.
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        Requirement for upper layer. No implementation requirement for CanTp.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>481</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.CopyRxData.BufferNotReserved.1</id>
         <status>approved</status>
         <source>EB</source>
         <creationdate>2012-08-07</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
            If UL_[LL]CopyRxData() returns BUFREQ_E_NOT_OK when copying a number of bytes that does not
            exceed the available buffer size which was previously returned by UL_[LL]StartOfReception()
            or UL_[LL]CopyRxData(), CanTp shall abort the reception and report notification result
            E_NOT_OK.
         </description>
         <comment>
            - Needs tests for case of StartOfReception returning OK and subsequent CopyRxData returning
            NOT_OK.
            - All other cases are covered by CANTP271
         </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <!--
               Test cases:
               - SF: covered by CanTp.ASR40.CopyRxData.BufferNotReserved.4
               - FF: PduR_CanTpStartOfReception() returns BUFREQ_E_BUSY: Remains
               - FF: PduR_CanTpStartOfReception() returns BUFREQ_E_OK: TS_CANTP_30164
               - CF: covered by CanTp.SWS_CanTp_00271_1,1
            -->
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30164</srcid><srcstatus/><internalId>1257</internalId></linkedfrom></coveredby></needscov>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00271_1</srcid><srcstatus/><internalId>184</internalId></linkedfrom><linkedfrom><srcid>CanTp.ASR40.CopyRxData.BufferNotReserved.4</srcid><srcstatus/><internalId>487</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.SWS_CanTp_00084</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>187</internalId></provcov>
            <provcov>
               <linksto>CanTp.ASR40.CopyRxData.BufferNotReserved.3</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>486</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>482</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.CopyRxData.BufferNotReserved.2a</id>
         <status>approved</status>
         <source>EB</source>
         <creationdate>2012-08-07</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
            If UL_[LL]CopyRxData() returns BUFREQ_E_BUSY when copying a number of bytes that does not
            exceed the available buffer size which was previously returned by UL_[LL]StartOfReception(),
            CanTp shall abort the reception with notification result E_NOT_OK.
         </description>
         <comment>
            - Needs tests for case of StartOfReception returning OK and subsequent CopyRxData returning
               BUSY.
            - All other cases are covered by CANTP271
         </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <!-- Covered by CanTp.SWS_CanTp_00271_2,1 -->
            <!-- Covered by CanTp.ASR40.CopyRxData.BufferNotReserved.2c,1 -->
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.ASR40.CopyRxData.BufferNotReserved.2c</srcid><srcstatus/><internalId>485</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.SWS_CanTp_00084</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>187</internalId></provcov>
            <provcov>
               <linksto>CanTp.ASR40.CopyRxData.BufferNotReserved.3</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>486</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>483</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.CopyRxData.BufferNotReserved.2b</id>
         <status>approved</status>
         <source>EB</source>
         <creationdate>2012-08-07</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        If UL_[LL]CopyRxData() returns BUFREQ_E_BUSY when copying a number of bytes that does not
        exceed the available buffer size which was previously returned by UL_[LL]CopyRxData(),
        CanTp shall abort the reception with notification result E_NOT_OK.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_CONCURRENT_RX</srcid><srcstatus/><internalId>1347</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_RX_BUSY_CF</srcid><srcstatus/><internalId>1414</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.SWS_CanTp_00084</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>187</internalId></provcov>
            <provcov>
               <linksto>CanTp.ASR40.CopyRxData.BufferNotReserved.3</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>486</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>484</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.CopyRxData.BufferNotReserved.2c</id>
         <status>approved</status>
         <source>EB</source>
         <creationdate>2013-04-09</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        If the function PduR_CanTpCopyRxData() called for getting enough buffer for next block
        returns BUFREQ_E_BUSY, the CanTp module shall suspend the N-SDU
        reception by sending the next Flow Control N-PDU with status WAIT (i.e. FC(WT)).
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30099</srcid><srcstatus/><internalId>1222</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_N_Br_CFEOB</srcid><srcstatus/><internalId>1352</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.ASR40.CopyRxData.BufferNotReserved.2a</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>483</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>485</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.CopyRxData.BufferNotReserved.3</id>
         <status>approved</status>
         <source>EB</source>
         <creationdate>2012-08-07</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        If UL_[LL]CopyRxData() does not return BUFREQ_OK when copying a number of bytes that does
        not exceed the available buffer size which was previously returned by
        UL_[LL]StartOfReception() or UL_[LL]CopyRxData() and the internal buffer is not large enough
        to hold the received data bytes, CanTp shall abort the reception with notification result
        E_NOT_OK.
      </description>
         <comment>
        This requirement is only valid for consecutive frames. CanTp provides a buffer for first
        frame and single frames.
        Consecutive frames will not be buffered internally in the module during a block transfer.
        Rational:
        Transmission of a block will only be done when upper layer provides enough buffer for the
        whole block at the beginning of the transmission.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
        <!--
          Covered by CanTp.ASR40.CopyRxData.BufferNotReserved.1 for return value BUFREQ_E_NOT_OK
          Covered by CanTp.ASR40.CopyRxData.BufferNotReserved.2a for return value BUFREQ_E_BUSY
          Covered by CanTp.ASR40.CopyRxData.BufferNotReserved.2b for return value BUFREQ_E_BUSY
        -->
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.ASR40.CopyRxData.BufferNotReserved.1</srcid><srcstatus/><internalId>482</internalId></linkedfrom><linkedfrom><srcid>CanTp.ASR40.CopyRxData.BufferNotReserved.2a</srcid><srcstatus/><internalId>483</internalId></linkedfrom><linkedfrom><srcid>CanTp.ASR40.CopyRxData.BufferNotReserved.2b</srcid><srcstatus/><internalId>484</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.SWS_CanTp_00084</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>187</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>486</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.CopyRxData.BufferNotReserved.4</id>
         <status>approved</status>
         <source>EB</source>
         <creationdate>2013-03-13</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        If UL_[LL]CopyRxData() returns BUFREQ_E_NOT_OK while requesting buffer for SF,
        CanTp shall abort the reception and report notification result E_NOT_OK.
      </description>
         <comment>
        Needs test for case of StartOfReception returning OK and subsequent CopyRxData returning
        NOT_OK
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
        <!--
          Test cases:
          - PduR_CanTpStartOfReception() returns BUFREQ_E_BUSY: Remains (Minor)
          - PduR_CanTpStartOfReception() returns BUFREQ_E_OK: TS_CANTP_RxSF_NOTOK, TS_CANTP_30318
        -->
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30318</srcid><srcstatus/><internalId>1255</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_RxSF_NOTOK</srcid><srcstatus/><internalId>1361</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.ASR40.CopyRxData.BufferNotReserved.1</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>482</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>487</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.CopyRxData.BUFREQ_E_BUSY</id>
         <status>rejected</status>
         <source>EB</source>
         <creationdate>2012-08-07</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        UL_[LL]CopyRxData() shall return BUFREQ_E_BUSY and write the currently free buffer size
        to output parameter 'BufferSizePtr' if the buffer available is smaller than 
        'PduInfoPtr-&gt;SduLength'. Note: No data shall be copied.
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        Requirement for upper layer. No implementation requirement for CanTp.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>488</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.CopyRxData.BUFREQ_OK</id>
         <status>rejected</status>
         <source>EB</source>
         <creationdate>2012-08-07</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        UL_[LL]CopyRxData() shall copy the data passed at PduInfo into the reserved buffer and
        write the remaining size (after copying) of the reserved buffer to output parameter
        'BufferSizePtr' and return BUFREQ_OK.
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        Requirement for upper layer. No implementation requirement for CanTp.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>489</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.RxIndication</id>
         <status>rejected</status>
         <source>Specification of PDU Router V3.2.0</source>
         <creationdate>2012-08-07</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        UL shall provide an API function with the following signature:
        void UL_[LL]RxIndication(PduIdType RxPduId, Std_ReturnType Result)
        UL: Upper layer module prefix - see related SWS.
        LL: Lower layer module prefix (optional) - see related SWS.
        RxPduId [in]: identifies the Rx connection
        Result [in]: connection transfer result
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        Requirement for upper layer. No implementation requirement for CanTp.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>490</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.RxIndciation.InvalidId</id>
         <status>rejected</status>
         <source>EB</source>
         <creationdate>2012-08-07</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        If UL_[LL]RxIndication() is called with an invalid RxPduId:
         - RxPduId unknown
         - no receive session ongoing for this RxPduId
        then the function shall be exited without any further operation.
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        Requirement for upper layer. No implementation requirement for CanTp.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>491</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.RxIndication.BufferDeallocation</id>
         <status>rejected</status>
         <source>EB</source>
         <creationdate>2012-08-07</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        Calling UL_[LL]RxIndication shall discard the buffer for 'RxPduId'.
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        Requirement for upper layer. No implementation requirement for CanTp.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>492</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.RxIndication.Precondition</id>
         <status>approved</status>
         <source>AUTOSAR Bugzilla 53674 </source>
         <creationdate>2012-08-07</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        LL shall call UL_[LL]RxIndication() only, if a previous call to UL_[LL]StartOfReception()
        returned BUFREQ_OK.
      </description>
         <comment>
        http://www.autosar.org/bugzilla/show_bug.cgi?id=53674
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.ASR40.RxIndication.Precondition1</srcid><srcstatus/><internalId>494</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>493</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.RxIndication.Precondition1</id>
         <status>approved</status>
         <source>EB</source>
         <creationdate>2012-08-07</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        LL shall call UL_[LL]RxIndication() only, if a previous call to UL_[LL]StartOfReception()
        returned BUFREQ_OK or BUFREQ_E_BUSY.
      </description>
         <comment>
        This requirement replaces CanTp.ASR40.RxIndication.Precondition for compatibility reasons
        for upper layer not implementing CanTp.ASR40.StartOfReception.BUFREQ_E_BUSY so far.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30086</srcid><srcstatus/><internalId>1224</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_BS_Unlimited</srcid><srcstatus/><internalId>1401</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_31104</srcid><srcstatus/><internalId>1417</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30406</srcid><srcstatus/><internalId>1475</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.ASR40.RxIndication.Precondition</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>493</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>494</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.Rx.BufferHandling1</id>
         <status>rejected</status>
         <source>EB</source>
         <creationdate>2012-08-07</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        If a buffer is reserved for an 'RxPduId' using UL_[LL]StartOfReception() or 
        UL_[LL]CopyRxData() it must be guaranteed and used exclusively for this 'RxPduId'.
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        Requirement for upper layer. No implementation requirement for CanTp.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>495</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.Rx.BufferHandling2</id>
         <status>rejected</status>
         <source>EB</source>
         <creationdate>2012-08-07</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        The size of the available buffer for an 'RxPduId' shall decrease only by calling
        UL_[LL]CopyRxData() for the same 'RxPduId'.
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        Requirement for upper layer. No implementation requirement for CanTp.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>496</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.Rx.BufferHandling3</id>
         <status>rejected</status>
         <source>EB</source>
         <creationdate>2012-08-07</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        The size of the available buffer for an 'RxPduId' may increase without any intervention of
        the Tp modules (due to the upper layer consuming the data).
        (E.g.
          - buffer gets filled during reception
          - PduR starts transmission of buffer on another connection (Tp-gateway)
          - available buffer increases as data has been transmitted
        )
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        Requirement for upper layer. No implementation requirement for CanTp.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>497</internalId></specobject>

      <!-- Autosar 4.0 TP API Transmission -->
    <specobject>
         <id>CanTp.ASR40.Transmit</id>
         <status>approved</status>
         <source>Specification of PDU Router V3.2.0</source>
         <creationdate>2012-08-21</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        LL shall provide an API function with the following signature:
        Std_ReturnType LL_Transmit(PduIdType TxPduId, const PduInfoType* PduInfoPtr)
        LL: Lower layer module prefix - see related SWS.
        TxPduId [in]: identifies the Tx connection
        PduInfoPtr [in]: Information about the NPdu to transmit.
                            PduInfoPtr-&gt;SduLength contains the total NSdu length.
                            PduInfoPtr-&gt;SduDataPtr shall not be used.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
        <!-- Covered by the syntax requirement CanTp.SWS_CanTp_00212 -->
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00212</srcid><srcstatus/><internalId>43</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>498</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.Transmit.E_NOT_OK1</id>
         <status>approved</status>
         <source>Specification of PDU Router V3.2.0</source>
         <creationdate>2012-08-21</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        LL_Transmit() shall perform the module-API specific DET checks (module initialization,
        argument values) and return E_NOT_OK if any check fails.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30039</srcid><srcstatus/><internalId>1186</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30175</srcid><srcstatus/><internalId>1288</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.SWS_CanTp_00294</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>336</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>499</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.Transmit.E_NOT_OK2</id>
         <status>approved</status>
         <source>EB</source>
         <creationdate>2012-08-21</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        If LL_Transmit() is called and there is a transmission already ongoing
        (see CanTp.ASR40.Transmit.Session) for the requested NPdu, then LL_Transmit doesn't
        perform any further operation but returns E_NOT_OK.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30245</srcid><srcstatus/><internalId>1247</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>500</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.Transmit.E_OK</id>
         <status>approved</status>
         <source>Specification of PDU Router V3.2.0</source>
         <creationdate>2012-08-21</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        LL_Transmit() returns E_OK if it accepts the transmit request.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
        <!--
          Test cases:
          SF transmission (normal addressing): TS_CANTP_30048
          SF transmission (mixed addressing, not after initialization): Remains
          SF transmission (extended addressing): Remains
          Segmented transmission (normal addressing): TS_CANTP_30053
          Segmented transmission (mixed addressing): Remains
          Segmented transmission (extended addressing, not after initialization): Remains
        -->
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_RequestNewTransmissionFromTxConfirmation_SF</srcid><srcstatus/><internalId>1180</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30048</srcid><srcstatus/><internalId>1193</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30053</srcid><srcstatus/><internalId>1196</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>501</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.Transmit.Session</id>
         <status>approved</status>
         <source>EB</source>
         <creationdate>2012-08-21</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        A transmit session for a specific NPdu starts with LL_Transmit() returning E_OK and ends
        with the related  UL_[LL]TxConfirmation() call.
        If LL_Transmit() returns E_OK, the LL must finish the transmission session calling
        UL_[LL]TxConfirmation(), no matter of the transmission result.
        If LL_Transmit() returns a value different from E_OK, UL_[LL]TxConfirmation() must not be
        called.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30057</srcid><srcstatus/><internalId>1201</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30077</srcid><srcstatus/><internalId>1237</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_TimeoutFF</srcid><srcstatus/><internalId>1238</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30245</srcid><srcstatus/><internalId>1247</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30066</srcid><srcstatus/><internalId>1251</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30343</srcid><srcstatus/><internalId>1311</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>502</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.CopyTxData</id>
         <status>rejected</status>
         <source>Specification of PDU Router V3.2.0</source>
         <creationdate>2012-08-07</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        UL shall provide a API function with the following signature:
        BufReq_ReturnType UL_[LL]CopyTxData
        (
          PduIdType TxPduId, 
          PduInfoType* PduInfoPtr, 
          RetryInfoType* RetryInfoPtr, 
          PduLengthType* AvailableDataPtr
        )
        UL: Upper layer module prefix - see related SWS.
        LL: Lower layer module prefix (optional) - see related SWS.
        TxPduId [in]: identifies the Tx connection.
        PduInfoPtr [in/out]: payload pointer to store transmit data to [out] and length of the
                             required transmit payload [in].
        RetryInfoPtr [in]: payload data retry handling information.
        AvailableDataPtr [out]: tx-payload currently available from UL after copy operation has been
                                performed.
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        Requirement for upper layer. No implementation requirement for CanTp.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>503</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.CopyTxData.BUFREQ_NOT_OK1</id>
         <status>rejected</status>
         <source>Specification of PDU Router V3.2.0</source>
         <creationdate>2012-08-21</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        UL_[LL]CopyTxData() shall perform the module-API specific DET checks (module initialization,
        argument values) and return BUFREQ_E_NOT_OK if any check fails.
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        Requirement for upper layer. No implementation requirement for CanTp.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>504</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.CopyTxData.BUFREQ_NOT_OK2</id>
         <status>rejected</status>
         <source>EB</source>
         <creationdate>2012-08-21</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        If UL_[LL]CopyTxData() is called and there is no transmission already ongoing
        for the requested NPdu (see ASR40.Transmit.Session), then UL_[LL]CopyTxData() doesn't
        perform any further operation (beside Det reporting if required by the particular SWS) but
        returns BUFREQ_E_NOT_OK.
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        Requirement for upper layer. No implementation requirement for CanTp.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>505</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.CopyTxData.BufferHandling</id>
         <status>rejected</status>
         <source>EB</source>
         <creationdate>2012-08-21</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
         If UL_[LL]CopyTxData() shall maintain a buffer with transmit data (tx-buffer).
         It shall mark the position of payload data already transmitted within this tx-buffer.
         It shall be possible to rewind the mark back to already transmitted data.
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        Requirement for upper layer. No implementation requirement for CanTp.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>506</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.CopyTxData.Retry</id>
         <status>rejected</status>
         <source>EB</source>
         <creationdate>2012-08-21</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        If RetryInfoPtr-&gt;TpDataState == TP_RETRY, the internal
        transmitted data mark shall be rewinded by RetryInfoPtr-&gt;TxTpDataCnt bytes.
        All data before the new rewinded mark may be discarded (since retry is an implicit
        confirmation for all data before the new rewinded mark).
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        Requirement for upper layer. No implementation requirement for CanTp.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>507</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.CopyTxData.RetryError</id>
         <status>rejected</status>
         <source>AUTOSAR Bugzilla 52897</source>
         <creationdate>2012-08-21</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        If  RetryInfoPtr-&gt;TpDataState == TP_RETRY, and
        RetryInfoPtr-&gt;TxTpDataCnt is larger than the available payload data prior to the current
        transmitted data mark
	      UL_[LL]CopyTxData() shall return BUFREQ_E_NOT_OK.
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        Requirement for upper layer. No implementation requirement for CanTp.
        http://www.autosar.org/bugzilla/show_bug.cgi?id=52897
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>508</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.CopyTxData.NoData</id>
         <status>rejected</status>
         <source>AUTOSAR Bugzilla 52897</source>
         <creationdate>2012-08-21</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        If available payload data within the tx-buffer measured from the mark of transmitted payload
        is smaller than PduInfoPtr-&gt;SduLength, write the available data length to AvailableDataPtr
        and return BUFREQ_E_BUSY.
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        Requirement for upper layer. No implementation requirement for CanTp.
        http://www.autosar.org/bugzilla/show_bug.cgi?id=52897
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>509</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.CopyTxData.ConfirmData1</id>
         <status>rejected</status>
         <source>AUTOSAR Bugzilla 52897</source>
         <creationdate>2012-08-21</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        If RetryInfoPtr-&gt;TpDataState == TP_DATACONF, the
        internal tx-buffer from start until the mark of already transmitted data may be discarded.
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        Requirement for upper layer. No implementation requirement for CanTp.
        http://www.autosar.org/bugzilla/show_bug.cgi?id=52897
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>510</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.CopyTxData.ConfirmData2</id>
         <status>rejected</status>
         <source>AUTOSAR Bugzilla 52897</source>
         <creationdate>2012-08-21</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        If RetryInfoPtr == NULL_PTR, the
        data within the tx-buffer from start until the mark of already transmitted data may be
        discarded.
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        Requirement for upper layer. No implementation requirement for CanTp.
        http://www.autosar.org/bugzilla/show_bug.cgi?id=52897
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>511</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.CopyTxData.CopyData</id>
         <status>rejected</status>
         <source>AUTOSAR Bugzilla 52897</source>
         <creationdate>2012-08-21</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        UL_[LL]CopyTxData() shall copy PduInfoPtr-&gt;SduLength bytes of payload from
        the internal tx-buffer (current mark) to PduInfoPtr-&gt;SduDataPtr and forward the internal
        mark of transmitted payload by PduInfoPtr-&gt;SduLength bytes.
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        Requirement for upper layer. No implementation requirement for CanTp.
        http://www.autosar.org/bugzilla/show_bug.cgi?id=52897
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>512</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.CopyTxData.AvailableData</id>
         <status>rejected</status>
         <source>AUTOSAR Bugzilla 52897</source>
         <creationdate>2012-08-21</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        UL_[LL]CopyTxData() shall write the amount of payload within the tx-buffer which has
        not been copied yet to AvailableDatatPtr and return BUFREQ_OK.
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        Requirement for upper layer. No implementation requirement for CanTp.
        http://www.autosar.org/bugzilla/show_bug.cgi?id=52897
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>513</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.CopyTxData.RequestFirstData</id>
         <status>approved</status>
         <source>AUTOSAR Bugzilla 59995</source>
         <creationdate>2012-08-21</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        For each transmission the first call of UL_[LL]CopyTxData() shall be performed with
        info-&gt;SduDataPtr = NULL_PTR and info-&gt;SduLength = 0 to get the amount of available data.
      </description>
         <comment>
        Requirement was introduced due to known issue ASCCANTP-913.
        http://www.autosar.org/bugzilla/show_bug.cgi?id=59995
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_Con02_FirstTxDataRequest</srcid><srcstatus/><internalId>1383</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>514</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.CopyTxData.RequestData</id>
         <status>approved</status>
         <source>AUTOSAR Bugzilla 59995</source>
         <creationdate>2012-08-21</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        The lower layer shall only request an amount of data smaller or equal as announced by
        AvailableDatatPtr of the last call of UL_[LL]CopyTxData().
      </description>
         <comment>
        Requirement was introduced due to known issue ASCCANTP-913.
        http://www.autosar.org/bugzilla/show_bug.cgi?id=59995
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_Con02_TxDataRequest</srcid><srcstatus/><internalId>1385</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>515</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.CopyTxData.RequestMoreData</id>
         <status>approved</status>
         <source>AUTOSAR Bugzilla 59995</source>
         <creationdate>2012-08-21</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        If at the moment no data are available to transmit (AvailableDatatPtr = 0 of the last
        call of UL_[LL]CopyTxData()), the module shall call UL_[LL]CopyTxData() with
        info-&gt;SduDataPtr = NULL_PTR and info-&gt;SduLength = 0.
      </description>
         <comment>
        Requirement was introduced due to known issue ASCCANTP-913.
        http://www.autosar.org/bugzilla/show_bug.cgi?id=59995
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_Con02_TxNoDataRequest</srcid><srcstatus/><internalId>1384</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_Con02_TxNoDataAvailable</srcid><srcstatus/><internalId>1386</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>516</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.TxConfirmation</id>
         <status>rejected</status>
         <source>Specification of PDU Router V3.2.0</source>
         <creationdate>2012-08-07</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        UL shall provide an API function with the following signature:
        void UL_[LL]TxConfirmation(PduIdType TxPduId, Std_ReturnType Result)
        UL: Upper layer module prefix - see related SWS.
        LL: Lower layer module prefix (optional) - see related SWS.
        TxPduId [in]: identifies the Tx connection
        Result [in]: connection transfer result
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        Requirement for upper layer. No implementation requirement for CanTp.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>517</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.TxConfirmation.InvalidId</id>
         <status>rejected</status>
         <source>EB</source>
         <creationdate>2012-08-07</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        If UL_[LL]TxConfirmation() is called with an invalid TxPduId:
         - TxPduId unknown
         - no transmission session ongoing for this TxPduId
        then the function shall be exited without any further operation (beside Det reporting if
        required by the particular SWS).
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        Requirement for upper layer. No implementation requirement for CanTp.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>518</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.TxConfirmation.BufferDeallocation</id>
         <status>rejected</status>
         <source>EB</source>
         <creationdate>2012-08-07</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        The LL shall call UL_[LL]TxConfirmation() when finishing an ongoing transmission.
        The result of the transmission is passed as Result.
        All tx-buffers shall be discarded before exiting UL_[LL]TxConfirmation.
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        Requirement for upper layer. No implementation requirement for CanTp.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>519</internalId></specobject>
      <!-- Autosar 4.0 TP API Cancel/Change -->

    <specobject>
         <id>CanTp.ASR40.CancelReceive</id>
         <status>approved</status>
         <source>Specification of CAN Transport Layer V4.0.0</source>
         <creationdate>2012-08-07</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        UL shall provide an API function with the following signature:
        Std_ReturnType LL_CancelReceive(PduIdType RxPduId)
        LL: Lower layer module prefix - see related SWS.
        RxPduId [in]: identifies the Rx connection
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
        <!-- Covered by CanTp.ASR40.SWS_CanTp_00257 -->
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00257</srcid><srcstatus/><internalId>50</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>520</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.CancelReceive.E_NOT_OK</id>
         <status>approved</status>
         <source>Specification of CAN Transport Layer V4.0.0</source>
         <creationdate>2012-08-07</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        LL_CancelReceive() shall perform the module-API specific DET checks (module initialization,
        argument values) and return E_NOT_OK if any check fails.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30039</srcid><srcstatus/><internalId>1186</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_RCV_CANCL_DET</srcid><srcstatus/><internalId>1334</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>521</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.CancelReceive.E_OK</id>
         <status>approved</status>
         <source>AUTOSAR Bugzilla 52106</source>
         <creationdate>2012-08-07</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        LL_CancelReceive() shall cancel the reception.
        If the request has been accepted E_OK shall be returned. In any other case return E_NOT_OK.
      </description>
         <comment>
        http://www.autosar.org/bugzilla/show_bug.cgi?id=52106
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
        <!-- Cases returning E_OK -->
        <!-- Covered by CanTp.SWS_CanTp_00261 -->
        <!-- Cases returning E_NOT_OK -->
        <!-- Covered by CanTp.ASR40.CancelReceive.E_NOT_OK -->
        <!-- Covered by CanTp.EB.RxCancellation_WaitTxConfirmation -->
        <!-- Covered by CanTp.SWS_CanTp_00262_1 -->
        <!-- Covered by CanTp.SWS_CanTp_00262_2 -->
        <!-- Covered by CanTp.ASR40.SWS_CanTp_00260_1 -->
        <!-- Covered by CanTp.ASR40.SWS_CanTp_00260_2 -->
        <!-- Covered by CanTp.Design.ChannelLock.RxCancellation -->
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00260_1</srcid><srcstatus/><internalId>52</internalId></linkedfrom><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00260_2</srcid><srcstatus/><internalId>53</internalId></linkedfrom><linkedfrom><srcid>CanTp.Design.ChannelLock.RxCancellation</srcid><srcstatus/><internalId>108</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00261</srcid><srcstatus/><internalId>373</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00262_1</srcid><srcstatus/><internalId>375</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00262_2</srcid><srcstatus/><internalId>376</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.RxCancellation_WaitTxConfirmation</srcid><srcstatus/><internalId>595</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>522</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.CancelReceive.RxIndication</id>
         <status>approved</status>
         <source>AUTOSAR Bugzilla 52106</source>
         <creationdate>2012-08-07</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        If the receive connection has been aborted by previously calling LL_CancelReceive() and
        the Tp-statemachine has reached it's idle state, report 
        UL_[LL]RxIndication(Id,E_NOT_OK).
      </description>
         <comment>
        http://www.autosar.org/bugzilla/show_bug.cgi?id=52106
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_RCV_CANCL_OK1</srcid><srcstatus/><internalId>1337</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_RCV_CANCL_OK2</srcid><srcstatus/><internalId>1338</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_40088</srcid><srcstatus/><internalId>1634</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_40100</srcid><srcstatus/><internalId>1635</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>523</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.CancelTransmit</id>
         <status>approved</status>
         <source>Specification of CAN Transport Layer V4.0.0</source>
         <creationdate>2012-08-07</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        UL shall provide an API function with the following signature:
        Std_ReturnType LL_CancelTransmit(PduIdType TxPduId)
        LL: Lower layer module prefix - see related SWS.
        TxPduId [in]: identifies the Tx connection
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
        <!-- Covered by CanTp.ASR40.SWS_CanTp_00246 -->
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00246</srcid><srcstatus/><internalId>45</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>524</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.CancelTransmit.E_NOT_OK</id>
         <status>approved</status>
         <source>Specification of CAN Transport Layer V4.0.0</source>
         <creationdate>2012-08-07</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        LL_CancelTransmit() shall perform the module-API specific DET checks (module initialization,
        argument values) and return E_NOT_OK if any check fails.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30039</srcid><srcstatus/><internalId>1186</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_CancelTxReq_DetParamId</srcid><srcstatus/><internalId>1320</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.ASR40.CancelTransmit.E_OK</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>526</internalId></provcov>
            <provcov>
               <linksto>CanTp.SWS_CanTp_00294</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>336</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>525</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.CancelTransmit.E_OK</id>
         <status>approved</status>
         <source>AUTOSAR Bugzilla 52106</source>
         <creationdate>2012-08-07</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        LL_CancelTransmit() shall cancel the transmission.
        If the request has been accepted E_OK shall be returned. In any other case return E_NOT_OK.
      </description>
         <comment>
        http://www.autosar.org/bugzilla/show_bug.cgi?id=52106
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30366</srcid><srcstatus/><internalId>1326</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30365</srcid><srcstatus/><internalId>1328</internalId></linkedfrom></coveredby></needscov>
            <!-- Cases returning E_NOT_OK will be covered by other more specific requirements. -->

        <!-- Covered by CanTp.EB.TxCancellation_WaitTxConfirmation -->
        <!-- Covered by CanTp.ASR40.CancelTransmit.E_NOT_OK -->
        <!-- Covered by CanTp.EB.TxCancellation_WaitForFC -->
        <!-- Covered by CanTp.Design.ChannelLock.TxCancellation -->
        <!-- Covered by CanTp.ASR40.SWS_CanTp_00254_1 -->
        <!-- Covered by CanTp.ASR40.SWS_CanTp_00254_2 -->
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00254_1</srcid><srcstatus/><internalId>48</internalId></linkedfrom><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00254_2</srcid><srcstatus/><internalId>49</internalId></linkedfrom><linkedfrom><srcid>CanTp.Design.ChannelLock.TxCancellation</srcid><srcstatus/><internalId>109</internalId></linkedfrom><linkedfrom><srcid>CanTp.ASR40.CancelTransmit.E_NOT_OK</srcid><srcstatus/><internalId>525</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.TxCancellation_WaitForFC</srcid><srcstatus/><internalId>593</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.TxCancellation_WaitTxConfirmation</srcid><srcstatus/><internalId>594</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>526</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.CancelTransmit.TxConfirmation</id>
         <status>approved</status>
         <source>AUTOSAR Buzilla 52106</source>
         <creationdate>2012-08-07</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        If the transmit connection has been aborted by previously calling LL_CancelTransmit() and
        the Tp-statemachine has reached it's idle state, report
        UL_[LL]TxConfirmation(Id,E_NOT_OK).
      </description>
         <comment>
        http://www.autosar.org/bugzilla/show_bug.cgi?id=52106
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30367</srcid><srcstatus/><internalId>1319</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30366</srcid><srcstatus/><internalId>1326</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30365</srcid><srcstatus/><internalId>1328</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30362</srcid><srcstatus/><internalId>1329</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>527</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.ChangeParameter</id>
         <status>approved</status>
         <source>Specification of CAN Transport Layer V4.0.0</source>
         <creationdate>2012-08-07</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        UL shall provide an API function with the following signature:
        Std_ReturnType LL_ChangeParameter(PduIdType Id, TPParameterType parameter, uint16 value)
        LL: Lower layer module prefix - see related SWS.
        id [in]: identifies the Tx connection
        parameter [in]: parameter to be changed
        value [in]: value the parameter shall be set to
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
        <!-- Covered by CanTp.ASR40.SWS_CanTp_00302 -->
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.ASR40.SWS_CanTp_00302</srcid><srcstatus/><internalId>54</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>528</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.ChangeParameter.E_NOT_OK</id>
         <status>approved</status>
         <source>Specification of CAN Transport Layer V4.0.0</source>
         <creationdate>2012-08-07</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        LL_ChangeParameter() shall perform the module-API specific DET checks (module initialization,
        argument values) and return E_NOT_OK if any check fails.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30039</srcid><srcstatus/><internalId>1186</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_CHANGEPARA_INV_PDUID</srcid><srcstatus/><internalId>1296</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_CHANGEPARA_INV_TPID</srcid><srcstatus/><internalId>1297</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_CHANGEPARA_BSVAL</srcid><srcstatus/><internalId>1298</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.SWS_CanTp_00294</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>336</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>529</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.ChangeParameter.E_OK</id>
         <status>approved</status>
         <source>EB</source>
         <creationdate>2012-08-07</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        LL_ChangeParameter() shall change the 'parameter' to the 'value' synchronously.
        If the change has been performed E_OK shall be returned. In any other case return E_NOT_OK.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_Conf07003_AllowChangeParameter</srcid><srcstatus/><internalId>1430</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>530</internalId></specobject>
    
    
    
      <specobject>
         <id>CanTp.ASR40.ReadParameter</id>
         <status>approved</status>
         <source>Specification of CAN Transport Layer V4.0.0</source>
         <creationdate>2017-06-02</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        UL shall provide an API function with the following signature:
        Std_ReturnType LL_ReadParameter(PduIdType Id, TPParameterType parameter, uint16* value)
        LL: Lower layer module prefix - see related SWS.
        id [in]: identifies the received N_SDU
        parameter [in]: parameter from which the value has to be read
        value [in]: pointer where the parameter value will be provided
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
        <!-- Covered by CanTp.SWS_CanTp_00323 -->
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00323</srcid><srcstatus/><internalId>386</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>531</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.ReadParameter.E_NOT_OK</id>
         <status>approved</status>
         <source>Specification of CAN Transport Layer V4.0.0</source>
         <creationdate>2017-06-02</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        LL_ReadParameter() shall perform the module-API specific DET checks (module initialization,
        argument values) and return E_NOT_OK if any check fails.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30039</srcid><srcstatus/><internalId>1186</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_READPARA_INV_PDUID</srcid><srcstatus/><internalId>1302</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_READPARA_INV_PARAMETER</srcid><srcstatus/><internalId>1303</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.SWS_CanTp_00294</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>336</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>532</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.ReadParameter.E_OK</id>
         <status>approved</status>
         <source>EB</source>
         <creationdate>2017-06-02</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        LL_ReadParameter() shall read the 'parameter' synchronously.
        If the changed value of "parameter" has been stored in "value", E_OK shall be returned. 
        In any other case return E_NOT_OK.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00323_E_OK_BS</srcid><srcstatus/><internalId>387</internalId></linkedfrom><linkedfrom><srcid>CanTp.SWS_CanTp_00323_E_OK_STmin</srcid><srcstatus/><internalId>388</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>533</internalId></specobject>
    
      <!-- CanTp specific requirements for Tx-API usage -->
    <specobject>
         <id>CanTp.ASR40.TxSTF_1</id>
         <status>approved</status>
         <source>EB</source>
         <creationdate>2012-08-31</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        If CanTp_Transmit is called, CanTp shall call PduR_CanTpCopyTxData() to fill the FF with
        data.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30206</srcid><srcstatus/><internalId>1252</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>534</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.TxSTF_2</id>
         <status>approved</status>
         <source>EB</source>
         <creationdate>2012-08-31</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        If PduR_CanTpCopyTxData() for the FF returned BUFREQ_E_BUSY
        perform the transmission with the next CanTp_Mainfunction() invocation.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30361</srcid><srcstatus/><internalId>1325</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30372</srcid><srcstatus/><internalId>1332</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>535</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.TxCF</id>
         <status>approved</status>
         <source>EB</source>
         <creationdate>2012-08-31</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        After CTS fill CF Tx-Pdus with PduR_CanTpCopyTxData()
        -) as long as data copied is less than BfS
        -) as long PduR_CanTpCopyTxData() returns BUFREQ_OK and AvailableBuffer is larger than 0.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30206</srcid><srcstatus/><internalId>1252</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>536</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.TxCFEOB</id>
         <status>rejected</status>
         <source>EB</source>
         <creationdate>2012-08-31</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        A CFEOB shall be send if
        -) data copied is equal to BfS
        -) if  PduR_CanTpCopyTxData() returns BUFREQ_E_BUSY (re-call PduR_CanTpCopyTxData()
           considering the AvailableBuffer) or AvailableBuffer is equal to 0.
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        Requirement does not make sense for CanTp since
        ISO 15765 does not make a distinction between last CF of a block and other CFs.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>537</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.TxLF</id>
         <status>rejected</status>
         <source>EB</source>
         <creationdate>2012-08-31</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        A LF shall be send if the remaining data fits into the LF-Pdu and BfS is respected.
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        Requirement does not make sense for CanTp since
        ISO 15765 does not specify a LF.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>538</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.TxNoRetry</id>
         <status>approved</status>
         <source>EB</source>
         <creationdate>2012-08-31</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        CanTp shall pass NULL_PTR to PduR_CanTpCopyTxData() argument
        RetryInfoPtr.
      </description>
         <comment>
        CanTp shall always pass NULL_PTR to to PduR_CanTpCopyTxData() argument
        RetryInfoPtr.
        ISO 15765 does not support retransmission of already sent data.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_RequestNewTransmissionFromTxConfirmation_SF</srcid><srcstatus/><internalId>1180</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30048</srcid><srcstatus/><internalId>1193</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>539</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.TxDATACONF</id>
         <status>rejected</status>
         <source>EB</source>
         <creationdate>2012-08-31</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        For acknowledged transmission CanTp shall pass TP_DATACONF to PduR_CanTpCopyTxData()
        argument RetryInfoPtr for the first CF/CFEOB/LF after a received FC-CTS.
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        Requirement does not make sense for CanTp since
        ISO 15765 does not support retransmission of already sent data.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>540</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.TxRETRY</id>
         <status>rejected</status>
         <source>EB</source>
         <creationdate>2012-08-31</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        If FC-RETRY is received for acknowledged transmission CanTp shall pass TP_RETRY and the
        negative offset to the current copy location calculated from the BP received within the FC
        to PduR_CanTpCopyTxData() argument RetryInfoPtr for the next CF/CFEOB/LF to transmit.
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        Requirement does not make sense for CanTp since
        ISO 15765 does not support retransmission of already sent data.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>541</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.CopyTxData_Error</id>
         <status>approved</status>
         <source>EB</source>
         <creationdate>2012-08-31</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        If PduR_CanTpCopyTxData returns a value different from BUFREQ_OK or BUFREQ_E_BUSY, CanTp
        shall wait for pending transmission confirmations and finally call
        PduR_CanTpTxconfirmation(E_NOT_OK) and reset the statemachine.
      </description>
         <comment>
        Phrase " wait for pending transmission confirmation" is not applicable.
        Rational:
        A call of PduR_CanTpCopyTxData will only be performed before sending a frame. At this
        time the channel does not have any outstanding transmission confirmation.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_CopyTxData_NOT_OK</srcid><srcstatus/><internalId>1362</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>542</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.RxNoBuffer</id>
         <status>approved</status>
         <source>EB</source>
         <creationdate>2012-08-31</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        If PduR_CanTpCopyRxData() returns BUFREQ_E_BUSY or the AvailableBuffer is 0 during a block
        transfer (sender is still allowed to send further data), then the CanTp shall call
        PduR_CanTpRxIndication(E_NOT_OK).
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.ASR40.RxNoBuffer_1</srcid><srcstatus/><internalId>544</internalId></linkedfrom><linkedfrom><srcid>CanTp.ASR40.RxNoBuffer_2</srcid><srcstatus/><internalId>545</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>543</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.RxNoBuffer_1</id>
         <status>approved</status>
         <source>EB</source>
         <creationdate>2013-09-09</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
            If PduR_CanTpCopyRxData() returns BUFREQ_E_BUSY during a block
            transfer (sender is still allowed to send further data), then the CanTp shall call
            PduR_CanTpRxIndication(E_NOT_OK).
         </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_FailedBlockReception_1</srcid><srcstatus/><internalId>1235</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_FailedBlockReception_2</srcid><srcstatus/><internalId>1236</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_RX_BUSY_CF</srcid><srcstatus/><internalId>1414</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.ASR40.RxNoBuffer</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>543</internalId></provcov>
            <provcov>
               <linksto>CanTp.SWS_CanTp_00271_2</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>185</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>544</internalId></specobject>

      <specobject>
         <id>CanTp.ASR40.RxNoBuffer_2</id>
         <status>approved</status>
         <source>EB</source>
         <creationdate>2013-09-09</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        If PduR_CanTpCopyRxData() returns BUFREQ_OK AvailableBuffer smaller (or 0) than required for
        receiving the next CF during a block transfer, then the CanTp shall ignore the available
        buffer size and shall try to copy next CF.
      </description>
         <comment>
        Rationale:
        A block reception only starts if the whole block can be received. This requirement will only
        take place if upper layer reduces its buffer during a block reception.
        If no buffer is available for the next CF in the block the upper layer will return
        BUFREQ_E_BUSY, which is covered by CanTp.ASR40.RxNoBuffer_1.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
        <!--
          Test cases:
          - Available buffer size = 0: TS_CANTP_FailedBlockReception_1
          - Available buffer size < next CF: TS_CANTP_FailedBlockReception_2
        -->
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_FailedBlockReception_1</srcid><srcstatus/><internalId>1235</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_FailedBlockReception_2</srcid><srcstatus/><internalId>1236</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.ASR40.RxNoBuffer</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>543</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>545</internalId></specobject>

      <specobject>
         <id>CanTp.EB.FF.Buffering</id>
         <status>approved</status>
         <source>EB</source>
         <creationdate>2013-09-10</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        If upper layer does not provide enough buffer and FF data can not be copied in the context
        of CanTp_RxIndication(), the module shall buffer the FF data internally to be used when
        upper layer provides enough buffer.
      </description>
         <comment>
      </comment>
         <needscoverage>
        <!--
          Test cases:
          - PduR calls return BUFREQ_E_BUSY at CanTp_RxIndication() call:
              Remains (Similar test done by CanTp.EB.SF.Buffering)
          - PduR calls return not enough buffer at CanTp_RxIndication() call:
              TS_CANTP_ConfTest06_SF_Buffering
          - PduR calls return no buffer at CanTp_RxIndication() call: Remains

          Note: For all test cases above the transmission shall end successfully and the FF data
                shall be checked for correctness.
        -->
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_ConfTest06_FF_Buffering</srcid><srcstatus/><internalId>1413</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.ASR40.SWS_CanTp_00082_1</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>21</internalId></provcov>
            <provcov>
               <linksto>CanTp.ASR40.SWS_CanTp_00082_2</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>22</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>546</internalId></specobject>

      <specobject>
         <id>CanTp.EB.SF.Buffering</id>
         <status>approved</status>
         <source>EB</source>
         <creationdate>2013-09-10</creationdate>
         <version>1</version>
         <priority>high</priority>
         <description>
        If upper layer does not provide enough buffer and SF data can not be copied in the context
        of CanTp_RxIndication(), the module shall buffer the SF data internally to be used when
        upper layer provides enough buffer.
      </description>
         <comment>
      </comment>
         <needscoverage>
        <!--
          Test cases:
          - PduR calls return BUFREQ_E_BUSY at CanTp_RxIndication() call:
              TS_CANTP_ConfTest06_SF_Buffering
          - PduR calls return not enough buffer at CanTp_RxIndication() call:
              Remains (Similar test done by CanTp.EB.FF.Buffering)
          - PduR calls return no buffer at CanTp_RxIndication() call: Remains

          Note: For all test cases above the transmission shall end successfully and the SF data
                shall be checked for correctness.
        -->
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_ConfTest06_SF_Buffering</srcid><srcstatus/><internalId>1412</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTp.ASR40.SWS_CanTp_00082_1</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>21</internalId></provcov>
            <provcov>
               <linksto>CanTp.ASR40.SWS_CanTp_00082_2</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>22</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>547</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs">

    <specobject>
      <id>CanTp.EB.PublishedInformation</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Requirement CANTP326 applies, but the version numbers shall be published
        as stated in [BSW00318] according to the General Requirements on Basic Software Modules
        of ASR V3.1.0 R4.0 Rev 2.
        That is, the following version numbers shall be defined in the header file
        according to [BSW00318] (General Requirements on Basic Software Modules
        of ASR V3.1.0 R4.0 Rev 2):
          -CANTP_VENDOR_ID
          -CANTP_MODULE_ID
          -CANTP_AR_RELEASE_MAJOR_VERSION
          -CANTP_AR_RELEASE_MINOR_VERSION
          -CANTP_AR_RELEASE_REVISION_VERSION
          -CANTP_SW_MAJOR_VERSION
          -CANTP_SW_MINOR_VERSION
          -CANTP_SW_PATCH_VERSION
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanTp.c.m4_10</srcid><srcstatus/><internalId>1010</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00326</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>548</internalId></specobject>

    <specobject>
      <id>CanTp.EB.Init.Gpt</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Notification for the used GPT channels should be enabled during
        CanTp initialization.
        This is done using Gpt_EnableNotification().
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_EnableGpt</srcid><srcstatus/><internalId>1189</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>549</internalId></specobject>

    <specobject>
      <id>CanTp.EB.GetVersionInfo</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        CanTp_GetVersionInfo() shall return the version informations even if it is called before
        CanTp_Init.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30317</srcid><srcstatus/><internalId>1188</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00031</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>138</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>550</internalId></specobject>

    <specobject>
      <id>CanTp.EB.MainFunction.STminHandling_1</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        When transmitting a segmented message, the CanTp module shall
        wait STmin between two CF within a block. If CanTpSTminTimeoutHandling
        is set to CanTpMainFunction, the CanTp_MainFunction() shall take care of STmin
        timing.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_STmin_MF_CLBK</srcid><srcstatus/><internalId>1382</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30295</srcid><srcstatus/><internalId>1390</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30296</srcid><srcstatus/><internalId>1391</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30324</srcid><srcstatus/><internalId>1392</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_WaitingSTmin_CancelTransmit_Ignored</srcid><srcstatus/><internalId>1642</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>551</internalId></specobject>

    <specobject>
      <id>CanTp.EB.Gpt.STminHandling_1</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        When transmitting a segmented message, the CanTp module shall
        wait STmin between two CF within a block. If CanTpSTminTimeoutHandling
        is set to Gpt a general purpose timer shall be started and shall take
        care of STmin timing.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30485</srcid><srcstatus/><internalId>1214</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30095</srcid><srcstatus/><internalId>1215</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30486</srcid><srcstatus/><internalId>1216</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30096</srcid><srcstatus/><internalId>1217</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30323</srcid><srcstatus/><internalId>1218</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_InvalidSTmin</srcid><srcstatus/><internalId>1219</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_31015</srcid><srcstatus/><internalId>1451</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_40046</srcid><srcstatus/><internalId>1605</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>552</internalId></specobject>

    <specobject>
      <id>CanTp.EB.MainFunction.STminHandling_2</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If STmin elapses and CanTpSTminTimeoutHandling is set to CanTpMainFunction,
        the CanTp_MainFunction() shall initiate sending the next CF.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30295</srcid><srcstatus/><internalId>1390</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30296</srcid><srcstatus/><internalId>1391</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30324</srcid><srcstatus/><internalId>1392</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>553</internalId></specobject>

    <specobject>
      <id>CanTp.EB.Gpt.STminHandling_2</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If CanTpSTminTimeoutHandling is set to Gpt the CanTp module shall
        provide a configurable callback function (function name provided
        by CanTpGptChannelCallbackName for each channel). After STmin has elapsed
        the general purpose timer shall call this callback function. This
        callback function shall initiate sending the next CF.
      </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.EB.Gpt.STminHandling_2a</srcid><srcstatus/><internalId>555</internalId></linkedfrom><linkedfrom><srcid>CanTp.EB.Gpt.STminHandling_2b</srcid><srcstatus/><internalId>556</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>554</internalId></specobject>

    <specobject>
      <id>CanTp.EB.Gpt.STminHandling_2a</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If CanTpSTminTimeoutHandling is set to Gpt the CanTp module shall
        provide a configurable callback function (function name provided
        by CanTpGptChannelCallbackName for each channel).
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_49022</srcid><srcstatus/><internalId>1104</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.Gpt.STminHandling_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>554</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>555</internalId></specobject>

    <specobject>
      <id>CanTp.EB.Gpt.STminHandling_2b</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        After STmin has elapsed the general purpose timer shall
        call the configurable Gpt callback function. This
        callback function shall initiate sending the next CF.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30279</srcid><srcstatus/><internalId>1378</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_31015</srcid><srcstatus/><internalId>1451</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_40046</srcid><srcstatus/><internalId>1605</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.Gpt.STminHandling_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>554</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>556</internalId></specobject>

    <specobject>
      <id>CanTp.EB.Gpt.STminCallback_Unexpected</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If the configurable Gpt callback function is called for a channel not expecting
        such a call, then the module shall ignore the call.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30095</srcid><srcstatus/><internalId>1215</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>557</internalId></specobject>

    <specobject>
      <id>CanTp.EB.FC.CTS</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        When receiving a segmented message, the flow control message FC(CTS) shall
        be sent immediately when the corresponding conditions (buffer available) are met.
      </description>
      <comment>
        See deviation dev.CanTp.FlowControlSending.
        </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30148</srcid><srcstatus/><internalId>1221</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30102</srcid><srcstatus/><internalId>1242</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_SegExtRxMultBuf_1</srcid><srcstatus/><internalId>1256</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30170</srcid><srcstatus/><internalId>1258</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>558</internalId></specobject>

    <specobject>
      <id>CanTp.EB.FC.OVFLOW</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        When receiving a segmented message, the flow control messages
        FC(OVFLW) shall be sent immediately when the corresponding conditions
        (buffer request failed) are met.
      </description>
      <comment>
        See deviation dev.CanTp.FlowControlSending.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30086</srcid><srcstatus/><internalId>1224</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_31105</srcid><srcstatus/><internalId>1419</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>559</internalId></specobject>

    <specobject>
      <id>CanTp.EB.11310_2</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
      CanTp shall terminate the current reception connection
      when CanIf_Transmit() returns E_NOT_OK when transmitting FC,
      accordingly call PduR_CanTpRxIndication with result E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanTp_TransmitFrame.c_134</srcid><srcstatus/><internalId>1051</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30269</srcid><srcstatus/><internalId>1246</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
      <provcov>
      <linksto>CanTp.SWS_CanTp_00342</linksto>
      <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>194</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>560</internalId></specobject>

    <specobject>
      <id>CanTp.EB.DynamicNSaEnabled_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name: CanTpDynamicNSaEnabled
        Parent container: CanTpGeneral
        Description:
      Vendor specific configuration parameter to enable or disable
      handling of dynamic N_SA values. If dynamic N_SA values are enabled,
      one entry of N_SA values per N-SDU can be set for Rx or Tx direction of the N_SDU.
        Multiplicity 1
        Type EcucBooleanParamDef
        Default value: FALSE
        ConfigurationClass
      Pre-compile time  X All Variants
      Link time         -
      Post-build time   -
        Scope / Dependency: scope: Module
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        The behavior is covered by CanTp.EB.SetNSa_ApiEnabled, CanTp.EB.GetNSa_ApiEnabled,
        CanTp.EB.SetNSa_ApiDisabled and CanTp.EB.GetNSa_ApiDisabled.
      </comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>561</internalId></specobject>

    <specobject>
      <id>CanTp.EB.SetNSa_ApiEnabled</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If the configuration parameter CanTpDynamicNSaEnabled is enabled,
        the module shall provide the API function CanTp_SetNSa().
      </description>
      <needscoverage>
    <!-- Shall be tested with a compile test only. -->
    <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_NSa</srcid><srcstatus/><internalId>1648</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>562</internalId></specobject>

    <specobject>
      <id>CanTp.EB.GetNSa_ApiEnabled</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If the configuration parameter CanTpDynamicNSaEnabled is enabled,
        the module shall provide the API function CanTp_GetNSa().
      </description>
      <needscoverage>
    <!-- Shall be tested with a compile test only. -->
    <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_NSa</srcid><srcstatus/><internalId>1648</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>563</internalId></specobject>

    <specobject>
      <id>CanTp.EB.SetNSa_ApiDisabled</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If the configuration parameter CanTpDynamicNSaEnabled is disabled,
        the module shall not provide the API function CanTp_SetNSa().
      </description>
      <needscoverage>
    <!-- Shall be tested with a compile test only. -->
    <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_NSa_Disabled</srcid><srcstatus/><internalId>1119</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>564</internalId></specobject>

    <specobject>
      <id>CanTp.EB.GetNSa_ApiDisabled</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If the configuration parameter CanTpDynamicNSaEnabled is disabled,
        the module shall not provide the API function CanTp_GetNSa().
      </description>
      <needscoverage>
    <!-- Shall be tested with a compile test only. -->
    <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_NSa_Disabled</srcid><srcstatus/><internalId>1119</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>565</internalId></specobject>

    <specobject>
      <id>CanTp.EB.SetNSa_Api</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Service name: CanTp_SetNSa
        Syntax: Std_ReturnType CanTp_SetNSa (PduIdType CanTpPduId, uint8 CanTpDirection, uint8 CanTpNSa)
        Service id: 0x1E
        Sync/Async: Synchronous
        Reentrancy: Non Reentrant
        Parameters (in): CanTpPduId CanTp module identifier of a CAN N-SDU to be
        changed.
        Parameters (in): CanTpDirection The direction of the CAN N-SDU can be
        transmit or receive. The parameter can be CANTP_PDUDIR_TRANSMIT or
        CANTP_PDUDIR_RECEIVE.
        Parameters (in): CanTpNSa Value to be changed (source address in extended
        addressing mode).
        Return value:
    - E_OK if setting was successful
    - E_NOT_OK if setting was not successful.
        This can happen,
    - if call of function without a call of CanTp_Init() has been done
    - if CanTpPduId is wrong,
    - if CanTpDirection parameter is wrong,
    - if no CanTpPduId found for given CanTpDirection.
        Description: This function changes a N_SA value for a corresponding CAN
        N-SDU.
      </description>
      <needscoverage>
    <!-- Syntax shall be tested with a compile test only. -->
    <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_NSa</srcid><srcstatus/><internalId>1648</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>566</internalId></specobject>

    <specobject>
      <id>CanTp.EB.SetNSa_Success</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If CanTp_SetNSa() is called with valid parameter the function shall store the new
        N_SA value internally and return with E_OK.
      </description>
      <verifycrit>
        Use case from known issue ASCCANTP-1037:
    * Config: - 2 RX N-SDU extended addressing with reference to the same RX N-PDU
          - 1 TX N-SDU extended addressing with FC reference to the same RX N-PDU
    * It shall be that setting of N-SA value for the different N-SDU with same RX N-PDU does
      not overwrite each other.
    </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_Conf_SetGetNSa001_SameNPdu</srcid><srcstatus/><internalId>1508</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30456</srcid><srcstatus/><internalId>1509</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30460</srcid><srcstatus/><internalId>1513</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30487</srcid><srcstatus/><internalId>1521</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30488</srcid><srcstatus/><internalId>1522</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30489</srcid><srcstatus/><internalId>1523</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>567</internalId></specobject>

    <specobject>
      <id>CanTp.EB.11569</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If DET is enabled and CanTp_SetNSa() is called before the module is
        initialized (CanTp_Init() not called), the function shall raise the DET error
        CANTP_E_UNINIT and shall return with E_NOT_OK. The service id of the function shall
        be used for the Det report.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30464</srcid><srcstatus/><internalId>1517</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293_4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>328</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>568</internalId></specobject>

    <specobject>
      <id>CanTp.EB.11570</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If DET is enabled and CanTp_SetNSa() is called with an invalid value for
        the parameter CanTpDirection, the function shall raise the DET error
        CANTP_E_PARAM_DIRECTION (= 0xA1) and shall return with E_NOT_OK.
        The service id of the function shall be used for the Det report.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30462</srcid><srcstatus/><internalId>1515</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00294</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>336</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>569</internalId></specobject>

    <specobject>
      <id>CanTp.EB.11571</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If DET is enabled and CanTp_SetNSa() is called with the parameter CanTpDirection
        set to CANTP_PDU_DIR_TRANSMIT and the parameter CanTpPduId does not contain a valid
        transmit N-SDU id, the function shall raise the DET error CANTP_E_INVALID_TX_ID
        and shall return with E_NOT_OK. The service id of the function shall
        be used for the Det report.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30467</srcid><srcstatus/><internalId>1520</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293_5</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>329</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00294</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>336</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>570</internalId></specobject>

    <specobject>
      <id>CanTp.EB.11573</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If DET is enabled and CanTp_SetNSa() is called with the parameter CanTpDirection
        set to  CANTP_PDU_DIR_RECEIVE and the parameter CanTpPduId does not contain a valid
        receive N-SDU id, the function shall raise the DET error CANTP_E_INVALID_RX_ID
        and shall return with E_NOT_OK. The service id of the function shall
        be used for the Det report.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30467</srcid><srcstatus/><internalId>1520</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293_6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>330</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00294</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>336</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>571</internalId></specobject>

    <specobject>
      <id>CanTp.EB.SetNSa_RxNotExtendedAddr</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If DET is enabled and CanTp_SetNSa() is called with the parameter CanTpDirection
        set to CANTP_PDU_DIR_RECEIVE and the parameter CanTpPduId does not refer to a N-Sdu
        configured for extended addressing, the function shall raise the DET error
        CANTP_E_INVALID_RX_ID and shall return with E_NOT_OK. The service id of the
        function shall be used for the Det report.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30458</srcid><srcstatus/><internalId>1511</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293_6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>330</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00294</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>336</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>572</internalId></specobject>

    <specobject>
      <id>CanTp.EB.SetNSa_TxNotExtendedAddr</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If DET is enabled and CanTp_SetNSa() is called with the parameter CanTpDirection
        set to CANTP_PDU_DIR_TRANSMIT and the parameter CanTpPduId does not refer to a N-Sdu
        configured for extended addressing, the function shall raise the DET error
        CANTP_E_INVALID_TX_ID and shall return with E_NOT_OK. The service id of the
        function shall be used for the Det report.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30458</srcid><srcstatus/><internalId>1511</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293_5</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>329</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00294</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>336</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>573</internalId></specobject>

    <specobject>
      <id>CanTp.EB.SetNSa_TxFunctionalAddr</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If DET is enabled and CanTp_SetNSa() is called with the parameter CanTpDirection
        set to CANTP_PDU_DIR_TRANSMIT and the parameter CanTpPduId refers to a N-Sdu
        configured for functional addressing, the function shall raise the DET error
        CANTP_E_INVALID_TX_ID and shall return with E_NOT_OK. The service id of the
        function shall be used for the Det report.
      </description>
      <comment>
        Rationale:
        The source address is only used to verify the address of incoming frames.
        Functional addressing is only allowed for single frames and therefore no incoming FC
        frame will be expected. Because of this the source address has no relevance for
        functional TX N-Sdus.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_SetGetNSa_Functional</srcid><srcstatus/><internalId>1524</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293_5</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>329</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00294</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>336</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>574</internalId></specobject>

    <specobject>
      <id>CanTp.EB.GetNSa_Api</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Service name: CanTp_GetNSa
        Syntax: Std_ReturnType CanTp_GetNSa
      (PduIdType CanTpPduId, uint8 CanTpDirection, uint8* CanTpNSaPtr)
        Sync/Async: Synchronous
        Service ID: 0x1F
        Reentrancy: Non Reentrant
        Parameters (in): CanTpPduId CanTp module identifier of a CAN N-SDU to be
        changed.
        Parameters (in): CanTpDirection The direction of the CAN N-SDU can be
        transmit or receive. The parameter can be CANTP_PDU_DIR_TRANSMIT or
        CANTP_PDUDIR_RECEIVE.
        Parameters (out): CanTpNSaPtr Address, where the current N_SA value can
        be written to.
        Return value:
    - E_OK if N_SA value was found.
    - E_NOT_OK if get N_SA was not successful.
        This can happen,
    - if call of function without a call of CanTp_Init() has been done
    - if CanTpNSaPtr is NULL
    - if CanTpPduId is wrong
    - if CanTpDirection parameter is wrong
    - if no CanTpPduId found for given CanTpDirection.
        Description: This function gets the N_SA value for a corresponding CAN
        N-SDU.
      </description>
      <needscoverage>
    <!-- Syntax shall be tested with a compile test only. -->
    <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_NSa</srcid><srcstatus/><internalId>1648</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>575</internalId></specobject>

    <specobject>
      <id>CanTp.EB.GetNSa_Success</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If CanTp_GetNSa() is called with valid parameter the function shall return the actual
        N_SA value for the defined N-Sdu id and return with E_OK.
      </description>
      <verifycrit>
        Use case from known issue ASCCANTP-1037:
    * Config: - 2 RX N-SDU extended addressing with reference to the same RX N-PDU
          - 1 TX N-SDU extended addressing with FC reference to the same RX N-PDU
    </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_Conf_SetGetNSa001_SameNPdu</srcid><srcstatus/><internalId>1508</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30456</srcid><srcstatus/><internalId>1509</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30459</srcid><srcstatus/><internalId>1512</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30489</srcid><srcstatus/><internalId>1523</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>576</internalId></specobject>

    <specobject>
      <id>CanTp.EB.11574</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If DET is enabled and CanTpGetNSa() is called before the module is
        initialized (CanTp_Init() not called), the function shall raise the DET error
        CANTP_E_UNINIT and shall return with E_NOT_OK. The service id of the function shall
        be used for the Det report.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30463</srcid><srcstatus/><internalId>1516</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293_4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>328</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>577</internalId></specobject>

    <specobject>
      <id>CanTp.EB.11575</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If DET is enabled and CanTp_GetNSa() is called with an invalid value for
        the parameter CanTpDirection, the function shall raise the DET error
        CANTP_E_PARAM_DIRECTION (= 0xA1) and shall return with E_NOT_OK.
        The service id of the function shall be used for the Det report.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30461</srcid><srcstatus/><internalId>1514</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00294</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>336</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>578</internalId></specobject>

    <specobject>
      <id>CanTp.EB.11576</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If DET is enabled and CanTp_GetNSa() is called the parameter CanTpNSaPtr set to NULL_PTR,
        the function shall raise the DET error
        CANTP_E_PARAM_POINTER and shall return with E_NOT_OK.
        The service id of the function shall be used for the Det report.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30465</srcid><srcstatus/><internalId>1518</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>327</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00294</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>336</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>579</internalId></specobject>

    <specobject>
      <id>CanTp.EB.11577</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If DET is enabled and CanTp_GetNSa() is called with the parameter CanTpDirection
        set to CANTP_PDU_DIR_TRANSMIT and the parameter CanTpPduId does not contain a valid
        transmit N-SDU id, the function shall raise the DET error CANTP_E_INVALID_TX_ID
        and shall return with E_NOT_OK. The service id of the function shall
        be used for the Det report.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30466</srcid><srcstatus/><internalId>1519</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293_5</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>329</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00294</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>336</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>580</internalId></specobject>

    <specobject>
      <id>CanTp.EB.11578</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If DET is enabled and CanTp_GetNSa() is called with the parameter CanTpDirection
        set to CANTP_PDU_DIR_RECEIVE and the parameter CanTpPduId does not contain a valid
        receive N-SDU id, the function shall raise the DET error CANTP_E_INVALID_RX_ID
        and shall return with E_NOT_OK. The service id of the function shall
        be used for the Det report.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30466</srcid><srcstatus/><internalId>1519</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293_6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>330</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00294</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>336</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>581</internalId></specobject>

    <specobject>
      <id>CanTp.EB.GetNSa_RxNotExtendedAddr</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If DET is enabled and CanTp_GetNSa() is called with the parameter CanTpDirection
        set to CANTP_PDU_DIR_RECEIVE and the parameter CanTpPduId does not refer to a N-Sdu
        configured for extended addressing, the function shall raise the DET error
        CANTP_E_INVALID_RX_ID and shall return with E_NOT_OK. The service id of the
        function shall be used for the Det report.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30457</srcid><srcstatus/><internalId>1510</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293_6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>330</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00294</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>336</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>582</internalId></specobject>

    <specobject>
      <id>CanTp.EB.GetNSa_TxNotExtendedAddr</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If DET is enabled and CanTp_GetNSa() is called with the parameter CanTpDirection
        set to CANTP_PDU_DIR_TRANSMIT and the parameter CanTpPduId does not refer to a N-Sdu
        configured for extended addressing, the function shall raise the DET error
        CANTP_E_INVALID_TX_ID and shall return with E_NOT_OK. The service id of the
        function shall be used for the Det report.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30457</srcid><srcstatus/><internalId>1510</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293_5</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>329</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00294</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>336</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>583</internalId></specobject>

    <specobject>
      <id>CanTp.EB.GetNSa_TxFunctionalAddr</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If DET is enabled and CanTp_GetNSa() is called with the parameter CanTpDirection
        set to CANTP_PDU_DIR_TRANSMIT and the parameter CanTpPduId refers to a N-Sdu
        configured for functional addressing, the function shall raise the DET error
        CANTP_E_INVALID_TX_ID and shall return with E_NOT_OK. The service id of the
        function shall be used for the Det report.
      </description>
      <comment>
        Rationale:
        The source address is only used to verify the address of incoming frames.
        Functional addressing is only allowed for single frames and therefore no incoming FC
        frame will be expected. Because of this the source address has no relevance for
        functional TX N-Sdus.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_SetGetNSa_Functional</srcid><srcstatus/><internalId>1524</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293_5</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>329</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00294</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>336</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>584</internalId></specobject>

    <specobject>
      <id>CanTp.EB.11580</id>
      <status>rejected</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Type or error: API service used with wrong value for the parameter
        CanTpDirection. Relevance: Development Related error code:
        CANTP_E_PARAM_DIRECTION Value: 0xA1
      </description>
      <comment>
        This requirement is informational only.
        Rationale:
        This new development error is specified for API functions CanTp_GetNSa()
        and CanTp_SetNSa().
        The behavior is covered with CanTp.EB.11575 and CanTp.EB.11570.
      </comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>585</internalId></specobject>

    <specobject>
      <id>CanTp.EB.11582</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If a main function of an uninitialized module is called from the BSW
        Scheduler, then it shall return immediately without performing any
        functionality and without raising any errors.
      </description>
      <comment>
        EB requirement is in line with the AUTOSAR 4.0 General SRS requirement
        BSW00450. https://issue.ebgroup.elektrobit.com/browse/ASCCCB-1403
    ----
        Main Function processing of an uninitialized Module may result in
        undesired and non defined behaviour.

        Rationale for the deviation list: The SchM module may schedule the modules
        main function before the module is initialized. This would result in lots
        of Det errors during start up. Therefore the modules main function does
        not throw a Det error if the module is not yet initialized and simply
        returns in this case.
        ASCCCB-1403
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30484</srcid><srcstatus/><internalId>1187</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>586</internalId></specobject>

    <specobject>
      <id>CanTp.EB.CancelReceiveApi_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name: CanTpCancelReceiveApi {CANTP_RX_CANCELLATION_API}
        Parent container: CanTpGeneral
        Description:
      This parameter shall enable the API CanTp_CancelReceive().
        Multiplicity: 1
        Type: BooleanParamDef
        Default value: FALSE
        Range
      TRUE: API CanTp_CancelReceive() shall be provided.
      FALSE: API CanTp_CancelReceive() shall not be provided.
        ConfigurationClass:
      Pre-compile time    X   VARIANT-PRE-COMPILE
      Link time           -
      Post-build time     -
        Scope/Dependency: scope: Module
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        The behavior is covered by CanTp.EB.CancelReceiveApiEnabled,
        CanTp.EB.CancelReceiveApiDisabled.
      </comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>587</internalId></specobject>

    <specobject>
      <id>CanTp.EB.CancelReceiveApiEnabled</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If the configuration parameter CanTpCancelReceiveApi is enabled,
        the module shall provide the API function CanTp_CancelReceive().
      </description>
      <needscoverage>
    <!-- Shall be tested with a compile test only. -->
    <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_49017</srcid><srcstatus/><internalId>1647</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>588</internalId></specobject>

    <specobject>
      <id>CanTp.EB.CancelReceiveApiDisabled</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If the configuration parameter CanTpCancelReceiveApi is disabled,
        the module shall not provide the API function CanTp_CancelReceive().
      </description>
      <needscoverage>
    <!-- Shall be tested with a compile test only. -->
    <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_RCV_CANCL_API_OFF</srcid><srcstatus/><internalId>1111</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>589</internalId></specobject>

    <specobject>
      <id>CanTp.EB.CancelTransmitApi_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name: CanTpCancelTransmitApi {CANTP_TX_CANCELLATION_API}
        Parent container: CanTpGeneral
        Description:
      This parameter shall enable the API CanTp_CancelTransmit().
        Multiplicity: 1
        Type: BooleanParamDef
        Default value: FALSE
        Range
      TRUE: API CanTp_CancelTransmit() shall be provided.
      FALSE: API CanTp_CancelTransmit() shall not be provided.
        ConfigurationClass:
      Pre-compile time    X   VARIANT-PRE-COMPILE
      Link time           -
      Post-build time     -
        Scope/Dependency: scope: Module
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        The behavior is covered by CanTp.EB.CancelTransmitApiEnabled, CanTp.EB.CancelTransmitApiDisabled.
      </comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>590</internalId></specobject>

    <specobject>
      <id>CanTp.EB.CancelTransmitApiEnabled</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If the configuration parameter CanTpTransmitReceiveApi is enabled,
        the module shall provide the API function CanTp_CancelTransmit().
      </description>
      <needscoverage>
    <!-- Shall be tested with a compile test only. -->
    <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_49017</srcid><srcstatus/><internalId>1647</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>591</internalId></specobject>

    <specobject>
      <id>CanTp.EB.CancelTransmitApiDisabled</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If the configuration parameter CanTpCancelTransmitApi is disabled,
        the module shall not provide the API function CanTp_CancelTransmit().
      </description>
      <needscoverage>
    <!-- Shall be tested with a compile test only. -->
    <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_49024</srcid><srcstatus/><internalId>1106</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>592</internalId></specobject>

    <specobject>
      <id>CanTp.EB.TxCancellation_WaitForFC</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        A cancellation using CanTp_CancelTransmit() shall be rejected when actual
        transmission is waiting for a flow control message.
        In this case the called function shall return E_NOT_OK.
      </description>
      <comment>
        See also limitation lim.CanTp.CancellationPrecondition.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30376</srcid><srcstatus/><internalId>1322</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.CancelTransmit.E_OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>526</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>593</internalId></specobject>

    <specobject>
      <id>CanTp.EB.TxCancellation_WaitTxConfirmation</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        A cancellation using CanTp_CancelTransmit() shall be rejected when actual
        transmission is waiting for a  TX confirmation from lower layer.
        In this case the called function shall return E_NOT_OK.
      </description>
      <comment>
        See also limitation lim.CanTp.CancellationPrecondition.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30339</srcid><srcstatus/><internalId>1321</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30379</srcid><srcstatus/><internalId>1323</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.CancelTransmit.E_OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>526</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>594</internalId></specobject>

    <specobject>
      <id>CanTp.EB.RxCancellation_WaitTxConfirmation</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        A cancellation using CanTp_CancelReceive() shall be rejected when actual
        reception is waiting for a TX confirmation from lower layer.
        In this case the called function shall return E_NOT_OK.
      </description>
      <comment>
        See also limitation lim.CanTp.CancellationPrecondition.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_RxCancel_LastCF</srcid><srcstatus/><internalId>1339</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.CancelReceive.E_OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>522</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>595</internalId></specobject>

    <specobject>
      <id>CanTp.EB.SymbolicNameValue</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Macros for symbolic name values shall be generated for all parameters having
        SymbolicNameValue set to true:
        CanTpRxNSduId
        CanTpRxNPduId
        CanTpTxFcNPduConfirmationPduId
        CanTpTxNSduId
        CanTpTxNPduConfirmationPduId
        CanTpRxFcNPduId

        The naming scheme shall be:
        CanTpConf_&amp;lt;ChannelName&amp;gt;_&amp;lt;ParentContainerName&amp;gt;_&amp;lt;ContainerName&amp;gt;
      </description>
      <comment>
        see http://wiki.elektrobit.com/index.php/Project:EB_tresos/Architecture/Config#Symbolic_Names
        and https://issue.ebgroup.elektrobit.com/browse/ASCPROJECT-332
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_NonLegacySymbolicNameValues</srcid><srcstatus/><internalId>1122</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_SymbolicNameValues</srcid><srcstatus/><internalId>1124</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>596</internalId></specobject>

    <specobject>
      <id>CanTp.EB.LegacySymbolicNameValue</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If macro CANTP_PROVIDE_LEGACY_SYMBOLIC_NAMES is defined:
        1 Macro for symbolic name values shall be generated for all parameters having
        SymbolicNameValue set to true:
        CanTpRxNSduId
        CanTpRxNPduId
        CanTpTxFcNPduConfirmationPduId
        CanTpTxNSduId
        CanTpTxNPduConfirmationPduId
        CanTpRxFcNPduId

        The naming scheme shall be:
        CanTp_&amp;lt;ChannelName&amp;gt;_&amp;lt;ParentContainerName&amp;gt;_&amp;lt;ContainerName&amp;gt;
      </description>
      <comment>
        see http://wiki.elektrobit.com/index.php/Project:EB_tresos/Architecture/Config#Symbolic_Names
        and https://issue.ebgroup.elektrobit.com/browse/ASCPROJECT-332.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_NonLegacySymbolicNameValues</srcid><srcstatus/><internalId>1122</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_SymbolicNameValues</srcid><srcstatus/><internalId>1124</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>597</internalId></specobject>

    <specobject>
      <id>CanTp.EB.BSWMDGeneration_1</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The CanTp module's generator shall generate a basic software
        module description (BSWMD) based on the CanTp module's
        configuration containing information on the exclusive areas
        required by the CanTp module's implementation.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_SCHM</srcid><srcstatus/><internalId>1123</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>598</internalId></specobject>

    <specobject>
      <id>CanTp.EB.BSWMDGeneration_2</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The CanTp module's generator shall generate a basic software
        module description (BSWMD) based on the CanTp module's
        configuration containing information on the scheduled
        MainFunctions together with the scheduling period.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_SCHM</srcid><srcstatus/><internalId>1123</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>599</internalId></specobject>

    <specobject>
      <id>CanTp.EB.BSWMDGeneration_3</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The CanTp module's BSWMD shall be generated using a generator
        mode named "generate_swcd".
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_SCHM</srcid><srcstatus/><internalId>1123</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>600</internalId></specobject>

    <specobject>
      <id>CanTp.EB.ExpressTxConfirmation</id>
      <status>approved</status>
      <source>AUTOSAR</source>
      <version>1</version>
      <description>
        CanTp shall successfully process the call of CanTp_TxConfirmation, even if it is executed
        in the context of CanIf_Transmit().
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30275</srcid><srcstatus/><internalId>1374</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30280</srcid><srcstatus/><internalId>1375</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30281</srcid><srcstatus/><internalId>1376</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30283</srcid><srcstatus/><internalId>1377</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30285</srcid><srcstatus/><internalId>1379</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30286</srcid><srcstatus/><internalId>1380</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30287</srcid><srcstatus/><internalId>1381</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>601</internalId></specobject>

    <specobject>
      <id>CanTp.EB.ExpressRxIndication</id>
      <status>approved</status>
      <source>AUTOSAR</source>
      <version>1</version>
      <description>
        CanTp shall successfully process the call of CanTp_RxIndication, even if it is executed
        in the context of CanIf_Transmit().
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30285</srcid><srcstatus/><internalId>1379</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30286</srcid><srcstatus/><internalId>1380</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30287</srcid><srcstatus/><internalId>1381</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>602</internalId></specobject>

    <specobject>
      <id>CanTp.EB.RelocatablePBCfg</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        In order to support post-build-time configuration data handled by relative offsets to the
        configuration start address,
        the container CanTpGeneral must be extended by the configuration parameter
        CanTpRelocatablePbcfgEnable.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_Test_PBcfgM_Off</srcid><srcstatus/><internalId>1098</internalId></linkedfrom><linkedfrom><srcid>CanTp_Test_PBcfgM_On</srcid><srcstatus/><internalId>1099</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_RELOCATABLEPBCFG_1</srcid><srcstatus/><internalId>1102</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_RELOCATABLEPBCFG_2</srcid><srcstatus/><internalId>1103</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_RELOCATABLEPBCFG_3</srcid><srcstatus/><internalId>1105</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_RELOCATABLEPBCFG_4</srcid><srcstatus/><internalId>1107</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_RELOCATABLEPBCFG_5</srcid><srcstatus/><internalId>1110</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_RELOCATABLEPBCFG_6</srcid><srcstatus/><internalId>1112</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>603</internalId></specobject>

    <specobject>
      <id>CanTp.EB.CanTp306</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        After CanTp_ChangeParameter service has been successfully executed
        the service shall return E_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_STMIN_BS_VAR</srcid><srcstatus/><internalId>1607</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>604</internalId></specobject>

    <specobject>
      <id>CanTp.EB.SF.RxDataLength_NormalAddressing</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If padding is disabled, a received SF NSdu frame with normal addressing
        shall have a NSdu length equal to the data length (specified in N_PCI)
        plus header byte (N_PCI).
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30356</srcid><srcstatus/><internalId>1318</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>605</internalId></specobject>

    <specobject>
      <id>CanTp.EB.SF.RxMinDataLength_NormalAddressing</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If padding is disabled, a received SF NSdu frame with normal addressing
        and NSdu length greater than the data length (specified in N_PCI)
        plus header byte (N_PCI) shall be tolerated and treated as it were equal.
      </description>
      <comment>
        Use case:
        If padding is disabled, the module shall tolerate incoming frames from a sender
        which has padding enabled.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30189</srcid><srcstatus/><internalId>1260</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30325</srcid><srcstatus/><internalId>1287</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>606</internalId></specobject>

    <specobject>
      <id>CanTp.EB.SF.RxDataLength_ExtendedAddressing</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If padding is disabled, a received SF NSdu frame with extended addressing
        shall have a NSdu length equal to the data length (specified in N_PCI)
        plus header bytes (N_TA + N_PCI).
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30201</srcid><srcstatus/><internalId>1262</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>607</internalId></specobject>

    <specobject>
      <id>CanTp.EB.SF.RxMinDataLength_ExtendedAddressing</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If padding is disabled, a received SF NSdu frame with extended addressing
        and NSdu length greater than the data length (specified in N_PCI)
        plus header bytes (N_TA + N_PCI) shall be tolerated and treated as it were equal.
      </description>
      <comment>
        Use case:
        If padding is disabled, the module shall tolerate incoming frames from a sender
        which has padding enabled.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30201</srcid><srcstatus/><internalId>1262</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>608</internalId></specobject>

    <specobject>
      <id>CanTp.EB.SF.RxDataLength_MixedAddressing</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If padding is disabled, a received SF NSdu frame with mixed addressing
        shall have a NSdu length equal to the data length (specified in N_PCI)
        plus header bytes (N_AE + N_PCI).
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30414</srcid><srcstatus/><internalId>1658</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>609</internalId></specobject>

    <specobject>
      <id>CanTp.EB.SF.RxMinDataLength_MixedAddressing</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If padding is disabled, a received SF NSdu frame with normal addressing
        and NSdu length greater than the data length (specified in N_PCI)
        plus header bytes (N_AE + N_PCI) shall be tolerated and treated as it were equal.
      </description>
      <comment>
        Use case:
        If padding is disabled, the module shall tolerate incoming frames from a sender
        which has padding enabled.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30414</srcid><srcstatus/><internalId>1658</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>610</internalId></specobject>

    <specobject>
      <id>CanTp.EB.LastCF.RxDataLength_NormalAddressing</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If padding is disabled, a received last CF NSdu frame with normal addressing
        shall have a NSdu length equal to the data length (specified in N_PCI)
        plus header byte (N_PCI).
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30135</srcid><srcstatus/><internalId>1206</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>611</internalId></specobject>

    <specobject>
      <id>CanTp.EB.LastCF.RxMinDataLength_NormalAddressing</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If padding is disabled, a received last CF NSdu frame with normal addressing
        and NSdu length greater than the data length (specified in N_PCI)
        plus header byte (N_PCI) shall be tolerated and treated as it were equal.
      </description>
      <comment>
        Use case:
        If padding is disabled, the module shall tolerate incoming frames from a sender
        which has padding enabled.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30325</srcid><srcstatus/><internalId>1287</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_CancelRx_LF_1</srcid><srcstatus/><internalId>1356</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>612</internalId></specobject>

    <specobject>
      <id>CanTp.EB.LastCF.RxDataLength_ExtendedAddressing</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If padding is disabled, a received last CF NSdu frame with extended addressing
        shall have a NSdu length equal to the data length (specified in N_PCI)
        plus header bytes (N_TA + N_PCI).
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30319</srcid><srcstatus/><internalId>1207</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>613</internalId></specobject>

    <specobject>
      <id>CanTp.EB.LastCF.RxMinDataLength_ExtendedAddressing</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If padding is disabled, a received last CF NSdu frame with extended addressing
        and NSdu length greater than the data length (specified in N_PCI)
        plus header bytes (N_TA + N_PCI) shall be tolerated and treated as it were equal.
      </description>
      <comment>
        Use case:
        If padding is disabled, the module shall tolerate incoming frames from a sender
        which has padding enabled.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_SegExtRxMultBuf_1</srcid><srcstatus/><internalId>1256</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>614</internalId></specobject>

    <specobject>
      <id>CanTp.EB.LastCF.RxDataLength_MixedAddressing</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If padding is disabled, a received last CF NSdu frame with mixed addressing
        shall have a NSdu length equal to the data length (specified in N_PCI)
        plus header bytes (N_AE + N_PCI).
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_SegRxMixedAdr</srcid><srcstatus/><internalId>1683</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>615</internalId></specobject>

    <specobject>
      <id>CanTp.EB.LastCF.RxMinDataLength_MixedAddressing</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If padding is disabled, a received last CF NSdu frame with normal addressing
        and NSdu length greater than the data length (specified in N_PCI)
        plus header bytes (N_AE + N_PCI) shall be tolerated and treated as it were equal.
      </description>
      <comment>
        Use case:
        If padding is disabled, the module shall tolerate incoming frames from a sender
        which has padding enabled.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_SegRxMixedAdr</srcid><srcstatus/><internalId>1683</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>616</internalId></specobject>


    <specobject>
      <id>CanTp.EB.HandleIdGenerator</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The module shall support the correct automatic calculation of
        the handle IDs for the following parameters:
    - CanTpTxNSduId
    - CanTpRxNSduId
    - CanTpTxFcNPduConfirmationPduId
    - CanTpTxNPduConfirmationPduId
    - CanTpRxNPduId
    - CanTpRxFcNPduId
      </description>
      <comment>
      - Handle Id wizards doesn't generate Ids for CanTpTxFcNPduConfirmationPduId
      and CanTpRxFcNPduId if the corresponding TAType is not PHYSICAL.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_HandleIdGenerator</srcid><srcstatus/><internalId>1115</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>617</internalId></specobject>

    <specobject>
      <id>CanTp.EB.NPdus</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Transmission and reception shall be handled properly even if the configured N-PDUs are not
        zero based and consecutive.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30403</srcid><srcstatus/><internalId>1411</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>618</internalId></specobject>

    <specobject>
      <id>CanTp.EB.BS.Unlimited</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If upper layer provides enough buffer for the whole incoming segmented message, CanTp shall
        use the configured block size in the FC(CTS).
      </description>
      <comment>
        This requirement is a customer request: See ASCCANTP-948.
      </comment>
      <needscoverage>
    <!-- Shall be tested with configured block size 0. -->
    <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_BS_Unlimited</srcid><srcstatus/><internalId>1401</internalId></linkedfrom><linkedfrom><srcid>CanTp_ConTest04_BS_EnoughBufffer</srcid><srcstatus/><internalId>1402</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_Rx_MaxDataLength</srcid><srcstatus/><internalId>1403</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_BS_Unlimited_1</srcid><srcstatus/><internalId>1406</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>619</internalId></specobject>

    <specobject>
      <id>CanTp.EB.BS.EnoughBuffer</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Considering the configured block size is not zero and bigger as available upper layer buffer:
        If upper layer provides enough buffer for the whole incoming segmented message, CanTp shall
        use the configured block size in the FC(CTS).
      </description>
      <comment>
        This requirement is a customer request: See ASCCANTP-948
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest_BS_UseConfigValue</srcid><srcstatus/><internalId>1427</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>620</internalId></specobject>

    <specobject>
      <id>CanTp.EB.BS.Limited</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Considering the case that the block size is not limited by a configuration
        parameter.
        If upper layer provides enough buffer to receive more than 255 CFs but not
        enough for the whole incoming segmented message, the promoted block size
        in the FC(CTS) shall be 0xFF.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_BS_Limited</srcid><srcstatus/><internalId>1404</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_BS_Limited_1</srcid><srcstatus/><internalId>1405</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>621</internalId></specobject>

    <specobject>
      <id>CanTp.EB.Rx.DataConsistency</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Data provided to upper layer should be consistent to that received from lower layer
        and only payload should get copied to the upper layer buffer, irrespective of padding.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30381</srcid><srcstatus/><internalId>1317</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>622</internalId></specobject>

    <specobject>
      <id>CanTp.EB.RxNSdus</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        CanTp shall be compilable with no RxNSdus configured.
      </description>
      <comment>
        This is possible as the container CanTpRxNSdu can have multiplicity 0.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_49028</srcid><srcstatus/><internalId>1651</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>623</internalId></specobject>

    <specobject>
      <id>CanTp.EB.TxNSdus</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        CanTp shall be compilable with no TxNSdus configured.
      </description>
      <comment>
        This is possible as the container CanTpTxNSdu can have multiplicity 0.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_49027</srcid><srcstatus/><internalId>1650</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>624</internalId></specobject>

    <specobject>
      <id>CanTp.EB.IntFrame.InvalidRxLength</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
        Reception of an intermediate frame with N-Pdu length less than 8 shall report Det error
        CANTP_E_INVALID_RX_LENGTH, irrespective of whether padding is enabled or not.
      </description>
      <comment>
        Covering this requirement shall also include testing the service id used for the Det report.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_InvalidRxLength</srcid><srcstatus/><internalId>1363</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293_10</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>332</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>625</internalId></specobject>

    <specobject>
      <id>CanTp.EB.RxIndication.InvalidRxLength</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
        If DET is enabled and a frame is received with N-Pdu length greater than 8 bytes,
        then CanTp_RxIndication shall raise the DET error CANTP_E_INVALID_RX_LENGTH.
      </description>
      <comment>
        Covering this requirement shall also include testing the service id used for the Det report.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30261</srcid><srcstatus/><internalId>1306</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30477</srcid><srcstatus/><internalId>1675</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293_10</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>332</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>626</internalId></specobject>

    <specobject>
      <id>CanTp.EB.Rx.Padding.InvalidRxLength</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
        If DET is enabled, padding is CANTP_ON and a frame is received with N-Pdu length not equal to
        8, then CanTp_RxIndication shall raise the DET error CANTP_E_INVALID_RX_LENGTH.
      </description>
      <comment>
        Covering this requirement shall also include testing the service id used for the Det report.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest12_007_InvalidRxLength_CANTP_ON_CAN_CAN_FD_CAN20_frames</srcid><srcstatus/><internalId>1174</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30266</srcid><srcstatus/><internalId>1307</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_Padding_InvalidRxLength</srcid><srcstatus/><internalId>1308</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30479</srcid><srcstatus/><internalId>1677</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30483</srcid><srcstatus/><internalId>1681</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293_10</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>332</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00344</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>261</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00345</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>264</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00346</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>267</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>627</internalId></specobject>

    <specobject>
      <id>CanTp.EB.Rx.Padding.CANTP_ON_CAN_CAN_FD.InvalidRxLength.CAN-FD_frame</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If DET is enabled, padding is CANTP_ON_CAN_CAN_FD and a CAN-FD frame is received with N-Pdu length not equal to
        64, then CanTp_RxIndication shall raise the DET error CANTP_E_INVALID_RX_LENGTH.
      </description>
      <comment>
        Covering this requirement shall also include testing the service id used for the Det report.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest12_006_InvalidRxLength_CANTP_ON_CAN_CAN_FD_CANFD_frames</srcid><srcstatus/><internalId>1173</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293_10</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>332</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00344.CANTP_ON_CAN_CAN_FD.CAN-FD_frames</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>262</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00345.CANTP_ON_CAN_CAN_FD.CAN-FD_frames</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>265</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00346.CANTP_ON_CAN_CAN_FD.CAN-FD_frames</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>268</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>628</internalId></specobject>

    <specobject>
      <id>CanTp.EB.Rx.Padding.CANTP_ON_CAN_CAN_FD.InvalidRxLength.CAN2.0_frame</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If DET is enabled, padding is CANTP_ON_CAN_CAN_FD and a CAN 2.0 frame is received with N-Pdu length not equal to
        8, then CanTp_RxIndication shall raise the DET error CANTP_E_INVALID_RX_LENGTH.
      </description>
      <comment>
        Covering this requirement shall also include testing the service id used for the Det report.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest12_007_InvalidRxLength_CANTP_ON_CAN_CAN_FD_CAN20_frames</srcid><srcstatus/><internalId>1174</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293_10</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>332</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00344.CANTP_ON_CAN_CAN_FD.CAN2.0_frames</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>263</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00345.CANTP_ON_CAN_CAN_FD.CAN2.0_frames</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>266</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00346.CANTP_ON_CAN_CAN_FD.CAN2.0_frames</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>269</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>629</internalId></specobject>

    <specobject>
      <id>CanTp.EB.SF.InvalidRxLength</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
        If DET is enabled and a SF is received with N-Pdu length less than that required
        for holding header(1 byte for standard and 2 bytes for extended/mixed) and
        encoded data(SF_DL), then CanTp shall raise the DET error CANTP_E_INVALID_RX_LENGTH.
      </description>
      <comment>
        Covering this requirement shall also include testing the service id used for the Det report.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30200</srcid><srcstatus/><internalId>1261</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30261</srcid><srcstatus/><internalId>1306</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30478</srcid><srcstatus/><internalId>1676</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293_10</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>332</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>630</internalId></specobject>

    <specobject>
      <id>CanTp.EB.SF.InvalidRxLength_1</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
        If DET is enabled and a SF is received with  message length as 0 bytes, then CanTp shall
        raise the DET error CANTP_E_INVALID_RX_LENGTH.
      </description>
      <comment>
        Covering this requirement shall also include testing the service id used for the Det report.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30049</srcid><srcstatus/><internalId>1266</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30272</srcid><srcstatus/><internalId>1310</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293_10</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>332</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>631</internalId></specobject>

    <specobject>
      <id>CanTp.EB.SF.InvalidRxLength_2</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
        If DET is enabled and a SF is received with message length greater than 7 bytes on a NSdu
        configured for standard addressing, then CanTp shall raise the DET error
        CANTP_E_INVALID_RX_LENGTH.
      </description>
      <comment>
        Covering this requirement shall also include testing the service id used for the Det report.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30059</srcid><srcstatus/><internalId>1267</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293_10</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>332</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>632</internalId></specobject>

    <specobject>
      <id>CanTp.EB.SF.InvalidRxLength_3</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
        If DET is enabled and a SF is received with message length greater than 6 bytes on a NSdu
        configured for extended addressing, then CanTp shall raise the DET error
        CANTP_E_INVALID_RX_LENGTH.
      </description>
      <comment>
        Covering this requirement shall also include testing the service id used for the Det report.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30060</srcid><srcstatus/><internalId>1268</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293_10</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>332</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>633</internalId></specobject>

    <specobject>
      <id>CanTp.EB.SF.InvalidRxLength_4</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
        If DET is enabled and a SF is received with message length greater than 6 bytes on a NSdu
        configured for mixed addressing, then CanTp shall raise the DET error
        CANTP_E_INVALID_RX_LENGTH.
      </description>
      <comment>
        Covering this requirement shall also include testing the service id used for the Det report.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_Mixed_SF_InvalidLength</srcid><srcstatus/><internalId>1434</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293_10</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>332</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>634</internalId></specobject>

    <specobject>
      <id>CanTp.EB.FF.InvalidRxLength_1</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
        If DET is enabled, and a FF is received with message length less than or equal to 7 (which
        can fit in SF) for normal addressing mode, then CanTp shall raise the DET error
        CANTP_E_INVALID_RX_LENGTH.
      </description>
      <comment>
        Covering this requirement shall also include testing the service id used for the Det report.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30080</srcid><srcstatus/><internalId>1265</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293_10</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>332</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>635</internalId></specobject>

    <specobject>
      <id>CanTp.EB.FF.InvalidRxLength_2</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
        If DET is enabled, and a FF is received with message length less than or equal to 6
        (which can fit in a SF) for extended addressing mode, then CanTp shall raise the DET error
        CANTP_E_INVALID_RX_LENGTH.
      </description>
      <comment>
        Covering this requirement shall also include testing the service id used for the Det report.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30087</srcid><srcstatus/><internalId>1269</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30088</srcid><srcstatus/><internalId>1270</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30272</srcid><srcstatus/><internalId>1310</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293_10</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>332</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>636</internalId></specobject>

    <specobject>
      <id>CanTp.EB.FF.InvalidRxLength_3</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
        If DET is enabled, and a FF is received with message length less than or equal to 6
        (which can fit in SF) for mixed addressing mode, then CanTp shall raise the DET error
        CANTP_E_INVALID_RX_LENGTH.
      </description>
      <comment>
        Covering this requirement shall also include testing the service id used for the Det report.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_Mixed_FF_InvalidLength</srcid><srcstatus/><internalId>1435</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293_10</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>332</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>637</internalId></specobject>

    <specobject>
      <id>CanTp.EB.FF.InvalidRxLength_4</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
        If DET is enabled, and a FF is received with N-Pdu length less than 8 irrespective of
        padding is enabled or not, then CanTp shall raise the DET error
        CANTP_E_INVALID_RX_LENGTH.
      </description>
      <comment>
        Covering this requirement shall also include testing the service id used for the Det report.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30261</srcid><srcstatus/><internalId>1306</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293_10</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>332</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>638</internalId></specobject>
    
    <specobject>
      <id>CanTp.EB.FF.InvalidRxLength_5</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
        If DET is enabled, and a FF with mixed or extended addressing is received, with length less 
        than 3, then CanTp shall raise the DET error
        CANTP_E_INVALID_RX_LENGTH.
      </description>
      <comment>
        Covering this requirement shall also include testing the service id used for the Det report.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FF_Extended_InvalidLength</srcid><srcstatus/><internalId>1271</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_Mixed_FF_InvalidLength_1</srcid><srcstatus/><internalId>1436</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293_10</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>332</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>639</internalId></specobject>

    <specobject>
      <id>CanTp.EB.LastFrame.InvalidRxLength</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
        If DET is enabled, and a last frame is received with N-Pdu length less than that required
        for holding header bytes and remaining data, then CanTp shall raise the DET error
        CANTP_E_INVALID_RX_LENGTH.
      </description>
      <comment>
        Covering this requirement shall also include testing the service id used for the Det report.
      </comment>
      <needscoverage>
        <!--
          Shall be tested for following test cases:
          - Normal addressing: TS_CANTP_30480
          - Mixed addressing: Remains
          - Extended addressing: TS_CANTP_30261
        -->
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30261</srcid><srcstatus/><internalId>1306</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30480</srcid><srcstatus/><internalId>1678</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30481</srcid><srcstatus/><internalId>1679</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293_10</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>332</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>640</internalId></specobject>

    <specobject>
      <id>CanTp.EB.OverwritePostponedFrame</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If DET is enabled and a previous CF is overwritten then CanTp shall
        raise the DET error CANTP_E_OVERWRITE_FRAME.
      </description>
      <comment>
        Covering this requirement shall also include testing the service id used for the Det report.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30287</srcid><srcstatus/><internalId>1381</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>641</internalId></specobject>

    <specobject>
      <id>CanTp.EB.Init.ParamConfig</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        CanTp shall report Det error CANTP_E_PARAM_CONFIG when called with an
        invalid configuration pointer.
      </description>
      <comment>
    - Validity of configuration pointer is verified by the function CanTp_IsValidConfig
      by checking whether post build configuration fits to the link time configuration part.
    - Covering this requirement shall also include testing the service id used for the Det report.
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanTp_Init.c_173</srcid><srcstatus/><internalId>1022</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>324</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>642</internalId></specobject>

    <specobject>
      <id>CanTp.EB.TxConfirmation.InvalidTxId</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If DET is enabled and CanTp_TxConfirmation() is called with invalid CanTpTxPduId,
        the function shall raise the DET error CANTP_E_INVALID_TX_ID.
      </description>
      <comment>
        Covering this requirement shall also include testing the service id used for the Det report.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30255</srcid><srcstatus/><internalId>1682</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293_5</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>329</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>643</internalId></specobject>

    <specobject>
      <id>CanTp.EB.RxIndication.InvalidRxId</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If DET is enabled and CanTp_RxIndication() is called with CanTpRxPduId which is not
        configured, the function shall raise the DET error CANTP_E_INVALID_RX_ID.
      </description>
      <comment>
        Covering this requirement shall also include testing the service id used for the Det report.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30253</srcid><srcstatus/><internalId>1293</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293_6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>330</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>644</internalId></specobject>

    <specobject>
      <id>CanTp.EB.RxIndication.InvalidRxId_1</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If DET is enabled and a first frame is received with CanTpRxPduId corresponding to the
        CanTpRxFcNPduId of a Tx-N-Sdu (standard addressing), then CanTp_RxIndication shall ignore
        the frame and shall raise the DET error CANTP_E_INVALID_RX_ID.
      </description>
      <comment>
        Covering this requirement shall also include testing the service id used for the Det report.
        Rationale:
        For standard addressing a 1:1 relationship exists. If this error report occurs,
        then this is an indication for a bug in the code of the lower layer.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_FF_InvalidRxId</srcid><srcstatus/><internalId>1364</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293_6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>330</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>645</internalId></specobject>

    <specobject>
      <id>CanTp.EB.RxIndication.InvalidRxId_2</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If DET is enabled and a FC frame is received with CanTpRxPduId corresponding to an
        Rx-N-Sdu (standard addressing), then CanTp_RxIndication shall ignore the frame and shall
        raise the DET error CANTP_E_INVALID_RX_ID.
      </description>
      <comment>
        Covering this requirement shall also include testing the service id used for the Det report.
        Rationale:
        For standard addressing a 1:1 relationship exists. If this error report occurs,
        then this is an indication for a bug in the code of the lower layer.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_FC_InvalidRxId</srcid><srcstatus/><internalId>1366</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293_6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>330</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>646</internalId></specobject>

    <specobject>
      <id>CanTp.EB.RxIndication.InvalidRxId_3</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If DET is enabled and a single frame is received with CanTpRxPduId corresponding to the
        CanTpRxFcNPduId of a Tx-N-Sdu (standard addressing), then CanTp_RxIndication shall ignore
        the frame and shall raise the DET error CANTP_E_INVALID_RX_ID.
      </description>
      <comment>
        Covering this requirement shall also include testing the service id used for the Det report.
        Rationale:
        For standard addressing a 1:1 relationship exists. If this error report occurs,
        then this is an indication for a bug in the code of the lower layer.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_SF_InvalidRxId</srcid><srcstatus/><internalId>1365</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293_6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>330</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>647</internalId></specobject>

    <specobject>
      <id>CanTp.EB.Transmit.InvalidTxLength</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If DET is enabled and CanTp_Transmit() is called with invalid N-Pdu length, i.e
        0x0 or greater than 0x0FFF, the function shall raise the DET error CANTP_E_INVALID_TX_LENGTH.
      </description>
      <comment>
        Covering this requirement shall also include testing the service id used for the Det report.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30260</srcid><srcstatus/><internalId>1305</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293_9</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>331</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>648</internalId></specobject>

    <specobject>
      <id>CanTp.EB.RxIndication.ParamPointer</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If DET is enabled and CanTp_RxIndication() is called with SduDataPtr as NULL_PTR,
        the function shall raise the DET error CANTP_E_PARAM_POINTER.
      </description>
      <comment>
        Covering this requirement shall also include testing the service id used for the Det report.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30262</srcid><srcstatus/><internalId>1295</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>327</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>649</internalId></specobject>

    <specobject>
      <id>CanTp.EB.StartofRx.InvalidReturn</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If PduR_CanTpStartOfReception returns a value other than BUFREQ_E_BUSY, BUFREQ_OK,
        BUFREQ_E_NOT_OK or BUFREQ_E_OVFL, then CanTp shall abort the reception.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_FF_PduRInvalidReturn</srcid><srcstatus/><internalId>1357</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00064</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>650</internalId></specobject>

    <specobject>
      <id>CanTp.EB.CopyRxData.InvalidReturn</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If PduR_CanTpCopyRxData returns a value other than BUFREQ_E_BUSY, BUFREQ_OK,
        BUFREQ_E_NOT_OK or BUFREQ_E_OVFL, then CanTp shall abort the reception.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_FF_PduRInvalidReturn_1</srcid><srcstatus/><internalId>1358</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>651</internalId></specobject>

    <specobject>
      <id>CanTp.EB.CopyTxData.InvalidReturn</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If PduR_CanTpCopyTxData returns a value other than BUFREQ_E_BUSY, BUFREQ_OK,
        BUFREQ_E_NOT_OK or BUFREQ_E_OVFL, then CanTp shall abort the transmission.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_CopyTxData_InvalidReturn</srcid><srcstatus/><internalId>1360</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>652</internalId></specobject>

    <specobject>
      <id>CanTp.EB.Functional.NormalAddr</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        When CanTp_Transmit is called for a N-Sdu, which is configured with normal addressing and
        functional communication type, with N-Sdu length greater than 7, CanTp shall reject the
        request and shall report Det error CANTP_E_INVALID_TATYPE.
      </description>
      <comment>
        Covering this requirement shall also include testing the service id used for the Det report.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30066</srcid><srcstatus/><internalId>1251</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>653</internalId></specobject>

    <specobject>
      <id>CanTp.EB.Functional.ExtendedAddr</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        When CanTp_Transmit is called for a N-Sdu, which is configured with extended addressing and
        functional communication type, with N-Sdu length greater than 6, CanTp shall reject the
        request and shall report Det error CANTP_E_INVALID_TATYPE.
      </description>
      <comment>
        Covering this requirement shall also include testing the service id used for the Det report.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_Extented_Functional</srcid><srcstatus/><internalId>1408</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>654</internalId></specobject>

    <specobject>
      <id>CanTp.EB.Functional.MixedAddr</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        When CanTp_Transmit is called for a N-Sdu, which is configured with mixed addressing and
        functional communication type, with N-Sdu length greater than 6, CanTp shall reject the
        request and shall report Det error CANTP_E_INVALID_TATYPE.
      </description>
      <comment>
        Covering this requirement shall also include testing the service id used for the Det report.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_Mixed_Functional_2</srcid><srcstatus/><internalId>1394</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>655</internalId></specobject>

    <specobject>
      <id>CanTp.EB.NPduNSaFiltering</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If a frame with extended addressing is received, the module shall compare the configuration
        parameter CanTpNSa of each matching (same N-PduId) Rx N-Pdu with the target address of
        the frame to get the right Rx N-Sdu.
      </description>
      <comment>
        How to test:
    - Configure two Rx N-Sdus with equal N-PduIds and different CanTpNSa.
    - Receive a frame with extended addressing configured N-PduId and target address equal to
      CanTpNSa of the first N-Sdu.
    - Verify that first N-Sdu will be used to process the frame.
    - Perform the same test for the second N-Sdu as well.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_NPduNSaFiltering</srcid><srcstatus/><internalId>1395</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>656</internalId></specobject>

    <specobject>
      <id>CanTp.EB.FcNPduNSaFiltering</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If a FC frame with extended addressing is received, the module shall compare the
        configuration parameter CanTpNSa of each matching (same FcNPduId) Rx N-FcPdu with the
        target address of the frame to get the right Tx N-Sdu.
      </description>
      <comment>
        How to test:
    - Configure two Tx N-Sdus with equal FcNPduIds and different CanTpNSa.
    - Receive a frame with extended addressing configured FcNPduId and target address equal to
      CanTpNSa of the first N-Sdu.
    - Verify that first N-Sdu will be used to process the frame.
    - Perform the same test for the second N-Sdu as well.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_FcNPduNSaFiltering</srcid><srcstatus/><internalId>1396</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>657</internalId></specobject>

    <specobject>
      <id>CanTp.EB.NPduNAeFiltering</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If a frame with mixed addressing is received, the module shall compare the configuration
        parameter CanTpNAe of each matching (same N-PduId) Rx N-Pdu with the N_Ae value of
        the frame to get the right Rx N-Sdu.
      </description>
      <comment>
        How to test:
    - Configure two Rx N-Sdus with equal N-PduIds and different CanTpNAe.
    - Receive a frame with mixed addressing configured N-PduId and N_Ae value equal to
      CanTpNAe of the first N-Sdu.
    - Verify that first N-Sdu will be used to process the frame.
    - Perform the same test for the second N-Sdu as well.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_NPduNAeFiltering</srcid><srcstatus/><internalId>1397</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>658</internalId></specobject>

    <specobject>
      <id>CanTp.EB.FcNPduNAeFiltering</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If a FC frame with mixed addressing is received, the module shall compare the configuration
        parameter CanTpNSa of each matching (same FcNPduId) Rx N-FcPdu with the N_Ae value of
        the frame to get the right Tx N-Sdu.
      </description>
      <comment>
        How to test:
    - Configure two Tx N-Sdus with equal FcNPduIds and different CanTpNAe.
    - Receive a frame with mixed addressing configured FcNPduId and N_Ae value equal to
      CanTpNAe of the first N-Sdu.
    - Verify that first N-Sdu will be used to process the frame.
    - Perform the same test for the second N-Sdu as well.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_FcNPduNAeFiltering</srcid><srcstatus/><internalId>1398</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>659</internalId></specobject>

    <specobject>
      <id>CanTp.EB.ShortNames</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If a short name exists for configuration parameter with enabled symbolic name values,
        then the naming schema shall follow ecuc_sws_2108, that is
        CanTpConf_&amp;lt;short name of EcucParamConfContainerDef&amp;gt;_&amp;lt;short name
        of EcucContainerValue&amp;gt;

        This naming schema is applicable for:
        CanTpRxNSduId
        CanTpRxNPduId
        CanTpTxFcNPduConfirmationPduId
        CanTpTxNSduId
        CanTpTxNPduConfirmationPduId
        CanTpRxFcNPduId
      </description>
      <comment>
        The short names should be unique.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_SymbolicNameValues</srcid><srcstatus/><internalId>1124</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>660</internalId></specobject>

    <specobject>
      <id>CanTp.EB.MMapIsValidFunctionToMemSection</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If PbcfgM is used and if config parameter PbcfgMMapIsValidFunctionToMemSection
        exists and it is set on true then generate a new memory section and place the
        CanTp_IsValidConfig function in the new memory section.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_PBCFGM</srcid><srcstatus/><internalId>1113</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>661</internalId></specobject>

    <!-- == Start Section: AUTOSAR SWS General - EB Requirement Extension ========================== -->
    
    <specobject>
      <id>CanTp.EB.ASRExt.StdAddr.FullDuplexNPduId</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For standard addressing it shall be possible that a incoming TX FC N-PDU and a incoming RX
        N-PDU with the same N-PDU ID (CanIf N-PDU reference) can be handled at the same time.
      </description>
      <comment>ASCCANTP-961</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_Conf08001_Sdt_FD_Com</srcid><srcstatus/><internalId>1125</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>662</internalId></specobject>

    <specobject>
      <id>CanTp.EB.ASRExt.ExtAddr.FullDuplexNPduId</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For extended addressing it shall be possible that a incoming TX FC N-PDU and a incoming RX
        N-PDU with the same N-PDU ID (CanIf N-PDU reference) and the same source address can be
        handled at the same time.
      </description>
      <comment>ASCCANTP-961</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_Conf08003_Ext_FD_Com</srcid><srcstatus/><internalId>1127</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>663</internalId></specobject>

    <specobject>
      <id>CanTp.EB.ASRExt.MixAddr.FullDuplexNPduId</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For mixed addressing it shall be possible that a incoming TX FC N-PDU and a incoming RX
        N-PDU with the same N-PDU ID (CanIf N-PDU reference) and the same address extension can be
        handled at the same time.
      </description>
      <comment> ASCCANTP-961</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_Conf08002_Mix_FD_Com</srcid><srcstatus/><internalId>1126</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>664</internalId></specobject>
    
    <specobject>
      <id>CanTp.EB.IdleChannels</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        CanTp_MainFunction shall exit immediately if all channels are Idle.
      </description>
      <needscoverage>
    <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/src/CanTp_MultiMainFunction.c_68</srcid><srcstatus/><internalId>1005</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/CanTp_MainFunction.c_96</srcid><srcstatus/><internalId>1024</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/CanTp_MainFunction.c_159</srcid><srcstatus/><internalId>1025</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_SF_Transmission</srcid><srcstatus/><internalId>1612</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MF_Transmission</srcid><srcstatus/><internalId>1613</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_SF_Reception</srcid><srcstatus/><internalId>1614</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MF_Reception</srcid><srcstatus/><internalId>1615</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MF_Transmission_and_Reception</srcid><srcstatus/><internalId>1616</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>665</internalId></specobject>
    <!-- == End Section: AUTOSAR SWS General - EB Requirement Extension ============================ -->

  <!-- == Start Section: Jump table - EB Requirement Extension =================================== -->
  <specobject>
      <id>CanTp.EB.JTM_MemMapSection_SharedVariables</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        All variables which shall be shared between jump table client and server shall be placed in
        the memory section VAR_INIT_JUMP_TABLE_SHARED_UNSPECIFIED.
      </description>
      <comment>
        The module owner has to make sure that all variables that are required for both jump table
        server and client are placed in this memory section.
        The integrator only needs provide shared memory only for all variables within this section.
        This way shared variables can be removed or added without impact major on the integration.
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/src/CanTp_Cfg.c_77</srcid><srcstatus/><internalId>999</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>666</internalId></specobject>
    <!-- == End Section: Jump table - EB Requirement Extension ===================================== -->


  <!-- == Start Section: Supported PduLength values for small CAN 2.0 single frames ============================================= -->

  <!-- =============================  Transmission ==================================-->

  <specobject>
      <id>CanTp.EB.TX.STANDARD_AddressingFormat_PaddingOff_PduLengthSmallerThan8</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For a Tx N-SDU with CanTpFlexibleDataRateSupport equal to CANTP_OFF,
        CanTpTxPaddingActivation equal to CANTP_OFF and addressing format CANTP_STANDARD,
        CanTp module shall be able to transmit frames with the following payload length values:
      - payload length of 1 byte, for EcuC PduLength = 2
      - payload length of 2 bytes, for EcuC PduLength = 3
      - payload length of 3 bytes, for EcuC PduLength = 4
      - payload length of 4 bytes, for EcuC PduLength = 5
      - payload length of 5 bytes, for EcuC PduLength = 6
      - payload length of 6 bytes, for EcuC PduLength = 7
      </description>
      <comment>
      </comment>
      <verifycrit>
        Precondition:
    * CanTpFlexibleDataRateSupport = FALSE
    * CanTpTxPaddingActivation = CANTP_OFF
    * Addressing = STANDARD
    * Frame type: SF
        Result:
        Data are correctly passed to CanIf.
    </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_Con03_ST_MIX_EXT_CAN20_SF_Transmission_PduLengthLessThan8</srcid><srcstatus/><internalId>1387</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>667</internalId></specobject>

    <specobject>
      <id>CanTp.EB.TX.MIXED_AddressingFormat_PaddingOff_PduLengthSmallerThan8</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For a Tx N-SDU with CanTpFlexibleDataRateSupport equal to CANTP_OFF,
        CanTpTxPaddingActivation equal to CANTP_OFF and addressing format CANTP_MIXED,
        CanTp module shall be able to transmit frames with the following payload length values:
      - payload length of 1 byte, for EcuC PduLength = 3
      - payload length of 2 bytes, for EcuC PduLength = 4
      - payload length of 3 bytes, for EcuC PduLength = 5
      - payload length of 4 bytes, for EcuC PduLength = 6
      - payload length of 5 bytes, for EcuC PduLength = 7
      </description>
      <comment>
      </comment>
      <verifycrit>
        Precondition:
    * CanTpFlexibleDataRateSupport = FALSE
    * CanTpTxPaddingActivation = CANTP_OFF
    * Addressing = MIXED
    * Frame type: SF
        Result:
        Data are correctly passed to CanIf.
    </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_Con03_ST_MIX_EXT_CAN20_SF_Transmission_PduLengthLessThan8</srcid><srcstatus/><internalId>1387</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>668</internalId></specobject>

    <specobject>
      <id>CanTp.EB.TX.EXTENDED_AddressingFormat_PaddingOff_PduLengthSmallerThan8</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For a Tx N-SDU with CanTpFlexibleDataRateSupport equal to CANTP_OFF,
        CanTpTxPaddingActivation equal to CANTP_OFF and addressing format CANTP_EXTENDED,
        CanTp module shall be able to transmit frames with the following payload length values:
      - payload length of 1 byte, for EcuC PduLength = 3
      - payload length of 2 bytes, for EcuC PduLength = 4
      - payload length of 3 bytes, for EcuC PduLength = 5
      - payload length of 4 bytes, for EcuC PduLength = 6
      - payload length of 5 bytes, for EcuC PduLength = 7
      </description>
      <comment>
      </comment>
      <verifycrit>
        Precondition:
    * CanTpFlexibleDataRateSupport = FALSE
    * CanTpTxPaddingActivation = CANTP_OFF
    * Addressing = EXTENDED
    * Frame type: SF
        Result:
        Data are correctly passed to CanIf.
    </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_Con03_ST_MIX_EXT_CAN20_SF_Transmission_PduLengthLessThan8</srcid><srcstatus/><internalId>1387</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>669</internalId></specobject>

    <!-- ==================================  Reception  =========================================-->
  <specobject>
      <id>CanTp.EB.RX.STANDARD_AddressingFormat_PaddingOff_PduLengthSmallerThan8</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For a Rx N-SDU with CanTpFlexibleDataRateSupport equal to CANTP_OFF,
        CanTpRxPaddingActivation equal to CANTP_OFF and addressing format CANTP_STANDARD,
        CanTp module shall be able to receive frames with the following payload length values:
      - payload length of 1 byte, for EcuC PduLength = 2
      - payload length of 2 bytes, for EcuC PduLength = 3
      - payload length of 3 bytes, for EcuC PduLength = 4
      - payload length of 4 bytes, for EcuC PduLength = 5
      - payload length of 5 bytes, for EcuC PduLength = 6
      - payload length of 6 bytes, for EcuC PduLength = 7
      </description>
      <comment>
      </comment>
      <verifycrit>
        Precondition:
    * CanTpFlexibleDataRateSupport = FALSE
    * CanTpTxPaddingActivation = CANTP_OFF
    * Addressing = STANDARD
    * Frame type: SF
        Result:
        PduR is notified about the successfully received frame.
    </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_Con04_ST_MIX_EXT_CAN20_SF_Reception_PduLengthLessThan8</srcid><srcstatus/><internalId>1388</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>670</internalId></specobject>

    <specobject>
      <id>CanTp.EB.RX.MIXED_AddressingFormat_PaddingOff_PduLengthSmallerThan8</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For a Rx N-SDU with CanTpFlexibleDataRateSupport equal to CANTP_OFF,
        CanTpRxPaddingActivation equal to CANTP_OFF and addressing format CANTP_MIXED,
        CanTp module shall be able to receive frames with the following payload length values:
      - payload length of 1 byte, for EcuC PduLength = 3
      - payload length of 2 bytes, for EcuC PduLength = 4
      - payload length of 3 bytes, for EcuC PduLength = 5
      - payload length of 4 bytes, for EcuC PduLength = 6
      - payload length of 5 bytes, for EcuC PduLength = 7
      </description>
      <comment>
      </comment>
      <verifycrit>
        Precondition:
    * CanTpFlexibleDataRateSupport = FALSE
    * CanTpTxPaddingActivation = CANTP_OFF
    * Addressing = MIXED
    * Frame type: SF
        Result:
        PduR is notified about the successfully received frame.
    </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_Con04_ST_MIX_EXT_CAN20_SF_Reception_PduLengthLessThan8</srcid><srcstatus/><internalId>1388</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>671</internalId></specobject>

    <specobject>
      <id>CanTp.EB.RX.EXTENDED_AddressingFormat_PaddingOff_PduLengthSmallerThan8</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For a Rx N-SDU with CanTpFlexibleDataRateSupport equal to CANTP_OFF,
        CanTpRxPaddingActivation equal to CANTP_OFF and addressing format CANTP_EXTENDED,
        CanTp module shall be able to receive frames with the following payload length values:
      - payload length of 1 byte, for EcuC PduLength = 3
      - payload length of 2 bytes, for EcuC PduLength = 4
      - payload length of 3 bytes, for EcuC PduLength = 5
      - payload length of 4 bytes, for EcuC PduLength = 6
      - payload length of 5 bytes, for EcuC PduLength = 7
      </description>
      <comment>
      </comment>
      <verifycrit>
        Precondition:
    * CanTpFlexibleDataRateSupport = FALSE
    * CanTpTxPaddingActivation = CANTP_OFF
    * Addressing = EXTENDED
    * Frame type: SF
        Result:
        PduR is notified about the successfully received frame.
    </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_Con04_ST_MIX_EXT_CAN20_SF_Reception_PduLengthLessThan8</srcid><srcstatus/><internalId>1388</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>672</internalId></specobject>

    <!-- == End Section: Supported PduLength values for small CAN 2.0 single frames =============================================== -->




  <!-- == Start Section: Flexible data rate feature ============================================== -->


    <specobject>
      <id>CanTp.EB.CanTpPaddingByteCanFD_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name: CanTpPaddingByteCanFD {CANTP_PADDING_BYTE_CANFD}
        Description:
        Used for the initialization of unused bytes with a certain
        value, within CAN FD PDUs.
        Multiplicity 0..1
        Type EcucIntegerParamDef
        Range 0 .. 255
        Default value -
        ConfigurationClass
        Pre-compile time  X All Variants
        Link time         -
        Post-build time   -
        Scope / Dependency: scope: ECU
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        Functional behavior covered by CanTp.SWS_CanTp_00351
      </comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>673</internalId></specobject>

    <specobject>
      <id>CanTp.EB.CanFD_Tx_FF_EcuC_PduLength</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For a Tx N-SDU with CanTpFlexibleDataRateSupport = true:
        The N-PDU size of a FF shall always be the highest allowed value. This value is limited by
        corresponding PduLength defined in EcuC and shall be one of the values 8, 12, 16, 20, 24,
        32, 48, or 64.
      </description>
      <comment>
      </comment>
      <verifycrit>
        Precondition:
    * Addressing = {standard, extended, mixed}
    * N-PDU EcuC PduLength = {8 .. 64}
    </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest09005_CanFD_Tx_FF_EcuC_PduLength</srcid><srcstatus/><internalId>1141</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>674</internalId></specobject>

    <specobject>
      <id>CanTp.EB.CanFD_Tx_CF_EcuC_PduLength</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For a Tx N-SDU with CanTpFlexibleDataRateSupport = true:
        The N-PDU size of a CF shall always be the highest allowed value. This value is limited by
        corresponding PduLength defined in EcuC and shall be one of the values 8, 12, 16, 20, 24,
        32, 48, or 64.
      </description>
      <comment>
      </comment>
      <verifycrit>
        Precondition:
    * Addressing = {standard, extended, mixed}
    * N-PDU EcuC PduLength = {8 .. 64}
    </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest09006_CanFD_Tx_CF_EcuC_PduLength</srcid><srcstatus/><internalId>1142</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>675</internalId></specobject>

    <specobject>
      <id>CanTp.EB.CanFD_Tx_SF_EcuC_MaxPduLength</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For a Tx N-SDU with CanTpFlexibleDataRateSupport = true:
        The N-PDU size of a SF shall not exceed the corresponding PduLength defined in EcuC.
      </description>
      <comment>
      </comment>
      <verifycrit>
        Precondition:
    * Addressing = {standard, extended, mixed}
    * N-PDU EcuC PduLength = {9 .. 64}
    </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest09007_CanFD_Tx_SF__EcuC_PduLength__Format</srcid><srcstatus/><internalId>1144</internalId></linkedfrom><linkedfrom><srcid>CanTp_ConTest09008_CanFD_Tx_LastCF_EcuC_MaxPduLength</srcid><srcstatus/><internalId>1145</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>676</internalId></specobject>

    <specobject>
      <id>CanTp.EB.CanFD_Tx_LastCF_EcuC_MaxPduLength</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For a Tx N-SDU with CanTpFlexibleDataRateSupport = true:
        The N-PDU size of a last CF shall not exceed the corresponding PduLength defined in EcuC.
      </description>
      <comment>
      </comment>
      <verifycrit>
        Precondition:
    * Addressing = {standard, extended, mixed}
    * N-PDU EcuC PduLength = {9 .. 64}
    </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest09008_CanFD_Tx_LastCF_EcuC_MaxPduLength</srcid><srcstatus/><internalId>1145</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>677</internalId></specobject>

    <specobject>
      <id>CanTp.EB.CanFD_Tx_SF_Format</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For an Tx N-SDU with CanTpFlexibleDataRate = true:
        If a N-PDU can be transmitted as SF with size greater than 8 byte, then
        N_PCI header shall be:
    * 1st byte - shall be zero.
    * 2nd byte - shall contain the payload length (without padding bytes).
      </description>
      <comment>
      </comment>
      <verifycrit>
        Precondition:
    * Addressing = {standard, extended, mixed}
    * Test with Can 2.0 (backward compatibility) &amp; Can Flexible Data conforming frames
    </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest09009_CanFD_Tx_SF_CAN_20</srcid><srcstatus/><internalId>1143</internalId></linkedfrom><linkedfrom><srcid>CanTp_ConTest09007_CanFD_Tx_SF__EcuC_PduLength__Format</srcid><srcstatus/><internalId>1144</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>678</internalId></specobject>

    <specobject>
      <id>CanTp.EB.Rx_SF_STANDARD_CanIdType</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For STANDARD_CAN CanIdType, the module shall accept incoming Single Frames
        with size equal to 8 bytes (for CAN 2.0 and small CAN FD frames), 12, 16, 20, 24, 32, 48, 64 (for CAN FD frames).
      </description>
      <comment>
      </comment>
      <verifycrit>
        Precondition:
    * Addressing = extended
    * N-PDU length = {8, 12, 16, 20, 24, 32, 48, or 64}
    </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest09031_Rx_SF_CAN_20_CANFD_EXTENDED_STANDARD_CanIdType</srcid><srcstatus/><internalId>1155</internalId></linkedfrom><linkedfrom><srcid>CanTp_ConTest_Reception_Of_Classical_CanFd_Invalid_SFs</srcid><srcstatus/><internalId>1160</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>679</internalId></specobject>

    <specobject>
      <id>CanTp.EB.Rx_SF_EXTENDED_CanIdType</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For EXTENDED_CAN CanIdType, the module shall accept incoming Single Frames
        with size equal to 8 bytes (for CAN 2.0 and small CAN FD frames), 12, 16, 20, 24, 32, 48, 64 (for CAN FD frames).
      </description>
      <comment>
      </comment>
      <verifycrit>
        Precondition:
    * Addressing = extended
    * N-PDU length = {8, 12, 16, 20, 24, 32, 48, or 64}
    </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest09031_Rx_SF_CAN_20_CANFD_EXTENDED_STANDARD_CanIdType</srcid><srcstatus/><internalId>1155</internalId></linkedfrom><linkedfrom><srcid>CanTp_ConTest_CanFD_Rx_SF_InvalidLength</srcid><srcstatus/><internalId>1159</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>680</internalId></specobject>


    <specobject>
      <id>CanTp.EB.Rx_FF_STANDARD_CanIdType</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For STANDARD_CAN CanIdType, the module shall accept incoming First Frames
        with size equal to 8 bytes (for CAN 2.0 and small CAN FD frames), 12, 16, 20, 24, 32, 48, 64 (for CAN FD frames).
      </description>
      <comment>
      </comment>
      <verifycrit>
        Precondition:
    * Addressing = standard
    * N-PDU length = {8, 12, 16, 20, 24, 32, 48, or 64}
    </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest09032_Rx_FF_CF_lastCF_CAN_20_CANFD_EXTENDED_STANDARD_CanIdType</srcid><srcstatus/><internalId>1156</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>681</internalId></specobject>

    <specobject>
      <id>CanTp.EB.Rx_FF_EXTENDED_CanIdType</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For EXTENDED_CAN CanIdType, the module shall accept incoming First Frames
        with size equal to 8 bytes (for CAN 2.0 and small CAN FD frames), 12, 16, 20, 24, 32, 48, 64 (for CAN FD frames).
      </description>
      <comment>
      </comment>
      <verifycrit>
        Precondition:
    * Addressing = extended
    * N-PDU length = {8, 12, 16, 20, 24, 32, 48, or 64}
    </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest09032_Rx_FF_CF_lastCF_CAN_20_CANFD_EXTENDED_STANDARD_CanIdType</srcid><srcstatus/><internalId>1156</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>682</internalId></specobject>

    <specobject>
      <id>CanTp.EB.Rx_FC_STANDARD_CanIdType</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For STANDARD_CAN CanIdType, the module shall accept incoming Flow Control frames
        with size equal to 8 bytes (for CAN 2.0 and small CAN FD frames), 12, 16, 20, 24, 32, 48, 64 (for CAN FD frames).
      </description>
      <comment>
      </comment>
      <verifycrit>
        Precondition:
    * Addressing = standard
    * N-PDU length = {8, 12, 16, 20, 24, 32, 48, or 64}
    </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest09032_Rx_FF_CF_lastCF_CAN_20_CANFD_EXTENDED_STANDARD_CanIdType</srcid><srcstatus/><internalId>1156</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>683</internalId></specobject>

    <specobject>
      <id>CanTp.EB.Rx_FC_EXTENDED_CanIdType</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For EXTENDED_CAN CanIdType, the module shall accept incoming Flow Control frames
        with size equal to 8 bytes (for CAN 2.0 and small CAN FD frames), 12, 16, 20, 24, 32, 48, 64 (for CAN FD frames).
      </description>
      <comment>
      </comment>
      <verifycrit>
        Precondition:
    * Addressing = extended
    * N-PDU length = {8, 12, 16, 20, 24, 32, 48, or 64}
    </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest09032_Rx_FF_CF_lastCF_CAN_20_CANFD_EXTENDED_STANDARD_CanIdType</srcid><srcstatus/><internalId>1156</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>684</internalId></specobject>


    <specobject>
      <id>CanTp.EB.Rx_CF_STANDARD_CanIdType</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For STANDARD_CAN CanIdType, the module shall accept incoming Consecutive Frames
        with size equal to 8 bytes (for CAN 2.0 and small CAN FD frames), 12, 16, 20, 24, 32, 48, 64 (for CAN FD frames).
      </description>
      <comment>
      </comment>
      <verifycrit>
        Precondition:
    * Addressing = standard
    * N-PDU length = {8, 12, 16, 20, 24, 32, 48, or 64}
    </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest09032_Rx_FF_CF_lastCF_CAN_20_CANFD_EXTENDED_STANDARD_CanIdType</srcid><srcstatus/><internalId>1156</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00269_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>178</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>685</internalId></specobject>

    <specobject>
      <id>CanTp.EB.Rx_CF_EXTENDED_CanIdType</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For EXTENDED_CAN CanIdType, the module shall accept incoming Consecutive Frames
        with size equal to 8 bytes (for CAN 2.0 and small CAN FD frames), 12, 16, 20, 24, 32, 48, 64 (for CAN FD frames).
      </description>
      <comment>
      </comment>
      <verifycrit>
        Precondition:
    * Addressing = extended
    * N-PDU length = {8, 12, 16, 20, 24, 32, 48, or 64}
    </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest09032_Rx_FF_CF_lastCF_CAN_20_CANFD_EXTENDED_STANDARD_CanIdType</srcid><srcstatus/><internalId>1156</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00269_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>178</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>686</internalId></specobject>


    <specobject>
      <id>CanTp.EB.Rx_lastCF_STANDARD_CanIdType</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For STANDARD_CAN CanIdType, the module shall accept incoming last Consecutive Frames
        with size equal to 8 bytes (for CAN 2.0 and small CAN FD frames), 12, 16, 20, 24, 32, 48, 64 (for CAN FD frames).
      </description>
      <comment>
      </comment>
      <verifycrit>
        Precondition:
    * Addressing = standard
    * N-PDU length = {8, 12, 16, 20, 24, 32, 48, or 64}
    </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest09032_Rx_FF_CF_lastCF_CAN_20_CANFD_EXTENDED_STANDARD_CanIdType</srcid><srcstatus/><internalId>1156</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00269_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>178</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>687</internalId></specobject>

    <specobject>
      <id>CanTp.EB.Rx_lastCF_EXTENDED_CanIdType</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For EXTENDED_CAN CanIdType, the module shall accept incoming last Consecutive Frames
        with size equal to 8 bytes (for CAN 2.0 and small CAN FD frames), 12, 16, 20, 24, 32, 48, 64 (for CAN FD frames).
      </description>
      <comment>
      </comment>
      <verifycrit>
        Precondition:
    * Addressing = extended
    * N-PDU length = {8, 12, 16, 20, 24, 32, 48, or 64}
    </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest09032_Rx_FF_CF_lastCF_CAN_20_CANFD_EXTENDED_STANDARD_CanIdType</srcid><srcstatus/><internalId>1156</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00269_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>178</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>688</internalId></specobject>

    <specobject>
      <id>CanTp.EB.CanFD_Rx_SF</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For an Rx N-SDU with CanTpFlexibleDataRate = true:
        The module shall accept incoming SF with size greater than 8 byte and N_PCI header with:
    * 1st byte - is zero.
    * 2nd byte - contains data length.
        The payload data shall be passed to the upper layer.
      </description>
      <comment>
      </comment>
      <verifycrit>
        Precondition:
    * Addressing = {standard, extended, mixed}
    * N-PDU length = {12, 16, 20, 24, 32, 48, or 64}
    * Test with and without padding bytes.
    * Test with Can 2.0 &amp; Can Flexible Data conforming frames
    </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest09011_CanFD_Rx_SF_CAN_20</srcid><srcstatus/><internalId>1150</internalId></linkedfrom><linkedfrom><srcid>CanTp_ConTest09010_CanFD_Rx_SF</srcid><srcstatus/><internalId>1151</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>689</internalId></specobject>

    <specobject>
      <id>CanTp.EB.CanFD_Rx_FF</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For an Rx N-SDU with CanTpFlexibleDataRate = true:
        The module shall accept incoming FF with size greater than 8 byte.
      </description>
      <comment>
      </comment>
      <verifycrit>
        Precondition:
    * Addressing = {standard, extended, mixed}
    * N-PDU length = {12, 16, 20, 24, 32, 48, or 64}
    * Test with Can 2.0 &amp; Can Flexible Data conforming frames
    </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest09012_CanFD_Rx_FF_CF_LastCF</srcid><srcstatus/><internalId>1152</internalId></linkedfrom><linkedfrom><srcid>CanTp_ConTest09013_CanFD_Rx_Multiframe</srcid><srcstatus/><internalId>1153</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>690</internalId></specobject>

    <specobject>
      <id>CanTp.EB.CanFD_Rx_CF</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For an Rx N-SDU with CanTpFlexibleDataRate = true:
        The module shall accept incoming CF with size greater than 8 byte.
      </description>
      <comment>
      </comment>
      <verifycrit>
        Precondition:
    * Addressing = {standard, extended, mixed}
    * N-PDU length = {12, 16, 20, 24, 32, 48, or 64}
    </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest09012_CanFD_Rx_FF_CF_LastCF</srcid><srcstatus/><internalId>1152</internalId></linkedfrom><linkedfrom><srcid>CanTp_ConTest09013_CanFD_Rx_Multiframe</srcid><srcstatus/><internalId>1153</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>691</internalId></specobject>

    <specobject>
      <id>CanTp.EB.CanFD_Rx_LastCF</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For an Rx N-SDU with CanTpFlexibleDataRate = true:
        The module shall accept incoming last CF with size greater than 8 byte.
      </description>
      <comment>
      </comment>
      <verifycrit>
        Precondition:
    * Addressing = {standard, extended, mixed}
    * N-PDU length = {12, 16, 20, 24, 32, 48, or 64}
    * Test with and without padding bytes.
    </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest09012_CanFD_Rx_FF_CF_LastCF</srcid><srcstatus/><internalId>1152</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>692</internalId></specobject>

    <specobject>
      <id>CanTp.EB.CanFD_Rx_InvalidSize</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For an Rx N-SDU with CanTpFlexibleDataRateSupport = true
        If a received frame is greater than 8 and does not match 12, 16, 20, 24, 32, 48, or 64,
        the frame shall be ignored.
        If the development error detection is enabled, a
        development error CANTP_E_PADDING shall be triggered. (SRS_Can_01073)
      </description>
      <comment>
    * CANTP_E_PADDING does not exist in AUTOSAR 4.0.3. Instead CANTP_E_INVALID_RX_LENGTH shall
      be reported.
      </comment>
      <verifycrit>
        Precondition:
    * Addressing = {standard, extended, mixed}
    * N-PDU length != {12, 16, 20, 24, 32, 48, or 64}
    * Test with and without padding bytes.
    * SF, FF, CF, LastCF
    </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest09014_CanFD_Rx_InvalidSize</srcid><srcstatus/><internalId>1154</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>693</internalId></specobject>

    <specobject>
      <id>CanTp.EB.CanFD_Rx_BigData</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For an Rx N-SDU with CanTpFlexibleDataRateSupport = true
        The module shall be able to receive segmented CAN FD frames with more than 4095 bytes
        payload.
      </description>
      <comment>
      </comment>
      <verifycrit>
        Precondition:
    * Addressing = {standard, extended, mixed}
    * N-PDU length = {8, 12, 16, 20, 24, 32, 48, or 64}
    * N-SDU length = {&gt; 4095}
    * Test with and without padding bytes.
    * Verify received payload.
    * Test with Can 2.0 &amp; Can Flexible Data conforming frames
    </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest09027_BigData_Rx_Standard_Addr</srcid><srcstatus/><internalId>1137</internalId></linkedfrom><linkedfrom><srcid>CanTp_ConTest09028_BigData_Rx_Extended_Addr</srcid><srcstatus/><internalId>1138</internalId></linkedfrom><linkedfrom><srcid>CanTp_ConTest09029_BigData_Rx_Mixed_Addr</srcid><srcstatus/><internalId>1139</internalId></linkedfrom><linkedfrom><srcid>CanTp_ConTest09015_CanFD_Rx_BigData</srcid><srcstatus/><internalId>1158</internalId></linkedfrom><linkedfrom><srcid>CanTp_ConTest10_002_CAN20_and_CANFD_Rx_FF_Format_Standard_Addr</srcid><srcstatus/><internalId>1164</internalId></linkedfrom><linkedfrom><srcid>CanTp_ConTest10_003_BigData_Rx_FF_Format_Mixed_Addr</srcid><srcstatus/><internalId>1165</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>694</internalId></specobject>

    <specobject>
      <id>CanTp.EB.CanFD_Tx_BigData</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For an Tx N-SDU with CanTpFlexibleDataRateSupport = true
        The module shall be able to transmit segmented CAN FD frames with more than 4095 bytes
        payload.
      </description>
      <comment>
      </comment>
      <verifycrit>
        Precondition:
    * Addressing = {standard, extended, mixed}
    * N-PDU length = {8, 12, 16, 20, 24, 32, 48, or 64}
    * N-SDU length = {&gt; 4095}
    * Test with and without padding bytes.
    * Verify received payload.
    * Test with Can 2.0 &amp; Can Flexible Data conforming frames
    </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest09020_BigData_Tx_Standard_Addr</srcid><srcstatus/><internalId>1131</internalId></linkedfrom><linkedfrom><srcid>CanTp_ConTest09021_BigData_Tx_Extended_Addr</srcid><srcstatus/><internalId>1132</internalId></linkedfrom><linkedfrom><srcid>CanTp_ConTest09022_BigData_Tx_Mixed_Addr</srcid><srcstatus/><internalId>1133</internalId></linkedfrom><linkedfrom><srcid>CanTp_ConTest09016_CanFD_Tx_BigData</srcid><srcstatus/><internalId>1149</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>695</internalId></specobject>

    <!-- == End Section: Flexible data rate feature ================================================ -->


  <!-- == Start Section: Parallel channels feature ======================================================== -->

  <specobject>
      <id>CanTp.EB.Transmission.AllParallelChannelsBusy</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
      When the upper layer performs a transmisssion request and all Tx parallel channels are busy,
      then the transmission request shall be ignored.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_Transmit_SF_ParallelChannelsHandling</srcid><srcstatus/><internalId>1636</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_Transmit_MF_ParallelChannelsHandling</srcid><srcstatus/><internalId>1637</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_Transmit_MF_ParallelChannelsHandling_UseTheCorrespondingLockedChannel_FirstChannelFreeAndSecondLocked_TakesSecond</srcid><srcstatus/><internalId>1638</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_Transmit_MF_ParallelChannelsHandling_UseTheCorrespondingLockedChannel_FirstChannelLockedAndSecondFree_TakesFirst</srcid><srcstatus/><internalId>1639</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>696</internalId></specobject>

    <specobject>
      <id>CanTp.EB.Transmission.AtLeastOneParallelChannelFree</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
      When the upper layer performs a transmission request and at least one of the Tx parallel channels is free,
      then the first available Tx channel shall be used.
      </description>
      <comment>
      Handling of N-PDU arrivals for half duplex channels is not supported, when parallel channels are enabled.
      When a transmission request on a half duplex channel happens and reception is in progress on the same channel,
      the first free Tx Channel is used.
        </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_Transmit_SF_ParallelChannelsHandling</srcid><srcstatus/><internalId>1636</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_Transmit_MF_ParallelChannelsHandling</srcid><srcstatus/><internalId>1637</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_Transmit_MF_ParallelChannelsHandling_UseTheCorrespondingLockedChannel_FirstChannelFreeAndSecondLocked_TakesSecond</srcid><srcstatus/><internalId>1638</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_Transmit_MF_ParallelChannelsHandling_UseTheCorrespondingLockedChannel_FirstChannelLockedAndSecondFree_TakesFirst</srcid><srcstatus/><internalId>1639</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>697</internalId></specobject>

    <specobject>
      <id>CanTp.EB.Transmission.AllParallelChannelsFree</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
      When the upper layer performs a transmission request and all Tx parallel channels are free,
      then the first available Tx channel shall be used.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_Transmit_SF_ParallelChannelsHandling</srcid><srcstatus/><internalId>1636</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_Transmit_MF_ParallelChannelsHandling</srcid><srcstatus/><internalId>1637</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_Transmit_MF_ParallelChannelsHandling_UseTheCorrespondingLockedChannel_FirstChannelFreeAndSecondLocked_TakesSecond</srcid><srcstatus/><internalId>1638</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_Transmit_MF_ParallelChannelsHandling_UseTheCorrespondingLockedChannel_FirstChannelLockedAndSecondFree_TakesFirst</srcid><srcstatus/><internalId>1639</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>698</internalId></specobject>


    <specobject>
      <id>CanTp.EB.Reception.AllParallelChannelsBusy</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
      When the lower layer notifies CanTp about a new data reception and all Rx parallel channels are busy,
      then the reception shall be ignored.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_Receive_MF_ParallelChannelsHandling</srcid><srcstatus/><internalId>1641</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>699</internalId></specobject>

    <specobject>
      <id>CanTp.EB.Reception.AtLeastOneParallelChannelFree</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
      When the lower layer notifies CanTp about a new data reception and at least one Rx parallel channel is free,
      then the first free Rx channel shall be used.
      </description>
      <comment>
      Handling of N-PDU arrivals for half duplex channels is not supported, when parallel channels are enabled.
      When a new data reception on a half duplex channel happens and transmission is in progress on the same channel,
      the first free Rx Channel is used.
        </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_Receive_MF_ParallelChannelsHandling</srcid><srcstatus/><internalId>1641</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>700</internalId></specobject>

    <specobject>
      <id>CanTp.EB.Reception.AllParallelChannelsFree</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
      When the lower layer notifies CanTp about a new data reception and all Rx paraller channels are free,
      then the first free Rx channel shall be used.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_Receive_MF_ParallelChannelsHandling</srcid><srcstatus/><internalId>1641</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>701</internalId></specobject>


    <specobject>
      <id>CanTp.EB.MaximumNoOfTxParallelChannels_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
      Name: CanTpMaxParallelTxChannels {CANTP_MAX_PARALLEL_TX_CHANNELS}
      Description:
        Allow to configure a maximum number of parallel channels.
        Please note: The number of Tx parallel channels shall be
        smaller or equal to the number of CanTpMaxTxChannels.
      Multiplicity 0..1
      Type EcucIntegerParamDef
      Range 0 .. 0..32767
      Default value -
      ConfigurationClass
        Pre-compile time  X VARIANT-PRE-COMPILE
        Link time         -
        Post-build time   X VARIANT-POST-BUILD
      Scope / Dependency: scope: ECU
      </description>
      <comment>
      This is a configuration parameter requirement without functional specification.
        </comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>702</internalId></specobject>

    <specobject>
      <id>CanTp.EB.MaximumNoOfRxParallelChannels_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
      Name: CanTpMaxParallelRxChannels {CANTP_MAX_PARALLEL_RX_CHANNELS}
      Description:
        Allow to configure a maximum number of parallel channels.
        Please note: The number of Rx parallel channels shall be
        smaller or equal to the number of CanTpMaxRxChannels.
      Multiplicity 0..1
      Type EcucIntegerParamDef
      Range 0 .. 0..32767
      Default value -
      ConfigurationClass
        Pre-compile time  X VARIANT-PRE-COMPILE
        Link time         -
        Post-build time   X VARIANT-POST-BUILD
      Scope / Dependency: scope: ECU
      </description>
      <comment>
      This is a configuration parameter requirement without functional specification.
        </comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>703</internalId></specobject>



    <!-- == End Section: Parallel channels feature ================================================ -->


  <!-- == Start Section: Big data feature ======================================================== -->

  <specobject>
      <id>CanTp.EB.BigData_Tx_FF_Format</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For a Tx N-SDU and PduLength defined in EcuC greater 4095:
        If CanTp_Transmit() is called with N_SDU length more than 4095, the first frame
        shall have a N_PCI header of 6 bytes.
        N_PCI header bytes:
    * 1st byte upper nibble - contains frame type (FF).
    * 1st byte lower nibble - is zero.
    * 2nd byte - is zero.
    * 3rd till 6th byte - contain the data length (without padding bytes).
      </description>
      <comment>
      </comment>
      <verifycrit>
        Precondition:
    * Addressing = {standard, extended, mixed}
    * N-SDU length = {4096, 65535}
    * Verify first frame.
    </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest09017_BigData_Tx_FF_Format_Standard_Addr</srcid><srcstatus/><internalId>1128</internalId></linkedfrom><linkedfrom><srcid>CanTp_ConTest09018_BigData_Tx_FF_Format_Extended_Addr</srcid><srcstatus/><internalId>1129</internalId></linkedfrom><linkedfrom><srcid>CanTp_ConTest09019_BigData_Tx_FF_Format_Mixed_Addr</srcid><srcstatus/><internalId>1130</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>704</internalId></specobject>

    <specobject>
      <id>CanTp.EB.BigData_Tx</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For a Tx N-SDU and PduLength defined in EcuC greater 4095:
        If CanTp_Transmit() is called with N_SDU length more than 4095, the module shall perform
        a segmented transmission of all bytes.
      </description>
      <comment>
      </comment>
      <verifycrit>
        Precondition:
    * Addressing = {standard, extended, mixed}
    * N-SDU length = {4096, 65535}
    * Test with and without padding bytes.
    * Verify transmitted frames.
    </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest09020_BigData_Tx_Standard_Addr</srcid><srcstatus/><internalId>1131</internalId></linkedfrom><linkedfrom><srcid>CanTp_ConTest09021_BigData_Tx_Extended_Addr</srcid><srcstatus/><internalId>1132</internalId></linkedfrom><linkedfrom><srcid>CanTp_ConTest09022_BigData_Tx_Mixed_Addr</srcid><srcstatus/><internalId>1133</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>705</internalId></specobject>

    <specobject>
      <id>CanTp.EB.BigData_Rx_FF_Format</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The module shall be able to receive and process FF which use a 6 byte N_PCI header.

        Such FF have following N_PCI byte values:
    * Upper nibble of 1st byte contains frame type (FF).
    * Lower nibble of 1st byte is 0.
    * 2nd byte is 0.
    * 3rd till 6th byte contain the data length (without padding bytes).

        The rest of the FF is filled with data.
      </description>
      <comment>
      </comment>
      <verifycrit>
        Precondition:
    * Addressing = {standard, extended, mixed}
    * N-SDU length = {4096, 65535}
    </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest09024_BigData_Rx_FF_Format_Standard_Addr</srcid><srcstatus/><internalId>1134</internalId></linkedfrom><linkedfrom><srcid>CanTp_ConTest09025_BigData_Rx_FF_Format_Extended_Addr</srcid><srcstatus/><internalId>1135</internalId></linkedfrom><linkedfrom><srcid>CanTp_ConTest09026_BigData_Rx_FF_Format_Mixed_Addr</srcid><srcstatus/><internalId>1136</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>706</internalId></specobject>

    <specobject>
      <id>CanTp.EB.BigData_Rx</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The module shall be able to receive a segmented message with more than 4095 bytes.
      </description>
      <comment>
      </comment>
      <verifycrit>
        Precondition:
    * Addressing = {standard, extended, mixed}
    * N-SDU length = {4096, 65535}
    * Test with and without padding bytes.
    * Verify received frames.
    </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest09027_BigData_Rx_Standard_Addr</srcid><srcstatus/><internalId>1137</internalId></linkedfrom><linkedfrom><srcid>CanTp_ConTest09028_BigData_Rx_Extended_Addr</srcid><srcstatus/><internalId>1138</internalId></linkedfrom><linkedfrom><srcid>CanTp_ConTest09029_BigData_Rx_Mixed_Addr</srcid><srcstatus/><internalId>1139</internalId></linkedfrom><linkedfrom><srcid>CanTp_ConTest10_002_CAN20_and_CANFD_Rx_FF_Format_Standard_Addr</srcid><srcstatus/><internalId>1164</internalId></linkedfrom><linkedfrom><srcid>CanTp_ConTest10_003_BigData_Rx_FF_Format_Mixed_Addr</srcid><srcstatus/><internalId>1165</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>707</internalId></specobject>

    <specobject>
      <id>CanTp.EB.BigData_Rx_InvalidLength</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If a FF is received and the contained message length for the I-PDU exceeds the configured
        PduLength type then the frame shall be ignored.
        If the development error detection is enabled, a development error CANTP_E_PADDING
        shall be triggered.
      </description>
      <comment>
    * CANTP_E_PADDING does not exist in AUTOSAR 4.0.3. Instead CANTP_E_INVALID_RX_LENGTH shall
      be reported.
      </comment>
      <verifycrit>
        Precondition:
    * N-SDU length = {65535}
    </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest09030_BigData_Rx_InvalidMsgLength</srcid><srcstatus/><internalId>1140</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>708</internalId></specobject>

    <specobject>
      <id>CanTp.EB.SWS_CanTp_00030_1g</id>
      <status>approved</status>
      <source>EB refinement</source>
      <version>1</version>
      <description>
        After the function call CanTp_Init(), the module shall use the configuration parameter
        CanTpPaddingByteCanFD for CAN-FD frames as the value of unused bytes in transmitted frames
        if configured; otherwise CanTpPaddingByte shall be used.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest10_001_CANFD_SF_CANFD_PADDING_VALUE</srcid><srcstatus/><internalId>1161</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00030_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>129</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>709</internalId></specobject>

    <!-- == End Section: Big data feature ========================================================== -->

  <!-- == XDM/MCG Checks ========================================================================= -->

  <specobject>
      <id>CanTp.EB.Xdm.RxNSduRef.MaxPduLength</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If CanTpRxNSduRef refers to a PDU with configured length more than 65535, then an error
        shall be generated.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_GenTest_01010_Xdm_RxNSduRef_MaxPduLength</srcid><srcstatus/><internalId>1535</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>710</internalId></specobject>

    <specobject>
      <id>CanTp.EB.Xdm.TxNSduRef.MaxPduLength</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If CanTpTxNSduRef refers to a PDU with configured length more than 65535, then an error
        shall be generated.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_GenTest_01011_Xdm_TxNSduRef_MaxPduLength</srcid><srcstatus/><internalId>1536</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
      <provcov>
      <linksto>CanTp.SWS_CanTp_00354</linksto>
      <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>358</internalId></provcov>
    </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>711</internalId></specobject>

    <specobject>
      <id>CanTp.EB.Xdm.RxNPduRef.MinPduLength</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If CanTpRxNPduRef refers to a PDU with configured length smaller than 8, then an error
        shall be generated.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_GenTest_01001_Xdm_CanTpTxNPduRef_INV_00</srcid><srcstatus/><internalId>1547</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>712</internalId></specobject>

    <specobject>
      <id>CanTp.EB.Xdm.TxNPduRef.MinPduLength</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If CanTpTxNPduRef refers to a PDU with configured length smaller than 8, then an error
        shall be generated.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_GenTest_01001_Xdm_CanTpTxNPduRef_INV_00</srcid><srcstatus/><internalId>1547</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>713</internalId></specobject>

    <specobject>
      <id>CanTp.EB.Xdm.RxNPduRef.ValidPduLength</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For a N-SDU with CanTpFlexibleDataRate = true:
        If CanTpRxNPduRef refers to a PDU with configured length other than 8, 12, 16, 20, 24, 32,
        48, or 64, then an error shall be generated.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_GenTest_01001_Xdm_CanTpTxNPduRef_INV_00</srcid><srcstatus/><internalId>1547</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>714</internalId></specobject>

    <specobject>
      <id>CanTp.EB.Xdm.TxNPduRef.ValidPduLength</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For a N-SDU with CanTpFlexibleDataRate = true:
        If CanTpTxNPduRef refers to a PDU with configured length other than 8, 12, 16, 20, 24, 32,
        48, or 64, then an error shall be generated.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_GenTest_01001_Xdm_CanTpTxNPduRef_INV_00</srcid><srcstatus/><internalId>1547</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>715</internalId></specobject>

    <specobject>
      <id>CanTp.EB.MCG.CanFd.RX.EXTENDED.CanIdType</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If CanTpRxNPduRef refers a PDU with configured length
        greater than 8 and CanIdType is EXTENDED_NO_FD_CAN, then an error shall be generated.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_GenTest_01001_MCG_CanIdType_INV_00</srcid><srcstatus/><internalId>1543</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>716</internalId></specobject>

    <specobject>
      <id>CanTp.EB.MCG.CanFd.RX.STANDARD.CanIdType</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If CanTpRxNPduRef refers a PDU with configured length
        greater than 8 and CanIdType is STANDARD_NO_FD_CAN, then an error shall be generated.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_GenTest_01002_MCG_CanIdType_INV_00</srcid><srcstatus/><internalId>1544</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>717</internalId></specobject>

    <specobject>
      <id>CanTp.EB.MCG.CanFd.TX.EXTENDED.CanIdType</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If CanTpTxNPduRef refers a PDU with configured length
        greater than 8 and CanIdType is EXTENDED_CAN, then an error shall be generated.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_GenTest_01003_MCG_CanIdType_INV_00</srcid><srcstatus/><internalId>1545</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>718</internalId></specobject>

    <specobject>
      <id>CanTp.EB.MCG.CanFd.TX.STANDARD.CanIdType</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If CanTpTxNPduRef refers a PDU with configured length
        greater than 8 and CanIdType is STANDARD_CAN, then an error shall be generated.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_GenTest_01004_MCG_CanIdType_INV_00</srcid><srcstatus/><internalId>1546</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>719</internalId></specobject>

    <specobject>
      <id>CanTp.EB.MCG.TX.CAN20_NOFD_FUNC_TaType_STANDARD_Addressing_InvalidPduLength</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If CanTpTxNPduRef refers a PDU with configured
        length less or equal than 1 for an NSdu with a CANTP_STANDARD addressing format,
        padding activation CANTP_OFF, NO FD CanIdType and CANTP_FUNCTIONAL TaType,
        then an error shall be generated.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_GenTest_01002_MCG_CAN20_NoFD_StandardAddressing_Invalid_TX_PduLength_0</srcid><srcstatus/><internalId>1563</internalId></linkedfrom><linkedfrom><srcid>CanTp_GenTest_01004_MCG_CAN20_NoFD_StandardAddressing_Invalid_TX_PduLength_1</srcid><srcstatus/><internalId>1565</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>720</internalId></specobject>

    <specobject>
      <id>CanTp.EB.MCG.TX.CAN20_NOFD_FUNC_TaType_MIXED_Addressing_InvalidPduLength</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If CanTpTxNPduRef refers a PDU with configured
        length less or equal than 2 for an NSdu with a CANTP_MIXED addressing format,
        padding activation CANTP_OFF, NO FD CanIdType and CANTP_FUNCTIONAL TaType,
        then an error shall be generated.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_GenTest_01006_MCG_CAN20_NoFD_Mixed_Addressing_Invalid_TX_PduLength_0</srcid><srcstatus/><internalId>1567</internalId></linkedfrom><linkedfrom><srcid>CanTp_GenTest_01008_MCG_CAN20_NoFD_Mixed_Addressing_Invalid_TX_PduLength_1</srcid><srcstatus/><internalId>1569</internalId></linkedfrom><linkedfrom><srcid>CanTp_GenTest_01010_MCG_CAN20_NoFD_Mixed_Addressing_Invalid_TX_PduLength_2</srcid><srcstatus/><internalId>1571</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>721</internalId></specobject>

    <specobject>
      <id>CanTp.EB.MCG.TX.CAN20_NOFD_FUNC_TaType_EXTENDED_Addressing_InvalidPduLength</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If CanTpTxNPduRef refers a PDU with configured
        length less or equal than 2 for an NSdu with an CANTP_EXTENDED addressing format,
        padding activation CANTP_OFF, NO FD CanIdType and CANTP_FUNCTIONAL TaType,
        then an error shall be generated.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_GenTest_01012_MCG_CAN20_NoFD_Extended_Addressing_Invalid_TX_PduLength_0</srcid><srcstatus/><internalId>1573</internalId></linkedfrom><linkedfrom><srcid>CanTp_GenTest_01014_MCG_CAN20_NoFD_Extended_Addressing_Invalid_TX_PduLength_1</srcid><srcstatus/><internalId>1575</internalId></linkedfrom><linkedfrom><srcid>CanTp_GenTest_01016_MCG_CAN20_NoFD_Extended_Addressing_Invalid_TX_PduLength_2</srcid><srcstatus/><internalId>1577</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>722</internalId></specobject>

    <specobject>
      <id>CanTp.EB.MCG.RX.CAN20_NOFD_FUNC_TaType_STANDARD_Addressing_InvalidPduLength</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If CanTpRxNPduRef refers a PDU with configured
        length less or equal than 1 for an NSdu with a CANTP_STANDARD addressing format,
        padding activation CANTP_OFF, NO FD CanIdType and CANTP_FUNCTIONAL TaType,
        then an error shall be generated.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_GenTest_01001_MCG_CAN20_NoFD_StandardAddressing_Invalid_RX_PduLength_0</srcid><srcstatus/><internalId>1562</internalId></linkedfrom><linkedfrom><srcid>CanTp_GenTest_01003_MCG_CAN20_NoFD_StandardAddressing_Invalid_RX_PduLength_1</srcid><srcstatus/><internalId>1564</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>723</internalId></specobject>

    <specobject>
      <id>CanTp.EB.MCG.RX.CAN20_NOFD_FUNC_TaType_MIXED_Addressing_InvalidPduLength</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If CanTpRxNPduRef refers a PDU with configured
        length less or equal than 2 for an NSdu with a CANTP_MIXED addressing format,
        padding activation CANTP_OFF, NO FD CanIdType and CANTP_FUNCTIONAL TaType,
        then an error shall be generated.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_GenTest_01005_MCG_CAN20_NoFD_Mixed_Addressing_Invalid_RX_PduLength_0</srcid><srcstatus/><internalId>1566</internalId></linkedfrom><linkedfrom><srcid>CanTp_GenTest_01007_MCG_CAN20_NoFD_Mixed_Addressing_Invalid_RX_PduLength_1</srcid><srcstatus/><internalId>1568</internalId></linkedfrom><linkedfrom><srcid>CanTp_GenTest_01009_MCG_CAN20_NoFD_Mixed_Addressing_Invalid_RX_PduLength_2</srcid><srcstatus/><internalId>1570</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>724</internalId></specobject>

    <specobject>
      <id>CanTp.EB.MCG.RX.CAN20_NOFD_FUNC_TaType_EXTENDED_Addressing_InvalidPduLength</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If CanTpRxNPduRef refers a PDU with configured
        length less or equal than 2 for an NSdu with a CANTP_EXTENDED addressing format,
        padding activation CANTP_OFF, NO FD CanIdType and CANTP_FUNCTIONAL TaType,
        then an error shall be generated.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_GenTest_01011_MCG_CAN20_NoFD_Extended_Addressing_Invalid_RX_PduLength_0</srcid><srcstatus/><internalId>1572</internalId></linkedfrom><linkedfrom><srcid>CanTp_GenTest_01013_MCG_CAN20_NoFD_Extended_Addressing_Invalid_RX_PduLength_1</srcid><srcstatus/><internalId>1574</internalId></linkedfrom><linkedfrom><srcid>CanTp_GenTest_01015_MCG_CAN20_NoFD_Extended_Addressing_Invalid_RX_PduLength_2</srcid><srcstatus/><internalId>1576</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>725</internalId></specobject>

    <specobject>
      <id>CanTp.EB.MCG.TX.PHYSICAL_TaType_InvalidPduLength</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If CanTpTxNPduRef refers a PDU with configured
        length less then 8 bytes for an NSdu with a CANTP_PHYSICAL TaType (multiframe),
        then an error shall be generated.
        (ISO 15765-2:2016: A valid FF always has a CAN_DL value greater than or equal to 8.)
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_GenTest_01018_MCG_PHYSICAL_TaType_Invalid_TX_PduLength_SmallerThan8</srcid><srcstatus/><internalId>1579</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>726</internalId></specobject>

    <specobject>
      <id>CanTp.EB.MCG.RX.PHYSICAL_TaType_STANDARD_CAN_InvalidPduLength</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If CanTpRxNPduRef refers a PDU with configured
        length less then 8 bytes for an NSdu with a CANTP_PHYSICAL TaType (multiframe)
        and STANDARD_CAN CanIdType, then an error shall be generated.
        (ISO 15765-2:2016: A valid FF always has a CAN_DL value greater than or equal to 8.)
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_GenTest_01017_MCG_PHYSICAL_TaType_STANDARD_CAN_CanIdType_Invalid_RX_PduLength_SmallerThan8</srcid><srcstatus/><internalId>1578</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>727</internalId></specobject>

    <specobject>
      <id>CanTp.EB.MCG.RX.PHYSICAL_TaType_EXTENDED_CAN_InvalidPduLength</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If CanTpRxNPduRef refers a PDU with configured
        length less then 8 bytes for an NSdu with a CANTP_PHYSICAL TaType (multiframe)
        and EXTENDED_CAN CanIdType, then an error shall be generated.
        (ISO 15765-2:2016: A valid FF always has a CAN_DL value greater than or equal to 8.)
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_GenTest_01019_MCG_PHYSICAL_TaType_EXTENDED_CAN_CanIdType_Invalid_RX_PduLength_SmallerThan8</srcid><srcstatus/><internalId>1580</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>728</internalId></specobject>


    <!-- Functional TX/RX CAN FD frames with configured PduLength smaller than 8 bytes -->

  <specobject>
      <id>CanTp.EB.MCG.RX.FUNC_TaType_STANDARD_FD_CAN_PduLengthLessThan8</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If CanTpRxNSduRef refers to a PDU with configured length smaller than 8 bytes,
        for an NSdu with a CANTP_FUNCTIONAL addressing format (single frame) and STANDARD_FD_CAN CanIdType,
        than an error shall be generated.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_GenTest_01020_MCG_FUNCTIONAL_TaType_STANDARD_FD_CAN_CanIdType_Invalid_RX_PduLength_SmallerThan8</srcid><srcstatus/><internalId>1581</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>729</internalId></specobject>

    <specobject>
      <id>CanTp.EB.MCG.RX.FUNC_TaType_EXTENDED_FD_CAN_PduLengthLessThan8</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If CanTpRxNSduRef refers to a PDU with configured length smaller than 8 bytes,
        for an NSdu with a CANTP_FUNCTIONAL addressing format (single frame) and EXTENDED_FD_CAN CanIdType,
        than an error shall be generated.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_GenTest_01021_MCG_FUNCTIONAL_TaType_EXTENDED_FD_CAN_CanIdType_Invalid_RX_PduLength_SmallerThan8</srcid><srcstatus/><internalId>1582</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>730</internalId></specobject>

    <specobject>
      <id>CanTp.EB.MCG.TX.FUNC_TaType_STANDARD_FD_CAN_PduLengthLessThan8</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If CanTpTxNSduRef refers to a PDU with configured length smaller than 8 bytes,
        for an NSdu with a CANTP_FUNCTIONAL addressing format (single frame) and STANDARD_FD_CAN CanIdType,
        than an error shall be generated.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_GenTest_01022_MCG_FUNCTIONAL_TaType_STANDARD_FD_CAN_CanIdType_Invalid_TX_PduLength_SmallerThan8</srcid><srcstatus/><internalId>1583</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>731</internalId></specobject>

    <specobject>
      <id>CanTp.EB.MCG.TX.FUNC_TaType_EXTENDED_FD_CAN_PduLengthLessThan8</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If CanTpTxNSduRef refers to a PDU with configured length smaller than 8 bytes,
        for an NSdu with a CANTP_FUNCTIONAL addressing format (single frame) and EXTENDED_FD_CAN CanIdType,
        than an error shall be generated.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_GenTest_01023_MCG_FUNCTIONAL_TaType_EXTENDED_FD_CAN_CanIdType_Invalid_TX_PduLength_SmallerThan8</srcid><srcstatus/><internalId>1584</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>732</internalId></specobject>


    <!-- Invalid RX PduLength values for PHYSICAL or FUNCTIONAL TaType, STANDARD_CAN (Classic or CanFd frames) or EXTENDED_CAN (Classic or CanFd frames), and padding activation    CANTP_ON_CAN_CAN_FD. -->

  <specobject>
      <id>CanTp.EB.MCG.RX.CANTP_ON_CAN_CAN_FD_MandatoryPduLength</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If CanTpRxNSduRef refers to a PDU with configured length different from 8 bytes (for CAN 2.0
        and CAN-FD frames) and 64 bytes(for CAN-FD frames), the generator will issue an error.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_GenTest_01024_MCG_PHYSICAL_Std_CanFd_Invalid_RX_PduLength</srcid><srcstatus/><internalId>1585</internalId></linkedfrom><linkedfrom><srcid>CanTp_GenTest_01025_MCG_PHYSICAL_Ext_CanFd_Invalid_RX_PduLength</srcid><srcstatus/><internalId>1586</internalId></linkedfrom><linkedfrom><srcid>CanTp_GenTest_01026_MCG_FUNCTIONAL_Std_Classic_Invalid_RX_PduLength</srcid><srcstatus/><internalId>1587</internalId></linkedfrom><linkedfrom><srcid>CanTp_GenTest_01027_MCG_FUNCTIONAL_Std_CanFd_Invalid_RX_PduLength</srcid><srcstatus/><internalId>1588</internalId></linkedfrom><linkedfrom><srcid>CanTp_GenTest_01028_MCG_FUNCTIONAL_Ext_Classic_Invalid_RX_PduLength</srcid><srcstatus/><internalId>1589</internalId></linkedfrom><linkedfrom><srcid>CanTp_GenTest_01029_MCG_FUNCTIONAL_Ext_CanFd_Invalid_RX_PduLength</srcid><srcstatus/><internalId>1590</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>733</internalId></specobject>

    <specobject>
      <id>CanTp.EB.NbrWTRepeated_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name CanTpNbrWaitRepeated
        Description:
      For a Rx N-SDU with CanTpNbrWaitRepeatedSupport = true:
      Vendor specific configuration parameter for handling of dedicated N_Br
      timeout values for repeated FC WAIT PDUs.
      Value in seconds of the performance requirement for(N_Br_WT + N_Ar).
      N_Br_WT is the elapsed time until the next Flow Control transmission
      when sending subsequent FC WAIT PDUs.
        Multiplicity 0..1
        Type EcucFloatParamDef
        Range 0 .. INF
        Default value -
        ConfigurationClass
      Pre-compile time X VARIANT-PRE-COMPILE
      Link time -
      Post-build time X VARIANT-POST-BUILD
        Scope / Dependency scope: Module
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        Behavior is covered by CanTp.EB.NbrWaitRepeated_AfterFF.
        Please refer to figure TS_CanTp_N_Br_WT.png.
      </comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>734</internalId></specobject>

    <specobject>
      <id>CanTp.EB.NbrWTRepeatedSupport_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name CanTpNbrWaitRepeatedSupport {CANTP_N_BR_WAIT_SUPPORT}
        Parent Container: CanTpGeneral
        Description Enable support for different configurable timeout values for repeated FC WAIT and other FC PDUs.
        Multiplicity 1
        Type EcucBooleanParamDef
        Default value false
        Value Configuration Class
      Pre-compile time X All Variants
      Link time --
      Post-build time --
        Scope / Dependency scope: local
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        Behavior is covered by CanTp.EB.NbrWaitRepeated_AfterFF.
      </comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>735</internalId></specobject>

    <specobject>
      <id>CanTp.EB.Rx_CANTP_ON_CAN_CAN_FD_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name CanTpRxPaddingActivation {CANTP_PADDING_ACTIVATION}
        Description
      Defines if the receive frame uses padding or not.
        Definition of enumeration values:
      CanTpOff The transmit N-PDU does not use
      padding for SF, CF and the last CF. (N-PDU length is dynamic)
      CanTpOn Enabled mandatory padding to 8 bytes for CAN 2.0 PDUs only
      CanTpOn_Can_Can_Fd Enable mandatory padding to 8 bytes for CAN 2.0 PDUs
      and 64 bytes for CAN FD PDUs
        Multiplicity 1
        Type EcucEnumerationParamDef
        Range CANTP_OFF Padding is not used
        CANTP_ON Enabled mandatory padding to 8 bytes for CAN 2.0 PDUs only
        CANTP_ON_CAN_CAN_FD Enable mandatory padding to 8 bytes for CAN 2.0 PDUs
        and 64 bytes for CAN FD PDUs
        ConfigurationClass
      Pre-compile time X All Variants
      Link time -
      Post-build time -
        Scope / Dependency scope:Module
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        The behavior is covered by CanTp.SWS_CanTp_00351.CANTP_ON_CAN_CAN_FD.CAN_FD.
      </comment>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ECUC_CanTp_00249</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>436</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>736</internalId></specobject>

    <specobject>
      <id>CanTp.EB.Tx_CANTP_ON_CAN_CAN_FD_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name CanTpTxPaddingActivation {CANTP_PADDING_ACTIVATION}
        Description
      Defines if the transmit frame use padding or not.
      Definition of Enumeration  values:
      CanTpOff The transmit N-PDU does not use
      padding for SF, CF and the last CF. (N-PDU length is dynamic)
      CanTpOn Enabled mandatory padding to 8 bytes for CAN 2.0 PDUs only
      CanTpOn_Can_Can_Fd Enable mandatory padding to 8 bytes for CAN 2.0 PDUs
      and 64 bytes for CAN FD PDUs
        Multiplicity 1
        Type EcucEnumerationParamDef
        Range
      CANTP_OFF Padding is not used
      CANTP_ON Enabled mandatory padding to 8 bytes for CAN 2.0 PDUs only
      CANTP_ON_CAN_CAN_FD Enable mandatory padding to 8 bytes for CAN 2.0 PDUs
          and 64 bytes for CAN FD PDUs
        ConfigurationClass
      Pre-compile time X All Variants
      Link time -
      Post-build time -
        Scope / Dependency scope: Module
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        The behavior is covered by CanTp.SWS_CanTp_00351.CANTP_ON_CAN_CAN_FD.CAN_FD.
      </comment>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ECUC_CanTp_00269</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>454</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>737</internalId></specobject>

    <specobject>
      <id>CanTp.EB.NbrWaitRepeated_AfterFF</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        When sending the first FC WAIT PDU (after a FF reception) the value of CanTpNbr shall
        be used. When sending any subsequent FC WAIT PDU, CanTpNbrWaitRepeated shall be used
        (i.e., consecutive FC WAIT PDUs shall be separated by CanTpNbrWaitRepeated) if the
        optional parameter is configured.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest11001_FCWAIT_NBrWTTimeoutEnabled</srcid><srcstatus/><internalId>1166</internalId></linkedfrom><linkedfrom><srcid>CanTp_ConTest11002_FCWAIT_NBrWTTimeoutDisabled</srcid><srcstatus/><internalId>1167</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>738</internalId></specobject>

    <specobject>
      <id>CanTp.EB.Xdm.NbrWTRepeated.NbrWTRepeatedSupport_OFF</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        A Rx N-SDU shall not use CanTpNbrWaitRepeated if CanTpNbrWaitRepeatedSupport is disabled.
      </description>
      <needscoverage>
    <!-- Shall be tested with a generic test -->
    <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_GenTest_01001_Xdm_NBrWT_UsedWhenNotSupported</srcid><srcstatus/><internalId>1561</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>739</internalId></specobject>


    <!-- =================================== Accepted and Not accepted lengths for RxFC based on CanTpTxPaddingActivation ============================================ -->
    
    
    <!-- ============================================== Accepted and Not accepted lengths for CAN 20 RxFC ======================================================= -->
    <specobject>
      <id>CanTp.EB.Padding.CANTP_OFF.Receiving.CAN20_RxFC.AcceptedLengths.STANDARD</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
      If frames with a payload &lt;= 8 (CAN 2.0 frames) are used for a Tx N-SDU and if CanTpTxPaddingActivation is equal to CANTP_OFF,
      CanTp shall accept by means of CanIf_RxIndication() call, CAN 2.0 FC N-PDU that belongs to that Tx N-SDU
      with length greater or equal to the header bytes (N_PCI) for STANDARD addressing format and smaller or equal than 8 bytes.
      (i.e. PduLength = 8 (standard addressing format) =&gt; accepted PduInfoPtr.SduLength values between 3 and 8)
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_ConTest16_001_CAN20_FC_Lengths_NoPadding_NormalPadding_CanFDPadding</srcid><srcstatus/><internalId>1183</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30089</srcid><srcstatus/><internalId>1202</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30093</srcid><srcstatus/><internalId>1210</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30325</srcid><srcstatus/><internalId>1287</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>740</internalId></specobject>
    
    <specobject>
      <id>CanTp.EB.Padding.CANTP_OFF.Receiving.CAN20_RxFC.AcceptedLengths.EXTENDED.MIXED</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
      If frames with a payload &lt;= 8 (CAN 2.0 frames) are used for a Tx N-SDU and if CanTpTxPaddingActivation is equal to CANTP_OFF,
      CanTp shall accept by means of CanIf_RxIndication() call, CAN 2.0 FC N-PDU that belongs to that Tx N-SDU
      with length greater or equal to the header bytes (N_PCI + addressing length) for other than STANDARD addressing formats 
      and smaller or equal than 8 bytes.
      (i.e. PduLength = 8 (extended addressing format) =&gt; accepted PduInfoPtr.SduLength values between 4 and 8)
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_RequestNewTransmissionFromTxConfirmation_MultiFrame</srcid><srcstatus/><internalId>1181</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_ConTest16_001_CAN20_FC_Lengths_NoPadding_NormalPadding_CanFDPadding</srcid><srcstatus/><internalId>1183</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30055</srcid><srcstatus/><internalId>1198</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_SegMixed_PaddingOff</srcid><srcstatus/><internalId>1199</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30057</srcid><srcstatus/><internalId>1201</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_FC_Extended_InvalidLength</srcid><srcstatus/><internalId>1309</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_SegTxMixedAdr</srcid><srcstatus/><internalId>1686</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>741</internalId></specobject>


    <!-- ================================ Accepted and Not accepted lengths for CAN FD RxFC ========================================== -->
    <specobject>
      <id>CanTp.EB.Padding.CANTP_OFF.Receiving.CANFD.RxFC.AcceptedLengths.STANDARD</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
      If frames with a payload &gt; 8 (CAN FD frames) are used for a Tx N-SDU and if CanTpTxPaddingActivation is equal to CANTP_OFF,
      CanTp shall accept by means of CanIf_RxIndication() call, CAN FD FC N-PDU that belongs to that Tx N-SDU
      with length greater or equal to the header bytes (N_PCI) for STANDARD addressing format and smaller or equal than 8 bytes.
      (i.e. PduLength = 8 (standard addressing format) =&gt; accepted PduInfoPtr.SduLength values between 3 and 8)
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_ConTest16_002_CANFD_FC_Lengths_NoPadding_NormalPadding_CanFDPadding</srcid><srcstatus/><internalId>1184</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>742</internalId></specobject>

    <specobject>
      <id>CanTp.EB.Padding.CANTP_OFF.Receiving.CANFD.RxFC.AcceptedLengths.EXTENDED.MIXED</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
      If frames with a payload &gt; 8 (CAN FD frames) are used for a Tx N-SDU and if CanTpTxPaddingActivation is equal to CANTP_OFF,
      CanTp shall accept by means of CanIf_RxIndication() call, CAN FD FC N-PDU that belongs to that Tx N-SDU
      with length greater or equal to the header bytes (N_PCI + addressing length) for EXTENDED addressing format
      and smaller or equal than 8 bytes.
      (i.e. PduLength = 8 (standard addressing format) =&gt; accepted PduInfoPtr.SduLength values between 4 and 8)
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_ConTest16_002_CANFD_FC_Lengths_NoPadding_NormalPadding_CanFDPadding</srcid><srcstatus/><internalId>1184</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>743</internalId></specobject>

    <specobject>
      <id>CanTp.EB.Receiving.RxFC.UnexpectedLengths</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
      If a FC N-PDU is rejected because of unexpected length
      CanTp module shall abort the transmission session
      by calling PduR_TxConfirmation() with the result E_NOT_OK.
      If the default error detection is enabled, a development error
      CANTP_E_INVALID_RX_LENGTH shall be triggered.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest12_004_Tx_FF_RxFC_lastCF_CAN20_CANFD_CANTP_ON_CAN_CAN_FD</srcid><srcstatus/><internalId>1171</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_ConTest16_001_CAN20_FC_Lengths_NoPadding_NormalPadding_CanFDPadding</srcid><srcstatus/><internalId>1183</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_ConTest16_002_CANFD_FC_Lengths_NoPadding_NormalPadding_CanFDPadding</srcid><srcstatus/><internalId>1184</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_FC_Mixed_InvalidLength</srcid><srcstatus/><internalId>1437</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30482</srcid><srcstatus/><internalId>1680</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>744</internalId></specobject>
    
    

    <!-- == End Section: XDM/MCG Checks ============================================================ -->

  <!-- == Variant Handling ========================================================================= -->

  <specobject>
      <id>CanTp.EB.PBSelectable.FileName</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If postBuildVariant returns a non-empty string, the module's post-build-time
        configuration file names shall be changed in the following way:
    &lt;CanTp&gt;[_*]_PBcfg.* to &lt;CanTp&gt;_&lt;postBuildVariant&gt;[_*]_PBcfg.*
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_31001</srcid><srcstatus/><internalId>1438</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>745</internalId></specobject>

    <specobject>
      <id>CanTp.EB.PBSelectable.TypeName</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If postBuildVariant returns a non-empty string, the module's post-build-time
        configuration type/variable names shall be changed in the following way:
    - CanTp_[Const]ConfigLayoutType to CanTp_&lt;postBuildVariant&gt;_[Const]ConfigLayoutType
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_31001</srcid><srcstatus/><internalId>1438</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>746</internalId></specobject>

    <specobject>
      <id>CanTp.EB.PBSelectable.Master</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If postBuildVariant returns a non-empty string, the module shall generate a post-build-time
        configuration file CanTp_PBcfg.h/c which includes all the variants specific post-build-time
        configurations (CanTp_&lt;postBuildVariant&gt;[_*]_PBcfg.h/c).
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_31001</srcid><srcstatus/><internalId>1438</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>747</internalId></specobject>
    
    <specobject>
    <id>CanTp.EB.CanTp_ChangeTxParameter</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        CanTp_ChangeTxParameter
        Service name: CanTp_ChangeTxParameter
        Syntax: Std_ReturnType CanTp_ChangeTxParameter
        (
        PduIdType id,
        TPParameterType parameter,
        uint16 value
    )
        Sync/Async: Synchronous
        Service ID[hex]: 0x0c
        Reentrancy: Non Reentrant
        Parameters (in):
        id Identifier of the received N-SDU for Stmin.
        parameter Specify the parameter to which the value has to be changed only STmin is supported.
        value The new value of the parameter.
        Parameters (inout): None
        Parameters (out): None
        Return value: Std_ReturnType
        E_OK: request is accepted.
        E_NOT_OK: request is not accepted.
        Description: This service is used to  change STmin parameter for a specified N-SDU.
      </description>
    <needscoverage>
    <!-- Syntax shall be tested with a compile test only. -->
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_ChangeTx_ResetTx_NoInit</srcid><srcstatus/><internalId>1591</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_40111_ChangeTxParameter</srcid><srcstatus/><internalId>1699</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>748</internalId></specobject>

    <specobject>
    <id>CanTp.EB.CanTp_ChangeTxParameter.STmin</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        CanTp_ChangeTxParameter() shall only support the change of transmit parameter STmin.
      </description>
    <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_Change_Tx_Param_Api</srcid><srcstatus/><internalId>1114</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_ChangeTx_STmin_ResetTx_InvalidParam</srcid><srcstatus/><internalId>1592</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_ChangeTx_STmin_NoTxPending</srcid><srcstatus/><internalId>1593</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>749</internalId></specobject>

    <specobject>
    <id>CanTp.EB.CanTp_ChangeTxParameter.Modify</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        The STmin set via a call to CanTp_ChangeTxParameter() for the TX N-SDUs shall be fix to this
        value and no longer modifiable by the content of any FC-CTS frame until a subsequent call to
        CanTp_ResetTxParameter() is done.
      </description>
    <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_Allow_ChangeTx_STmin_OngoingTx</srcid><srcstatus/><internalId>1594</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>750</internalId></specobject>

    <specobject>
    <id>CanTp.EB.CanTp_ChangeTxParameter.ErrorDetection_1</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        If development error detection is enabled, the function CanTp_ChangeTxParameter shall check the validity
        of function parameters (Identifier, Parameter and transmitted value). If any parameter is invalid, CANTP_E_PARAM_ID 
        error is reported via DET and CanTp_ChangeTxParameter returns E_NOT_OK.
      </description>
    <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_ChangeTx_STmin_NoTxPending</srcid><srcstatus/><internalId>1593</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>751</internalId></specobject>
    
    <specobject>
    <id>CanTp.EB.CanTp_ChangeRxParameter</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        CanTp_ChangeRxParameter
        Service name: CanTp_ChangeRxParameter
        Syntax: Std_ReturnType CanTp_ChangeRxParameter
        (
        PduIdType id,
        TPParameterType parameter,
        uint16 value
    )
        Sync/Async: Synchronous
        Service ID[hex]: 0x0a
        Reentrancy: Non Reentrant
        Parameters (in):
        id Identifier of the received N-SDU on which the reception parameter has to be
        changed.
        parameter Specify the parameter to which the value has to be changed (BS or STmin).
        value The new value of the parameter.
        Parameters (inout): None
        Parameters (out): None
        Return value: Std_ReturnType
        E_OK: request is accepted.
        E_NOT_OK: request is not accepted.
        Description: This service is used to request the change of reception parameters BS
        and STmin for a specified N-SDU.
      </description>
    <needscoverage>
    <!-- Syntax shall be tested with a compile test only. -->
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_Conf07005_ChangeRx_Read_STmin</srcid><srcstatus/><internalId>1432</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_Conf07006_ChangeRx_Read_BS</srcid><srcstatus/><internalId>1433</internalId></linkedfrom></coveredby></needscov>  
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>752</internalId></specobject>

    <specobject>
    <id>CanTp.EB.CanTp_ChangeRxParameter.BSandSTmin</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        CanTp_ChangeRxParameter shall delegate the handling to CanTp_ChangeParameter 
        to support the change of reception parameters BS and STmin.
      </description>
    <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_40111_ChangeParameter</srcid><srcstatus/><internalId>1697</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>753</internalId></specobject>
      
    <specobject>
    <id>CanTp.EB.CanTp_ResetTxParameter</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        CanTp_ResetTxParameter
        Service name: CanTp_ResetTxParameter
        Syntax: void CanTp_ResetTxParameter
        (
        PduIdType Id
    )
        Sync/Async: Synchronous
        Service ID[hex]: 0x0d
        Reentrancy: Non Reentrant
        Parameters (in):
        id Identifier of the received N-SDU on which  parameter has to be reset.
        parameter Specify the parameter to which value has to be reset (only STmin).
        Parameters (inout): None
        Parameters (out): None
        Return value: None
        Description: This service shall re-enable the modification of the parameter for the
        given TX N-SDU by the content of any FC-CTS frame.
      </description>
    <needscoverage>
    <!-- Syntax shall be tested with a compile test only. -->
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_ChangeTx_ResetTx_NoInit</srcid><srcstatus/><internalId>1591</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_40111_ResetTxParameter</srcid><srcstatus/><internalId>1700</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>754</internalId></specobject>

    <specobject>
    <id>CanTp.EB.CanTp_ResetTxParameter.Stmin</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        A call to CanTp_ResetTxParameter() shall re-enable the modification of the parameter 
        for the given TX N-SDU by the content of any FC-CTS frame.
      </description>
    <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_Allow_ResetTx_STmin_OngoingTx</srcid><srcstatus/><internalId>1595</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>755</internalId></specobject>

    <specobject>
    <id>CanTp.EB.CanTp_ResetTxParameter.ErrorDetection</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        If development error detection is enabled, the function CanTp_ResetTxParameter shall check the validity
        of function parameters (Identifier). If any of the parameter value is
        invalid, the CanTp_ResetTxParameter function shall raise the development
        error CANTP_E_PARAM_ID and return E_NOT_OK.
      </description>
    <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_ChangeTx_ResetTx_NoInit</srcid><srcstatus/><internalId>1591</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_ChangeTx_STmin_ResetTx_InvalidParam</srcid><srcstatus/><internalId>1592</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>756</internalId></specobject>
    
    <specobject>
    <id>CanTp.EB.CanTp_RxIndication.SFPostPoneRxIndication</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        If CanTpChannelMode is set to CANTP_MODE_HALF_DUFLEX and TxConfirmation for the last frame of the 
        message is pending and a single frame receive request on the same channel is performed 
        the Single Frame reception shall be postponed when the channel is locked, at CanTp_RxIndication.
      </description>
    <comment>This will be checked with successful compilation of test after generating from PduR.xdm file that allow two different sources which are routing to the same destination.
      </comment>
    <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_SF_RECEPTION_POSTONED</srcid><srcstatus/><internalId>1369</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>757</internalId></specobject>
    
    <specobject>
    <id>CanTp.EB.CanTp_RxIndication.FFPostPoneRxIndication</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      If a First Frame is received when the processing of a last Consecutive Frame is ongoing, this First Frame should be postponed.
      </description>
    <comment>
      </comment>
    <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_40042</srcid><srcstatus/><internalId>1601</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_40043</srcid><srcstatus/><internalId>1602</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>758</internalId></specobject>
    
    <specobject>
    <id>CanTp.EB.CanTp_ReadParameter.CheckAgainstValueNULL_PTR</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        If default error detection is enabled the function CanTp_ReadParameter shall check the validity of 
        function parameter (value). If the parameter value is invalid, the CanTp_ReadParameter 
        function shall raise the development error CANTP_E_PARAM_POINTER and return E_NOT_OK.
      </description>
    <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_Check_Against_NULL_PTR</srcid><srcstatus/><internalId>1389</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00324</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>389</internalId></provcov>
    </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>759</internalId></specobject>
    
    <specobject>
    <id>CanTp.EB.CheckPduRNto1RoutingInteference</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        CanTp shall allows Nto1 routing  configuration supported by PduR.
      </description>
    <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_RELOCATABLEPBCFG_2</srcid><srcstatus/><internalId>1103</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>760</internalId></specobject>
    
    <specobject>
    <id>CanTp.EB.SameTxNpduFCandData_CONFIG</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        If CanTpTxNPduRef and CanTpTxFcNPduRef are using the same CanIf PDU reference, 
        then CanTpTxFcNPduConfirmationPduId and CanTpTxNPduConfirmationPduId IDs have to be the same.
      </description>
    <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_Timeout_FC_Transmission_Nothing_Pending</srcid><srcstatus/><internalId>1500</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_Timeout_SF_Transmission_Nothing_Pending</srcid><srcstatus/><internalId>1501</internalId></linkedfrom><linkedfrom><srcid>CanTp_GenTest_01012_Err_TxNPduRef_TxFcNpduRef</srcid><srcstatus/><internalId>1537</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>761</internalId></specobject>
    
    <specobject>
    <id>CanTp.EB.SameTxNpduFCandData_transmit_SF</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        If a SF was sent (via CanIf_Transmit()) on a Tx Npdu referencing the same CanIf Npdu as a Tx FcNpdu, 
        the CanIf shall postpone the transmission of the FC (of an ongoing segmented reception) until the SF transmission is confirmed.
      </description>
    <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_SF_Transmission_Pending_FC</srcid><srcstatus/><internalId>1477</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_SF_Transmission_Timeout_Pending_FC</srcid><srcstatus/><internalId>1478</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_SF_Transmission_Pending_FC_Wait</srcid><srcstatus/><internalId>1489</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_SF_Transmission_Pending_FC_Overflow</srcid><srcstatus/><internalId>1490</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>762</internalId></specobject>
    
    <specobject>
    <id>CanTp.EB.SameTxNpduFCandData_transmit_FF</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        If a FF was sent (via CanIf_Transmit()) on a Tx Npdu referencing the same CanIf Npdu as a Tx FcNpdu, 
        the CanIf shall postpone the transmission of the FC (of an ongoing segmented reception) until the FF transmission is confirmed.
      </description>
    <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_FF_Transmission_Pending_FC</srcid><srcstatus/><internalId>1479</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_FF_Transmission_Timeout_Pending_FC</srcid><srcstatus/><internalId>1480</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_FF_Transmission_Pending_FC_WAIT</srcid><srcstatus/><internalId>1493</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_FF_Transmission_Pending_FC_OVERFLOW</srcid><srcstatus/><internalId>1494</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_CF_Reception_Pending_FC_Transmission</srcid><srcstatus/><internalId>1497</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_FF_Reception_FF_Transmission</srcid><srcstatus/><internalId>1502</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_FF_Transmission_RxCancellation</srcid><srcstatus/><internalId>1504</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>763</internalId></specobject>
    
    <specobject>
    <id>CanTp.EB.SameTxNpduFCandData_transmit_CF</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        If a CF was sent on a Tx Npdu referencing the same CanIf Npdu as a Tx FcNpdu, the CanIf shall postpone the 
        transmission of the FC (of an ongoing segmented reception) until the CF transmission is confirmed.
      </description>
    <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_CF_Transmission_Pending_FC</srcid><srcstatus/><internalId>1481</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_CF_Transmission_Timeout_Pending_FC</srcid><srcstatus/><internalId>1482</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_CF_Transmission_Pending_FC_WAIT</srcid><srcstatus/><internalId>1495</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_CF_Transmission_Pending_FC_OVERFLOW</srcid><srcstatus/><internalId>1496</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>764</internalId></specobject>
    
    <specobject>
    <id>CanTp.EB.SameTxNpduFCandData_transmit_FC_SF</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        In case of an ongoing FC transmission (multiframe reception), if a SF transmission was triggered (via CanTp_Transmit()) 
        using the same PDU ref (see req CanTp.EB.SameTxNpduFCandData_CONFIG), the SF should be postponed until the FC transmission is confirmed.
      </description>
    <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_FC_Transmission_Pending_SF</srcid><srcstatus/><internalId>1483</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_FC_Transmission_Timeout_Pending_SF</srcid><srcstatus/><internalId>1486</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_FC_Wait_Transmission_Pending_SF</srcid><srcstatus/><internalId>1491</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_FC_Overflow_Transmission_Pending_SF</srcid><srcstatus/><internalId>1492</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_CF_Reception_FF_Transmission</srcid><srcstatus/><internalId>1503</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>765</internalId></specobject>
    
    <specobject>
    <id>CanTp.EB.SameTxNpduFCandData_transmit_FC_FF</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        In case of an ongoing FC transmission (multiframe reception), if a FF transmission was triggered (via CanTp_Transmit()) 
        using the same PDU ref (see req CanTp.EB.SameTxNpduFCandData_CONFIG), the FF should be postponed until the FC transmission is confirmed.
      </description>
    <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_FC_Transmission_Pending_FF</srcid><srcstatus/><internalId>1484</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_FC_Transmission_Timeout_Pending_FF</srcid><srcstatus/><internalId>1487</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_FC_Transmission_TxCancellation</srcid><srcstatus/><internalId>1505</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>766</internalId></specobject>
    
    <specobject>
    <id>CanTp.EB.SameTxNpduFCandData_transmit_FC_CF</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        In case of an ongoing FC transmission (multiframe reception), if a CF transmission was triggered using the same PDU ref 
        (see req CanTp.EB.SameTxNpduFCandData_CONFIG), the CF should be postponed until the FC transmission is confirmed.
      </description>
    <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_FC_Transmission_Pending_CF</srcid><srcstatus/><internalId>1485</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_FC_Transmission_Timeout_Pending_CF</srcid><srcstatus/><internalId>1488</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>767</internalId></specobject>
    
    <specobject>
    <id>CanTp.EB.SameTxNpduUseNCSforDataRetry</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        In case of an ongoing FC transmission (multiframe reception), if the time period(N_Cs) of the postponed SF/FF is smaller 
        than the remaining time period to transmit the FC, the CanTp will use remaining time of the (N_Ar+N_Br) to send the SF/FF.
      </description>
    <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_FC_Transmission_Pending_SF_Smaller_NCS</srcid><srcstatus/><internalId>1499</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>768</internalId></specobject>
    
    <specobject>
    <id>CanTp.EB.SameTxNpduFCTransmissionRetry</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        In case of an ongoing FC transmission (multiframe reception), if a FC WAIT is postponed due to an ongoing 
        data transmission, CanTp shall retry to send FC until N_Ar expires.
      </description>
    <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_FF_Transmission_Pending_FC_WAIT</srcid><srcstatus/><internalId>1493</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_CF_Transmission_Pending_FC_WAIT</srcid><srcstatus/><internalId>1495</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>769</internalId></specobject>
    
    <specobject>
    <id>CanTp.EB.SameTxNpduFCTimeout</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        In case of N_Ar timeout occurrence (no FC frame sent due to ongoing SF/FF/CF transmission on the same N-Pdu) the CanTp module shall
        abort reception and notify the upper layer of this failure by calling the indication function PduR_CanTpRxIndication() 
        with the result E_NOT_OK.
      </description>
    <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_SF_Transmission_Pending_FC_Wait_Timeout</srcid><srcstatus/><internalId>1498</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>770</internalId></specobject>
    
    <specobject>
    <id>CanTp.EB.StateHandlingSupport_Conf</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      Name CanTpStallHandlingSupport {CANTP_STALLHANDLING_SUPPORT}
      Parent Container: CanTpGeneral
      Description Enable support of stallhandling feature for received messages.
      Multiplicity 1
      Type EcucBooleanParamDef
      Default value true
      Value Configuration Class
      Pre-compile time X All Variants
      Link time --
      Post-build time --
      Scope / Dependency scope: local
      </description>
    <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_BurstOfCF_Reception</srcid><srcstatus/><internalId>1646</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>771</internalId></specobject>


    <!-- == End Section: Variant Handling ============================================================ -->

    <!-- == MetaData Handling ========================================================================= -->

    <specobject>
    <id>CanTp.EB.RxAddressingFormat_Conf</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        Name CanTpRxAddressingFormat
        Parent Container CanTpRxNSdu
        Description
      Declares which communication addressing mode is supported for this Rx N-SDU.
        Definition of Enumeration values:
      CanTpStandard to use normal addressing format.
      CanTpExtended to use extended addressing format.
      CanTpMixed to use mixed 11 bit addressing format.
      CanTpNormalFixed to use normal fixed addressing format.
        Multiplicity 1
        Type EcucEnumerationParamDef
        Range
      CANTP_EXTENDED Extended addressing format
      CANTP_MIXED Mixed 11 bit addressing format
      CANTP_NORMALFIXED Normal fixed addressing format
      CANTP_STANDARD Standard addressing format
        Post-Build Variant Value false
        Value Configuration Class
      Pre-compile time X All Variants
      Link time -
      Post-build time -
        Scope / Dependency
      scope: local
      </description>
    <comment>
        This is a configuration parameter requirement without functional specification.
        Behavior is covered by CanTp.ASR40.SWS_CanTp_00281.
      </comment>
    <providescoverage>
      <provcov>
      <linksto>CanTp.ECUC_CanTp_00281</linksto>
      <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>434</internalId></provcov>
    </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>772</internalId></specobject>

    <specobject>
    <id>CanTp.EB.TxAddressingFormat_Conf</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        Name CanTpTxAddressingFormat
        Parent Container CanTpTxNSdu
        Description
      Declares which communication addressing mode is supported for this TxNSDU.
        Definition of Enumeration values:
      CanTpStandard to use normal addressing format.
      CanTpExtended to use extended addressing format(the N_TA
            container of this TxNsdu will be used).
      CanTpMixed to use mixed 11 bit addressing format
            (the N_AE container of this TxNsdu will be used).
      CanTpNormalFixed to use normal fixed addressing format.
        Multiplicity 1
        Type EcucEnumerationParamDef
        Range
      CANTP_EXTENDED Extended addressing format
      CANTP_MIXED Mixed 11 bit addressing format
      CANTP_NORMALFIXED Normal fixed addressing format
      CANTP_STANDARD Standard addressing format
        Post-Build Variant Value false
        Value Configuration Class
      Pre-compile time X All Variants
      Link time -
      Post-build time -
        Scope / Dependency
      scope: local
      </description>
    <comment>
        This is a configuration parameter requirement without functional specification.
        Behavior is covered by CanTp.ASR40.SWS_CanTp_00281.
      </comment>
    <providescoverage>
      <provcov>
      <linksto>CanTp.ECUC_CanTp_00262</linksto>
      <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>452</internalId></provcov>
    </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>773</internalId></specobject>

    <specobject>
    <id>CanTp.EB.MetaData.GetRxNTaFromCanId</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        When CanTp_RxIndication() is called for a SF or FF N-SDU with Normal fixed addressing format
        (CanTpDynIdSupport is enabled), the CanTp module shall get the N_Ta value from the CanId of
        the PDU via the EcuC_GetMetaDataCanId() API call and compare it with the corresponding configured
        value.
        If these values do not match, CanTp shall ignore the frame reception.
      </description>
    <comment>
        29 bit CAN ID bit position (Normal fixed addressing mode):
    - physical addressing:
      28-26|25|24|23-16|15-8|7-0 |
        110 |0 |0 | 218 |N_TA|N_SA|
      - functional addressing:
      28-26|25|24|23-16|15-8|7-0 |
        110 |0 |0 | 219 |N_TA|N_SA|
      </comment>
    <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanTp_RxIndication.c_2319</srcid><srcstatus/><internalId>1036</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/CanTp_RxIndication.c_2354</srcid><srcstatus/><internalId>1037</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ReceiveSF</srcid><srcstatus/><internalId>1461</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ReceiveMultiframe</srcid><srcstatus/><internalId>1462</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ReceiveMultiframeOngoing_HalfDuplex</srcid><srcstatus/><internalId>1463</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ReceiveMultiframeOngoing_FullDuplex</srcid><srcstatus/><internalId>1464</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_IgnoreCF_DifferentTA</srcid><srcstatus/><internalId>1467</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_IgnoreCF_DifferentSA</srcid><srcstatus/><internalId>1468</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ReceiveSF_FunctionalTaType</srcid><srcstatus/><internalId>1471</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ChangeParameter</srcid><srcstatus/><internalId>1472</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ReceiveSF_DifferentSA</srcid><srcstatus/><internalId>1473</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
      <linksto>CanTp.SWS_CanTp_00330</linksto>
      <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>156</internalId></provcov>
    </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>774</internalId></specobject>

    <specobject>
    <id>CanTp.EB.MetaData.GetRxNSaGenConnectionOn</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        When CanTpGenericConnectionSupport is enabled and CanTp_RxIndication() is called for a
        SF or FF N-SDU with Normal fixed addressing format, the CanTp module shall get the N_Sa
        value obtained from the CanId of the PDU via the EcuC_GetMetaDataCanId() API call.
      </description>
    <comment>
        29 bit CAN ID bit position (Normal fixed addressing mode):
    - physical addressing:
      28-26|25|24|23-16|15-8|7-0 |
        110 |0 |0 | 218 |N_TA|N_SA|
      - functional addressing:
      28-26|25|24|23-16|15-8|7-0 |
        110 |0 |0 | 219 |N_TA|N_SA|
      </comment>
    <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanTp_RxIndication.c_2369</srcid><srcstatus/><internalId>1039</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ReceiveSF</srcid><srcstatus/><internalId>1461</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ReceiveMultiframe</srcid><srcstatus/><internalId>1462</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ReceiveMultiframeOngoing_HalfDuplex</srcid><srcstatus/><internalId>1463</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ReceiveMultiframeOngoing_FullDuplex</srcid><srcstatus/><internalId>1464</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_IgnoreCF_DifferentTA</srcid><srcstatus/><internalId>1467</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_IgnoreCF_DifferentSA</srcid><srcstatus/><internalId>1468</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ChangeParameter</srcid><srcstatus/><internalId>1472</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
      <linksto>CanTp.SWS_CanTp_00330</linksto>
      <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>156</internalId></provcov>
    </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>775</internalId></specobject>

    <specobject>
    <id>CanTp.EB.MetaData.GetRxNSaGenConnectionOff</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        When CanTpGenericConnectionSupport is disabled and CanTp_RxIndication() is called for a SF
        or FF N-SDU with Normal fixed addressing format (CanTpDynIdSupport is enabled), the CanTp
        module shall get the N_Sa value from the configuration and compare it with the value provided
        from the CanId.
        If these values do not match, CanTp shall ignore the frame reception.
      </description>
    <comment>
        29 bit CAN ID bit position (Normal fixed addressing mode):
    - physical addressing:
      28-26|25|24|23-16|15-8|7-0 |
        110 |0 |0 | 218 |N_TA|N_SA|
      - functional addressing:
      28-26|25|24|23-16|15-8|7-0 |
        110 |0 |0 | 219 |N_TA|N_SA|
      </comment>
    <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanTp_RxIndication.c_2364</srcid><srcstatus/><internalId>1038</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ReceiveSF</srcid><srcstatus/><internalId>1461</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ReceiveMultiframe</srcid><srcstatus/><internalId>1462</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ReceiveMultiframeOngoing_HalfDuplex</srcid><srcstatus/><internalId>1463</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ReceiveMultiframeOngoing_FullDuplex</srcid><srcstatus/><internalId>1464</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_IgnoreCF_DifferentTA</srcid><srcstatus/><internalId>1467</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_IgnoreCF_DifferentSA</srcid><srcstatus/><internalId>1468</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ChangeParameter</srcid><srcstatus/><internalId>1472</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ReceiveSF_DifferentSA</srcid><srcstatus/><internalId>1473</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>776</internalId></specobject>

    <specobject>
    <id>CanTp.EB.MetaData.SetRxNTa</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        When CanTp_RxIndication() is called for a SF or FF N-SDU with Normal fixed addressing format,
        the CanTp module shall set the N_Ta value via the EcuC_SetMetaDataTargetAddr() API call
        (see CanTp.EB.MetaData.GetRxNTaFromCanId).
      </description>
    <comment>
        29 bit CAN ID bit position (Normal fixed addressing mode):
    - physical addressing:
      28-26|25|24|23-16|15-8|7-0 |
        110 |0 |0 | 218 |N_TA|N_SA|
      - functional addressing:
      28-26|25|24|23-16|15-8|7-0 |
        110 |0 |0 | 219 |N_TA|N_SA|
      </comment>
    <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanTp_RxIndication.c_2379</srcid><srcstatus/><internalId>1041</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ReceiveSF</srcid><srcstatus/><internalId>1461</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ReceiveMultiframe</srcid><srcstatus/><internalId>1462</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ReceiveMultiframeOngoing_HalfDuplex</srcid><srcstatus/><internalId>1463</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ReceiveMultiframeOngoing_FullDuplex</srcid><srcstatus/><internalId>1464</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_IgnoreCF_DifferentTA</srcid><srcstatus/><internalId>1467</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_IgnoreCF_DifferentSA</srcid><srcstatus/><internalId>1468</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ReceiveSF_FunctionalTaType</srcid><srcstatus/><internalId>1471</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ChangeParameter</srcid><srcstatus/><internalId>1472</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>777</internalId></specobject>

    <specobject>
    <id>CanTp.EB.MetaData.SetRxNSa</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        When CanTp_RxIndication() is called for a SF or FF N-SDU with Normal fixed addressing format,
        the CanTp module shall set the N_Sa value via the EcuC_SetMetaDataSourceAddr() API call (see
        CanTp.EB.MetaData.GetRxNSaGenConnectionOn and CanTp.EB.MetaData.GetRxNSaGenConnectionOff).
      </description>
    <comment>
        29 bit CAN ID bit position (Normal fixed addressing mode):
    - physical addressing:
      28-26|25|24|23-16|15-8|7-0 |
        110 |0 |0 | 218 |N_TA|N_SA|
      - functional addressing:
      28-26|25|24|23-16|15-8|7-0 |
        110 |0 |0 | 219 |N_TA|N_SA|
      </comment>
    <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanTp_RxIndication.c_2377</srcid><srcstatus/><internalId>1040</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ReceiveSF</srcid><srcstatus/><internalId>1461</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ReceiveMultiframe</srcid><srcstatus/><internalId>1462</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ReceiveMultiframeOngoing_HalfDuplex</srcid><srcstatus/><internalId>1463</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ReceiveMultiframeOngoing_FullDuplex</srcid><srcstatus/><internalId>1464</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_IgnoreCF_DifferentTA</srcid><srcstatus/><internalId>1467</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_IgnoreCF_DifferentSA</srcid><srcstatus/><internalId>1468</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ReceiveSF_FunctionalTaType</srcid><srcstatus/><internalId>1471</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ChangeParameter</srcid><srcstatus/><internalId>1472</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>778</internalId></specobject>

    <specobject>
    <id>CanTp.EB.MetaData.CheckRxNTa</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        When CanTp_RxIndication() is called for a CF N-SDU with Normal fixed addressing format,
        the CanTp module shall compare the N_Ta value obtained via EcuC_GetMetaDataTargetAddr()
        API call against the value set via EcuC_GetMetaDataCanId() API call.
        If these values do not match, CanTp shall ignore the CF.
      </description>
    <comment>
        29 bit CAN ID bit position (Normal fixed addressing mode):
    - physical addressing:
      28-26|25|24|23-16|15-8|7-0 |
        110 |0 |0 | 218 |N_TA|N_SA|
      - functional addressing:
      28-26|25|24|23-16|15-8|7-0 |
        110 |0 |0 | 219 |N_TA|N_SA|
      </comment>
    <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanTp_RxIndication.c_2400</srcid><srcstatus/><internalId>1042</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ReceiveMultiframe</srcid><srcstatus/><internalId>1462</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ReceiveMultiframeOngoing_HalfDuplex</srcid><srcstatus/><internalId>1463</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ReceiveMultiframeOngoing_FullDuplex</srcid><srcstatus/><internalId>1464</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_IgnoreCF_DifferentTA</srcid><srcstatus/><internalId>1467</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ChangeParameter</srcid><srcstatus/><internalId>1472</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
      <linksto>CanTp.SWS_CanTp_00333</linksto>
      <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>160</internalId></provcov>
      <provcov>
      <linksto>CanTp.SWS_CanTp_00330_1</linksto>
      <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>157</internalId></provcov>
    </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>779</internalId></specobject>

    <specobject>
    <id>CanTp.EB.MetaData.CheckRxNSa</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        When CanTpGenericConnectionSupport is enabled and CanTp_RxIndication() is called for a CF
        N-SDU with Normal fixed addressing format, the CanTp module shall compare the N_Sa value
        obtained via EcuC_GetMetaDataSourceAddr() API call against the value set in the CanId via
        EcuC_GetMetaDataCanId() API call.
        If these values do not match, CanTp shall ignore the CF.
      </description>
    <comment>
        29 bit CAN ID bit position (Normal fixed addressing mode):
    - physical addressing:
      28-26|25|24|23-16|15-8|7-0 |
        110 |0 |0 | 218 |N_TA|N_SA|
      - functional addressing:
      28-26|25|24|23-16|15-8|7-0 |
        110 |0 |0 | 219 |N_TA|N_SA|
      </comment>
    <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanTp_RxIndication.c_2402</srcid><srcstatus/><internalId>1044</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ReceiveMultiframe</srcid><srcstatus/><internalId>1462</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ReceiveMultiframeOngoing_HalfDuplex</srcid><srcstatus/><internalId>1463</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ReceiveMultiframeOngoing_FullDuplex</srcid><srcstatus/><internalId>1464</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_IgnoreCF_DifferentSA</srcid><srcstatus/><internalId>1468</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ChangeParameter</srcid><srcstatus/><internalId>1472</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
      <linksto>CanTp.SWS_CanTp_00333</linksto>
      <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>160</internalId></provcov>
      <provcov>
      <linksto>CanTp.SWS_CanTp_00330_1</linksto>
      <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>157</internalId></provcov>
    </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>780</internalId></specobject>

    <specobject>
    <id>CanTp.EB.MetaData.GetNSaTxFc</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        Before calling CanIf_Transmit() for a FC N-SDU with Normal fixed addressing format, the
        CanTp module shall provide the stored N_Sa (at FF reception) for the CanId via EcuC_GetMetaDataTargetAddr()
        API call.
      </description>
    <comment>
        Normal fixed addressing format: N_TA (saved N_SA).
      </comment>
    <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanTp_TransmitFrame.c_257</srcid><srcstatus/><internalId>1055</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ReceiveMultiframe</srcid><srcstatus/><internalId>1462</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ReceiveMultiframeOngoing_HalfDuplex</srcid><srcstatus/><internalId>1463</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ReceiveMultiframeOngoing_FullDuplex</srcid><srcstatus/><internalId>1464</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_IgnoreCF_DifferentTA</srcid><srcstatus/><internalId>1467</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_IgnoreCF_DifferentSA</srcid><srcstatus/><internalId>1468</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ChangeParameter</srcid><srcstatus/><internalId>1472</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>781</internalId></specobject>

    <specobject>
    <id>CanTp.EB.MetaData.GetNTaTxFc</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        Before calling CanIf_Transmit() for a FC N-SDU with Normal fixed addressing format, the
        CanTp module shall provide the stored N_Ta (at FF reception) for the CanId via the
        EcuC_GetMetaDataSourceAddr() API call.
      </description>
    <comment>
        Normal fixed addressing format: N_SA (saved N_TA).
      </comment>
    <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanTp_TransmitFrame.c_252</srcid><srcstatus/><internalId>1053</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ReceiveMultiframe</srcid><srcstatus/><internalId>1462</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ReceiveMultiframeOngoing_HalfDuplex</srcid><srcstatus/><internalId>1463</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ReceiveMultiframeOngoing_FullDuplex</srcid><srcstatus/><internalId>1464</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_IgnoreCF_DifferentTA</srcid><srcstatus/><internalId>1467</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_IgnoreCF_DifferentSA</srcid><srcstatus/><internalId>1468</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ChangeParameter</srcid><srcstatus/><internalId>1472</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>782</internalId></specobject>

    <specobject>
    <id>CanTp.EB.MetaData.SetTxFcMetaDataCanId</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        Before calling CanIf_Transmit() for a FC N-SDU with Normal fixed addressing, the CanTp module shall
        set the stored addressing information (see CanTp.EB.MetaData.GetNSaTxFc and CanTp.EB.MetaData.GetNTaTxFc)
        and the rest of the Can ID (as defined by ISO) via the EcuC_SetMetaDataCanId() API call.
      </description>
    <comment>
        29 bit CAN ID bit position (Normal fixed addressing mode):
    - physical addressing:
      28-26|25|24|23-16|15-8             |7-0              |
        110 |0 |0 | 218 |N_SA (saved N_TA)|N_TA (saved N_SA)|
      </comment>
    <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanTp_TransmitFrame.c_298</srcid><srcstatus/><internalId>1058</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ReceiveMultiframe</srcid><srcstatus/><internalId>1462</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ReceiveMultiframeOngoing_HalfDuplex</srcid><srcstatus/><internalId>1463</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ReceiveMultiframeOngoing_FullDuplex</srcid><srcstatus/><internalId>1464</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_IgnoreCF_DifferentTA</srcid><srcstatus/><internalId>1467</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_IgnoreCF_DifferentSA</srcid><srcstatus/><internalId>1468</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_ChangeParameter</srcid><srcstatus/><internalId>1472</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>783</internalId></specobject>

    <specobject>
    <id>CanTp.EB.MetaData.GetTxNSa</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        When a transmission of a N-SDU is requested, before calling CanIf_Transmit() for a SF, FF or CF for
        a N-SDU with Normal fixed addressing format, the CanTp module shall call EcuC_GetMetaDataSourceAddr()
        API to obtain the N_Sa (see ISO 15765-2:2016) and compare it with the corresponding configured value.
        If these values do not match, CanTp shall abort the transmission.
      </description>
    <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanTp_TransmitFrame.c_253</srcid><srcstatus/><internalId>1054</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_MetaDataSupport_TransmitSF</srcid><srcstatus/><internalId>1465</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_TransmitMultiframe</srcid><srcstatus/><internalId>1466</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_IgnoreFC_DifferentSA</srcid><srcstatus/><internalId>1469</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_IgnoreFC_DifferentTA</srcid><srcstatus/><internalId>1470</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_TransmitSF_DifferentTA</srcid><srcstatus/><internalId>1474</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
    <provcov>
      <linksto>CanTp.SWS_CanTp_00335</linksto>
      <dstversion>1</dstversion>
    <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>198</internalId></provcov>
    </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>784</internalId></specobject>

    <specobject>
    <id>CanTp.EB.MetaData.GetTxNTaGenConnectionOff</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        When CanTpGenericConnectionSupport is disabled, before calling CanIf_Transmit() for a SF,
        FF or CF for a N-SDU with Normal fixed addressing format, the CanTp module shall call the
        EcuC_GetMetaDataTargetAddr() API to obtain the N_Ta (see ISO 15765-2:2016) and compare it
        with the corresponding configured value.
        If these values do not match, CanTp shall abort the transmission.
      </description>
    <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanTp_TransmitFrame.c_141</srcid><srcstatus/><internalId>1052</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_MetaDataSupport_TransmitSF</srcid><srcstatus/><internalId>1465</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_TransmitMultiframe</srcid><srcstatus/><internalId>1466</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_IgnoreFC_DifferentSA</srcid><srcstatus/><internalId>1469</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_IgnoreFC_DifferentTA</srcid><srcstatus/><internalId>1470</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_TransmitSF_DifferentTA</srcid><srcstatus/><internalId>1474</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>785</internalId></specobject>

    <specobject>
    <id>CanTp.EB.MetaData.GetTxNTaGenConnectionOn</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        When CanTpGenericConnectionSupport is enabled, before calling CanIf_Transmit() for a SF,
        FF or CF for a N-SDU with Normal fixed addressing format, the CanTp module shall call the
        EcuC_GetMetaDataTargetAddr() API to retrieve the N_Ta (see ISO 15765-2:2016).
      </description>
    <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanTp_TransmitFrame.c_258</srcid><srcstatus/><internalId>1056</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_MetaDataSupport_TransmitSF</srcid><srcstatus/><internalId>1465</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_TransmitMultiframe</srcid><srcstatus/><internalId>1466</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_IgnoreFC_DifferentSA</srcid><srcstatus/><internalId>1469</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_IgnoreFC_DifferentTA</srcid><srcstatus/><internalId>1470</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>786</internalId></specobject>

    <specobject>
    <id>CanTp.EB.MetaData.SetTxMetaDataCanId</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        After getting the N_Sa and N_Ta, the CanTp module shall set the CanId via the EcuC_SetMetaDataCanId()
        API call (see CanTp.EB.MetaData.GetTxNTaGenConnectionOff and CanTp.EB.MetaData.GetTxNTaGenConnectionOn)
        before calling CanIf_Transmit() for a SF, FF or CF for a N-SDU with Normal fixed addressing format.
      </description>
    <comment>
        29 bit CAN ID bit position (Normal fixed addressing mode):
    - physical addressing:
      28-26|25|24|23-16|15-8|7-0 |
        110 |0 |0 | 218 |N_SA|N_TA|
    - functional addressing:
      28-26|25|24|23-16|15-8|7-0 |
        110 |0 |0 | 219 |N_SA|N_TA|
        N_TA and N_SA are obtained calling EcuC_GetMetaDataSourceAddr() and EcuC_GetMetaDataTargetAddr().
      </comment>
    <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanTp_TransmitFrame.c_297</srcid><srcstatus/><internalId>1057</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_MetaDataSupport_TransmitSF</srcid><srcstatus/><internalId>1465</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_TransmitMultiframe</srcid><srcstatus/><internalId>1466</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_IgnoreFC_DifferentSA</srcid><srcstatus/><internalId>1469</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_IgnoreFC_DifferentTA</srcid><srcstatus/><internalId>1470</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>787</internalId></specobject>

    <specobject>
    <id>CanTp.EB.MetaData.CheckRxFcNSa</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        When CanTp_RxIndication is called for a FC N-SDU with Normal fixed addressing format, the CanTp
        module shall check that the N_Sa obtained from the CanId (via the EcuC_GetMetaDataCanId() API
        call) is equal to the N_Ta set during FF transmission (via the EcuC_GetMetaDataTargetAddr() API call).
        If these values do not match, CanTp shall ignore it.
      </description>
    <comment>
        Normal fixed addressing format: N_TA (saved N_SA), N_SA (saved N_TA).
      </comment>
    <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanTp_RxIndication.c_2403</srcid><srcstatus/><internalId>1045</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_MetaDataSupport_TransmitMultiframe</srcid><srcstatus/><internalId>1466</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_IgnoreFC_DifferentSA</srcid><srcstatus/><internalId>1469</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
      <linksto>CanTp.SWS_CanTp_00336</linksto>
      <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>199</internalId></provcov>
    </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>788</internalId></specobject>

    <specobject>
    <id>CanTp.EB.MetaData.CheckRxFcNTa</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        When CanTp_RxIndication is called for a FC N-PDU N-SDU with Normal fixed addressing format,
        the CanTp module shall check that the N_Ta obtained from the CanId (via the EcuC_GetMetaDataCanId()
        API call) is equal to the N_Sa set during FF transmission (via the EcuC_GetMetaDataSourceAddr() API call).
        If these values do not match, CanTp shall ignore it.
      </description>
    <comment>
        Normal fixed addressing format: N_TA (saved N_SA), N_SA (saved N_TA).
      </comment>
    <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanTp_RxIndication.c_2401</srcid><srcstatus/><internalId>1043</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_MetaDataSupport_TransmitMultiframe</srcid><srcstatus/><internalId>1466</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataSupport_IgnoreFC_DifferentTA</srcid><srcstatus/><internalId>1470</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
    <provcov>
      <linksto>CanTp.SWS_CanTp_00334_1</linksto>
      <dstversion>1</dstversion>
    <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>197</internalId></provcov>
    <provcov>
      <linksto>CanTp.SWS_CanTp_00336</linksto>
      <dstversion>1</dstversion>
    <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>199</internalId></provcov>
    </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>789</internalId></specobject>

    <specobject>
    <id>CanTp.EB.MetaData.NSduMetaDataTypeRef</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        If CANTP_NORMALFIXED addressing format is used for a N-SDU, then CanTp shall check that
        the corresponding MetaDataItems are of type SOURCE_ADDRESS_16 and TARGET_ADDRESS_16.
      </description>
    <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanTp_Extension.xdm.m4_913</srcid><srcstatus/><internalId>1069</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/config/CanTp_Extension.xdm.m4_1607</srcid><srcstatus/><internalId>1077</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01001_Err_CANTP_NORMALFIXED_EcuC_Ref</srcid><srcstatus/><internalId>1539</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_01001_Err_CANTP_NORMALFIXED_INVALID_METADATA_ITEMTYPE</srcid><srcstatus/><internalId>1541</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>790</internalId></specobject>

    <specobject>
    <id>CanTp.EB.MetaData.NPduMetaDataTypeRef</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        If CANTP_NORMALFIXED addressing format is used for a N-SDU, then CanTp shall check that
        the MetaDataItem is of type CAN_ID_32 for the respective CanTpTxNPdu, CanTpRxNPdu, CanTpTxFcNPdu
        and CanTpRxFcNPdu.
      </description>
    <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanTp_Extension.xdm.m4_914</srcid><srcstatus/><internalId>1070</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/config/CanTp_Extension.xdm.m4_1608</srcid><srcstatus/><internalId>1078</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01001_Err_CANTP_NORMALFIXED_EcuC_Ref</srcid><srcstatus/><internalId>1539</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_01001_Err_CANTP_NORMALFIXED_INVALID_METADATA_ITEMTYPE</srcid><srcstatus/><internalId>1541</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>791</internalId></specobject>

    <specobject>
    <id>CanTp.EB.InvalidCanIdMask</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        CanTp shall throw an error when the CanIfTxPduCanIdMask overrides the N_Sa, N_Ta
        or uni-/multicast info bit (bits 0..16, see ISO 15765-2:2016).
      </description>
    <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate_var/xgen/CanTp.xgen_1182</srcid><srcstatus/><internalId>1089</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01001_Err_CANTP_NORMALFIXED_CanIf_InvalidMask</srcid><srcstatus/><internalId>1540</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>792</internalId></specobject>

    <!-- == End Section: MetaData Handling ============================================================ -->
    
    <!-- == Multicore Handling ========================================================================= -->
    
    <specobject>
    <id>CanTp.EB.Multicore.CanTpMultiCoreSupport_Conf</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        Name: CanTpMultiCoreSupport
        Parent Container CanTpGeneral
        Description
      Enable support for CanTpMulticore via CanTpEcucPartitionRef. Each Partition will handle
        a specific main function, which will handle one or several CanTp channels.
      This feature cannot be enabled if CanTpDedicatedChannelProcessingSupport is disabled.
        Type BOOLEAN
        Default value false
        Post-Build Variant Multiplicity false
        Post-Build Variant Value false
        Multiplicity Configuration Class
      Pre-compile time  X    All variants
      Link time         --
      Post-build time   --
        Value Configuration Class
      Pre-compile time  X    All variants
      Link time         --
      Post-build time   --
        Scope / Dependency
      scope: local
      </description>
    <comment>
      </comment>
    <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01001_No_Partition_Referenced</srcid><srcstatus/><internalId>1550</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>793</internalId></specobject>
    
    <specobject>
    <id>CanTp.EB.Multicore.CanTpDedicatedChannelProcessingSupport_Conf</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        Name: CanTpDedicatedChannelProcessingSupport
        Parent Container CanTpGeneral
        Description
      Enables support to map the processing of CanTp channels to different main functions.
        Type BOOLEAN
        Default value false
        Post-Build Variant Multiplicity false
        Post-Build Variant Value false
        Multiplicity Configuration Class
      Pre-compile time  X    All variants
      Link time         --
      Post-build time   --
        Value Configuration Class
      Pre-compile time  X    All variants
      Link time         --
      Post-build time   --
        Scope / Dependency
      scope: local
      </description>
    <comment>
      </comment>
    <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01001_Err_Same_Channel_Referenced</srcid><srcstatus/><internalId>1548</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_01001_No_Channel_Referenced</srcid><srcstatus/><internalId>1549</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_01001_No_CanTpChannelProcessing_Configured</srcid><srcstatus/><internalId>1551</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_01001_MaxParallelChannels_Enabled</srcid><srcstatus/><internalId>1553</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>794</internalId></specobject>
    
    <specobject>
      <id>CanTp.EB.Multicore.CanTpChannelProcessing_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
      Container Name: CanTpChannelProcessing [Multi Config Container]
      Description:
        This container contains the configuration parameters and sub
        containers of the AUTOSAR CanTp module. This container is a
        MultipleConfigurationContainer, i.e. this container and its
        sub-containers exist once per configuration set.
      Configuration Parameters: None
      </description>
      <comment>
      This is a configuration container which allows the definition of multiple CanTp_MainFunctions for the channels handling.
        </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01001_No_CanTpChannelProcessing_Configured</srcid><srcstatus/><internalId>1551</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>795</internalId></specobject>
    
    <specobject>
      <id>CanTp.EB.Multicore.CanTpTimeBase_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
      Name:CanTpTimeBase
      Description: Reference CanTpTimeBase for the associated CanTpChannels.
      Range 0 .. 3.6
      Default value --
      </description>
      <comment>
      This requirement is informational only.
      Rationale:
      This requirement gives information about the call of the function,
      which is not part of the implementation of this module.
        </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanTp_EBParameters.xdm.m4_641</srcid><srcstatus/><internalId>1065</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>796</internalId></specobject>
    
    <specobject>
      <id>CanTp.EB.Multicore.CanTpChannelRef_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
      Container Name: CanTpChannelRef
      Description:
        This container contains a refference to CanTpChannels which will be processed by
        the respective CanTp_Mainfunction.
      </description>
      <comment>
        </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01001_Err_Same_Channel_Referenced</srcid><srcstatus/><internalId>1548</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_01001_No_Channel_Referenced</srcid><srcstatus/><internalId>1549</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>797</internalId></specobject>
    
    <specobject>
      <id>CanTp.EB.Multicore.CanTpEcuCPartitionRef_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
      Container Name: CanTpEcuCPartitionRef
      Description: This container contains a refference to EcuCPartition.
      </description>
      <comment>
        </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01001_No_Partition_Referenced</srcid><srcstatus/><internalId>1550</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_01001_Same_Partition_ref</srcid><srcstatus/><internalId>1552</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>798</internalId></specobject>
    
    <specobject>
    <id>CanTp.EB.Multicore.MainFunctions_name</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      When CanTpDedicatedChannelProcessingSupport is enabled, for each CanTpChannelProcessing a CanTp_MainFunction
      will be generated.
      For each of those CanTp_MainFunctions the following naming scheme should be used:
      CanTp_MainFunction_shortName(): Where shortName is the short name of the respective configuration container in the ECU configuration.
      </description>
    <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_DedicatedMF_uninitialized</srcid><srcstatus/><internalId>1617</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_DedicatedMF_Transmission</srcid><srcstatus/><internalId>1618</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_DedicatedMF_Transmission_ClassicMF</srcid><srcstatus/><internalId>1619</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_DedicatedMF_Reception</srcid><srcstatus/><internalId>1620</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_DedicatedMF_Timeout</srcid><srcstatus/><internalId>1621</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>799</internalId></specobject>
    
    <specobject>
    <id>CanTp.EB.Multicore.MainFunctions_handling</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      Each CanTp_MainFunction_shortName() will handle the configured channels under CanTpChannelRef.
      </description>
    <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_DedicatedMF_Transmission</srcid><srcstatus/><internalId>1618</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_DedicatedMF_Transmission_ClassicMF</srcid><srcstatus/><internalId>1619</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_DedicatedMF_Reception</srcid><srcstatus/><internalId>1620</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_DedicatedMF_Timeout</srcid><srcstatus/><internalId>1621</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>800</internalId></specobject>
    
    <specobject>
    <id>CanTp.EB.Multicore.MainFunctions_1_handling</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      The CanTpChannels that are not referenced by any CanTpChannelProcessing container, will be handled by the 
      normal CanTp_MainFunction().
      </description>
    <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_DedicatedMF_Transmission</srcid><srcstatus/><internalId>1618</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_DedicatedMF_Transmission_ClassicMF</srcid><srcstatus/><internalId>1619</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_DedicatedMF_Reception</srcid><srcstatus/><internalId>1620</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_DedicatedMF_Timeout</srcid><srcstatus/><internalId>1621</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>801</internalId></specobject>
    
    <specobject>
    <id>CanTp.EB.Multicore.ParallelChannelsLimitation_Conf</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      An error should be displayed if both CanTpDedicatedChannelProcessingSupport and CanTpMaxParallelChannels are enabled.
      </description>
    <comment>
      When ParallelChannels feature is enabled, the CanTp channels are assigned dynamically. If both features are enabled in the same time,
        it might be possible to assign the same channel to two different partitions and that would lead to an issue (concurrent memory access).
      </comment>
    <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01001_MaxParallelChannels_Enabled</srcid><srcstatus/><internalId>1553</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>802</internalId></specobject>
    
    <specobject>
    <id>CanTp.EB.Multicore.EcuCPartitionRef_Limitation1_Conf</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      An error should be displayed if All the Pdus (N-Sdu and N-Pdu) mapped to a CanTp Channel are not 
      on the same partition as the Channel.
      </description>
    <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01001_InvalidPartitionEcuC</srcid><srcstatus/><internalId>1555</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_01001_InvalidPartitionEcuC_2</srcid><srcstatus/><internalId>1556</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_01001_InvalidPartitionEcuC_3</srcid><srcstatus/><internalId>1557</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_01001_InvalidPartitionEcuC_4</srcid><srcstatus/><internalId>1558</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_01001_InvalidPartitionEcuC_5</srcid><srcstatus/><internalId>1559</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_01001_InvalidPartitionEcuC_6</srcid><srcstatus/><internalId>1560</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>803</internalId></specobject>
    
    <specobject>
    <id>CanTp.EB.Multicore.CanTpChannelRef_Limitation1_Conf</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      An error should be displayed if several CanTpChannelRef are referencing the same channel.
      </description>
    <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01001_Err_Same_Channel_Referenced</srcid><srcstatus/><internalId>1548</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>804</internalId></specobject>
    
    <specobject>
    <id>CanTp.EB.Multicore.CanTpChannelRef_Limitation2_Conf</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      An error should be displayed if CanTpDedicatedChannelProcessingSupport is enabled and no Channel reference is configured
      for each CanTpChannelProcessing.
      </description>
    <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01001_No_Channel_Referenced</srcid><srcstatus/><internalId>1549</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>805</internalId></specobject>
    
    <specobject>
    <id>CanTp.EB.Multicore.CanTpChannelProcessing_Limitation1_Conf</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      A warning should be displayed if CanTpDedicatedChannelProcessingSupport is enabled and no CanTpChannelProcessing entry
      is configured.
      </description>
    <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01001_No_CanTpChannelProcessing_Configured</srcid><srcstatus/><internalId>1551</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>806</internalId></specobject>
    
    <specobject>
    <id>CanTp.EB.Multicore.CanTpEcuCPartitionRef_Limitation1_Conf</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      An error should be displayed if CanTpMultiCoreSupport is enabled and no PartitionRef is configured.
      </description>
    <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01001_No_Partition_Referenced</srcid><srcstatus/><internalId>1550</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>807</internalId></specobject>
    
    <specobject>
    <id>CanTp.EB.Multicore.CanTpEcuCPartitionRef_Limitation2_Conf</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      A warning should be displayed if CanTpMultiCoreSupport is enabled and all channels are referencing the same partition.
      </description>
    <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01001_Same_Partition_ref</srcid><srcstatus/><internalId>1552</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>808</internalId></specobject>
    
    <!-- == End Section: Multicore Handling ============================================================ -->
    
    <specobject>
    <id>CanTp.EB.CanTpFixedRxPduLengthSupport_Conf</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        Name: CanTpFixedRxPduLengthSupport
        Parent Container CanTpGeneral
        Description
      Enable/Disable support for variable length of received NSdu.
      If this parameter is enabled the lenght of the received Nsdu should be equal with the one configured in EcuC.
      If this parameter is disabled the lenght of the received Nsdu should be smaller or equal to the one configured in EcuC.
        Type BOOLEAN
        Default value false
        Post-Build Variant Multiplicity false
        Post-Build Variant Value false
        Multiplicity Configuration Class
      Pre-compile time  X    All variants
      Link time         --
      Post-build time   --
        Value Configuration Class
      Pre-compile time  X    All variants
      Link time         --
      Post-build time   --
        Scope / Dependency
      scope: local
      </description>
    <comment>
      </comment>
    <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanTp_EBParameters.xdm.m4_461</srcid><srcstatus/><internalId>1064</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>809</internalId></specobject>
    
    <specobject>
    <id>CanTp.EB.CanTpFixedRxPduLengthSupport_Enabled</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      When configuraton parameter CanTpFixedRxPduLengthSupport is enabled the lenght of the received NPdu should be equal with the one configured in EcuC.
      </description>
    <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_1</srcid><srcstatus/><internalId>1643</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_2</srcid><srcstatus/><internalId>1644</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_3</srcid><srcstatus/><internalId>1645</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>810</internalId></specobject>
    
    <specobject>
    <id>CanTp.EB.CanTpFixedRxPduLengthSupport_InvalidLength</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      If a frame with invalid length will be received, this one should be dropped and DET CANTP_E_INVALID_RX_LENGTH should be reported.
      If the frame with invalid lenght is received during the reception of a valid multiframe, the multiframe 
      reception should countinue after DET reporting.
      </description>
    <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_2</srcid><srcstatus/><internalId>1644</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_3</srcid><srcstatus/><internalId>1645</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>811</internalId></specobject>
    
    <!-- ==  Parallel CAN IDs with MetaData Handling ============================================================ -->
    
    <specobject>
    <id>CanTp.EB.CanTpMetaDataParallelHandling_Conf</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        Name: CanTpMetaDataParallelHandling
        Parent Container CanTpGeneral
        Description
      Enable/Disable support for handling of parallel CAN IDs using MetaData.
        Type BOOLEAN
        Default value false
        Post-Build Variant Multiplicity false
        Post-Build Variant Value false
        Multiplicity Configuration Class
      Pre-compile time  X    All variants
      Link time         --
      Post-build time   --
        Value Configuration Class
      Pre-compile time  X    All variants
      Link time         --
      Post-build time   --
        Scope / Dependency
      scope: local
      </description>
    <comment>
      </comment>
    <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanTp_EBParameters.xdm.m4_421</srcid><srcstatus/><internalId>1061</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_MetaDataParallelHandling_ReceiveSF</srcid><srcstatus/><internalId>1452</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataParallelHandling_ReceiveMultiframe</srcid><srcstatus/><internalId>1453</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataParallelHandling_MultiRx</srcid><srcstatus/><internalId>1454</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataParallelHandling_ReceiveMultiframe_Fail</srcid><srcstatus/><internalId>1455</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataParallelHandling_ReceiveMultiframeOngoing_FullDuplex</srcid><srcstatus/><internalId>1456</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataParallelHandling_TransmitSF</srcid><srcstatus/><internalId>1457</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataParallelHandling_TransmitMultiframe</srcid><srcstatus/><internalId>1458</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataParallelHandling_TransmitMultiframe_Fail</srcid><srcstatus/><internalId>1459</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataParallelHandling_ReceiveMultiframe_Invalid_RxPduId</srcid><srcstatus/><internalId>1460</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>812</internalId></specobject>
    
    <specobject>
    <id>CanTp.EB.CanTpMetaDataParallelHandling_Conf_Limitation1</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      If CanTpMetaDataParallelHandling is ENABLED, CanTpRxAddressingFormat and CanTpTxAddressingFormat should be CANTP_STANDARD 
      for all Rx and Tx NSdus.
      </description>
    <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanTp_EBParameters.xdm.m4_441</srcid><srcstatus/><internalId>1062</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01001_Err_MetaDataParallelChannels</srcid><srcstatus/><internalId>1554</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>813</internalId></specobject>
    
    <specobject>
    <id>CanTp.EB.CanTpMetaDataParallelHandling_Conf_Limitation2</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      If CanTpMetaDataParallelHandling is ENABLED, CanTpMultiCoreSupport and CanTpDynIdSupport should be disabled.
      </description>
    <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanTp_EBParameters.xdm.m4_450</srcid><srcstatus/><internalId>1063</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01001_Err_MetaDataParallelChannels</srcid><srcstatus/><internalId>1554</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>814</internalId></specobject>
    
    <specobject>
    <id>CanTp.EB.CanTpMetaDataParallelHandling_Conf_Limitation3</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        If CanTpMetaDataParallelHandling is ENABLED, CanTp shall check that MetaDataTypeRef of type CAN_ID_32 
        is configured for all CanTpRxNPduRef, CanTpTxFcNPduRef, CanTpRxNSduRef, CanTpTxNSduRef, CanTpTxNPduRef and CanTpRxFcNPduRef.
      </description>
    <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanTp_Extension.xdm.m4_1110</srcid><srcstatus/><internalId>1071</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/config/CanTp_Extension.xdm.m4_1744</srcid><srcstatus/><internalId>1079</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01001_Err_MetaDataParallelChannels</srcid><srcstatus/><internalId>1554</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>815</internalId></specobject>
    
    <specobject>
    <id>CanTp.EB.CanTpMetaDataParallelHandling_Reception</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      If CanTpMetaDataParallelHandling is ENABLED, then at reception of an RxNPdu its metadata should be read using EcuC_GetMetaDataCanId() API.
      A search in the pool of RxNSdus should be performed and metadata should be read, with the same EcuC API, for the RxNSdus that already have a reception ongoing.
      </description>
    <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanTp_RxIndication.c_873</srcid><srcstatus/><internalId>1028</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/CanTp_RxIndication.c_890</srcid><srcstatus/><internalId>1029</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_MetaDataParallelHandling_ReceiveSF</srcid><srcstatus/><internalId>1452</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataParallelHandling_ReceiveMultiframe</srcid><srcstatus/><internalId>1453</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataParallelHandling_MultiRx</srcid><srcstatus/><internalId>1454</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>816</internalId></specobject>
    
    <specobject>
    <id>CanTp.EB.CanTpMetaDataParallelHandling_RxSameMetadata</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      If the result of the search from CanTp.EB.CanTpMetaDataParallelHandling_Reception returns that any of the RxNSdus have an ongoing reception
      on the same metadata as the one received in the RxNPdu, that reception will be discarded and the new one will be processed.
      </description>
    <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanTp_RxIndication.c_895</srcid><srcstatus/><internalId>1030</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_MetaDataParallelHandling_ReceiveMultiframeOngoing_FullDuplex</srcid><srcstatus/><internalId>1456</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>817</internalId></specobject>
    
    <specobject>
    <id>CanTp.EB.CanTpMetaDataParallelHandling_RxDifferentMetadata</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      If the result of the search from CanTp.EB.CanTpMetaDataParallelHandling_Reception returns that metadata is not the same for any RxNSdu, and there are RxNSdus
      that don't have an ongoing reception, metadata will be set for that free RxNSdu using EcuC_SetMetaDataCanId() API (only for FF/ SF but not for CF)
      and the frame will be processed.
      </description>
    <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanTp_RxIndication.c_920</srcid><srcstatus/><internalId>1032</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_MetaDataParallelHandling_ReceiveSF</srcid><srcstatus/><internalId>1452</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataParallelHandling_ReceiveMultiframe</srcid><srcstatus/><internalId>1453</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_MetaDataParallelHandling_MultiRx</srcid><srcstatus/><internalId>1454</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>818</internalId></specobject>
    
    <specobject>
    <id>CanTp.EB.CanTpMetaDataParallelHandling_RxDifferentMetadataCF</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      When CanTpMetaDataParallelHandling is ENABLED, if a CF is received and its metadata is not the same as the one received in the FF, this CF will be discarded.
      </description>
    <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_MetaDataParallelHandling_ReceiveMultiframe_Fail</srcid><srcstatus/><internalId>1455</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>819</internalId></specobject>
    
    <specobject>
    <id>CanTp.EB.CanTpMetaDataParallelHandling_RxNSduNotAvailable</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      When CanTpMetaDataParallelHandling is ENABLED, if there are no free RxNSdus the reception will be discarded.
      </description>
    <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanTp_RxIndication.c_903</srcid><srcstatus/><internalId>1031</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_MetaDataParallelHandling_ReceiveMultiframeOngoing_FullDuplex</srcid><srcstatus/><internalId>1456</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>820</internalId></specobject>
    
    <specobject>
    <id>CanTp.EB.CanTpMetaDataParallelHandling_SF_Transmission</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      If CanTpMetaDataParallelHandling is ENABLED, when a SF transmission is initiated by calling CanTp_Transmit(), metadata should be read from TxNSdu
      using EcuC_GetMetaDataCanId() and should be set on the related TxNPdu using EcuC_SetMetaDataCanId().
      </description>
    <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanTp_Transmit.c_332</srcid><srcstatus/><internalId>1048</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_MetaDataParallelHandling_TransmitSF</srcid><srcstatus/><internalId>1457</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>821</internalId></specobject>
    
    <specobject>
    <id>CanTp.EB.CanTpMetaDataParallelHandling_FF_Transmission</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      If CanTpMetaDataParallelHandling is ENABLED, when a FF a transmission is initiated by calling CanTp_Transmit(), metadata should be read from TxNSdu
      using EcuC_GetMetaDataCanId() and should be set on the related TxNPdu using EcuC_SetMetaDataCanId().
      Also the metadata should be read and saved locally for the corresponding RxFcNPdu.
      </description>
    <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanTp_Transmit.c_367</srcid><srcstatus/><internalId>1049</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_MetaDataParallelHandling_TransmitMultiframe</srcid><srcstatus/><internalId>1458</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>822</internalId></specobject>
    
    <specobject>
    <id>CanTp.EB.CanTpMetaDataParallelHandling_FC_Reception</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      If CanTpMetaDataParallelHandling is ENABLED, when a FC is received, metadata should be read using EcuC_GetMetaDataCanId() and it should be checked
      against the saved metadata for all ongoing transmissions. If it matches, the FC will be processed, otherwise it will be discarded.
      </description>
    <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanTp_RxIndication.c_944</srcid><srcstatus/><internalId>1033</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_MetaDataParallelHandling_TransmitMultiframe_Fail</srcid><srcstatus/><internalId>1459</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>823</internalId></specobject>
    
    <!-- == End Section: Parallel CAN IDs with MetaData Handling ============================================================ -->
    <!-- == Modified description of transport protocol address value parameters ============================================================ -->

    <specobject>
      <id>CanTp.EB.CanTpNADescription.CanTpNSa</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description> 
        Rx N-SDU:
          If an Rx N-SDU is configured for extended addressing format or normal
          fixed addressing format (CanTpDynIdSupport enabled and CanTpGenericConnectionSupport
          disabled), this parameter contains the value of the transport protocol address of the local
          node (e.g., this ECU).
        Tx N-SDU:
          This parameter contains the value of the transport protocol
          address of the local node (i.e., this ECU), if a Tx N-SDU is configured with: - extended
          addressing format - normal fixed addressing format and CanTpDynIdSupport is enabled.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanTp_Extension.xdm.m4_1184</srcid><srcstatus/><internalId>1073</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/config/CanTp_Extension.xdm.m4_1821</srcid><srcstatus/><internalId>1081</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ECUC_CanTp_00254</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>466</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>824</internalId></specobject>

    <specobject>
      <id>CanTp.EB.CanTpNADescription.CanTpNAe</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description> 
        Rx N-SDU:
          If an Rx N-SDU is configured for mixed addressing format, this
          parameter contains the value of the transport protocol
          address extension.
        Tx N-SDU:
          If a Tx N-SDU is configured for mixed addressing format, this
          parameter contains the value of the transport protocol address
          extension.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanTp_Extension.xdm.m4_1141</srcid><srcstatus/><internalId>1072</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/config/CanTp_Extension.xdm.m4_1777</srcid><srcstatus/><internalId>1080</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ECUC_CanTp_00285</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>468</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>825</internalId></specobject>

    <specobject>
      <id>CanTp.EB.CanTpNADescription.CanTpNTa</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description> 
        Rx N-SDU:
          If a Rx N-SDU is configured for extended addressing format
          or normal fixed addressing format (CanTpDynIdSupport enabled),
          this parameter contains the value of the transport protocol
          address of the remote node (e.g., the diagnostic tester),
          if an Rx N-SDU is configured with:
          - extended addressing format
          - Normal fixed addressing format and CanTpDynIdSupport is
            enabled.
        Tx N-SDU:
          This parameter contains the value of the transport protocol
          address of the remote node (e.g., the diagnostic tester),
          if Tx N-SDU is configured with:
          - extended addressing format
          - normal fixed addressing format, CanTpDynIdSupport is enabled
            and CanTpGenericConnectionSupport is disabled.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanTp_Extension.xdm.m4_1233</srcid><srcstatus/><internalId>1075</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/config/CanTp_Extension.xdm.m4_1871</srcid><srcstatus/><internalId>1083</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ECUC_CanTp_00255</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>464</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>826</internalId></specobject>
  <!-- == End Section: Modified description of transport protocol address value parameters ============================================================ -->

  </specobjects>
    <specobjects doctype="swurs">
 
    <specobject>
      <id>CanTp.11226</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        Figure TS_CANTP_11226.png shows the transmission of unsegmented messages:
        Only one single frame is transmitted.
      </description>
      <comment>
       Please refer to figure TS_CANTP_11226.png.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30054</srcid><srcstatus/><internalId>1197</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>827</internalId></specobject>

    <specobject>
      <id>CanTp.11247</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        In case of normal addressing, 7 data bytes are transmitted.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_RequestNewTransmissionFromTxConfirmation_SF</srcid><srcstatus/><internalId>1180</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30048</srcid><srcstatus/><internalId>1193</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>828</internalId></specobject>

    <specobject>
      <id>CanTp.11248</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        In case of extended addressing, 6 data bytes are transmitted.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30054</srcid><srcstatus/><internalId>1197</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>829</internalId></specobject>

    <specobject>
      <id>CanTp.11228</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>2</version>
      <description>
        Figure TS_CANTP_11228.png shows the transmission of segmented messages: The
        Block Size is the number of consecutive frames before awaiting the next
        flow control. STmin is the time to wait at least before transmitting the
        next consecutive frame.
      </description>
      <comment>
        Please refer to figure TS_CANTP_11228.png.
        See Deviation : Block size (BS) handling
      </comment>
      <needscoverage>
        <!-- Old linkage dsn deleted -->
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30085</srcid><srcstatus/><internalId>1208</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30485</srcid><srcstatus/><internalId>1214</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>830</internalId></specobject>

    <specobject>
      <id>CanTp.11249</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        Messages longer than 6 or 7 data bytes are segmented into
        - a FirstFrame protocol data unit (FF N_PDU), containing the first
          five (5) - in the case of extended or mixed addressing - or six
          (6) - in the case of normal addressing - data bytes, and
        - one or more ConsecutiveFrame protocol data units (CF N_PDU), containing
          each six (6) or seven (7) data bytes.
        The CF N_PDU contains only the remaining data bytes, and may therefore be
        less than six (6) or seven (7) data bytes long.
      </description>
      <needscoverage>
        <!-- Old linkage dsn deleted -->
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_RequestNewTransmissionFromTxConfirmation_MultiFrame</srcid><srcstatus/><internalId>1181</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30053</srcid><srcstatus/><internalId>1196</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30055</srcid><srcstatus/><internalId>1198</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30056</srcid><srcstatus/><internalId>1200</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30057</srcid><srcstatus/><internalId>1201</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>831</internalId></specobject>

    <specobject>
      <id>CanTp.11245</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        The message length is transmitted in the FF.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30374</srcid><srcstatus/><internalId>1204</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30375</srcid><srcstatus/><internalId>1205</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>832</internalId></specobject>

    <specobject>
      <id>CanTp.11246</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        The CF are numbered to allow reassembly.
      </description>
      <comment>
        Covered by CanTp.11109
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30089</srcid><srcstatus/><internalId>1202</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30090</srcid><srcstatus/><internalId>1203</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>833</internalId></specobject>

    <specobject>
      <id>CanTp.11252</id>
      <status>rejected</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        After receiving/sending a FF, CanTp sends/expects one of FC.CTS continue
        to send, the authorization to continue, FC.WAIT: the request to continue
        to wait, FC.OVFLW: buffer overflow, the indication that the number of
        bytes specified in the FirstFrame of the segmented message exceeds the
        number of bytes that can be stored in the buffer of the receiver entity
      </description>
      <comment>
        This requirement is informational only.
        Rationale:
        This requirement provides an overview. The handling of the flow control
        messages is better defined in the AUTOSAR SWS. 
      </comment>
      <!-- Old linkage dsn deleted -->
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>834</internalId></specobject>

    <specobject>
      <id>CanTp.11253</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
      The N_WFTmax parameter shall indicate how many FC N_PDU WTs can be
      transmitted by the receiver in a row. This parameter is a system design
      constant and is not transmitted in the first FC N_PDU.
      </description>
      <needscoverage>
        <!-- Requirement covered by CanTp.SWS_CanTp_00223 -->
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00223</srcid><srcstatus/><internalId>171</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>835</internalId></specobject>

    <specobject>
      <id>CanTp.11277</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        The N_WFTmax parameter shall only be used on the receiving network entity
        during message reception.
      </description>
      <needscoverage>
        <!-- Requirement covered by CanTp.SWS_CanTp_00223 -->
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00223</srcid><srcstatus/><internalId>171</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>836</internalId></specobject>

    <specobject>
      <id>CanTp.11278</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        If N_WFTmax parameter value is set to zero (0), then flow control shall
        rely upon flow control continue to send FC N_PDU CTS only. Flow control
        wait (FC N_PDU WT) shall not be used by that network entity.
      </description>
      <needscoverage>
        <!-- Old linkage dsn deleted -->
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30322</srcid><srcstatus/><internalId>1223</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>837</internalId></specobject>

    <specobject>
      <id>CanTp.11307</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        The N_TA value of the CAN identifier is placed in the first byte of the
        frame. The CAN frame thus consists of N_TA, N_PCI and the data bytes.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_RequestNewTransmissionFromTxConfirmation_MultiFrame</srcid><srcstatus/><internalId>1181</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30055</srcid><srcstatus/><internalId>1198</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>838</internalId></specobject>

    <specobject>
      <id>CanTp.11256</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        The SF N_PDU is identified by the single-frame protocol control
        information (SF N_PCI). The SF N_PDU shall be sent out by the sending
        network entity and can be received by one or multiple receiving network
        entities. It shall be sent out to transfer a service data unit that can
        be transferred via a single service request to the data link layer, and
        to transfer unsegmented messages.
      </description>
      <needscoverage>
        <!-- Old linkage dsn deleted -->
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30054</srcid><srcstatus/><internalId>1197</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>839</internalId></specobject>

    <specobject>
      <id>CanTp.ISO15765.SF.Format</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        The following table provides an overview about the whole Single Frame.
        Byte      normal addressing             extended addressing           mixed addressing
        0         Single Frame N_PCI byte 0     N_TA                          N_AE
        1         Single Frame N_PCI byte 1     Single Frame N_PCI byte 0     Single Frame N_PCI byte 0
        2         Data byte 0                   Single Frame N_PCI byte 1     Single Frame N_PCI byte 1
        3         Data byte 1                   Data byte 0                   Data byte 0
        4         Data byte 2                   Data byte 1                   Data byte 1
        5         Data byte 3                   Data byte 2                   Data byte 2
        6         Data byte 4                   Data byte 3                   Data byte 3
        7         Data byte 5                   Data byte 4                   Data byte 4
      </description>
      <comment>
        Information only.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_Normal_Functional</srcid><srcstatus/><internalId>1368</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_Mixed_Functional_1</srcid><srcstatus/><internalId>1393</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30414</srcid><srcstatus/><internalId>1658</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>840</internalId></specobject>

    <specobject>
      <id>CanTp.10942</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        The Single Frame N_PCI byte:
              Bit   7       6       5       4       3       2       1       0
        Byte 0      0       0       0       0       SF_DL   SF_DL   SF_DL   SF_DL
      </description>
      <comment>
      Information only.
      </comment>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.10966</srcid><srcstatus/><internalId>842</internalId></linkedfrom><linkedfrom><srcid>CanTp.11298</srcid><srcstatus/><internalId>843</internalId></linkedfrom><linkedfrom><srcid>CanTp.11299</srcid><srcstatus/><internalId>844</internalId></linkedfrom><linkedfrom><srcid>CanTp.11300</srcid><srcstatus/><internalId>845</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>841</internalId></specobject>

    <specobject>
      <id>CanTp.10966</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        Parameter: SF_DL - SingleFrame DataLength
        - 0x0 Reserved
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30049</srcid><srcstatus/><internalId>1266</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.10942</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>841</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>842</internalId></specobject>

    <specobject>
      <id>CanTp.11298</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        Parameter: SF_DL - SingleFrame DataLength
        - 0x1 - 0x6 data length for normal and extended addressing mode
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30054</srcid><srcstatus/><internalId>1197</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30187</srcid><srcstatus/><internalId>1250</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.10942</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>841</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>843</internalId></specobject>

    <specobject>
      <id>CanTp.11299</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        Parameter: SF_DL - SingleFrame DataLength
        - 0x7 data length for normal addressing mode only
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_RequestNewTransmissionFromTxConfirmation_SF</srcid><srcstatus/><internalId>1180</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30048</srcid><srcstatus/><internalId>1193</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30060</srcid><srcstatus/><internalId>1268</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_Normal_Functional</srcid><srcstatus/><internalId>1368</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.10942</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>841</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>844</internalId></specobject>

    <specobject>
      <id>CanTp.11300</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        Parameter: SF_DL - SingleFrame DataLength
        - 0x8 - 0xF invalid
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30066</srcid><srcstatus/><internalId>1251</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30059</srcid><srcstatus/><internalId>1267</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_Extented_Functional</srcid><srcstatus/><internalId>1408</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.10942</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>841</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>845</internalId></specobject>

    <specobject>
      <id>CanTp.11257</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        The FF N_PDU is identified by the first-frame protocol control information
        (FF N_PCI). The FF N_PDU shall be sent out by the sending network entity
        and received by a unique receiving network entity for the duration of the
        segmented message transmission. It identifies the first N_PDU of a
        segmented message transmitted by a network sending entity and received by
        a receiving network entity. The receiving network layer entity shall
        start assembling the segmented message on receipt of an FF N_PDU.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30056</srcid><srcstatus/><internalId>1200</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30135</srcid><srcstatus/><internalId>1206</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>846</internalId></specobject>

    <specobject>
      <id>CanTp.10969</id>
      <status>rejected</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        The following table provides an overview about the whole FirstFrame.
        Byte      normal addressing           extended addressing         mixed addressing
        0         First Frame N_PCI byte 0    N_TA                        N_AE
        1         First Frame N_PCI byte 1    First Frame N_PCI byte 0    First Frame N_PCI byte 0
        2         Data byte 0                 First Frame N_PCI byte 1    First Frame N_PCI byte 1
        3         Data byte 1                 Data byte 0                 Data byte 0
        4         Data byte 2                 Data byte 1                 Data byte 1
        5         Data byte 3                 Data byte 2                 Data byte 2
        6         Data byte 4                 Data byte 3                 Data byte 3
        7         Data byte 5                 Data byte 4                 Data byte 4
      </description>
      <comment>
        This requirement is informational only.
        Rationale:
        This requirement provides an overview. If coverage of this topic is required,
        then additional requirements need to be defined.
      </comment>
      <!-- Old linkage dsn deleted -->
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>847</internalId></specobject>

    <specobject>
      <id>CanTp.11010</id>
      <status>rejected</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        The FirstFrame N_PCI byte:
              Bit   7       6       5       4       3       2       1       0
        Byte 0      0       0       0       1       FF_DL   FF_DL   FF_DL   FF_DL
        Byte 1      FF_DL   FF_DL   FF_DL   FF_DL   FF_DL   FF_DL   FF_DL   FF_DL
      </description>
      <comment>
        This requirement is informational only.
        Rationale:
        This requirement provides an overview. If coverage of this topic is required,
        then additional requirements need to be defined.
      </comment>
      <!-- Old linkage dsn deleted -->
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>848</internalId></specobject>

    <specobject>
      <id>CanTp.11042</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        Parameter: FF_DL - FirstFrame DataLength
        - 0x0 - 0x06 invalid
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30080</srcid><srcstatus/><internalId>1265</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30088</srcid><srcstatus/><internalId>1270</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>849</internalId></specobject>

    <specobject>
      <id>CanTp.11265</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        Parameter: FF_DL - FirstFrame DataLength
        - 0x7 data length for extended addressing mode only
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_RequestNewTransmissionFromTxConfirmation_MultiFrame</srcid><srcstatus/><internalId>1181</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30055</srcid><srcstatus/><internalId>1198</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30087</srcid><srcstatus/><internalId>1269</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>850</internalId></specobject>

    <specobject>
      <id>CanTp.11266</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        Parameter: FF_DL - FirstFrame DataLength
        - 0x8 - 0xFFF data length for normal and extended addressing mode
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30304</srcid><srcstatus/><internalId>1399</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>851</internalId></specobject>

    <specobject>
      <id>CanTp.11258</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        The CF N_PDU is identified by the consecutive-frame protocol control
        information (CF N_PCI). The CF N_PDU transfers segments (N_Data) of the
        service data unit message data (MessageData). All N_PDUs
        transmitted by the sending entity after the FF N_PDU shall be encoded as
        CF N_PDUs. The receiving entity shall pass the assembled message to the
        service user of the network receiving entity after the last CF N_PDU has
        been received. The CF N_PDU shall be sent out by the sending network
        entity and received by a unique receiving network entity for the duration
        of the segmented message transmission.
      </description>
      <needscoverage>
        <!-- Old linkage dsn deleted -->
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_RequestNewTransmissionFromTxConfirmation_MultiFrame</srcid><srcstatus/><internalId>1181</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30053</srcid><srcstatus/><internalId>1196</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30055</srcid><srcstatus/><internalId>1198</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30056</srcid><srcstatus/><internalId>1200</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30057</srcid><srcstatus/><internalId>1201</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30089</srcid><srcstatus/><internalId>1202</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30090</srcid><srcstatus/><internalId>1203</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30091</srcid><srcstatus/><internalId>1209</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>852</internalId></specobject>

    <specobject>
      <id>CanTp.11045</id>
      <status>rejected</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        The following table provides an overview about the whole ConsecutiveFrame.
        Byte      normal addressing           extended addressing         mixed addressing
        0         Consecutive Frame N_PCI     N_TA                        N_AE
        1         Data byte 0                 Consecutive Frame N_PCI     Consecutive Frame N_PCI
        2         Data byte 1                 Data byte 0                 Data byte 0
        3         Data byte 2                 Data byte 1                 Data byte 1
        4         Data byte 3                 Data byte 2                 Data byte 2
        5         Data byte 4                 Data byte 3                 Data byte 3
        6         Data byte 5                 Data byte 4                 Data byte 4
        7         Data byte 6                 Data byte 5                 Data byte 5
      </description>
      <comment>
        This requirement is informational only.
        Rationale:
        This requirement provides an overview. If coverage of this topic is required,
        then additional requirements need to be defined.
      </comment>
      <!-- Old linkage dsn deleted -->
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>853</internalId></specobject>

    <specobject>
      <id>CanTp.11086</id>
      <status>rejected</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        The ConsecutiveFrame N_PCI byte:
              Bit   7       6       5       4       3       2       1       0
        Byte 0      0       0       1       0       SN      SN      SN      SN
      </description>
      <comment>
        This requirement is informational only.
        Rationale:
        This requirement provides an overview. If coverage of this topic is required,
        then additional requirements need to be defined.
      </comment>
      <!-- Old linkage dsn deleted -->
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>854</internalId></specobject>

    <specobject>
      <id>CanTp.11109</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        Parameter: SN - SequenceNumber
        0x0 - 0xF
        The parameter SequenceNumber (SN) is used in the ConsecutiveFrame N_PDU to
        specify the order of the consecutive frames. The following rules apply to
        the SequenceNumber (SN):
        - The SequenceNumber (SN) shall start with zero (0) for all segmented
        messages. The FirstFrame shall be assigned the value zero (0). It does
        not include an explicit SequenceNumber in the N_PCI field but it shall be
        treated as the segment number zero (0).
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30089</srcid><srcstatus/><internalId>1202</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30090</srcid><srcstatus/><internalId>1203</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>855</internalId></specobject>

    <specobject>
      <id>CanTp.11290</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        - The SequenceNumber (SN) of the first ConsecutiveFrame that immediately
        follows the FirstFrame shall be set to one (1).
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30089</srcid><srcstatus/><internalId>1202</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30090</srcid><srcstatus/><internalId>1203</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>856</internalId></specobject>

    <specobject>
      <id>CanTp.11291</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        - The SequenceNumber (SN) shall be incremented by one (1) for each new
        ConsecutiveFrame (CF) that is transmitted during a segmented message
        transmission.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30089</srcid><srcstatus/><internalId>1202</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30090</srcid><srcstatus/><internalId>1203</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>857</internalId></specobject>

    <specobject>
      <id>CanTp.11292</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        - The SequenceNumber (SN) value shall not be affected by any FlowControl
        (FC) frame.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30093</srcid><srcstatus/><internalId>1210</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>858</internalId></specobject>

    <specobject>
      <id>CanTp.11293</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        - When the SequenceNumber (SN) reaches the value of fifteen (15), it shall
        wraparound and be set to zero (0) for the next ConsecutiveFrame (CF).
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30089</srcid><srcstatus/><internalId>1202</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30090</srcid><srcstatus/><internalId>1203</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>859</internalId></specobject>

    <specobject>
      <id>CanTp.11271</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        If a CF N_PDU message is received with an incorrect sequence number, then
        proper error handling shall take place in the network layer. The message
        reception shall be aborted, and the network layer shall make an
        N_USData.indication service call with the parameter N_Result =
        N_WRONG_SN to the adjacent upper layer.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30091</srcid><srcstatus/><internalId>1209</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>860</internalId></specobject>

    <specobject>
      <id>CanTp.11259</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        The FC N_PDU is identified by the flow-control protocol control
        information (FC N_PCI). The FC N_PDU instructs a sending network entity
        to start, stop or resume transmission of CF N_PDUs. It shall be sent by
        the receiving network layer entity to the sending network layer entity,
        when ready to receive more data, after correct reception of
        a) an FF N_PDU, or      
        b) the last CF N_PDU of a block of consecutive frames, if further
        consecutive frames need to be sent.
      </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.11268_1</srcid><srcstatus/><internalId>862</internalId></linkedfrom><linkedfrom><srcid>CanTp.11268_2</srcid><srcstatus/><internalId>863</internalId></linkedfrom><linkedfrom><srcid>CanTp.11268_3</srcid><srcstatus/><internalId>864</internalId></linkedfrom><linkedfrom><srcid>CanTp.11268_4</srcid><srcstatus/><internalId>865</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>861</internalId></specobject>

    <specobject>
      <id>CanTp.11268_1</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        The FC N_PDU is identified by the flow-control protocol control
        information (FC N_PCI).
      </description>
      <comment>
        How to test:
        Verify that the N_PCI contains the expected information to
        identify FC(CTS), FC(WT) and FC(OVFLW).
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30093</srcid><srcstatus/><internalId>1210</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30320</srcid><srcstatus/><internalId>1212</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30141</srcid><srcstatus/><internalId>1226</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.11259</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>861</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>862</internalId></specobject>

    <specobject>
      <id>CanTp.11268_2</id>
      <status>rejected</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        The FC N_PDU instructs a sending network entity to start, stop or
        resume transmission of CF N_PDUs.
      </description>
      <comment>
        This requirement is informational only.
        Rationale:
        This requirement provides an overview. If coverage of this topic is required,
        then additional requirements need to be defined.
      </comment>
      <!-- Old linkage dsn deleted -->
      <providescoverage>
        <provcov>
          <linksto>CanTp.11259</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>861</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>863</internalId></specobject>

    <specobject>
      <id>CanTp.11268_3</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        FC N_PDU shall be sent by the receiving network layer entity to the sending
        network layer entity, when ready to receive more data, after correct
        reception of an FF N_PDU
      </description>
      <needscoverage>
        <!-- Old linkage dsn deleted -->
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_RX_WAIT</srcid><srcstatus/><internalId>1192</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30085</srcid><srcstatus/><internalId>1208</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_CancelTx_WhileRx</srcid><srcstatus/><internalId>1346</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_N_Cr_CFReception</srcid><srcstatus/><internalId>1348</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.11259</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>861</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>864</internalId></specobject>

    <specobject>
      <id>CanTp.11268_4</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        FC N_PDU shall be sent by the receiving network layer entity to the sending
        network layer entity, when ready to receive more data, after correct
        reception of the last CF N_PDU of a block of consecutive frames, if further
        consecutive frames need to be sent.
      </description>
      <needscoverage>
        <!-- Old linkage dsn deleted -->
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30085</srcid><srcstatus/><internalId>1208</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_31109</srcid><srcstatus/><internalId>1421</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.11259</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>861</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>865</internalId></specobject>

    <specobject>
      <id>CanTp.11311</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        The FC N_PDU can also inform a sending network entity to pause
        transmission of CF N_PDUs during a segmented message transmission.
      </description>
      <needscoverage>
        <!-- Old linkage dsn deleted -->
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30320</srcid><srcstatus/><internalId>1212</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>866</internalId></specobject>

    <specobject>
      <id>CanTp.11312</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        The FC N_PDU can also inform a sending network entity to abort the
        transmission of a segmented message if the length information (FF_DL) in
        the FF N_PDU transmitted by the sending entity exceeds the buffer size of
        the receiving entity.
      </description>
      <needscoverage>
        <!-- Old linkage dsn deleted -->
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30086</srcid><srcstatus/><internalId>1224</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30141</srcid><srcstatus/><internalId>1226</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>867</internalId></specobject>

    <specobject>
      <id>CanTp.11112</id>
      <status>rejected</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        The following table provides an overview about the whole Flow Control
        Frame.
        Byte      normal addressing       extended addressing     mixed addressing
        0         0x30 + FS               N_TA                    N_AE
        1         BS                      0x30 + FS               0x30 + FS
        2         STmin                   BS                      BS
        3         [unused]                STmin                   STmin
        4         [unused]                [unused]                [unused]
        5         [unused]                [unused]                [unused]
        6         [unused]                [unused]                [unused]
        7         [unused]                [unused]                [unused]
      </description>
      <comment>
        This requirement is informational only.
        Rationale:
        This requirement provides an overview. If coverage of this topic is required,
        then additional requirements need to be defined.
      </comment>
      <!-- Old linkage dsn deleted -->
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>868</internalId></specobject>

    <specobject>
      <id>CanTp.11152</id>
      <status>rejected</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        The FlowControlFrame - byte 0:
              Bit   7       6       5       4       3       2       1       0
        Byte 0      0       0       1       1       FS      FS      FS      FS
      </description>
      <comment>
        This requirement is informational only.
        Rationale:
        This requirement provides an overview. If coverage of this topic is required,
        then additional requirements need to be defined.
      </comment>
      <!-- Old linkage dsn deleted -->
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>869</internalId></specobject>

    <specobject>
      <id>CanTp.11174</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        Parameter: FS - Flowstatus
        0x0 ContinueToSend (CTS)
        The FlowControl ContinueToSend parameter shall be encoded by setting the
        lower nibble of the N_PCI byte #1 to "0". It shall cause the sender to
        resume the sending of Consecutive frames. The meaning of this value is
        that the receiver is ready to receive a maximum of BS number of
        Consecutive frames.
      </description>
      <needscoverage>
        <!-- Old linkage dsn deleted -->
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30263</srcid><srcstatus/><internalId>1227</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>870</internalId></specobject>

    <specobject>
      <id>CanTp.11260</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        Parameter: FS - Flowstatus
        0x1 Wait (WT) The FlowControl Wait parameter shall be encoded by setting
        the lower nibble of the N_PCI byte #1 to "1". It shall cause the sender
        to continue to wait for a new FlowControl N_PDU and to restart its N_BS
        timer.
      </description>
      <needscoverage>
        <!-- Old linkage dsn deleted -->
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30289</srcid><srcstatus/><internalId>1213</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_N_Bs_FCWAIT</srcid><srcstatus/><internalId>1349</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>871</internalId></specobject>

    <specobject>
      <id>CanTp.11261</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        Parameter: FS - Flowstatus
        0x2 Overflow (OVFLW) The FlowControl Overflow parameter shall be encoded
        by setting the lower nibble of the N_PCI byte #1 to "2". It shall cause
        the sender to abort the transmission of a segmented message and make a
        N_USData.confirm service call with the parameter
        N_Result=N_BUFFER_OVFLW. This N_PCI FlowStatus parameter value is
        only allowed to be transmitted in the FlowControl N_PDU that follows the
        FirstFrame N_PDU and shall only be used in case the message length FF_DL
        of the received FirstFrame N_PDU exceeds the buffer size of the receiving
        entity.
      </description>
      <needscoverage>
        <!-- Old linkage dsn deleted -->
        <!-- Covered by requirement CanTp.11261_1 -->
        <!-- Covered by requirement CanTp.11261_2 -->
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.11261_1</srcid><srcstatus/><internalId>873</internalId></linkedfrom><linkedfrom><srcid>CanTp.11261_2</srcid><srcstatus/><internalId>874</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>872</internalId></specobject>

    <specobject>
      <id>CanTp.11261_1</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        Parameter: FS - Flowstatus
        0x2 Overflow (OVFLW) The FlowControl Overflow parameter shall be encoded
        by setting the lower nibble of the N_PCI byte #1 to "2". It shall cause
        the sender to abort the transmission of a segmented message and make a
        N_USData.confirm service call with the parameter
        N_Result=N_BUFFER_OVFLW.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30141</srcid><srcstatus/><internalId>1226</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.11261</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>872</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>873</internalId></specobject>

    <specobject>
      <id>CanTp.11261_2</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        Parameter: FS - Flowstatus
        0x2 Overflow (OVFLW) This N_PCI FlowStatus parameter value is
        only allowed to be transmitted in the FlowControl N_PDU that follows the
        FirstFrame N_PDU and shall only be used in case the message length FF_DL
        of the received FirstFrame N_PDU exceeds the buffer size of the receiving
        entity.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30086</srcid><srcstatus/><internalId>1224</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.11261</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>872</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>874</internalId></specobject>

    <specobject>
      <id>CanTp.11263</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        Parameter: FS - Flowstatus
        0x3 - 0xF reserved If an FC N_PDU message is received with an invalid
        (reserved) FS parameter value, then proper error handling shall take
        place in the network layer. The message transmission shall be aborted,
        and the network layer shall make an service call to the adjacent upper
        layer reporting the error.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30092</srcid><srcstatus/><internalId>1220</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>875</internalId></specobject>

    <specobject>
      <id>CanTp.11176</id>
      <status>rejected</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        The Consecutive Frame - byte 1 (BS - Blocksize):
              Bit   7       6       5       4       3       2       1       0
        Byte 0      BS      BS      BS      BS      BS      BS      BS      BS
      </description>
      <comment>
        This requirement is informational only.
        Rationale:
        This requirement provides an overview. If coverage of this topic is required,
        then additional requirements need to be defined.
      </comment>
      <!-- Old linkage dsn deleted -->
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>876</internalId></specobject>

    <specobject>
      <id>CanTp.11198</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        Parameter: BS - Blocksize
        0x0 The BlockSize (BS) parameter value zero (0)
        shall be used to indicate to the sender that no more FlowControl frames
        shall be sent during the transmission of the segmented message. The
        sending network layer entity shall send all remaining consecutive frames
        without any stop for further FlowControl frames from the receiving
        network layer entity.
      </description>
      <needscoverage>
        <!-- Old linkage dsn deleted -->
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30094</srcid><srcstatus/><internalId>1211</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>877</internalId></specobject>

    <specobject>
      <id>CanTp.11264</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        Parameter: BS - Blocksize
        0x1 - 0xFF This range of BlockSize (BS) parameter values shall be used to
        indicate to the sender the maximum number of consecutive frames that can
        be received without an intermediate FlowControl frame (FC) from the
        receiving network entity.
      </description>
      <needscoverage>
        <!-- Old linkage dsn deleted -->
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30093</srcid><srcstatus/><internalId>1210</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_BS_Limited</srcid><srcstatus/><internalId>1404</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>878</internalId></specobject>

    <specobject>
      <id>CanTp.11200</id>
      <status>rejected</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        The ConsecutiveFrame - byte 2 (STmin - Separation Time):
              Bit   7       6       5       4       3       2       1       0
        Byte 0      STmin   STmin   STmin   STmin   STmin   STmin   STmin   STmin
      </description>
      <comment>
        This requirement is informational only.
        Rationale:
        This requirement provides an overview. If coverage of this topic is required,
        then additional requirements need to be defined.
      </comment>
      <!-- Old linkage dsn deleted -->
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>879</internalId></specobject>

    <specobject>
      <id>CanTp.11222</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        Parameter: STmin - Separation Time
        0x0 - 0x7F The units of STmin in the range 00 hex - 7F hex are absolute
        milliseconds (ms).
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30485</srcid><srcstatus/><internalId>1214</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30095</srcid><srcstatus/><internalId>1215</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30295</srcid><srcstatus/><internalId>1390</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>880</internalId></specobject>

    <specobject>
      <id>CanTp.11269</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        Parameter: STmin - Separation Time
        0xF1 - 0xF9 The units of STmin in the range F1 hex - F9 hex are even 100
        microseconds (us), where parameter value F1 hex represents 100 us and
        parameter value F9 hex represents 900 us.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30486</srcid><srcstatus/><internalId>1216</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30096</srcid><srcstatus/><internalId>1217</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30296</srcid><srcstatus/><internalId>1391</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>881</internalId></specobject>

    <specobject>
      <id>CanTp.11270</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        Parameter: STmin - Separation Time
        0x80 - 0xF0 0xFA - 0xFF reserved If an FC N_PDU message is received with a
        reserved ST parameter value, then the sending network entity shall use
        the longest ST value specified by this part of ISO 15765 (7F hex - 127
        ms) instead of the value received from the receiving network entity for
        the duration of the ongoing segmented message transmission.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30323</srcid><srcstatus/><internalId>1218</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_InvalidSTmin</srcid><srcstatus/><internalId>1219</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30324</srcid><srcstatus/><internalId>1392</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_STmin_InvalidValue</srcid><srcstatus/><internalId>1596</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>882</internalId></specobject>

    <specobject>
      <id>CanTp.11282</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        The DLC is always set to 8. If the N_PDU to be transmitted is shorter than
        8 bytes, then the sender has to set the DLC to the maximum value 8
        (padding of unused data bytes). In particular this can be the case for an
        SF, FC frame or last CF of a segmented message.
      </description>
      <comment>
        Covered by CanTp.CanTp040
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30188</srcid><srcstatus/><internalId>1284</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>883</internalId></specobject>

    <specobject>
      <id>CanTp.11295</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        The DLC parameter of the CAN frame is set by the sender and read by the
        receiver to determine the number of data bytes per CAN frame to be
        processed by the network layer.
      </description>
      <needscoverage>
        <!-- Old linkage dsn deleted -->
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30188</srcid><srcstatus/><internalId>1284</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>884</internalId></specobject>

    <specobject>
      <id>CanTp.11283</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        The parameter cannot be used to determine the message length; this
        information shall be extracted from the N_PCI information in the
        beginning of a message.
      </description>
      <needscoverage>
        <!-- Old linkage dsn deleted -->
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30188</srcid><srcstatus/><internalId>1284</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30190</srcid><srcstatus/><internalId>1286</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>885</internalId></specobject>

    <specobject>
      <id>CanTp.11284</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        The DLC does not always need to be 8. If the N_PDU to be transmitted is
        shorter than 8 bytes, then the sender may optimize the CAN bus load by
        shortening the CAN frame data to only contain the number of bytes
        occupied by the N_PDU (no padding of unused data bytes).
      </description>
      <needscoverage>
        <!-- Old linkage dsn deleted -->
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30187</srcid><srcstatus/><internalId>1250</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>886</internalId></specobject>

    <specobject>
      <id>CanTp.11296</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        CAN frame data optimization can only be used for a SF, FC frame or last CF
        of a segmented message.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30056</srcid><srcstatus/><internalId>1200</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_30057</srcid><srcstatus/><internalId>1201</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>887</internalId></specobject>

    <specobject>
      <id>CanTp.11285</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        The parameter cannot be used to determine the message length; this
        information shall be extracted from the N_PCI information in the
        beginning of a message.
      </description>
      <needscoverage>
        <!-- Old linkage dsn deleted -->
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30189</srcid><srcstatus/><internalId>1260</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>888</internalId></specobject>

    <specobject>
      <id>CanTp.11287</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        Depending on the N_PCI value, the network layer can calculate the smallest
        expected value for the CAN DLC parameter in a received CAN frame.
      </description>
      <comment>
        Covered by CanTp.ASR40.SWS_CanTp_00098
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30325</srcid><srcstatus/><internalId>1287</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>889</internalId></specobject>

    <specobject>
      <id>CanTp.11288</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        The reception of a CAN frame with a DLC value smaller than expected (less
        than 8 for applications which pad the CAN frames or smaller than implied
        by the size of the network protocol data unit for optimized
        implementations) shall be ignored by the network layer without any
        further action.
      </description>
      <comment>
        Covered by CanTp.ASR40.SWS_CanTp_00098
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30200</srcid><srcstatus/><internalId>1261</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>890</internalId></specobject>

    <specobject>
      <id>CanTp.11230</id>
      <status>rejected</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        Figure TS_CANTP_11230.png shows the Timeouts N_As, N_Bs, N_Cs, N_Ar, N_Br,
        N_Cr during the transmission of a segmented message.
      </description>
      <comment>     
        This requirement is informational only.
        Rationale:
        This requirement provides an overview. If coverage of this topic is required,
        then additional requirements need to be defined.
        Please refer to figure TS_CANTP_11230.png.
      </comment>
      <!-- Old linkage dsn deleted -->
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>891</internalId></specobject>

    <specobject>
      <id>CanTp.11232</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        N_As:
        Time for transmission of the CAN frame on the sender side. - Timeout:
        1000ms (ISO 15765-4: 25ms)
        For CanTp it means the time from transmitting
        a N-PDU via CanIf_Transmit() until confirmation of the N-PDU via
        CanIf_TxConfirmation(). If the transmit confirmation is not received
        within N_As, CanTp shall act as it had received an unsuccessful
        transmission confirmation and the late confirmation shall be ignored.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30077</srcid><srcstatus/><internalId>1237</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_TimeoutFF</srcid><srcstatus/><internalId>1238</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>892</internalId></specobject>

    <specobject>
      <id>CanTp.11234</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        N_Bs:
        Time until reception of the next FlowControl N_PDU. - Timeout: 1000ms (ISO
        15765-4: 75ms)
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30100</srcid><srcstatus/><internalId>1239</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>893</internalId></specobject>

    <specobject>
      <id>CanTp.11236</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>2</version>
      <description>
        N_Cs:
        CanTpNcs is the time in which CanTp is allowed to request from PduR the Tx data of a Consecutive Frame N_PDU.
      </description>
      <comment>
        Covered by CanTp.CanTp185
        Note: For CanTp, this is used as a timeout, though: CanTp requests a buffer 
        (and continues sending) after STmin elapses and aborts if no buffer 
        is provided before N_Cs elapses.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30101</srcid><srcstatus/><internalId>1241</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_Ncs_SmallerThan_STmin</srcid><srcstatus/><internalId>1370</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>894</internalId></specobject>

    <specobject>
      <id>CanTp.11238</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        N_Ar:
        Time for transmission of the CAN frame on the receiver side. - Timeout:
        1000ms (ISO 15765-4: 25ms)
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30102</srcid><srcstatus/><internalId>1242</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_31109</srcid><srcstatus/><internalId>1421</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>895</internalId></specobject>

    <specobject>
      <id>CanTp.11240</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        N_Br:
        Time until transmission of the next FlowControl N_PDU. Performance
        requirement: (N_Br + N_Ar) &amp;amp;lt; (0.9 * N_Bs timeout)
      </description>
      <comment>
        Note: this is not a timeout, but the minimum time!
        See Deviation: Flow control frames are sent immediately without respecting timeout N_Br
      </comment>
      <needscoverage>
        <!-- Requirement covered by CanTp.SWS_CanTp_00222 -->
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.SWS_CanTp_00222</srcid><srcstatus/><internalId>169</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>896</internalId></specobject>

    <specobject>
      <id>CanTp.11242</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        N_Cr:
        Time until transmission of the next ConsecutiveFrame N_PDU. - Timeout:
        1000ms (ISO 15765-4: 150ms)
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_30104</srcid><srcstatus/><internalId>1244</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>897</internalId></specobject>

    <specobject>
      <id>CanTp.ISO2004.UnexpectedCF</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        If reception is in progress and a CF was received:
        If awaited, process the CF N_PDU in the on-going reception and perform
        the required checks (e.g. SN in right order),
        otherwise ignore it.
      </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp.ISO2004.UnexpectedCF_1</srcid><srcstatus/><internalId>899</internalId></linkedfrom><linkedfrom><srcid>CanTp.ISO2004.UnexpectedCF_2</srcid><srcstatus/><internalId>900</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>898</internalId></specobject>

    <specobject>
      <id>CanTp.ISO2004.UnexpectedCF_1</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        If reception is in progress and a CF was received:
        If awaited, process the CF N_PDU in the on-going reception and perform
        the required checks (e.g. SN in right order).
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_CF_PduRInvalidReturn</srcid><srcstatus/><internalId>1359</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_ZeroBrForBlockLF</srcid><srcstatus/><internalId>1373</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_31102</srcid><srcstatus/><internalId>1415</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ISO2004.UnexpectedCF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>898</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>899</internalId></specobject>

    <specobject>
      <id>CanTp.ISO2004.UnexpectedCF_2</id>
      <status>approved</status>
      <source>ISO 15765-2:2004(E)</source>
      <version>1</version>
      <description>
        If reception is in progress and a CF was received:
        If not awaited, ignore it.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_ZeroBrForBlockLF</srcid><srcstatus/><internalId>1373</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ISO2004.UnexpectedCF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>898</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>900</internalId></specobject>

    <specobject>
      <id>CanTp.ISO2016.DynamicStminBS</id>
      <status>approved</status>
      <source>ISO 15765-2:2016(E)</source>
      <version>1</version>
      <description>
        If the client is the sender of a segmented data transmission
        (i.e. the receiver of the FlowControl frame), shall adjust to the values of BS and STmin
        from each FC (CTS) received during the same segmented data transmission.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanTp_RxIndication.c_1805</srcid><srcstatus/><internalId>1035</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_DynamicStminBS_GptTicks</srcid><srcstatus/><internalId>1194</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_DynamicStminBS_MainFunctionTicks</srcid><srcstatus/><internalId>1195</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>901</internalId></specobject>
    
    <specobject>
      <id>CanTp.ISO2016.InvalidFF_DL</id>
      <status>approved</status>
      <source>ISO 15765-2:2016(E)</source>
      <version>1</version>
      <description>
        If a FirstFrame is received with the escape sequence (where all bits of the lower nibble of PCI byte 1 and
        all bits of PCI byte 2 are set to 0’s) and the FF_DL less or equal to 4095, then the network layer shall ignore the FF
        N_PDU and not transmit an FC N_PDU.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanTp_RxIndication.c_1261</srcid><srcstatus/><internalId>1034</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest09013_CanFD_Rx_Multiframe</srcid><srcstatus/><internalId>1153</internalId></linkedfrom><linkedfrom><srcid>CanTp_ConTest09014_CanFD_Rx_InvalidSize</srcid><srcstatus/><internalId>1154</internalId></linkedfrom><linkedfrom><srcid>CanTp_ConTest09001_CAN_FD_SWS_CanTp_00344_00345_00346</srcid><srcstatus/><internalId>1157</internalId></linkedfrom><linkedfrom><srcid>CanTp_ConTest12_007_InvalidRxLength_CANTP_ON_CAN_CAN_FD_CAN20_frames</srcid><srcstatus/><internalId>1174</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_1</srcid><srcstatus/><internalId>1643</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_3</srcid><srcstatus/><internalId>1645</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>902</internalId></specobject>
    
    <specobject>
      <id>CanTp.ISO2016.SF_DL_Standard_12</id>
      <status>approved</status>
      <source>ISO 15765-2:2016(E)</source>
      <version>1</version>
      <description>
        When a Single Frame with addressing type set as Normal/Standard is received and CAN_DL value 12,
        SF_DL should be greater or equal than 8 and smaller or equal than 10.(table 13)
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest09031_Rx_SF_CAN_20_CANFD_EXTENDED_STANDARD_CanIdType</srcid><srcstatus/><internalId>1155</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>903</internalId></specobject>
    
    <specobject>
      <id>CanTp.ISO2016.SF_DL_Standard_16</id>
      <status>approved</status>
      <source>ISO 15765-2:2016(E)</source>
      <version>1</version>
      <description>
        When a Single Frame with addressing type set as Normal/Standard is received and CAN_DL value 16,
        SF_DL should be greater or equal than 11 and smaller or equal than 14.(table 13)
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest09031_Rx_SF_CAN_20_CANFD_EXTENDED_STANDARD_CanIdType</srcid><srcstatus/><internalId>1155</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>904</internalId></specobject>
    
    <specobject>
      <id>CanTp.ISO2016.SF_DL_Standard_20</id>
      <status>approved</status>
      <source>ISO 15765-2:2016(E)</source>
      <version>1</version>
      <description>
        When a Single Frame with addressing type set as Normal/Standard is received and CAN_DL value 20,
        SF_DL should be greater or equal than 15 and smaller or equal than 18.(table 13)
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest09031_Rx_SF_CAN_20_CANFD_EXTENDED_STANDARD_CanIdType</srcid><srcstatus/><internalId>1155</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>905</internalId></specobject>
    
    <specobject>
      <id>CanTp.ISO2016.SF_DL_Standard_24</id>
      <status>approved</status>
      <source>ISO 15765-2:2016(E)</source>
      <version>1</version>
      <description>
        When a Single Frame with addressing type set as Normal/Standard is received and CAN_DL value 24,
        SF_DL should be greater or equal than 19 and smaller or equal than 22.(table 13)
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest09031_Rx_SF_CAN_20_CANFD_EXTENDED_STANDARD_CanIdType</srcid><srcstatus/><internalId>1155</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>906</internalId></specobject>
    
    <specobject>
      <id>CanTp.ISO2016.SF_DL_Standard_32</id>
      <status>approved</status>
      <source>ISO 15765-2:2016(E)</source>
      <version>1</version>
      <description>
        When a Single Frame with addressing type set as Normal/Standard is received and CAN_DL value 32,
        SF_DL should be greater or equal than 23 and smaller or equal than 30.(table 13)
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest09031_Rx_SF_CAN_20_CANFD_EXTENDED_STANDARD_CanIdType</srcid><srcstatus/><internalId>1155</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>907</internalId></specobject>
    
    <specobject>
      <id>CanTp.ISO2016.SF_DL_Standard_48</id>
      <status>approved</status>
      <source>ISO 15765-2:2016(E)</source>
      <version>1</version>
      <description>
        When a Single Frame with addressing type set as Normal/Standard is received and CAN_DL value 48,
        SF_DL should be greater or equal than 31 and smaller or equal than 46.(table 13)
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest09031_Rx_SF_CAN_20_CANFD_EXTENDED_STANDARD_CanIdType</srcid><srcstatus/><internalId>1155</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>908</internalId></specobject>
    
    <specobject>
      <id>CanTp.ISO2016.SF_DL_Standard_64</id>
      <status>approved</status>
      <source>ISO 15765-2:2016(E)</source>
      <version>1</version>
      <description>
        When a Single Frame with addressing type set as Normal/Standard is received and CAN_DL value 64,
        SF_DL should be greater or equal than 47 and smaller or equal than 62.(table 13)
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest09031_Rx_SF_CAN_20_CANFD_EXTENDED_STANDARD_CanIdType</srcid><srcstatus/><internalId>1155</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00231_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>355</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>909</internalId></specobject>
    
    <specobject>
      <id>CanTp.ISO2016.SF_DL_ExtendedMixed_12</id>
      <status>approved</status>
      <source>ISO 15765-2:2016(E)</source>
      <version>1</version>
      <description>
        When a Single Frame with addressing type set as Extended or Mixed is received and CAN_DL value 12,
        SF_DL should be greater or equal than 7 and smaller or equal than 9.(table 13)
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest09010_CanFD_Rx_SF</srcid><srcstatus/><internalId>1151</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>910</internalId></specobject>
    
    <specobject>
      <id>CanTp.ISO2016.SF_DL_ExtendedMixed_16</id>
      <status>approved</status>
      <source>ISO 15765-2:2016(E)</source>
      <version>1</version>
      <description>
        When a Single Frame with addressing type set as Extended or Mixed is received and CAN_DL value 16,
        SF_DL should be greater or equal than 10 and smaller or equal than 13.(table 13)
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest09010_CanFD_Rx_SF</srcid><srcstatus/><internalId>1151</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>911</internalId></specobject>
    
    <specobject>
      <id>CanTp.ISO2016.SF_DL_ExtendedMixed_20</id>
      <status>approved</status>
      <source>ISO 15765-2:2016(E)</source>
      <version>1</version>
      <description>
        When a Single Frame with addressing type set as Extended or Mixed is received and CAN_DL value 20,
        SF_DL should be greater or equal than 14 and smaller or equal than 17.(table 13)
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest09010_CanFD_Rx_SF</srcid><srcstatus/><internalId>1151</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>912</internalId></specobject>
    
    <specobject>
      <id>CanTp.ISO2016.SF_DL_ExtendedMixed_24</id>
      <status>approved</status>
      <source>ISO 15765-2:2016(E)</source>
      <version>1</version>
      <description>
        When a Single Frame with addressing type set as Extended or Mixed is received and CAN_DL value 24,
        SF_DL should be greater or equal than 18 and smaller or equal than 21.(table 13)
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest09010_CanFD_Rx_SF</srcid><srcstatus/><internalId>1151</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>913</internalId></specobject>
    
    <specobject>
      <id>CanTp.ISO2016.SF_DL_ExtendedMixed_32</id>
      <status>approved</status>
      <source>ISO 15765-2:2016(E)</source>
      <version>1</version>
      <description>
        When a Single Frame with addressing type set as Extended or Mixed is received and CAN_DL value 32,
        SF_DL should be greater or equal than 22 and smaller or equal than 29.(table 13)
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest09010_CanFD_Rx_SF</srcid><srcstatus/><internalId>1151</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>914</internalId></specobject>
    
    <specobject>
      <id>CanTp.ISO2016.SF_DL_ExtendedMixed_48</id>
      <status>approved</status>
      <source>ISO 15765-2:2016(E)</source>
      <version>1</version>
      <description>
        When a Single Frame with addressing type set as Extended or Mixed is received and CAN_DL value 48,
        SF_DL should be greater or equal than 330 and smaller or equal than 45.(table 13)
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest09010_CanFD_Rx_SF</srcid><srcstatus/><internalId>1151</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>915</internalId></specobject>
    
    <specobject>
      <id>CanTp.ISO2016.SF_DL_ExtendedMixed_64</id>
      <status>approved</status>
      <source>ISO 15765-2:2016(E)</source>
      <version>1</version>
      <description>
        When a Single Frame with addressing type set as Extended or Mixed is received and CAN_DL value 64,
        SF_DL should be greater or equal than 46 and smaller or equal than 61.(table 13)
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_ConTest09010_CanFD_Rx_SF</srcid><srcstatus/><internalId>1151</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>916</internalId></specobject>

  </specobjects>
    <specobjects doctype="swurs">

      <specobject>
         <id>CanTp.JTM_0000</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        The Jump Table Module must provide a jump table.
      </description>
         <comment>
        Note: Jump Table Module = jump table server
        Note: jump table = CanTp_EntryTable
        Source: BMW Software Specification, Jump Table Module, Revision 1.1.0, 15.11.2007.
      </comment>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_40074</srcid><srcstatus/><internalId>1624</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>917</internalId></specobject>

      <specobject>
         <id>CanTp.JTM_0001</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        All APIs of the Jump Table Module shall be accessible via the jump table.
      </description>
         <comment>
        Note: Jump Table Module = jump table server
        Note: jump table = CanTp_EntryTable
        Source: BMW Software Specification, Jump Table Module, Revision 1.1.0, 15.11.2007.
      </comment>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_40073</srcid><srcstatus/><internalId>1623</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_40074</srcid><srcstatus/><internalId>1624</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_40075</srcid><srcstatus/><internalId>1625</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_40079</srcid><srcstatus/><internalId>1628</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_40090</srcid><srcstatus/><internalId>1687</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_40115</srcid><srcstatus/><internalId>1702</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_40116</srcid><srcstatus/><internalId>1703</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_40118</srcid><srcstatus/><internalId>1704</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_40119</srcid><srcstatus/><internalId>1705</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_40121</srcid><srcstatus/><internalId>1706</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>918</internalId></specobject>

      <specobject>
         <id>CanTp.JTM_0002</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        The Jump Table Module shall provide an external interface for other
        applications.
      </description>
         <comment>
        The jump table client shall exist and provide all regular CanTp APIs to the application.
        Note: External interface = jump table client
        Note: Jump Table Module = jump table server
        Source: BMW Software Specification, Jump Table Module, Revision 1.1.0, 15.11.2007.
      </comment>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_49040_1</srcid><srcstatus/><internalId>1101</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_49046</srcid><srcstatus/><internalId>1116</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_49034</srcid><srcstatus/><internalId>1654</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_49036</srcid><srcstatus/><internalId>1655</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_49038</srcid><srcstatus/><internalId>1656</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_49040</srcid><srcstatus/><internalId>1657</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>919</internalId></specobject>

      <specobject>
         <id>CanTp.JTM_0003</id>
         <status>rejected</status>
         <source>EB</source>
         <version>1</version>
         <description>
        A separate section in the flash memory must be reserved for the Jump Table
        (JumpTableSection).
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        This requirement is for the integrator and not for the module development.
        Note: JumpTableSection = Rom space for CanTp_EntryTable
        The position of CanTp_EntryTable must be equal in application and bootloader.
        Source: BMW Software Specification, Jump Table Module, Revision 1.1.0, 15.11.2007.
      </comment>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>920</internalId></specobject>

      <specobject>
         <id>CanTp.JTM_0004</id>
         <status>rejected</status>
         <source>EB</source>
         <version>1</version>
         <description>
        The Jump Table must be located at the start address of the
        JumpTableSection.
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        This requirement is for the integrator and not for the module development.
        Note: JumpTableSection = CanTp_EntryTable in ROM
        The position of CanTp_EntryTable can be defined by the configuration parameter
        as:modconf('CanTp')[1]/CanTpJumpTable/CanTpJumpTableAddress.
        Source: BMW Software Specification, Jump Table Module, Revision 1.1.0, 15.11.2007.
      </comment>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>921</internalId></specobject>

      <specobject>
         <id>CanTp.JTM_0005</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        The Jump Table shall be defined as a structure.
      </description>
         <comment>
        Note: Jump Table = CanTp_EntryTable
        Source: BMW Software Specification, Jump Table Module, Revision 1.1.0, 15.11.2007.
      </comment>
         <needscoverage>
            <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/include/CanTp_EntryTableTypes.h_21</srcid><srcstatus/><internalId>996</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>922</internalId></specobject>

      <specobject>
         <id>CanTp.JTM_0006</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        The members of the Jump Table structure shall be constant pointers to
        functions.
      </description>
         <comment>
        Since the whole CanTp_EntryTable is constant all member are constant.
        Note: Jump Table = CanTp_EntryTable
        Source: BMW Software Specification, Jump Table Module, Revision 1.1.0, 15.11.2007.
      </comment>
         <needscoverage>
            <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/src/CanTp_EntryTable.c_46</srcid><srcstatus/><internalId>1001</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>923</internalId></specobject>

      <specobject>
         <id>CanTp.JTM_0007</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        The external interface of the Jump Table Module must know the address of
        the JumpTableSection.
      </description>
         <comment>
        Note: JumpTableSection = CanTp_EntryTable in ROM
        The position of CanTp_EntryTable can be defined by the configuration parameter
        as:modconf('CanTp')[1]/CanTpJumpTable/CanTpJumpTableAddress.
        Source: BMW Software Specification, Jump Table Module, Revision 1.1.0, 15.11.2007.
      </comment>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_40090</srcid><srcstatus/><internalId>1687</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_40091</srcid><srcstatus/><internalId>1688</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_40093</srcid><srcstatus/><internalId>1689</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_40094</srcid><srcstatus/><internalId>1690</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_40095</srcid><srcstatus/><internalId>1691</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_40096</srcid><srcstatus/><internalId>1692</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_40097</srcid><srcstatus/><internalId>1693</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_40098</srcid><srcstatus/><internalId>1694</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_40109</srcid><srcstatus/><internalId>1695</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_40110</srcid><srcstatus/><internalId>1696</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_40111_ChangeParameter</srcid><srcstatus/><internalId>1697</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_40111_ReadParameter</srcid><srcstatus/><internalId>1698</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_40112</srcid><srcstatus/><internalId>1701</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations><ruleid>WRN.swuts.needscoverage.count</ruleid></oreqmViolations><covstatus>covered</covstatus><internalId>924</internalId></specobject>

      <specobject>
         <id>CanTp.JTM_0008</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        The external interface of the Jump Table Module must know the structure of
        the Jump Table.
      </description>
         <comment>
        The type of CanTp_EntryTable must be equal for both CanTp jump table server and client.
        Note: Jump Table = CanTp_EntryTable
        Source: BMW Software Specification, Jump Table Module, Revision 1.1.0, 15.11.2007.
      </comment>
         <needscoverage>
            <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/include/CanTp_EntryTableTypes.h_21</srcid><srcstatus/><internalId>996</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>925</internalId></specobject>

      <specobject>
         <id>CanTp.JTM_0009</id>
         <status>rejected</status>
         <source>EB</source>
         <version>1</version>
         <description>
        All applications that use the Jump Table Module must reserve the same
        flash area for the JumpTableSection.
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        This is a requirement for integrator and not for the module development.
        Note: JumpTableSection = CanTp_EntryTable in ROM
        This is only relevant for all jump table clients. If only the server is used
        (e.g. bootloader) there is no need for a CanTp_EntryTable.
        Source: BMW Software Specification, Jump Table Module, Revision 1.1.0, 15.11.2007.
      </comment>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>926</internalId></specobject>

      <specobject>
         <id>CanTp.JTM_0010</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        The Jump Table Module must provide a callback jump table.
      </description>
         <comment>
        Both client and server shall provide a exit jump table.
        Note: Jump Table Module = jump table server
        Note: callback jump table = CanTp_ExitTable
        Source: BMW Software Specification, Jump Table Module, Revision 1.1.0, 15.11.2007.
      </comment>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_40074</srcid><srcstatus/><internalId>1624</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>927</internalId></specobject>

      <specobject>
         <id>CanTp.JTM_0011</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        All callback functions called by the Jump Table Module shall be accessible
        via the jump table.
      </description>
         <comment>
        With the "jump table" in this requirement, the callback jump table (or in
        EB notation the exit jump table) is meant.
        Source: BMW Software Specification, Jump Table Module, Revision 1.1.0, 15.11.2007.
      </comment>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_49042</srcid><srcstatus/><internalId>1117</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_49044</srcid><srcstatus/><internalId>1118</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_40073</srcid><srcstatus/><internalId>1623</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_40074</srcid><srcstatus/><internalId>1624</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_40075</srcid><srcstatus/><internalId>1625</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_40076</srcid><srcstatus/><internalId>1626</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_40077</srcid><srcstatus/><internalId>1627</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_40079</srcid><srcstatus/><internalId>1628</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_40080</srcid><srcstatus/><internalId>1629</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_40081</srcid><srcstatus/><internalId>1630</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_40083</srcid><srcstatus/><internalId>1631</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_40084</srcid><srcstatus/><internalId>1632</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_40085</srcid><srcstatus/><internalId>1633</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_40088</srcid><srcstatus/><internalId>1634</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_40100</srcid><srcstatus/><internalId>1635</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_49030</srcid><srcstatus/><internalId>1652</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_49032</srcid><srcstatus/><internalId>1653</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_40118</srcid><srcstatus/><internalId>1704</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_40119</srcid><srcstatus/><internalId>1705</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_40123</srcid><srcstatus/><internalId>1707</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_40124</srcid><srcstatus/><internalId>1708</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations><ruleid>WRN.swuts.needscoverage.count</ruleid></oreqmViolations><covstatus>covered</covstatus><internalId>928</internalId></specobject>

      <specobject>
         <id>CanTp.JTM_0012</id>
         <status>rejected</status>
         <source>EB</source>
         <version>1</version>
         <description>
        The Jump Table Module shall provide a callback interface.
      </description>
         <comment>
        This requirement is not applicable.
        Rationale:
        The jump table server shall call the upper layer APIs directly via exit table. There is no
        "callback interface" required for this task.
        Note: Jump Table Module = jump table server
        Source: BMW Software Specification, Jump Table Module, Revision 1.1.0, 15.11.2007.
      </comment>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>929</internalId></specobject>

      <specobject>
         <id>CanTp.JTM_0013</id>
         <status>rejected</status>
         <source>EB</source>
         <version>1</version>
         <description>
        A separate section in the flash memory must be reserved for the Callback
        Jump Table (CallbackJumpTableSection)
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        This requirement is for the integrator and not for the module development.
        Note: CallbackJumpTableSection = CanTp_ExitTable in ROM
        The content of CanTp_ExitTable in application and bootloader can be different but the
        position must be equal.
        Source: BMW Software Specification, Jump Table Module, Revision 1.1.0, 15.11.2007.
      </comment>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>930</internalId></specobject>

      <specobject>
         <id>CanTp.EB.JTM_11579</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        The location of the callback jump table shall be registered before the
        call of the jump table module's initialization function.
      </description>
         <comment>
        Note: callback jump table = CanTp_ExitTable
        The registration shall be done at start up.
      </comment>
         <needscoverage>
            <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/src/CanTp_Cfg.c_81</srcid><srcstatus/><internalId>1000</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>931</internalId></specobject>

      <specobject>
         <id>CanTp.JTM_0014</id>
         <status>rejected</status>
         <source>EB</source>
         <version>1</version>
         <description>
        The Callback Jump Table must be located at the start address of the
        Callback-JumpTableSection.
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        This requirement is for the integrator and not for the module development.
        Note: CallbackJumpTableSection = CanTp_ExitTable in ROM
        The position of CanTp_ExitTable will be defined at start up code only.
        Source: BMW Software Specification, Jump Table Module, Revision 1.1.0, 15.11.2007.
      </comment>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>932</internalId></specobject>

      <specobject>
         <id>CanTp.JTM_0015</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        The Callback Jump Table shall be defined as a structure.
      </description>
         <comment>
        Note: Callback Jump Table = CanTp_ExitTable
        Source: BMW Software Specification, Jump Table Module, Revision 1.1.0, 15.11.2007.
      </comment>
         <needscoverage>
            <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/include/CanTp_ExitTableTypes.h_42</srcid><srcstatus/><internalId>997</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>933</internalId></specobject>

      <specobject>
         <id>CanTp.JTM_0016</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        The members of the Callback Jump Table structure shall be constant
        pointers to functions.
      </description>
         <comment>
        Since the whole CanTp_ExitTable is constant all member are constant.
        Note: Callback Jump Table = CanTp_ExitTable
        Source: BMW Software Specification, Jump Table Module, Revision 1.1.0, 15.11.2007.
      </comment>
         <needscoverage>
            <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/src/CanTp_ExitTable.c_31</srcid><srcstatus/><internalId>1003</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>934</internalId></specobject>

      <specobject>
         <id>CanTp.JTM_0017</id>
         <status>rejected</status>
         <source>EB</source>
         <version>1</version>
         <description>
        The callback interface of the Jump Table Module must know the address of
        the CallbackJumpTableSection.
      </description>
         <comment>
        This requirement is not applicable.
        Rationale:
        The jump table server shall call the upper layer APIs directly via exit table. There is no
        "callback interface" required for this task.
        Note: External interface = jump table client
        Note: Callback interface = is not required
        Note: Jump Table Module = jump table server
        Source: BMW Software Specification, Jump Table Module, Revision 1.1.0, 15.11.2007.
      </comment>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>935</internalId></specobject>

      <specobject>
         <id>CanTp.JTM_0018</id>
         <status>rejected</status>
         <source>EB</source>
         <version>1</version>
         <description>
        The callback interface of the Jump Table Module must know the structure of
        the Callback Jump Table.
      </description>
         <comment>
        This requirement is not applicable.
        Rationale:
        The jump table server shall call the upper layer APIs directly via exit table. There is no
        "callback interface" required for this task.
        Note: External interface = jump table client
        Note: Callback interface = is not required
        Note: Jump Table Module = jump table server
        Source: BMW Software Specification, Jump Table Module, Revision 1.1.0, 15.11.2007.
      </comment>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>936</internalId></specobject>

      <specobject>
         <id>CanTp.JTM_0019</id>
         <status>rejected</status>
         <source>EB</source>
         <version>1</version>
         <description>
        All applications that use the Jump Table Module must reserve the same
        flash area for the CallbackJumpTableSection.
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        This requirement is for the integrator and not for the module development.
        Note: CallbackJumpTableSection = CanTp_ExitTable in ROM
        The content of CanTp_ExitTable in application and bootloader can be different but the
        position must be equal.
        Source: BMW Software Specification, Jump Table Module, Revision 1.1.0, 15.11.2007.
      </comment>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>937</internalId></specobject>

      <specobject>
         <id>CanTp.JTM_0020</id>
         <status>rejected</status>
         <source>EB</source>
         <version>1</version>
         <description>
        Separate sections in the RAM must be reserved for global variables of the
        Jump Table Module (GlobalVariableSections).
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        This requirement is for the integrator and not for the module development.
        Each Autosar module has its own memory sections according to the memory
        mapping SWS. The integrator must make sure, that they are correctly used.
        Note: Jump Table Module = jump table server
        Note: GlobalVariableSections = Ram sections shared by jump table client and server
        Source: BMW Software Specification, Jump Table Module, Revision 1.1.0, 15.11.2007.
      </comment>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>938</internalId></specobject>

      <specobject>
         <id>CanTp.JTM_0021</id>
         <status>rejected</status>
         <source>EB</source>
         <version>1</version>
         <description>
        All global variables of the Jump Table Module must be located to the
        respective global variable sections.
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        This requirement is for the integrator and not for the module development.
        Each Autosar module has its own memory sections according to the memory
        mapping SWS. The integrator must make sure, that they are correctly used.
        Note: Jump Table Module = jump table server
        Note: GlobalVariableSections = Ram sections shared by jump table client and server
        Source: BMW Software Specification, Jump Table Module, Revision 1.1.0, 15.11.2007.
      </comment>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>939</internalId></specobject>

      <specobject>
         <id>CanTp.JTM_0022</id>
         <status>rejected</status>
         <source>EB</source>
         <version>1</version>
         <description>
        The external interface of the Jump Table Module must know the addresses of
        the global variable sections.
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        This requirement is for the integrator and not for the module development.
        The shared RAM must be accessible by both jump table client and server.
        Source: BMW Software Specification, Jump Table Module, Revision 1.1.0, 15.11.2007.
      </comment>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>940</internalId></specobject>

      <specobject>
         <id>CanTp.JTM_0023</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        The external interface of the Jump Table Module must know the structure of
        the global variables.
      </description>
         <comment>
        All shared global variables must be equal for jump table client and server.
        Source: BMW Software Specification, Jump Table Module, Revision 1.1.0, 15.11.2007.
      </comment>
         <needscoverage>
            <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/src/CanTp_Cfg.c_81</srcid><srcstatus/><internalId>1000</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>941</internalId></specobject>

      <specobject>
         <id>CanTp.JTM_0024</id>
         <status>rejected</status>
         <source>EB</source>
         <version>1</version>
         <description>
        All applications that use the Jump Table Module must reserve the same RAM
        areas for the global variable sections.
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        This requirement is for the integrator and not for the module development.
        Note: section = GlobalVariableSections = Ram sections shared by jump table client and server
        The shared RAM must be at the same position for all used applications.
        Source: BMW Software Specification, Jump Table Module, Revision 1.1.0, 15.11.2007.
      </comment>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>942</internalId></specobject>

      <specobject>
         <id>CanTp.JTM_0025</id>
         <status>rejected</status>
         <source>EB</source>
         <version>1</version>
         <description>
        Each section shall contain only one object.
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        This requirement is for the integrator and not for the module development.
        Note: one object = one struct
        Note: section = GlobalVariableSections = Ram sections shared by jump table client and server
        Source: BMW Software Specification, Jump Table Module, Revision 1.1.0, 15.11.2007.
      </comment>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>943</internalId></specobject>

      <specobject>
         <id>CanTp.JTM_0026</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        The jump table module must not use static variables in functions.
        Source: BMW Software Specification, Jump Table Module, Revision 1.1.0, 15.11.2007.
      </description>
         <needscoverage>
            <needscov><needsobj>man</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_Manual_InterruptCallable</srcid><srcstatus/><internalId>951</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>944</internalId></specobject>

      <specobject>
         <id>CanTp.JTM_0027</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        The Jump Table Module must provide an initialisation function.
      </description>
         <comment>
        Note: Jump Table Module = jump table server
        Source: BMW Software Specification, Jump Table Module, Revision 1.1.0, 15.11.2007.
      </comment>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_40075</srcid><srcstatus/><internalId>1625</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>945</internalId></specobject>

      <specobject>
         <id>CanTp.JTM_0028</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        All global variables of the jump table module must be initialized by the
        initialisation function.
      </description>
         <comment>
         Source: BMW Software Specification, Jump Table Module, Revision 1.1.0, 15.11.2007.
      </comment>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_40115</srcid><srcstatus/><internalId>1702</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_40121</srcid><srcstatus/><internalId>1706</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>946</internalId></specobject>

      <specobject>
         <id>CanTp.JTM_0029</id>
         <status>rejected</status>
         <source>EB</source>
         <version>1</version>
         <description>
        The initialisation function of the jump table module must be called before
        any other call of the module.
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        This is a requirement for the application, not for the jump table module.
        Source: BMW Software Specification, Jump Table Module, Revision 1.1.0, 15.11.2007.
      </comment>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>947</internalId></specobject>

      <specobject>
         <id>CanTp.JTM_0030</id>
         <status>rejected</status>
         <source>EB</source>
         <version>1</version>
         <description>
        Equivalent macros must have the same value.
      </description>
         <comment>
        This requirement is not applicable.
        Rationale:
        Macros shall not be shared between jump table server and jump table client.
        Source: BMW Software Specification, Jump Table Module, Revision 1.1.0, 15.11.2007.
      </comment>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>948</internalId></specobject>

      <specobject>
         <id>CanTp.JTM_0031</id>
         <status>rejected</status>
         <source>EB</source>
         <version>1</version>
         <description>
        The compiler shall not change the order of the members of a structure.
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        This is a requirement for the compiler, not for the jump table module.
        Source: BMW Software Specification, Jump Table Module, Revision 1.1.0, 15.11.2007.
      </comment>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>949</internalId></specobject>

      <specobject>
         <id>CanTp.JTM_0032</id>
         <status>rejected</status>
         <source>EB</source>
         <version>1</version>
         <description>
        The compiler shall not remove members of a structure for optimization.
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        This is a requirement for the compiler, not for the jump table module.
        Source: BMW Software Specification, Jump Table Module, Revision 1.1.0, 15.11.2007.
      </comment>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>950</internalId></specobject>

  </specobjects>
    <specobjects doctype="man">

    <specobject>
      <id>TS_CANTP_Manual_InterruptCallable</id>
      <status>approved</status>
      <source>EB manual test</source>
      <version>1</version>
      <description>
        Test Description:
        Check that CanTp_TxConfirmation and CanTp_RxIndication are callable from interrupt context.

        Test Precondition:

        Test Execution:
        Code review.
        All test steps are required to fulfil CanTp.SWS_CanTp_00235 and CanTp.SWS_CanTp_00236.
        01: VP(CanTp.JTM_0026):
            Search the source code for "STATIC" and "static" and verify that no static
            variable exists in a function.
        02: VP(CanTp.SWS_CanTp_00235):
            Check that no Os calls apart from locking (via SchM's Enter/Exit calls) are used within
            CanTp_RxIndication and its sub functions.
        03: VP(CanTp.SWS_CanTp_00236):
            Check that no Os calls apart from locking (via SchM's Enter/Exit calls) are used within
            CanTp_TxConfirmation and its sub functions.
      </description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00235</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>398</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00236</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>401</internalId></provcov>
        <provcov>
          <linksto>CanTp.JTM_0026</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>944</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>951</internalId></specobject>

    <specobject>
      <id>TS_CANTP_Manual_CanTpHeaderFile</id>
      <status>approved</status>
      <source>EB manual test</source>
      <version>1</version>
      <description>
        Test Description:
        The file CanTp.h shall only contain 'external' declarations of constants, global
        data, type definitions and services that are specified in the CAN
        Transport Protocol SWS. (BSW00302)

        Test Precondition:

        Test Execution:
        Code review.
        All test steps are required to fulfil CanTp.ASR40.SWS_CanTp_00157.
        It is only required to check CanTp module header files.
        01: Check that CanTp.h and all included CanTp_*.h only contain declarations of constants
            required for the external usage outside of the module.
        02: Check that CanTp.h and all included CanTp_*.h only contain declarations of global data
            required for the external usage outside of the module.
        03: VP(SWS_CanTp_00296):
            Check that CanTp.h and all included CanTp_*.h only contain type definitions
            required for the external usage outside of the module.
        04: Check that CanTp.h and all included CanTp_*.h only contain services (APIs)
            required for the external usage outside of the module.
      </description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00157</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>6</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00296</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>341</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>952</internalId></specobject>

    <specobject>
      <id>TS_CANTP_Manual_GlobalVariables</id>
      <status>approved</status>
      <source>EB manual test</source>
      <version>1</version>
      <description>
        Test Description:
        	The CanTp module shall not define global data in header files (If global variables
        	have to be used, the definition should take place in the C file)

        Test Precondition:

        Test Execution:
        Code review.
        All test steps are required to fulfil CanTp.ASR40.SWS_CanTp_00155.
        01: Search for the string " VAR(" in the whole module source code.
            Note: Use a space in front of "VAR" to get an accurate search result.
        02: Verify that only declarations of global variables exists and no
            initialization takes place in header files.
            Note: all "VAR(*, TYPEDEF)" are part of a type definition hand have no relevance for
            this manual test.
        03: Search for the string "CONST" and "const" in the whole module source code.
        04: Verify that only declarations of global constants exists and no initialization takes
            place in header files.
      </description>
      <comment>
        Additionally following coding style shall be checked (not required for CanTp.ASR40.SWS_CanTp_00155):
        - All global variables and constants in a header file shall have the qualifier "extern".
        - Since no initialization is allowed in header files the qualifier "STATIC" or "static"
          shall not exist in header files.
      </comment>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00155</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>8</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>953</internalId></specobject>

  </specobjects>
    <specobjects doctype="swurs">

    <specobject>
      <id>CanTp.EB.DBGINST001</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Every public API of the module shall have debug instrumentation.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CanTp_DBGINST_001</srcid><srcstatus/><internalId>1095</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>954</internalId></specobject>

    <specobject>
      <id>CanTp.EB.DBGINST002</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The parameter of a API shall be available in the entry instrumentation.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CanTp_DBGINST_001</srcid><srcstatus/><internalId>1095</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>955</internalId></specobject>

    <specobject>
      <id>CanTp.EB.DBGINST003</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The parameter of a API shall be available in the exit instrumentation.
        If the API has a return value, the very first parameter of the macro shall contain the expected return value.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CanTp_DBGINST_001</srcid><srcstatus/><internalId>1095</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>956</internalId></specobject>

    <specobject>
      <id>CanTp.EB.DBGINST004</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The default implementation of the debug instrumentation shall be an empty macro.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CanTp_DBGINST_001</srcid><srcstatus/><internalId>1095</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>957</internalId></specobject>

    <specobject>
      <id>CanTp.EB.DBGINST005</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The module shall include the header files Base_Dbg.h in order to allow changing the default implementation of the debug instrumentation.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CanTp_DBGINST_001</srcid><srcstatus/><internalId>1095</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>958</internalId></specobject>

  </specobjects>
    <specobjects doctype="swurs">

    <specobject>
      <id>CanTp.EB.PBCFGM101</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Service name: CanTp_IsValidConfig
        Syntax: Std_ReturnType CanTp_IsValidConfig( void* ConfigPtr )
        Sync/Async: Synchronous
        Reentrancy: Reentrant
        Parameters (in): ConfigPtr, post build configuration manager
        configuration.
        Parameters (inout): None
        Parameters (out): None
        Return value: Returns E_OK if the CanTp configuration is valid otherwise E_NOT_OK. A
        null pointer is interpreted as invalid configuration.
        Description: This function determines if the CanTp configuration is valid. This
        function can be called also before the CanTp is initialized. No error reporting
        is necessary within this function.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_Test_IsValidConfig</srcid><srcstatus/><internalId>1096</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_PBCFGM</srcid><srcstatus/><internalId>1113</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>959</internalId></specobject>

    <specobject>
      <id>CanTp.EB.PBCFGM102</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        A configuration is valid
        - if the platform signature in the post build configuration equals the value
          determined by the macro TS_PlatformSigIsValid.
        - if the link time signature in the post build configuration equals the link time
          signature in the link time configuration file.
        - if the compile time signature in the post build configuration equals the value of
          the macro CANTP_CFG_SIGNATURE.
        - if the compile time signature of Published information in the post build configuration
          equals the value of the macro CANTP_PUBLIC_INFO_SIGNATURE.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_Test_IsValidConfig</srcid><srcstatus/><internalId>1096</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>960</internalId></specobject>

    <specobject>
      <id>CanTp.EB.PBCFGM104</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For generalized consistency of the post build configuration versus the compile time
        configuration:
        - the post build configuration structure shall contain the uint32 value
          CfgSignature.
        - the CanTp_Cfg.h file shall contain the macro
          CANTP_CFG_SIGNATURE.
        - the MCG shall generate this signature value of compile time parameters. The x-path
          function asc:getConfigSignature(nodeset) shall be used to determine the signature out
          of a list of parameters. The list of compile time parameters shall determined with the
          function asc:getConfigClassNodeList(cassString).
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_Test_IsValidConfig</srcid><srcstatus/><internalId>1096</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_PBCFGM</srcid><srcstatus/><internalId>1113</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>961</internalId></specobject>

    <specobject>
      <id>CanTp.EB.PBCFGM104_1</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For generalized consistency of the post build configuration versus the compile time
        configuration:
        - the post build configuration structure shall contain the uint32 value
          PublicInfoSignature.
        - the CanTp_Cfg.h file shall contain the macro
          CANTP_PUBLIC_INFO_SIGNATURE.
        - The MCG shall generate this signature value from the list of parameters of
          configuration class 'PublishedInformation' except 'Release'. The XPath function
          asc:getConfigSignature(nodeset) shall be used to determine the signature out of the
          list of parameters. The list of parameters shall be determined with the function
          asc:getConfigClassNodeList(cassString).
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_Test_IsValidConfig</srcid><srcstatus/><internalId>1096</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>962</internalId></specobject>

    <specobject>
      <id>CanTp.EB.PBCFGM105</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For generalized consistency of the post build configuration versus the link time
        configuration:
        - the post build configuration structure shall contain the uint32 value
          LcfgSignature.
        - the link time configuration shall contain the uint32 value
          CanTp_LcfgSignature.
        - the MCG shall generate this signature value of link time parameters. The x-path
          function asc:getConfigSignature(nodeset) shall be used to determine the signature out
          of a list of parameters. The list of link time parameters shall determined with the
          function asc:getConfigClassNodeList(cassString).
      </description>
      <comment>
        See also:
        https://infohub.automotive.elektrobit.com/display/PRJEBTRESOS/PostBuild#PostBuild-Consistencypostbuildconfig
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_Test_IsValidConfig</srcid><srcstatus/><internalId>1096</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_LCFG_C</srcid><srcstatus/><internalId>1598</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>963</internalId></specobject>

    <specobject>
      <id>CanTp.EB.PBCFGM106</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For Platform verification:
        - the CanTp post build configuration structure shall contain the value
          uint32 PlatformSignature. This uint32 must be the first value of the post build
          configuration structure to guarantee the correct access not disturbed by any padding
          bytes.
        - the MCG shall generate this signature for the selected target. The generator shall
          use the x-path function asc:getPlatformSignature() to determine this value.
      </description>
      <comment>
        See also:
        https://infohub.automotive.elektrobit.com/display/PRJEBTRESOS/PostBuild#PostBuild-Consistencypostbuildconfig
        https://issue.ebgroup.elektrobit.com/browse/ASCBASE-1485
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_Test_IsValidConfig</srcid><srcstatus/><internalId>1096</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>964</internalId></specobject>

    <specobject>
      <id>CanTp.EB.PBCFGM107</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The PbcfgM support shall be enabled or disabled via the macro
        CANTP_PBCFGM_SUPPORT_ENABLED defined in the file
        CanTp_Cfg.h.
        If the PbcfgM configuration references the CanTp configuration
        the macro is set to STD_ON otherwise, or if no PbcfgM configuration is
        available it is set to STD_OFF.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_Test_IsValidConfig</srcid><srcstatus/><internalId>1096</internalId></linkedfrom><linkedfrom><srcid>CanTp_Test_PBcfgM_Off</srcid><srcstatus/><internalId>1098</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_RELOCATABLEPBCFG_1</srcid><srcstatus/><internalId>1102</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_RELOCATABLEPBCFG_2</srcid><srcstatus/><internalId>1103</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_RELOCATABLEPBCFG_3</srcid><srcstatus/><internalId>1105</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_RELOCATABLEPBCFG_4</srcid><srcstatus/><internalId>1107</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_RELOCATABLEPBCFG_5</srcid><srcstatus/><internalId>1110</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_RELOCATABLEPBCFG_6</srcid><srcstatus/><internalId>1112</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>965</internalId></specobject>

    <specobject>
      <id>CanTp.EB.PBCFGM108</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If the CanTp is referenced by the PbcfgM, the parameter regarding the
        relocatable feature, shall not be editable and the MCG shall use the configuration of
        the PbcfgM.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_Test_PBcfgM_Off</srcid><srcstatus/><internalId>1098</internalId></linkedfrom><linkedfrom><srcid>CanTp_Test_PBcfgM_On</srcid><srcstatus/><internalId>1099</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_RELOCATABLEPBCFG_1</srcid><srcstatus/><internalId>1102</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_RELOCATABLEPBCFG_2</srcid><srcstatus/><internalId>1103</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_RELOCATABLEPBCFG_3</srcid><srcstatus/><internalId>1105</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_RELOCATABLEPBCFG_4</srcid><srcstatus/><internalId>1107</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_RELOCATABLEPBCFG_5</srcid><srcstatus/><internalId>1110</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_RELOCATABLEPBCFG_6</srcid><srcstatus/><internalId>1112</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanTp_EBParameters.xdm.m4_103</srcid><srcstatus/><internalId>1060</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>966</internalId></specobject>

    <specobject>
      <id>CanTp.EB.PBCFGM110</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The CanTp_Init() function must be extended to enable the PbcgfM
        features.
        The initialization function shall obtain the CanTp configuration
        from the PbcfgM if the PbcfgM support is enabled within this CanTp
        and the initialization function is called with a null pointer.
        The validity of the configuration shall be checked by the function
        CanTp_IsValidConfig(). The validity shall be check regardless the PbcfgM
        support is enabled or not.
        If no valid configuration can be obtained the initialization function shall
        return, leaving the CanTp uninitialized.
        In the case error reporting is enabled and no valid configuration can be obtained
        an erroneous parameter shall be indicated.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_Test_VerifyInitWithPcfgM</srcid><srcstatus/><internalId>1097</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>967</internalId></specobject>

    <specobject>
      <id>CanTp.EB.PostBuild_1</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The CanTp module shall compile and build an executable even in the absence
        of a post build configuration, i.e. without any post build generated .c and .h files
        available.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_Compile_NoPBCfg</srcid><srcstatus/><internalId>1121</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_Gen_00000_OnlyPbCfg</srcid><srcstatus/><internalId>1525</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>968</internalId></specobject>

    <specobject>
      <id>CanTp.EB.PbcfgM_General_3</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The CanTp shall provide the following macros in the header file
        CanTp_Cfg.h:
        - CANTP_RELOCATABLE_CFG_ENABLE which is set to STD_ON
          if relocatable config shall be enabled, otherwise it's set to STD_OFF.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_Test_PBcfgM_On</srcid><srcstatus/><internalId>1099</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>969</internalId></specobject>

    <specobject>
      <id>CanTp.EB.PbcfgM_General_6</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If PbcfgM support is enabled CanTp shall define the following macros in
        CanTp_PBCfg.c:
        - TS_PB_CFG_LAYOUT_TYPE: Shall expand to the type definition of the Postbuild
          configuration layout type (e.g. CanTp_ConstConfigLayoutType)
        - TS_PB_CFG_NAME: Shall expand to the name of the structure defining the Postbuild
          configuration layout (e.g. CanTp_ConfigLayout)
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTp_Test_PBcfgM_Off</srcid><srcstatus/><internalId>1098</internalId></linkedfrom><linkedfrom><srcid>CanTp_Test_PBcfgM_On</srcid><srcstatus/><internalId>1099</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>970</internalId></specobject>

  </specobjects>
    <specobjects doctype="swurs">

    <specobject>
      <id>CanTp.EB.PDULENGTHTYPE001</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The CanTp module shall support the following values of PduLengthType:
        [UINT32, UINT16]
      </description>
      <verifycrit>
        Use case 1 - Modules not capable of handling more than 64 kbytes of data:
          - use PduLengthType value 'UINT32' with conformance test
          - verify successful test run, verify absence of metric violations
            (MISRA-C:2012, static code analysis, compiler warnings)
        Use case 2 - Modules capable of handling more than 64 kbytes of data:
          - use conformance test which handles more than 64 kbytes of data
          - apply "boundary" tests using data length of:
            [&lt;&lt;65535,65535, 65536, &gt;131072][bytes]
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTP_ConTest13_01_UINT32_PduLengthType_Transmit_CANFD_MF</srcid><srcstatus/><internalId>1178</internalId></linkedfrom><linkedfrom><srcid>TS_CANTP_ConTest13_02_UINT32_PduLengthType_RxIndication</srcid><srcstatus/><internalId>1179</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>971</internalId></specobject>

  </specobjects>
    <specobjects doctype="swurs">

    <specobject>
      <id>CanTp.EB.Interface.Consistency</id>
       <status>approved</status>
       <source>EB</source>
       <version>1</version>
       <description>
        The module shall provide a mechanism to guarantee consistency of interfaces and
        types between its implementation and its code stub.
       </description>
       <comment>
        The code stub of a module shall provide the same external view than the module itself.
        This is mandatory because unit test of modules test against the code stubs of
        adjacent modules. Inconsistent stubs may result in the situation that incompatible
        interfaces are not detected as unit test stage.
       </comment>
       <verifycrit>
        Create a compile test with two permutations that call all interfaces of a module
        (in both permutations).
        p0: Behave like a regular compile test; call the module generator and compile against
        the implementation of the module.
        p1: Do not generate module code and do not compile the implementation of the module.
        Instead the module shall be replaced with its own code stub.
       </verifycrit>
       <needscoverage>
          <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CanTp_VerifyCodeStub</srcid><srcstatus/><internalId>1100</internalId></linkedfrom></coveredby></needscov>
       <containerCovstatus>covered</containerCovstatus></needscoverage>
       
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>972</internalId></specobject>

  </specobjects>
    <specobjects doctype="dev">
    <specobject>
      <id>dev.CanTp.DetInvalidBuffer</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>61</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00293_7</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>62</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00293_8</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>63</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>973</internalId></specobject>
    <specobject>
      <id>dev.CanTp.Shutdown</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>87</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00010</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>141</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00211</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>348</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00202</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>349</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00200</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>350</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>974</internalId></specobject>
    <specobject>
      <id>dev.CanTp.Debugging</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>105</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00249</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>67</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00250</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>68</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00251</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>69</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00252</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>70</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00253</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>71</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>975</internalId></specobject>
    <specobject>
      <id>dev.CanTp.Det.E_xx_COM</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>131</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00229</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00293_13</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>64</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00293_14</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>65</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00293_15</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>66</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>976</internalId></specobject>
    <specobject>
      <id>dev.CanTp.ConsChck</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>169</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00307</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>83</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00308</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>84</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>977</internalId></specobject>
    <specobject>
      <id>dev.CanTp.Errors</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>198</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00229</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>338</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293_16</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>335</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00352</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>337</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00093</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>223</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00345</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>264</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00346</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>267</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00349</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>280</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00254</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>368</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00260</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>372</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00216</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>402</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>978</internalId></specobject>
    <specobject>
      <id>dev.CanTp.StartOfReceptionWithoutData</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>222</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00329</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>152</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>979</internalId></specobject>
    <specobject>
      <id>dev.CanTp.TxConfirmation</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>246</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00075</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00355</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>149</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>980</internalId></specobject>
    <specobject>
      <id>dev.CanTp.DemErrors</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>266</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00291</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>322</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>981</internalId></specobject>
    <specobject>
      <id>dev.CanTp.MetaData.AddresingFormats</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>288</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00330</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>156</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00331</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>158</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00332</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>159</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00334</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>196</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00335</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>198</internalId></provcov>
        <provcov>
          <linksto>CanTp.ECUC_CanTp_00284</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>467</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00248</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>252</internalId></provcov>
        <provcov>
          <linksto>CanTp.ECUC_CanTp_00281</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>434</internalId></provcov>
        <provcov>
          <linksto>CanTp.ECUC_CanTp_00262</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>452</internalId></provcov>
        <provcov>
          <linksto>CanTp.ECUC_CanTp_00139</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>463</internalId></provcov>
        <provcov>
          <linksto>CanTp.ECUC_CanTp_00302</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>422</internalId></provcov>
        <provcov>
          <linksto>CanTp.ECUC_CanTp_00253</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>465</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>982</internalId></specobject>
    <specobject>
      <id>dev.CanTp.MetaDataForward</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>315</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00331</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>158</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00332</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>159</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>983</internalId></specobject>
    <specobject>
      <id>dev.CanTp.StartOfReception.BufferSize</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>336</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00339</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>166</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>984</internalId></specobject>
    <specobject>
      <id>dev.CanTp.Metadata.OngoingReception</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>357</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00337</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>251</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>985</internalId></specobject>
    <specobject>
      <id>dev.CanTp.MaxChannelCnt</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>378</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ECUC_CanTp_00304</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>418</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>986</internalId></specobject>
    <specobject>
      <id>dev.CanTp.Metadata.AddressExtension8</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>399</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ECUC_CanTp_00138</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>447</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>987</internalId></specobject>
    <specobject>
      <id>dev.CanTp.Metadata.NoTransmitForward</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>420</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00299_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>365</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>988</internalId></specobject>
    <specobject>
      <id>dev.CanTp.NCs</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>440</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ECUC_CanTp_00265</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>450</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>989</internalId></specobject>
    <specobject>
      <id>dev.CanTp.SF.NBr</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>461</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00166</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>161</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>990</internalId></specobject>
    <specobject>
      <id>dev.CanTp.StartOfReception.BUSY</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>482</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00082</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>167</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>991</internalId></specobject>
    <specobject>
      <id>dev.CanTp.Signature.ServiceID</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>506</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00212</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>351</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00321</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>366</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00246</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>367</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00257</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>371</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00302</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>378</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00215</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>400</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>992</internalId></specobject>
    <specobject>
      <id>dev.CanTp.NPduRef</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>529</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00328</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>414</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>993</internalId></specobject>
    <specobject>
      <id>dev.CanTp.MainFunctionRange</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>549</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ECUC_CanTp_00240</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>417</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>994</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/generate/include/CanTp_Cfg.h.m4_9</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/generate/include/CanTp_Cfg.h.m4</sourcefile>
      <sourceline>9</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>85</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>995</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/generate/include/CanTp_EntryTableTypes.h_21</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/generate/include/CanTp_EntryTableTypes.h</sourcefile>
      <sourceline>21</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.JTM_0005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>922</internalId></provcov>
        <provcov>
          <linksto>CanTp.JTM_0008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>925</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>996</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/generate/include/CanTp_ExitTableTypes.h_42</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/generate/include/CanTp_ExitTableTypes.h</sourcefile>
      <sourceline>42</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.JTM_0015</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>933</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>997</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/generate/include/CanTp_Lcfg.h_6</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/generate/include/CanTp_Lcfg.h</sourcefile>
      <sourceline>6</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00160_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>100</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>998</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/generate/src/CanTp_Cfg.c_77</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/generate/src/CanTp_Cfg.c</sourcefile>
      <sourceline>77</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.JTM_MemMapSection_SharedVariables</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>666</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>999</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate/src/CanTp_Cfg.c_81</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/generate/src/CanTp_Cfg.c</sourcefile>
      <sourceline>81</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.JTM_0023</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>941</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.JTM_11579</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>931</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1000</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/generate/src/CanTp_EntryTable.c_46</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/generate/src/CanTp_EntryTable.c</sourcefile>
      <sourceline>46</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.JTM_0006</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>923</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1001</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/generate/src/CanTp_ExitTable.c_12</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/generate/src/CanTp_ExitTable.c</sourcefile>
      <sourceline>12</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00165</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>102</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1002</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate/src/CanTp_ExitTable.c_31</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/generate/src/CanTp_ExitTable.c</sourcefile>
      <sourceline>31</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.JTM_0016</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>934</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1003</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/generate/src/CanTp_Lcfg.c_3</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/generate/src/CanTp_Lcfg.c</sourcefile>
      <sourceline>3</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00159</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>98</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1004</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/generate/src/CanTp_MultiMainFunction.c_68</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/generate/src/CanTp_MultiMainFunction.c</sourcefile>
      <sourceline>68</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.IdleChannels</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>665</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1005</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/include/CanTp.h_23</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/include/CanTp.h</sourcefile>
      <sourceline>23</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00264</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>104</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1006</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/CanTp.h_26</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/include/CanTp.h</sourcefile>
      <sourceline>26</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00264</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>104</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1007</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/include/CanTp_Cbk.h_5</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/include/CanTp_Cbk.h</sourcefile>
      <sourceline>5</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00233</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>57</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1008</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/include/CanTp_Internal.h.m4_44</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/include/CanTp_Internal.h.m4</sourcefile>
      <sourceline>44</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00165</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>102</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1009</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/src/CanTp.c.m4_10</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/src/CanTp.c.m4</sourcefile>
      <sourceline>10</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00024</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>87</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.PublishedInformation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>548</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1010</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/src/CanTp_CancelReceive.c_154</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/src/CanTp_CancelReceive.c</sourcefile>
      <sourceline>154</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00260_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>53</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1011</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanTp_CancelReceive.c_220</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/src/CanTp_CancelReceive.c</sourcefile>
      <sourceline>220</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00262_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>375</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1012</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanTp_CancelReceive.c_275</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/src/CanTp_CancelReceive.c</sourcefile>
      <sourceline>275</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00260_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>53</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1013</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanTp_CancelReceive.c_300</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/src/CanTp_CancelReceive.c</sourcefile>
      <sourceline>300</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00260_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>53</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1014</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/src/CanTp_CancelTransmit.c_140</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/src/CanTp_CancelTransmit.c</sourcefile>
      <sourceline>140</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00254_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>49</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1015</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanTp_CancelTransmit.c_227</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/src/CanTp_CancelTransmit.c</sourcefile>
      <sourceline>227</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00254_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>49</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1016</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanTp_CancelTransmit.c_243</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/src/CanTp_CancelTransmit.c</sourcefile>
      <sourceline>243</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00256</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>369</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1017</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanTp_CancelTransmit.c_254</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/src/CanTp_CancelTransmit.c</sourcefile>
      <sourceline>254</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00254_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>49</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1018</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/src/CanTp_ChangeParameter.c_86</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/src/CanTp_ChangeParameter.c</sourcefile>
      <sourceline>86</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00305_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>385</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1019</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanTp_ChangeParameter.c_127</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/src/CanTp_ChangeParameter.c</sourcefile>
      <sourceline>127</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00304</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>380</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1020</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanTp_ChangeParameter.c_149</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/src/CanTp_ChangeParameter.c</sourcefile>
      <sourceline>149</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00338</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>381</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1021</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/src/CanTp_Init.c_173</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/src/CanTp_Init.c</sourcefile>
      <sourceline>173</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.Init.ParamConfig</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>642</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1022</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanTp_Init.c_206</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/src/CanTp_Init.c</sourcefile>
      <sourceline>206</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00169</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>125</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1023</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/src/CanTp_MainFunction.c_96</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/src/CanTp_MainFunction.c</sourcefile>
      <sourceline>96</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.IdleChannels</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>665</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1024</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanTp_MainFunction.c_159</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/src/CanTp_MainFunction.c</sourcefile>
      <sourceline>159</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.IdleChannels</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>665</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1025</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/src/CanTp_RxIndication.c_689</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/src/CanTp_RxIndication.c</sourcefile>
      <sourceline>689</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_FullDuplex_6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>311</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_FullDuplex_7</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>312</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1026</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanTp_RxIndication.c_701</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/src/CanTp_RxIndication.c</sourcefile>
      <sourceline>701</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_HalfDuplex_6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>295</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_HalfDuplex_7</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>296</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1027</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanTp_RxIndication.c_873</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/src/CanTp_RxIndication.c</sourcefile>
      <sourceline>873</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanTpMetaDataParallelHandling_Reception</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>816</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1028</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanTp_RxIndication.c_890</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/src/CanTp_RxIndication.c</sourcefile>
      <sourceline>890</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanTpMetaDataParallelHandling_Reception</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>816</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1029</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanTp_RxIndication.c_895</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/src/CanTp_RxIndication.c</sourcefile>
      <sourceline>895</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanTpMetaDataParallelHandling_RxSameMetadata</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>817</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1030</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanTp_RxIndication.c_903</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/src/CanTp_RxIndication.c</sourcefile>
      <sourceline>903</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanTpMetaDataParallelHandling_RxNSduNotAvailable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>820</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1031</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanTp_RxIndication.c_920</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/src/CanTp_RxIndication.c</sourcefile>
      <sourceline>920</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanTpMetaDataParallelHandling_RxDifferentMetadata</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>818</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1032</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanTp_RxIndication.c_944</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/src/CanTp_RxIndication.c</sourcefile>
      <sourceline>944</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanTpMetaDataParallelHandling_FC_Reception</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>823</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1033</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanTp_RxIndication.c_1261</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/src/CanTp_RxIndication.c</sourcefile>
      <sourceline>1261</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ISO2016.InvalidFF_DL</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>902</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1034</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanTp_RxIndication.c_1805</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/src/CanTp_RxIndication.c</sourcefile>
      <sourceline>1805</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ISO2016.DynamicStminBS</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>901</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1035</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanTp_RxIndication.c_2319</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/src/CanTp_RxIndication.c</sourcefile>
      <sourceline>2319</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetRxNTaFromCanId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>774</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1036</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanTp_RxIndication.c_2354</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/src/CanTp_RxIndication.c</sourcefile>
      <sourceline>2354</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetRxNTaFromCanId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>774</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1037</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanTp_RxIndication.c_2364</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/src/CanTp_RxIndication.c</sourcefile>
      <sourceline>2364</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetRxNSaGenConnectionOff</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>776</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1038</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanTp_RxIndication.c_2369</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/src/CanTp_RxIndication.c</sourcefile>
      <sourceline>2369</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetRxNSaGenConnectionOn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>775</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1039</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanTp_RxIndication.c_2377</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/src/CanTp_RxIndication.c</sourcefile>
      <sourceline>2377</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MetaData.SetRxNSa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>778</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1040</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanTp_RxIndication.c_2379</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/src/CanTp_RxIndication.c</sourcefile>
      <sourceline>2379</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MetaData.SetRxNTa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>777</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1041</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanTp_RxIndication.c_2400</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/src/CanTp_RxIndication.c</sourcefile>
      <sourceline>2400</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MetaData.CheckRxNTa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>779</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1042</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanTp_RxIndication.c_2401</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/src/CanTp_RxIndication.c</sourcefile>
      <sourceline>2401</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MetaData.CheckRxFcNTa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>789</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1043</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanTp_RxIndication.c_2402</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/src/CanTp_RxIndication.c</sourcefile>
      <sourceline>2402</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MetaData.CheckRxNSa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>780</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1044</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanTp_RxIndication.c_2403</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/src/CanTp_RxIndication.c</sourcefile>
      <sourceline>2403</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MetaData.CheckRxFcNSa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>788</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1045</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/src/CanTp_StopChannel.c_74</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/src/CanTp_StopChannel.c</sourcefile>
      <sourceline>74</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00263</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>377</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1046</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanTp_StopChannel.c_115</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/src/CanTp_StopChannel.c</sourcefile>
      <sourceline>115</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00255</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>370</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1047</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/src/CanTp_Transmit.c_332</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/src/CanTp_Transmit.c</sourcefile>
      <sourceline>332</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanTpMetaDataParallelHandling_SF_Transmission</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>821</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1048</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanTp_Transmit.c_367</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/src/CanTp_Transmit.c</sourcefile>
      <sourceline>367</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanTpMetaDataParallelHandling_FF_Transmission</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>822</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1049</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/src/CanTp_TransmitFrame.c_133</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/src/CanTp_TransmitFrame.c</sourcefile>
      <sourceline>133</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00343</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>218</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1050</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanTp_TransmitFrame.c_134</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/src/CanTp_TransmitFrame.c</sourcefile>
      <sourceline>134</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.11310_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>560</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1051</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanTp_TransmitFrame.c_141</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/src/CanTp_TransmitFrame.c</sourcefile>
      <sourceline>141</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetTxNTaGenConnectionOff</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>785</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1052</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanTp_TransmitFrame.c_252</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/src/CanTp_TransmitFrame.c</sourcefile>
      <sourceline>252</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetNTaTxFc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>782</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1053</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanTp_TransmitFrame.c_253</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/src/CanTp_TransmitFrame.c</sourcefile>
      <sourceline>253</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetTxNSa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>784</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1054</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanTp_TransmitFrame.c_257</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/src/CanTp_TransmitFrame.c</sourcefile>
      <sourceline>257</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetNSaTxFc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>781</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1055</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanTp_TransmitFrame.c_258</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/src/CanTp_TransmitFrame.c</sourcefile>
      <sourceline>258</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetTxNTaGenConnectionOn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>786</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1056</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanTp_TransmitFrame.c_297</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/src/CanTp_TransmitFrame.c</sourcefile>
      <sourceline>297</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MetaData.SetTxMetaDataCanId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>787</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1057</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanTp_TransmitFrame.c_298</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/src/CanTp_TransmitFrame.c</sourcefile>
      <sourceline>298</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MetaData.SetTxFcMetaDataCanId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>783</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1058</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/config/CanTp_EBParameters.xdm.m4_13</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/config/CanTp_EBParameters.xdm.m4</sourcefile>
      <sourceline>13</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ECUC_CanTp_00306</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>415</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1059</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanTp_EBParameters.xdm.m4_103</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/config/CanTp_EBParameters.xdm.m4</sourcefile>
      <sourceline>103</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.PBCFGM108</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>966</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1060</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanTp_EBParameters.xdm.m4_421</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/config/CanTp_EBParameters.xdm.m4</sourcefile>
      <sourceline>421</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanTpMetaDataParallelHandling_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>812</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1061</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanTp_EBParameters.xdm.m4_441</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/config/CanTp_EBParameters.xdm.m4</sourcefile>
      <sourceline>441</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanTpMetaDataParallelHandling_Conf_Limitation1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>813</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1062</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanTp_EBParameters.xdm.m4_450</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/config/CanTp_EBParameters.xdm.m4</sourcefile>
      <sourceline>450</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanTpMetaDataParallelHandling_Conf_Limitation2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>814</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1063</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanTp_EBParameters.xdm.m4_461</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/config/CanTp_EBParameters.xdm.m4</sourcefile>
      <sourceline>461</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanTpFixedRxPduLengthSupport_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>809</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1064</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanTp_EBParameters.xdm.m4_641</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/config/CanTp_EBParameters.xdm.m4</sourcefile>
      <sourceline>641</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.Multicore.CanTpTimeBase_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>796</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1065</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/config/CanTp_Extension.xdm.m4_383</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/config/CanTp_Extension.xdm.m4</sourcefile>
      <sourceline>383</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ECUC_CanTp_00302</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>422</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1066</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanTp_Extension.xdm.m4_416</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/config/CanTp_Extension.xdm.m4</sourcefile>
      <sourceline>416</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ECUC_CanTp_00305</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>423</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1067</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanTp_Extension.xdm.m4_449</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/config/CanTp_Extension.xdm.m4</sourcefile>
      <sourceline>449</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ECUC_CanTp_00303</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>424</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1068</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanTp_Extension.xdm.m4_913</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/config/CanTp_Extension.xdm.m4</sourcefile>
      <sourceline>913</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MetaData.NSduMetaDataTypeRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>790</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1069</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanTp_Extension.xdm.m4_914</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/config/CanTp_Extension.xdm.m4</sourcefile>
      <sourceline>914</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MetaData.NPduMetaDataTypeRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>791</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1070</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanTp_Extension.xdm.m4_1110</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/config/CanTp_Extension.xdm.m4</sourcefile>
      <sourceline>1110</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanTpMetaDataParallelHandling_Conf_Limitation3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>815</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1071</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanTp_Extension.xdm.m4_1141</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/config/CanTp_Extension.xdm.m4</sourcefile>
      <sourceline>1141</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanTpNADescription.CanTpNAe</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>825</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1072</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanTp_Extension.xdm.m4_1184</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/config/CanTp_Extension.xdm.m4</sourcefile>
      <sourceline>1184</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanTpNADescription.CanTpNSa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>824</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1073</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanTp_Extension.xdm.m4_1199</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/config/CanTp_Extension.xdm.m4</sourcefile>
      <sourceline>1199</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ECUC_CanTp_00253</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>465</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1074</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanTp_Extension.xdm.m4_1233</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/config/CanTp_Extension.xdm.m4</sourcefile>
      <sourceline>1233</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanTpNADescription.CanTpNTa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>826</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1075</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanTp_Extension.xdm.m4_1251</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/config/CanTp_Extension.xdm.m4</sourcefile>
      <sourceline>1251</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ECUC_CanTp_00139</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>463</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1076</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanTp_Extension.xdm.m4_1607</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/config/CanTp_Extension.xdm.m4</sourcefile>
      <sourceline>1607</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MetaData.NSduMetaDataTypeRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>790</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1077</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanTp_Extension.xdm.m4_1608</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/config/CanTp_Extension.xdm.m4</sourcefile>
      <sourceline>1608</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MetaData.NPduMetaDataTypeRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>791</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1078</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanTp_Extension.xdm.m4_1744</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/config/CanTp_Extension.xdm.m4</sourcefile>
      <sourceline>1744</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanTpMetaDataParallelHandling_Conf_Limitation3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>815</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1079</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanTp_Extension.xdm.m4_1777</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/config/CanTp_Extension.xdm.m4</sourcefile>
      <sourceline>1777</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanTpNADescription.CanTpNAe</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>825</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1080</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanTp_Extension.xdm.m4_1821</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/config/CanTp_Extension.xdm.m4</sourcefile>
      <sourceline>1821</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanTpNADescription.CanTpNSa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>824</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1081</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanTp_Extension.xdm.m4_1837</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/config/CanTp_Extension.xdm.m4</sourcefile>
      <sourceline>1837</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ECUC_CanTp_00253</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>465</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1082</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanTp_Extension.xdm.m4_1871</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/config/CanTp_Extension.xdm.m4</sourcefile>
      <sourceline>1871</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanTpNADescription.CanTpNTa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>826</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1083</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanTp_Extension.xdm.m4_1887</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/config/CanTp_Extension.xdm.m4</sourcefile>
      <sourceline>1887</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ECUC_CanTp_00139</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>463</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1084</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/generate_var/xgen/CanTp.xgen_116</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/generate_var/xgen/CanTp.xgen</sourcefile>
      <sourceline>116</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00340</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>342</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1085</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate_var/xgen/CanTp.xgen_586</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/generate_var/xgen/CanTp.xgen</sourcefile>
      <sourceline>586</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00160_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>101</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1086</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate_var/xgen/CanTp.xgen_588</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/generate_var/xgen/CanTp.xgen</sourcefile>
      <sourceline>588</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00259</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>103</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1087</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate_var/xgen/CanTp.xgen_651</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/generate_var/xgen/CanTp.xgen</sourcefile>
      <sourceline>651</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00152</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>96</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1088</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate_var/xgen/CanTp.xgen_1182</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/src/Autosar/generate_var/xgen/CanTp.xgen</sourcefile>
      <sourceline>1182</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.InvalidCanIdMask</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>792</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1089</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="Preemption Requirements">
    <specobject>
      <id>dsn.CanTp.Preemption1</id>
      <status>approved</status>
      <source>Elektrobit Automotive GmbH</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/doc/project/design/pdf/CanTp_Design-profiled.xml</sourcefile>
      <sourceline>2077</sourceline>
      <version>1</version>
      <description>
&lt;pre&gt;CanTp_Init() shall not be preempted by any other module API calls.
It needs to be ensured that the function call CanTp_Init() is not
preempted by any other module API calls.
During the call of CanTp_Init() global variables and pointers get 
initialized. It is easy for the integrator to avoid this preemption,
thus no data protection mechanism has been implemented for function
CanTp_Init().&lt;/pre&gt;
            </description>
      <needscoverage>
        <needscov><needsobj>lim</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>lim.CanTp.EB_INTREQ_CanTp_0005</srcid><srcstatus/><internalId>4</internalId></linkedfrom><linkedfrom><srcid>lim.CanTp.EB_INTREQ_CanTp_0006</srcid><srcstatus/><internalId>5</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1090</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="Limitation requirements">
    <specobject>
      <id>dsn.CanTp.API.Limitation1</id>
      <status>approved</status>
      <source>Elektrobit Automotive GmbH</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/doc/project/design/pdf/CanTp_Design-profiled.xml</sourcefile>
      <sourceline>2406</sourceline>
      <version>1</version>
      <description>
&lt;pre&gt;Limitation on multiple invocations of functions. The module 
postpones invocations of CanTp_RxIndication, CanTp_TxConfirmation 
or the Gpt callback function in case that the channel is occupied 
to handle a previous call of these functions. In this case the 
incoming call is postponed. In case of multiple calls on an occupied 
channel only the last call is stored and all previous pending calls
are discarded.
API functions have to occupy the CanTp Channel for consistent
operations. During execution the API function might get interrupted.
Especially the three functions CanTp_RxIndication, CanTp_TxConfirmation
and the Gpt callback function are relevant because they are most 
likely called in interrupt mode. The CanTp addresses this issue. 
One incoming call of CanTp_RxIndication, CanTp_TxConfirmation and 
the Gpt callback function per channel are stored and resolved at 
the end of the initial API function call. In the unlikely event of
multiple calls take place while the channel is occupied. The last 
incoming frame is stored. Discarded frames segmented messages are 
detected through the sequence number check provided for this type of
frames.&lt;/pre&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>lim</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>lim.CanTp.EB_INTREQ_CanTp_0001</srcid><srcstatus/><internalId>0</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1091</internalId></specobject>
    <specobject>
      <id>dsn.CanTp.API.Limitation2</id>
      <status>approved</status>
      <source>Elektrobit Automotive GmbH</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/doc/project/design/pdf/CanTp_Design-profiled.xml</sourcefile>
      <sourceline>2436</sourceline>
      <version>1</version>
      <description>
&lt;pre&gt;Limitation on API CanTp_CancelReceive and CanTp_CancelTransmit. 
The API services CanTp_CancelReceive and CanTp_CancelTransmit do not
cancel an ongoing reception/transmission of a message if the API call
interrupts data processing. In this case the APIs signalize the 
disability to cancel the communication by returning E_NOT_OK.
For a successful receive cancellation following preconditions must 
be fulfilled:
- Related N-SDU is in state of reception.
- Receive cancellation is applied to a segmented message.
- Channel is not locked.
- CanTp is not waiting for the last consecutive frame.

Channel is not waiting for a TX confirmation response from lower
layer.

For a successful transmit cancellation following preconditions
must be fulfilled:
- Related N-SDU is in state of transmission.
- Channel is not locked.

Channel is not waiting for a TX confirmation response from lower
layer.

Channel is not waiting for a flow control message.
To ensure internal data consistency of a communication channel it
is advisable to wait with the cancellation until the data handling mechanism
frees (unlocks) the channel. A storage of the cancellation event to process
it after the channel unlock is not possible because the API service shall 
return immediately with the correct return status which is not yet known.&lt;/pre&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>lim</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>lim.CanTp.EB_INTREQ_CanTp_0002</srcid><srcstatus/><internalId>1</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1092</internalId></specobject>
    <specobject>
      <id>dsn.CanTp.API.Limitation3</id>
      <status>approved</status>
      <source>Elektrobit Automotive GmbH</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/doc/project/design/pdf/CanTp_Design-profiled.xml</sourcefile>
      <sourceline>2476</sourceline>
      <version>1</version>
      <description>
&lt;pre&gt;The effect of CanTpGeneral/CanTpMainFunctionPeriod on the accuracy 
of the callback functions.
If CanTpSTminTimeoutHandling is configured to CanTpMainFunction, 
the module uses an internal counter to trigger the callback routine used 
for the STmin delay. Note that the accuracy of this method depends highly 
on the time between subsequent CanTp_MainFunction calls as specified in 
CanTpGeneral/CanTpMainFunctionPeriod. This value is also used to
calculate the counter values for the CanTp_MainFunction timer.&lt;/pre&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>lim</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>lim.CanTp.EB_INTREQ_CanTp_0003</srcid><srcstatus/><internalId>2</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1093</internalId></specobject>
    <specobject>
      <id>dsn.CanTp.API.Limitation4</id>
      <status>approved</status>
      <source>Elektrobit Automotive GmbH</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/doc/project/design/pdf/CanTp_Design-profiled.xml</sourcefile>
      <sourceline>2495</sourceline>
      <version>1</version>
      <description>
&lt;pre&gt;The reinitialization process must not interrupt other module functions.
If reinitialization of the module is required, the call of CanTp_Init must 
not interrupt other module functions.
The reinitialization process resets all internal variables. Continuing
and interrupted module function after reinitialization can lead to undefined 
module behavior.&lt;/pre&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>lim</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>lim.CanTp.EB_INTREQ_CanTp_0004</srcid><srcstatus/><internalId>3</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1094</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CanTp_DBGINST_001</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/build/reqm/common_req/CanTp_DbgInst_Trace_APIs.c</sourcefile>
      <sourceline>40</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
   Test Dbg
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
  VP: Successful compilation test.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.DBGINST001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>954</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.DBGINST002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>955</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.DBGINST003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>956</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.DBGINST004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>957</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.DBGINST005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>958</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1095</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>CanTp_Test_IsValidConfig</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/build/reqm/common_req/CanTp_PbcfgM_Main_Impl_Test.c</sourcefile>
      <sourceline>71</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the function CanTp_IsValidConfig() is implemented as specified.
  
Test Object: 
    CanTp_IsValidConfig()
  
Test Precondition: 
    The CanTp module is not initialized.
  
Test Execution: 
    01: Call the function CanTp_IsValidConfig() with an NULL_PTR.
    02: VP:
        The function must have returned with E_NOT_OK.
    03: Create an invalid configuration regarding the endianness and alignment.
    04: Call the function CanTp_IsValidConfig() with this invalid configuration.
    05: VP(CanTp.EB.PBCFGM106):
        The function must have returned with E_NOT_OK.
    The following 3 steps are only executed if the module has a link-time configuration:
        06: Create an invalid configuration regarding the link time configuration.
        07: Call the function CanTp_IsValidConfig() with this invalid configuration.
        08: VP(CanTp.EB.PBCFGM105):
                The function must have returned with E_NOT_OK.
    09: Create an invalid configuration regarding the compile time configuration.
    10: Call the function CanTp_IsValidConfig() with this invalid configuration.
    11: VP(CanTp.EB.PBCFGM104):
        The function must have returned with E_NOT_OK.
    12: Create an invalid configuration regarding the published information configuration.
    13: Call the function CanTp_IsValidConfig() with this invalid configuration.
    14: VP(CanTp.EB.PBCFGM104_1):
        The function must have returned with E_NOT_OK.
    15: Call the function CanTp_IsValidConfig() with a valid configuration.
    16: VP:
        The function must have returned with E_OK.
    17: VP(CanTp.EB.PBCFGM107):
        Check if CANTP_PBCFGM_SUPPORT_ENABLED is set to STD_ON.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.PBCFGM101</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>959</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.PBCFGM102</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>960</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.PBCFGM104</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>961</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.PBCFGM104_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>962</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.PBCFGM105</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>963</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.PBCFGM106</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>964</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.PBCFGM107</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>965</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1096</internalId></specobject>
    <specobject>
      <id>CanTp_Test_VerifyInitWithPcfgM</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/build/reqm/common_req/CanTp_PbcfgM_Main_Impl_Test.c</sourcefile>
      <sourceline>225</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the CanTp can be initialized via the PbcfgM.
  
Test Object: 
    CanTp_IsValidConfig()
  
Test Precondition: 
    The CanTp module must not have been initialized.
  
Test Execution: 
    01: Create an invalid configuration regarding the endianness and alignment.
    02: Call the function CanTp_Init() with this invalid configuration.
    03: VP:
        A Det call must have been performed correctly.
    04: Create an invalid configuration regarding the compile time configuration.
    05: Call the function CanTp_Init() with this invalid configuration.
    06: VP:
        A Det call must have been performed correctly.
    The following 3 steps are only executed if the module has a link-time configuration:
        07: Create an invalid configuration regarding the link time configuration.
        08: Call the function CanTp_Init() with this invalid configuration.
        09: VP:
            A Det call must have been performed correctly.
    10: Create an invalid configuration regarding the published information configuration.
    11: Call the function CanTp_Init() with this invalid configuration.
    12: VP:
        A Det call must have been performed correctly.
    13: Initialize the PbcfgM_GetConfig() stub that way that it can return a valid function.
    14: Call the function CanTp_Init() with a null pointer.
    15: VP:
        The function PbcfgM_GetConfig() must have been called once.
    16: VP:
        No Det call must have been performed.
    17: VP:
        The module internal configuration pointer CanTp_RootPtr must equal
        the pointer supplied to the initialization function
    18: PbcfgM_GetConfig shall return E_NOT_OK.
        set the configuration pointer which is returned to NULL_PTR
    19: Call CanTp_Init with NULL_PTR.
    20: VP(CanTp.EB.PBCFGM110):
        Check if Det error is reported.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.PBCFGM110</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>967</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1097</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>CanTp_Test_PBcfgM_Off</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/build/reqm/common_req/CanTp_PbcfgM_Off_Compile_Test.c</sourcefile>
      <sourceline>26</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
      Verify that if PbcfgM support is disabled then CanTp_PBCfg.c shall define
      TS_PB_CFG_LAYOUT_TYPE and TS_PB_CFG_NAME.
      CANTP_PBCFGM_SUPPORT_ENABLED shall be set to STD_OFF.
      CANTP_RELOCATABLE_CFG_ENABLE shall be set to STD_OFF.
    
Test Object: None.
Test Precondition: 
      - PbcfgM configuration does not refer to module CanTp (or no config exists)
      - Include CanTp_PBcfg.c only for step 01 and 02.
      - Include CanTp_Cfg.h for step 03.
    
Test Execution: 
        01: VP(CanTp.EB.PbcfgM_General_6):
            Check that symbols TS_PB_CFG_LAYOUT_TYPE and TS_PB_CFG_NAME exists.
        02: VP(CanTp.EB.PbcfgM_General_6):
            Check that symbols TS_PB_CFG_LAYOUT_TYPE and TS_PB_CFG_NAME has the value
            CanTp_ConfigLayoutType and CANTP_CONFIG_NAME respectively.
        03: VP (CanTp.EB.PBCFGM107):
            Verify that CANTP_PBCFGM_SUPPORT_ENABLED is set to STD_OFF.
        04: VP(CanTp.EB.PBCFGM108, CanTp.EB.RelocatablePBCfg):
            CANTP_RELOCATABLE_CFG_ENABLE shall be STD_OFF
    
Test Input: 
    
Test Output: 
    &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.PbcfgM_General_6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>970</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.PBCFGM107</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>965</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.PBCFGM108</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>966</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.RelocatablePBCfg</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>603</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1098</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>CanTp_Test_PBcfgM_On</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/build/reqm/common_req/CanTp_PbcfgM_On_Compile_Test.c</sourcefile>
      <sourceline>24</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
      1.)
      Verify that CANTP_RELOCATABLE_CFG_ENABLE is defined
      in the header file CanTp_Cfg.h.
      2.)
      Verify that if PbcfgM support is enabled then CanTp_PBCfg.c shall NOT define
      TS_PB_CFG_LAYOUT_TYPE and TS_PB_CFG_NAME.
    
Test Object: None.
Test Precondition: 
        - CANTP_PBCFGM_SUPPORT_ENABLED = STD_ON
    
Test Execution: 
        ------------------------ 1.) ---------------------
        01: VP (CanTp.EB.PbcfgM_General_3,
                CanTp.EB.PBCFGM108,
                CanTp.EB.RelocatablePBCfg):
            Verify that CANTP_RELOCATABLE_CFG_ENABLE is set to STD_ON.
        ------------------------ 2.) ---------------------
        02: Include CanTp_PBcfg.c.
        03: VP(CanTp.EB.PbcfgM_General_6):
            Check that symbols TS_PB_CFG_LAYOUT_TYPE and TS_PB_CFG_NAME exist.
    
Test Input: 
        None.
    
Test Output: 
        Binary file.
    &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.PbcfgM_General_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>969</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.PbcfgM_General_6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>970</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.PBCFGM108</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>966</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.RelocatablePBCfg</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>603</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1099</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CanTp_VerifyCodeStub</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/build/reqm/common_req/CanTp_VerifyStub_testspec.h</sourcefile>
      <sourceline>7</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that the code stub of the module is consistent with the
    implementation.
  
Test Object: 
    Relocatable post-build configuration macros generation.
  
Test Precondition: 
    Permutation [VerifyStub == true]:
      - Unit test contains its own code stub
      - Module is excluded from generation and compilation
    Permutation [VerifyStub == false]:
      - unit test excludes its own code stub
  
Test Execution: 
    01: Invoke all module APIs
    02: VP(CanTp.EB.Interface.Consistency):
        Unit test compiles (implicitly tested)
  
Test Input: 
  
Test Output: 
    Test is correctly generated and compiled.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.Interface.Consistency</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>972</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1100</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_49040_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Compile/IN/CanTp_Compile_1/source/application/Appl.c</sourcefile>
      <sourceline>44</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    CanTp_Compile_JtCli_ApiM_SchMM

    Configuration as in testcase CanTp_Compile_JtCli_ApiF_SchMF with the following difference:
    API wrapper macros are used instead of functions
    SchM macros are used and therefore there is no SchM entry in the exit jumptable
  
Test Object: 
    Jumptable support
  
Test Precondition: 
  
Test Execution: 
    Compile test
  
Test Input: 
  
Test Output: 
    Test is correctly generated and compiled.
    01: VP(CanTp.JTM_0002): The CanTp jump table client shall provide
        all CanTp APIs allowed for this configuration.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.JTM_0002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>919</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1101</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_RELOCATABLEPBCFG_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Compile/IN/CanTp_Compile_1/source/application/Tst_Cfg.h</sourcefile>
      <sourceline>37</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that pre-compile macros regarding RelocatablePbcfg are correctly generated.
  
Test Object: 
    Relocatable post-build configuration macros generation.
  
Test Precondition: 
    PbcfgM exists and refers to CanTp.
    PbcfgMRelocatableCfgEnable = true.
    CanTpRelocatablePbcfgEnable = false.
  
Test Execution: 
    01: VP(CanTp.EB.PBCFGM107):
        CANTP_PBCFGM_SUPPORT_ENABLED must be set to STD_ON.
    02: VP(CanTp.EB.PBCFGM108, CanTp.EB.RelocatablePBCfg):
        CANTP_RELOCATABLE_CFG_ENABLE must be set to STD_ON.
  
Test Input: 
  
Test Output: 
    Test is correctly generated and compiled.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.RelocatablePBCfg</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>603</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.PBCFGM107</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>965</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.PBCFGM108</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>966</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1102</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_RELOCATABLEPBCFG_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Compile/IN/CanTp_Compile_2/source/application/Tst_Cfg.h</sourcefile>
      <sourceline>37</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that pre-compile macros regarding RelocatablePbcfg are correctly generated.
  
Test Object: 
    Relocatable post-build configuration macros generation.
  
Test Precondition: 
    PbcfgM exists and does not refer to CanTp.
    PbcfgMRelocatableCfgEnable = true.
    CanTpRelocatablePbcfgEnable = false.
  
Test Execution: 
    01: VP(CanTp.EB.PBCFGM107):
        CANTP_PBCFGM_SUPPORT_ENABLED must be set to STD_OFF.
    02: VP(CanTp.EB.PBCFGM108, CanTp.EB.RelocatablePBCfg):
        CANTP_RELOCATABLE_CFG_ENABLE must be set to STD_OFF.
  
Test Input: 
  
Test Output: 
    Test is correctly generated and compiled.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.RelocatablePBCfg</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>603</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.PBCFGM107</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>965</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.PBCFGM108</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>966</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.CheckPduRNto1RoutingInteference</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>760</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1103</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_49022</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Compile/IN/CanTp_Compile_3/source/application/Application.c</sourcefile>
      <sourceline>21</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 

    Check that a configurable callback function for Gpt exists.
  
Test Object: 
    Gpt callback function
  
Test Precondition: 
  
Test Execution: 
    Compile test
  
Test Input: 
  
Test Output: 
    Test is correctly generated and compiled.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.Gpt.STminHandling_2a</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>555</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1104</internalId></specobject>
    <specobject>
      <id>TS_CANTP_RELOCATABLEPBCFG_3</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Compile/IN/CanTp_Compile_3/source/application/Application.c</sourcefile>
      <sourceline>64</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that pre-compile macros regarding RelocatablePbcfg are correctly generated.
  
Test Object: 
    Relocatable post-build configuration macros generation.
  
Test Precondition: 
    PbcfgM exists and refers to CanTp.
    PbcfgMRelocatableCfgEnable = false.
    CanTpRelocatablePbcfgEnable = true.
  
Test Execution: 
    01: VP(CanTp.EB.PBCFGM107):
        CANTP_PBCFGM_SUPPORT_ENABLED must be set to STD_ON.
    02: VP(CanTp.EB.PBCFGM108, CanTp.EB.RelocatablePBCfg):
        CANTP_RELOCATABLE_CFG_ENABLE must be set to STD_OFF.
  
Test Input: 
  
Test Output: 
    Test is correctly generated and compiled.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.RelocatablePBCfg</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>603</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.PBCFGM107</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>965</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.PBCFGM108</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>966</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1105</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_49024</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Compile/IN/CanTp_Compile_4/source/application/Application.c</sourcefile>
      <sourceline>72</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    CanTp Testcase 04

    Disable transmit cancellation. Provide an own implementation of CanTp_CancelTransmit().
    Call CanTp_CancelTransmit(). The compiler / linker must not complain about a redeclaration of
    CanTp_CancelTransmit().
  
Test Object: 
    CanTp_CancelTransmit() configuration
  
Test Precondition: 
     Disable CanTp_CancelTransmit() API service in configuration.
  
Test Execution: 
    Compile test
  
Test Input: 
  
Test Output: 
    Test is correctly generated and compiled.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CancelTransmitApiDisabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>592</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1106</internalId></specobject>
    <specobject>
      <id>TS_CANTP_RELOCATABLEPBCFG_4</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Compile/IN/CanTp_Compile_4/source/application/Application.c</sourcefile>
      <sourceline>120</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that pre-compile macros regarding RelocatablePbcfg are correctly generated.
  
Test Object: 
    Relocatable post-build configuration macros generation.
  
Test Precondition: 
    PbcfgM exists and does not refer to CanTp.
    PbcfgMRelocatableCfgEnable = false.
    CanTpRelocatablePbcfgEnable = true.
  
Test Execution: 
    01: VP(CanTp.EB.PBCFGM107):
        CANTP_PBCFGM_SUPPORT_ENABLED must be set to STD_OFF.
    02: VP(CanTp.EB.PBCFGM108, CanTp.EB.RelocatablePBCfg):
        CANTP_RELOCATABLE_CFG_ENABLE must be set to STD_ON.
  
Test Input: 
  
Test Output: 
    Test is correctly generated and compiled.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.RelocatablePBCfg</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>603</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.PBCFGM107</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>965</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.PBCFGM108</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>966</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1107</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_CHANGEPARA_API_OFF</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Compile/IN/CanTp_Compile_7/source/application/Application.c</sourcefile>
      <sourceline>70</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Provide an own implementation of CanTp_ChangeParameter().
    Call CanTp_ChangeParameter(). The compiler / linker must not complain about a
    redeclaration of CanTp_ChangeParameter().
  
Test Object: 
    CanTp_ChangeParameter() configuration
  
Test Precondition: 
    Disable CanTp_ChangeParameter() API service in configuration.
  
Test Execution: 
    Compile test
  
Test Input: 
  
Test Output: 
    Test is correctly generated and compiled.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ECUC_CanTp_00299</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>420</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1108</internalId></specobject>
    <specobject>
      <id>TS_CANTP_READPARA_API_OFF</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Compile/IN/CanTp_Compile_7/source/application/Application.c</sourcefile>
      <sourceline>119</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Provide an own implementation of CanTp_ReadParameter().
    Call CanTp_ReadParameter(). The compiler / linker must not complain about a
    redeclaration of CanTp_ReadParameter().
  
Test Object: 
    CanTp_ReadParameter() configuration
  
Test Precondition: 
    Disable CanTp_ReadParameter() API service in configuration.
  
Test Execution: 
    Compile test
  
Test Input: 
  
Test Output: 
    Test is correctly generated and compiled.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ECUC_CanTp_00300</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>426</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1109</internalId></specobject>
    <specobject>
      <id>TS_CANTP_RELOCATABLEPBCFG_5</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Compile/IN/CanTp_Compile_7/source/application/Application.c</sourcefile>
      <sourceline>170</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that pre-compile macros regarding RelocatablePbcfg are correctly generated.
  
Test Object: 
    Relocatable post-build configuration macros generation.
  
Test Precondition: 
    PbcfgM does not exists.
    CanTpRelocatablePbcfgEnable = true.
  
Test Execution: 
    01: VP(CanTp.EB.PBCFGM107):
        CANTP_PBCFGM_SUPPORT_ENABLED must be set to STD_OFF.
    02: VP(CanTp.EB.PBCFGM108, CanTp.EB.RelocatablePBCfg):
        CANTP_RELOCATABLE_CFG_ENABLE must be set to STD_ON.
  
Test Input: 
  
Test Output: 
    Test is correctly generated and compiled.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.RelocatablePBCfg</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>603</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.PBCFGM107</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>965</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.PBCFGM108</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>966</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1110</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_RCV_CANCL_API_OFF</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Compile/IN/CanTp_Compile_8/source/application/Application.c</sourcefile>
      <sourceline>45</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Provide an own implementation of CanTp_CancelReceive().
    Call CanTp_CancelReceive(). The compiler / linker must not complain about a
    redeclaration of CanTp_CancelReceive().
  
Test Object: 
    CanTp_CancelReceive() configuration
  
Test Precondition: 
    Disable CanTp_CancelReceive() API service in configuration.
  
Test Execution: 
    Compile test
  
Test Input: 
  
Test Output: 
    Test is correctly generated and compiled.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CancelReceiveApiDisabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>589</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1111</internalId></specobject>
    <specobject>
      <id>TS_CANTP_RELOCATABLEPBCFG_6</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Compile/IN/CanTp_Compile_8/source/application/Application.c</sourcefile>
      <sourceline>91</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that pre-compile macros regarding RelocatablePbcfg are correctly generated.
  
Test Object: 
    Relocatable post-build configuration macros generation.
  
Test Precondition: 
    PbcfgM does not exist.
    CanTpRelocatablePbcfgEnable = false.
  
Test Execution: 
    01: VP(CanTp.EB.PBCFGM107):
        CANTP_PBCFGM_SUPPORT_ENABLED must be set to STD_OFF.
    02: VP(CanTp.EB.PBCFGM108, CanTp.EB.RelocatablePBCfg):
        CANTP_RELOCATABLE_CFG_ENABLE must be set to STD_OFF.
  
Test Input: 
  
Test Output: 
    Test is correctly generated and compiled.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.RelocatablePBCfg</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>603</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.PBCFGM107</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>965</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.PBCFGM108</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>966</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1112</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_PBCFGM</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Compile/IN/CanTp_Compile_9/source/application/Application.c.m4</sourcefile>
      <sourceline>21</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check for existence and syntax of API functions. Call:

    CanTp_Init();
    CanTp_IsValidConfig();

    Check that compiling and linking of the file succeeds without warnings.
  
Test Object: 
    Compile test
  
Test Precondition: 
  
Test Execution: 
    Compile test
  
Test Input: 
  
Test Output: 
    Test correctly generates and compiles.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.PBCFGM101</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>959</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.PBCFGM104</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>961</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MMapIsValidFunctionToMemSection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>661</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1113</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_Change_Tx_Param_Api</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Compile/IN/CanTp_Compile_Change_Tx_Param/source/application/Appl.c</sourcefile>
      <sourceline>41</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    CANTP_Change_Tx_Param_Api check if CANTP_CHANGE_TX_PARAMETER_REQ_API
    was selected and if the code compiles. 
  
Test Object: 
  
Test Precondition: 
  
Test Execution: 
    Compile test
  
Test Input: 
  
Test Output: 
    Code is correctly generated and module compiles succesfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanTp_ChangeTxParameter.STmin</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>749</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1114</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_HandleIdGenerator</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Compile/IN/CanTp_Compile_HandleIdGenerator/source/application/Application.c</sourcefile>
      <sourceline>17</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks that invoking the handle ID autocalc wizard creates a valid configuration
    (i.e., a configuration adhering to the constraints of the module's generator (e.g., zero-based,
    dense, and unique)) out of an invalid configuration (i.e., a configuration violating the
    constraints of the module's generator (e.g., not zero-based, not dense, and not unique))

    Handle Id wizard support generation of handle Ids for the following parameters:
      - CanTpTxNSduId
      - CanTpRxNSduId
      - CanTpTxFcNPduConfirmationPduId
      - CanTpTxNPduConfirmationPduId
      - CanTpRxNPduId
      - CanTpRxFcNPduId
  
Test Object: None.
Test Precondition: None.
Test Execution: 
    Ts5 build environment steps:
        The handle ID wizard is started by command line via the Merged_Makefile.mak.
        The module configuration generator provides the generated handle ids
        in CanTp_SymbolicNames_PBcfg.h which is checked against the reference.
        Module code is generated, linked, and compiled with this file.

    Check that the parameters are enumerated in the following order:
    01: VP:
        CanTpTxNSduId are enumerated starting with 0.
    02: VP:
        CanTpRxNSduId are enumerated starting with 0.
    03: VP:
         CanTpTxNPduConfirmationPduId with TAType "PHYSICAL" are enumerated starting with 0.
    04: VP:
        CanTpTxFcNPduConfirmationPduId are enumerated counting from the last value of
        CanTpTxNPduConfirmationPduId.
    05: VP:
        CanTpRxNPduId are enumerated starting with 0.
    06: VP:
        CanTpRxFcNPduId, with TATYPE "PHYSICAL" are enumerated counting from the last value of
        CanTpRxNPduId.

  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.HandleIdGenerator</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>617</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1115</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_49046</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Compile/IN/CanTp_Compile_JtCli_MinFunc/source/application/Tst_49046.c</sourcefile>
      <sourceline>73</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    CanTp_Compile_JtCli_MinFunc

    General configuration as in testcase CanTp_Compile_JtServ_MinFunc with the following difference:
    CanTp is configured as jump table client and not as server
  
Test Object: 
    Jumptable support
  
Test Precondition: 
  
Test Execution: 
    Compile test
  
Test Input: 
  
Test Output: 
    Test is correctly generated and compiled.
    01: VP(CanTp.JTM_0002) The CanTp jump table client shall provide
        all CanTp APIs allowed for this configuration.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.JTM_0002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>919</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1116</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_49042</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Compile/IN/CanTp_Compile_JtServ_AllFunc/source/application/Tst_49042.c</sourcefile>
      <sourceline>53</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    CanTp_Compile_JtServ_AllFunc

    Configuration as in testcase CanTp_Compile_JtServ_SchMF with the following difference:
    All functionalities relevant for the (exit) schedule table are enabled (including Det, SchM as functions, Gpt and EB specific functions)

    Implementation specifics:
    Test has own stubs that only contain those functions, that are referenced by the exit jump table
  
Test Object: 
    Jumptable support
  
Test Precondition: 
  
Test Execution: 
    Compile test
  
Test Input: 
  
Test Output: 
    Test is correctly generated and compiled.
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.JTM_0011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>928</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1117</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_49044</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Compile/IN/CanTp_Compile_JtServ_MinFunc/source/application/Tst_49044.c</sourcefile>
      <sourceline>73</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    CanTp_Compile_JtServ_MinFunc

    General configuration as in testcase CanTp_Compile_JtServ_AllFunc but changed that the jump tables contain minimum API functions which especially means:
    Det is disabled
    SchM used as macros (like in test CanTp_Compile_JtServ_SchMM)
    No Gpt used

    Implementation specifics: See CanTp_Compile_JtServ_AllFunc
  
Test Object: 
    Jumptable support
  
Test Precondition: 
  
Test Execution: 
    Compile test
  
Test Input: 
  
Test Output: 
    Test is correctly generated and compiled.
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.JTM_0011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>928</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1118</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_NSa_Disabled</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Compile/IN/CanTp_Compile_NSa/source/application/Application.c</sourcefile>
      <sourceline>95</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Disable the support for setting of the N_SA values.
    Provide an own implementation of CanTp_GetNSa() and CanTp_SetNSa.
    Call CanTp_GetNSa() and CanTp_SetNSa. The compiler / linker must not complain about a
    redeclaration of CanTp_GetNSa() and CanTp_SetNSa.
  
Test Object: 
    CanTp_GetNSa() and CanTp_SetNSa() configuration
  
Test Precondition: 
    CanTpDynamicNSaEnabled should be disabled.
  
Test Execution: 
    Compile test
  
Test Input: 
  
Test Output: 
    Test is correctly generated and compiled.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.GetNSa_ApiDisabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>565</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.SetNSa_ApiDisabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>564</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1119</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_49049</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Compile/IN/CanTp_Compile_NoGetVersionInfo/source/application/Tst_49049.c</sourcefile>
      <sourceline>73</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    CanTp_Compile_NoGetVersionInfo

    Configuration as in Testcase 01, but GetVersionInfoApi disabled.

    Provide an own implementation of CanTp_GetVersionInfo(). Call CanTp_GetVersionInfo(). The compiler / linker must not complain about a redeclaration of CanTp_GetVersionInfo().
  
Test Object: 
    Compile test
  
Test Precondition: 
  
Test Execution: 
    Compile test
  
Test Input: 
  
Test Output: 
    Compile succeeds.
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00163</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>42</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1120</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>CanTp_Compile_NoPBCfg</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Compile/IN/CanTp_Compile_NoPBCfg/source/application/CanTp_Compile_NoPBCfg.c</sourcefile>
      <sourceline>54</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test shall prove that that the CanTp also compiles without any post build information
  
Test Object: 
    Compile test
  
Test Precondition: 
        * Set TS_CANTP_COMPILE_WITH_POSTBUILD to FALSE in the merged make file to prevent the compilation
          of the post build C file.
        * The merged make file holds a rule which removes all post build files after generation
    
Test Execution: 
        The test run is successful when the CanTp compiles under sticking to the precondition.
    
Test Input: 
    
Test Output: 
    &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.PostBuild_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>968</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1121</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_NonLegacySymbolicNameValues</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Compile/IN/CanTp_Compile_NonLegSymbolicNames/source/application/Application.c</sourcefile>
      <sourceline>19</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Checking the symbolic name macros generated when CANTP_PROVIDE_LEGACY_SYMBOLIC_NAMES is not defined.
  
Test Object: 
  
Test Precondition: 
    CANTP_PROVIDE_LEGACY_SYMBOLIC_NAMES shall not be defined.
  
Test Execution: 
    01: Check that macros are generated with the names and the values listed in output.
  
Test Input: 
  
Test Output: 
   All symbolic name Macros generated should be defined as per Autosar 4.0 rev3
   and the values should be :
    CanTpConf_CanTpChannel_0_CanTpRxPdu1_CanTpRxNPdu     0U
    CanTpConf_CanTpChannel_0_CanTpRxPdu2_CanTpRxNPdu     1U
    CanTpConf_CanTpChannel_0_CanTpRxPdu3_CanTpRxNPdu     2U
    CanTpConf_CanTpChannel_0_CanTpRxPdu2_CanTpTxFcNPdu   0U
    CanTpConf_CanTpChannel_0_CanTpRxPdu3_CanTpTxFcNPdu   1U
    CanTpConf_CanTpTxNSdu_CanTpTxPdu1                    0U
    CanTpConf_CanTpTxNSdu_CanTpTxPdu2                    2U
    CanTpConf_CanTpTxNSdu_CanTpTxPdu3                    1U
    CanTpConf_CanTpChannel_0_CanTpTxPdu3_CanTpRxFcNPdu   1U
    CanTpConf_CanTpChannel_0_CanTpTxPdu1_CanTpTxNPdu     2U
    CanTpConf_CanTpChannel_0_CanTpTxPdu2_CanTpTxNPdu     3U
    CanTpConf_CanTpChannel_0_CanTpTxPdu3_CanTpTxNPdu     4U

  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.LegacySymbolicNameValue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>597</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.SymbolicNameValue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>596</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1122</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_SCHM</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Compile/IN/CanTp_Compile_SchM/source/application/CanTp_Compile_SchM.c</sourcefile>
      <sourceline>46</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
     This test checks that the CanTp module's generator generates a
     syntactically and semantically valid basic software module
     description (BSWMD) when the generator mode "generate_swcd" is
     invoked. It further tests that the SchM exclusive area API is
     correctly generated by the RTE generator based on the CanTp module's
     generated BSWMD.
  
Test Object: None.
Test Precondition: None.
Test Execution: 
    Ts5 build environment steps:
      The module configuration generator produces the BSWMD containing
      the information on the required exclusive areas.  This information
      is then used by the RTE generator to create the required SchM API
      for these exclusive areas. This implicitly verifies that the BSWMD
      is syntactically and semantically correct.  CanTp's static code
      makes use of this API (and the respective #defines) thus causing
      compile/link errors if the BSWMD does not contain the correct
      information.
  
Test Input: 
    Usage of a common ASR configuration having all adjacent ASR modules
    configured.
  
Test Output: 
    Compile succeeds.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.BSWMDGeneration_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>598</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.BSWMDGeneration_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>599</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.BSWMDGeneration_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>600</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1123</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_SymbolicNameValues</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Compile/IN/CanTp_Compile_SymbolicNames/source/application/Application.c</sourcefile>
      <sourceline>21</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that macros are generated for configuration parameters which are specified as 
    SYMBOLICNAMEVALUES.
  
Test Object: 
    Symbolic name value config parameters
  
Test Precondition: 
    CANTP_PROVIDE_LEGACY_SYMBOLIC_NAMES shall be defined.
  
Test Execution: 
    01: Check that macros are generated with the names and the values listed in output.
  
Test Input: 
  
Test Output: 
    CanTpConf_CanTpRxNSdu_CanTpRxPdu1                   0U
    CanTp_CanTpChannel_0_CanTpRxPdu1                    0U

    CanTpConf_CanTpRxNPdu_CanTpRxNPdu_Rx1               0U
    CanTp_CanTpChannel_0_CanTpRxPdu1_CanTpRxNPdu        0U

    CanTpConf_CanTpRxNSdu_CanTpRxPdu2                   1U
    CanTp_CanTpChannel_0_CanTpRxPdu2                    1U

    CanTpConf_CanTpChannel_0_CanTpRxPdu2_CanTpRxNPdu    1U
    CanTp_CanTpChannel_0_CanTpRxPdu2_CanTpRxNPdu        1U

    CanTpConf_CanTpTxFcNPdu_CanTpTxFcNPdu_Rx2           0U
    CanTp_CanTpChannel_0_CanTpRxPdu2_CanTpTxFcNPdu      0U

    CanTpConf_CanTpRxNSdu_CanTpRxPdu3                   2U
    CanTp_CanTpChannel_0_CanTpRxPdu3                    2U

    CanTpConf_CanTpChannel_0_CanTpRxPdu3_CanTpRxNPdu    2U
    CanTp_CanTpChannel_0_CanTpRxPdu3_CanTpRxNPdu        2U

    CanTpConf_CanTpChannel_0_CanTpRxPdu3_CanTpTxFcNPdu  1U
    CanTp_CanTpChannel_0_CanTpRxPdu3_CanTpTxFcNPdu      1U

    CanTpConf_CanTpTxNSdu_CanTpTxPdu1                   0U
    CanTp_CanTpChannel_0_CanTpTxPdu1                    0U

    CanTpConf_CanTpTxNPdu_CanTpTxNPdu_Tx1               2U
    CanTp_CanTpChannel_0_CanTpTxPdu1_CanTpTxNPdu        2U

    CanTpConf_CanTpTxNSdu_CanTpTxPdu2                   2U
    CanTp_CanTpChannel_0_CanTpTxPdu2                    2U

    CanTpConf_CanTpChannel_0_CanTpTxPdu2_CanTpTxNPdu    3U
    CanTp_CanTpChannel_0_CanTpTxPdu2_CanTpTxNPdu        3U

    CanTpConf_CanTpTxNSdu_CanTpTxPdu3                   1U
    CanTp_CanTpChannel_0_CanTpTxPdu3                    1U

    CanTpConf_CanTpRxFcNPdu_CanTpRxFcNPdu_Tx3           1U
    CanTp_CanTpChannel_0_CanTpTxPdu3_CanTpRxFcNPdu      1U

    CanTpConf_CanTpChannel_0_CanTpTxPdu3_CanTpTxNPdu    4U
    CanTp_CanTpChannel_0_CanTpTxPdu3_CanTpTxNPdu        4U
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.SymbolicNameValue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>596</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.LegacySymbolicNameValue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>597</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.ShortNames</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>660</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1124</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_Conf08001_Sdt_FD_Com</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest08_FullDuplex/source/application/CanTp_ConTest08_FullDuplex.c</sourcefile>
      <sourceline>75</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    For standard addressing it shall be verified that Rx N-SDU and Tx N-SDU using the same N-PDU
    ID for incoming frames and incoming FC frames can be handled at the same time.
  
Test Object: 
    N-PDU ID to N-SDU ID translation within CanTp_RxIndication()
  
Test Precondition: 
    - Configured Rx N-SDU with standard addressing format.
    - Configured Tx N-SDU with standard addressing format.
    - Rx N-SDU and Tx N-SDU shall use the same CanIf N-PDU for receiving N-PDUs and FC N-PDUs
      (N-PDU ID equals FC N-PDU ID)
  
Test Execution: 
    01: Initialize CanTp
    02: Start a segmented reception for configured Rx N-SDU.
    03: Start a segmented transmission for configured Tx N-SDU.
    04: Call CanTp_MainFunction() to perform and finish the segmented transmission.
    05: VP(CanTp.EB.ASRExt.StdAddr.FullDuplexNPduId): Verify that PduR_CanTpTxConfirmation() is
        called with result E_OK.
    06: Perform and finish the segmented reception.
    07: VP(CanTp.EB.ASRExt.StdAddr.FullDuplexNPduId): Verify that PduR_CanTpRxIndication() is called
        with result E_OK.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.ASRExt.StdAddr.FullDuplexNPduId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>662</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1125</internalId></specobject>
    <specobject>
      <id>TS_CANTP_Conf08002_Mix_FD_Com</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest08_FullDuplex/source/application/CanTp_ConTest08_FullDuplex.c</sourcefile>
      <sourceline>220</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    For mixed addressing it shall be verified that Rx N-SDU and Tx N-SDU using the same N-PDU ID
    and the same address extension for incoming frames and incoming FC frames can be handled at the
    same time.
  
Test Object: 
    N-PDU ID to N-SDU ID translation within CanTp_RxIndication()
  
Test Precondition: 
    - Configured Rx N-SDU with mixed addressing format.
    - Configured Tx N-SDU with mixed addressing format.
    - Rx N-SDU and Tx N-SDU shall use the same CanIf N-PDU and same address extension for receiving
      N-PDUs and FC N-PDUs (N-PDU ID equals FC N-PDU ID)
  
Test Execution: 
    01: Initialize CanTp
    02: Start a segmented reception for configured Rx N-SDU.
    03: Start a segmented transmission for configured Tx N-SDU.
    04: Call CanTp_MainFunction() to perform and finish the segmented transmission.
    05: VP(CanTp.EB.ASRExt.MixAddr.FullDuplexNPduId): Verify that PduR_CanTpTxConfirmation() is
        called with result E_OK.
    06: Perform and finish the segmented reception.
    07: VP(CanTp.EB.ASRExt.MixAddr.FullDuplexNPduId): Verify that PduR_CanTpRxIndication() is called
        with result E_OK.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.ASRExt.MixAddr.FullDuplexNPduId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>664</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1126</internalId></specobject>
    <specobject>
      <id>TS_CANTP_Conf08003_Ext_FD_Com</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest08_FullDuplex/source/application/CanTp_ConTest08_FullDuplex.c</sourcefile>
      <sourceline>376</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    For extended addressing it shall be verified that Rx N-SDU and Tx N-SDU using the same N-PDU
    ID and the same source address for incoming frames and incoming FC frames can be handled at the
    same time.
  
Test Object: 
    N-PDU ID to N-SDU ID translation within CanTp_RxIndication()
  
Test Precondition: 
    - Configured Rx N-SDU with extended addressing format.
    - Configured Tx N-SDU with extended addressing format.
    - Rx N-SDU and Tx N-SDU shall use the same CanIf N-PDU and same source address for receiving
      N-PDUs and FC N-PDUs (N-PDU ID equals FC N-PDU ID)
  
Test Execution: 
    01: Initialize CanTp
    02: Start a segmented reception for configured Rx N-SDU.
    03: Start a segmented transmission for configured Tx N-SDU.
    04: Call CanTp_MainFunction() to perform and finish the segmented transmission.
    05: VP(CanTp.EB.ASRExt.ExtAddr.FullDuplexNPduId): Verify that PduR_CanTpTxConfirmation() is
        called with result E_OK.
    06: Perform and finish the segmented reception.
    07: VP(CanTp.EB.ASRExt.ExtAddr.FullDuplexNPduId): Verify that PduR_CanTpRxIndication() is called
        with result E_OK.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.ASRExt.ExtAddr.FullDuplexNPduId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>663</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1127</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>CanTp_ConTest09017_BigData_Tx_FF_Format_Standard_Addr</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest09_FlexibleData/source/application/CanTp_ConTest09_FlexibleData.c</sourcefile>
      <sourceline>273</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    If the N-SDU's to be sent data length is bigger than 4095, the module shall be able to send a FF
    which uses a 6 byte N_PCI header.
    Used addressing: standard.
  
Test Object: 
    CanTp accepts FF_DL lengths greater than 4095 and less than 65536.
  
Test Precondition: 
    - Configured Tx N-SDU with standard addressing format and ECUC N-SDU length &gt; 4095.
  
Test Execution: 
    01: Initialize CanTp.
    02: Start a segmented transmission for an standard addressing configured Tx N-SDU.
    03: call CanTp_MainFunction so that the segmented message's transmission is started.
    04: VP(CanTp.EB.BigData_Tx_FF_Format): Verify that PduR_CanTpCopyTxData() is called with correct
        parameters.
    05: VP(CanTp.EB.BigData_Tx_FF_Format): Verify that CanIf_Transmit() is called with correct
        parameters.
    06: VP(CanTp.EB.BigData_Tx_FF_Format): Verify FF's N_PCI bytes.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.BigData_Tx_FF_Format</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>704</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1128</internalId></specobject>
    <specobject>
      <id>CanTp_ConTest09018_BigData_Tx_FF_Format_Extended_Addr</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest09_FlexibleData/source/application/CanTp_ConTest09_FlexibleData.c</sourcefile>
      <sourceline>402</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    If the N-SDU's to be sent data length is bigger than 4095, the module shall be able to send a FF
    which uses a 6 byte N_PCI header.
    Used addressing: extended.
  
Test Object: 
    CanTp accepts FF_DL lengths greater than 4095 and less than 65536.
  
Test Precondition: 
    - Configured Tx N-SDU with extended addressing format and ECUC N-SDU length &gt; 4095.
  
Test Execution: 
    01: Initialize CanTp.
    02: Start a segmented transmission for an extended addressing configured Tx N-SDU.
    03: call CanTp_MainFunction so that the segmented message's transmission is started.
    04: VP(CanTp.EB.BigData_Tx_FF_Format): Verify that PduR_CanTpCopyTxData() is called with correct
        parameters.
    05: VP(CanTp.EB.BigData_Tx_FF_Format): Verify that CanIf_Transmit() is called with correct
        parameters.
    06: VP(CanTp.EB.BigData_Tx_FF_Format): Verify FF's N_PCI bytes.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.BigData_Tx_FF_Format</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>704</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1129</internalId></specobject>
    <specobject>
      <id>CanTp_ConTest09019_BigData_Tx_FF_Format_Mixed_Addr</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest09_FlexibleData/source/application/CanTp_ConTest09_FlexibleData.c</sourcefile>
      <sourceline>531</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    If the N-SDU's to be sent data length is bigger than 4095, the module shall be able to send a FF
    which uses a 6 byte N_PCI header.
    Used addressing: mixed.
  
Test Object: 
    CanTp accepts FF_DL lengths greater than 4095 and less than 65536s.
  
Test Precondition: 
    - Configured Tx N-SDU with mixed addressing format and ECUC N-SDU length &gt; 4095s.
  
Test Execution: 
    01: Initialize CanTp.
    02: Start a segmented transmission for an mixed addressing configured Tx N-SDU.
    03: call CanTp_MainFunction so that the segmented message's transmission is started.
    04: VP(CanTp.EB.BigData_Tx_FF_Format): Verify that PduR_CanTpCopyTxData() is called with correct
        parameters.
    05: VP(CanTp.EB.BigData_Tx_FF_Format): Verify that CanIf_Transmit() is called with correct
        parameters
    06: VP(CanTp.EB.BigData_Tx_FF_Format): Verify FF's N_PCI bytes.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.BigData_Tx_FF_Format</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>704</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1130</internalId></specobject>
    <specobject>
      <id>CanTp_ConTest09020_BigData_Tx_Standard_Addr</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest09_FlexibleData/source/application/CanTp_ConTest09_FlexibleData.c</sourcefile>
      <sourceline>660</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    If the N-SDU's to be sent data length is bigger than 4095, the module shall be able to send a FF
    which uses a 6 byte N_PCI header.
    The module shall send CAN 2.0 with Big data Tx messages (65536 &gt; Rx payload &gt; 4095).
    Used addressing: standard.
  
Test Object: 
    CanTp accepts FF_DL lengths greater than 4095 and less or equal to 65535.
    CanTp is able to send CAN 2.0 messages longer than 4095 and smaller than 65536 bytes if CAN
    flexible data is On.
  
Test Precondition: 
    - Configured Tx N-SDU with standard addressing format and ECUC N-SDU length &gt; 4095.
    - CanTpFlexibleDataRateSupport is equal to CANTP_OFF / CANTP_ON.
  
Test Execution: 
    01: Initialize CanTp.
    02: Start a segmented transmission for an standard addressing configured Tx N-SDU.
    03: Call CanTp_MainFunction triggering data to be sent.
    04 VP(CanTp.EB.BigData_Tx, CanTp.EB.CanFD_Tx_BigData): check PduR's PduR_CanTpCopyTxData API is
       called with correct I-PDU ID.
    05 VP(CanTp.EB.BigData_Tx, CanTp.EB.CanFD_Tx_BigData): check CanIf is called with correct L-SDU
       ID and correct frame type.
    06 VP(CanTp.EB.BigData_Tx, CanTp.EB.CanFD_Tx_BigData): check the sent frame's 2'nd N_PCI byte
       is 0x00.
    07 VP(CanTp.EB.BigData_Tx, CanTp.EB.CanFD_Tx_BigData): check the sent FF's payload.
    08 VP(CanTp.EB.BigData_Tx, CanTp.EB.CanFD_Tx_BigData): verify call to PduR_CanTpCopyTxData API
       is called with correct I-PDU ID to send a CF.
    09 VP(CanTp.EB.BigData_Tx, CanTp.EB.CanFD_Tx_BigData): check CanIf is called with correct L-SDU
       ID, frame type and serial number.
    10 VP(CanTp.EB.BigData_Tx, CanTp.EB.CanFD_Tx_BigData): check the sent CF's payload.
    11: Confirm previously sent CF.
    12 VP(CanTp.EB.BigData_Tx, CanTp.EB.CanFD_Tx_BigData): verify call to PduR_CanTpCopyTxData API
       is called with correct I-PDU ID to send a CF.
    13 VP(CanTp.EB.BigData_Tx, CanTp.EB.CanFD_Tx_BigData): check CanIf is called with correct L-SDU
       ID, frame type and serial number.
    14 VP(CanTp.EB.BigData_Tx, CanTp.EB.CanFD_Tx_BigData): check the sent CF's payload.
    15 VP(CanTp.EB.BigData_Tx, CanTp.EB.CanFD_Tx_BigData): verify call to PduR_CanTpCopyTxData API
       is called with correct I-PDU ID to send a CF.
    16 VP(CanTp.EB.BigData_Tx, CanTp.EB.CanFD_Tx_BigData): check CanIf is called with correct L-SDU
       ID, frame type and serial number.
    17 VP(CanTp.EB.BigData_Tx, CanTp.EB.CanFD_Tx_BigData): check the sent CF's payload.
    18 VP (CanTp.EB.BigData_Tx, CanTp.EB.CanFD_Tx_BigData): PduR Tx confirmation is called with
       correct I-PDU ID and positive result.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.BigData_Tx</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>705</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.CanFD_Tx_BigData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>695</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1131</internalId></specobject>
    <specobject>
      <id>CanTp_ConTest09021_BigData_Tx_Extended_Addr</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest09_FlexibleData/source/application/CanTp_ConTest09_FlexibleData.c</sourcefile>
      <sourceline>941</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    If the N-SDU's to be sent data length is bigger than 4095, the module shall be able to send a FF
    which uses a 6 byte N_PCI header.
    The module shall send CAN 2.0 with Big data Tx messages (65536 &gt; Rx payload &gt; 4095).
    Used addressing: extended.
  
Test Object: 
    CanTp accepts FF_DL lengths greater than 4095 and less or equal to 65535.
    CanTp is able to send CAN 2.0 messages longer than 4095 and smaller than 65536 bytes if CAN
    flexible data is On.
  
Test Precondition: 
    - Configured Tx N-SDU with extended addressing format and ECUC N-SDU length &gt; 4095.
    - CanTpFlexibleDataRateSupport is equal to CANTP_OFF / CANTP_ON.
  
Test Execution: 
    01: Initialize CanTp.
    02: Start a segmented transmission for an extended addressing configured Tx N-SDU.
    03: Call CanTp_MainFunction triggering data to be sent.
    04 VP(CanTp.EB.BigData_Tx, CanTp.EB.CanFD_Tx_BigData): check PduR's PduR_CanTpCopyTxData API is
       called with correct I-PDU ID.
    05 VP(CanTp.EB.BigData_Tx, CanTp.EB.CanFD_Tx_BigData): check CanIf is called with correct L-SDU
       ID and correct frame type.
    06 VP(CanTp.EB.BigData_Tx, CanTp.EB.CanFD_Tx_BigData): check the sent frame's 2'nd N_PCI byte
       is 0x00.
    07 VP(CanTp.EB.BigData_Tx, CanTp.EB.CanFD_Tx_BigData): check the sent FF's payload.
    08 VP(CanTp.EB.BigData_Tx, CanTp.EB.CanFD_Tx_BigData): verify call to PduR_CanTpCopyTxData API
       is called with correct I-PDU ID to send a CF.
    09 VP(CanTp.EB.BigData_Tx, CanTp.EB.CanFD_Tx_BigData): check CanIf is called with correct L-SDU
       ID, frame type and serial number.
    10 VP(CanTp.EB.BigData_Tx, CanTp.EB.CanFD_Tx_BigData): check the sent CF's payload.
    11: Confirm previously sent CF.
    12 VP(CanTp.EB.BigData_Tx, CanTp.EB.CanFD_Tx_BigData): verify call to PduR_CanTpCopyTxData API
       is called with correct I-PDU ID to send a CF.
    13 VP(CanTp.EB.BigData_Tx, CanTp.EB.CanFD_Tx_BigData): check CanIf is called with correct L-SDU
       ID, frame type and serial number.
    14 VP(CanTp.EB.BigData_Tx, CanTp.EB.CanFD_Tx_BigData): check the sent CF's payload.
    15 VP(CanTp.EB.BigData_Tx, CanTp.EB.CanFD_Tx_BigData): verify call to PduR_CanTpCopyTxData API
       is called with correct I-PDU ID to send a CF.
    16 VP(CanTp.EB.BigData_Tx, CanTp.EB.CanFD_Tx_BigData): check CanIf is called with correct L-SDU
       ID, frame type and serial number.
    17 VP(CanTp.EB.BigData_Tx, CanTp.EB.CanFD_Tx_BigData): check the sent CF's payload.
    18 VP (CanTp.EB.BigData_Tx, CanTp.EB.CanFD_Tx_BigData): PduR Tx confirmation is called with
       correct I-PDU ID and positive result.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.BigData_Tx</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>705</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.CanFD_Tx_BigData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>695</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1132</internalId></specobject>
    <specobject>
      <id>CanTp_ConTest09022_BigData_Tx_Mixed_Addr</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest09_FlexibleData/source/application/CanTp_ConTest09_FlexibleData.c</sourcefile>
      <sourceline>1222</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    If the N-SDU's to be sent data length is bigger than 4095, the module shall be able to send a FF
    which uses a 6 byte N_PCI header.
    The module shall send CAN 2.0 with Big data Tx messages (65536 &gt; Rx payload &gt; 4095).
    Used addressing: mixed.
  
Test Object: 
    CanTp accepts FF_DL lengths greater than 4095 and less or equal to 65535
    CanTp is able to send CAN 2.0 messages longer than 4095 and smaller than 65536 bytes if CAN
    flexible data is On.
  
Test Precondition: 
    - Configured Tx N-SDU with mixed addressing format and ECUC N-SDU length &gt; 4095
    - CanTpFlexibleDataRateSupport is equal to CANTP_OFF / CANTP_ON.
  
Test Execution: 
    01: Initialize CanTp
    02: Start a segmented transmission for an mixed addressing configured Tx N-SDU.
    03: Call CanTp_MainFunction triggering data to be sent.
    04 VP(CanTp.EB.BigData_Tx, CanTp.EB.CanFD_Tx_BigData): check PduR's PduR_CanTpCopyTxData API is
       called with correct I-PDU ID.
    05 VP(CanTp.EB.BigData_Tx, CanTp.EB.CanFD_Tx_BigData): check CanIf is called with correct L-SDU
       ID and correct frame type.
    06 VP(CanTp.EB.BigData_Tx, CanTp.EB.CanFD_Tx_BigData): check the sent frame's 2'nd N_PCI byte
       is 0x00.
    07 VP(CanTp.EB.BigData_Tx, CanTp.EB.CanFD_Tx_BigData): check the sent FF's payload.
    08 VP(CanTp.EB.BigData_Tx, CanTp.EB.CanFD_Tx_BigData): verify call to PduR_CanTpCopyTxData API
       is called with correct I-PDU ID to send a CF.
    09 VP(CanTp.EB.BigData_Tx, CanTp.EB.CanFD_Tx_BigData): check CanIf is called with correct L-SDU
       ID, frame type and serial number.
    10 VP(CanTp.EB.BigData_Tx, CanTp.EB.CanFD_Tx_BigData): check the sent CF's payload.
    11: Confirm previously sent CF.
    12 VP(CanTp.EB.BigData_Tx, CanTp.EB.CanFD_Tx_BigData): verify call to PduR_CanTpCopyTxData API
       is called with correct I-PDU ID to send a CF.
    13 VP(CanTp.EB.BigData_Tx, CanTp.EB.CanFD_Tx_BigData): check CanIf is called with correct L-SDU
       ID, frame type and serial number.
    14 VP(CanTp.EB.BigData_Tx, CanTp.EB.CanFD_Tx_BigData): check the sent CF's payload.
    15 VP(CanTp.EB.BigData_Tx, CanTp.EB.CanFD_Tx_BigData): verify call to PduR_CanTpCopyTxData API
       is called with correct I-PDU ID to send a CF.
    16 VP(CanTp.EB.BigData_Tx, CanTp.EB.CanFD_Tx_BigData): check CanIf is called with correct L-SDU
       ID, frame type and serial number.
    17 VP(CanTp.EB.BigData_Tx, CanTp.EB.CanFD_Tx_BigData): check the sent CF's payload.
    18 VP (CanTp.EB.BigData_Tx, CanTp.EB.CanFD_Tx_BigData): PduR Tx confirmation is called with
       correct I-PDU ID and positive result.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.BigData_Tx</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>705</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.CanFD_Tx_BigData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>695</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1133</internalId></specobject>
    <specobject>
      <id>CanTp_ConTest09024_BigData_Rx_FF_Format_Standard_Addr</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest09_FlexibleData/source/application/CanTp_ConTest09_FlexibleData.c</sourcefile>
      <sourceline>1507</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The module shall be able to receive and process a FF which use a 6 byte N_PCI header
  
Test Object: 
    CanTp accepts FF_DL lengths greater than 4095 and less than 65535
  
Test Precondition: 
    - Configured Rx N-SDU with standard addressing format and ECUC N-SDU length &gt; 4095
  
Test Execution: 
    01: Initialize CanTp
    02: Start a segmented reception for an standard addressing configured Rx N-SDU.
    03: VP(CanTp.EB.BigData_Rx_FF_Format): Verify that PduR_CanTpStartOfReception() is called
        with correct parameters
    04: VP(CanTp.EB.BigData_Rx_FF_Format): Verify that PduR_CanTpCopyRxData() is called
        with correct parameters
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.BigData_Rx_FF_Format</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>706</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1134</internalId></specobject>
    <specobject>
      <id>CanTp_ConTest09025_BigData_Rx_FF_Format_Extended_Addr</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest09_FlexibleData/source/application/CanTp_ConTest09_FlexibleData.c</sourcefile>
      <sourceline>1600</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The module shall be able to receive and process a FF which use a 6 byte N_PCI header.
  
Test Object: 
    CanTp accepts FF_DL lengths greater than 4095 and less than 65535.
  
Test Precondition: 
    - Configured Rx N-SDU with extended addressing format and ECUC N-SDU length &gt; 4095.
  
Test Execution: 
    01: Initialize CanTp.
    02: Start a segmented reception for an extended addressing configured Rx N-SDU.
    03: VP(CanTp.EB.BigData_Rx_FF_Format): Verify that PduR_CanTpStartOfReception() is called
        with correct parameters.
    04: VP(CanTp.EB.BigData_Rx_FF_Format): Verify that PduR_CanTpCopyRxData() is called
        with correct parameters.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.BigData_Rx_FF_Format</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>706</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1135</internalId></specobject>
    <specobject>
      <id>CanTp_ConTest09026_BigData_Rx_FF_Format_Mixed_Addr</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest09_FlexibleData/source/application/CanTp_ConTest09_FlexibleData.c</sourcefile>
      <sourceline>1691</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The module shall be able to receive and process a FF which use a 6 byte N_PCI header.
  
Test Object: 
    CanTp accepts FF_DL lengths greater than 4095 and less than 65535.
  
Test Precondition: 
    - Configured Rx N-SDU with standard addressing format and ECUC N-SDU length &gt; 4095.
  
Test Execution: 
    01: Initialize CanTp.
    02: Start a segmented reception for an extended addressing configured Rx N-SDU.
    03: VP(CanTp.EB.BigData_Rx_FF_Format): Verify that PduR_CanTpStartOfReception() is called
        with correct parameters.
    04: VP(CanTp.EB.BigData_Rx_FF_Format): Verify that PduR_CanTpCopyRxData() is called
        with correct parameters.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.BigData_Rx_FF_Format</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>706</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1136</internalId></specobject>
    <specobject>
      <id>CanTp_ConTest09027_BigData_Rx_Standard_Addr</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest09_FlexibleData/source/application/CanTp_ConTest09_FlexibleData.c</sourcefile>
      <sourceline>1785</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The module shall be able to receive a segmented message with more than 4095 bytes.
    The module shall accept CAN 2.0 with Big data Rx messages (65536 &gt; Rx payload &gt; 4095).
  
Test Object: 
    CanTp receives segmented messages with message lengths &gt; 4095.
    CanTp is able to receive CAN 2.0 messages longer than 4095 and smaller than 65536 bytes if CAN
    flexible data is On.
  
Test Precondition: 
    - Configured Rx N-SDU with standard addressing format and ECUC N-SDU length &gt; 4095.
    - CanTpFlexibleDataRateSupport is equal to CANTP_OFF / CANTP_ON.
  
Test Execution: 
    01: Initialize CanTp.
    02: Start a segmented reception for an standard addressing configured Rx N-SDU.
    03: VP(CanTp.EB.BigData_Rx, CanTp.EB.CanFD_Rx_BigData): Verify that PduR_CanTpStartOfReception()
        is called with correct parameters.
    04: VP(CanTp.EB.BigData_Rx, CanTp.EB.CanFD_Rx_BigData): Verify that PduR_CanTpCopyRxData() is
        called with correct parameters.
    05: VP(CanTp.EB.BigData_Rx, CanTp.EB.CanFD_Rx_BigData): Verify that PduR_CanTpCopyRxData() is
        called with correct parameters for all consecutive frames.
    06: VP(CanTp.EB.BigData_Rx, CanTp.EB.CanFD_Rx_BigData): Verify that PduR_CanTpCopyRxData() is
        called with correct parameters for the last consecutive frame.
    07: VP(CanTp.EB.BigData_Rx, CanTp.EB.CanFD_Rx_BigData): Verify that PduR_CanTpRxIndication() is
        called with correct parameters, hence all message segments are copied to the upper buffer
        and the PduR in triggered.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.BigData_Rx</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>707</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.CanFD_Rx_BigData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>694</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1137</internalId></specobject>
    <specobject>
      <id>CanTp_ConTest09028_BigData_Rx_Extended_Addr</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest09_FlexibleData/source/application/CanTp_ConTest09_FlexibleData.c</sourcefile>
      <sourceline>1959</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The module shall be able to receive a segmented message with more than 4095 bytes.
    The module shall accept CAN 2.0 with Big data Rx messages (65536 &gt; Rx payload &gt; 4095).
  
Test Object: 
    CanTp receives segmented messages with message lengths &gt; 4095.
    CanTp is able to receive CAN 2.0 messages longer than 4095 and smaller than 65536 bytes if CAN
    flexible data is On.
  
Test Precondition: 
    - Configured Rx N-SDU with extended addressing format and ECUC N-SDU length &gt; 4095.
    - CanTpFlexibleDataRateSupport is equal to CANTP_OFF / CANTP_ON.
  
Test Execution: 
    01: Initialize CanTp.
    02: Start a segmented reception for an extended addressing configured Rx N-SDU.
    03: VP(CanTp.EB.BigData_Rx, CanTp.EB.CanFD_Rx_BigData): Verify that PduR_CanTpStartOfReception()
        is called with correct parameters.
    04: VP(CanTp.EB.BigData_Rx, CanTp.EB.CanFD_Rx_BigData): Verify that PduR_CanTpCopyRxData() is
        called with correct parameters.
    05: VP(CanTp.EB.BigData_Rx, CanTp.EB.CanFD_Rx_BigData): Verify that PduR_CanTpCopyRxData() is
        called with correct parameters for all consecutive frames.
    06: VP(CanTp.EB.BigData_Rx, CanTp.EB.CanFD_Rx_BigData): Verify that PduR_CanTpCopyRxData() is
        called with correct parameters for the last consecutive frame.
    07: VP(CanTp.EB.BigData_Rx, CanTp.EB.CanFD_Rx_BigData): Verify that PduR_CanTpRxIndication() is
        called with correct parameters, hence all message segments are copied to the upper buffer
        and the PduR in triggered.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.BigData_Rx</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>707</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.CanFD_Rx_BigData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>694</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1138</internalId></specobject>
    <specobject>
      <id>CanTp_ConTest09029_BigData_Rx_Mixed_Addr</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest09_FlexibleData/source/application/CanTp_ConTest09_FlexibleData.c</sourcefile>
      <sourceline>2137</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The module shall be able to receive a segmented message with more than 4095 bytes.
    The module shall accept CAN 2.0 with Big data Rx messages (65536 &gt; Rx payload &gt; 4095).
  
Test Object: 
    CanTp accepts FF_DL lengths greater than 4095 and less than 65535.
  
Test Precondition: 
    - Configured Rx N-SDU with mixed addressing format and ECUC N-SDU length &gt; 4095.
    - CanTpFlexibleDataRateSupport is equal to CANTP_OFF / CANTP_ON.
  
Test Execution: 
    01: Initialize CanTp.
    02: Start a segmented reception for an mixed addressing configured Rx N-SDU.
    03: VP(CanTp.EB.BigData_Rx, CanTp.EB.CanFD_Rx_BigData): Verify that PduR_CanTpStartOfReception()
        is called with correct parameters.
    04: VP(CanTp.EB.BigData_Rx, CanTp.EB.CanFD_Rx_BigData): Verify that PduR_CanTpCopyRxData() is
        called with correct parameters.
    05: VP(CanTp.EB.BigData_Rx, CanTp.EB.CanFD_Rx_BigData): Verify that PduR_CanTpCopyRxData() is
        called with correct parameters for all consecutive frames.
    06: VP(CanTp.EB.BigData_Rx, CanTp.EB.CanFD_Rx_BigData): Verify that PduR_CanTpCopyRxData() is
        called with correct parameters for the last consecutive frame.
    07: VP(CanTp.EB.BigData_Rx, CanTp.EB.CanFD_Rx_BigData): Verify that PduR_CanTpRxIndication() is
        called with correct parameters, hence all message segments are copied to the upper buffer
        and the PduR in triggered.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.BigData_Rx</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>707</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.CanFD_Rx_BigData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>694</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1139</internalId></specobject>
    <specobject>
      <id>CanTp_ConTest09030_BigData_Rx_InvalidMsgLength</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest09_FlexibleData/source/application/CanTp_ConTest09_FlexibleData.c</sourcefile>
      <sourceline>2313</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The module shall ignore an incoming CAN first frame if the frame's contained length is bigger
    than the in EcuC defined N-PDU length or the contained FF_DL exceeds the PduLength type.
  
Test Object: 
    CanTp ignores CAN frames if FF_DL length  exceeds the PduLength type.
  
Test Precondition: 
    - Rx message is Standard, mixed and extended
    - EcuC PduLengthTypeEnum configured to UINT16.
  
Test Execution: 
    01: Initialize CanTp.
    02: Standard addressing: Send FF with N-PDU length &gt; 8.
    03: VP(CanTp.EB.Rx_InvalidMsgLength): Det is called with correct parameters for the Rx FF.
    04: Standard addressing: Send FF (big data format) with I-PDU length in header &gt; 65535.
    05: VP(CanTp.EB.Rx_InvalidMsgLength): Verify no API call, hence Rx message is ignored.
    06: VP(CanTp.EB.Rx_InvalidMsgLength): Det is called with correct parameters for the Rx FF.
    07: Mixed addressing: Send FF with N-PDU length &gt; 8.
    08: VP(CanTp.EB.Rx_InvalidMsgLength): Det is called with correct parameters for the Rx FF.
    09: Mixed addressing: Send FF (big data format) with I-PDU length in header &gt; 65535.
    10: VP(CanTp.EB.Rx_InvalidMsgLength): Det is called with correct parameters for the Rx FF.
    11: VP(CanTp.EB.Rx_InvalidMsgLength): Verify no API call, hence Rx message is ignored.
    12: Extended addressing: Send FF with N-PDU length &gt; 8.
    13: VP(CanTp.EB.Rx_InvalidMsgLength): Det is called with correct parameters for the Rx FF.
    14: Extended addressing: Send FF (big data format) with I-PDU length in header &gt; 65535.
    15: VP(CanTp.EB.Rx_InvalidMsgLength): Det is called with correct parameters for the Rx FF.
    16: VP(CanTp.EB.Rx_InvalidMsgLength): Verify no API call, hence Rx message is ignored.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.BigData_Rx_InvalidLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>708</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1140</internalId></specobject>
    <specobject>
      <id>CanTp_ConTest09005_CanFD_Tx_FF_EcuC_PduLength</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest09_FlexibleData/source/application/CanTp_ConTest09_FlexibleData.c</sourcefile>
      <sourceline>2524</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The module shall always send First Frames (FFs) of the highest length allowed (8, 12, 16, 20,
    24, 32, 48, or 64.)
  
Test Object: 
    CanTp CAN_FD FF transmitted frames
  
Test Precondition: 
    - EcuC Configured Tx N_PDU length is 8, 12, 16, 20, 24, 32, 48, or 64
    - Addressing is standard, extended or mixed
    - CanTpFlexibleDataRateSupport is equal to CANTP_ON
  
Test Execution: 
    01: Initialize CanTp
    02: Start a segmented transmission for a standard extended and mixed addressing configured Tx
        N-SDU.
    03: Call CanTp_MainFunction triggering data to be sent.
    04: VP(CanTp.EB.CanFD_Tx_FF_EcuC_PduLength): Verify that PduR_CanTpCopyTxData() is called with
        correct parameters
    05: VP(CanTp.EB.CanFD_Tx_FF_EcuC_PduLength): Verify that CanIf_Transmit() is called with correct
        parameters
    06: VP(CanTp.EB.CanFD_Tx_FF_EcuC_PduLength): Verify CanIf_Transmit() call, is called with
        correct N_PDU length
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanFD_Tx_FF_EcuC_PduLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>674</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1141</internalId></specobject>
    <specobject>
      <id>CanTp_ConTest09006_CanFD_Tx_CF_EcuC_PduLength</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest09_FlexibleData/source/application/CanTp_ConTest09_FlexibleData.c</sourcefile>
      <sourceline>2667</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The module shall always send Consecutive Frames (CFs) of the highest length allowed (12, 16, 20,
    24, 32, 48, or 64.)
  
Test Object: 
    CanTp CAN_FD CF transmitted frames
  
Test Precondition: 
    - EcuC Configured Tx N_PDU length is 8, 12, 16, 20, 24, 32, 48, or 64
    - Addressing is standard, extended or mixed
    - CanTpFlexibleDataRateSupport is equal to CANTP_ON
  
Test Execution: 
    01: Initialize CanTp
    02: Start a segmented transmission for a standard extended and mixed addressing configured Tx
        N-SDU.
    03: Call CanTp_MainFunction triggering data to be sent.
    04: VP(CanTp.EB.CanFD_Tx_CF_EcuC_PduLength): Verify CanIf_Transmit() call, is called with
        correct N_PDU length
    05: VP(CanTp.EB.CanFD_Tx_CF_EcuC_PduLength): Verify CanIf_Transmit() call, is called with
        correct N_PDU length
    06: VP(CanTp.EB.CanFD_Tx_CF_EcuC_PduLength): Verify CanIf_Transmit() call, is called with
        correct N_PDU length
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanFD_Tx_CF_EcuC_PduLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>675</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1142</internalId></specobject>
    <specobject>
      <id>CanTp_ConTest09009_CanFD_Tx_SF_CAN_20</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest09_FlexibleData/source/application/CanTp_ConTest09_FlexibleData.c</sourcefile>
      <sourceline>3025</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The module shall be able to send fully compatible CAN 2.0 single frames if CAN flexible data is
    set to ON
  
Test Object: 
    CanTp CAN_FD SF transmitted frames
  
Test Precondition: 
    - EcuC Configured Tx N_PDU length is less or equal to 8
    - Addressing is standard, extended or mixed
    - CanTpFlexibleDataRateSupport is equal to CANTP_ON
  
Test Execution: 
    01: Initialize CanTp
    02: Start a Single frame transmission for a standard addressing configured Tx N-SDU.
    03: Call CanTp_MainFunction triggering data to be sent.
    04 VP(CanTp.EB.CanFD_Tx_SF_Format): Verify that PduR_CanTpCopyTxData() is called with correct
       parameters.
    05 VP(CanTp.EB.CanFD_Tx_SF_Format): Verify that CanIf_Transmit() is called with correct
       parameters.
    06 VP(CanTp.EB.CanFD_Tx_SF_Format): Sent frame is indeed a SF.
    07 VP(CanTp.EB.CanFD_Tx_SF_Format): Verify CanIf_Transmit() call, is called with correct N_PDU
       length.
    08 VP(CanTp.EB.CanFD_Tx_SF_Format): check correctness of SF's N_PCI byte 0.
    09 VP(CanTp.EB.CanFD_Tx_SF_Format): check SF sent data: compare CanIf N-PDU &amp; PduR I-PDU
       payloads
    10 VP(CanTp.EB.CanFD_Tx_SF_Format): Expect a positive Tx confirmation signalled to PduR with
       correct parameters.
    11: Start a Single frame transmission for a mixed addressing configured Tx N-SDU.
    12: Call CanTp_MainFunction triggering data to be sent.
    13 VP(CanTp.EB.CanFD_Tx_SF_Format): Verify that PduR_CanTpCopyTxData() is called with correct
       parameters.
    14 VP(CanTp.EB.CanFD_Tx_SF_Format): Verify that CanIf_Transmit() is called with correct
       parameters.
    15 VP(CanTp.EB.CanFD_Tx_SF_Format): Sent frame is indeed a SF.
    16 VP(CanTp.EB.CanFD_Tx_SF_Format): Verify CanIf_Transmit() call, is called with correct N_PDU
       length.
    17 VP(CanTp.EB.CanFD_Tx_SF_Format): check correctness of SF's N_PCI byte 0.
    18 VP(CanTp.EB.CanFD_Tx_SF_Format): check SF sent data: compare CanIf N-PDU &amp; PduR I-PDU
       payloads
    19 VP(CanTp.EB.CanFD_Tx_SF_Format): Expect a positive Tx confirmation signalled to PduR with
       correct parameters.
    20: Start a Single frame transmission for a extended addressing configured Tx N-SDU.
    21: Call CanTp_MainFunction triggering data to be sent.
    22 VP(CanTp.EB.CanFD_Tx_SF_Format): Verify that PduR_CanTpCopyTxData() is called with correct
       parameters.
    23 VP(CanTp.EB.CanFD_Tx_SF_Format): Verify that CanIf_Transmit() is called with correct
       parameters.
    24 VP(CanTp.EB.CanFD_Tx_SF_Format): Sent frame is indeed a SF.
    25 VP(CanTp.EB.CanFD_Tx_SF_Format): Verify CanIf_Transmit() call, is called with correct N_PDU
       length.
    26 VP(CanTp.EB.CanFD_Tx_SF_Format): check correctness of SF's N_PCI byte 0.
    27 VP(CanTp.EB.CanFD_Tx_SF_Format): check SF sent data: compare CanIf N-PDU &amp; PduR I-PDU
       payloads
    28 VP(CanTp.EB.CanFD_Tx_SF_Format): Expect a positive Tx confirmation signalled to PduR with
       correct parameters.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanFD_Tx_SF_Format</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>678</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1143</internalId></specobject>
    <specobject>
      <id>CanTp_ConTest09007_CanFD_Tx_SF__EcuC_PduLength__Format</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest09_FlexibleData/source/application/CanTp_ConTest09_FlexibleData.c</sourcefile>
      <sourceline>3449</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The module shall always send Single Frames (SFs) not longer than the configured (in EcuC)
    N_PDU frame length
  
Test Object: 
    CanTp CAN_FD SF transmitted frames
  
Test Precondition: 
    - EcuC Configured Tx N_PDU length is 12, 16, 20, 24, 32, 48, or 64
    - Addressing is standard, extended or mixed
    - CanTpFlexibleDataRateSupport is equal to CANTP_ON
  
Test Execution: 
    01: Initialize CanTp
    02: Start a Single frame transmission for a standard extended and mixed addressing configured Tx
        N-SDU. The chosen length will be picked so that it will be the maximum payload for a SF
    03: Call CanTp_MainFunction triggering data to be sent.
    04 VP(CanTp.EB.CanFD_Tx_SF_EcuC_MaxPduLength): Verify that PduR_CanTpCopyTxData() is called
       with correct parameters
    05 VP(CanTp.EB.CanFD_Tx_SF_EcuC_MaxPduLength): Verify that CanIf_Transmit() is called with
       correct parameters
    06 VP(CanTp.EB.CanFD_Tx_SF_EcuC_MaxPduLength): Sent frame is indeed a SF.
    07 VP(CanTp.EB.CanFD_Tx_SF_EcuC_MaxPduLength): Verify CanIf_Transmit() call, is called with
        correct N_PDU length
    08 VP(CanTp.EB.CanFD_Tx_SF_Format): check correctness of SF's N_PCI byte 0 (value is 0x00)
    09 VP(CanTp.EB.CanFD_Tx_SF_Format): check correctness of SF's N_PCI byte 1 (SF_DL)
    10 VP(CanTp.EB.CanFD_Tx_SF_EcuC_MaxPduLength): Expect a positive Tx confirmation signalled to
       PduR with correct parameter. This verifies the transmission of the message is finished
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanFD_Tx_SF_Format</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>678</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.CanFD_Tx_SF_EcuC_MaxPduLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>676</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00231_4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>356</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1144</internalId></specobject>
    <specobject>
      <id>CanTp_ConTest09008_CanFD_Tx_LastCF_EcuC_MaxPduLength</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest09_FlexibleData/source/application/CanTp_ConTest09_FlexibleData.c</sourcefile>
      <sourceline>3640</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The module shall always send last Consecutive Frames (CFs) and SFs not longer than the
    configured (in EcuC) N_PDU frame length
  
Test Object: 
    CanTp CAN_FD CF transmitted frames
  
Test Precondition: 
    - EcuC Configured Tx N_PDU length is 12, 16, 20, 24, 32, 48, or 64
    - Addressing is standard, extended or mixed
    - CanTpFlexibleDataRateSupport is equal to CANTP_ON
  
Test Execution: 
    01: Initialize CanTp
    02: Start a segmented transmission for a standard extended and mixed addressing configured Tx
        N-SDU.
    03: Call CanTp_MainFunction triggering data to be sent.
    04 VP(CanTp.EB.CanFD_Tx_SF_EcuC_MaxPduLength): Sent frame is indeed a FF =&gt; EcuC configured
       maximum length is not violated by sending a SF.
    05 VP(CanTp.EB.CanFD_Tx_SF_EcuC_MaxPduLength): Verify CanIf_Transmit() call, is called with
       correct N_PDU length (maximum payload for a FF).
    06: send a FC to CAN TP informing it no more FCs will be sent during transmission.
    07 VP(CanTp.EB.CanFD_Tx_SF_EcuC_MaxPduLength): CanIf_Transmit called indeed to send a last CF.
    08 VP(CanTp.EB.CanFD_Tx_LastCF_EcuC_MaxPduLength): Verify CanIf_Transmit() call, is called with
       correct length - not more than the EcuC configured length.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanFD_Tx_LastCF_EcuC_MaxPduLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>677</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.CanFD_Tx_SF_EcuC_MaxPduLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>676</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1145</internalId></specobject>
    <specobject>
      <id>CanTp_ConTest09002_CAN_FD_SWS_CanTp_00348</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest09_FlexibleData/source/application/CanTp_ConTest09_FlexibleData.c</sourcefile>
      <sourceline>3880</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    If CAN FD is enabled, the module shall always send Single Frames (SFs), or last CFs with N_PDU
    frame length 8
  
Test Object: 
    CanTp CAN_FD SF last CF transmitted frames
  
Test Precondition: 
    - Addressing is standard, extended or mixed
    - CanTpFlexibleDataRateSupport is equal to CANTP_ON
  
Test Execution: 
    01: Initialize CanTp.
    02: Start a Single frame transmission for a standard extended and mixed addressing configured Tx
        N-SDU.
    03: Call CanTp_MainFunction triggering data to be sent.
    04 VP(CanTp.SWS_CanTp_00348_2): Verify that PduR_CanTpCopyTxData() is called with
       correct parameters.
    05 VP(CanTpSWS_CanTp_00348_2): Verify that CanIf_Transmit() is called with correct
       parameters.
    06 VP(CanTp.SWS_CanTp_00348_2): Verify CanIf_Transmit() call, is called with correct
       N_PDU length.
    07 VP(CanTp.SWS_CanTp_00348_2): check correctness of SF's N_PCI byte 0 (SF_DL).
    08: Start a segmented transmission for a standard extended and mixed addressing configured Tx
        N-SDU.
    09: Call CanTp_MainFunction triggering data to be sent.
    10 VP(CanTp.SWS_CanTp_00348_2): Verify that PduR_CanTpCopyTxData() is called with
       correct parameters.
    11 VP(CanTp.SWS_CanTp_00348_2): Verify CanIf_Transmit() call, is called with correct
       N_PDU length.
    12 VP(CanTp.SWS_CanTp_00348_2): Verify CanIf_Transmit() call, is called with correct
       N_PDU length.
    13: send a FC to CAN TP informing it no more FCs will be sent during transmission.
    14 VP(CanTp.SWS_CanTp_00348_2): Verify that PduR_CanTpCopyTxData() is called with
       correct parameters, showing that a CF is sent.
    15 VP(CanTp.SWS_CanTp_00348_2): Verify that CanIf_Transmit() is called with correct
       CanTxPduId parameter.
    16 VP(CanTp.SWS_CanTp_00348_2): Verify CanIf_Transmit() call, is called with correct
       N_PDU length.
    17: Confirm last sent CF.
    18 VP(CanTp.SWS_CanTp_00348_2): Verify PduR_CanTpTxConfirmation() signaled to PduR with
       correct parameters, showing a positive Transmission confirmation (TxPduId parameter is
       correct and Result parameter value is E_OK).
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00348_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>277</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1146</internalId></specobject>
    <specobject>
      <id>CanTp_ConTest09003_CAN_FD_ON_8_BYTES_SWS_CanTp_00351</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest09_FlexibleData/source/application/CanTp_ConTest09_FlexibleData.c</sourcefile>
      <sourceline>4271</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    If CAN FD is enabled, the module shall always send Single Frames (SFs), or last CFs with N_PDU
    frame length 8 in the case the referenced EcuC PDU length is 8
  
Test Object: 
    SF last CF transmitted frames: CAN flexible data ON
  
Test Precondition: 
    - Addressing is standard, extended or mixed
    - CanTpFlexibleDataRateSupport is equal to CANTP_ON
    - Use SF &amp; last CF to stimulate CanTp
  
Test Execution: 
    01: Initialize CanTp.
    02: Start a Single frame transmission for a standard extended and mixed addressing configured Tx
        N-SDU.
    03: Call CanTp_MainFunction triggering data to be sent.
    04: VP(CanTp.SWS_CanTp_00351): Verify that PduR_CanTpCopyTxData() is called with
        correct parameters.
    05: VP(CanTp.SWS_CanTp_00351): Verify that CanIf_Transmit() is called with correct
        parameters.
    06: VP(CanTp.SWS_CanTp_00351): Verify CanIf_Transmit() call, is called with correct
        N_PDU length (8 bytes).
    07: VP(CanTp.SWS_CanTp_00351): Verify CanIf_Transmit() call, is called with correct
        payload.
    08: VP(CanTp.SWS_CanTp_00351): Verify CanIf_Transmit() call, is called with correct
        padding.
    09: VP(CanTp.SWS_CanTp_00351): check correctness of CAN FD message, SF's data length
        byte (SF_DL).
    10: Start a segmented message transmission for a standard extended and mixed addressing
        configured Tx N-SDU.
    11: Call CanTp_MainFunction triggering data to be sent.
    12: VP(CanTp.SWS_CanTp_00351): Verify that PduR_CanTpCopyTxData() is called with
        correct parameters.
    13: VP(CanTp.SWS_CanTp_00351): Verify that CanIf_Transmit() is called with correct
        parameters.
    14: VP(CanTp.SWS_CanTp_00351): Sent frame is indeed a FF.
    15: VP(CanTp.SWS_CanTp_00351): Verify CanIf_Transmit() call, is called with correct
        N_PDU length.
    16: VP(CanTp.SWS_CanTp_00351): Verify CanIf_Transmit() call, is called with correct
        payload.
    17: send FC to CanTp
    18: VP(CanTp.SWS_CanTp_00351): Verify that PduR_CanTpCopyTxData() is called with
        correct parameters.
    19: VP(CanTp.SWS_CanTp_00351): Verify that CanIf_Transmit() is called with correct
        parameters.
    20: VP(CanTp.SWS_CanTp_00351): Sent frame is indeed a CF.
    21: VP(CanTp.SWS_CanTp_00351): check correctness of CAN FD message, CF's serial number
        byte (SN).
    22: VP(CanTp.SWS_CanTp_00351): Verify CanIf_Transmit() call, is called with correct
        payload.
    23: VP(CanTp.SWS_CanTp_00351): Verify CanIf_Transmit() call, is called with correct
        padding.
    24: VP(CanTp.SWS_CanTp_00351): Verify CanIf_Transmit() call, is called with correct
        N_PDU length (8 bytes).
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00351</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>285</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1147</internalId></specobject>
    <specobject>
      <id>CanTp_ConTest09004_CAN_FD_ON_SWS_CanTp_00351</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest09_FlexibleData/source/application/CanTp_ConTest09_FlexibleData.c</sourcefile>
      <sourceline>4720</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    If CAN FD is enabled, the module shall always send Single Frames (SFs), or last CFs with N_PDU
    frame length value equal to the next higher possible length (12, 16, 20, 24, 32, 48, or 64)
  
Test Object: 
    SF last CF transmitted frames: CAN flexible data ON
  
Test Precondition: 
    - Addressing is standard, extended or mixed
    - CanTpFlexibleDataRateSupport is equal to CANTP_ON
    - Use SF &amp; last CF to stimulate CanTp
  
Test Execution: 
    01: Initialize CanTp.
    02: Start a Single frame transmission for a standard extended and mixed addressing configured Tx
        N-SDU.
    03: Call CanTp_MainFunction triggering data to be sent.
    04: VP(CanTp.SWS_CanTp_00351): Verify that PduR_CanTpCopyTxData() is called with
        correct parameters.
    05: VP(CanTp.SWS_CanTp_00351): Verify that CanIf_Transmit() is called with correct
        parameters.
    06: VP(CanTp.SWS_CanTp_00351): Verify CanIf_Transmit() call, is called with correct
        N_PDU length.
    07: VP(CanTp.SWS_CanTp_00351): Verify CanIf_Transmit() call, is called with correct
        payload.
    08: VP(CanTp.SWS_CanTp_00351): Verify CanIf_Transmit() call, is called with correct
        padding.
    09: VP(CanTp.SWS_CanTp_00351): check correctness of CAN FD message, SF's data length
        byte (SF_DL).
    10: Start a segmented message transmission for a standard extended and mixed addressing
        configured Tx N-SDU.
    11: Call CanTp_MainFunction triggering data to be sent.
    12: VP(CanTp.SWS_CanTp_00351): Verify that PduR_CanTpCopyTxData() is called with
        correct parameters.
    13: VP(CanTp.SWS_CanTp_00351): Verify that CanIf_Transmit() is called with correct
        parameters.
    14: VP(CanTp.SWS_CanTp_00351): Sent frame is indeed a FF.
    15: VP(CanTp.SWS_CanTp_00351): Verify CanIf_Transmit() call, is called with correct
        N_PDU length.
    16: VP(CanTp.SWS_CanTp_00351): Verify CanIf_Transmit() call, is called with correct
        payload.
    17: send FC to CanTp
    18: VP(CanTp.SWS_CanTp_00351): Verify that PduR_CanTpCopyTxData() is called with
        correct parameters.
    19: VP(CanTp.SWS_CanTp_00351): Verify that CanIf_Transmit() is called with correct
        parameters.
    20: VP(CanTp.SWS_CanTp_00351): Sent frame is indeed a CF.
    21: VP(CanTp.SWS_CanTp_00351): check correctness of CAN FD message, CF's serial number
        byte (SN).
    22: VP(CanTp.SWS_CanTp_00351): Verify CanIf_Transmit() call, is called with correct
        payload.
    23: VP(CanTp.SWS_CanTp_00351): Verify CanIf_Transmit() call, is called with correct
        N_PDU length.
    24: VP(CanTp.SWS_CanTp_00351): Verify CanIf_Transmit() call, is called with correct
        padding.
    25: VP(CanTp.SWS_CanTp_00351): Verify CanIf_Transmit() call, is called with correct
        N_PDU length in case no need for padding.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00351</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>285</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1148</internalId></specobject>
    <specobject>
      <id>CanTp_ConTest09016_CanFD_Tx_BigData</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest09_FlexibleData/source/application/CanTp_ConTest09_FlexibleData.c</sourcefile>
      <sourceline>5207</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The module shall correctly send CAN FD &amp; Big data messages
  
Test Object: 
    CanTp is able to transmit messages longer than 4095 bytes if CAN flexible data is On
  
Test Precondition: 
    - EcuC Configured Rx N_PDU length is 8, 12, 16, 20, 24, 32, 48, or 64
    - Addressing is standard, extended or mixed
    - CanTpFlexibleDataRateSupport is equal to CANTP_ON
  
Test Execution: 
    01: Initialize CanTp.
    02: Start a segmented transmission for a standard extended and mixed addressing configured Tx
        N-SDU.
    03: Call CanTp_MainFunction triggering data to be sent.
    04 VP(CanTp.EB.CanFD_Tx_BigData): Verify that PduR_CanTpCopyTxData() is called
       with correct parameters.
    05 VP(CanTp.EB.CanFD_Tx_BigData): Verify that CanIf_Transmit() is called with correct
       parameters.
    06 VP(CanTp.EB.CanFD_Tx_BigData): Verify CanIf_Transmit() call, is called with correct
       N_PDU length.
    07 VP(CanTp.EB.CanFD_Tx_BigData): Verify CanIf_Transmit() is called for a FF.
    08 VP(CanTp.EB.CanFD_Tx_BigData): Verify that the sent FF is having lower nibble 0x00.
    09 VP(CanTp.EB.CanFD_Tx_BigData): Verify that the sent FF is having byte 2 N_PCI equal to 0x00.
    10 VP(CanTp.EB.CanFD_Tx_BigData): Check that the towards CanIf sent frame's bytes 3-&gt;6 hold the
       correct message length.
    11 VP(CanTp.EB.CanFD_Tx_BigData): Verify the sent FF payload.
    12: Send a FC to CanTp.
    13 VP(CanTp.EB.CanFD_Tx_BigData): Verify that PduR_CanTpCopyTxData() is called
       with correct parameters.
    14 VP(CanTp.EB.CanFD_Tx_BigData): Verify that CanIf_Transmit() is called with correct
       parameters.
    15 VP(CanTp.EB.CanFD_Tx_BigData): Verify CanIf_Transmit() is called for a CF.
    16 VP(CanTp.EB.CanFD_Tx_BigData): Verify the sent CF payload.
    17 VP(CanTp.EB.CanFD_Tx_BigData): Check correctness of CF's SN field.
    18 VP(CanTp.EB.CanFD_Tx_BigData): Verify CanIf_Transmit() call, is called with correct
       N_PDU length.
    19: Confirm sent CF.
    20 VP(CanTp.EB.CanFD_Tx_BigData): Verify that PduR_CanTpCopyTxData() is called
       with correct parameters.
    21 VP(CanTp.EB.CanFD_Tx_BigData): Verify that CanIf_Transmit() is called with correct
       parameters.
    22 VP(CanTp.EB.CanFD_Tx_BigData): Verify CanIf_Transmit() is called for a CF.
    23 VP(CanTp.EB.CanFD_Tx_BigData): Verify the sent CF payload.
    24 VP(CanTp.EB.CanFD_Tx_BigData): Check correctness of CF's SN field.
    25 VP(CanTp.EB.CanFD_Tx_BigData): Verify CanIf_Transmit() call, is called with correct
       N_PDU length.
    26: Confirm sent CF.
    27 VP(CanTp.EB.CanFD_Tx_BigData): Verify that PduR_CanTpCopyTxData() is called with correct
       parameters.
    28 VP(CanTp.EB.CanFD_Tx_BigData): Verify that CanIf_Transmit() is called with correct
       parameters.
    29 VP(CanTp.EB.CanFD_Tx_BigData): Verify CanIf_Transmit() is called for a CF.
    30 VP(CanTp.EB.CanFD_Tx_BigData): Verify the sent CF payload.
    31 VP(CanTp.EB.CanFD_Tx_BigData): Check correctness of CF's SN field.
    32 VP(CanTp.EB.CanFD_Tx_BigData): Verify CanIf_Transmit() call, is called with correct N_PDU
       length.
    33: Confirm sent CF.
    34 VP(CanTp.EB.CanFD_Tx_BigData): Positive Tx confirmation signaled to PduR with correct
       parameters
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanFD_Tx_BigData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>695</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1149</internalId></specobject>
    <specobject>
      <id>CanTp_ConTest09011_CanFD_Rx_SF_CAN_20</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest09_FlexibleData/source/application/CanTp_ConTest09_FlexibleData.c</sourcefile>
      <sourceline>5733</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The module shall accept Single Frames (SFs) conform to CAN 2.0 specification
  
Test Object: 
    CanTp CAN_FD SF received frames
  
Test Precondition: 
    - EcuC Configured Rx N_PDU length is at most 8 (CAN 2.0 conforming frames will be used)
    - Addressing is standard, extended or mixed
    - CanTpFlexibleDataRateSupport is equal to CANTP_ON
  
Test Execution: 
    01: Initialize CanTp
    02: Start a Single frame reception for a standard addressing configured Rx N-SDU.
    03: VP(CanTp.EB.CanFD_Rx_SF): Verify that PduR_CanTpStartOfReception() is called
        with correct parameters
    04: VP(CanTp.EB.CanFD_Rx_SF): Verify that PduR_CanTpCopyRxData() is called with correct
        parameters
    05: VP(CanTp.EB.CanFD_Rx_SF): Verify that PduR_CanTpRxIndication() is called with correct
        parameters
    06: VP(CanTp.EB.CanFD_Rx_SF): Verify payload of received frame
    07: Start a Single frame reception for a mixed addressing configured Rx N-SDU.
    08: VP(CanTp.EB.CanFD_Rx_SF): Verify that PduR_CanTpStartOfReception() is called
        with correct parameters
    09: VP(CanTp.EB.CanFD_Rx_SF): Verify that PduR_CanTpCopyRxData() is called with correct
        parameters
    10: VP(CanTp.EB.CanFD_Rx_SF): Verify that PduR_CanTpRxIndication() is called with correct
        parameters
    11: VP(CanTp.EB.CanFD_Rx_SF): Verify payload of received frame
    12: Start a Single frame reception for a extended addressing configured Rx N-SDU.
    13: VP(CanTp.EB.CanFD_Rx_SF): Verify that PduR_CanTpStartOfReception() is called
        with correct parameters
    14: VP(CanTp.EB.CanFD_Rx_SF): Verify that PduR_CanTpCopyRxData() is called with correct
        parameters
    15: VP(CanTp.EB.CanFD_Rx_SF): Verify that PduR_CanTpRxIndication() is called with correct
        parameters
    16: VP(CanTp.EB.CanFD_Rx_SF): Verify payload of received frame
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanFD_Rx_SF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>689</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1150</internalId></specobject>
    <specobject>
      <id>CanTp_ConTest09010_CanFD_Rx_SF</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest09_FlexibleData/source/application/CanTp_ConTest09_FlexibleData.c</sourcefile>
      <sourceline>6023</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The module shall accept Single Frames (SFs) conform to CAN FD specification
  
Test Object: 
    CanTp CAN_FD SF received frames
  
Test Precondition: 
    - EcuC Configured Rx N_PDU length is 8, 12, 16, 20, 24, 32, 48, or 64
    - Addressing is standard, extended or mixed
    - CanTpFlexibleDataRateSupport is equal to CANTP_ON
  
Test Execution: 
    01: Initialize CanTp
    02: Start a Single frame reception for a standard, extended and mixed addressing configured Rx
        N-SDU.
    03 VP(CanTp.EB.CanFD_Rx_SF): Verify that PduR_CanTpStartOfReception() is called
       with correct parameters.
    04 VP(CanTp.EB.CanFD_Rx_SF): Verify that PduR_CanTpCopyRxData() is called with correct
       parameters.
    05 VP(CanTp.EB.CanFD_Rx_SF): Verify that PduR_CanTpRxIndication() is called with correct
       parameters (correct RxPduId and E_OK as Result).
    06 VP(CanTp.EB.CanFD_Rx_SF): Verify correct data reception and forwarding to PduR
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanFD_Rx_SF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>689</internalId></provcov>
        <provcov>
          <linksto>CanTp.ISO2016.SF_DL_ExtendedMixed_12</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>910</internalId></provcov>
        <provcov>
          <linksto>CanTp.ISO2016.SF_DL_ExtendedMixed_16</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>911</internalId></provcov>
        <provcov>
          <linksto>CanTp.ISO2016.SF_DL_ExtendedMixed_20</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>912</internalId></provcov>
        <provcov>
          <linksto>CanTp.ISO2016.SF_DL_ExtendedMixed_24</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>913</internalId></provcov>
        <provcov>
          <linksto>CanTp.ISO2016.SF_DL_ExtendedMixed_32</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>914</internalId></provcov>
        <provcov>
          <linksto>CanTp.ISO2016.SF_DL_ExtendedMixed_48</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>915</internalId></provcov>
        <provcov>
          <linksto>CanTp.ISO2016.SF_DL_ExtendedMixed_64</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>916</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1151</internalId></specobject>
    <specobject>
      <id>CanTp_ConTest09012_CanFD_Rx_FF_CF_LastCF</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest09_FlexibleData/source/application/CanTp_ConTest09_FlexibleData.c</sourcefile>
      <sourceline>6212</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The module shall accept First Frames (FFs) &amp; Consecutive Frames (CFs) and last CFs conform to
    CAN Flexible Data (CAN FD) specification.
  
Test Object: 
    CanTp CAN_FD FF CF received frames.
  
Test Precondition: 
    - EcuC Configured Rx N_PDU length is 8, 12, 16, 20, 24, 32, 48, or 64.
    - Addressing is standard, extended or mixed.
    - CanTpFlexibleDataRateSupport is equal to CANTP_ON.
  
Test Execution: 
    01: Initialize CanTp.
    02: Start a segmented reception for an standard/extended/mixed addressing configured Rx N-SDU.
    03 VP(CanTp.EB.CanFD_Rx_FF): Verify that PduR_CanTpStartOfReception() is called with correct Pdu
       ID parameter.
    04 VP(CanTp.EB.CanFD_Rx_FF): Verify that PduR_CanTpCopyRxData() is called with correct Pdu ID
       parameter.
    05 VP(CanTp.EB.CanFD_Rx_CF): Verify that PduR_CanTpCopyRxData() is called with Pdu ID parameter
       for all consecutive Rx frames.
    06 VP(CanTp.EB.CanFD_Rx_LastCF): The module shall accept incoming last CF with N_PDU lengths of
       12, 16, 20, 24, 32, 48, or 64.
    07 VP(CanTp.EB.CanFD_Rx_LastCF): Verify that PduR_CanTpCopyRxData() is called with correct Pdu
       ID parameter for the last consecutive frame.
    08 VP(CanTp.EB.CanFD_Rx_FF, CanTp.EB.CanFD_Rx_CF, CanTp.EB.CanFD_Rx_LastCF): Verify that
       PduR_CanTpRxIndication() is called with correct parameters (RxPduId is correct and Result is
       E_OK), hence all message segments are copied to the upper buffer and the PduR is
       triggered to forward the received data up.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanFD_Rx_FF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>690</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.CanFD_Rx_CF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>691</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.CanFD_Rx_LastCF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>692</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00350_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>154</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00350_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1152</internalId></specobject>
    <specobject>
      <id>CanTp_ConTest09013_CanFD_Rx_Multiframe</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest09_FlexibleData/source/application/CanTp_ConTest09_FlexibleData.c</sourcefile>
      <sourceline>6570</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    The module shall accept First Frames with lenght greater than 4095 and further Consecutive Frames.
  
Test Object: 
    CanTp CAN_FD CF received frames
  
Test Precondition: 
    - EcuC Configured Rx N_PDU length is 12, 16, 20, 24, 32, 48, or 64
    - Addressing is standard, extended or mixed
    - CanTpFlexibleDataRateSupport is equal to CANTP_ON
  
Test Execution: 
    01: Initialize CanTp
    02 VP(CanTp.ISO2016.InvalidFF_DL): Check that a FF reception for an standard/extended/mixed addressing configured Rx N-SDU is working fine.
    03 VP(CanTp.EB.CanFD_Rx_FF): Verify that PduR_CanTpStartOfReception() is called
       with correct parameters
    04 VP(CanTp.EB.CanFD_Rx_FF): Verify that PduR_CanTpCopyRxData() is called with correct
       parameters
    05 VP(CanTp.EB.CanFD_Rx_CF): Verify that PduR_CanTpCopyRxData() is called with correct
       parameters for the received CF.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanFD_Rx_FF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>690</internalId></provcov>
        <provcov>
          <linksto>CanTp.ISO2016.InvalidFF_DL</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>902</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.CanFD_Rx_CF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>691</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1153</internalId></specobject>
    <specobject>
      <id>CanTp_ConTest09014_CanFD_Rx_InvalidSize</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest09_FlexibleData/source/application/CanTp_ConTest09_FlexibleData.c</sourcefile>
      <sourceline>6783</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The module shall ignore SF, FF, CF, Last CF Rx frames if their N_PDU length is not 12, 16, 20,
    24, 32, 48, or 64 bytes.
  
Test Object: 
    CanTp CAN FD received SF, FF, CF, last CF frames
  
Test Precondition: 
    - EcuC Configured Rx N_PDU length is 12, 16, 20, 24, 32, 48, or 64
    - Addressing is standard, extended or mixed
    - CanTpFlexibleDataRateSupport is equal to CANTP_ON
  
Test Execution: 
    01: Initialize CanTp
    02: Start a SF / FF / CF / last CF reception for a standard, extended and mixed addressing
        configured Rx N-SDU.
    03 VP(CanTp.EB.CanFD_Rx_InvalidSize): Det is called with correct parameters (ModuleId is CanTp,
       ApiId is RxIndication and ErrorId is CANTP_E_INVALID_RX_LENGTH) for the received SF.
    04 VP(CanTp.EB.CanFD_Rx_InvalidSize): SF is ignored.
    05 VP(CanTp.EB.CanFD_Rx_InvalidSize): Det is called with correct parameters (ModuleId is CanTp,
       ApiId is RxIndication and ErrorId is CANTP_E_INVALID_RX_LENGTH) for the received FF.
    06 VP(CanTp.ISO2016.InvalidFF_DL): FF is ignored.
    07 VP(CanTp.EB.CanFD_Rx_InvalidSize): Det is called with correct parameters (ModuleId is CanTp,
       ApiId is RxIndication and ErrorId is CANTP_E_INVALID_RX_LENGTH) for the received CF.
    08 VP(CanTp.EB.CanFD_Rx_InvalidSize): CF is ignored.
    09 VP(CanTp.EB.CanFD_Rx_InvalidSize): Det is called with correct parameters (ModuleId is CanTp,
       ApiId is RxIndication and ErrorId is CANTP_E_INVALID_RX_LENGTH) for the received last CF.
    10 VP(CanTp.EB.CanFD_Rx_InvalidSize): CF is ignored.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanFD_Rx_InvalidSize</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>693</internalId></provcov>
        <provcov>
          <linksto>CanTp.ISO2016.InvalidFF_DL</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>902</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1154</internalId></specobject>
    <specobject>
      <id>CanTp_ConTest09031_Rx_SF_CAN_20_CANFD_EXTENDED_STANDARD_CanIdType</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest09_FlexibleData/source/application/CanTp_ConTest09_FlexibleData.c</sourcefile>
      <sourceline>7330</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The module shall accept SF, FF, CF, Last CF Rx frames if their N_PDU length
    is smaller than the maximum configured PduLength.
  
Test Object: 
    1. CanTp accepts EXTENDED CAN 2.0 and EXTENDED CAN FD SFs,
       when RxPduCanIdType is EXTENDED
    2. CanTp accepts STANDARD CAN-2.0 and STANDARD CAN-FD SFs,
       when RxPduCanIdType is STANDARD
    3. CanTp shall ignore SF which have length greater than configured PduLength
  
Test Precondition: 
    - EcuC Configured Rx N_PDU from position 6 has length configured to 48 bytes and STANDARD_CAN as CanIdType
    - EcuC Configured Rx N_PDU from position 7 has length configured to 64 bytes and EXTENDED_CAN as CanIdType
    - CanTpFlexibleDataRateSupport is equal to CANTP_ON
  
Test Execution: 
    01: Initialize CanTp
    02: Start a CAN 2.0 SF reception for a standard and mixed addressing configured Rx N-SDU.
    03: Start a CAN-FD SF reception for a standard and mixed addressing configured Rx N-SDU.
    04: SF is ignored because it has length greater than the maximum configured PduLength = 48 (64 &gt; 48 not accepted)
        Check that a Det error is reported with correct parameters (ModuleId is CanTp,
        ApiId is RxIndication and ErrorId is CANTP_E_INVALID_RX_LENGTH) for the invalid received SF.
    05: Check that PduR_CanTpStartOfReception was called for a valid CAN 2.0 or CAN-FD Single Frame
    06: Check that PduR_CanTpCopyRxData was called for a valid SF
    07: Check that PduR_CanTpRxIndication was called with E_OK, for a valid SF
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.Rx_SF_STANDARD_CanIdType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>679</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Rx_SF_EXTENDED_CanIdType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>680</internalId></provcov>
        <provcov>
          <linksto>CanTp.ISO2016.SF_DL_Standard_12</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>903</internalId></provcov>
        <provcov>
          <linksto>CanTp.ISO2016.SF_DL_Standard_16</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>904</internalId></provcov>
        <provcov>
          <linksto>CanTp.ISO2016.SF_DL_Standard_20</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>905</internalId></provcov>
        <provcov>
          <linksto>CanTp.ISO2016.SF_DL_Standard_24</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>906</internalId></provcov>
        <provcov>
          <linksto>CanTp.ISO2016.SF_DL_Standard_32</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>907</internalId></provcov>
        <provcov>
          <linksto>CanTp.ISO2016.SF_DL_Standard_48</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>908</internalId></provcov>
        <provcov>
          <linksto>CanTp.ISO2016.SF_DL_Standard_64</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>909</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1155</internalId></specobject>
    <specobject>
      <id>CanTp_ConTest09032_Rx_FF_CF_lastCF_CAN_20_CANFD_EXTENDED_STANDARD_CanIdType</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest09_FlexibleData/source/application/CanTp_ConTest09_FlexibleData.c</sourcefile>
      <sourceline>7559</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The module shall accept FF, CF, Last CF Rx frames if their N_PDU length is:
      - smaller than the maximum configured PduLength
      - one of the discrete values: 12, 16, 20, 24, 48, 64
  
Test Object: 
    1. CanTp accepts EXTENDED CAN 2.0 and EXTENDED CAN FD FF, CF, last CF,
       when RxPduCanIdType is EXTENDED (supports classical and CanFd frames)
    2. CanTp accepts STANDARD CAN 2.0 and STANDARD CAN-FD FF, CF, last CF,
       when RxPduCanIdType is STANDARD (supports classical and CanFd frames)
    3. CanTp shall ignore FF, CF, last CF which have length greater than configured PduLength
  
Test Precondition: 
    - EcuC Configured Rx N_PDU from position 6 has length configured to 48 bytes and STANDARD_CAN as CanIdType
    - EcuC Configured Rx N_PDU from position 7 has length configured to 64 bytes and EXTENDED_CAN as CanIdType
    - CanTpFlexibleDataRateSupport is equal to CANTP_ON
  
Test Execution: 
    01: Initialize CanTp
    02: Receive a standard/mixed CAN 2.0 FF and standard/mixed CAN-FD frames.
    03: Check that a Det error is reported because received frame has length greater than the maximum
        configured PduLength. In our case 40 length is not accepted
        if CAN_DL is configured to 64 (64 &gt; 48 not accepted) .
    04: Check if PduR_CanTpStartOfReception function was called for a valid FF frame
    05: Check if PduR_CanTpCopyRxData was called for reception of a valid frame
    06: Reception of block of intermediate standard/mixed CAN 2.0 and standard/mixed CAN-FD CFs
    07: Check if PduR_CanTpCopyRxData was called for a valid standard/mixed CAN 2.0
        and standard/mixed CAN-FD intermediate CF reception
    08: Reception of a standard/mixed CAN 2.0 and standard/mixed CAN-FD last CF
    09: Check if PduR_CanTpCopyRxData function was called for the last CF
    10: Check if PduR_CanTpRxIndication function was called after the entire message was successfully received
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.Rx_FF_STANDARD_CanIdType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>681</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Rx_FF_EXTENDED_CanIdType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>682</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Rx_FC_STANDARD_CanIdType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>683</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Rx_FC_EXTENDED_CanIdType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>684</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Rx_CF_STANDARD_CanIdType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>685</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Rx_CF_EXTENDED_CanIdType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>686</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Rx_lastCF_STANDARD_CanIdType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>687</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Rx_lastCF_EXTENDED_CanIdType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>688</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1156</internalId></specobject>
    <specobject>
      <id>CanTp_ConTest09001_CAN_FD_SWS_CanTp_00344_00345_00346</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest09_FlexibleData/source/application/CanTp_ConTest09_FlexibleData.c</sourcefile>
      <sourceline>7993</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The module shall ignore an incoming CAN_FD SF, CF &amp; last CF frame if the frame's data length is
    different than 8 and CanTpRxPaddingActivation is equal to CANTP_ON and the N_PDU length is 8 in
    EcuC
  
Test Object: 
    CanTp Padding feature for Rx CAN_FD frames
  
Test Precondition: 
    - EcuC Configured Rx N-PDU length is 8
    - EcuC Configured Rx I-PDU length is 8
    - CanTpRxPaddingActivation is equal to CANTP_ON
    - CanTpFlexibleDataRateSupport is equal to CANTP_ON
    - Det is on
  
Test Execution: 
    01: Initialize CanTp
    02: Start a SF reception for a standard / mixed / extended addressing configured Rx N-SDU.
    03 VP(CanTp.SWS_CanTp_00345): Det is called with correct parameters for the received
       SF (ErrorId == CANTP_E_INVALID_RX_LENGTH).
    04 VP(CanTp.SWS_CanTp_00344): Verify no API call, hence Rx message is ignored.
    05 VP(CanTp.ISO2016.InvalidFF_DL): 
        Check that a FF reception for a standard / mixed / extended addressing configured Rx
        N-SDU is processed.
    06 VP(CanTp.SWS_CanTp_00346): Det is called with correct parameters for the received
       last CF (ErrorId == CANTP_E_INVALID_RX_LENGTH).
    07 VP(CanTp.SWS_CanTp_00344, CanTp.SWS_CanTp_00346): Verify no API call,
       hence Rx message is ignored for the received invalid padded CF.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00344</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>261</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00345</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>264</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00346</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>267</internalId></provcov>
        <provcov>
          <linksto>CanTp.ISO2016.InvalidFF_DL</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>902</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1157</internalId></specobject>
    <specobject>
      <id>CanTp_ConTest09015_CanFD_Rx_BigData</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest09_FlexibleData/source/application/CanTp_ConTest09_FlexibleData.c</sourcefile>
      <sourceline>8315</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The module shall accept CAN FD &amp; Big data Rx messages
    specification
  
Test Object: 
    CanTp is able to receive messages longer than 4095 bytes if CAN flexible data is On
  
Test Precondition: 
    - EcuC Configured Rx N_PDU length is 8, 12, 16, 20, 24, 32, 48, or 64
    - Addressing is standard, extended or mixed
    - CanTpFlexibleDataRateSupport is equal to CANTP_ON
  
Test Execution: 
    01: Initialize CanTp
    02: Start a segmented reception for an standard/extended/mixed addressing configured Rx N-SDU.
    03: VP(CanTp.EB.CanFD_Rx_BigData): Verify received payload
    04: VP(CanTp.EB.CanFD_Rx_BigData): Verify that PduR_CanTpStartOfReception() is called
        with correct parameters
    05: VP(CanTp.EB.CanFD_Rx_BigData): Verify that PduR_CanTpCopyRxData() is called with correct
        parameters
    06: VP(CanTp.EB.CanFD_Rx_BigData): Verify that CanIf_Transmit() is called with correct
        parameters for sending the FC frame
    07: VP(CanTp.EB.CanFD_Rx_BigData): Verify that PduR_CanTpCopyRxData() is called with correct
        parameters
    08: VP(CanTp.EB.CanFD_Rx_BigData): Verify received payload
    09: VP(CanTp.EB.CanFD_Rx_BigData): Verify that CanIf_Transmit() is called with correct
        CanTxPduId parameter value for sending the FC frame
    10: VP(CanTp.EB.CanFD_Rx_BigData): Verify that CanIf_Transmit() is called with correct
        payload (frame type FC)
    11: Send last CF.
    12: VP(CanTp.EB.CanFD_Rx_BigData): Verify that PduR_CanTpCopyRxData() is called with correct
        parameters
    13: VP(CanTp.EB.CanFD_Rx_BigData): Verify received payload
    14: VP(CanTp.EB.CanFD_Rx_BigData): Verify that PduR_CanTpRxIndication() is called with correct
        parameters, hence all message segments are copied to the upper buffer and the PduR is
        triggered
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanFD_Rx_BigData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>694</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1158</internalId></specobject>
    <specobject>
      <id>CanTp_ConTest_CanFD_Rx_SF_InvalidLength</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest09_FlexibleData/source/application/CanTp_ConTest09_FlexibleData.c</sourcefile>
      <sourceline>8735</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The module shall ignore SF FD messages with SF_DL &gt; 61 for Extended or mixed addressing modes.
    And report Det_ReportError with error id = CANTP_E_INVALID_RX_LENGTH
  
Test Object: 
    CanTp CAN_FD SF received frames with Extended or mixed addressing modes.
  
Test Precondition: 
    - EcuC Configured Rx N_PDU length is 64
    - Addressing is mixed
    - CanTpFlexibleDataRateSupport is equal to CANTP_ON
    - CanTpDevErrorDetectValue is equal to CANTP_ON
  
Test Execution: 
    01: Initialize CanTp
    02: Start a Single frame reception for a mixed addressing configured Rx N-SDU
        with message length &gt; 61 bytes.
    03 VP(CanTp.EB.Rx_SF_EXTENDED_CanIdType): Verify that Det_ReportError() is called
       with error code CANTP_E_INVALID_RX_LENGTH.
    04 Check that this message is ignored and PduR_CanTpStartOfReception is not called.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.Rx_SF_EXTENDED_CanIdType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>680</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1159</internalId></specobject>
    <specobject>
      <id>CanTp_ConTest_Reception_Of_Classical_CanFd_Invalid_SFs</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest09_FlexibleData/source/application/CanTp_ConTest09_FlexibleData.c</sourcefile>
      <sourceline>8843</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    The module shall ignore:
    - CAN 20 or CAN FD SFs with SduLength &lt;=8 and SF_DL from the first byte equal to zero.
    - CAN FD SFs with SduLength &gt; 8 and SF_DL from the second byte equal to zero.
    - CAN FD SFs with SduLength &gt; 8 and SF_DL from the second byte greater than (SduLength - NPCI) - because payload will not fit in the frame.
    - CAN FD SFs with SduLength &gt; 8 and SF_DL from the second byte is a valid one, but first byte is not 0, as it should be for frames with CANFD format.
  
Test Object: 
    CanTp receives invalid CAN 20 Single Frames and CAN FD Single Frames.
  
Test Precondition: 
    - EcuC Configured Rx N_PDU length is 8, for CLASSICAL SF format
    - EcuC configured Rx N_PDU length is 24, for CAN FD SF format
    - Addressing is standard for both NSdus
    - SduLength is smaller or equal to 8, for CLASSICAL SFs
    - SduLength is bigger than 8, for CAN FD SF
    - CanTpFlexibleDataRateSupport is equal to CANTP_ON
    - CanTpDevErrorDetectValue is equal to CANTP_ON
  
Test Execution: 
    01: Initialize CanTp

    02: Start a Single frame reception for a standard addressing,
        with SduLength &lt;= 8 bytes and SF_DL from the first byte equal to zero.
    03: VP():
        Check that this message is ignored and PduR_CanTpStartOfReception is not called

    04: Start a CAN FD Single frame reception for a standard addressing,
        with SduLength &gt; 8 bytes and SF_DL from the second byte equal to zero.
    05: VP():
        Check that this message is ignored and PduR_CanTpStartOfReception is not called

    06: Start a CAN FD Single frame reception for a standard addressing,
        with SduLength &gt; 8 bytes and SF_DL from the second byte greater than (SduLength - NPCI) - because payload will not fit in the frame.
    07: VP():
        Check that this message is ignored and PduR_CanTpStartOfReception is not called

    08: Start a CAN FD Single frame reception for a standard addressing,
        with SduLength &gt; 8 bytes and SF_DL from the second byte is a valid one, but first byte is not 0, as it should be for frames with CANFD format.
    09: VP():
        Check that this message is ignored and PduR_CanTpStartOfReception is not called
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.Rx_SF_STANDARD_CanIdType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>679</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1160</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>CanTp_ConTest10_001_CANFD_SF_CANFD_PADDING_VALUE</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest10_DiffPaddingValues/source/application/CanTp_ConTest10_DiffPaddingValues.c</sourcefile>
      <sourceline>175</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    If CAN FD is enabled, the module shall always send Single Frames (SFs), or last CFs with N_PDU
    frame length value equal to the next higher possible length (12, 16, 20, 24, 32, 48, or 64)
  
Test Object: 
    SF last CF transmitted frames: CAN flexible data ON
  
Test Precondition: 
    - Addressing is standard, extended or mixed
    - CanTpFlexibleDataRateSupport is equal to CANTP_ON, padding is enabled
    - Use SF &amp; last CF to stimulate CanTp
  
Test Execution: 
    01: Initialize CanTp.
    02: Start a Single frame transmission for a standard extended and mixed addressing configured Tx
        N-SDU.
    03: Call CanTp_MainFunction triggering data to be sent.
    04: VP(CanTp.SWS_CanTp_00351): Verify that PduR_CanTpCopyTxData() is called with
        correct parameters.
    05: VP(CanTp.SWS_CanTp_00351): Verify that CanIf_Transmit() is called with correct
        parameters.
    06: VP(CanTp.SWS_CanTp_00351): Verify CanIf_Transmit() call, is called with correct
        padding. If PduLen is 8 or 64 bytes and uses CANTP_ON_CAN_CAN_FD =&gt; padding the CanTpPaddingByteCanFd
        shall be used, otherwise CanTpPaddingByte shall be used.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00351</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>285</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.SWS_CanTp_00030_1g</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>709</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1161</internalId></specobject>
    <specobject>
      <id>CanTp_ConTest10_004_NO_CANFD_SF_lastCF_CLASSIC_PADDING_VALUE</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest10_DiffPaddingValues/source/application/CanTp_ConTest10_DiffPaddingValues.c</sourcefile>
      <sourceline>378</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    If CAN FD is enabled, the module shall always send Single Frames (SFs), or last CFs with N_PDU
    frame length 8 in the case the referenced EcuC PDU length is 8
  
Test Object: 
    SF last CF transmitted frames: CAN flexible data ON
  
Test Precondition: 
    - Addressing is standard, extended or mixed
    - CanTpFlexibleDataRateSupport is equal to CANTP_ON
    - Use SF &amp; last CF to stimulate CanTp
  
Test Execution: 
    01: Initialize CanTp.
    02: Start a Single frame transmission for a standard extended and mixed addressing configured Tx
        N-SDU.
    03: Call CanTp_MainFunction triggering data to be sent.
    04: VP(CanTp.SWS_CanTp_00351): Verify that PduR_CanTpCopyTxData() is called with
        correct parameters.
    05: VP(CanTpSWS_CanTp_00351): Verify that CanIf_Transmit() is called with correct
        parameters.
    06: VP(CanTp.SWS_CanTp_00351): Verify CanIf_Transmit() call, is called with correct
        padding.
    07: Start a segmented message transmission for a standard extended and mixed addressing
        configured Tx N-SDU.
    08: Call CanTp_MainFunction triggering data to be sent.
    09: VP(CanTp.SWS_CanTp_00351): Verify that PduR_CanTpCopyTxData() is called with
        correct parameters.
    10: VP(CanTp.SWS_CanTp_00351): Verify that CanIf_Transmit() is called with correct
        parameters.
    11: send FC to CanTp
    12: VP(CanTp.SWS_CanTp_00351): Verify that PduR_CanTpCopyTxData() is called with
        correct parameters.
    13: VP(CanTp.SWS_CanTp_00351): Verify that CanIf_Transmit() is called with correct
        parameters.
    14: VP(CanTp.SWS_CanTp_00351): Verify CanIf_Transmit() call, is called with correct
        padding.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00351</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>285</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00348_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>276</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1162</internalId></specobject>
    <specobject>
      <id>CanTp_ConTest10_005_CANFD_SF_lastCF_CANFD_PADDING_VALUE</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest10_DiffPaddingValues/source/application/CanTp_ConTest10_DiffPaddingValues.c</sourcefile>
      <sourceline>665</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    If CAN FD is enabled, the module shall always send Single Frames (SFs), or last CFs with
    length greater than 4095. Unused byte shall be padded with CANFD padding value.
  
Test Object: 
    SF last CF transmitted frames: CAN flexible data ON
  
Test Precondition: 
    - Addressing is extended
    - CanTpFlexibleDataRateSupport is equal to CANTP_ON
    - Use SF &amp; last CF to stimulate CanTp
  
Test Execution: 
    01: Get Single frame NpciLength and check if it's a valid one
    02: Flush trace to eliminate test-case dependencies.
    03: Reset stubs.
    04: Sent data needs to be checked.
    05: Initialize CanTp module.
    06: Start a First Frame transmission for an extended configured Tx N-SDU.
    07: Call CanTp_MainFunction triggering data to be sent.
    08: Verify that PduR_CanTpCopyTxData() is called with
        correct parameters.
    09: check that CanIf_Transmit was called with correct parameters.
    10: Check that the sent frame towards CanIf is a FF
    11: Confirm sent FF.
    12: Verify that PduR_CanTpCopyTxData() is called with correct parameters.
    13: Check if CanIf_Transmit() is called with correct parameters.
    14: Check that sent frame is indeed a CF.
    15: Check correctness of CF's SN field.
    16: A CF confirmation is received and triggers CAN TP to send next message.
    17: Check that PduR_CanTpCopyTxData() was called.
    18: Check that CanIf_Transmit() was called with correct parameters.
    19: check CanIf is called with correct L-SDU ID, frame type and serial number.
    20: check the sent CF's payload.
    21: Check if unused bytes of the last Consecutive Frame are padded with CAN FD padding value
    22: PduR Tx confirmation is called withcorrect I-PDU ID and positive result.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00351</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>285</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00348_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>277</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00059_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>260</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1163</internalId></specobject>
    <specobject>
      <id>CanTp_ConTest10_002_CAN20_and_CANFD_Rx_FF_Format_Standard_Addr</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest10_DiffPaddingValues/source/application/CanTp_ConTest10_DiffPaddingValues.c</sourcefile>
      <sourceline>959</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The module shall be able to receive a segmented message with more than 4095 bytes.
    The module shall accept CAN FD with Big data Rx messages (65536 &gt; Rx payload &gt; 4095).
  
Test Object: 
    CanTp receives segmented messages with message lengths &gt; 4095.
    CanTp is able to receive CAN FD messages longer than 4095 and smaller than 65536 bytes if CAN
    flexible data is On.
  
Test Precondition: 
    - Configured Rx N-SDU with standard addressing format and ECUC N-SDU length &gt; 4095.
    - CanTpFlexibleDataRateSupport is equal to CANTP_ON.
  
Test Execution: 
    01: Initialize CanTp.
    02: Start a segmented reception for an standard addressing configured Rx N-SDU.
    03: VP(CanTp.EB.BigData_Rx, CanTp.EB.CanFD_Rx_BigData): Verify that PduR_CanTpStartOfReception()
        is called with correct parameters.
    04: VP(CanTp.EB.BigData_Rx, CanTp.EB.CanFD_Rx_BigData): Verify that PduR_CanTpCopyRxData() is
        called with correct parameters.
    05: VP(CanTp.EB.BigData_Rx, CanTp.EB.CanFD_Rx_BigData): Verify CanIf_Transmit() call, is called with correct
        padding value for Flow Control frame.
    06: VP(CanTp.EB.BigData_Rx, CanTp.EB.CanFD_Rx_BigData): Verify that PduR_CanTpCopyRxData() is
        called with correct parameters for all consecutive frames.
    07: Check padding values for FC(CTS);
    08: VP(CanTp.EB.BigData_Rx, CanTp.EB.CanFD_Rx_BigData): Verify that PduR_CanTpCopyRxData() is
        called with correct parameters for the last consecutive frame.
    09: VP(CanTp.EB.BigData_Rx, CanTp.EB.CanFD_Rx_BigData): Verify that PduR_CanTpRxIndication() is
        called with correct parameters, hence all message segments are copied to the upper buffer
        and the PduR in triggered.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.BigData_Rx</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>707</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.CanFD_Rx_BigData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>694</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00347_CAN2.0</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>271</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00347_CANFD</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>272</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1164</internalId></specobject>
    <specobject>
      <id>CanTp_ConTest10_003_BigData_Rx_FF_Format_Mixed_Addr</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest10_DiffPaddingValues/source/application/CanTp_ConTest10_DiffPaddingValues.c</sourcefile>
      <sourceline>1162</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The module shall be able to receive a segmented message with more than 4095 bytes.
    The module shall accept CAN FD with Big data Rx messages (65536 &gt; Rx payload &gt; 4095).
  
Test Object: 
    CanTp accepts FF_DL lengths greater than 4095 and less than 65535.
  
Test Precondition: 
    - Configured Rx N-SDU with standard addressing format and ECUC N-SDU length &gt; 4095.
  
Test Execution: 
    01: Initialize CanTp.
    02: Start a segmented reception for an extended addressing configured Rx N-SDU.
    03: VP(CanTp.EB.BigData_Rx_FF_Format): Verify that PduR_CanTpStartOfReception() is called
        with correct parameters.
    04: VP(CanTp.EB.BigData_Rx_FF_Format): Verify that PduR_CanTpCopyRxData() is called
        with correct parameters.
    05: VP(CanTp.EB.BigData_Rx_FF_Format): Verify CanIf_Transmit() call, is called with correct
        padding value for Flow Control frame.
    06: VP(CanTp.EB.BigData_Rx_FF_Format): Verify that PduR_CanTpCopyRxData() is
        called with correct parameters for all consecutive frames.
    07: VP(CanTp.EB.BigData_Rx_FF_Format): Verify that PduR_CanTpCopyRxData() is
        called with correct parameters for the last consecutive frame.
    08: VP(CanTp.EB.BigData_Rx_FF_Format): Verify that PduR_CanTpRxIndication() is
        called with correct parameters, hence all message segments are copied to the upper buffer
        and the PduR in triggered.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.BigData_Rx</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>707</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.CanFD_Rx_BigData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>694</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00347_CANFD</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>272</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1165</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>CanTp_ConTest11001_FCWAIT_NBrWTTimeoutEnabled</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest11_DifferentTimeoutRepeatedFCWAIT/source/application/CanTp_ConTest11_DiffTimeoutRepFCWAIT.c</sourcefile>
      <sourceline>81</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    If CanTpNbrWaitRepeatedSupport is enabled and if the N-SDU to be sent has CanTpNbrWaitRepeated enabled,
	the module shall use N_Br_WT timer when sending any subsequent FC WAIT PDU.
    Used addressing: extended.
  
Test Object: 
    CanTp module shall use CanTpNbrWaitRepeated timer, when sending any subsequent FC WAIT PDU.
  
Test Precondition: 
    - Configured Rx N-SDU with extended addressing format and ECUC N-SDU length &lt; 4095.
  
Test Execution: 
    01: Initialize CanTp.
    02: Send extended FF. Data is not relevant for this test.
    03: Check that PduR_CanTpStartOfReception was called for FF.
    04: Wait until N_Br timer expires.
    05: Check that PduR_CanTpCopyRxData was called for FC.
    06: Check that FC was sent because of unavailable buffer (BUFREQ_E_BUSY or BUFREQ_OK with smaller buffer than needed for the next block).
    07: TxConfirmation for FC WAIT arrives before N_Ar expires.
    08: Check that PduR_CanTpCopyRxData was called for FC.
    09: Sanity check: Expect that FC(WAIT) was sent,
    	because of unavailable buffer (BUFREQ_E_BUSY or BUFREQ_OK with smaller buffer than needed for the next block).
    10: TxConfirmation for second FC(WAIT) frame arrives, before N_Ar timer expires.
    11: For transmitting the next FC(WAIT),  N_Br_WT timer has to expire.
    12: Check that PduR_CanTpCopyRxData was called for the third FC(WAIT).
    13: Sanity check: Expect that FC(WAIT) was sent,
    	because of unavailable buffer (BUFREQ_E_BUSY or BUFREQ_OK with smaller buffer than needed for the next block).
    14: TxConfirmation for the third FC(WAIT) arrives before N_Ar timer expires.
    15: PduR_CanTpCopyRxData returns BUFREQ_OK.
    16: For transmitting FC(CTS),  N_Br timer has to expire.
    17: Check that PduR_CanTpCopyRxData was called.
    18: Sanity check: Expect that FC(CTS) was sent.
    19: TxConfirmation for FC(CTS) arrives before N_Ar timer expires.
    20: Send first block of CFs.
    21: Check that PduR_CanTpCopyRxData was called for CF.
    22: Expect that FC(CTS) was sent.
    23: TxConfirmation arrives before N_Ar expires
    24: Send last CF.
    25: Check that PduR_CanTpCopyRxData was called for last CF.
    26: RxIndication to PduR is called, to indicate a successful reception.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.NbrWaitRepeated_AfterFF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>738</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1166</internalId></specobject>
    <specobject>
      <id>CanTp_ConTest11002_FCWAIT_NBrWTTimeoutDisabled</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest11_DifferentTimeoutRepeatedFCWAIT/source/application/CanTp_ConTest11_DiffTimeoutRepFCWAIT.c</sourcefile>
      <sourceline>360</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    If CanTpNbrWaitRepeatedSupport is enabled and if the N-SDU to be sent has CanTpNbrWaitRepeated disabled,
	the module shall use N_Br timer when sending any subsequent FC WAIT PDU.
    Used addressing: extended.
  
Test Object: 
    If CanTpNbrWaitRepeated is disabled, CanTp module shall NOT use CanTpNbrWaitRepeated timer when sending any subsequent FC WAIT PDU. 
  
Test Precondition: 
    - Configured Rx N-SDU with extended addressing format and ECUC N-SDU length &lt; 4095.
  
Test Execution: 
    01: Initialize CanTp.
    02: Send extended FF. Data is not relevant for this test.
    03: Check that PduR_CanTpStartOfReception was called for FF.
    04: Wait until N_Br timer expires.
    05: Check that PduR_CanTpCopyRxData was called for FC.
    06: Check that FC was sent, because of unavailable buffer 
	   (BUFREQ_E_BUSY or BUFREQ_OK with smaller buffer than needed for the next block).
    07: TxConfirmation for FC WAIT arrives before N_Ar expires.
    08: Check that PduR_CanTpCopyRxData was called for FC.
    09: Sanity check: Expect that FC(WAIT) was sent.
    10: TxConfirmation for second FC(WAIT) frame arrives, before N_Ar timer expires.
    11: For transmitting the next FC(WAIT),  N_Br timer has to expire.
    12: Check that PduR_CanTpCopyRxData was called for the third FC(WAIT).
    13: Sanity check: Expect that FC(WAIT) was sent, 
	    because of unavailable buffer (BUFREQ_E_BUSY or BUFREQ_OK with smaller buffer than needed for the next block).
    14: TxConfirmation for the third FC(WAIT) arrives before N_Ar timer expires.
    15: PduR_CanTpCopyRxData returns BUFREQ_OK.
    16: For transmitting FC(CTS),  N_Br timer has to expire.
    17: Check that PduR_CanTpCopyRxData was called.
    18: Sanity check: Expect that FC(CTS) was sent.
    19: TxConfirmation for FC(CTS) arrives before N_Ar timer expires.
    20: Send first block of CFs.
    21: Check that PduR_CanTpCopyRxData was called for CF.
    22: Expect that FC(CTS) was sent.
    23: TxConfirmation arrives before N_Ar expires
    24: Send last CF.
    25: Check that PduR_CanTpCopyRxData was called for last CF.
    26: RxIndication to PduR is called, to indicate a successful reception.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.NbrWaitRepeated_AfterFF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>738</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1167</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>CanTp_ConTest12_001_Rx_FF_CAN20_CANTP_ON_CAN_CAN_FD</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest12_MandatoryPaddingOfCanFDPdus/source/application/CanTp_ConTest12_MandatoryPaddingOfCanFDPdus.c</sourcefile>
      <sourceline>160</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    If CAN FD is enabled and Padding Activation is equal to CANTP_ON_CAN_CAN_FD,
    the module shall always send FCs, or receive last CFs with N_PDU
    frame length value equal to 8 bytes for CAN 2.0 frames.
  
Test Object: 
    CAN 2.0 FF and last CF, reception: CAN flexible data ON
  
Test Precondition: 
    - Addressing is standard
    - CanTpFlexibleDataRateSupport is equal to STD_ON
    - RxPaddingActivation equals CANTP_ON_CAN_CAN_FD
    - Use SF &amp; last CF to stimulate CanTp
  
Test Execution: 
    01: Initialize CanTp module.
    02: Receive a standard addressing Rx NSdus.
    03: Verify that PduR_CanTpStartOfReception() is called with
        correct parameters.
    04: Verify that PduR_CanTpCopyTxData() is called with
        correct parameters.
    05: VP(CanTp.SWS_CanTp_00351.CANTP_ON_CAN_CAN_FD.CAN_20): Verify that CanIf_Transmit() is called with correct
        parameters for sending a FC(CTS).
    06: VP(CanTp.SWS_CanTp_00351.CANTP_ON_CAN_CAN_FD.CAN_20): Verify that FC(CTS) is padded to 8 for a CAN 2.0 message.
    07: Verify that PduR_CanTpCopyRxData() is called.
    08: Check that FC is padded to the correct length
    09: Check that CF is padded to the correct length
    10: Check that PduR_CanTpCopyRxData() was called for the last CF
    11: Check that PduR_CanTpRxIndication() was called to indicate a successful reception.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00347.CANTP_ON_CAN_CAN_FD.CAN20_frames</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>273</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00351.CANTP_ON_CAN_CAN_FD.CAN_20</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>286</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1168</internalId></specobject>
    <specobject>
      <id>CanTp_ConTest12_002_Tx_SF_CAN20_CANTP_ON_CAN_CAN_FD</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest12_MandatoryPaddingOfCanFDPdus/source/application/CanTp_ConTest12_MandatoryPaddingOfCanFDPdus.c</sourcefile>
      <sourceline>384</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    If CAN FD is enabled and Tx Padding Activation is equal to CANTP_ON_CAN_CAN_FD,
    the module shall always send SFs with N_PDU frame length value equal to 8 bytes for CAN 2.0 frames.
  
Test Object: 
    SF transmitted frames: CAN flexible data ON
  
Test Precondition: 
    - Addressing is standard and mixed
    - CanTpFlexibleDataRateSupport is equal to STD_ON
    - TxPaddingActivation equals CANTP_ON_CAN_CAN_FD
    - Use (CAN 2.0) SF to stimulate CanTp
  
Test Execution: 
    01: Initialize CanTp module.
    02: Start a SF transmission for a standard and mixed addressing configured Tx N-SDU.
    03: Call CanTp_MainFunction triggering data to be sent.
    04: Request available buffer for SF (CAN 2.0) by calling PduR_CanTpCopyTxData().
    05: Check that CanIf_Transmit() was called for CAN 2.0 Single Frame transmission.
    06: Check that SduLength was indeed 8 bytes.
    07: Check that Single Frame is padded to the correct length
        (8 bytes for a CAN 2.0 message) and uses the correct value for padding
    08: Confirm sent SF to CanTp.
    09: Expect a positive Tx confirmation signaled to PduR.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00348.CANTP_ON_CAN_CAN_FD.CAN2.0_frames</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>279</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1169</internalId></specobject>
    <specobject>
      <id>CanTp_ConTest12_003_Tx_SF_CANFD_CANTP_ON_CAN_CAN_FD</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest12_MandatoryPaddingOfCanFDPdus/source/application/CanTp_ConTest12_MandatoryPaddingOfCanFDPdus.c</sourcefile>
      <sourceline>542</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    If CAN FD is enabled and Tx Padding Activation is equal to CANTP_ON_CAN_CAN_FD,
    the module shall always send SFs, with N_PDU frame length value equal to 64 bytes for CAN FD frames.
  
Test Object: 
    SF transmitted frames: CAN flexible data ON
  
Test Precondition: 
    - Addressing is mixed, standard, extended
    - CanTpFlexibleDataRateSupport is equal to STD_ON
    - TxPaddingActivation equals CANTP_ON_CAN_CAN_FD
    - Use SF (CAN FD) to stimulate CanTp
  
Test Execution: 
    01: Initialize CanTp module.
    02: Check that CanIf_Transmit() was called for CAN FD Single Frame transmission.
    03: Call CanTp_MainFunction triggering data to be sent.
    04: Request available buffer for SF (CAN 2.0) by calling PduR_CanTpCopyTxData().
    05: Check that CanIf_Transmit was called for CAN FD Single Frame.
    06: Check that Single Frame is padded to the correct length
        (64 bytes for a CAN FD messages) and uses the correct value for padding.
    07: Confirm sent SF to CanTp.
    08: Expect a positive Tx confirmation signaled to PduR with correct parameter.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00351.CANTP_ON_CAN_CAN_FD.CAN_FD</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>287</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00348.CANTP_ON_CAN_CAN_FD.CAN-FD_frames</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>278</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1170</internalId></specobject>
    <specobject>
      <id>CanTp_ConTest12_004_Tx_FF_RxFC_lastCF_CAN20_CANFD_CANTP_ON_CAN_CAN_FD</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest12_MandatoryPaddingOfCanFDPdus/source/application/CanTp_ConTest12_MandatoryPaddingOfCanFDPdus.c</sourcefile>
      <sourceline>701</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    If CAN FD is enabled and TxPaddingActivation and RxPaddingActivation is configured to CANTP_ON_CAN_CAN_FD
    the module shall always send First Frames (FFs), receive Flow Control Frames (FCs)
    and transmit last Consecutive Frames (CFs) with length equal to 64 bytes for CAN FD frames.
    Unused byte shall be padded with CANFD padding value if configured;
    otherwise CAN 2.0 padding value shall be used.
  
Test Object: 
    - Transmit First Frame
    - Receive Flow Control with length 64 bytes
    - Transmit last CF padded until 64 bytes
  
Test Precondition: 
    - Addressing is standard
    - CanTpFlexibleDataRateSupport is equal to STD_ON
    - Use FF &amp; last CF to stimulate CanTp
  
Test Execution: 
    01: Flush trace to eliminate test-case dependencies.
    02: Reset stubs.
    03: Sent data needs to be checked.
    04: Initialize CanTp module.
    05: Start a First Frame transmission for an extended configured Tx N-SDU.
    06: Call CanTp_MainFunction triggering data to be sent.
    07: Check that PduR_CanTpCopyTxData() is called with
        correct parameters.
    08: Check that CanIf_Tranmsit is called for FF
    09: Check that the sent frame towards CanIf is a FF.
    10: Confirm sent FF.
    11: Initialize NPCI lengths depending of frame type and addressing type
    12: Verify that PduR_CanTpCopyTxData() is called with correct parameters.
    13: Check if CanIf_Transmit() is called with correct parameters.
    14: Receiving a CF confirmation triggers CAN TP to send next message.
    15: Check that PduR_CanTpCopyTxData() was called for CF.
    16: Check that CF was transmitted.
    17: PduR_CanTpCopyTxData() is called.
    18: Check CanIf is called with correct L-SDU ID, frame type and sequence number, for last CF.
    19: Check if unused bytes of the last Consecutive Frame are padded with CAN FD padding value,
        for CAN FD and small CAN FD frames.
    20: Confirm sent CF.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00351.CANTP_ON_CAN_CAN_FD.CAN_FD</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>287</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00348.CANTP_ON_CAN_CAN_FD.CAN-FD_frames</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>278</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00348.CANTP_ON_CAN_CAN_FD.CAN2.0_frames</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>279</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Receiving.RxFC.UnexpectedLengths</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>744</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1171</internalId></specobject>
    <specobject>
      <id>CanTp_ConTest12_005_Rx_FF_CANFD_CANTP_ON_CAN_CAN_FD</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest12_MandatoryPaddingOfCanFDPdus/source/application/CanTp_ConTest12_MandatoryPaddingOfCanFDPdus.c</sourcefile>
      <sourceline>964</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    If CAN FD is enabled and Padding Activation is equal to CANTP_ON_CAN_CAN_FD,
    the module shall always send FCs, or receive last CFs with N_PDU
    frame length value equal to 64 bytes for CAN FD frames or 8 bytes for CAN 2.0 frames.
  
Test Object: 
    SF last CF transmitted frames: CAN flexible data ON
  
Test Precondition: 
    - Addressing is standard
    - CanTpFlexibleDataRateSupport is equal to STD_ON
    - RxPaddingActivation equals CANTP_ON_CAN_CAN_FD
    - Use SF &amp; last CF to stimulate CanTp
  
Test Execution: 
    01: Initialize CanTp module.
    02: Receive a standard addressing Rx NSdus.
    03: Verify that PduR_CanTpStartOfReception() is called with
        correct parameters.
    04: Verify that PduR_CanTpCopyTxData() is called with
        correct parameters.
    05: VP(CanTp.SWS_CanTp_00351.CANTP_ON_CAN_CAN_FD.CAN_FD): Verify that CanIf_Transmit() is called with correct
        parameters for sending a FC(CTS).
    06: VP(CanTp.SWS_CanTp_00351.CANTP_ON_CAN_CAN_FD.CAN_FD): Verify that FC(CTS) is padded to 8 for a CAN 2.0 message
        and to 64 for a CAN FD message.
    07: Verify that PduR_CanTpCopyRxData() is called with
        correct parameters after receiving CF
    08: Check that FC is padded to the correct length
    09: Check that last CF is padded to the correct length
    10: Check that PduR_CanTpCopyRxData() was called for the last CF
    11: Check that PduR_CanTpRxIndication() was called to indicate a successful reception.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00351.CANTP_ON_CAN_CAN_FD.CAN_FD</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>287</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00347.CANTP_ON_CAN_CAN_FD.CANFD_frames</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>274</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1172</internalId></specobject>
    <specobject>
      <id>CanTp_ConTest12_006_InvalidRxLength_CANTP_ON_CAN_CAN_FD_CANFD_frames</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest12_MandatoryPaddingOfCanFDPdus/source/application/CanTp_ConTest12_MandatoryPaddingOfCanFDPdus.c</sourcefile>
      <sourceline>1210</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CAN TP reports a DET error when an invalid PDU length is given at reception
    (N_PCI valid, SDU Length wrong) [padding enabled].
  
Test Object: 
    Error detection
  
Test Precondition: 
    Module compiled with DET enabled.
    Padding enabled.
  
Test Execution: 
    01: Simulate reception of SF with invalid SduLength.
    02: VP(CanTp.EB.Rx.Padding.InvalidRxLength):
        Check that Det error CANTP_E_INVALID_RX_LENGTH is reported.
    03: Simulate reception of FF with valid SduLength.
    04: Check that PduR_CanTpCopyRxData() was called for the last CF
    05: Check that PduR_CanTpRxIndication() was called to indicate a successful reception.
    06: VP(CanTp.EB.Rx.Padding.InvalidRxLength):
        Check that Det error CANTP_E_INVALID_RX_LENGTH is reported.
    07: Continue with a reception until CF is expected.
    08: Simulate reception of CF with invalid SduLength.
    09: VP(CanTp.EB.Rx.Padding.InvalidRxLength):
        Check that Det error CANTP_E_INVALID_RX_LENGTH is reported.
    10: Start a transmission and continue until FC is expected.
    11: Simulate reception of FC frame with invalid SduLength.
    12: VP(CanTp.EB.Rx.Padding.InvalidRxLength):
        Check that Det error CANTP_E_INVALID_RX_LENGTH is reported.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00021</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>86</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00132</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>93</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00344.CANTP_ON_CAN_CAN_FD.CAN-FD_frames</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>262</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00345.CANTP_ON_CAN_CAN_FD.CAN-FD_frames</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>265</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00346.CANTP_ON_CAN_CAN_FD.CAN-FD_frames</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>268</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Rx.Padding.CANTP_ON_CAN_CAN_FD.InvalidRxLength.CAN-FD_frame</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>628</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1173</internalId></specobject>
    <specobject>
      <id>CanTp_ConTest12_007_InvalidRxLength_CANTP_ON_CAN_CAN_FD_CAN20_frames</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest12_MandatoryPaddingOfCanFDPdus/source/application/CanTp_ConTest12_MandatoryPaddingOfCanFDPdus.c</sourcefile>
      <sourceline>1435</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CAN TP reports a DET error when an invalid PDU length is given at reception
    (N_PCI valid, SDU Length wrong) [padding enabled].
  
Test Object: 
    Error detection
  
Test Precondition: 
    Module compiled with DET enabled.
    Padding enabled.
  
Test Execution: 
    01: Simulate reception of SF with invalid SduLength.
    02: VP(CanTp.EB.Rx.Padding.InvalidRxLength):
        Check that Det error CANTP_E_INVALID_RX_LENGTH is reported.
    03: Simulate reception of FF with invalid SduLength.
    04: VP(CanTp.EB.Rx.Padding.InvalidRxLength):
        Check that Det error CANTP_E_INVALID_RX_LENGTH is reported.
    05: VP(CanTp.ISO2016.InvalidFF_DL):
        Check that FF with payload greater than 4096 are accepted.
    06: Simulate reception of CF with invalid SduLength.
    07: VP(CanTp.EB.Rx.Padding.InvalidRxLength):
        Check that Det error CANTP_E_INVALID_RX_LENGTH is reported.
    08: Start a transmission and continue until FC is expected.
    09: Simulate reception of FC frame with invalid SduLength.
    10: VP(CanTp.EB.Rx.Padding.InvalidRxLength):
        Check that Det error CANTP_E_INVALID_RX_LENGTH is reported.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ISO2016.InvalidFF_DL</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>902</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00021</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>86</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00132</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>93</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Rx.Padding.InvalidRxLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>627</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00344.CANTP_ON_CAN_CAN_FD.CAN2.0_frames</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>263</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00345.CANTP_ON_CAN_CAN_FD.CAN2.0_frames</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>266</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00346.CANTP_ON_CAN_CAN_FD.CAN2.0_frames</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>269</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Rx.Padding.CANTP_ON_CAN_CAN_FD.InvalidRxLength.CAN2.0_frame</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>629</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1174</internalId></specobject>
    <specobject>
      <id>CanTp_ConTest12_008_InvalidRxLength_LastCF_frame</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest12_MandatoryPaddingOfCanFDPdus/source/application/CanTp_ConTest12_MandatoryPaddingOfCanFDPdus.c</sourcefile>
      <sourceline>1647</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    If CAN FD is enabled and Padding Activation is equal to CANTP_ON_CAN_CAN_FD,
    the module shall always send FCs, or receive last CFs with N_PDU
    frame length value equal to 64 bytes for CAN FD frames or 8 bytes for CAN 2.0 frames.
  
Test Object: 
    SF last CF transmitted frames: CAN flexible data ON
  
Test Precondition: 
    - Addressing is standard
    - CanTpFlexibleDataRateSupport is equal to STD_ON
    - RxPaddingActivation equals CANTP_ON_CAN_CAN_FD
    - Use SF &amp; last CF to stimulate CanTp
  
Test Execution: 
    01: Initialize CanTp module.
    02: Receive a standard addressing Rx NSdus.
    03: Verify that PduR_CanTpStartOfReception() is called with
        correct parameters.
    04: Verify that PduR_CanTpCopyTxData() is called with
        correct parameters.
    05: VP(CanTp.SWS_CanTp_00351.CANTP_ON_CAN_CAN_FD.CAN_FD): Verify that CanIf_Transmit() is called with correct
        parameters for sending a FC(CTS).
    06: VP(CanTp.SWS_CanTp_00351.CANTP_ON_CAN_CAN_FD.CAN_FD): Verify that FC(CTS) is padded to 8 for a CAN 2.0 message
        and to 64 for a CAN FD message.
    07: Verify that PduR_CanTpCopyRxData() is called with
        correct parameters after receiving CF
    08: Check that DET error is reported when a last CF with an invalid value is received
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00351.CANTP_ON_CAN_CAN_FD.CAN_FD</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>287</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00344.CANTP_ON_CAN_CAN_FD.CAN-FD_frames</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>262</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1175</internalId></specobject>
    <specobject>
      <id>CanTp_ConTest12_009_FC_CANFD_8bytes_PADDING_CANTP_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest12_MandatoryPaddingOfCanFDPdus/source/application/CanTp_ConTest12_MandatoryPaddingOfCanFDPdus.c</sourcefile>
      <sourceline>1866</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    If CAN FD is enabled and Padding Activation is equal to CANTP_ON, while CanIdType = STANDARD_FD_CAN or EXTENDED_FD_CAN
    the module shall pad the sent FCs, or the last CFs with N_PDU frame length value equal to 8 bytes with CanTpPaddingByteCanFD
    instead of CanTpPaddingByte.
  
Test Object: 
    SF last CF transmitted frames: CAN flexible data ON
  
Test Precondition: 
    - Addressing is standard
    - CanIdType is STANDARD_FD_CAN
    - CanTpFlexibleDataRateSupport is equal to STD_ON
    - RxPaddingActivation equals CANTP_ON
  
Test Execution: 
    01: Initialize CanTp module.
    02: Receive a standard addressing Rx NSdus with CanIdType STANDARD_FD_CAN.
    03: Check that PduR_CanTpStartOfReception() is called with the expected RxPduId.
    04: Check that PduR_CanTpCopyTxData() is called with expected RxPduId.
    05: Check that CanIf_Transmit() is called with correct parameters indicating that a FC(CTS) is sent.
    06: VP(CanTp.SWS_CanTp_00347_CANFD): Verify that FC(CTS) is padded to 8 bytes for small CANFD frames
        with padding value=CanTpPaddingByteCanFD.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00347_CANFD</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>272</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1176</internalId></specobject>
    <specobject>
      <id>CanTp_ConTest12_010_lastCF_CANFD_8bytes_PADDING_CANTP_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest12_MandatoryPaddingOfCanFDPdus/source/application/CanTp_ConTest12_MandatoryPaddingOfCanFDPdus.c</sourcefile>
      <sourceline>1978</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    If CAN FD is enabled and TxPaddingActivation and RxPaddingActivation is configured to CANTP_ON
    the module shall always send First Frames (FFs), receive Flow Control Frames (FCs)
    and transmit last Consecutive Frames (CFs) with length equal to 8 bytes for small CAN FD frames.
    Unused byte shall be padded with CANFD padding value if configured while CanIdType is configured either
    STANDARD_FD_CAN or EXTENDED_FD_CAN
    otherwise CAN 2.0 padding value shall be used.
  
Test Object: 
    - Transmit First Frame
    - Receive Flow Control with length 8 bytes
    - Transmit last CF padded until 8 bytes
  
Test Precondition: 
    - Addressing is standard
    - CanTpFlexibleDataRateSupport is equal to STD_ON
    - PaddingActivation is equal to CANTP_ON for Tx, Rx, TxFc Npdus
    - CanIdType is equal to STANDARD_FD_CAN for Tx, Rx, TxFc Npdus
    - Use FF &amp; last CF to stimulate CanTp
  
Test Execution: 
    01: Flush trace to eliminate test-case dependencies.
    02: Reset stubs.
    03: Initialize CanTp module.
    04: Sent data needs to be checked.
    05: Start a First Frame transmission for an Standard configured Tx N-SDU.
    06: Call CanTp_MainFunction triggering data to be sent.
    07: Check that PduR_CanTpCopyTxData() is called with
        correct parameters.
    08: Check that CanIf_Tranmsit is called for FF.
    09: Check that the sent frame towards CanIf is a FF.
    10: Confirmation for sent FF.
    11: Initialize NPCI lengths.
    12: Check that PduR_CanTpCopyTxData() is called with correct parameters.
    13: Check if CanIf_Transmit() is called with correct parameters.
    14: Receiving a CF confirmation triggers CAN TP to send next message.
    15: Check that PduR_CanTpCopyTxData() was called for CF.
    16: Check that CF was transmitted.
    17: Check that PduR_CanTpCopyTxData() is called for Last CF.
    18: Check CanIf is called with correct L-SDU ID, frame type and sequence number, for last CF.
    19: VP(CanTp.SWS_CanTp_00348_2): Verify that unused bytes of the last Consecutive Frame
        are padded with CAN FD padding value, for small CAN FD frames, until the valid length of 8 bytes.
    20: Confirm sent last CF.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00348_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>277</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1177</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_ConTest13_01_UINT32_PduLengthType_Transmit_CANFD_MF</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest13_UINT32_PduLengthType_Support/source/application/Tests.c</sourcefile>
      <sourceline>89</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify whether transmission of a CAN FD MF is handled properly even if the SduLength is
    of type UINT32.
  
Test Object: 
    Successful transmission of a CAN FD frame with SduLength of type uint32.
  
Test Precondition: 
    CanTp module shall be initialized.
  
Test Execution: 
    01: Initialize CanTp module
    02: Start transmission of a CANFD multi frame, with length equals 65600.
    03: Call CanTp_MainFunction to start the multi frame transmission.
    04: Check if PduR_CanTpCopyTxData was called for CAN FD MF
    05: Check that the FF was transmitted, even if SduLength was of type uint32
    06: Check that the sent frame towards CanIf is a FF.
    07: Check that the towards CanIf sent frame's 2'nd N_PCI byte is 0x00.
    08: Check that the messageLength fit in the frame from byte 2 to byte 5,
        for Standard Addressing format.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.PDULENGTHTYPE001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>971</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1178</internalId></specobject>
    <specobject>
      <id>TS_CANTP_ConTest13_02_UINT32_PduLengthType_RxIndication</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest13_UINT32_PduLengthType_Support/source/application/Tests.c</sourcefile>
      <sourceline>211</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify whether reception of a CAN 2.0/CAN FD SF and reception of CAN 2.0/CAN FD MF
    is handled properly even if the SduLength is of type UINT32.
  
Test Object: 
    Reception of a CAN 2.0/CAN FD Single Frame and CAN 2.0/CAN FD Multi Frame with SduLength of type uint32.
  
Test Precondition: 
    CanTp module shall be initialized.
  
Test Execution: 
    01: Initialize CanTp module
    02: Receive a CAN 2.0 SF with SduLength of type uint32
        Data is not relevant for this test.
    03: Check that Det_ReportError was called,
        when receiving an invalid SduLength
    04: Prepare CAN 2.0 SF data to be received
    05: Receive a CAN 2.0 SF with SduLength of type uint32
        Data is not relevant for this test.
    06: Check that Det_ReportError was called,
        when receiving an invalid SduLength
    07: Prepare CAN 2.0 FF data to be received
    08: Receive a CAN 2.0 FF with SduLength of type uint32
        Data is not relevant for this test.
    09: Check that Det_ReportError was called,
        when receiving an invalid SduLength
    10: Receive a CAN-FD FF with SduLength of type uint32
        Data is not relevant for this test.
    11: Check that Det_ReportError was called
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.PDULENGTHTYPE001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>971</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1179</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_RequestNewTransmissionFromTxConfirmation_SF</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest14_TxConfirmationRequestNewTransmission/source/application/Tests.c</sourcefile>
      <sourceline>89</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    Test that a new single frame transmission request for the same PduId is accepted in context of the PduR_CanTpTxConfirmation.
  
Test Object: 
    Single frame transmission
  
Test Precondition: 
    Normal addressing mode.
  
Test Execution: 
    01: VP(CanTp.ASR40.Transmit.E_OK):
        Call CanTp_Transmit() with PduId 0 and SduLength 7 (maximum size of SF)
        in normal addressing mode and check that it returns E_OK.
    02: Check that CanIf_Transmit() is not called.
    03: Elapse a MainFunction tick.
    04: VP(CanTp.ASR40.SWS_CanTp_00226, CanTp.SWS_CanTp_00299_1, CanTp.SWS_CanTp_00272, CanTp.SWS_CanTp_00216_5,
           CanTp.ASR40.TxNoRetry):
        Verify whether PduR_CanTpCopyTxData() is called with SduLength 7 and
        RetryInfoPtr as NULL_PTR.
    05: VP(CanTp.SWS_CanTp_00231_1, CanTp.SWS_CanTp_00216_1, CanTp.11247, CanTp.11299):
        Verify whether CanIf_Transmit() is called to transmit SF with SduLength 8 and verify
        that the data transmitted is same as that provided by PduR.
    06: Call CanTp_TxConfirmation() to confirm the Pdu sent.
    07: VP(CanTp.SWS_CanTp_00204, CanTp.SWS_CanTp_00177, CanTp.SWS_CanTp_00216_8):
        Verify whether PduR_CanTpTxConfirmation is called with result E_OK.
    08: Elapse a MainFunction tick.
    09: VP(CanTp.Design.AllowCanTp_Transmit_FromContext_PduR_CanTpTxConfirmation):
        Verify that a new tranmission is being requested and processed within the context of
        last PduR_CanTpTxConfirmation
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00226</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>25</internalId></provcov>
        <provcov>
          <linksto>CanTp.11247</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>828</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00177</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>143</internalId></provcov>
        <provcov>
          <linksto>CanTp.11299</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>844</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00231_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>353</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00216_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>403</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00204</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>359</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00299_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>364</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00272</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>204</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00216_8</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>409</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.Transmit.E_OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>501</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00216_5</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>405</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.TxNoRetry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>539</internalId></provcov>
        <provcov>
          <linksto>CanTp.Design.AllowCanTp_Transmit_FromContext_PduR_CanTpTxConfirmation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1180</internalId></specobject>
    <specobject>
      <id>TS_CANTP_RequestNewTransmissionFromTxConfirmation_MultiFrame</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest14_TxConfirmationRequestNewTransmission/source/application/Tests.c</sourcefile>
      <sourceline>246</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    Test that a new multi-frame transmission request for the same PduId is accepted in context of the PduR_CanTpTxConfirmation.
  
Test Object: 
    Message transmission
  
Test Precondition: 
    - Padding disabled
    - Extended addressing mode.
  
Test Execution: 
    01: Call CanTp_Transmit() with PduId 2 and SduLength 7 bytes (minimum message length)
        in extended addressing mode and check that it returns E_OK.
    02: Check that CanIf_Transmit() is not called.
    03: Elapse a MainFunction tick.
    04: Verify whether PduR_CanTpCopyTxData() is called with SduLength 5.
    05: VP(CanTp.11249, CanTp.11265, CanTp.11307,
           CanTp.SWS_CanTp_00281_ExtendedAdr, CanTp.SWS_CanTp_00232):
        Verify whether CanIf_Transmit() is called to transmit FF with SduLength 8.
    06: Call CanTp_TxConfirmation to confirm the transmission of FF.
    07: Simulate the reception of FC CTS with NSdu length 8(only 4 bytes are valid).
    08: VP(CanTp.EB.Padding.CANTP_OFF.Receiving.CAN20_RxFC.AcceptedLengths.EXTENDED.MIXED):
        Verify whether PduR_CanTpCopyTxData() is called with SduLength 2.
    09: VP(CanTp.11249, CanTp.11258, CanTp.11307, CanTp.SWS_CanTp_00232):
        Verify whether CanIf_Transmit() is called to transmit CF with SduLength 4.
    10: Call CanTp_TxConfirmation to confirm the transmission of CF.
    11: VP(CanTp.SWS_CanTp_00177):
        Verify whether PduR_CanTpTxConfirmation() is called with result E_OK.
    12: Elapse a MainFunction tick.
    13. VP(CanTp.Design.AllowCanTp_Transmit_FromContext_PduR_CanTpTxConfirmation):
        Verify that a new tranmission is being requested and processed within the context of
        last PduR_CanTpTxConfirmation.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00281_ExtendedAdr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>226</internalId></provcov>
        <provcov>
          <linksto>CanTp.11249</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>831</internalId></provcov>
        <provcov>
          <linksto>CanTp.11258</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>852</internalId></provcov>
        <provcov>
          <linksto>CanTp.11265</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>850</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00177</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>143</internalId></provcov>
        <provcov>
          <linksto>CanTp.11307</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>838</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00232</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>357</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Padding.CANTP_OFF.Receiving.CAN20_RxFC.AcceptedLengths.EXTENDED.MIXED</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>741</internalId></provcov>
        <provcov>
          <linksto>CanTp.Design.AllowCanTp_Transmit_FromContext_PduR_CanTpTxConfirmation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1181</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_Check_ChannelIdx_Type</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest15_ChannelIndexType/source/application/Tests.c</sourcefile>
      <sourceline>84</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Received First Frames for which the local channel index is 371 of type UIN16,
  
Test Object: 
    Check the Channel ID has the correct type
  
Test Precondition: 
  
Test Execution: 
    01: Simulate reception of FF, for which the calculated local index for the channel is 371
    02: Check that for reception id 196, the right channel index was assigned (UINT16 type)
        and the channel index was not truncated to UINT8.
    03: VP(CanTp.SWS_CanTp_00057_HalfDuplex_2):
        Verify whether PduR_CanTpCopyRxData() is called.
    04: Verify whether CanIf_Transmit() is called for ID = 196.
    05: Call CanTp_TxConfirmation() to confirm transmission of FC frame.
    06: CF1 is received
    07: Verify whether PduR_CanTpCopyRxData() is called for RxNSdu with ID 196.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00190</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>243</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1182</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_ConTest16_001_CAN20_FC_Lengths_NoPadding_NormalPadding_CanFDPadding</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest16_FC_MinMaxLengths/source/application/Tests.c</sourcefile>
      <sourceline>57</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The CanTp module shall accept the following FC frames:
      1. STANDARD CAN 2.0 FC if padding CANTP_OFF =&gt; 3 bytes to 8 bytes
      2. EXTENDED CAN 2.0 FC if padding CANTP_OFF =&gt; 4 bytes to 8 bytes
      3. STANDARD CAN 2.0 FC if padding CANTP_ON =&gt; 8 bytes
      4. EXTENDED CAN 2.0 FC if padding CANTP_ON =&gt; 8 bytes
      5. STANDARD CAN 2.0 FC if padding CANTP_ON_CAN_CAN_FD =&gt; 8 bytes
      6. EXTENDED CAN 2.0 FC if padding CANTP_ON_CAN_CAN_FD =&gt; 8 bytes
  
Test Object: 
    1a) accepted lengths for STANDARD CAN 2.0 FC if padding CANTP_OFF =&gt; 3 bytes to 8 bytes
    1b) accepted lengths for EXTENDED CAN 2.0 FC if padding CANTP_OFF =&gt; 4 bytes to 8 bytes
    2a) accepted lengths for STANDARD CAN 2.0 FC if padding CANTP_ON =&gt; 8 bytes
    2b) accepted lengths for EXTENDED CAN 2.0 FC if padding CANTP_ON =&gt; 8 bytes
    3a) accepted lengths for STANDARD CAN 2.0 FC if padding CANTP_ON_CAN_CAN_FD =&gt; 8 bytes
    3b) accepted lengths for EXTENDED CAN 2.0 FC if padding CANTP_ON_CAN_CAN_FD =&gt; 8 bytes
  
Test Precondition: 
    - Send a CAN 2.0 FF and the transmission shall be a successful one.
  
Test Execution: 
    01: Initialize CanTp.

    02: Start a CAN2.0 FF transmission for a STANDARD addressing configured Tx
        N-SDU, which has CanTpTxPaddingActivation set to CANTP_OFF.
    03: Call CanTp_MainFunction triggering data to be sent.
    04: VP(CanTp.SWS_CanTp_00351): Verify that CanIf_Transmit() is called with correct
        parameters.
    05: A FC frame with min length of  4,5,6,7  bytes is received
    06: VP(CanTp.EB.Padding.CANTP_OFF.Receiving.CAN20_RxFC.AcceptedLengths.STANDARD):
        Check that FC was accepted and CF was transmitted.
    07: A FC frame with exact length of 3 bytes is received
    08: VP(CanTp.EB.Padding.CANTP_OFF.Receiving.CAN20_RxFC.AcceptedLengths.STANDARD):
        Check that FC was accepted and the CF1 was sent.

    09: Start a CAN2.0 FF transmission for an EXTENDED addressing configured Tx
        N-SDU, which has CanTpTxPaddingActivation set to CANTP_OFF.
    10: Call CanTp_MainFunction triggering data to be sent.
    11: VP(CanTp.SWS_CanTp_00351): Verify that CanIf_Transmit() is called with correct
        parameters.
    12: A FC frame with min length of  5,6,7  bytes is received
    13: VP(CanTp.EB.Padding.CANTP_OFF.Receiving.CAN20_RxFC.AcceptedLengths.EXTENDED.MIXED):
        Check that FC was accepted and CF was transmitted.
    14: A FC frame with min length of 3 bytes is received
    15: VP(CanTp.EB.Receiving.RxFC.UnexpectedLengths):
        Check that it was rejected, because the length was 3, DET was called and PduR was notified.
    16: A FC frame with exact length of 4 bytes is received
    17: VP(CanTp.EB.Padding.CANTP_OFF.Receiving.CAN20_RxFC.AcceptedLengths.EXTENDED.MIXED):
        Check that FC was accepted and the CF1 was sent.

    18: Start a CAN2.0 FF transmission for an STANDARD addressing configured Tx
        N-SDU, which has CanTpTxPaddingActivation set to CANTP_ON.
    19: Call CanTp_MainFunction triggering data to be sent.
    20: VP(CanTp.SWS_CanTp_00351): Verify that CanIf_Transmit() is called with correct
        parameters.
    21: A FC frame with min length of  3,4,5,6,7  bytes is received
    22: VP(CanTp.EB.Receiving.RxFC.UnexpectedLengths):
        Check that it was rejected, because the length was not greater or equal to 8 bytes,
        DET was called.
    23: A FC frame with exact length of 8 bytes is received
    24: VP(CanTp.SWS_CanTp_00349.CANTP_ON.Receiving.CAN20_RxFC.AcceptedLength):
        Check that FC was accepted and the CF1 was sent.

    25: Start a CAN2.0 FF transmission for an STANDARD addressing configured Tx
        N-SDU, which has CanTpTxPaddingActivation set to CANTP_ON_CAN_CAN_FD.
    26: Call CanTp_MainFunction triggering data to be sent.
    27: VP(CanTp.SWS_CanTp_00351): Verify that CanIf_Transmit() is called with correct
        parameters.
    28: A FC frame with min length of  3,4,5,6,7  bytes is received
    29: VP(CanTp.EB.Receiving.RxFC.UnexpectedLengths):
        Check that it was rejected, because the length was not greater or equal to 8 bytes,
        DET was called.
    30: A FC frame with exact length of 8 bytes is received
    31: VP(CanTp.SWS_CanTp_00349.CANTP_ON_CAN_CAN_FD.Receiving.CAN20_RxFC.AcceptedLength):
        Check that FC was accepted and the CF1 was sent.

  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00351</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>285</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00098</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>88</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Padding.CANTP_OFF.Receiving.CAN20_RxFC.AcceptedLengths.STANDARD</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>740</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Padding.CANTP_OFF.Receiving.CAN20_RxFC.AcceptedLengths.EXTENDED.MIXED</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>741</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Receiving.RxFC.UnexpectedLengths</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>744</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00349.CANTP_ON.Receiving.CAN20_RxFC.AcceptedLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>281</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00349.CANTP_ON_CAN_CAN_FD.Receiving.CAN20_RxFC.AcceptedLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>282</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1183</internalId></specobject>
    <specobject>
      <id>TS_CANTP_ConTest16_002_CANFD_FC_Lengths_NoPadding_NormalPadding_CanFDPadding</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_ConTest16_FC_MinMaxLengths/source/application/Tests.c</sourcefile>
      <sourceline>474</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    The CanTp module shall accept the following FC frames:
      1. STANDARD CAN FD FC if padding CANTP_OFF =&gt; 3 bytes to 8 bytes
      2. EXTENDED CAN FD FC if padding CANTP_OFF =&gt; 4 bytes to 8 bytes
      3. STANDARD CAN FD FC if padding CANTP_ON =&gt; MaxPduLength cofigured in EcuC
      4. EXTENDED CAN FD FC if padding CANTP_ON =&gt; MaxPduLength cofigured in EcuC
      5. STANDARD CAN FD FC if padding CANTP_ON_CAN_CAN_FD =&gt; 64 bytes
      6. EXTENDED CAN FD FC if padding CANTP_ON_CAN_CAN_FD =&gt; 64 bytes
  
Test Object: 
    1a) accepted lengths for STANDARD CAN FD FC if padding CANTP_OFF =&gt; 3 bytes to 8 bytes (11 is considered unexpected length)
    1b) accepted lengths for EXTENDED CAN FD FC if padding CANTP_OFF =&gt; 4 bytes to 8 bytes (11 is considered unexpected length)
    2a) accepted lengths for STANDARD CAN FD FC if padding CANTP_ON =&gt; MaxPduLength
    2b) accepted lengths for EXTENDED CAN FD FC if padding CANTP_ON =&gt; MaxPduLength
    3a) accepted lengths for STANDARD CAN FD FC if padding CANTP_ON_CAN_CAN_FD =&gt; 64 bytes
    3b) accepted lengths for EXTENDED CAN FD FC if padding CANTP_ON_CAN_CAN_FD =&gt; 64 bytes
  
Test Precondition: 
    - Send a CAN FD FF and the transmission shall be a successful one.
  
Test Execution: 
    01: Initialize CanTp.

    02: Start a CANFD FF transmission for a STANDARD addressing configured Tx
        N-SDU, which has CanTpTxPaddingActivation set to CANTP_OFF.
    03: Call CanTp_MainFunction triggering data to be sent.
    04: VP(CanTp.SWS_CanTp_00351): Verify that CanIf_Transmit() is called with correct
        parameters.
    05: A FC frame with min length of  4,5,6,7,11  bytes is received
    06: VP(CanTp.EB.Padding.CANTP_OFF.Receiving.CANFD.RxFC.AcceptedLengths.STANDARD):
        Check that FC was accepted and CF was transmitted.
    07: A FC frame with min length of  11  bytes is received
    08: VP(CanTp.EB.Receiving.RxFC.UnexpectedLengths):
         Check that it was rejected, because the length was out of boundaries (3 &lt;= length &lt;=8),
         DET was called and PduR was notified.
    09: A FC frame with exact length of 3 bytes is received
    10: VP(CanTp.EB.Padding.CANTP_OFF.Receiving.CANFD.RxFC.AcceptedLengths.STANDARD):
        Check that FC was accepted and the CF1 was sent.

    11: Start a CANFD FF transmission for a EXTENDED addressing configured Tx
        N-SDU, which has CanTpTxPaddingActivation set to CANTP_OFF.
    12: Call CanTp_MainFunction triggering data to be sent.
    13: VP(CanTp.SWS_CanTp_00351): Verify that CanIf_Transmit() is called with correct
        parameters.
    14: A FC frame with min length of  5,6,7 bytes is received
    15: VP(CanTp.EB.Padding.CANTP_OFF.Receiving.CANFD.RxFC.AcceptedLengths.EXTENDED.MIXED):
        Check that FC was accepted and CF was transmitted.
    16: A FC frame with min length of 11 bytes is received
    17: VP(CanTp.EB.Receiving.RxFC.UnexpectedLengths):
       Check that it was rejected, because the length was out of boundaries (4 &lt;= length &lt;=8),
       DET was called and PduR was notified.
    18: A FC frame with exact length of 4 bytes is received
    19: VP(CanTp.EB.Padding.CANTP_OFF.Receiving.CANFD.RxFC.AcceptedLengths.EXTENDED.MIXED):
        Check that FC was accepted and the CF1 was sent.

    20: Start a CAN FD FF transmission for a STANDARD addressing configured Tx
        N-SDU, which has CanTpTxPaddingActivation set to CANTP_ON.
    21: Call CanTp_MainFunction triggering data to be sent.
    22: VP(CanTp.SWS_CanTp_00351): Verify that CanIf_Transmit() is called with correct
        parameters.
    23: A FC frame with min length of  3,4,5,6,7,11  bytes is received
    24: VP(CanTp.EB.Receiving.RxFC.UnexpectedLengths):
        Check that it was rejected, because the length was not equal to 12 bytes,
        DET was called.
    25: A FC frame with exact length of  12  bytes is received
    26: VP(CanTp.SWS_CanTp_00349.CANTP_ON.Receiving.CANFD.RxFC.AcceptedLengths):
        Check that FC was accepted and the CF1 was sent.

    27: Start a CAN FD FF transmission for a STANDARD addressing configured Tx
        N-SDU, which has CanTpTxPaddingActivation set to CANTP_ON_CAN_CAN_FD.
    28: Call CanTp_MainFunction triggering data to be sent.
    29: VP(CanTp.EB.ASR42.SWS_CanTp_00351): Verify that CanIf_Transmit() is called with correct
        parameters.
    30: A FC frame with length of 3,..,63 bytes is received
    31: VP(CanTp.EB.Receiving.RxFC.UnexpectedLengths):
        Check that it was rejected, because the length was not equal to 64 bytes,
        DET was called.
    32: A FC frame with exact length of 64 bytes is received
    33: VP(CanTp.SWS_CanTp_00349.CANTP_ON_CAN_CAN_FD.Receiving.CANFD_RxFC.AcceptedLength):
        Check that FC was accepted and the CF1 was sent.

  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00351</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>285</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00098</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>88</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Padding.CANTP_OFF.Receiving.CANFD.RxFC.AcceptedLengths.STANDARD</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>742</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Padding.CANTP_OFF.Receiving.CANFD.RxFC.AcceptedLengths.EXTENDED.MIXED</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>743</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Receiving.RxFC.UnexpectedLengths</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>744</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00349.CANTP_ON.Receiving.CANFD.RxFC.AcceptedLengths</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>283</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00349.CANTP_ON_CAN_CAN_FD.Receiving.CANFD_RxFC.AcceptedLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>284</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1184</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_30143</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>145</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that CANTP_MODULE_ID is properly defined.
  
Test Object: 
    Module ID
  
Test Precondition: 
  
Test Execution: 
    01: VP(CanTp.ASR40.SWS_CanTp_00115):
        Include CanTp.h and verify that CANTP_MODULE_ID is defined and equal to 0x23.
  
Test Input: 
  
Test Output: 
    CANTP_MODULE_ID is defined and has the correct value.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00115</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>39</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1185</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30039</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>193</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The CAN Transport Layer must not try to process calls when in the CANTP_OFF
    state (which must be the state before CanTp_Init() is called). Calling API
    functions in this state must result in calls to DET providing the Service ID
    of the API function which has been called.

    Since "not processing any calls" could also be seen as definition of the
    CANTP_OFF state, this test also covers SWS_CanTp_00168 and SWS_CanTp_00238.
  
Test Object: 
    CanTp state machine
  
Test Precondition: 
    DET enabled.
    CAN TP module not initialized.
  
Test Execution: 
   01: VP(CanTp.ASR40.Transmit.E_NOT_OK1, CanTp.SWS_CanTp_00168, CanTp.SWS_CanTp_00238):
       Call CanTp_Transmit and verify that it returned E_NOT_OK.
   02: VP(CanTp.SWS_CanTp_00031):
       Check if Det error CANTP_E_UNINIT is reported.
   03: Call CanTp_RxIndication.
   04: VP(CanTp.SWS_CanTp_00031, CanTp.SWS_CanTp_00168, CanTp.SWS_CanTp_00238):
       Check if Det error CANTP_E_UNINIT is reported and the frame is not processed.
   05: Call CanTp_TxConfirmation.
   06: VP(CanTp.SWS_CanTp_00031, CanTp.SWS_CanTp_00168):
       Check if Det error CANTP_E_UNINIT is reported.
   07: VP(CanTp.ASR40.CancelTransmit.E_NOT_OK, CanTp.SWS_CanTp_00168):
       Call CanTp_CancelTransmit and verify that it returned E_NOT_OK.
   08: VP(CanTp.SWS_CanTp_00031):
       Check if Det error CANTP_E_UNINIT is reported.
   09: VP(CanTp.ASR40.ChangeParameter.E_NOT_OK, CanTp.SWS_CanTp_00168):
       Call CanTp_ChangeParameter and verify that it returned E_NOT_OK.
   10: VP(CanTp.SWS_CanTp_00031):
       Check if Det error CANTP_E_UNINIT is reported.
   11: VP(CanTp.ASR40.ReadParameter.E_NOT_OK, CanTp.SWS_CanTp_00168):
       Call CanTp_ReadParameter and verify that it returned E_NOT_OK.
   12: VP(CanTp.SWS_CanTp_00031):
       Check if Det error CANTP_E_UNINIT is reported.
   13: VP(CanTp.ASR40.CancelReceive.E_NOT_OK, CanTp.SWS_CanTp_00168):
       Call CanTp_CancelReceive and verify that it returned E_NOT_OK.
   14: VP(CanTp.SWS_CanTp_00031):
       Check if Det error CANTP_E_UNINIT is reported.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00168</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>124</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00238</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>127</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00031</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>138</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.ChangeParameter.E_NOT_OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>529</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.ReadParameter.E_NOT_OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>532</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.CancelTransmit.E_NOT_OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>525</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.CancelReceive.E_NOT_OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>521</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.Transmit.E_NOT_OK1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>499</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1186</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30484</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>439</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test CanTp_MainFunction() prior to module initialization.
  
Test Object: 
    CanTp_MainFunction()
  
Test Precondition: 
    Module uninitialized.
  
Test Execution: 
    01: Call CanTp_MainFunction().
    02: VP(CanTp.EB.11582):
    Check if no development error is reported by CanTp_MainFunction().
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.11582</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>586</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1187</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30317</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>490</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test CanTp_GetVersionInfo() prior to module initialization and compare the
    returned values with the version macros.
  
Test Object: 
    CanTp_GetVersionInfo()
  
Test Precondition: 
    Module uninitialized.
    CANTP_VERSION_INFO_API should be enabled.
  
Test Execution: 
    01: Call CanTp_GetVersionInfo().
    02: VP(CanTp.EB.GetVersionInfo):
        Verify result.
  
Test Input: 
  
Test Output: 
    Comparison matches.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.GetVersionInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>550</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1188</internalId></specobject>
    <specobject>
      <id>TS_CANTP_EnableGpt</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>552</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check whether notifications are enabled for Gpt channels during CanTp
    initialization.
  
Test Object: 
    CanTp_Init()
  
Test Precondition: 
    GPT usage should be enabled
  
Test Execution: 
    01: Call CanTp_Init().
    02: VP(CanTp.EB.Init.Gpt):
        Verify whether Gpt_EnableNotification is called for enabling the callback notifications
        for all configured Gpt channels.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.Init.Gpt</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>549</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1189</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30047</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>607</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Put the CAN TP into the CANTP_ON state (necessary to run the following
    tests). Test CanTp_GetVersionInfo() after module initalization and compare
    the returned values with the version macros.
  
Test Object: 
    CanTp_GetVersionInfo()
  
Test Precondition: 
    Module uninitialized.
  
Test Execution: 
    01: Call CanTp_Init() followed by CanTp_GetVersionInfo().
    02: VP(CanTp.ASR40.SWS_CanTp_00162):
        Verify result.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00162</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>41</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1190</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30136</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>668</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanTp_Init() called during a transmission (CAN TP sends) will abort the
    transmission and changes the state to IDLE.
  
Test Object: 
    CanTp_Init()
  
Test Precondition: 
    Ongoing transmission (segmented message).
  
Test Execution: 
    01: Start a transmission and check that the request is accepted and processed.
    02: Call CanTp_TxConfirmation() to confirm the FF sent.
    03: Call CanTp_Init(), this should stop current transfer.
    04: Simulate reception of Flow Control frame.
    05: VP(CanTp.SWS_CanTp_00030_3, CanTp.SWS_CanTp_00273, CanTp.SWS_CanTp_00111):
        Check if the FC frame is ignored as the current transmission got stopped(global variables
        got reset).
    06: VP(CanTp.SWS_CanTp_00030_3, CanTp.SWS_CanTp_00273, CanTp.SWS_CanTp_00111):
        Verify that another transmit request for the same NSdu is accepted and finish
        the transmission.
  
Test Input: 
  
Test Output: 
    Current transfer stopped:
    No more data is sent by CAN TP after the call to CanTp_Init().
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00030_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>137</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00111</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>139</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00273</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>140</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1191</internalId></specobject>
    <specobject>
      <id>TS_CANTP_RX_WAIT</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>788</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the reception is not progressed when CanTp_Init is called in between and the state
    gets changed to IDLE.
  
Test Object: 
    Ongoing reception
  
Test Precondition: 
    CanTp should be initialized.
    Configure normal addressing mode.
  
Test Execution: 
    01: Simulate reception of FF with message length as 27 on PduId 0.
    02: VP(CanTp.SWS_CanTp_00216_7):
        Verify whether PduR_CanTpStartOfReception() is called with TpSduLength 27.
    03: Verify whether PduR_CanTpCopyRxData() is called with SduLength 6.
    04: VP(CanTp.11268_3):
        Verify whether CanIf_Transmit() is called to send FC frame.
    05: Call CanTp_TxConfirmation() to confirm transmission of FC frame.
    06: Call CanTp_Init().
    07: Verify that the reception got aborted and PduR is notified with E_NOT_OK.
    08: Simulate reception of CF with SN 1.
    09: VP(CanTp.SWS_CanTp_00030_3, CanTp.SWS_CanTp_00273, CanTp.SWS_CanTp_00111):
        Verify that PduR_CanTpCopyRxData() is not get called indicating that the CF is not accepted
        as ongoing reception got aborted and the state got changed to IDLE.
    10: Simulate reception of SF on PduId 0.
    11: VP(CanTp.SWS_CanTp_00273, CanTp.SWS_CanTp_00111):
        Verify that the SF is accepted and received succesfully, as the state is IDLE.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.11268_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>864</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00030_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>137</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00216_7</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>408</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00111</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>139</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00273</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>140</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1192</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30048</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>944</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test transmission of a Single Frame of the maximum size in normal addressing mode.
  
Test Object: 
    Single frame transmission
  
Test Precondition: 
    Normal addressing mode.
  
Test Execution: 
    01: VP(CanTp.ASR40.Transmit.E_OK):
        Call CanTp_Transmit() with PduId 0 and SduLength 7 (maximum size of SF)
        in normal addressing mode and check that it returns E_OK.
    02: VP(CanTp.SWS_CanTp_00176):
        Verify that CanIf_Transmit() is not called.
    03: Elapse a MainFunction tick.
    04: VP(CanTp.ASR40.SWS_CanTp_00226, CanTp.SWS_CanTp_00299_1, CanTp.SWS_CanTp_00272, CanTp.SWS_CanTp_00216_5,
           CanTp.ASR40.TxNoRetry):
        Verify whether PduR_CanTpCopyTxData() is called with SduLength 7 and
        RetryInfoPtr as NULL_PTR.
    05: VP(CanTp.SWS_CanTp_00231_1, CanTp.SWS_CanTp_00216_1, CanTp.11247, CanTp.11299):
        Verify whether CanIf_Transmit() is called to transmit SF with SduLength 8 and verify
        that the data transmitted is same as that provided by PduR.
    06: Call CanTp_TxConfirmation() to confirm the Pdu sent.
    07: VP(CanTp.SWS_CanTp_00204, CanTp.SWS_CanTp_00177, CanTp.SWS_CanTp_00216_8):
        Verify whether PduR_CanTpTxConfirmation is called with result E_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00176</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>142</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00226</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>25</internalId></provcov>
        <provcov>
          <linksto>CanTp.11247</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>828</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00177</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>143</internalId></provcov>
        <provcov>
          <linksto>CanTp.11299</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>844</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00231_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>353</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00216_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>403</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00204</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>359</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00299_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>364</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00272</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>204</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00216_8</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>409</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.Transmit.E_OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>501</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00216_5</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>405</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.TxNoRetry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>539</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1193</internalId></specobject>
    <specobject>
      <id>TS_CANTP_DynamicStminBS_GptTicks</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>1113</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test that CanTp module allow dynamic assign for BS and Stmin during the transmision of the same pduId.
    while CanTpSTminTimeoutHandling is set to Gpt
  
Test Object: 
    Dynamic Assign for BS and Stmin during the transmision of the same pduId.
  
Test Precondition: 
    CanTpSTminTimeoutHandling is set to Gpt
    CanTp module is initialized by the call of CanTp_Init function.
  
Test Execution: 
    01: Call CanTp_Transmit() with PduId 0 and SduLength 22
        in normal addressing mode and check that it returns E_OK.
    02: Check that CanIf_Transmit() is not called.
    03: Elapse a MainFunction tick.
    04: Check whether PduR_CanTpCopyTxData() is called with the correct TxPduId and SduLength = 6.
    05: Check whether CanIf_Transmit() called to transmit FF with SduLength 8 and 6 data bytes.
    06: Call CanTp_TxConfirmation() to confirm transmission of FF.
    07: Simulate the reception of FC CTS frame with Stmin = 1 and BS = 1.
    08: Check whether PduR_CanTpCopyTxData() is called with SduLength 7 for 1st CF.
    09: Check whether CanIf Transmit() is called to transmit 1st CF with SduLength 8 and 7 data bytes.
    10: Call CanTp_TxConfirmation() to confirm transmission of the 1st CF.
    11: Simulate the reception of FC CTS frame with Stmin = 2 and BS = 2.
    12: Check whether PduR_CanTpCopyTxData() is called with SduLength 7 for the 2nd CF.
    13: Check whether CanIf Transmit() is called to transmit 2nd CF with SduLength 8 and 7 data bytes.
    14: Call CanTp_TxConfirmation() to confirm transmission of 2nd CF.
    15: VP(CanTp.ISO2016.DynamicStminBS):
        Verify whether Gpt timeout has been set to ((2000+1)/2)+1 equivalent to Stmin value = 2ms.
    16: Check whether PduR_CanTpCopyTxData() is called with SduLength 2 for the last CF.
    17: Elapse some Mainfunction ticks and check that transmission of CF is not initiated by MainFunction ticks.
    18: Simulate a Gpt timeout.
    19: Check whether CanIf Transmit() is called to transmit last CF with SduLength 3 and 2 data bytes.
    20: Call CanTp_TxConfirmation() to confirm transmission of the last CF.
    21: Check whether PduR_CanTpTxConfirmation is called with the correct TxPduId and Result = E_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ISO2016.DynamicStminBS</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>901</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1194</internalId></specobject>
    <specobject>
      <id>TS_CANTP_DynamicStminBS_MainFunctionTicks</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>1310</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test that CanTp module allow dynamic assign for BS and Stmin during the transmision of the same pduId.
    while CanTpSTminTimeoutHandling is set to CanTpMainFunction
  
Test Object: 
    Dynamic Assign for BS and Stmin during the transmision of the same pduId.
  
Test Precondition: 
    CanTpSTminTimeoutHandling is set to CanTpMainFunction
    CanTp module is initialized by the call of CanTp_Init function.
  
Test Execution: 
    01: Call CanTp_Transmit() with PduId 9 and SduLength 22
        in normal addressing mode and check that it returns E_OK.
    02: Check that CanIf_Transmit() is not called.
    03: Elapse a MainFunction tick.
    04: Check whether PduR_CanTpCopyTxData() is called with the correct TxPduId and SduLength = 6.
    05: Check whether CanIf_Transmit() called to transmit FF with SduLength 8 and 6 data bytes.
    06: Call CanTp_TxConfirmation() to confirm transmission of FF.
    07: Simulate the reception of FC CTS frame with Stmin = 1 and BS = 1.
    08: Check whether PduR_CanTpCopyTxData() is called with SduLength 7 for 1st CF.
    09: Check whether CanIf Transmit() is called to transmit 1st CF with SduLength 8 and 7 data bytes.
    10: Call CanTp_TxConfirmation() to confirm transmission of the 1st CF.
    11: Simulate the reception of FC CTS frame with Stmin = 2 and BS = 2.
    12: Check whether PduR_CanTpCopyTxData() is called with SduLength 7 for the 2nd CF.
    13: Check whether CanIf Transmit() is called to transmit 2nd CF with SduLength 8 and 7 data bytes.
    14: Call CanTp_TxConfirmation() to confirm transmission of 2nd CF.
    15: Check whether PduR_CanTpCopyTxData() is called with SduLength 2 for the last CF.
    16: VP(CanTp.ISO2016.DynamicStminBS):
        Verify whether Stmin took 2 more MainFunction ticks before it sends the next CF
        Stmin value = 2ms. while MainFunctionPeriod = 1ms , MFticks = (2/1) + 1
    17: Check whether CanIf Transmit() is called to transmit last CF with SduLength 3 and 2 data bytes.
    18: Call CanTp_TxConfirmation() to confirm transmission of the last CF.
    19: Check whether PduR_CanTpTxConfirmation is called with the correct TxPduId and Result = E_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ISO2016.DynamicStminBS</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>901</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1195</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30053</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>1502</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test transmission of a the minimum data size that must be split into several frames in normal
    addressing mode.
  
Test Object: 
    Message transmission
  
Test Precondition: 
    Normal addressing mode.
  
Test Execution: 
    01: VP(CanTp.ASR40.Transmit.E_OK, CanTp.SWS_CanTp_00238):
        Call CanTp_Transmit() with PduId 0 and SduLength 8 (minimum size of segmented message)
        in normal addressing mode and check that it returns E_OK.
    02: VP(CanTp.SWS_CanTp_00176):
        Verify that CanIf_Transmit() is not called.
    03: Elapse a MainFunction tick.
    04: VP(CanTp.SWS_CanTp_00216_5_1):
        Verify whether PduR_CanTpCopyTxData() is called with
        TxPduId = PduRConf_PduRRoutingPath_0_PduRDestPdu_0 (PduRDestPduHandleId of PduRDestPdu_0
                  which is referenced to Pdu that is also referenced by CanTpTxNSdu0)
        SduLength = 6.
    05: VP(CanTp.SWS_CanTp_00232, CanTp.11249):
        Verify whether CanIf_Transmit() called to transmit FF with SduLength 8 and 6 data bytes.
    06: Call CanTp_TxConfirmation() to confirm transmission of FF.
    07: Simulate the reception of FC CTS frame with PduId 9.
    08: Verify whether PduR_CanTpCopyTxData() is called with SduLength 2.
    09: VP(CanTp.11249, CanTp.11258):
        Check whether CanIf Transmit() is called to transmit CF with SduLength 3.
    10: Call CanTp_TxConfirmation() to confirm transmission of CF.
    11: VP(CanTp.SWS_CanTp_00177, CanTp.SWS_CanTp_00216_8_1):
        Check whether PduR_CanTpTxConfirmation is called with
        TxPduId = PduRConf_PduRRoutingPath_0_PduRDestPdu_0(PduRDestPduHandleId of PduRDestPdu_0
                  which is referenced to Pdu that is also referenced by CanTpTxNSdu0)
        Result = E_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00176</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>142</internalId></provcov>
        <provcov>
          <linksto>CanTp.11249</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>831</internalId></provcov>
        <provcov>
          <linksto>CanTp.11258</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>852</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00177</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>143</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00232</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>357</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.Transmit.E_OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>501</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00216_5_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>406</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00216_8_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>410</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00238</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>127</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1196</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30054</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>1686</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test transmission of a Single Frame of the maximum size in extended addressing mode.
  
Test Object: 
    Message transmission
  
Test Precondition: 
  
Test Execution: 
    Loop over steps 01 to 06 for different N-Pdu length from 1 to 6
    01: Call CanTp_Transmit() with PduId 2 and SduLength as in input
        in extended addressing mode and check that it returns E_OK.
    02: Elapse a MainFunction tick.
    03: VP(CanTp.ASR40.SWS_CanTp_00226):
        Verify whether PduR_CanTpCopyTxData() is called with N-Sdu length as in output.
    04: VP(CanTp.SWS_CanTp_00216_1, CanTp.SWS_CanTp_00231_2,
           CanTp.11226, CanTp.11248, CanTp.11256, CanTp.11298):
        Verify whether CanIf_Transmit() is called to transmit SF with SduLength as in output and
        N_TA 1.
    05: Call CanTp_TxConfirmation to confirm transmission of SF.
    06: VP(CanTp.SWS_CanTp_00090):
        Verify whether PduR_CanTpTxConfirmation is called with result E_OK.
  
Test Input: 
   01: 1 2 3 4 5 6
  
Test Output: 
   03: 1 2 3 4 5 6
   04: 3 4 5 6 7 8
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00090</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>217</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00281_ExtendedAdr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>226</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00226</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>25</internalId></provcov>
        <provcov>
          <linksto>CanTp.11226</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>827</internalId></provcov>
        <provcov>
          <linksto>CanTp.11248</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>829</internalId></provcov>
        <provcov>
          <linksto>CanTp.11256</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>839</internalId></provcov>
        <provcov>
          <linksto>CanTp.11298</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>843</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00216_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>403</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00231_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>354</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1197</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30055</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>1831</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test the transmission of minimum data size that must be split into several frames in extended
    addressing mode.
  
Test Object: 
    Message transmission
  
Test Precondition: 
    - Padding disabled
    - Extended addressing mode.
  
Test Execution: 
    01: Call CanTp_Transmit() with PduId 2 and SduLength 7 bytes (minimum message length)
        in extended addressing mode and check that it returns E_OK.
    02: VP(CanTp.SWS_CanTp_00176):
        Verify that CanIf_Transmit() is not called.
    03: Elapse a MainFunction tick.
    04: Verify whether PduR_CanTpCopyTxData() is called with SduLength 5.
    05: VP(CanTp.11249, CanTp.11265, CanTp.11307,
           CanTp.SWS_CanTp_00281_ExtendedAdr, CanTp.SWS_CanTp_00232):
        Verify whether CanIf_Transmit() is called to transmit FF with SduLength 8.
    06: Call CanTp_TxConfirmation to confirm the transmission of FF.
    07: Simulate the reception of FC CTS with NSdu length 8(only 4 bytes are valid).
    08: VP(CanTp.EB.Padding.CANTP_OFF.Receiving.CAN20_RxFC.AcceptedLengths.EXTENDED.MIXED):
        Verify whether PduR_CanTpCopyTxData() is called with SduLength 2.
    09: VP(CanTp.11249, CanTp.11258, CanTp.11307, CanTp.SWS_CanTp_00232):
        Verify whether CanIf_Transmit() is called to transmit CF with SduLength 4.
    10: Call CanTp_TxConfirmation to confirm the transmission of CF.
    11: VP(CanTp.SWS_CanTp_00177):
        Verify whether PduR_CanTpTxConfirmation() is called with result E_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00176</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>142</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00281_ExtendedAdr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>226</internalId></provcov>
        <provcov>
          <linksto>CanTp.11249</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>831</internalId></provcov>
        <provcov>
          <linksto>CanTp.11258</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>852</internalId></provcov>
        <provcov>
          <linksto>CanTp.11265</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>850</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00177</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>143</internalId></provcov>
        <provcov>
          <linksto>CanTp.11307</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>838</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00232</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>357</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Padding.CANTP_OFF.Receiving.CAN20_RxFC.AcceptedLengths.EXTENDED.MIXED</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>741</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1198</internalId></specobject>
    <specobject>
      <id>TS_CANTP_SegMixed_PaddingOff</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>2007</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify the reception of FC is correctly handled in mixed addressing format.
  
Test Object: 
    Message transmission
  
Test Precondition: 
    Padding disabled
  
Test Execution: 
    01: Call CanTp_Transmit() with PduId 2 and SduLength 7 bytes (minimum message length)
        in mixed addressing mode and check that it returns E_OK.
    02: Elapse a MainFunction tick.
    03: Verify whether PduR_CanTpCopyTxData() is called with SduLength 5.
    04: Verify whether CanIf_Transmit() is called to transmit FF with SduLength 8.
    05: Call CanTp_TxConfirmation to confirm the transmission of FF.
    06: Simulate the reception of FC CTS with N_Sdu length 4.
    07: VP(CanTp.EB.Padding.CANTP_OFF.Receiving.CAN20_RxFC.AcceptedLengths.EXTENDED.MIXED):
        Verify whether the FC CTS is accepted and PduR_CanTpCopyTxData is called.
    08: Verify whether CanIf_Transmit() is called to transmit CF with SduLength 4.
    09: Call CanTp_TxConfirmation to confirm the transmission of CF.
    10: VP(CanTp.SWS_CanTp_00177):
        Verify whether PduR_CanTpTxConfirmation() is called with result E_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00177</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>143</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Padding.CANTP_OFF.Receiving.CAN20_RxFC.AcceptedLengths.EXTENDED.MIXED</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>741</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1199</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30056</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>2142</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that all Consecutive Frames except the last one are full with data (in normal addressing
    mode).
  
Test Object: 
    Message transmission
  
Test Precondition: 
  
Test Execution: 
    01: Call CanTp_Transmit() with PduId 0 and SduLength 21 in normal addressing and
        check that it returns E_OK.
    02: Elapse a MainFunction Tick.
    03: Verify whether PduR_CanTpCopyTxData() is called with SduLength 6.
    04: VP(CanTp.11249, CanTp.11258, CanTp.11296, CanTp.SWS_CanTp_00216_1, CanTp.11257):
        Verify whether CanIf_Transmit() is called to transmit FF with SduLength 8.
    05: Call CanTp_TxConfirmation to confirm the transmission of FF.
    06: Simulate the reception of FC frame.
    07: Verify whether Pdu_CanTpCopyTxData() is called with SduLength 7.
    08: VP(CanTp.11249, CanTp.11258, CanTp.11296, CanTp.SWS_CanTp_00216_1):
        Verify whether CanIf_Transmit() is called to transmit CF with SduLength 8 (7 data + 1 NPCI).
    09: Call CanTp_TxConfirmation to confirm the transmission of CF.
    10: Simulate the reception of FC frame.
    11: VP(CanTp.11249)
        Verify whether Pdu_CanTpCopyTxData() is called with SduLength 7.
    12: VP(CanTp.11249, CanTp.11258, CanTp.11296, CanTp.SWS_CanTp_00216_1):
        Verify whether CanIf_Transmit() is called to transmit the next CF with SduLength 8
        (7 data + 1 NPCI).
    13: Call CanTp_TxConfirmation to confirm the transmission of CF.
    14: Simulate the reception of FC frame.
    15: Verify whether Pdu_CanTpCopyTxData() is called with SduLength 1.
    16: VP(CanTp.11249, CanTp.11258, CanTp.11296, CanTp.SWS_CanTp_00216_1):
        Verify whether CanIf_Transmit() is called to transmit the last CF with SduLength 2
        (1 data + 1 NPCI).
    17: Call CanTp_TxConfirmation to confirm the transmission of CF.
    18: Verify whether PduR_CanTpTxConfirmation() is called with result E_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.11249</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>831</internalId></provcov>
        <provcov>
          <linksto>CanTp.11258</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>852</internalId></provcov>
        <provcov>
          <linksto>CanTp.11257</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>846</internalId></provcov>
        <provcov>
          <linksto>CanTp.11296</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>887</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00216_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>403</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1200</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30057</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>2352</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that all Consecutive Frames except the last one are full with data (in extended
    addressing mode).
  
Test Object: 
    Message transmission
  
Test Precondition: 
    - Padding disabled
    - Extended addressing mode.
  
Test Execution: 
    01: Call CanTp_Transmit() with PduId 2 and SduLength 18 in extended addressing mode and
        check that it returns E_OK.
    02: Elapse a MainFunction tick.
    03: Verify whether PduR_CanTpCopyTxData() is called with SduLength 5.
    04: VP(CanTp.11249):
        Verify whether CanIf_Transmit() is called to transmit FF with SduLength 8.
    05: Call CanTp_TxConfirmation() to confirm the transmission of FF.
    06: Simulate reception of FC frame with 4 bytes (N_TA + N_PCI(3 bytes)).
    07: VP(CanTp.EB.Padding.CANTP_OFF.Receiving.CAN20_RxFC.AcceptedLengths.EXTENDED.MIXED):
        Verify whether PduR_CanTpCopyTxData() is called with SduLength 6.
    08: VP(CanTp.11258, CanTp.11249, CanTp.11296):
        Verify whether CanIf_Transmit() is called to transmit CF with SduLength 8 (6 data + 2 NPCI).
    09: Call CanTp_TxConfirmation() to confirm the transmission of CF.
    10: Simulate reception of FC frame with 4 bytes (N_TA + N_PCI(3 bytes)).
    11: VP(CanTp.EB.Padding.CANTP_OFF.Receiving.CAN20_RxFC.AcceptedLengths.EXTENDED.MIXED):
        Verify whether PduR_CanTpCopyTxData() is called with SduLength 6.
    12: VP(CanTp.11258, CanTp.11249, CanTp.11296):
        Verify whether CanIf_Transmit() is called to transmit next CF with SduLength 8
        (6 data + 2 NPCI).
    13: Call CanTp_TxConfirmation() to confirm the transmission of CF.
    14: Simulate reception of FC frame with 4 bytes (N_TA + N_PCI(3 bytes)).
    15: VP(CanTp.EB.Padding.CANTP_OFF.Receiving.CAN20_RxFC.AcceptedLengths.EXTENDED.MIXED):
        Verify whether PduR_CanTpCopyTxData() is called with SduLength 1.
    16: VP(CanTp.11258, CanTp.11249, CanTp.11296):
        Verify whether CanIf_Transmit() is called to transmit last CF with SduLength 3
        (1 data + 2 NPCI).
    17: Call CanTp_TxConfirmation() to confirm the transmission of CF.
    18: VP(CanTp.ASR40.Transmit.Session):
        Verify whether PduR_CanTpTxConfirmation() is called with result E_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.11249</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>831</internalId></provcov>
        <provcov>
          <linksto>CanTp.11258</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>852</internalId></provcov>
        <provcov>
          <linksto>CanTp.11296</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>887</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.Transmit.Session</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>502</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Padding.CANTP_OFF.Receiving.CAN20_RxFC.AcceptedLengths.EXTENDED.MIXED</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>741</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1201</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30089</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>2553</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify sequence number (SN) in sent frames (it should be periodic, from 0 to 15 in increments
    of 1). Normal addressing mode.
  
Test Object: 
    Sequence number
  
Test Precondition: 
    - Padding disabled.
    - Normal addressing mode.
  
Test Execution: 
    01: Call CanTp_Transmit() with PduId 0 and SduLength 132 bytes in normal addressing mode and
        check that it returns E_OK.
    02: Elapse a MainFunction tick.
    03: Verify whether CanIf_Transmit() is called to send FF with SduLength 8.
    04: Call CanTp_TxConfirmation() to confirm transmission of FF.
    05: VP(CanTp.EB.Padding.CANTP_OFF.Receiving.CAN20_RxFC.AcceptedLengths.STANDARD):
        Simulate a reception of FC frame(3 bytes of P_CI bytes) and verify that it is accepted.
    06: Loop steps 07 and 08, 18 times till the last CF is sent.
    07: VP(CanTp.11109, CanTp.11246, CanTp.11258):
        Verify whether CanTp makes CanIf_Transmit() calls to transmit CF.
    08: Call CanTp_TxConfirmation() to confirm transmission of CF.
    09: VP(CanTp.11290, CanTp.11291, CanTp.11293):
        Verify that there is no SN error occurred, SN was periodic.
  
Test Input: 
  
Test Output: 
    CAN TP should send:
    - FF [6 bytes] (SN = 0 implied)
    - CFs [7 bytes] with SN from 1 to 15
    - CFs with SN 0 to 2
    The SN starts from 0 and is incremented by one in each CF. It goes back to 0 after having reached 15.
    The reception of FC frames has no influence on the SN.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.11109</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>855</internalId></provcov>
        <provcov>
          <linksto>CanTp.11246</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>833</internalId></provcov>
        <provcov>
          <linksto>CanTp.11258</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>852</internalId></provcov>
        <provcov>
          <linksto>CanTp.11290</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>856</internalId></provcov>
        <provcov>
          <linksto>CanTp.11291</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>857</internalId></provcov>
        <provcov>
          <linksto>CanTp.11293</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>859</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Padding.CANTP_OFF.Receiving.CAN20_RxFC.AcceptedLengths.STANDARD</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>740</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1202</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30090</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>2702</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify sequence number (SN) in sent frames (it should be periodic, from 0 to 15 in increments
    of 1). Extended addressing mode.
  
Test Object: 
    Sequence number
  
Test Precondition: 
  
Test Execution: 
    01: Call CanTp_Transmit() with PduId 0 and SduLength 113 bytes in extended addressing mode and
        check that it returns E_OK.
    02: Elapse a MainFunction tick.
    03: Verify whether CanIf_Transmit() is called to send FF with SduLength 8.
    04: Call CanTp_TxConfirmation() to confirm transmission of FF.
    05: Simulate a reception of FC frame.
    06: Loop steps 07 and 08, 18 times till the last CF is sent.
    07: VP(CanTp.11109, CanTp.11246, CanTp.11258):
        Verify whether CanTp makes CanIf_Transmit() calls to transmit CF.
    08: Call CanTp_TxConfirmation() to confirm transmission of CF.
    09: VP(CanTp.11290, CanTp.11291, CanTp.11293):
        Verify that there is no SN error occurred, SN was periodic.
  
Test Input: 
  
Test Output: 
    CAN TP should send:
    - FF [5 bytes] (SN = 0 implied)
    - CFs [6 bytes] with SN from 1 to 15
    - CFs with SN 0 to 2
    The SN starts from 0 and is incremented of one in each CF. It goes back to 0 after having reached 15.
    The reception of FC frames has no influence on the SN.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.11109</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>855</internalId></provcov>
        <provcov>
          <linksto>CanTp.11246</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>833</internalId></provcov>
        <provcov>
          <linksto>CanTp.11258</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>852</internalId></provcov>
        <provcov>
          <linksto>CanTp.11290</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>856</internalId></provcov>
        <provcov>
          <linksto>CanTp.11291</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>857</internalId></provcov>
        <provcov>
          <linksto>CanTp.11293</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>859</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1203</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30374</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>2844</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the message length is transmitted in the FF. Normal addressing mode.
  
Test Object: 
    Message length
  
Test Precondition: 
  
Test Execution: 
    01: Call CanTp_Init.
    02: Call CanTp_Transmit in a loop from 8 to 4095 with the loop counter as length parameter.
    03: VP(CanTp.11245):
        Check if length information was sent in FF.
  
Test Input: 
  
Test Output: 
    The value of the loop counter is transmitted in byte 0 and 1 of the FF.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.11245</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>832</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1204</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30375</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>2929</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the message length is transmitted in the FF. Extended addressing mode.
  
Test Object: 
    Message length
  
Test Precondition: 
  
Test Execution: 
    01: Call CanTp_Init.
    02: Call CanTp_Transmit in a loop from 8 to 4095
        with the loop counter as length parameter.
    03: VP(CanTp.11245):
        Check if length information was sent in FF.
  
Test Input: 
  
Test Output: 
    The value of the loop counter is transmitted in byte 1 and 2 of the FF.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.11245</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>832</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1205</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30135</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>3017</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    - Segmented message reception (normal addressing mode).
    - Reception of last CF NSdu frame with normal addressing having
      NSdu length equal to the data length (specified in N_PCI) + header byte (N_PCI).
  
Test Object: 
    Message reception
  
Test Precondition: 
    - Padding disabled
    - CanTp should be initialized.
    - Normal addressing mode.
  
Test Execution: 
    01: VP(CanTp.SWS_CanTp_00238):
        Start reception of a segmented message. Simulate First Frame and verify that the
        reception request is accepted as CanTp is in CANTP_ON state.
    02: Check if Flow Control Frame was sent.
    03: Indicate CF with 7 bytes of data + 1 byte N_PCI.
    04: VP(CanTp.EB.LastCF.RxDataLength_NormalAddressing, CanTp.11257):
        Check that the data is properly reassembled after reception.
        First 6 bytes should be the data from FF indicating that the assembling started from FF.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.LastCF.RxDataLength_NormalAddressing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>611</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00238</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>127</internalId></provcov>
        <provcov>
          <linksto>CanTp.11257</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>846</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1206</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30319</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>3135</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    - Segmented message reception (extended addressing mode)
    - Reception of last CF NSdu frame with extended addressing
      having NSdu length equal to the data length + header byte (N_TA + N_PCI).
  
Test Object: 
    Message reception
  
Test Precondition: 
    - Padding disabled.
    - Extended addressing mode.
  
Test Execution: 
    01: Start reception of a segmented message. Simulate First Frame.
    02: Check if Flow Control Frame was sent.
    03: Indicate CF with 6 bytes of data + 2 bytes N_PCI.
    04: VP(CanTp.EB.LastCF.RxDataLength_ExtendedAddressing):
        Check that the data is properly reassembled after reception.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.LastCF.RxDataLength_ExtendedAddressing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>613</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1207</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30085</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>3235</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CAN TP correctly sends FC frames.
  
Test Object: 
    FC frame transmission
  
Test Precondition: 
  
Test Execution: 
    01: Simulate reception of FF on PduId 0 with length 27.
    02: Verify whether PduR_CanTpStartOfReception() is called with TpSduLength 27.
    03: Verify whether PduR_CanTpCopyRxData() is called with SduLength 6.
    04: VP(CanTp.11268_3, CanTp.11228, CanTp.SWS_CanTp_00030_1a):
        Verify whether CanIf_Transmit() is called to send FC frame with BS 2, which is the
        configured BS value.
    05: Call CanTp_TxConfirmation() to confirm transmission of FC frame.
    06: Simulate reception of CF with SN 1.
    07: VP(CanTp.SWS_CanTp_00216_4):
        Verify whether PduR_CanTpCopyRxData() is called for CF with SduLength 7.
    08: Simulate reception of CF with SN 2.
    09: Verify whether PduR_CanTpCopyRxData() is called with SduLength 7.
    10: VP(CanTp.11268_4):
        Verify whether CanIf_Transmit() is called to send FC frame.
    11: Call CanTp_TxConfirmation() to confirm transmission of FC frame.
    12: Simulate reception of CF with SN 3.
    13: Verify whether PduR_CanTpCopyRxData() is called with SduLength 7.
    14: VP(CanTp.SWS_CanTp_00216_6):
        Verify whether PduR_CanTpRxIndication is called with result E_OK.
    15: VP(CanTp.SWS_CanTp_00116_3):
        Check that only data bytes has been passed to the PduR.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.11228</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>830</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00116_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>256</internalId></provcov>
        <provcov>
          <linksto>CanTp.11268_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>864</internalId></provcov>
        <provcov>
          <linksto>CanTp.11268_4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>865</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00216_6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>407</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00216_4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>404</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00030_1a</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>130</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1208</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30091</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>3441</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Handling of error in sequence number (SN).
  
Test Object: 
    Sequence number errors
  
Test Precondition: 
  
Test Execution: 
    01: Simulate reception of FF on PduId 0.
    02: Verify whether PduR_CanTpStartOfReception and PduR_CanTpCopyRxData() are called.
    03: Verify whether CanIf_Transmit() is called to send FC frame.
    04: Call CanTp_TxConfirmation() to confirm sent FC frame.
    05: Simulate reception of CF with SN 1.
    06: Verify whether PduR_CanTpCopyRxData() is called with SduLength 7.
    07: Simulate reception of CF with SN 2.
    08: Verify whether PduR_CanTpCopyRxData() is called with SduLength 7.
    09: Verify whether CanIf_Transmit() is called to send FC frame.
    10: Call CanTp_TxConfirmation() to confirm sent FC frame.
    11: Simulate reception of CF with SN 4, wrong SN.
    12: VP(CanTp.SWS_CanTp_00314, CanTp.11271, CanTp.SWS_CanTp_00216_6):
        Verify whether reception is aborted and PduR_CanTpRxIndication() is called
        with result E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.11258</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>852</internalId></provcov>
        <provcov>
          <linksto>CanTp.11271</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>860</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00314</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>186</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00216_6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>407</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1209</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30093</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>3585</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the CAN TP respects the given BS when sending data. Part 1/2 (BS &amp;gt; 0).
    Verify FC frame is correctly handled in normal addressing mode(with/without padding bytes)
  
Test Object: 
    Block size handling
  
Test Precondition: 
    - Padding disabled.
    - Normal addressing mode.
  
Test Execution: 
    01: Call CanTp_Transmit() with PduId 0 and SduLength 41 and check that it returns E_OK.
    02: Elapse a MainFunction tick.
    03: VP(CanTp.SWS_CanTp_00216_5):
        Verify whether PduR_CanTpCopyTxData() is called with SduLength 6.
    04: Verify whether CanIf_Transmit() is called to transmit FF with SduLength 8.
    05: Call CanTp_TxConfirmation() to confirm sent FF.
    06: Simulate reception of FC with BS set to 1.
    07: VP(CanTp.SWS_CanTp_00216_5, CanTp.11268_1):
        Verify whether PduR_CanTpCopyTxData() is called with SduLength 7.
    08: Verify whether CanIf_Transmit() is called to transmit CF with SduLength 8.
    09: Call CanTp_TxConfirmation() to confirm the CF sent.
    10: Simulate reception of FC frame with BS set to 4 and last 5 padding bytes.
    11: VP(CanTp.11264, CanTp.EB.Padding.CANTP_OFF.Receiving.CAN20_RxFC.AcceptedLengths.STANDARD):
        Loop steps 12 to 14 four times and verify whether 4 CF are sent.
    12: Verify whether PduR_CanTpCopyTxData() is called with SduLength 7.
    13: Verify whether CanIf_Transmit() is called to transmit CF with SduLength 8.
    14: Call CanTp_TxConfirmation() to confirm the CF sent.
    15: VP(CanTp.11292):
        Verify that no SN error has occurred.
    16: Verify whether PduR_CanTpTxConfirmation is called with E_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.11264</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>878</internalId></provcov>
        <provcov>
          <linksto>CanTp.11292</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>858</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Padding.CANTP_OFF.Receiving.CAN20_RxFC.AcceptedLengths.STANDARD</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>740</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00216_5</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>405</internalId></provcov>
        <provcov>
          <linksto>CanTp.11268_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>862</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1210</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30094</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>3753</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the CAN TP respects the given BS when sending data. Part 2/2 (BS = 0).
  
Test Object: 
    Block size handling
  
Test Precondition: 
  
Test Execution: 
    01: Call CanTp_Transmit() with PduId 0 and SduLength 41 and check that it returns E_OK.
    02: Elapse a MainFunction tick.
    03: Verify whether PduR_CanTpCopyTxData() is called with SduLength 6.
    04: Verify whether CanIf_Transmit() is called to transmit FF with SduLength 8.
    05: Call CanTp_TxConfirmation() to confirm sent FF.
    06: Simulate reception of FC with BS set to 0.
    07: VP(CanTp.11198):
        Loop steps 08 to 10 five times and verify that remaining frame are sent without FC.
    08: Verify whether PduR_CanTpCopyTxData() is called with SduLength 7.
    09: Verify whether CanIf_Transmit() is called to transmit CF with SduLength 8.
    10: Call CanTp_TxConfirmation() to confirm the CF sent.
    11: Verify that no SN error has occurred.
    12: Verify whether PduR_CanTpTxConfirmation is called with E_OK.
  
Test Input: 
  
Test Output: 
    The CAN TP should send all frames without waiting for any FC frame.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.11198</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>877</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1211</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30320</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>3873</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the CAN TP waits when a FC(WAIT) frame is received.
  
Test Object: 
    FC(WAIT) frame reception
  
Test Precondition: 
  
Test Execution: 
    01: Call CanTp_Transmit() with PduId 0 and SduLength 41 and check that it returns E_OK.
    02: Elapse a MainFunction tick.
    03: Verify whether PduR_CanTpCopyTxData() is called with SduLength 6.
    04: Verify whether CanIf_Transmit() is called to transmit FF with SduLength 8.
    05: Call CanTp_TxConfirmation() to confirm the FF sent.
    06: Simulate reception of FC frame with BS 1.
    07: Verify whether PduR_CanTpCopyTxData() is called with SduLength 7.
    08: Verify whether CanIf_Transmit() is called to transmit CF with SduLength 8.
    09: Call CanTp_TxConfirmation() to confirm the CF sent.
    10: Simulate reception of FC frame with BS 2.
    11: Loop steps 12 to 14 two times.
    12: Verify whether PduR_CanTpCopyTxData() is called with SduLength 7.
    13: Verify whether CanIf_Transmit() is called to transmit CF with SduLength 8.
    14: Call CanTp_TxConfirmation() to confirm the CF sent.
    15: Simulate reception of FC WAIT frame.
    16: Elapse two MainFunction ticks.
    17: VP(CanTp.11311, CanTp.SWS_CanTp_00057_HalfDuplex_4, CanTp.11268_1):
        Verify that no frames are transmitted as FC WAIT was received instead of FC CTS.
    18: Simulate reception of FC CTS frame with BS 0.
    19: Loop steps 20 to 22 two times and verify that transmission is resumed.
    20: Verify whether PduR_CanTpCopyTxData() is called with SduLength 7.
    21: Verify whether CanIf_Transmit() is called to transmit CF with SduLength 8.
    22: Call CanTp_TxConfirmation() to confirm the CF sent.
    23: Verify no SN error has occurred.
    24: Verify whether PduR_CanTpTxConfirmation() is called with result E_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.11311</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>866</internalId></provcov>
        <provcov>
          <linksto>CanTp.11268_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>862</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_HalfDuplex_4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>293</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1212</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30289</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>4067</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that after receiving a FC(WT) message, the N_BS timer restarts.
  
Test Object: 
    N_Bs timeout handling
  
Test Precondition: 
  
Test Execution: 
    01: Call CanTp_Transmit() with PduId 0 and SduLength 8 and check that it return E_OK.
    02: Elapse a MainFunction tick.
    03: Verify whether PduR_CanTpCopyTxData() is called with SduLength 6.
    04: Verify whether CanIf_Transmit() is called to transmit FF.
    05: Call CanTp_TxConfirmation() to confirm the FF sent.
    06: Simulate reception of 3 FC WAIT with delay of 1/2 BS between each frame and
        elapse a MainFunction tick.
    07: Simulate reception of FC CTS frame.
    08: Verify whether PduR_CanTpCopyTxData() is called with SduLength 2.
    09: VP(CanTp.11260):
        Verify whether CanIf_Transmit() is called to transmit CF, timeout has not occurred.
    10: Call CanTp_TxConfirmation() to confirm the CF sent.
    11: Verify whether PduR_CanTpTxConfirmation is called with result E_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.11260</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>871</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1213</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30485</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>4194</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that the CAN TP respects Separation Time (STmin). Part 1/5 (STmin in ms, integer multiple
    of Gpt resolution).
  
Test Object: 
    STmin handling
  
Test Precondition: 
  
Test Execution: 
    01: Call CanTp_Transmit() with PduId 4 and SduLength 20 and check that it returns E_OK.
    02: Elapse a MainFunction tick.
    03: Verify whether PduR_CanTpCopyTxData() is called with SduLength 6.
    04: Verify whether CanIf_Transmit() is called to transmit FF.
    05: Call CanTp_TxConfirmation() to confirm the FF sent.
    06: Simulate reception of FC frame, indicate a ST of
        9 (decimal) (milliseconds) (integer multiple of Gpt resolution).
    07: Verify whether PduR_CanTpCopyTxData() is called with SduLength 7.
    08: Verify whether CanIf_Transmit() is called to transmit CF.
    09: Call CanTp_TxConfirmation() to confirm the CF sent.
    10: VP(CanTp.11222, CanTp.EB.Gpt.STminHandling_1, CanTp.11228):
        Verify whether Gpt timeout has been set to (9000+2)/3+1).
    11: Verify whether PduR_CanTpCopyTxData() is called with SduLength 7.
    12: Elapse some Mainfunction ticks and check that transmission of CF is not initiated.
    13: Simulate a Gpt timeout.
    14: Verify whether CanIf_Transmit() is called to transmit CF.
    15: Call CanTp_TxConfirmation() to confirm the CF sent.
    16: Verify whether PduR_CanTpTxConfirmation() is called with result E_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.Gpt.STminHandling_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>552</internalId></provcov>
        <provcov>
          <linksto>CanTp.11222</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>880</internalId></provcov>
        <provcov>
          <linksto>CanTp.11228</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>830</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1214</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30095</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>4355</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    - Check that the CAN TP respects Separation Time (STmin). Part 2/5
    (STmin in ms, no integer multiple of Gpt resolution).
    - Verify that the Gpt callback function will be ignored if called when
      channel is idle.
  
Test Object: 
    STmin handling
  
Test Precondition: 
  
Test Execution: 
    01: Call CanTp_Transmit() with PduId 4 and SduLength 20 and check that it returns E_OK.
    02: Elapse a MainFunction tick.
    03: Verify whether PduR_CanTpCopyTxData() is called with SduLength 6.
    04: Verify whether CanIf_Transmit() is called to transmit FF.
    05: Call CanTp_TxConfirmation() to confirm the FF sent.
    06: Simulate reception of FC frame, indicate a ST of
        10 (decimal) (milliseconds) (no integer multiple of Gpt resolution).
    07: Verify whether PduR_CanTpCopyTxData() is called with SduLength 7.
    08: Verify whether CanIf_Transmit() is called to transmit CF.
    09: Call CanTp_TxConfirmation() to confirm the CF sent.
    10: VP(CanTp.11222, CanTp.EB.Gpt.STminHandling_1):
        Verify whether Gpt timeout has been set to (10000+2)/3+1).
    11: Verify whether PduR_CanTpCopyTxData() is called with SduLength 7.
    12: Elapse some Mainfunction ticks and check that transmission of CF is not initiated.
    13: Simulate a Gpt timeout.
    14: Verify whether CanIf_Transmit() is called to transmit CF.
    15: Call CanTp_TxConfirmation() to confirm the CF sent.
    16: Verify whether PduR_CanTpTxConfirmation() is called with result E_OK.
    17: VP(CanTp.EB.Gpt.STminCallback_Unexpected):
        Call the configured Gpt callback function when the channel is idle and verify that the call
        is ignored.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.Gpt.STminHandling_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>552</internalId></provcov>
        <provcov>
          <linksto>CanTp.11222</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>880</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Gpt.STminCallback_Unexpected</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>557</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1215</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30486</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>4530</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that the CAN TP respects Separation Time (STmin). Part 3/5 (STmin in us, integer multiple
    of Gpt resolution).
  
Test Object: 
    STmin handling
  
Test Precondition: 
  
Test Execution: 
    01: Call CanTp_Transmit() with PduId 5 and SduLength 20 and check that it returns E_OK.
    02: Elapse a MainFunction tick.
    03: Verify whether PduR_CanTpCopyTxData() is called with SduLength 6.
    04: Verify whether CanIf_Transmit() is called to transmit FF.
    05: Call CanTp_TxConfirmation() to confirm the FF sent.
    06: Simulate reception of FC frame, indicate a ST of
        F6 (hex) (integer multiple of Gpt resolution).
    07: Verify whether PduR_CanTpCopyTxData() is called with SduLength 7.
    08: Verify whether CanIf_Transmit() is called to transmit CF.
    09: Call CanTp_TxConfirmation() to confirm the CF sent.
    10: VP(CanTp.11269, CanTp.EB.Gpt.STminHandling_1):
        Verify whether Gpt timeout has been set to (600+2)/3+1).
    11: Verify whether PduR_CanTpCopyTxData() is called with SduLength 7.
    12: Elapse some Mainfunction ticks and check that transmission of CF is not initiated.
    13: Simulate a Gpt timeout.
    14: Verify whether CanIf_Transmit() is called to transmit CF.
    15: Call CanTp_TxConfirmation() to confirm the CF sent.
    16: Verify whether PduR_CanTpTxConfirmation() is called with result E_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.Gpt.STminHandling_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>552</internalId></provcov>
        <provcov>
          <linksto>CanTp.11269</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>881</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1216</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30096</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>4683</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that the CAN TP respects Separation Time (STmin). Part 4/5 (STmin in us, no integer
    multiple of Gpt resolution).
  
Test Object: 
    STmin handling
  
Test Precondition: 
  
Test Execution: 
    01: Call CanTp_Transmit() with PduId 5 and SduLength 20 and check that it returns E_OK.
    02: Elapse a MainFunction tick.
    03: Verify whether PduR_CanTpCopyTxData() is called with SduLength 6.
    04: Verify whether CanIf_Transmit() is called to transmit FF.
    05: Call CanTp_TxConfirmation() to confirm the FF sent.
    06: Simulate reception of FC frame, indicate a ST of
        F5 (hex) (no integer multiple of Gpt resolution).
    07: Verify whether PduR_CanTpCopyTxData() is called with SduLength 7.
    08: Verify whether CanIf_Transmit() is called to transmit CF.
    09: Call CanTp_TxConfirmation() to confirm the CF sent.
    10: VP(CanTp.11269, CanTp.EB.Gpt.STminHandling_1):
        Verify whether Gpt timeout has been set to (500+2)/3+1).
    11: Verify whether PduR_CanTpCopyTxData() is called with SduLength 7.
    12: Elapse some Mainfunction ticks and check that transmission of CF is not initiated.
    13: Simulate a Gpt timeout.
    14: Verify whether CanIf_Transmit() is called to transmit CF.
    15: Call CanTp_TxConfirmation() to confirm the CF sent.
    16: Verify whether PduR_CanTpTxConfirmation() is called with result E_OK.
  
Test Input: 
  
Test Output: 
    The CAN TP should let a delay of at least 500 microseconds between the transmission of each
    following CF. The delay is controlled by the Gpt.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.Gpt.STminHandling_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>552</internalId></provcov>
        <provcov>
          <linksto>CanTp.11269</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>881</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1217</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30323</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>4838</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that the CAN TP respects Separation Time (STmin). Part 5/5 (invalid STmin value).
    - If invalid STmin is received, CanTp should use the maximum value 0x7F for STmin, leading to a
      Gpt timeout value of (127000+2)/3+1)= 42335
  
Test Object: 
    STmin handling
  
Test Precondition: 
  
Test Execution: 
    Loop over the steps 01 to 16 for all invalid values of STmin i.e. 0xFA to 0xFF:
    01: CanTp_Transmit() with PduId 5 and SduLength 20 and check that it returns E_OK.
    02: Elapse a MainFunction tick.
    03: Verify whether PduR_CanTpCopyTxData() is called with SduLength 6.
    04: Verify whether CanIf_Transmit() is called to transmit FF.
    05: Call CanTp_TxConfirmation() to confirm the FF sent.
    06: Simulate reception of FC frame, indicate a ST with invalid value.
    07: Verify whether PduR_CanTpCopyTxData() is called with SduLength 7.
    08: Verify whether CanIf_Transmit() is called to transmit CF.
    09: Call CanTp_TxConfirmation() to confirm the CF sent.
    10: VP(CanTp.11270, CanTp.EB.Gpt.STminHandling_1):
        Verify whether Gpt timeout has been set to (127000+2)/3+1).
    11: Verify whether PduR_CanTpCopyTxData() is called with SduLength 7.
    12: Elapse some Mainfunction ticks and check that transmission of CF is not initiated.
    13: Simulate a Gpt timeout.
    14: Verify whether CanIf_Transmit() is called to transmit CF.
    15: Call CanTp_TxConfirmation() to confirm the CF sent.
    16: Verify whether PduR_CanTpTxConfirmation() is called with result E_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.Gpt.STminHandling_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>552</internalId></provcov>
        <provcov>
          <linksto>CanTp.11270</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>882</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1218</internalId></specobject>
    <specobject>
      <id>TS_CANTP_InvalidSTmin</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>4995</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Checking the behavior of CanTp for invalid values of STmin ie from 0x80 to 0xF0.
    - If invalid STmin is received, CanTp should use the maximum value 0x7F for STmin, leading to a
      Gpt timeout value of (127000+2)/3+1)= 42335
  
Test Object: 
    Message transmission
  
Test Precondition: 
  
Test Execution: 
    Loop over the steps 01 to 16 for all invalid values of STmin from 0x80 to 0xF0 in step 06:
    01: CanTp_Transmit() with PduId 0 and message length 20 in normal addressing mode and check
        that it returned E_OK.
    02: Elapse a MainFunction tick.
    03: Verify whether PduR_CanTpCopyTxData() is called with SduLength 6.
    04: Verify whether CanIf_Transmit() is called to transmit FF.
    05: Call CanTp_TxConfirmation() to confirm the FF sent.
    06: Simulate the reception of FC CTS frame with invalid Stmin.
    07: Verify whether PduR_CanTpCopyTxData() is called with SduLength 7.
    08: Verify whether CanIf_Transmit() is called to transmit CF.
    09: Call CanTp_TxConfirmation() to confirm the CF sent.
    10: VP(CanTp.11270, CanTp.EB.Gpt.STminHandling_1):
        Verify whether Gpt timeout has been set to (127000+2)/3+1).
    11: Verify whether PduR_CanTpCopyTxData() is called with SduLength 7.
    12: Elapse some Mainfunction ticks and check that transmission of CF is not initiated.
    13: Simulate a Gpt timeout.
    14: Verify whether CanIf_Transmit() is called to transmit CF.
    15: Call CanTp_TxConfirmation() to confirm the CF sent.
    16: Verify whether PduR_CanTpTxConfirmation() is called with result E_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.11270</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>882</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Gpt.STminHandling_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>552</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1219</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30092</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>5163</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Handling of Flow Status error.
  
Test Object: 
    FC frame status error
  
Test Precondition: 
  
Test Execution: 
    Loop over steps 01 to 09 for all invalid Flow status values i.e. 0x03 to 0x0F for step 6.
    01: Call CanTp_Transmit() with PduId 0U and SduLength 20 and check that it returns E_OK.
    02: Elapse a MainFunction tick.
    03: Verify whether PduR_CanTpCopyTxData() is called with SduLength 6.
    04: Verify whether CanIf_Transmit() is called to transmit FF.
    05: Call CanTp_TxConfirmation() to confirm FF sent.
    06: Simulate reception of FC with invalid Flow status.
    07: VP(CanTp.SWS_CanTp_00317, CanTp.SWS_CanTp_00216_8):
        Verify whether PduR_CanTpTxConfirmation() is called with result E_NOT_OK.
    08: VP(CanTp.11263):
        Verify whether no frame is sent as transmission is aborted.
  
Test Input: 
  
Test Output: 
    The CAN TP should abort the transmission and report to the upper layer:
    The remaining CFs are not sent after reception of the invalid FC frame.
    The Rx indication callback of the upper layer is called with result = E_NOT_OK.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.11263</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>875</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00317</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>211</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00216_8</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>409</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1220</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30148</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>5284</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the CAN TP sends FC(WAIT) frames when needed and continues transferring when it can.
  
Test Object: 
    FC(WAIT) frame creation
  
Test Precondition: 
    N_Br &amp;gt; 0
  
Test Execution: 
    01: PduR shall not have buffer for reception.
    02: Simulate reception of FF on PduId 0. Check call to PduR.
        Verify that PduR_CanTpCopyRxData is called with a data length 0
    03: Verify no FC frame is sent.
    04: VP(CanTp.SWS_CanTp_00216_4):
        Elapse MF ticks just before N_Br timeout of 900ms and verify that
        PduR_CanTpCopyRxData is called each time for getting the buffer.
    05: Check if FC WAIT was not sent.
    06: Elapse a MF tick for N_Br timeout.
    07: VP(CanTp.SWS_CanTp_00341):
        Verify whether CanIf_Transmit() was called to send FC WAIT.
    08: Call CanTp_TxConfirmation() to confirm the FC WAIT frame sent.
    09: PduR now shall have the necessary buffer.
    10: Elapse MainFunction ticks up to half the time of N_Ar (100ms), to request buffer and check
        call to PduR_CanTpCopyRxData().
    11: VP(CanTp.EB.FC.CTS):
        Verify whether CanIf_Transmit() was called to transmit FC CTS.
    12. Call CanTp_TxConfirmation() to confirm the FC CTS frame sent.
    13: Simulate reception of CF.
    14: Verify whether PduR_CanTpCopyRxData() was called with SduLength 7.
    15: Verify whether PduR_CanTpRxIndication() was called with result E_OK.
  
Test Input: 
  
Test Output: 
    The next FC frame sent by the CAN TP after the buffer request should be a WAIT request frame;
    it should be sent when N_Br has elapsed.
    The CAN TP requests a buffer from the upper layer multiple times before N_Br has elapsed.
    After the buffer request in which the CAN TP obtains a buffer, the CAN TP sends a CTS FC frame.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00341</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>170</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00216_4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>404</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.FC.CTS</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>558</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1221</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30099</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>5458</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the CAN TP doesn't send more than N_WFTmax wait requests to the sender.
  
Test Object: 
    N_WFTmax
  
Test Precondition: 
  
Test Execution: 
    01: Simulate reception of FF on PduId 0. PduR_CanTpStartOfReception returns BUFREQ_OK and
        PduR_CanTpCopyRxData returns BUFREQ_E_BUSY.
    02: Check whether PduR was called.
    03: VP(CanTp.ASR40.CopyRxData.BufferNotReserved.2c):
        Elapse 3 * (N_Br(900ms)+N_Ar(100ms)) MainFunction ticks.
        Verify if FC WAIT is sent and confirm it.
    04: VP(CanTp.ASR40.SWS_CanTp_00166_1):
        Check if PduR_CanTpCopyRxData was called.
    05: VP(CanTp.SWS_CanTp_00223_1):
        Verify if WFTmax wait frames were sent.
    06: VP(CanTp.SWS_CanTp_00223_2, CanTp.SWS_CanTp_00216_6):
        Verify whether PduR_CanTpRxIndication() is called with E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00223_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>173</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00223_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>172</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00166_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>14</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00216_6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>407</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.CopyRxData.BufferNotReserved.2c</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>485</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1222</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30322</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>5600</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the CAN TP doesn't send FC(WAIT) frames if N_WFTmax is set to 0.
  
Test Object: 
    N_WFTmax
  
Test Precondition: 
    CanTpRxWftMax = 0
  
Test Execution: 
    01: PduR_CanTpCopyRxData shall return BUFREQ_E_BUSY.
    02: Simulate reception of FF on PduId 2.
    03: Check whether PduR_CanTpStartOfReception() was called.
    04: Elapse 2 * (N_Br(900ms)+ N_Ar(100ms)) MainFunction ticks.
    05: VP(CanTp.11278):
        Verify if no wait frames were sent.
    06: VP(CanTp.SWS_CanTp_00223_2):
        Verify whether PduR_CanTpRxIndication() is called with E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.11278</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>837</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00223_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>173</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1223</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30086</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>5711</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that the CAN TP reports an overflow when receiving a FF,
    if PduR_CanTpStartOfReception returned BUFREQ_E_OVFL.
  
Test Object: 
    Overflow error
  
Test Precondition: 
  
Test Execution: 
    01: Prepare PduR_CanTpStartOfReception() to return BUFREQ_E_OVFL.
    02: Simulate reception of FF on PduId 0 and SduLength 8.
    03: Check for call to PduR_CanTpStartOfReception().
    04: VP(CanTp.11261_2, CanTp.ASR40.SWS_CanTp_00318_1, CanTp.11312, CanTp.EB.FC.OVFLOW):
        Check whether CanIf_Transmit() is called to send a FC OVFL frame.
    05: Call CanTp_TxConfirmation() to confirm the FC sent.
    06: VP(CanTp.ASR40.RxIndication.Precondition1):
        Check the PduR_CanTpRxIndication is not called.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00318_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>18</internalId></provcov>
        <provcov>
          <linksto>CanTp.11312</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>867</internalId></provcov>
        <provcov>
          <linksto>CanTp.11261_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>874</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.RxIndication.Precondition1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>494</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.FC.OVFLOW</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>559</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1224</internalId></specobject>
    <specobject>
      <id>CanTp_Conf01_SF_StartOfReception_BUFREQ_E_OVFL</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>5806</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test shall verify that if PduR_CanTpStartOfReception() return BUFREQ_E_OVFL for a single
    frame reception, the module shall discard the SF and perform no further action.
  
Test Object: 
    Overflow error for SF.
  
Test Precondition: 
  
Test Execution: 
    01: Prepare PduR_CanTpStartOfReception() to return BUFREQ_E_OVFL.
    02: Simulate reception of SF on PduId 0.
    03: VP(CanTp.SWS_CanTp_00353): Verify that PduR_CanTpStartOfReception() is called.
    04: VP(CanTp.SWS_CanTp_00353):
        Verify that no further action is performed.
    05: Call CanTp_MainFunction().
    06: VP(CanTp.SWS_CanTp_00353):
        Verify that no further action is performed.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00353</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>165</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1225</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30141</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>5879</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that the CAN TP properly handles overflow indications.
  
Test Object: 
    FC(OVFLW) reception
  
Test Precondition: 
  
Test Execution: 
    01: Call CanTp_Transmit() with PduId 0 and SduLength 13 and check that it returns E_OK.
    02: Elapse a MainFunction tick.
    03: Check that PduR_CanTpCopyTxData() is called twice, first for getting available buffer
        and second for getting data for FF with Sdulength as 6.
    04: Check if CanIf_Transmit() is called to transmit FF.
    05: Call CanTp_TxConfirmation() to confirm the sent FF.
    06: Simulate reception of FC with overflow indication.
    07: VP(CanTp.SWS_CanTp_00309, CanTp.11312, CanTp.11261_1, CanTp.SWS_CanTp_00216_8, CanTp.11268_1):
        Verify whether PduR_CanTpTxConfirmation() is called with result E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.11261_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>873</internalId></provcov>
        <provcov>
          <linksto>CanTp.11312</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>867</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00309</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>210</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00216_8</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>409</internalId></provcov>
        <provcov>
          <linksto>CanTp.11268_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>862</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1226</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30263</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>5990</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that the CAN TP properly resumes a transfer after receiving a FC(WAIT) frame followed by
    a FC(CTS) frame.
  
Test Object: 
    FC(WAIT) reception
  
Test Precondition: 
  
Test Execution: 
    01: Call CanTp_Transmit() with PduId 0 and SduLength 13. Elapse a MainFunction tick
    02: Check for call of PduR_CanTpCopyTxData() with SduLength 6.
    03: Check whether CanIf_Transmit() is called to transmit FF.
    04: Call CanTp_TxConfirmation() to confirm the FF sent.
    05: Simulate reception of two wait frames with MainFunction ticks in between.
    06: Simulate reception of FC CTS. Elapse a MainFunction tick.
    07: Check whether PduR_CanTpCopyTxData() is called with SduLength 7.
    08: VP(CanTp.11174):
        Check whether CanIf_Transmit() is called to transmit CF.
    09: Call CanTp_TxConfirmation to confirm the CF sent.
    10: Verify whether PduR_CanTpTxConfirmation is called with result E_OK.
  
Test Input: 
  
Test Output: 
    The CAN TP indicates a successful transmission.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.11174</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>870</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1227</internalId></specobject>
    <specobject>
      <id>TS_CANTP_RxCTS_Before_TxConfFF</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>6096</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Segmented Transmission:
    Check that CAN TP accepts the reception of a FC frame after transmission of a FF even if the
    FF-TxConfirmation has not arrived yet.
  
Test Object: 
    Early FC(CTS) reception
  
Test Precondition: 
  
Test Execution: 
    01: Start a transmission on PduId 0. Perform steps till transmission of the FF.
    02: VP():
        Check whether PduR_CanTpCopyTxData() was called with SduLength 6.
    03: VP():
        Check whether CanIf_Transmit() was called to transmit FF.
    04: Simulate reception of FC CTS.
    05: VP(CanTp.Design.Tx.WaitTxConfirmation_FF):
        Check that no transmission took place before occurence of TxConfirmation
    06: Call CanTp_TxConfirmation() to confirm FF sent.
    07: Elapse a MainFunction tick - processing continues with next Mainfunction.
    08: VP(CanTp.Design.Tx.WaitTxConfirmation_FF):
        Check whether PduR_CanTpCopyTxData() was called with SduLength 2.
    09: VP():
        Check that the rest of the transmission is performed successfully.
  
Test Input: 
  
Test Output: 
    The transmission is successful.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.Design.Tx.WaitTxConfirmation_FF</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>117</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1228</internalId></specobject>
    <specobject>
      <id>TS_CANTP_RxCTS_And_MF_Before_TxConfFF</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>6202</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Segmented Transmission:
    Check that CAN TP accepts the reception of a FC frame after transmission of a FF even if the
    FF-TxConfirmation has not arrived yet. Also it does not trigger the sending of CFs in the main function.
  
Test Object: 
    Module robustness in the context of out-of-order interrupts.
  
Test Precondition: 
  
Test Execution: 
    01: Start a transmission on PduId 0. Perform steps till transmission of the FF.
    02: Check whether PduR_CanTpCopyTxData() was called with SduLength 6.
    03: Check whether CanIf_Transmit() was called to transmit FF.
    04: Simulate reception of FC CTS.
    05: VP(CanTp.Design.Tx.WaitTxConfirmation_FF):
        Check that no transmission took place before occurence of TxConfirmation
    06: Call the main function
    07: VP(CanTp.Design.Tx.WaitTxConfirmation_FF):
        Check that no transmission took place before occurence of TxConfirmation
    08: Call CanTp_TxConfirmation() to confirm FF sent.
    09: Elapse a MainFunction tick - processing continues with next Mainfunction.
    10: VP(CanTp.Design.Tx.WaitTxConfirmation_FF):
        Check whether PduR_CanTpCopyTxData() was called with SduLength 2.
    11: Check that the rest of the transmission is performed successfully.
  
Test Input: 
  
Test Output: 
    The transmission is successful.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.Design.Tx.WaitTxConfirmation_FF</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>117</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1229</internalId></specobject>
    <specobject>
      <id>TS_CANTP_RxCTS_Before_TxConfCF</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>6315</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Segmented Transmission:
    Check that CAN TP accepts the reception of a FC frame after transmission of a block-last-CF even if the
    CF-TxConfirmation has not arrived yet.
  
Test Object: 
    Early FC(CTS) reception
  
Test Precondition: 
  
Test Execution: 
    01: Call CanTp_Transmit() with PduId 0 and SduLength 41 and proceede until before the CF
        transmission of the last CF within the first block.
    02: VP():
        Verify whether PduR_CanTpCopyTxData() is called with SduLength 7.
    03: Verify whether CanIf_Transmit() is called to transmit CF with SduLength 8.
    04: Simulate reception of FC frame with BS set to 4 and last 5 padding bytes.
    05: Check that no transmission took place before occurence of TxConfirmation
    06: Call CanTp_TxConfirmation() to confirm the CF sent.
    07: Elapse a MainFunction tick - processing continues with next Mainfunction.
    08: VP(CanTp.Design.Tx.WaitTxConfirmation_CF):
        Check that the rest of the transmission is performed successfully.
   
Test Input: 
  
Test Output: 
    The transmission is successful.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.Design.Tx.WaitTxConfirmation_CF</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>118</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1230</internalId></specobject>
    <specobject>
      <id>TS_CANTP_RxCTS_And_MF_Before_TxConfCF</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>6457</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Segmented Transmission:
    Check that CAN TP accepts the reception of a FC frame after transmission of a block-last-CF even if the
    CF-TxConfirmation has not arrived yet. Also it does not trigger the sending of CFs in the main function.
  
Test Object: 
    Module robustness in the context of out-of-order interrupts.
  
Test Precondition: 
  
Test Execution: 
    01: Call CanTp_Transmit() with PduId 0 and SduLength 41 and proceede until before the CF
        transmission of the last CF within the first block.
    02: Verify whether PduR_CanTpCopyTxData() is called with SduLength 7.
    03: Verify whether CanIf_Transmit() is called to transmit CF with SduLength 8.
    04: Simulate reception of FC frame with BS set to 4 and last 5 padding bytes.
    05: VP(CanTp.Design.Tx.WaitTxConfirmation_CF):
        Check that no transmission took place before occurence of TxConfirmation
    06: Call the main function
    07: VP(CanTp.Design.Tx.WaitTxConfirmation_CF):
        Check that no transmission took place before occurence of TxConfirmation
    08: Call CanTp_TxConfirmation() to confirm the CF sent.
    09: Elapse a MainFunction tick - processing continues with next Mainfunction.
    10: Check that the rest of the transmission is performed successfully.
   
Test Input: 
  
Test Output: 
    The transmission is successful.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.Design.Tx.WaitTxConfirmation_CF</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>118</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1231</internalId></specobject>
    <specobject>
      <id>TS_CANTP_RxCTS_Interblock</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>6607</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Segmented Transmission:
    Check that CAN TP ignores a FC CTS which is received unexpectedly in the middle of a block.
  
Test Object: 
    Early FC(CTS) reception
  
Test Precondition: 
  
Test Execution: 
    01: Initiate a transmission for PduId 0 and SduLength 41 and proceed until reception of
        CTS with BS = 4.
    02: Loop steps 03 to 09 four times and verify whether 4 CF are sent and unexpected CTS are ignored.
    03: VP():
        Verify whether PduR_CanTpCopyTxData() is called with SduLength 7.
    04: VP():
        Verify whether CanIf_Transmit() is called to transmit CF with SduLength 8.
    05: VP(CanTp.Design.Tx.WaitTxConfirmation_UnexpFC_CTS):
        unexpected CTS (from last loop iteration) shall be ignored
    06: Stimulate reception of unexpected CTS
    07: VP(CanTp.Design.Tx.WaitTxConfirmation_UnexpFC_CTS):
        Unexpected CTS shall be ignored
    08: Call CanTp_TxConfirmation() to confirm the CF sent.
    09: Stimulate reception of unexpected CTS
    10: Verify whether PduR_CanTpTxConfirmation is called with E_OK.
   
Test Input: 
  
Test Output: 
    The transmission is successful.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.Design.Tx.WaitTxConfirmation_UnexpFC_CTS</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>119</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1232</internalId></specobject>
    <specobject>
      <id>TS_CANTP_RxCF_Before_TxConfCTS</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>6765</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Segmented reception:
    Check that CAN TP accepts the reception of a CF frame after transmission of a CTS even if the
    CTS-TxConfirmation has not arrived yet.
  
Test Object: 
    FC frame transmission
  
Test Precondition: 
  
Test Execution: 
    01: Simulate reception on PduId 0 with length 27 until before transmission of CTS after first block.
    02: VP():
        Verify whether CanIf_Transmit() is called to send FC frame.
    03: Simulate reception of CF with SN 3.
    04: VP(CanTp.Design.Rx.WaitTxConfirmation_FC_CTS):
        Verify whether PduR_CanTpCopyRxData() is called with SduLength 7.
    05: VP():
        Verify whether PduR_CanTpRxIndication is called with result E_OK.
    06: Call CanTp_TxConfirmation() to confirm transmission of FC frame.
    07: VP():
        Check that no further action happens.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.Design.Rx.WaitTxConfirmation_FC_CTS</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>116</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1233</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30340</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>6937</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CAN TP starts a timeout N_Br to limit the requests for an Rx buffer after receiving
    an SF.
  
Test Object: 
    N_Br timeout
  
Test Precondition: 
  
Test Execution: 
    01: PduR_CanTpCopyRxData shall return BUFREQ_E_BUSY.
    02: Simulate reception of SF on PduId 0.
    03: VP(CanTp.SWS_CanTp_00216_7):
        Verify that PduR_CanTpStartOfReception and PduR_CanTpCopyRxData get called.
    04: Wait for time N_Br, 900ms.
    05: VP(CanTp.ASR40.SWS_CanTp_00166_2):
        Check that module retries with data copy requests.
    06: Check whether PduR_CanTpRxIndication() is called with E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00166_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>15</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00216_7</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>408</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1234</internalId></specobject>
    <specobject>
      <id>TS_CANTP_FailedBlockReception_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>7039</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CAN TP aborts the reception if upper layer rejects the reception of CF during a
    block transfer.
    This test case verifies the behavior if upper layer returns  buffer size 0U for the next CF.
  
Test Object: 
    CF reception within a block.
  
Test Precondition: 
    - Normal addressing mode.
  
Test Execution: 
    01: Start a segmented reception for standard addressing mode.
    02: For the first CF frame reception, set PduR_CanTpCopyRxData to available
        buffer size 7 (just enough for the first CF).
    03: Indicate first CF.
    04: Set PduR_CanTpCopyRxData to return BUFREQ_E_BUSY and indicate next CF.
    05: VP(CanTp.ASR40.RxNoBuffer_2):
        Verify that module tries to copy next CF.
    06: VP(CanTp.ASR40.RxNoBuffer_1):
        Check that because PduR_CanTpCopyRxData returns BUFREQ_E_BUSY, the reception is aborted and
        PduR_CanTpRxIndication() is called with E_NOT_OK.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.RxNoBuffer_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>544</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.RxNoBuffer_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>545</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1235</internalId></specobject>
    <specobject>
      <id>TS_CANTP_FailedBlockReception_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>7160</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CAN TP aborts the reception if upper layer rejects the reception of CF during a
    block transfer.
    This test case verifies the behavior if upper layer returns a buffer size smaller as required
    for the next CF.
  
Test Object: 
    CF reception within a block.
  
Test Precondition: 
    - Normal addressing mode.
  
Test Execution: 
    01: Start a segmented reception for standard addressing mode.
    02: For the first CF frame reception, set PduR_CanTpCopyRxData to return available
        buffer size to 10 (Enough for the first CF but not enough for the next CF).
    03: Indicate first CF.
    04: Set PduR_CanTpCopyRxData to return BUFREQ_E_BUSY and indicate next CF.
    05: VP(CanTp.ASR40.RxNoBuffer_2):
        Verify that module tries to copy next CF.
    06: VP(CanTp.ASR40.RxNoBuffer_1):
        Check that because  PduR_CanTpCopyRxData returns BUFREQ_E_BUSY, the reception is aborted and
        PduR_CanTpRxIndication() is called with E_NOT_OK.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.RxNoBuffer_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>544</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.RxNoBuffer_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>545</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1236</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30077</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>7281</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Timeout Error Handling (sender):
    Transmission of a CAN frame timeout (N_As).
  
Test Object: 
    N_As timeout
  
Test Precondition: 
  
Test Execution: 
    01: Call CanTp_Transmit() on PduId 0 and SduLength 7 and check that it returns E_OK.
    02: Elapse a MainFunction tick.
    03: Check whether PduR_CanTpCopyTxData() is called with SduLength 7.
    04: Check if CanIf_Transmit() called to send SF.
    05: Simulate N_As timeout of 100ms.
    06: VP(CanTp.SWS_CanTp_00205, CanTp.11232, CanTp.SWS_CanTp_00310
           CanTp.SWS_CanTp_00216_8, CanTp.ASR40.Transmit.Session, CanTp.SWS_CanTp_00164_2):
        Check whether PduR_CanTpTxConfirmation() is called with E_NOT_OK.
    07: VP(CanTp.ASR40.SWS_CanTp_00075_3):
        Confirm the FC frame after N_As time and verify that no CF is transmitted
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.11232</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>892</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00205</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>360</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00310</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>209</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.Transmit.Session</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>502</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00216_8</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>409</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00075_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>12</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00164_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>395</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1237</internalId></specobject>
    <specobject>
      <id>TS_CANTP_TimeoutFF</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>7403</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Process of a received FF during the process of a previous transmission timeout.
  
Test Object: 
    N_As timeout
  
Test Precondition: 
  
Test Execution: 
    01: Call CanTp_Transmit() on PduId 0 and SduLength 7 and check that it returns E_OK.
    02: Elapse a MainFunction tick.
    03: Check whether PduR_CanTpCopyTxData() is called with SduLength 7.
    04: Check if CanIf_Transmit() called to send SF.
    05: Simulate N_As timeout of 100ms.
    06: VP(CanTp.SWS_CanTp_00205, CanTp.11232, CanTp.SWS_CanTp_00310
           CanTp.SWS_CanTp_00216_8, CanTp.ASR40.Transmit.Session, CanTp.SWS_CanTp_00164_2):
        Check whether PduR_CanTpTxConfirmation() is called with E_NOT_OK.
    07: Process postponed received FF.
    08: VP(CanTp.ASR40.SWS_CanTp_00075_3):
        Confirm the FC frame after N_As time and verify that no CF is transmitted
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.11232</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>892</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00205</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>360</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00310</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>209</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.Transmit.Session</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>502</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00216_8</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>409</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00075_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>12</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00164_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>395</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1238</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30100</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>7538</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Timeout Error Handling (sender):
    Reception of a Flow Control frame timeout (N_Bs).
  
Test Object: 
    N_Bs timeout
  
Test Precondition: 
  
Test Execution: 
    01: Call CanTp_Transmit() with PduId 0 and SduLength 8 and check that it returns E_OK.
    02: Elapse a MainFunction tick.
    03: Check for call for PduR_CanTpCopyTxData() with SduLength 6.
    04: Check if CanIf_Transmit() is called to send FF.
    05: Call CanTp_TxConfirmation() to confirm sent FF.
    06: Simulate a BS timeout of 1000ms.
    07: VP(CanTp.SWS_CanTp_00205, CanTp.SWS_CanTp_00316, CanTp.11234, CanTp.SWS_CanTp_00315_1):
        Check if PduR_CanTpTxConfirmation is called with E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.11234</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>893</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00205</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>360</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00316</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>216</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00315_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>213</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1239</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30508</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>7647</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Timeout Error Handling (sender):
    Reception of a Flow Control frame timeout (N_Bs) - continued from 30100.
  
Test Object: 
    N_Bs timeout
  
Test Precondition: 
    TS_CANTP_30100 was correctly executed directly before this test.
  
Test Execution: 
    01: Simulate reception of FC CTS. This frame will be ignored.
    02: VP(CanTp.SWS_CanTp_00057_HalfDuplex_14):
        Check that the frame is ignored.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_HalfDuplex_14</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>303</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1240</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30101</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>7705</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Timeout Error Handling (sender):
    Transmission of a Consecutive Frame timeout (N_Cs).
  
Test Object: 
    N_Cs timeout
  
Test Precondition: 
  
Test Execution: 
    01: Call CanTp_Transmit() with PduId 0 and SduLength 8 and check that it returns E_OK.
    02: Elapse a MainFunction tick.
    03: Check for call of PduR_CopyTxData() with SduLength 6.
    04: Check if CanIf_Transmit() is called to send FF.
    05: Call CanTp_TxConfirmation() to confirm the sent FF.
    06: PduR_CopyTxData shall return BUFREQ_E_BUSY.
    07: Simulate reception of FC.
    08: Elapse MainFunction ticks just before N_Cs timeout.
    09: Check if module retries with call to PduR_CanTpCopyTxData().
    10: VP(CanTp.11236):
        Check that timeout has not happened and PduR is not notified.
    11: Elapse a Mainfunction tick and N_Cs timeout occurs.
    12: VP(CanTp.SWS_CanTp_00205, CanTp.SWS_CanTp_00164_2, CanTp.11236, CanTp.SWS_CanTp_00177):
        Check that PduR_CanTpTxConfirmation() is called with E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.11236</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>894</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00205</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>360</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00164_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>395</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00177</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>143</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1241</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30102</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>7851</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Timeout Error Handling (receiver):
    Transmission of a CAN frame timeout (N_Ar).
  
Test Object: 
    N_Ar timeout
  
Test Precondition: 
  
Test Execution: 
    01: Simulate reception of FF on PduId 0.
    02: Check if PduR_CanTpStartOfReception() is called with SduLength 20.
    03: Check if PduR_CanTpCopyRxData() is called with SduLength 6.
    04: VP(CanTp.EB.FC.CTS):
        Check if CanIf_Transmit() is called to sent FC CTS.
    05: Elapse Mainfunction ticks just before N_Ar timeout of 100ms.
    06: VP(CanTp.11238):
        Check if PduR is not notified.
    07: Elapse a Mainfunction tick and indicate timeout.
    08: VP(CanTp.SWS_CanTp_00311, CanTp.SWS_CanTp_00164_2, CanTp.11238):
        Check if PduR_CanTpRxIndication() is called with result E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.11238</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>895</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00311</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>174</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00164_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>395</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.FC.CTS</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>558</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1242</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30288</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>7970</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Timeout Error Handling (receiver):
    Transmission of a Flow Control frame timeout N_Br.
  
Test Object: 
    Flow control frame timeout
  
Test Precondition: 
  
Test Execution: 
    01: PduR shall return BUFREQ_E_BUSY.
    02: Simulate reception of SF on PduId 0.
    03: Check the call to PduR.
    04: Elapse Mainfunction ticks just before timeout N_Br of 900ms.
    05: VP(CanTp.SWS_CanTp_00222):
        Check if module retries with call to PduR_CanTpCopyRxData().
    06: Check if PduR is not notified.
    07: Elapse a Mainfunction tick and indicate timeout.
    08: VP(CanTp.SWS_CanTp_00205):
        Check if PduR_CanTpRxIndicaton() is called with result E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00205</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>360</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00222</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>169</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1243</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30104</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>8089</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Timeout Error Handling (receiver):
    Reception of a Consecutive Frame timeout (N_Cr).
  
Test Object: 
    N_Cr timeout
  
Test Precondition: 
  
Test Execution: 
    01: Simulate reception of FF on PduId 0.
    02: Check if PduR_CanTpStartOfReception() is called.
    03: Check if PduR_CanTpCopyRxData() is called with SduLength 6.
    04: Check if CanIf_Transmit() is called to transmit FC CTS.
    05: Call CanTp_TxConfirmation() to confirm the FC sent.
    06: Elapse Mainfunction ticks just before timeout Cr of 1000ms.
    07: VP(CanTp.11242):
        Check if PduR is not notified.
    08: Elapse a Mainfunction tick and indicate timeout.
    09: VP(CanTp.SWS_CanTp_00313, CanTp.SWS_CanTp_00164_2, CanTp.SWS_CanTp_00312_2, CanTp.11242):
        Check if PduR_CanTpRxIndication() is called with result E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.11242</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>897</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00313</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>182</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00312_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>181</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00164_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>395</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1244</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30268</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>8206</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CAN TP terminates the current transmission connection for FF or CF
    when CanIf_Transmit returns E_NOT_OK
  
Test Object: 
    CanIf_Transmit returned E_NOT_OK for FF or CF
  
Test Precondition: 
  
Test Execution: 
----------- CanIf_Transmit returns E_NOT_OK when transmitting FF ----------------
    01: CanIf_Transmit() for FF shall return E_NOT_OK.
    02: Call CanTp_Transmit() with PduId 0 and SduLength 8.
    03: Check that CanTp tries to transmit a FF
    04: Check if PduR_CanTpTxConfirmation() is called with result E_NOT_OK.
----------- CanIf_Transmit returns E_NOT_OK when transmitting CF ----------------
    05: CanIf_Transmit() for FF shall return E_OK.
    06: Call CanTp_Transmit() with PduId 0 and SduLength 8 and check that it returns E_OK.
    07: Check if CanIf_Transmit() was called to transmit FF.
    08: Call CanTp_TxConfirmation() to confirm the FF sent.
    09: CanIf_Transmit() for CF shall return E_NOT_OK.
    10: Simulate reception of FC CTS.
    11: Check if CanIf_Transmit() was called for CF.
    12: Check if PduR_CanTpTxConfirmation() is called with result E_NOT_OK,
        because CanIf_Transmit() returned E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00343</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>218</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1245</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30269</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>8337</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanTp terminates the current reception
    connection when CanIf_Transmit returns E_NOT_OK for FC.
  
Test Object: 
    CanIf_Transmit returned E_NOT_OK for FC
  
Test Precondition: 
  
Test Execution: 
    01: CanIf_Transmit() for FC shall return E_NOT_OK.
    02: Simulate reception of FF on PduId 0.
    03: Check for call of CanIf_Transmit().
    04: VP(CanTp.EB.11310_2):
        Check if PduR_CanTpRxIndication() is called with E_NOT_OK.
    05: CanIf_Transmit() shall return E_OK.
    06: Simulate reception of first CF on PduId 0.
    07: Check that PduR_CanTpCopyRxData() was not called for this frame,
	    as the reception on this pdu is already terminated.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.11310_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>560</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1246</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30245</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>8435</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CAN TP rejects transmission requests when a transmission is ongoing on the same
    channel.
  
Test Object: 
    Message transmission
  
Test Precondition: 
  
Test Execution: 
    01: Call CanTp_Transmit() with NSduId 0 and SduLength 7 and check that it returns E_OK.
    02: Check call of CanIf_Transmit().
    03: VP(CanTp.SWS_CanTp_00123, CanTp.SWS_CanTp_00288):
        Again call CanTp_Transmit() on the same channel with different NSduId 4 and SduLength 7.
        Check that it returns E_NOT_OK.
    04: VP(CanTp.ASR40.Transmit.E_NOT_OK2):
        Again call CanTp_Transmit() on the same channel with same NSduId 0 and SduLength 7.
        Check that it returns E_NOT_OK.
    05: Confirm the SF sent with first attempt.
    06: VP(CanTp.ASR40.Transmit.Session):
        Check if PduR_CanTp_TxConfirmation() was called with result E_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00123</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>247</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00288</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>245</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.Transmit.E_NOT_OK2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>500</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.Transmit.Session</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>502</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1247</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30156</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>8542</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the CAN TP can do multiple requests using PduR_CanTpCopyTxData() to obtain the data
    to send.
    Part 1/2: when no data is given (BUFREQ_E_BUSY).
  
Test Object: 
    Message transmission
  
Test Precondition: 
  
Test Execution: 
    01: PduR_CanTpCopyTxData() shall return BUFREQ_E_BUSY.
    02: Call CanTp_Transmit() with PduId 0 and SduLength 13 and check that it returns E_OK.
    03: Elapse N_Cs mainfunction invocations.
    04: VP(CanTp.SWS_CanTp_00184, CanTp.SWS_CanTp_00216_5):
        Check that module retries with call to PduR_CanTpCopyTxData().
    05: Check if PduR is not notified.
    06: Elapse mainfunction tick and simulated N_Cs timeout.
    07: VP(CanTp.SWS_CanTp_00167_2):
        Check that the transmission is aborted and PduR_CanTpTxConfirmation() was called with
        result E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00184</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>206</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00216_5</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>405</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00167_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>202</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1248</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30151</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>8650</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the CAN TP can do multiple requests using PduR_CanTpCopyTxData() to obtain the data
    to send.
    Part 2/2: when not enough data is given.
  
Test Object: 
    Message transmission
  
Test Precondition: 
  
Test Execution: 
    01: PduR_CanTpCopyTxData() shall provide buffer only for FF.
    02: Call CanTp_Transmit() wit PduId 0 and SduLength 13 and check that it returns E_OK.
    03: VP(CanTp.SWS_CanTp_00086):
        Check for PduR_CanTpCopyTxData() call with SduLength 6.
    04: Check if CanIf_Transmit() is called to transmit FF.
    05: Call CanTp_TxConfirmation() to confirm the FF sent.
    06: Simulate reception of FC CTS.
    07: Check for PduR_CanTpCopyTxData() call with SduLength 7.
        PduR has no data temporarily, so the test callout returns BUFREQ_E_BUSY.
    08: Check if module retries up to N_Cs - 2 times to get a valid data size.
    09: Prepare PduR to provide valid data size.
    10: Elapse a MainFunction tick. The test callout function returns BUFREQ_OK.
    11: VP(CanTp.SWS_CanTp_00089):
        Check if CanIf_Transmit() is called to transmit CF.
    12: Call CanTp_TxConfirmation() to confirm the CF sent.
    13: Check that PduR_CanTpTxConfirmation() is called with result E_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00086</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>203</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00089</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>208</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1249</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30187</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>8795</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CAN TP doesn't send more data than necessary when padding is disabled.
  
Test Object: 
    Message transmission of a single frame with normal addressing.
  
Test Precondition: 
    Padding disabled.
  
Test Execution: 
    01: Call CanTp_Transmit() with PduId 0 and SduLength 1 and check that it returns E_OK.
    02: VP(CanTp.ASR40.SWS_CanTp_00098, CanTp.SWS_CanTp_00231_1, CanTp.11284, CanTp.11298):
        Check if CanIf_Transmit() was called to send the 1 byte message with DLC of 2 bytes.
    03: Call CanTp_TxConfirmation() to confirm the message sent.
    04: VP(CanTp.SWS_CanTp_00090):
        Check if PduR_CanTpTxConfirmation() is called with result E_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00098</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>88</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00090</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>217</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00231_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>353</internalId></provcov>
        <provcov>
          <linksto>CanTp.11284</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>886</internalId></provcov>
        <provcov>
          <linksto>CanTp.11298</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>843</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1250</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30066</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>8894</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the CAN TP refuses transmission of segmented messages in functional addressing mode
    and will report a Det error.
  
Test Object: 
    Message transmission
  
Test Precondition: 
  
Test Execution: 
    01: VP(CanTp.SWS_CanTp_00092):
        Call CanTp_Transmit() with PduId 1 and SduLength 8.
        Extended addressing mode not set, Functional addressing.
        Check that it returns E_NOT_OK.
    02: Check that CanIf_Transmit() was not called.
    03: VP(CanTp.ASR40.SWS_CanTp_00093_2, CanTp.EB.Functional.NormalAddr, CanTp.11300):
        Det error CANTP_E_INVALID_TATYPE is reported.
    04: VP(CanTp.ASR40.Transmit.Session):
        PduR_CanTpTxConfirmation() should not get called as CanTp_Transmit returned E_NOT_OK
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00093_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>29</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.Transmit.Session</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>502</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00092</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>222</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Functional.NormalAddr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>653</internalId></provcov>
        <provcov>
          <linksto>CanTp.11300</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>845</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1251</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30206</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>8981</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that PduR_CanTpCopyTxData is called multiple times during the transmission.
  
Test Object: 
    Message transmission
  
Test Precondition: 
  
Test Execution: 
    01: PduR_CanTpCopyTxData() shall provide 19 bytes.
    02: Call CanTp_Transmit() with PduId 0 and SduLength 50.
    03: VP(CanTp.SWS_CanTp_00086, CanTp.ASR40.TxSTF_1):
        Check if PduR_CanTpCopyTxData() is called.
    04: Check if CanIf_Transmit() is called to transmit FF.
    05: Call CanTp_TxConfirmation() to confirm the FF sent.
    06: PduR_CanTpCopyTxData() shall provide additional 31 bytes.
    07: Simulate reception of FC CTS with BS 0.
    08: Loop steps 09, 10 and 11.
    09: VP(CanTp.SWS_CanTp_00086, CanTp.ASR40.TxCF):
        Check if PduR_CanTpCopyTxData() is called.
    10: Check if CanIf_Transmit is called to transmit CF.
    11: Call CanTp_TxConfirmation() to confirm the CF sent.
    12: Check if data was correctly sent.
    13: Check if PduR_CanTpTxConfirmation() is called with result E_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00086</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>203</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.TxSTF_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>534</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.TxCF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>536</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1252</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30248</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>9110</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test simultaneous transmissions on multiple channels.
  
Test Object: 
    Message transmission
  
Test Precondition: 
    - CanTp should be initialized.
  
Test Execution: 
    01: Call CanTp_Transmit() on CanTpChannel_0 with SduLength 8, check if E_OK is returned.
    02: Check if CanIf_Transmit() was called to transmit FF on CanTpChannel_0 with data
        provided by PduR.
    03: Confirm the FF sent on CanTpChannel_0.
    04: Call CanTp_Transmit() for CanTpTxNSdu9 of CanTpChannel_1 with SduLength 8,
        check if E_OK is returned.
    05: Check if CanIf_Transmit() was called to send FF on CanTpChannel_1 with data
        provided by PduR.
    06: Confirm the FF sent on CanTpChannel_1.
    07: Simulate reception of FC CTS on CanTpChannel_1.
    08: Check if CanIf_Transmit() was called to send CF on CanTpChannel_1 with data
        provided by PduR.
    09: Confirm the CF sent on CanTpChannel_1.
    10: VP(CanTp.SWS_CanTp_00120, CanTp.SWS_CanTp_00122, CanTp.SWS_CanTp_00096):
        Check for PduR_CanTpTxConfirmation() call for CanTpChannel_1 with result E_OK.
    11: Simulate reception of FC CTS on CanTpChannel_0.
    12: Check if CanIf_Transmit() was called to send CF on CanTpChannel_0 with data
        provided by PduR.
    13: Confirm the CF sent on CanTpChannel_0.
    14: VP(CanTp.SWS_CanTp_00120, CanTp.SWS_CanTp_00122, CanTp.SWS_CanTp_00096):
        Check for PduR_CanTpTxConfirmation() call on CanTpChannel_0 with result E_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00120</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>238</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00122</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>242</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00096</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>237</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1253</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30079</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>9334</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the CAN TP gives reception indication of Single Frames to the upper layer and
    requests a buffer for processing the frame.
  
Test Object: 
    Single frame reception
  
Test Precondition: 
  
Test Execution: 
    01: Simulate reception of SF on PduId 0 with message length 1.
    02: VP(CanTp.SWS_CanTp_00079):
        Check whether PduR_CanTpStartOfReception and PduR_CanTpCopyRxData() is called with
        message length 1.
    03: Check if PduR_CanTpRxIndication() is called with result E_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00079</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>151</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1254</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30318</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>9404</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanTp aborts the reception of a single frame if no buffer is provided by the upper
    layer.
  
Test Object: 
    CanTp_RxIndication()
  
Test Precondition: 
  
Test Execution: 
    01: PduR_CanTpStartOfReception shall return BUFREQ_OK and subsequent call to
        PduR_CanTpCopyRxData() shall return BUFREQ_E_NOT_OK.
    02: Simulate reception of SF with PduId 0.
    03: Check for PduR calls.
    04: VP(CanTp.ASR40.CopyRxData.BufferNotReserved.4):
        Check that PduR_CanTpRxIndication() is called with result E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.CopyRxData.BufferNotReserved.4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>487</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1255</internalId></specobject>
    <specobject>
      <id>TS_CANTP_SegExtRxMultBuf_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>9472</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanTp calculates the BS correct and can handle as much incoming
    CF as promoted by the calculated BS.
  
Test Object: 
    Block Size handling.
  
Test Precondition: 
    - Extended addressing format.
    - Padding disabled.
  
Test Execution: 
    01: Prepare PduR to have a buffer to copy 10 bytes, that is too short for the whole message of
        length 26 bytes (FF - 5 bytes + four CFs - 21 bytes).
    02: Simulate reception of FF, in extended addressing format.
    03: VP(CanTp.SWS_CanTp_00080):
        PduR_CanTpStartOfReception() shall be called followed by
        PduR_CanTpCopyRxData() to copy the data of the FF.
    04: Provide a buffer of 12 bytes and elapse a mainfunction cycle
    05: VP(CanTp.SWS_CanTp_00224, CanTp.SWS_CanTp_00091_2, CanTp.EB.FC.CTS,
           CanTp.SWS_CanTp_00283_ExtendedAdr):
        Check that CanIf_Transmit() is called to send FC with calculated BS = 2U (buffer of 12 bytes
        exists) and with first byte as 199 which is the N_TA.
    06: Confirm the FC sent.
    07: Simulate reception of 1st CF of 6 bytes.
    08: Check the data of the 1st CF were copied to PduR.
    09: Prepare PduR to have more buffer(21 bytes) than the remaining 9 bytes of data.
    10: Simulate reception of 2nd CF of 6 bytes.
    11: VP(CanTp.SWS_CanTp_00224, CanTp.SWS_CanTp_00067_BS):
        Check that CanIf_Transmit() is called to send FC with calculated BS = 2U(calculated BS after
        FF reception ).
    12: Confirm the FC sent.
    13: Simulate reception of 3rd CF of 6 bytes.
    14: VP(CanTp.SWS_CanTp_00269_1):
        Simulate reception of last CF of 3 bytes and verify that PduR_CanTpCopyRxData
        is called with Sdu length as 3.
    15: Check if PduR_CanTpRxIndication() is called with result E_OK.
    16: VP(CanTp.EB.LastCF.RxMinDataLength_ExtendedAddressing):
        Check that all data are received correctly (data = sequence starting with 11).
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00080</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>162</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00224</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>175</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00091_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>221</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00067_BS</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>192</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00269_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>177</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00283_ExtendedAdr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>230</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.FC.CTS</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>558</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.LastCF.RxMinDataLength_ExtendedAddressing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>614</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1256</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30164</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>9770</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the CanTp aborts the reception in case PduR returns BUFREQ_E_NOT_OK.
  
Test Object: 
    Overflow during message reception
  
Test Precondition: 
  
Test Execution: 
   Loop 1:
    01: PduR_CanTpStartOfReception() shall return BUFREQ_E_NOT_OK.
    02: Simulate reception of FF on PduId 0.
    03: Check for call of PduR_CanTpStartOfReception().
    04: VP(CanTp.SWS_CanTp_00081):
        Check if reception is aborted and no other function called.
   Loop 2:
    05: PduR_CanTpStartOfRecetion shall return BUFREQ_OK.
        PduR_CanTpCopyRxData shall return BUFREQ_E_NOT_OK.
    06: Check for call of PduR_CanTpCopyRxData.
    07: VP(CanTp.ASR40.CopyRxData.BufferNotReserved.1, CanTp.SWS_CanTp_00081):
        Check if reception is aborted and PduR_CanTpRxIndication() is called with result
        E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00081</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>163</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.CopyRxData.BufferNotReserved.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>482</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1257</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30170</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>9888</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the CAN TP resumes reception when it obtains a reception buffer.
  
Test Object: 
    Message reception
  
Test Precondition: 
  
Test Execution: 
    01: PduR_CanTpCopyRxData() shall return BUFREQ_E_BUSY.
    02: Simulate reception of FF on PduId 0.
    03: Check for PduR calls.
    04: Simulate N_Br timeout of 900ms and check buffer requests.
    05: Check that FC WAIT frame was sent and confirm it.
    06: Allow PduR_CanTpCopyRxData() to return BUFREQ_OK. Elapse a MainFunction tick.
    07: VP(CanTp.SWS_CanTp_00224, CanTp.EB.FC.CTS):
        Check that data is successfully copied and FC CTS is sent.
    08: Confirm the sent CTS frame.
    09: Simulate reception of CFs and check call of PduR_CanTpCopyRxData().
    10: Check if PduR_CanTpRxIndication() is called with E_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00224</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>175</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.FC.CTS</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>558</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1258</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30113</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>10069</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the CAN TP rejects received FFs in functional addressing mode.
  
Test Object: 
    CanTp_RxIndication()
  
Test Precondition: 
  
Test Execution: 
    01: Simulate reception of FF on PduId 1 configured for functional addressing mode.
    02: VP(CanTp.ASR40.SWS_CanTp_00093_1, CanTp.SWS_CanTp_00092):
        Check if Det error CANTP_E_INVALID_TATYPE is reported.
  
Test Input: 
  
Test Output: 
    The CAN TP signals an error to the DET.
    No further processing is done.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00093_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>28</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00092</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>222</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1259</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30189</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>10142</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test shall verify that CanTp only passes N-SDU data to upper layer.
    For this test padding shall be disabled and a SF reception shall be tested.
  
Test Object: 
    Message reception
  
Test Precondition: 
    - Padding disabled.
    - Normal addressing mode.
  
Test Execution: 
    01: Loop over steps 02 to 05 for 7 times with data length specified in input section
    02: Simulate reception of SF with different data length.
    03: Check for PduR calls.
    04: Check that PduR_CanTpRxIndication() is called with result E_OK.
    05: VP(CanTp.SWS_CanTp_00116_4, CanTp.EB.SF.RxMinDataLength_NormalAddressing, CanTp.11285):
        Check that only data bytes have been copied.
  
Test Input: 
    1,2,3,4,5,6,7
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00116_4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>257</internalId></provcov>
        <provcov>
          <linksto>CanTp.11285</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>888</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.SF.RxMinDataLength_NormalAddressing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>606</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1260</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30200</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>10273</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the CAN TP checks the frame size of a single frame (normal addressing)
    if padding is disabled. In case that the frame size is smaller than the data
    length (from N_PCI) + the header byte (N_PCI), the module shall ignore the frame and
    report a DET.
  
Test Object: 
  
Test Precondition: 
    Padding disabled.
    Use normal addressing mode.
    CanTp should be initialized
  
Test Execution: 
    01: Simulate reception of SF of 2 bytes NPdu length (1 byte N_PCI + 1 byte data).
        The data length encoded in the N_PCI is set to 2, which is invalid.
    02: VP(CanTp.ASR40.SWS_CanTp_00098, CanTp.EB.SF.InvalidRxLength):
        Check that the frame is ignored and Det error CANTP_E_INVALID_RX_LENGTH is reported.
    03: VP(CanTp.11288):
        Check that the frame is ignored. No further action took place.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00098</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>88</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.SF.InvalidRxLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>630</internalId></provcov>
        <provcov>
          <linksto>CanTp.11288</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>890</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1261</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30201</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>10355</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the CAN TP correctly takes the N_TA value into account for extended addressing
    format. Part 1/2.
  
Test Object: 
    Reception in extended addressing mode.
  
Test Precondition: 
    Padding disabled
  
Test Execution: 
    Loop over steps 01 to 03 for different values of data length and N-Pdu length.
    01: Simulate reception of SF in extended addressing mode with valid N_TA value.
    02: VP(CanTp.SWS_CanTp_00095_ExtendedAdr, CanTp.EB.SF.RxDataLength_ExtendedAddressing):
        Check whether the frame is accepted by checking the PduR calls.
    03: VP(CanTp.ASR40.SWS_CanTp_00114_2, CanTp.EB.SF.RxMinDataLength_ExtendedAddressing):
        Verify that CanTp requests buffer for only the data part, i.e only for data length bytes.
        (Indicating that even if padding is disabled for Rx N-Sdu, the receiver should accept padded
        frame.)
    04: Check if PduR_CanTpRxIndication() is called with E_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00095_ExtendedAdr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>235</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00114_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00114_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>91</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.SF.RxDataLength_ExtendedAddressing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>607</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.SF.RxMinDataLength_ExtendedAddressing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>608</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1262</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30203</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>10493</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the CAN TP correctly takes the N_TA value into account. Part 2/2.
  
Test Object: 
    CanTp_RxIndication()
  
Test Precondition: 
  
Test Execution: 
    Loop the steps through a range of invalid N_TA values.
    01: Simulate reception of SF in extended address mode with invalid N_TA value.
    02: VP(CanTp.SWS_CanTp_00095_ExtendedAdr):
        Check that module ignores the message.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00095_ExtendedAdr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>235</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1263</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30249</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>10570</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test simultaneous reception on multiple channels.
  
Test Object: 
    Parallel message reception
  
Test Precondition: 
  
Test Execution: 
    01: Start the reception of first Pdu with PduId 0, indicate FF.
    02: Check for PduR calls and Check if FC CTS was sent and confirm it.
    03: Start the reception of another different Pdu with PduId 12 mapped to another channel,
        indicate FF.
    04: VP(CanTp.SWS_CanTp_00122, CanTp.SWS_CanTp_00190, CanTp.SWS_CanTp_00096):
        Check for PduR calls and Check if FC CTS was sent and confirm it.
    05: Complete reception of both channels. Check that PduR_CanTpRxIndication() is called with
        E_OK for both the channels.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00122</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>242</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00190</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>243</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00096</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>237</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1264</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30080</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>10809</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that the CAN TP ignores invalid First Frames (length set to zero).
  
Test Object: 
    Invalid frame handling
  
Test Precondition: 
    Normal addressing mode.
  
Test Execution: 
    Loop the steps for a range of invalid message lengths from 1 to 7
    (Note: 0 is reserved for big data first frame format).
    01: Simulate reception of FF with length field varying.
    02: VP(CanTp.EB.FF.InvalidRxLength_1, CanTp.11042):
        Check that the module ignores the FF and Det error CANTP_E_INVALID_RX_LENGTH is reported
        and doesn't make any other API calls.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.11042</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>849</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.FF.InvalidRxLength_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>635</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1265</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30049</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>10890</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that CanTp_RxIndication() ignores SFs of size zero.
  
Test Object: 
    Invalid frame handling
  
Test Precondition: 
  
Test Execution: 
    01: Simulate reception of SF with length field set to 0.
    02: VP(CanTp.EB.SF.InvalidRxLength_1, CanTp.10966):
        Check the module ignores the SF and reports DET and doesn't make any other API calls.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.10966</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>842</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.SF.InvalidRxLength_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>631</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1266</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30059</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>10959</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that CanTp_RxIndication() ignores SFs with a size exceeding the maximum allowed
    (in normal addressing).
  
Test Object: 
    Invalid frame handling
  
Test Precondition: 
    Use normal addressing
    Padding is disabled.
    CanTp should be initialized
  
Test Execution: 
    Loop the steps through a range of invalid message lengths from 8 to 15.
    Note: 15 is the maximum possible length that can be stored in 4 bit.
    01: Simulate reception of SF with length field varying.
    02: VP(CanTp.EB.SF.InvalidRxLength_2, CanTp.11300):
        Check the module ignores the SF and reports DET and doesn't make any other API calls.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.11300</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>845</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.SF.InvalidRxLength_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>632</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1267</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30060</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>11041</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that CanTp_RxIndication() ignores SFs with a size exceeding the maximum allowed (in extended addressing).
  
Test Object: 
    Invalid frame handling
  
Test Precondition: 
  
Test Execution: 
    01: Simulate reception of SF on PduId 2, configured for extended addressing,
        with length field set to 7.
    02: VP(CanTp.EB.SF.InvalidRxLength_3, CanTp.11299):
        Check the module ignores the SF and reports CANTP_E_INVALID_RX_LENGTH to DET.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.11299</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>844</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.SF.InvalidRxLength_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>633</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1268</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30087</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>11113</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that the CAN TP ignores FFs with a message length short enough for a SF (normal addressing).
  
Test Object: 
    Invalid frame handling
  
Test Precondition: 
  
Test Execution: 
    01: Simulate reception of FF on PduId 0 with length field set to 7.
    02: VP(CanTp.EB.FF.InvalidRxLength_2, CanTp.11265):
        Check the module ignores the FF,reports DET error and doesn't make any other API calls.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.11265</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>850</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.FF.InvalidRxLength_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>636</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1269</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30088</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>11182</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that the CAN TP ignores FFs with a message length short enough for a SF
    (extended addressing).
  
Test Object: 
    Invalid frame handling
  
Test Precondition: 
  
Test Execution: 
    01: Simulate reception of FF on PduId 2, configured for extended addressing,
        with length field set to 6.
    02: VP(CanTp.EB.FF.InvalidRxLength_2, CanTp.11042):
        Check the module ignores the FF, reports error to Det and doesn't make any
        other API calls.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.11042</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>849</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.FF.InvalidRxLength_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>636</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1270</internalId></specobject>
    <specobject>
      <id>TS_FF_Extended_InvalidLength</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>11255</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that the CAN TP ignores FFs with a PDU length less than 3 bytes
    (extended addressing).
  
Test Object: 
    Invalid frame handling
  
Test Precondition: 
  
Test Execution: 
    01: Simulate reception of FF on PduId 2, configured for extended addressing,
        with length field set to 6 and PDU length set to 2.
    02: VP(CanTp.EB.FF.InvalidRxLength_5):
        Check the module ignores the FF, reports error to Det and doesn't make any
        other API calls.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.FF.InvalidRxLength_5</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>639</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1271</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30118</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>11326</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Segmented transmit in progress.
    Received Single Frames on the same channel.
  
Test Object: 
    Unexpected frame handling
  
Test Precondition: 
  
Test Execution: 
    01: Call CanTp_Transmit() to send FF with PduId 0 and SduLength 8.
    02: Simulate reception of SF on PduId 0.
    03: VP(CanTp.SWS_CanTp_00057_HalfDuplex_1):
        Check that module ignores the SF received.
    04: Simulate the reception of FC CTS.
    05: Check that CF is sent.
    06: Simulate reception of SF on PduId 0.
    07: VP(CanTp.SWS_CanTp_00057_HalfDuplex_1):
        Check that module ignores the SF received.
    08: Check that PduR_CanTpTxConfirmation() is called with result E_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_HalfDuplex_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>290</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1272</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30120</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>11432</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Segmented transmission in progress.
    Received First Frames on the same channel.
  
Test Object: 
    Unexpected frame handling
  
Test Precondition: 
  
Test Execution: 
    01: Call CanTp_Transmit() to send FF with PduId 0 and SduLength 8.
    02: Simulate reception of FF on PduId 0.
    03: VP(CanTp.SWS_CanTp_00057_HalfDuplex_2):
        Check that module ignores the FF received.
    04: Elapse mainfunction tick and confirm FF sent.
    05: Simulate reception of FF on PduId 0.
    06: VP(CanTp.SWS_CanTp_00057_HalfDuplex_2):
        Check that module ignores the FF received.
    07: Simulate the reception of FC CTS.
    08: Check that CF is sent.
    09: Simulate reception of FF on PduId 0.
    10: VP(CanTp.SWS_CanTp_00057_HalfDuplex_2):
        Check that module ignores the FF received.
    11: Check that PduR_CanTpTxConfirmation() is called with result E_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_HalfDuplex_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>291</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1273</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30121</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>11554</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Segmented transmit in progress.
    Received Consecutive Frames on the same channel.
  
Test Object: 
    Unexpected frame handling
  
Test Precondition: 
  
Test Execution: 
    01: Call CanTp_Transmit() to send FF with PduId 0 and SduLength 8.
    02: Simulate reception of a valid but unexpected CF on PduId 0.
    03: VP(CanTp.SWS_CanTp_00057_HalfDuplex_3):
        Check that module ignores the CF received.
    04: Elapse a mainfunction tick and confirm the FF sent.
    05: Simulate reception of a valid but unexpected CF on PduId 0.
    06: VP(CanTp.SWS_CanTp_00057_HalfDuplex_3):
        Check that module ignores the CF received.
    07: Simulate the reception of FC CTS.
    08: Check that CF is sent.
    09: Simulate reception of a valid but unexpected CF on PduId 0.
    10: VP(CanTp.SWS_CanTp_00057_HalfDuplex_3):
        Check that module ignores the CF received.
    11: Confirm the CF sent.
    12: Check that PduR_CanTpTxConfirmation() is called with result E_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_HalfDuplex_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>292</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1274</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30123</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>11677</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Segmented transmit in progress.
    Received Flow Control Frames on the same channel.
  
Test Object: 
    Unexpected frame handling
  
Test Precondition: 
  
Test Execution: 
    01: Call CanTp_Transmit() to send FF with PduId 0 and SduLength 20.
    02: Simulate reception of awaited FC CTS.
    03: Check if first CF is transmitted.
    04: Simulate reception of unexpected FC CTS.
    05: VP(CanTp.SWS_CanTp_00057_HalfDuplex_4):
        Check that module ignores the FC received.
    06: Confirm the first CF and complete the transmission.
    07: Check that PduR_CanTpTxConfirmation() is called with result E_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_HalfDuplex_4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>293</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1275</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30507</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>11783</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Segmented transmit in progress.
    Received Flow Control Frames for the current transmission.
  
Test Object: 
    Unexpected frame handling
  
Test Precondition: 
  
Test Execution: 
    01: Call CanTp_Transmit() and continue until FF was sent and confirmed.
    02: VP(CanTp.SWS_CanTp_00057_HalfDuplex_4):
        Indicate CTS with BS greater than 1 and verify that FC is accepted as CanTp was expecting.
    03: Check if the first CF has been sent.
    04: Simulate reception of unexpected FC OVFL.
    05: VP(CanTp.SWS_CanTp_00057_HalfDuplex_4):
        Check that the unexpected FC has been ignored(CanTp is waiting for TxConfirmation
        of first CF for transmitting second CF).
    06: Simulate reception of unexpected FC WAIT.
    07: VP(CanTp.SWS_CanTp_00057_HalfDuplex_4):
        Check that the unexpected FC has been ignored(CanTp is waiting for TxConfirmation
        of first CF for transmitting second CF).
    08: Simulate the reception of FC CTS and complete the reception.
    09: Check that PduR_CanTpTxConfirmation() is called with result E_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_HalfDuplex_4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>293</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1276</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30129</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>11928</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Segmented receive in progress.
    Unexpected Single Frame on the same channel.
  
Test Object: 
    Unexpected frame handling
  
Test Precondition: 
    Segmented message reception in progress
  
Test Execution: 
    01: Simulate reception of FF on PduId 0.
    02: Check that FC CTS is sent and confirm it.
    03: Simulate reception of first CF on PduId 0.
    04: Simulate reception of unexpected SF with same PduId 0.
    05: VP(CanTp.SWS_CanTp_00057_HalfDuplex_6):
        Check the ongoing segmented reception on PduId 0 was aborted and the
        PduR_CanTpRxIndication() was called with result E_NOT_OK.
    06: VP(CanTp.SWS_CanTp_00057_HalfDuplex_6):
        Check if the previous unsegmented reception on PduId 1 was completed
        successfully and PduR_CanTpRxIndication() was called with result E_OK.
    07: Check if further CFs on PduId 0 were ignored.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_HalfDuplex_6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>295</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1277</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30130</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>12043</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Segmented receive in progress.
    Unexpected First Frame on the same channel.
  
Test Object: 
    Unexpected frame handling
  
Test Precondition: 
    Segmented message reception in progress
  
Test Execution: 
    01: Simulate reception of FF on PduId 0  with message length 20.
    02: Check that FC CTS is sent and confirm it.
    03: Simulate reception of first CF on PduId 0.
    04: Simulate reception of unexpected FF with another PduId 0.
    05: VP(CanTp.SWS_CanTp_00057_HalfDuplex_7, CanTp.SWS_CanTp_00124_Same_N_AI):
        Check if the previous ongoing segmented reception on PduId 0 was aborted and the
        PduR_CanTpRxIndication() was called with result E_NOT_OK.
    06: Finish the reception on PduId 0.
    07: VP(CanTp.SWS_CanTp_00057_HalfDuplex_7):
        Check if the segmented reception on PduId 0 was completed successfully and
        PduR_CanTpRxIndication() was called with result E_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00124_Same_N_AI</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>249</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_HalfDuplex_7</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>296</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1278</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30131</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>12166</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Segmented receive in progress.
    Unexpected Consecutive Frame on the same channel.
  
Test Object: 
    Unexpected frame handling
  
Test Precondition: 
    Segmented message reception in progress
  
Test Execution: 
    01: Simulate reception of FF on PduId 0.
    02: Confirm the sent FC CTS.
    03: VP(CanTp.SWS_CanTp_00057_HalfDuplex_8):
        Simulate reception of first CF on PduId 0 and verify that the CF is accepted as it was
        expected.
    04: Simulate reception of unexpected CF on PduId 4 with SN 1.
    05: VP(CanTp.SWS_CanTp_00057_HalfDuplex_8):
        Check the received unexpected CF is ignored.
    06: Complete reception on PduId 0.
    07: Check if PduR_CanTpRxIndication() is called with result E_OK for PduId 0.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_HalfDuplex_8</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>297</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1279</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30132</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>12271</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Segmented receive in progress.
    Unexpected Flow Control Frames on the same channel.
  
Test Object: 
    Unexpected frame handling
  
Test Precondition: 
    Segmented message reception in progress
  
Test Execution: 
    01: Simulate reception of FF on PduId 0.
    02: Confirm the sent FC CTS.
    03: Simulate reception of CF on PduId 0.
    04: Simulate reception of unexpected FC WAIT on PduId 9.
    05: VP(CanTp.SWS_CanTp_00057_HalfDuplex_9):
        Check the received FC is ignored.
    06: Complete reception on PduId 0.
    07: Check if PduR_CanTpRxIndication() is called with result E_OK for PduId 0.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_HalfDuplex_9</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>298</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1280</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30126</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>12394</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CAN TP ignores unexpected CFs when idle.
  
Test Object: 
    Unexpected frame handling
  
Test Precondition: 
    CAN TP Idle
  
Test Execution: 
    Loop the steps 01 to 06 for available range of RxPdus.
    01: Simulate reception of FF.
    02: Elapse a MF tick to send CTS and confirm it.
    03: Elapse N_Cr MF ticks.
    04: Check if reception is aborted.
    05: Simulate reception of CF and expire some main cycles.
    06: VP(CanTp.SWS_CanTp_00057_HalfDuplex_13):
        Check that the module ignores it.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_HalfDuplex_13</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>302</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1281</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30125</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>12503</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CAN TP ignores unexpected FC frames when idle.
  
Test Object: 
    Unexpected frame handling
  
Test Precondition: 
    CAN TP Idle
  
Test Execution: 
    Loop steps 01 to 06 for different TxPduIds.
    01: Start a segment transmission.
    02: Elapse MF tick to send the FF and confirm it.
    03: Elapse N_Bs MF ticks while waiting for CTS.
    04: Check if the transmission is aborted.
    05: Simulate reception of FC on PduId 9 and expire some main cycles.
    06: VP(CanTp.SWS_CanTp_00057_HalfDuplex_14):
        Check that the module ignores it.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_HalfDuplex_14</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>303</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1282</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30127</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>12628</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CAN TP ignores unexpected unknown frames when idle, sending or receiving a message.
  
Test Object: 
    Unexpected frame handling
  
Test Precondition: 
  
Test Execution: 
    01: Call CanTp_Init() to set CanTp into IDLE state.
    02: Call CanTp_RxIndication() and give to the CAN TP an invalid frame (a frame with an invalid N_PCI).
    03: VP(CanTp.SWS_CanTp_00057_HalfDuplex_15):
        Check that the received frame is ignored.
    04: Call CanTp_Init() to set CanTp into IDLE state.
    05: Start transmission of the first frame of a segmented frame.
    06: Call CanTp_RxIndication() and give to the CAN TP an invalid frame (a frame with an invalid N_PCI).
    07: VP(CanTp.SWS_CanTp_00057_HalfDuplex_5):
        Check that the invalid frame is ignored.
    08: Transmit the next part (CF) of the segmented frame.
    09: Verify, that the segmented frame transmission is reported to PduR.
    10: Call CanTp_Init() to set CanTp into IDLE state.
    11: Start reception of the first frame of a segmented frame.
    12: Receive the next part (CF) of the segmented frame.
    13: Call CanTp_RxIndication() and give to the CAN TP an invalid frame (a frame with an invalid N_PCI).
    14: VP(CanTp.SWS_CanTp_00057_HalfDuplex_10):
        Check that the invalid frame is ignored.
    15: Receive the next (last) part (CF) of the segmented frame.
    16: Verify, that the segmented frame reception is reported to PduR.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_HalfDuplex_5</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>294</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_HalfDuplex_10</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>299</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_HalfDuplex_15</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>304</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1283</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30188</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>12811</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CAN TP adds padding when configured to do so.
  
Test Object: 
    Padding
  
Test Precondition: 
    Padding enabled.
  
Test Execution: 
    01: Call CanTp_Transmit() to send a message of 1 byte in normal addressing.
    02: VP(CanTp.ASR40.SWS_CanTp_00114_1, CanTp.ASR40.SWS_CanTp_00114_2,
           CanTp.SWS_CanTp_00059_1, CanTp.ASR40.SWS_CanTp_00040_1, CanTp.11282,
           CanTp.SWS_CanTp_00030_1f):
        Check that the remaining bytes are padding bytes.
    03: Check that PduR_CanTpTxConfirmation() is called with result E_OK.
    04: Call CanTp_Transmit() to send a segmented message of 8 bytes in normal addressing.
        Continue until FF is sent and confirmed.
    05: Indicate FC CTS.
    06: Elapse a MF tick and check if CF is sent.
    07: VP(CanTp.ASR40.SWS_CanTp_00114_1, CanTp.ASR40.SWS_CanTp_00114_2,
           CanTp.SWS_CanTp_00059_1, CanTp.ASR40.SWS_CanTp_00040_1, CanTp.11282):
        Check that the remaining bytes are padding bytes.
    08: Check that PduR_CanTpTxConfirmation() is called with result E_OK.
    09: Loop over step 10 to step 11 for all RxPdus with padding enabled.
    10: VP(CanTp.11283):
        Start reception of the first frame of a segmented frame and verify that
        CanTp requests buffer to PduR for 8 bytes, which is the message size.
    11: VP(CanTp.ASR40.SWS_CanTp_00114_1, CanTp.ASR40.SWS_CanTp_00114_2,
           CanTp.SWS_CanTp_00059_1, CanTp.ASR40.SWS_CanTp_00040_1, CanTp.11282):
          Check that the remaining bytes are padding bytes.
    12: Receive  the next part (CF) of the segmented frame.
    13: Verify, that the segmented frame reception is reported to PduR.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00114_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>91</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00114_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
        <provcov>
          <linksto>CanTp.11282</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>883</internalId></provcov>
        <provcov>
          <linksto>CanTp.11283</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>885</internalId></provcov>
        <provcov>
          <linksto>CanTp.11295</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>884</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00059_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>259</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00040_1</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>34</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00030_1f</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>135</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1284</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30193</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>13058</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CAN TP doesn't accept PDU smaller than 8 bytes when padding is enabled.
  
Test Object: 
    Padding
  
Test Precondition: 
    Padding enabled.
  
Test Execution: 
    01: Simulate reception of SF with SduLength of 4 on PduId 5.
    02: VP():
        Check that Det_ReportError() is called with CANTP_E_INVALID_RX_LENGTH.
    03: VP(CanTp.ASR40.SWS_CanTp_00040_2):
        Check that the SF is considered as corrupted (SduLength != 8U for padding) and
        will be ignored.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00040_2</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>35</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1285</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30190</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>13128</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the CAN TP gives only the actual data (used bytes) to the upper layer.
    Padding enabled.
  
Test Object: 
    Padding
  
Test Precondition: 
    Padding enabled.
  
Test Execution: 
    01: Simulate reception of SF of 3 bytes.
    02: VP(CanTp.SWS_CanTp_00116_2, CanTp.11283):
        Check that only the three bytes are copied to PduR buffer.
    03: Check that PduR_CanTpRxIndication() is called with result E_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00116_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>255</internalId></provcov>
        <provcov>
          <linksto>CanTp.11283</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>885</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1286</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30325</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>13212</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    When padding is disabled, verify that CAN frames are accepted from sources which use padding.
  
Test Object: 
    Padding
  
Test Precondition: 
    - Padding disabled.
    - Normal addressing mode.
  
Test Execution: 
    01: Simulate reception of SF with message length of 8 and data length in N_PCI of 5.
    02: VP(CanTp.EB.SF.RxMinDataLength_NormalAddressing, CanTp.11287)
        Verify that single frame is accepted (received correctly) even if received
        length is greater than stated length in N_PCI.
    03: VP(CanTp.SWS_CanTp_00057_HalfDuplex_12):
        Simulate reception of FF with NSduLength 10
        (required to test that last CF with bigger message length will be accepted)
        and verify that the frame is accepted in Idle state.
    04: Confirm CTS.
    05: Simulate reception of last CF with NSduLength set to 8.
    06: VP(CanTp.EB.LastCF.RxMinDataLength_NormalAddressing, CanTp.11287):
        Check that last CF is accepted even if received data (SduLength = 8) is greater than
        expected data. The CF is accepted when PduR_CanTpRxIndication() is called with E_OK.
    07: Start transmission to test if module will accept a FC with bigger length
        by transmitting FF on PduId 0.
    08: Simulate reception of FC(CTS) indicating SduLength of 8.
    09: VP(CanTp.EB.Padding.CANTP_OFF.Receiving.CAN20_RxFC.AcceptedLengths.STANDARD, CanTp.11287):
        Verify that FC(CTS) is accepted even if SduLength was greater by checking that
        the transmission continues correctly.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.SF.RxMinDataLength_NormalAddressing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>606</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.LastCF.RxMinDataLength_NormalAddressing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>612</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Padding.CANTP_OFF.Receiving.CAN20_RxFC.AcceptedLengths.STANDARD</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>740</internalId></provcov>
        <provcov>
          <linksto>CanTp.11287</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>889</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_HalfDuplex_12</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>301</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1287</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30175</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>13407</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that, when development error detection is enabled, all parameters are checked for
    validity and that invalid errors are reported.
  
Test Object: 
    Error detection
  
Test Precondition: 
    Module compiled with DET enabled.
  
Test Execution: 
    01: Call CanTp_Transmit() with invalid PDU ID (for this configuration) and
        verify whether the return value is E_NOT_OK.
    02: VP(CanTp.ASR40.SWS_CanTp_00134):
        Check that Det error CANTP_E_PARAM_ID is reported.
    03: VP(CanTp.ASR40.Transmit.E_NOT_OK1):
        Call CanTp_Transmit() with invalid PDU pointer and
        verify whether the return value is E_NOT_OK.
    04: VP(CanTp.ASR40.SWS_CanTp_00134, CanTp.ASR40.SWS_CanTp_00321):
        Check that Det error CANTP_E_PARAM_POINTER is reported.
    05: Call CanTp_RxIndication() with invalid PDU ID (for this configuration).
    06: VP(CanTp.ASR40.SWS_CanTp_00134):
        Check that Det error CANTP_E_INVALID_RX_ID is reported.
    07: Call CanTp_RxIndication() with invalid PDU pointer.
    08: VP(CanTp.ASR40.SWS_CanTp_00134, CanTp.SWS_CanTp_00322):
        Check that Det error CANTP_E_PARAM_POINTER is reported.
    09: Call CanTp_TxConfirmation() with invalid PDU ID (for this configuration).
    10: VP(CanTp.ASR40.SWS_CanTp_00134):
        Check that Det error CANTP_E_INVALID_TX_ID is reported.
    11: Call CanTp_ChangeParameter() with invalid PDU ID (for this configuration).
    12: VP(CanTp.ASR40.SWS_CanTp_00134):
        Check that Det error CANTP_E_PARAM_ID is reported.
    13: Call CanTp_ChangeParameter() with invalid TP-Parameter.
    14: VP(CanTp.ASR40.SWS_CanTp_00134):
        Check that Det error CANTP_E_PARAM_ID is reported.
    15: Call CanTp_ChangeParameter() with invalid TP value.
    16: VP(CanTp.ASR40.SWS_CanTp_00134):
        Check that Det error CANTP_E_PARAM_ID is reported.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00134</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>38</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00322</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>399</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00321</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>44</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.Transmit.E_NOT_OK1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>499</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1288</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30176</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>13601</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    - Verify that the CAN TP is still in the CAN TP ON state after that errors were reported.
    - Verify that the SduDataPtr passed to CanTp_Transmit is not used to prepare SF but only uses
      length information
  
Test Object: 
    Error detection
  
Test Precondition: 
    DET errors has been reported in the previous tests.
  
Test Execution: 
    01: Call CanTp_Transmit() to send a SF (provide the CAN TP with buffer etc.
        so that it can perform the transmission).
    02: VP(CanTp.SWS_CanTp_00225, CanTp.SWS_CanTp_00008):
        Verify that the data transmitted to CanIf and that passed to CanTp_Transmit
        are different, only the length information(2) is considered not the data buffer.
    03: Check if CanTp reports successful transmission.
  
Test Input: 
  
Test Output: 
    The CAN TP transmits the data normally.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00225</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>195</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>321</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1289</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30250</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>13685</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a DET error is reported when the function CanTp_GetVersionInfo is given a wrong
    argument (1/1).
    Check the Service ID of CanTp_GetVersionInfo.
  
Test Object: 
    Error detection
  
Test Precondition: 
    Module compiled with DET enabled.
  
Test Execution: 
    01: Call CanTp_GetVersionInfo() with NULL_PTR.
    02: VP(CanTp.SWS_CanTp_00319, CanTp.ASR40.SWS_CanTp_00132):
        Check if Det error CANTP_E_PARAM_POINTER is reported.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00021</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>86</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00132</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>93</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00319</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>347</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1290</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30251</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>13755</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a DET error is reported when the function CanTp_Transmit is given a wrong argument
    (1/2).
  
Test Object: 
    Error detection
  
Test Precondition: 
    Module compiled with DET enabled.
  
Test Execution: 
    01: Call CanTp_Transmit() with PduId not in configurtion.
    02: VP(CanTp.SWS_CanTp_00293_2a):
        Check if Det error CANTP_E_PARAM_ID is reported.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00021</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>86</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00132</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>93</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00293_2a</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>326</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1291</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30252</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>13830</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a DET error is reported when the function CanTp_Transmit is given a wrong argument
    (2/2).
  
Test Object: 
    Error detection
  
Test Precondition: 
    Module compiled with DET enabled.
  
Test Execution: 
    01: Call CanTp_Transmit() with NULL_PTR.
    02: VP(CanTp.ASR40.SWS_CanTp_00321):
        Check if Det error CANTP_E_PARAM_POINTER is reported.
  
Test Input: 
  
Test Output: 
    DET module called with error code CANTP_E_PARAM_POINTER.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00321</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>44</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00021</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>86</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1292</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30253</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>13896</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a DET error is reported when the function CanTp_RxIndication is given a wrong
    argument (1/3).
  
Test Object: 
    Error detection
  
Test Precondition: 
    Module compiled with DET enabled.
  
Test Execution: 
    01: Call CanTp_RxIndication() with PduId that is not configured.
    02: VP(CanTp.EB.RxIndication.InvalidRxId):
        Check that Det error CANTP_E_INVALID_RX_ID is reported.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00021</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>86</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.RxIndication.InvalidRxId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>644</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1293</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30254</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>13967</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a DET error is reported when the function CanTp_RxIndication is called with
    NULL_PTR (2/3).
  
Test Object: 
    Error detection
  
Test Precondition: 
    Module compiled with DET enabled.
  
Test Execution: 
    01: Call CanTp_RxIndication() with NULL_PTR.
    02: VP(CanTp.SWS_CanTp_00322):
        Check that Det error CANTP_E_PARAM_POINTER is reported.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00021</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>86</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00322</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>399</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1294</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30262</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>14031</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a DET error is reported when the function CanTp_RxIndication is called with
    SduDataPtr as NULL_PTR (3/3).
  
Test Object: 
    Error detection
  
Test Precondition: 
    Module compiled with DET enabled.
  
Test Execution: 
    01: Call CanTp_RxIndication() with SduDataPtr as NULL_PTR.
    02: VP(CanTp.EB.RxIndication.ParamPointer):
        Check that Det error CANTP_E_PARAM_POINTER is reported.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00021</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>86</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.RxIndication.ParamPointer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>649</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1295</internalId></specobject>
    <specobject>
      <id>TS_CANTP_CHANGEPARA_INV_PDUID</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>14099</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a Det error and a PduR notification error is reported if the function
    CanTp_ChangeParameter is called with invalid Pdu Id (1/6).
  
Test Object: 
    Error detection
  
Test Precondition: 
    Module compiled with Det enabled.
  
Test Execution: 
    01: VP(CanTp.ASR40.ChangeParameter.E_NOT_OK):
        Call CanTp_ChangeParameter() with invalid Pdu Id and verify that it returned E_NOT_OK.
    02: VP(CanTp.SWS_CanTp_00305_1):
        Check that Det error CANTP_E_PARAM_ID is reported.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00305_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>383</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.ChangeParameter.E_NOT_OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>529</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1296</internalId></specobject>
    <specobject>
      <id>TS_CANTP_CHANGEPARA_INV_TPID</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>14168</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a Det error and a PduR notification error is reported if the function
    CanTp_ChangeParameter is called with invalid TPParameter (2/6).
  
Test Object: 
    Error detection
  
Test Precondition: 
    Module compiled with Det enabled.
  
Test Execution: 
    01: VP(CanTp.ASR40.ChangeParameter.E_NOT_OK):
        Call CanTp_ChangeParameter() with invalid TPParameter and verify that it returned E_NOT_OK.
    02: VP(CanTp.SWS_CanTp_00305_2):
        Check if Det error CANTP_E_PARAM_ID is reported.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00305_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>384</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.ChangeParameter.E_NOT_OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>529</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1297</internalId></specobject>
    <specobject>
      <id>TS_CANTP_CHANGEPARA_BSVAL</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>14239</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a Det error and a PduR notification error is reported if the function
    CanTp_ChangeParameter is called with invalid TP Value (3/6).
  
Test Object: 
    Error detection
  
Test Precondition: 
    Module compiled with Det enabled.
  
Test Execution: 
    01: VP(CanTp.ASR40.ChangeParameter.E_NOT_OK):
        Call CanTp_ChangeParameter() with invalid TP Value and verify that it returned E_NOT_OK.
    02: VP(CanTp.SWS_CanTp_00305_3):
        Check if Det error CANTP_E_PARAM_ID is reported.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00305_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>385</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.ChangeParameter.E_NOT_OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>529</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1298</internalId></specobject>
    <specobject>
      <id>TS_CANTP_CHANGEPARA_STMINVAL1</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>14310</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a Det error and a PduR notification error is reported if the function
    CanTp_ChangeParameter is called with invalid TP Value (4/6).
  
Test Object: 
    Error detection
  
Test Precondition: 
    Module compiled with Det enabled.
  
Test Execution: 
    01: Call CanTp_ChangeParameter() with invalid TP Value.
    02: VP(CanTp.SWS_CanTp_00305_3):
        Check if Det error CANTP_E_PARAM_ID is reported.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00305_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>385</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1299</internalId></specobject>
    <specobject>
      <id>TS_CANTP_CHANGEPARA_STMINVAL2</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>14377</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a Det error and a PduR notification error is reported if the function
    CanTp_ChangeParameter is called with invalid TP Value (5/6).
  
Test Object: 
    Error detection
  
Test Precondition: 
    Module compiled with Det enabled.
  
Test Execution: 
    01: Call CanTp_ChangeParameter() with invalid TP Value and check whether the return value
        is E_NOT_OK.
    02: VP(CanTp.SWS_CanTp_00305_3):
        Check if Det error CANTP_E_PARAM_ID is reported.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00305_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>385</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1300</internalId></specobject>
    <specobject>
      <id>TS_CANTP_CHANGEPARA_STMINVAL3</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>14442</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a Det error and a PduR notification error is reported if the function
    CanTp_ChangeParameter is called with invalid TP Value (6/6).
  
Test Object: 
    Error detection
  
Test Precondition: 
    Module compiled with Det enabled.
  
Test Execution: 
    01: Call CanTp_ChangeParameter() with invalid TP Value.
    02: VP(CanTp.SWS_CanTp_00305_3):
        Check if Det error CANTP_E_PARAM_ID is reported.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00305_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>385</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1301</internalId></specobject>
    <specobject>
      <id>TS_CANTP_READPARA_INV_PDUID</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>14507</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a Det error and a PduR notification error is reported if the function
    CanTp_ReadParameter is called with invalid Pdu Id.
  
Test Object: 
    Error detection
  
Test Precondition: 
    Module compiled with Det enabled.
  
Test Execution: 
    01: VP(CanTp.ASR40.ReadParameter.E_NOT_OK):
        Call CanTp_ReadParameter() with invalid Pdu Id and verify that it returned E_NOT_OK.
    02: VP(CanTp.SWS_CanTp_00324_Invalid_Id):
        Check that Det error CANTP_E_PARAM_ID is reported.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00324_Invalid_Id</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>390</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.ReadParameter.E_NOT_OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>532</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1302</internalId></specobject>
    <specobject>
      <id>TS_CANTP_READPARA_INV_PARAMETER</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>14581</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a Det error and a PduR notification error is reported if the function
    CanTp_ReadParameter is called with invalid Parameter.
  
Test Object: 
    Error detection
  
Test Precondition: 
    Module compiled with Det enabled.
  
Test Execution: 
    01: VP(CanTp.ASR40.ReadParameter.E_NOT_OK):
        Call CanTp_ReadParameter() with invalid Parameter and verify that it returned E_NOT_OK.
    02: VP(CanTp.SWS_CanTp_00324_Invalid_Id):
        Check that Det error CANTP_E_PARAM_ID is reported.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00324_Invalid_Parameter</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>391</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.ReadParameter.E_NOT_OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>532</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1303</internalId></specobject>
    <specobject>
      <id>TS_CANTP_INIT_NULLPTR</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>14655</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a Det error CANTP_E_PARAM_POINTER is reported when CanTp_Init is called
    with a NULL_PTR.
  
Test Object: 
    Error detection
  
Test Precondition: 
    Module compiled with Det enabled.
  
Test Execution: 
    01: Call CanTp_Init with NULL_PTR.
    02: VP(CanTp.ASR40.SWS_CanTp_00320):
        CANTP_E_PARAM_POINTER should be reported to Det
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00320</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>40</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1304</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30260</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>14711</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CAN TP reports a DET error when an invalid PDU length is given for transmission.
  
Test Object: 
    Error detection
  
Test Precondition: 
    Module compiled with DET enabled.
  
Test Execution: 
    01: Call CanTp_Transmit() with SduLength 0.
    02: VP(CanTp.EB.Transmit.InvalidTxLength):
        Check that Det error CANTP_E_INVALID_TX_LENGTH is reported.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00021</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>86</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Transmit.InvalidTxLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>648</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1305</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30261</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>14775</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CAN TP reports a DET error when an invalid PDU length is given at reception
    (N_PCI valid, SDU Length wrong) [padding disabled].
  
Test Object: 
    Error detection
  
Test Precondition: 
    Module compiled with DET enabled.
    Padding disabled.
  
Test Execution: 
    01: Simulate reception of SF with invalid SduLength.
    02: VP(CanTp.EB.SF.InvalidRxLength):
        Check that Det error CANTP_E_INVALID_RX_LENGTH is reported.
    03: Simulate reception of FF with invalid SduLength.
    04: VP(CanTp.EB.FF.InvalidRxLength_4):
        Check that Det error CANTP_E_INVALID_RX_LENGTH is reported.
    05: Start a segemented reception (extended addressing) until last CF is expected.
    06: Simulate reception of last CF with invalid SduLength.
    07: VP(CanTp.EB.LastFrame.InvalidRxLength):
        Check that Det error CANTP_E_INVALID_RX_LENGTH is reported.
    08: Start a transmission and continue until FC is expected.
    09: Simulate reception of FC frame with invalid SduLength.
    10: VP(CanTp.EB.RxIndication.InvalidRxLength):
        Check that Det error CANTP_E_INVALID_RX_LENGTH is reported
        and PduR is notified about the failed transmission.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00021</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>86</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.SF.InvalidRxLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>630</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.FF.InvalidRxLength_4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>638</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.LastFrame.InvalidRxLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>640</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.RxIndication.InvalidRxLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>626</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1306</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30266</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>14949</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CAN TP reports a DET error when an invalid PDU length is given at reception
    (N_PCI valid, SDU Length wrong) [padding enabled].
  
Test Object: 
    Error detection
  
Test Precondition: 
    Module compiled with DET enabled.
    Padding enabled.
  
Test Execution: 
    01: Simulate reception of SF with invalid SduLength.
    02: VP(CanTp.EB.Rx.Padding.InvalidRxLength):
        Check that Det error CANTP_E_INVALID_RX_LENGTH is reported.
    03: Simulate reception of FF with invalid SduLength.
    04: VP(CanTp.EB.Rx.Padding.InvalidRxLength):
        Check that Det error CANTP_E_INVALID_RX_LENGTH is reported.
    05: Continue with a reception until CF is expected.
    06: Simulate reception of CF with invalid SduLength.
    07: VP(CanTp.EB.Rx.Padding.InvalidRxLength):
        Check that Det error CANTP_E_INVALID_RX_LENGTH is reported.
    08: Start a transmission and continue until FC is expected.
    09: Simulate reception of FC frame with invalid SduLength.
    10: VP(CanTp.EB.Rx.Padding.InvalidRxLength):
        Check that Det error CANTP_E_INVALID_RX_LENGTH is reported.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00021</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>86</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Rx.Padding.InvalidRxLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>627</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1307</internalId></specobject>
    <specobject>
      <id>TS_CANTP_Padding_InvalidRxLength</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>15111</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CAN TP reports a DET error when an invalid PDU length is given at reception
    (N_PCI valid, SDU Length wrong) and that it does not interfere with ongoing connections [padding enabled].

    Test mandated by ticket ASCCANTP-1365.
  
Test Object: 
    Error detection
  
Test Precondition: 
    Module compiled with DET enabled.
    Padding enabled.
    Module initialized.
    Ongoing segmented connection.
  
Test Execution: 
    01: Simulate reception of SF with invalid SduLength.
    02: VP(CanTp.EB.Rx.Padding.InvalidRxLength):
        Check that Det error CANTP_E_INVALID_RX_LENGTH is reported.
    03: Simulate reception of FF with invalid SduLength.
    04: VP(CanTp.EB.Rx.Padding.InvalidRxLength):
        Check that Det error CANTP_E_INVALID_RX_LENGTH is reported.
    05: Simulate the rest of the preconditioned connection.
    06: VP(CanTp.EB.Rx.Padding.InvalidRxLength):
        Ongoing connection finishes successfully unaffected by the invalid receptions.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.Rx.Padding.InvalidRxLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>627</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1308</internalId></specobject>
    <specobject>
      <id>TS_CANTP_FC_Extended_InvalidLength</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>15242</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that Det error CANTP_E_INVALID_RX_LENGTH is reported when a FC frame is received
    with invalid N-Pdu Length(less than 4 bytes) for extended addressing.
  
Test Object: 
    Message transmission
  
Test Precondition: 
    Padding disabled
  
Test Execution: 
    01: Call CanTp_Transmit() with PduId 2 and SduLength 7 bytes in extended addressing mode.
        verify that FF is sent correctly.
    02: Call CanTp_TxConfirmation to confirm the transmission of FF.
    03: Simulate the reception of FC CTS with N-Pdu Length as 3 bytes, which is the wrong N-Pdu
        length (N-Pdu length of 4 bytes is the valid one).
    04: VP(CanTp.EB.Padding.CANTP_OFF.Receiving.CAN20_RxFC.AcceptedLengths.EXTENDED.MIXED):
        Check that Det error CANTP_E_INVALID_RX_LENGTH is reported.
    05: Simulate the reception of FC CTS with correct N_Pdu length.
    06: Finish the transmission successfully.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.Padding.CANTP_OFF.Receiving.CAN20_RxFC.AcceptedLengths.EXTENDED.MIXED</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>741</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1309</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30272</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>15367</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CAN TP reports a DET error when an invalid PDU length is given at reception
    (N_PCI information wrong, SduLength invalid but not corresponding to the N_PCI value).
  
Test Object: 
    Error detection
  
Test Precondition: 
    Module compiled with DET enabled.
  
Test Execution: 
    01: Simulate reception of SF with invalid SduLength 0.
    02: VP(CanTp.EB.SF.InvalidRxLength_1):
        Check if Det error CANTP_E_INVALID_RX_LENGTH is reported.
    03: Simulate reception of FF with invalid SduLength 4.
    04: VP(CanTp.EB.FF.InvalidRxLength_2):
        Check if Det error CANTP_E_INVALID_RX_LENGTH is reported.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00021</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>86</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.SF.InvalidRxLength_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>631</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.FF.InvalidRxLength_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>636</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1310</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30343</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>15446</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CAN TP aborts a transmit if the upper layer provides no Tx Buffer but returns
    BUFREQ_E_NOT_OK
  
Test Object: 
    Message transmission
  
Test Precondition: 
  
Test Execution: 
    01: PduR_CanTpCopyTxData() shall return BUFREQ_E_NOT_OK.
    02: Initiate a transmission.
    03: VP(CanTp.SWS_CanTp_00087, CanTp.ASR40.Transmit.Session):
        Check if PduR_CanTpTxConfirmation() is called with E_NOT_OK.
  
Test Input: 
  
Test Output: 
    The CAN TP calls the PduR_CanTpTxConfirmation() with the value E_NOT_OK.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00087</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>205</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.Transmit.Session</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>502</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1311</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30359</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>15525</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the CAN TP does not report an overflow error to the sender, when the
    BUFREQ_E_NOT_OK condition occurres after the reception of a CF.
  
Test Object: 
    Overflow during message reception
  
Test Precondition: 
  
Test Execution: 
    01: Simulate reception of FF.
    02: Check for PduR calls.
    03: Check if FC frame is sent and confirm it.
    04: PduR_CanTpCopyRxData() shall return BUFREQ_E_NOT_OK.
    05: Simulate reception of CF.
    06: VP(CanTp.SWS_CanTp_00271_1):
        Check if reception is aborted and PduR_CanTpRxIndication()
        is called with E_NOT_OK.
  
Test Input: 
  
Test Output: 
    CAN TP aborts the communication but does not send a FC(OVFLW) to the sender.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00271_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>184</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1312</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30368</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>15623</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanTp_Transmit rejects requests with an N-SDU Id which is already used in a running
    session (SF - SF).
  
Test Object: 
    Message transmission.
  
Test Precondition: 
  
Test Execution: 
    01: Call CanTp_Transmit() for a new SF directly after call
        of CanTp_Transmit() for a SF.
    02: Check if message is transmitted with the correct FrameType
        and Length (1 byte PCI + 3 byte data).
    03: VP(CanTp.SWS_CanTp_00206):
        Verify that PduR is notified of successful transmission.
    04: Call CanTp_Transmit() for a new SF after call of
        CanTp_MainFunction, SF is not confirmed yet.
    05: Check if message is transmitted with the correct FrameType
        and Length (1 byte PCI + 3 byte data).
    06: VP(CanTp.SWS_CanTp_00206):
        Verify that PduR is notified of successful transmission.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00206</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>361</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1313</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30377</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>15738</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanTp_Transmit rejects requests with an N-SDU Id which is already used in a running
    session (SF - multiple frames).
  
Test Object: 
    CanTp_Transmit()
  
Test Precondition: 
  
Test Execution: 
    01: Call CanTp_Transmit() for a new FF with length 8 directly after the call
        of CanTp_Transmit() for a SF with 3 bytes.
    02: Request to send CanTp_Transmit for FF returns E_NOT_OK.
    03: Call CanTp_MainFunction for transmitting the frame.
    04: Confirm SF.
    05: VP(CanTp.SWS_CanTp_00206):
        Verify that PduR is informed about successful transmission.
    06: Check if message is transmitted with the correct FrameType
        and Length (1 byte PCI + 3 byte data).
    07: Call CanTp_Transmit() to transmit SF.
    08: Call CanTp_MainFunction for transmitting the frame.
    09: Call CanTp_Transmit() for a new FF before confirming SF.
    10: Request to send CanTp_Transmit for FF returns E_NOT_OK.
    11: Confirm SF.
    12: VP(CanTp.SWS_CanTp_00206):
        Verify that PduR is informed about successful transmission.
    13: Check if message is transmitted with the correct FrameType
        and Length (1 byte PCI + 3 byte data).
  
Test Input: 
  
Test Output: 
    The second call of CanTp_Transmit returns E_NOT_OK. The first call is processed properly and
    the data is forwarded to CanIf.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00206</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>361</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1314</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30369</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>15876</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanTp_Transmit rejects requests with an N-SDU Id which is already used in a
    running session (multiple frames - SF).
  
Test Object: 
    CanTp_Transmit()
  
Test Precondition: 
  
Test Execution: 
   01: Start a transmission of segmented message of length 25 bytes.
   02: VP(CanTp.SWS_CanTp_00206):
       Request transmission of SF on same N-Sdu immediately after the transmission request for
       segmented message is accepted and verify that the transmit request is rejected
       (CanTp_Transmit returns E_NOT_OK).
   03: VP(CanTp.SWS_CanTp_00206):
       Try to start a transmission of SF on same N-Sdu directly after CanTp_MainFunction() call ie
       after FF got transmitted and verify that the transmit request is rejected.
   04: VP(CanTp.SWS_CanTp_00206):
       Try to start a transmission of SF on same N-Sdu directly after confirming the FF
       and verify that the transmit request is rejected.
   05: VP(CanTp.SWS_CanTp_00206):
       Try to start a transmission of SF on same N-Sdu directly after receiving the FC frame
       and verify that the transmit request is rejected.
   06: VP(CanTp.SWS_CanTp_00206):
       Try to start a transmission of SF on same N-Sdu directly after confirming the first CF
       and verify that the transmit request is rejected.
   07: VP(CanTp.SWS_CanTp_00206):
       Try to start a transmission of SF on same N-Sdu directly after confirming the second CF
       and verify that the transmit request is rejected.
   08: Complete the segmented transmission and verify the transmitted data and check that
       original message is transmitted successfully and intermediate transmission requests has
       been rejected.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00206</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>361</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1315</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30370</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>16054</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanTp_Transmit rejects requests with an N-SDU Id which is already used in a
    running session (multiple frames - multiple frames).
  
Test Object: 
    CanTp_Transmit()
  
Test Precondition: 
  
Test Execution: 
   01: Start a transmission of segmented message of length 25 bytes.
   02: VP(CanTp.SWS_CanTp_00206):
       Request transmission of another segmented message on same N-Sdu immediately after the
       first transmission request for segmented message is accepted and verify that the transmit
       request is rejected(CanTp_Transmit returns E_NOT_OK).
   03: VP(CanTp.SWS_CanTp_00206):
       Try to start a transmission of segmented message on same N-Sdu directly after
       CanTp_MainFunction() call ie after FF got transmitted and verify that the transmit
       request is rejected.
   04: VP(CanTp.SWS_CanTp_00206):
       Try to start a transmission of segmented message on same N-Sdu directly after confirming
       the FF and verify that the transmit request is rejected.
   05: VP(CanTp.SWS_CanTp_00206):
       Try to start a transmission of segmented message on same N-Sdu directly after receiving
       the FC frame and verify that the transmit request is rejected.
   06: VP(CanTp.SWS_CanTp_00206):
       Try to start a transmission of segmented message on same N-Sdu directly after confirming
       the first CF and verify that the transmit request is rejected.
   07: VP(CanTp.SWS_CanTp_00206):
       Try to start a transmission of segmented message on same N-Sdu directly after confirming
       the second CF and verify that the transmit request is rejected.
   08: Complete the initial segmented transmission and verify the transmitted data and check that
       original message is transmitted successfully and intermediate transmission requests has
       been rejected.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00206</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>361</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1316</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30381</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>16228</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanTp_RxIndication copies the received data correctly to the receive buffer.
  
Test Object: 
    CanTp_RxIndication()
  
Test Precondition: 
  
Test Execution: 
    01: Simulate reception of SF.
    02: VP(CanTp.SWS_CanTp_00079):
        Verify that PduR_CanTpStartOfReception is called for requesting the buffer.
    03: Check for completion of reception.
    04: Overwrite local data buffer.
    05: VP(CanTp.EB.Rx.DataConsistency):
        Check if Received data is stored internally before provided to upper layer. Data pointer
        from lower layer was not be provided to upper layer. Thus, the data received by
        the PduR must not have been overwritten with 0xFF.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.Rx.DataConsistency</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>622</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1317</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30356</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>16319</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    SF reception while state machine is idle.
  
Test Object: 
    Unexpected frame handling.
  
Test Precondition: 
    - CAN TP Idle.
    - Padding disabled.
    - Normal addressing mode.
  
Test Execution: 
    01: Simulate reception of SF.
    02: VP(CanTp.SWS_CanTp_00057_HalfDuplex_11, CanTp.SWS_CanTp_00216_4,
           CanTp.EB.SF.RxDataLength_NormalAddressing):
        Check that the frame is accepted and PduR_CanTpStartOfReception() and PduR_CanTpCopyRxData()
        get called
    03: Check if PduR_CanTpRxIndication is called with result E_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00216_4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>404</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_HalfDuplex_11</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>300</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.SF.RxDataLength_NormalAddressing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>605</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1318</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30367</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>16405</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a transmit cancellation causes the abort of a transfer before it has actually begun.
  
Test Object: 
    Message transmit cancellation
  
Test Precondition: 
    Transmit cancellation enabled.
  
Test Execution: 
    01: Call CanTp_Transmit() to start the transfer of a message.
    02: Call CanTp_CancelTransmit before CanTp_MainFunction is called to initiate the transfer and
        verify that the function returned E_OK.
    03: VP(CanTp.SWS_CanTp_00243, CanTp.SWS_CanTp_00274, CanTp.SWS_CanTp_00256,
           CanTp.ASR40.CancelTransmit.TxConfirmation):
        Check if PduR_CanTpTxConfirmation() is called with E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00274</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>145</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00243</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>146</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00256</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>369</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.CancelTransmit.TxConfirmation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>527</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1319</internalId></specobject>
    <specobject>
      <id>TS_CANTP_CancelTxReq_DetParamId</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>16502</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a transmit cancellation request with a wrong N-SDU ID is
    reported via development error CANTP_E_PARAM_ID.
  
Test Object: 
    Message transmit cancellation parameter check
  
Test Precondition: 
    Transmit cancellation enabled.
  
Test Execution: 
    01: VP(CanTp.ASR40.CancelTransmit.E_NOT_OK):
        Call CanTp_CancelTransmit() with invalid N-SDU ID (no 255 Tx N-SDUs
        configured, therefore 255 is invalid) and verify that it returned E_NOT_OK
    02: VP(CanTp.ASR40.SWS_CanTp_00254_1):
        Check if Det error CANTP_E_PARAM_ID is reported.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00021</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>86</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00254_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>48</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.CancelTransmit.E_NOT_OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>525</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1320</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30339</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>16575</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a transmit cancellation is rejected after the transfer of a FF as per deviation.
  
Test Object: 
    Message transmit cancellation
  
Test Precondition: 
    Transmit cancellation enabled.
  
Test Execution: 
    01: Call CanTp_Transmit() to start the transfer of a segmented message.
    02: After the FF has been transmitted, call CanTp_CancelTransmit() before confirmation of FF.
    03: VP(CanTp.SWS_CanTp_00274, CanTp.EB.TxCancellation_WaitTxConfirmation ):
        Check if cancel request is ignored.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00274</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>145</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.TxCancellation_WaitTxConfirmation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>594</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1321</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30376</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>16662</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a transmit cancellation is rejected while waiting for the FC as per deviation.
  
Test Object: 
    Message transmit cancellation
  
Test Precondition: 
    Transmit cancellation enabled.
  
Test Execution: 
    01: Call CanTp_Transmit() to start the transfer of a segmented message.
    02: After the FF has been transmitted and the FC is awaited, call CanTp_CancelTransmit().
    03: VP(CanTp.SWS_CanTp_00274, CanTp.EB.TxCancellation_WaitForFC):
        Check if cancel request is ignored.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00274</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>145</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.TxCancellation_WaitForFC</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>593</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1322</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30379</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>16749</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a transmit cancellation is rejected when CancelTransmit is called while waiting
    for the confirmation of first CF (as per deviation).
  
Test Object: 
    Message transmit cancellation before confirming the CF.
  
Test Precondition: 
    Transmit cancellation enabled.
  
Test Execution: 
    01: Perform a segmented message transmission.
    02: Call CanTp_CancelTransmit() while waiting for the Tx confirmation of the first CF.
    03: VP(CanTp.EB.TxCancellation_WaitTxConfirmation, CanTp.SWS_CanTp_00274):
        Check that the cancel request is ignored and transmission continues.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00274</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>145</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.TxCancellation_WaitTxConfirmation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>594</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1323</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30363</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>16846</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a transmit cancellation is rejected while waiting for next FC as per deviation.
  
Test Object: 
    Message transmit cancellation
  
Test Precondition: 
    Transmit cancellation enabled.
  
Test Execution: 
    01: Call CanTp_Transmit() to start the transfer of FF of length 20 bytes.
    02: Call Main Function to complete the FF transmission.
    03: Confirm FF transmitted.
    04: Receive FC with BS = 1.
    05: Transmit first CF.
    06: Confirm CF transmitted.
    07: Call CanTp_CancelTransmit() while waiting for next FC.
    08: VP(CanTp.SWS_CanTp_00243, CanTp.SWS_CanTp_00274):
        Check if cancel request was ignored.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00274</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>145</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00243</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>146</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1324</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30361</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>16946</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a transmit cancellation is rejected for a Single frame message as per deviation.
  
Test Object: 
    Message transmit cancellation
  
Test Precondition: 
    CanTp should be initialized
    Transmit cancellation enabled.
  
Test Execution: 
    01: PduR_CanTpCopyTxData() shall return BUFREQ_E_BUSY.
    02: Start transmission of SF.
    03: VP(CanTp.ASR40.SWS_CanTp_00246_1, CanTp.SWS_CanTp_00274):
        Call CanTp_CancelTransmit and check that the request is not accepted.
    04: Prepare PduR to return BUFREQ_OK and enough buffer
    05: VP(CanTp.ASR40.TxSTF_2):
        Call CanTp_MainFunction() and verify that buffer is again requested and finish the
        transmission successfully
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00274</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>145</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00246_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>46</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.TxSTF_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>535</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1325</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30366</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>17042</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a transmit cancellation causes the abort of a transfer while waiting for a buffer for FF.
  
Test Object: 
    Message transmit cancellation
  
Test Precondition: 
    Transmit cancellation enabled.
    CanTpTc of CanTpTxNSdu0 should be set to TRUE.
  
Test Execution: 
    01: PduR_CanTpCopyTxData() shall return BUFREQ_E_BUSY.
    02: Start a transmission.
    03: VP(CanTp.ASR40.CancelTransmit.E_OK, CanTp.SWS_CanTp_00242):
        Call CanTp_CancelTransmit to Cancel transmission and verify that it is accepted.
    04: VP(CanTp.SWS_CanTp_00243, CanTp.SWS_CanTp_00274, CanTp.SWS_CanTp_00256,
           CanTp.ASR40.CancelTransmit.TxConfirmation, CanTp.SWS_CanTp_00216_6):
        Check if PduR_CanTpTxConfirmation() is called with E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00274</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>145</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00243</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>146</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.CancelTransmit.TxConfirmation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>527</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00216_6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>407</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00256</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>369</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.CancelTransmit.E_OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>526</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00242</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>144</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1326</internalId></specobject>
    <specobject>
      <id>TS_CANTP_CanTpTc</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>17145</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a transmit cancellation is not processed if CanTpTc is set to false for the
    corresponding Tx NSdu.
  
Test Object: 
    Message transmit cancellation
  
Test Precondition: 
    Transmit cancellation enabled.
    CanTpTc of CanTpTxNSdu9 should be set to FALSE.
  
Test Execution: 
    01: PduR_CanTpCopyTxData() shall return BUFREQ_E_BUSY.
    02: Start a segmented transmission.
    03: VP(CanTp.SWS_CanTp_00242):
        Call CanTp_CancelTransmit to Cancel transmission and verify that it is not accepted
        as Tx cancellation is not enabled for CanTpTxNSdu9.
    04: Prepare PduR_CanTpCopyTxData to return BUFREQ_OK and finish the transmission successfully.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00242</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>144</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1327</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30365</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>17236</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a transmit cancellation causes the abort of a transfer while waiting for a buffer
    for CF after FF.
  
Test Object: 
    Message transmit cancellation
  
Test Precondition: 
    Transmit cancellation enabled.
  
Test Execution: 
    01: Start a segmented transmission.
    02: Check if FF is sent. Confirm it.
    03: PduR shall return BUFREQ_E_BUSY.
    04: Simulate reception of FC requesting first CF.
    05: VP(CanTp.ASR40.CancelTransmit.E_OK):
        Call CanTp_CancelTransmit while waiting for successful PduR call and verify that the cancel
        request is accepted.
    06: VP(CanTp.SWS_CanTp_00243, CanTp.SWS_CanTp_00274,
           CanTp.ASR40.CancelTransmit.TxConfirmation):
        Check if PduR_CanTpTxConfirmation() is called with E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00274</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>145</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00243</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>146</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.CancelTransmit.TxConfirmation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>527</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.CancelTransmit.E_OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>526</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1328</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30362</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>17354</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a transmit cancellation causes the abort of a transfer while waiting for a buffer
    for CF after CF.
  
Test Object: 
    Message transmit cancellation
  
Test Precondition: 
    Transmit cancellation enabled.
  
Test Execution: 
    01: Start a segmented transmission.
    02: Check if FF has been transmitted.
    03: Simulate reception of FC. Send and confirm the first CF.
    04: PduR shall return BUFREQ_E_BUSY.
    05: Simulate reception of FC requesting next CF.
    06: Cancel transmission while waiting for the successful PduR call.
    07: VP(CanTp.SWS_CanTp_00243, CanTp.SWS_CanTp_00274,
           CanTp.ASR40.CancelTransmit.TxConfirmation):
        Check if PduR_CanTpTxConfirmation() is called with E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00274</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>145</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00243</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>146</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.CancelTransmit.TxConfirmation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>527</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1329</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30371</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>17475</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanTp_Transmit rejects requests with an N-SDU Id which is already used in a running
    session while waiting for a buffer (SF - SF).
  
Test Object: 
    Message transmission
  
Test Precondition: 
  
Test Execution: 
    01: PduR_CanTpCopyTxData() shall return BUFREQ_E_BUSY.
    02: Initiate a transmission.
    03: VP(CanTp.SWS_CanTp_00206):
        Initiate another transmission. E_NOT_OK must be returned.
    04: Check that PduR_CanTpCopyTxData has not been called again.
    05: PduR_CanTpCopyTxData() shall return BUFREQ_OK.
    06: Check if SF have been transmitted.
    07: Check if correct data has been sent.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00206</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>361</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1330</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30378</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>17584</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanTp_Transmit rejects requests with an N-SDU Id which is already used in a running
    session while waiting for a buffer (SF - multiple frames).
  
Test Object: 
    CanTp_Transmit()
  
Test Precondition: 
  
Test Execution: 
    01: PduR_CanTpCopyTxData() shall return BUFREQ_E_BUSY.
    02: Initiate a transmission.
    03: VP(CanTp.SWS_CanTp_00206):
        Initiate another transmission. E_NOT_OK must be returned.
    04: PduR_CanTpCopyTxData() shall return BUFREQ_OK.
    05: Check if SF have been transmitted.
    06: Check if correct data has been sent
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00206</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>361</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1331</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30372</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>17697</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanTp_Transmit rejects requests with an N-SDU Id which is already used in a running
    session while waiting for a buffer (multiple frames - SF).
  
Test Object: 
    CanTp_Transmit()
  
Test Precondition: 
  
Test Execution: 
    01: PduR shall return BUFREQ_E_BUSY.
    02: Initiate transmission.
    03: VP(CanTp.SWS_CanTp_00206);
        While CanTp waits for successful PduR call, request a new
        transmit with the same pduId, which should return E_NOT_OK.
    04: VP(CanTp.ASR40.TxSTF_2):
        PduR shall return BUFREQ_OK and verify that PduR_CanTpCopyTxData get called again from
        Mainfunction for getting buffer.
    05: VP(CanTp.SWS_CanTp_00206);
        While CanTp waits for CanIf's Acknowledgement, request a new
        transmit with the same pduId, which should return E_NOT_OK.
    06: VP(CanTp.SWS_CanTp_00206);
        While FF is being transmitted, request a new
        transmit with the same pduId, which should return E_NOT_OK.
    07: PduR shall return BUFREQ_E_BUSY.
    08: VP(CanTp.SWS_CanTp_00206);
        While waiting for successful PduR call, request a new
        transmit with the same pduId, which should return E_NOT_OK.
    09: PduR_CanTpCopyTxData() shall return BUFREQ_OK.
    10: PduR_CanTpCopyTxData() shall return BUFREQ_E_BUSY.
    11: VP(CanTp.SWS_CanTp_00206);
        Initiate another transfer for the last time, E_NOT_OK must be returned.
    12: PduR_CanTpCopyTxData() shall return BUFREQ_OK.
    13: Complete the transmission.
    14: Check, that frame data has been sent correctly.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00206</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>361</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.TxSTF_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>535</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1332</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30373</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>17888</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanTp_Transmit rejects requests with an N-SDU Id which is already used in a running
    session while waiting for a buffer (multiple frames - multiple frames).
  
Test Object: 
    CanTp_Transmit()
  
Test Precondition: 
  
Test Execution: 
    01: PduR Shall return BUFREQ_E_BUSY.
    02: Start a segmented transmission and check E_OK is returned.
    03: Start another transmision on same pdu for which E_NOT_OK is returned.
    04: VP(CanTp.SWS_CanTp_00206):
        Start another transmission on same pdu while waiting for buffer and check E_NOT_OK is
        returned.
    05: PduR shall return BUFREQ_OK.
    06: Check, that frame data has been sent.
    07: VP(CanTp.SWS_CanTp_00206):
        Try starting another transmission on same pdu while waiting for confirmation and check
        E_NOT_OK is returned.
    08: Check transmission of FF.
    09: VP(CanTp.SWS_CanTp_00206):
        Try starting another transmission on same pdu while waiting for confirmation of FF and check
        E_NOT_OK is returned.
    10: PduR shall return BUFREQ_E_BUSY.
    11: Try starting a transmission again which would fail.
    12: PduR shall return BUFREQ_OK.
    13: Check, that frame data has been sent.
    14: PduR shall return BUFREQ_E_BUSY.
    15: Again try starting a transmission and check E_NOT_OK is returned.
    16: PduR shall return BUFREQ_OK.
    17: Check, that frame data has been sent.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00206</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>361</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1333</internalId></specobject>
    <specobject>
      <id>TS_CANTP_RCV_CANCL_DET</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>18093</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that DET error is reported when CanTp_CancelReceive is called for cancellation of
    reception on invalid id.
  
Test Object: 
    CanTp_CancelReceive()
  
Test Precondition: 
  
Test Execution: 
    01: Simulate reception of FF with message length 20 bytes until the FC has been sent.
    02: Confirm the FC sent.
    03: VP(CanTp.ASR40.CancelReceive.E_NOT_OK):
        Request receive cancellation on invalid id (value is out of range) and verify that it
        returned E_NOT_OK
    04: VP(CanTp.ASR40.SWS_CanTp_00260_1):
        Check DET error CANTP_E_PARAM_ID is reported.
    05: Finish the reception.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00260_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>52</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.CancelReceive.E_NOT_OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>521</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1334</internalId></specobject>
    <specobject>
      <id>TS_CANTP_RCV_CANCL_NOT_SUPPORT</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>18188</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that DET error is reported when CanTp_CancelReceive is called for cancellation of
    reception on PduId, that is not currently in the reception process.
  
Test Object: 
    CanTp_CancelReceive()
  
Test Precondition: 
  
Test Execution: 
    01: Signal data reception on PduId 0.
    02: Confirm the CTS.
    03: Request receive cancellation on PduId 1,that is not currently in the reception process.
    04: VP(CanTp.ASR40.SWS_CanTp_00260_2):
        Check DET error CANTP_E_OPER_NOT_SUPPORTED is reported.
    05: Finish reception.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00260_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>53</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1335</internalId></specobject>
    <specobject>
      <id>TS_CANTP_RCV_CANCL_ERR</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>18281</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanTp_CancelReceive() is rejected during the reception of a first
    frame and during the reception of a segmented message when waiting for the last CF.
  
Test Object: 
    CanTp_CancelReceive()
  
Test Precondition: 
  
Test Execution: 
    01: Simulate the reception of segmented message with length 10.
    02: Verify if FC is transmitted and confirmed.
    03: Call CancelReceiveRequest while waiting for the next CF.
    04: VP(CanTp.SWS_CanTp_00262_2):
        Verify that CancelReceiveRequest returns E_NOT_OK.
    05: Complete the reception.
    06: Simulate the reception of SF.
    07: Call CancelReceiveRequest.
    08: VP(CanTp.ASR40.SWS_CanTp_00257, CanTp.SWS_CanTp_00262_1):
        Verify that CancelReceiveRequest returns E_NOT_OK.
  
Test Input: 
    send FF (only 1 CF missing), call cancellation request -&gt; request rejected (ERROR returned)
    send SF, call cancellation request -&gt; request rejected (ERROR returned).
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00262_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>375</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00262_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>376</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00257</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>50</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1336</internalId></specobject>
    <specobject>
      <id>TS_CANTP_RCV_CANCL_OK1</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>18423</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test the correct cancellation of an ongoing segmented reception.
    - Receive cancellation after confirming FC frame.
    - Receiving CF after the reception got cancelled.
  
Test Object: 
    CanTp_CancelReceive()
  
Test Precondition: 
  
Test Execution: 
    01: Call RxIndication for FF with PduId 0.
    02: Verify the FC frame and confirm.
    03: VP(CanTp.SWS_CanTp_00261):
        Call CanTp_CancelReceive and verify that the request is accepted and returns E_OK and
        reception is aborted
    04: VP(CanTp.ASR40.CancelReceive.RxIndication):
        Verify that PduR_CanTpRxIndication is called with E_NOT_OK
    05: Call RxIndication for CF with PduId 0.
    06: VP(CanTp.SWS_CanTp_00057_HalfDuplex_13):
        Verify that the CF is not accepted.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.CancelReceive.RxIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>523</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00261</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>373</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_HalfDuplex_13</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>302</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1337</internalId></specobject>
    <specobject>
      <id>TS_CANTP_RCV_CANCL_OK2</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>18526</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test the correct cancellation of an ongoing segmented reception.
    - Receive cancellation while CanTp is waiting for an intermediate frame.
  
Test Object: 
    CanTp_CancelReceive()
  
Test Precondition: 
    CanTp should be initialized
    Use normal addressing.
    Padding is disabled.
  
Test Execution: 
    01: Receive FF with message length 30.
    02: Verify that FC frame is transmitted and confirm CTS.
    03: Receive first CF
    04: Call CanTp_CancelReceive and verify that it returned E_OK.
    05: VP(CanTp.SWS_CanTp_00261, CanTp.ASR40.CancelReceive.RxIndication):
        Verify that PduR_CanTpRxIndication is called with E_NOT_OK indicating that
        the reception is aborted.
    06: Receive the next CF and verify that the frame is not accepted as the reception is aborted.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00261</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>373</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.CancelReceive.RxIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>523</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1338</internalId></specobject>
    <specobject>
      <id>TS_CANTP_RxCancel_LastCF</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>18635</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test that the cancellation will be rejected if called:
    -&gt; when only one more CF has to be received to finish the reception and
    -&gt; N_Cr was not yet started for the last CF (e.g. if a FC frame was not yet confirmed).
  
Test Object: 
    CanTp_CancelReceive
  
Test Precondition: 
    The API CanTp_CancelReceive() shall be enabled.
  
Test Execution: 
    01: Signal data reception and verify that a FC frame is transmitted for first(last) CF.
    02: VP(CanTp.EB.RxCancellation_WaitTxConfirmation):
        Request receive cancellation and verify that cancel request is aborted as the FC
        frame is not confirmed.
    03: Confirm the FC CTS frame.
    04: Receive the CF with rest of the data.
    05: Check that the CF is accepted and PduR is notified with E_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.RxCancellation_WaitTxConfirmation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>595</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1339</internalId></specobject>
    <specobject>
      <id>TS_CANTP_PAD_FC_OVFLW</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>18740</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that padding works correctly on FC OVFLW frame.
  
Test Object: 
    Flow control frame
  
Test Precondition: 
    Padding is enabled.
  
Test Execution: 
    01: Prepare PduR_CanTpStartOfReception to return BUFREQ_E_OVFL.
    02: Indicate first frame reception.
    03: VP(CanTp.ASR40.SWS_CanTp_00040_1):
        Check whether the FC OVFLW is transmitted with N-PDU length as 8
    04: VP(CanTp.SWS_CanTp_00059_1):
        Check that first 3 bytes (FC N_PCI bytes) are not overwritten by padding bytes and the
        remaining unused bytes are set correctly with configured padding bytes.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00059_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>259</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00040_1</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>34</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1340</internalId></specobject>
    <specobject>
      <id>TS_CANTP_PAD_FC_CTS</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>18843</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that padding works correctly on FC CTS frame.
  
Test Object: 
    Flow control frame
  
Test Precondition: 
  
Test Execution: 
    01: Receive First Frame.
    02: CAN TP should respond with appropriate Flow Control Frame.
    03: VP(CanTp.ASR40.SWS_CanTp_00040_1):
        Check padding.
    04: First 3 bytes are FC N_PCI bytes -&gt; check that padding does not overwrite them.
    05: VP(CanTp.SWS_CanTp_00059_1):
        Check that unused bytes are set correctly.
    06: Finish transfer.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00059_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>259</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00040_1</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>34</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1341</internalId></specobject>
    <specobject>
      <id>TS_CANTP_PAD_FC_WAIT</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>18952</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that padding works correctly on FC WAIT frame.
  
Test Object: 
    Flow control frame
  
Test Precondition: 
    CanTp should be initialized.
    Prepare PduR_CanTpCopyRxData to return BUFREQ_E_BUSY
    Padding is enabled.
  
Test Execution: 
    01: Receive First Frame.
    02: Elapse MF ticks for N_Br timeout of 900ms.
    03: Verify that CanTp responded with appropriate Flow Control Frame and confirm the frame.
    04: VP(CanTp.ASR40.SWS_CanTp_00040_1):
        Check padding of FC Wait frame
    05: First 3 bytes are FC N_PCI bytes -&gt; check that padding does not overwrite them.
    06: VP(CanTp.SWS_CanTp_00059_1):
        Check that unused bytes are set correctly with the configured padding bytes.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00059_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>259</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00040_1</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>34</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1342</internalId></specobject>
    <specobject>
      <id>TS_CANTP_PAD_CF</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>19070</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Call CanTp_Transmit to transmit FF and one CF. Check that CF is padded correctly.
  
Test Object: 
    Transmission of last CF
  
Test Precondition: 
  
Test Execution: 
    01: Transmit on N-Sdu 8 which is configured as padding.
    02: Receive the FC frame to continue transfer.
    03: VP(CanTp.ASR40.SWS_CanTp_00040_1):
        Check padding for the last CF.
    04: First 5 bytes are 1 N_PCI byte + 4 data bytes -&gt; check that padding does not overwrite them.
    05: VP(CanTp.SWS_CanTp_00059_1):
        Check that last 3 bytes are unused and should be padded.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00059_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>259</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00040_1</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>34</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1343</internalId></specobject>
    <specobject>
      <id>TS_CANTP_CancelTxReqRepToDet_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>19182</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a transmit cancellation for a Tx N-SDU that is currently not
    transmitted is rejected and the Det error CANTP_E_OPER_NOT_SUPPORTED is
    reported (no transmission in progress).
  
Test Object: 
    CanTp_CancelTransmit()
  
Test Precondition: 
    - Transmit cancellation enabled.
    - No transmission in progress.
  
Test Execution: 
    01: Call CanTp_CancelTransmit() for a valid Tx N-SDU ID.
    02: VP(CanTp.ASR40.SWS_CanTp_00254_2):
        Check CanTp_CancelTransmit() returns E_NOT_OK and CANTP_E_OPER_NOT_SUPPORTED is reported
        to the Det.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00254_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>49</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1344</internalId></specobject>
    <specobject>
      <id>TS_CANTP_CancelTxReqRepToDet_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>19247</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a transmit cancellation for a Tx N-SDU that is currently not
    transmitted is rejected and the Det error CANTP_E_OPER_NOT_SUPPORTED is
    reported (transmission for a different Tx N-SDU is in progress).
  
Test Object: 
    CanTp_CancelTransmit()
  
Test Precondition: 
    - Transmit cancellation enabled.
    - At least one channel with two Tx N-SDUs (A and B).
  
Test Execution: 
    01: Start transmission of Tx N-SDU A.
    02: Call CanTp_CancelTransmit() for the valid Tx N-SDU B.
    03: VP(CanTp.ASR40.SWS_CanTp_00254_2):
        - CanTp_CancelTransmit() returns E_NOT_OK.
        - CANTP_E_OPER_NOT_SUPPORTED is reported to the Det.
    04: Finish transmission of Tx N-SDU A.
    05: Transmission of Tx N-SDU A was correctly finished.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00254_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>49</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1345</internalId></specobject>
    <specobject>
      <id>TS_CANTP_CancelTx_WhileRx</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>19348</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that ongoing reception is not affected when CanTp_CancelTransmit is called with
    N-SDU Id same as that of Rx-NSU Id of ongoing reception.
  
Test Object: 
    Transmit cancellation while reception is going on
  
Test Precondition: 
  
Test Execution: 
    01: Simulate reception of FF on PduId 0 with message length 20.
    02: Verify whether PduR_CanTpStartOfReception() is called with TpSduLength 20.
    03: Verify whether PduR_CanTpCopyRxData() is called with SduLength 6.
    04: VP(CanTp.11268_3):
        Verify whether CanIf_Transmit() is called to send FC frame.
    05: Call CanTp_CancelTransmit() for the Tx N-SDU Id which has similar value as that of
        Rx N-SDU Id of ongoing reception.
    06: VP(CanTp.ASR40.SWS_CanTp_00254_2):
        CanTp_CancelTransmit should return E_NOT_OK and report Det error CANTP_E_OPER_NOT_SUPPORTED.
    07: Call CanTp_TxConfirmation() to confirm transmission of FC frame.
    08: Simulate reception of CF with SN 1.
    09: Verify whether PduR_CanTpCopyRxData() is called with SduLength 7.
    10: Simulate reception of CF with SN 2.
    11: Verify whether PduR_CanTpCopyRxData() is called with SduLength 7.
    12: Verify whether PduR_CanTpRxIndication is called with result E_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00254_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>49</internalId></provcov>
        <provcov>
          <linksto>CanTp.11268_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>864</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1346</internalId></specobject>
    <specobject>
      <id>TS_CANTP_CONCURRENT_RX</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>19487</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a new reception on one channel is carried correctly when the ongoing reception on
    another channel is aborted by the unavailability of the buffer in PduR.
  
Test Object: 
  
Test Precondition: 
    - CanTp should be initialized.
    - Configure the channel mode as Half Duplex for both channels.
    - PduId 0 is associated with Channel_0.
    - PduId 9 is associated with Channel_1.
  
Test Execution: 
    01: Simulate reception of FF on PduId 0 associated with Channel_0.
    02: Check whether PduR calls are made and FC frame is sent and confirm it.
    03: Prepare PduR_CanTpCopyRxData to return BUFREQ_E_BUSY.
    04: Simulate reception of FF on PduId 9 associated with Channel_1.
    05: Check for PduR calls.
    06: Indicate reception of CF on PduId 0 associated with Channel_0.
    07: VP(CanTp.ASR40.CopyRxData.BufferNotReserved.2b):
        Verify that the reception on PduId 0 get aborted
    08: Prepare PduR_CanTpCopyRxData to return BUFREQ_OK.
    09: Elapse a MF tick.
    10: VP(CanTp.SWS_CanTp_00120):
        Verify that the reception started on Pdu 9 is continued and
        Check if the FF of PduId 9 is copied and CTS is transmitted.
    11: Confirm the CTS of PduId 9.
    12: VP(CanTp.SWS_CanTp_00120):
        Check if data copied are correct.
    13: Continue and finish the reception on PduId 9 successfully.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00120</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>238</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.CopyRxData.BufferNotReserved.2b</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>484</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1347</internalId></specobject>
    <specobject>
      <id>TS_CANTP_N_Cr_CFReception</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>19669</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanTp shall start a time-out N_Cr at each indication of CF reception
  
Test Object: 
    N_Cr timeout while CF reception
  
Test Precondition: 
     CanTp should be initialized.
     N_Cr = 1000ms
  
Test Execution: 
    01: Simulate reception of FF on PduId 0 with data length 27.
    02: Verify whether PduR_CanTpStartOfReception() is called with TpSduLength 27.
    03: Verify whether PduR_CanTpCopyRxData() is called with SduLength 6.
    04: VP(CanTp.11268_3):
        Verify whether CanIf_Transmit() is called to send FC frame.
    05: Call CanTp_TxConfirmation() to confirm transmission of FC frame.
    06: Simulate reception of CF with SN 1.
    07: Verify whether PduR_CanTpCopyRxData() is called with SduLength 7.
    08: Simulate Cr timeout of 1000ms.
    09: Elapse a Mainfunction tick and indicate timeout.
    10: VP(CanTp.SWS_CanTp_00312_1):
        Check if PduR_CanTpRxIndication() is called with result E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.11268_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>864</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00312_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>180</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1348</internalId></specobject>
    <specobject>
      <id>TS_CANTP_N_Bs_FCWAIT</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>19789</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that after receiving a FC(WT) message, the N_BS timer starts.
  
Test Object: 
    N_Bs timeout handling during the indication of FC with FS = WT
  
Test Precondition: 
  
Test Execution: 
    01: Call CanTp_Transmit() with PduId 0 and SduLength 8 and check that it return E_OK.
    02: Elapse a MainFunction tick.
    03: Verify whether PduR_CanTpCopyTxData() is called with SduLength 6.
    04: Verify whether CanIf_Transmit() is called to transmit FF.
    05: Call CanTp_TxConfirmation() to confirm the FF sent.
    06: Receive an FC Wait frame
    07: Simulate a BS timeout of 1000ms.
    08: Elapse a Mainfunction tick and indicate timeout.
    09: VP(CanTp.SWS_CanTp_00315_3, CanTp.11260):
        Verify whether PduR_CanTpTxConfirmation is called with result E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00315_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>215</internalId></provcov>
        <provcov>
          <linksto>CanTp.11260</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>871</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1349</internalId></specobject>
    <specobject>
      <id>TS_CANTP_N_Bs_LastCF</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>19892</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that N_Bs timer starts at confirmation of last CF of a block transmission.
  
Test Object: 
    N_Bs Timeout
  
Test Precondition: 
  
Test Execution: 
    01: Call CanTp_Transmit() with PduId 0 and SduLength 21 in normal addressing and
        check that it returns E_OK.
    02: Elapse a MainFunction Tick.
    03: Verify whether PduR_CanTpCopyTxData() is called with SduLength 6.
    04: Verify whether CanIf_Transmit() is called to transmit FF with SduLength 8.
    05: Call CanTp_TxConfirmation to confirm the transmission of FF.
    06: Simulate the reception of FC frame with BS 1.
    07: Verify whether Pdu_CanTpCopyTxData() is called with SduLength 7.
    08: Verify whether CanIf_Transmit() is called to transmit CF with SduLength 8(7 data + 1 NPCI)
        which is the first as well as the last CF of the block (as BS received is 1).
    09: Call CanTp_TxConfirmation to confirm the transmission of CF.
    10: Simulate a BS timeout of 1000ms while waiting for the next FC.
    11: Elapse a Mainfunction tick and indicate timeout.
    12: VP(CanTp.SWS_CanTp_00315_2, SWS_CanTp_00177):
        Check if PduR_CanTpTxConfirmation is called with E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00315_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>214</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00177</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>143</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1350</internalId></specobject>
    <specobject>
      <id>TS_CANTP_N_Cr_LASTCF</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>20033</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the CAN TP shall start a time-out N_Cr before requesting a Rx buffer
    during last frame reception
  
Test Object: 
    Repeated PduR Rx buffer requests for last CF
  
Test Precondition: 
   - CanTp should be initialized
   - Configure normal addressing mode for CanTpRxNSdu0
  
Test Execution: 
    01: Simulate reception of FF on PduId 0 with message length 32(6(FF) + 26(7*3 CFs + 5*1 CF).
    02: Verify whether PduR_CanTpStartOfReception() is called with TpSduLength 32.
    03: Verify whether PduR_CanTpCopyRxData() is called with SduLength 6.
    04: Verify whether CanIf_Transmit() is called to send FC frame.
    05: Call CanTp_TxConfirmation() to confirm transmission of FC frame.
    06: Simulate reception of CF with SN 1.
    07: Verify whether PduR_CanTpCopyRxData() is called with SduLength 7.
    08: Simulate reception of CF with SN 2.
    09: Verify whether PduR_CanTpCopyRxData() is called with SduLength 7.
    10: Verify whether CanIf_Transmit() is called to send FC frame.
    11: Call CanTp_TxConfirmation() to confirm transmission of FC frame.
    12: Simulate reception of CF with SN 3 and verify that it is accepted.
    13: Wait N_Cr times while waiting for last frame
    14: VP(CanTp.SWS_CanTp_00312_1):
        Verify whether PduR_CanTpRxIndication() is called with E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00312_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>180</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1351</internalId></specobject>
    <specobject>
      <id>TS_CANTP_N_Br_CFEOB</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>20202</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the CAN TP shall start a time-out N_Br while requesting enough buffer for
    next block
  
Test Object: 
    Repeated PduR Rx buffer requests for next block.
  
Test Precondition: 
  
Test Execution: 
    01: Simulate reception of FF on PduId 0 with message length 27.
    02: Verify whether PduR_CanTpStartOfReception() is called with TpSduLength 27.
    03: Verify whether PduR_CanTpCopyRxData() is called with SduLength 6.
    04: Verify whether CanIf_Transmit() is called to send FC frame.
    05: Call CanTp_TxConfirmation() to confirm transmission of FC frame.
    06: Simulate reception of CF with SN 1.
    07: Verify whether PduR_CanTpCopyRxData() is called with SduLength 7.
    08: Prepare PduR to return buffer for only the last CF of block, i.e. 7U.
    09: Simulate reception of CF with SN 2.
    10: Verify whether PduR_CanTpCopyRxData() is called with SduLength 7.
    11: Prepare PduR to return BUFREQ_E_BUSY while requesting enough buffer for next block
    12: VP(CanTp.ASR40.CopyRxData.BufferNotReserved.2c):
        Elapse 3 * (N_Br(900ms)+N_Ar(100ms)) MainFunction ticks.
        Verify if FC WAIT is sent 2 times and confirm it.
    13: VP(CanTp.SWS_CanTp_00223_2, CanTp.ASR40.SWS_CanTp_00166_3):
        Verify whether the reception is aborted as N_Br timeout occurred and verify that
        PduR_CanTpRxIndication() is called with E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00223_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>173</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00166_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>16</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.CopyRxData.BufferNotReserved.2c</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>485</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1352</internalId></specobject>
    <specobject>
      <id>TS_CANTP_CancelRx_LF</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>20392</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CAN TP rejects cancel request if CancelReceive is called after N-Cr timeout
    is started for the last CF
  
Test Object: 
    CancelReceive during last frame reception
  
Test Precondition: 
    CanTpBs of used Rx N-SDU is configured as 2 and address type as standard
  
Test Execution: 
    01: Simulate reception of FF on PduId 0 with message length 32.
    02: Verify whether PduR_CanTpStartOfReception() is called with TpSduLength 32.
    03: Verify whether PduR_CanTpCopyRxData() is called with SduLength 6.
    04: Verify whether CanIf_Transmit() is called to send FC frame with BS as 2.
    05: Call CanTp_TxConfirmation() to confirm transmission of FC frame.
    06: Simulate reception of CF with SN 1.
    07: Verify whether PduR_CanTpCopyRxData() is called with SduLength 7.
    08: Simulate reception of CF with SN 2.
    09: Verify whether PduR_CanTpCopyRxData() is called with SduLength 7.
    10: Verify whether CanIf_Transmit() is called to send next FC frame for receiving rest of the data.
    11: Call CanTp_TxConfirmation() to confirm transmission of FC frame and to start
        N_Cr for last frame
    12: VP(CanTp.SWS_CanTp_00262_2):
        Call CanTp_CancelReceive and verify that it returns E_NOT_OK indicating that the reception
        is not cancelled as the service is called after N-Cr timeout is started for the
        last Consecutive Frame
    13: Simulate reception of last CF with SN 3.
    14: Verify whether PduR_CanTpRxIndication is called with result E_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00262_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>376</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1353</internalId></specobject>
    <specobject>
      <id>TS_CANTP_CancelRx_INTCF</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>20554</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the reception is cancelled when CancelReceive is called while receiving
    first CF.
  
Test Object: 
    Receive cancellation during reception of intermediate frame.
  
Test Precondition: 
    CanTpBs of used Rx N-SDU is configured as 2 and address type as standard.
  
Test Execution: 
    01: Simulate reception of FF with length 22 on PduId 0.
    02: Verify whether PduR_CanTpStartOfReception() is called with TpSduLength 22.
    03: Verify whether PduR_CanTpCopyRxData() is called with SduLength 6.
    04: Verify that FC CTS is transmitted for receiving next block  and confirm the frame.
    05: VP(CanTp.SWS_CanTp_00261):
        Call CanTp_CancelReceive() and verify that it returned E_OK indicating that
        the reception will be cancelled as called during reception of intermediate frame
        and PduR is notified with E_NOT_OK.
    06: VP(CanTp.ASR40.SWS_CanTp_00260_2):
        Call CanTp_CancelReceive when no reception is in progress and verify that
        it returned E_NOT_OK and Det error CANTP_E_OPER_NOT_SUPPORTED is reported.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00261</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>373</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00260_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>53</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1354</internalId></specobject>
    <specobject>
      <id>TS_CANTP_CancelRx_BlkRequest</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>20676</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the reception will be cancelled when CancelReceive is called while CanTp is
    in buffer request state for next block.
  
Test Object: 
    Receive cancellation during buffer request for next block.
  
Test Precondition: 
    - CanTpBs of used Rx N-SDU is configured as 2 and address type as standard
    - CanTp should be initialized
  
Test Execution: 
    01: Prepare PduR to return a buffer of 20 bytes (which is not sufficient for second block).
    02: Simulate reception of FF with length 26 on PduId 0.
    03: Verify whether buffer is requested correctly to PduR.
    04: Verify that FC CTS is transmitted with BS = 2 for receiving next block and
        confirm the frame.
        (Buffer available = 20-6 = 14; BS = 14/7 = 2;)
    05: Simulate reception of correct CF with SN 1 and sduLength 8
    06: Simulate reception of CF with SN 2 which is the last frame of this block.
    07: Verify that buffer is again requested in next MainFunction call as PduR has not provided
        enough buffer for next block
    08: VP(CanTp.SWS_CanTp_00261):
        Call CanTp_CancelReceive() and verify that it returned E_OK indicating that
        the reception will be cancelled as called during buffer request for next block
        and PduR is notified with E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00261</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>373</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1355</internalId></specobject>
    <specobject>
      <id>TS_CANTP_CancelRx_LF_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>20818</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    - Verify that Cancellation will not be executed if CancelReceive is called
      while expecting last frame and N_Cr has started.
     (The frame received before LF is Last frame of block)
    - Verify that a received last CF NSdu frame with normal addressing
      and NSdu length greater than the data length (specified in N_PCI)
      plus header byte (N_PCI) shall be tolerated, if padding is disabled.
  
Test Object: 
    Receive cancellation
  
Test Precondition: 
    - CanTpBs of used Rx N-SDU is configured as 2 and address type as standard.
    - Padding disabled.
    - CanTp should be initialized
  
Test Execution: 
    01: Simulate reception of FF with length 26 on PduId 0.
    02: Verify whether PduR_CanTpStartOfReception() is called with TpSduLength 26.
    03: Verify whether PduR_CanTpCopyRxData() is called with SduLength 6.
    04: Verify and confirm the FC frame transmitted with BS as 2.
    05: Simulate reception of CF with SN 1 and sduLength 8
    06: Simulate reception of CF with SN 2 which is the last frame of this block.
    07: Verify the next FC frame transmitted, for the rest of the data, with BS 2.
    08: Confirm the FC frame.
    09: VP(CanTp.SWS_CanTp_00262_2):
        Request for receive cancellation and verify that the cancellation is not accepted as
        the N_Cr had already been started and is waiting for the Last frame
    10: Simulate reception of CF with SN 3 which is the first and last frame of this block which
        initializes N_Cr for last frame.
    11: Verify whether PduR_CanTpRxIndication is called with result E_OK.
    12: VP(CanTp.EB.LastCF.RxMinDataLength_NormalAddressing):
        Verify that CanTp provides only the valid data( no padded bytes) to PduR
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00262_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>376</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.LastCF.RxMinDataLength_NormalAddressing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>612</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1356</internalId></specobject>
    <specobject>
      <id>TS_CANTP_FF_PduRInvalidReturn</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>21009</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    - Checking the behavior when PduR_CanTpStartOfReception returns an unknown value while
      receiving FF
  
Test Object: 
    FF reception
  
Test Precondition: 
    CanTp should be initialized
    Address type is standard.
    Padding disabled.
  
Test Execution: 
    01: Prepare PduR to return an invalid value
    02: Simulate reception of FF with length 26 on PduId 0.
    03: Verify whether PduR_CanTpStartOfReception() is called.
    04: VP(CanTp.EB.StartofRx.InvalidReturn):
        Verify whether PduR_CanTpRxIndication is called with result E_NOT_OK
        indicating that the reception is aborted.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.StartofRx.InvalidReturn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>650</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1357</internalId></specobject>
    <specobject>
      <id>TS_CANTP_FF_PduRInvalidReturn_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>21086</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    - Verify whether the segmented reception is aborted when PduR_CanTpCopyRxData returns an invalid
      value while requesting buffer for next block
  
Test Object: 
    Segmented Reception
  
Test Precondition: 
    CanTp should be initialized
    Address Type = STANDARD
  
Test Execution: 
    01: Prepare PduR to return a buffer of 10 bytes (less than that can hold 1 FF + 1 CF).
    02: Simulate reception of FF with length 26 on PduId 0.
    03: Verify whether PduR_CanTpStartOfReception() and PduR_CanTpCopyRxData is called.
    04: Prepare PduR_CanTpCopyRxData to return invalid value.
    05: Elapse one Main cycle and verify whether enough buffer is requested to PduR again.
    06: VP(CanTp.EB.CopyRxData.InvalidReturn):
        Verify whether PduR_CanTpRxIndication is called with result E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CopyRxData.InvalidReturn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>651</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1358</internalId></specobject>
    <specobject>
      <id>TS_CANTP_CF_PduRInvalidReturn</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>21172</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
   - Verify whether the segmented reception is aborted when PduR_CanTpCopyRxData returns an invalid
     value while receiving the CF.
  
Test Object: 
    Segmented reception
  
Test Precondition: 
    Address type as standard.
    Padding disabled.
    CanTp should be initialized
  
Test Execution: 
    01: Prepare PduR to return a buffer of 13 bytes (for 1 FF and 1 CF)
    02: Simulate reception of FF with length 26 on PduId 0.
    03: Verify whether PduR_CanTpStartOfReception() is called with TpSduLength 26.
    04: Verify whether PduR_CanTpCopyRxData() is called with SduLength 6.
    05: Verify and confirm the FC frame transmitted with BS as 2.
    06: VP(CanTp.ISO2004.UnexpectedCF_1):
        Simulate reception of CF with SN 1 which is the first frame of block and verify that it
        is accepted.
        (Call to PduR_CanTpCopyRxData will return only a buffer for the received CF, no buffer
         for next block)
    07: Prepare PduR_CanTpCopyRxData to return an invalid value
    08: VP(CanTp.SWS_CanTp_00269_1):
        Call CanTp_MainFunction and verify that PduR_CanTpCopyRxData is called for getting the
        buffer for next block
    09: Verify whether the reception is aborted and PduR is notified with E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ISO2004.UnexpectedCF_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>899</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00269_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>177</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1359</internalId></specobject>
    <specobject>
      <id>TS_CANTP_CopyTxData_InvalidReturn</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>21310</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify whether the transmission is aborted when PduR_CanTpCopyTxData returns an invalid
    value.
  
Test Object: 
    Unsuccessful Message Transmission
  
Test Precondition: 
    CanTp should be initialized
  
Test Execution: 
    01: PduR_CanTpCopyTxData() shall return an Invalid value.
    02: Start transmission of SF.
    03: VP(CanTp.EB.CopyTxData.InvalidReturn):
        Verify that the transmission is stopped and PduR_CanTpTxConfirmation is called with
        E_NOT_OK
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CopyTxData.InvalidReturn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>652</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1360</internalId></specobject>
    <specobject>
      <id>TS_CANTP_RxSF_NOTOK</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>21378</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    - Verify whether the SF reception is aborted if PduR is not ready to provide enough buffer.
  
Test Object: 
    SF reception
  
Test Precondition: 
    Address type as standard.
    Padding disabled.
    CanTp should be initialized
  
Test Execution: 
    01: Prepare PduR to return BUFREQ_OK but lesser buffer than message length
    02: Simulate reception of SF on CanTpRxNSdu0.
    03: VP(CanTp.SWS_CanTp_00057_FullDuplex_11, CanTp.SWS_CanTp_00079):
        Verify whether buffer is requested correctly to PduR.
    04: Set the return of PduR_CanTpCopyRxData to BUFREQ_E_NOT_OK
    05: Elapse one main cycle and verify that enough buffer is requested to PduR again
    06: VP(CanTp.ASR40.CopyRxData.BufferNotReserved.4):
        Verify whether the reception is aborted and PduR is notified with E_NOT_OK
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_FullDuplex_11</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>316</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00079</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>151</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.CopyRxData.BufferNotReserved.4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>487</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1361</internalId></specobject>
    <specobject>
      <id>TS_CANTP_CopyTxData_NOT_OK</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>21476</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the transmission will be aborted when PduR_CanTpCopyTxData returns BUFREQ_E_NOT_OK
    in between.
  
Test Object: 
    Message transmission
  
Test Precondition: 
  
Test Execution: 
    01: Simulate transmission of FF with message length 8.
    02: Elapse a MainFunction tick.
    03: Verify whether PduR_CanTpCopyTxData() is called with SduLength = 6.
    04: Verify whether CanIf_Transmit() called to transmit FF with SduLength 8.
    05: Call CanTp_TxConfirmation() to confirm transmission of FF.
    06: Prepare PduR_CanTpCopyTxData to return BUFREQ_E_NOT_OK.
    07: Simulate the reception of FC CTS frame with PduId 9 and verify that PduR_CanTpCopyTxData
        is called.
    08: VP(CanTp.ASR40.CopyTxData_Error):
        Check whether PduR_CanTpTxConfirmation is called with Result E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.CopyTxData_Error</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>542</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1362</internalId></specobject>
    <specobject>
      <id>TS_CANTP_InvalidRxLength</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>21583</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    - Verify whether Det error CANTP_E_INVALID_RX_LENGTH is reported when an intermediate CF is
      received with N-Pdu length less than 8.
  
Test Object: 
    Reception of CF with wrong SduLength
  
Test Precondition: 
    Address type configured is standard.
    Padding disabled.
    CanTp should be initialized
  
Test Execution: 
    01: Simulate reception of FF with length 20 on PduId 0.
    02: Verify whether PduR_CanTpStartOfReception() is called with TpSduLength 20.
    03: Verify whether PduR_CanTpCopyRxData() is called with SduLength 6.
    04: Verify and confirm the FC frame transmitted with BS as 2.
    05: Simulate reception of CF with SN 1 with SduLength less than 8.
    06: VP(CanTp.EB.IntFrame.InvalidRxLength):
        Verify whether Det error CANTP_E_INVALID_RX_LENGTH is reported.
    07: Simulate reception of correct CF with SN 1 and sduLength 8.
    08: Receive second(last) CF and finish the reception successfully.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.IntFrame.InvalidRxLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>625</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1363</internalId></specobject>
    <specobject>
      <id>TS_CANTP_FF_InvalidRxId</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>21720</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that DET error is reported when CanTp_RxIndication is called for FF with CanTpRxPduId
    of a configured TX FC-Pdu in standard addressing.
  
Test Object: 
    Error detection
  
Test Precondition: 
    CanTp should be initialized.
    Use standard addressing.
  
Test Execution: 
    01: Call CanTp_RxIndication() for FF with PduId that is configured for FC frame.
    02: VP(CanTp.EB.RxIndication.InvalidRxId_1):
        Check that Det error CANTP_E_INVALID_RX_ID is reported.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.RxIndication.InvalidRxId_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>645</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1364</internalId></specobject>
    <specobject>
      <id>TS_CANTP_SF_InvalidRxId</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>21784</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that DET error is reported when CanTp_RxIndication is called for SF with CanTpRxPduId which
    is configured for FC frame and the FC id must be from an NSdu configured for standard addressing.
  
Test Object: 
    Error detection
  
Test Precondition: 
    CanTp should be initialized.
    Used N-Sdu should be configured for standard addressing.
  
Test Execution: 
    01: Call CanTp_RxIndication() for SF with PduId that is configured for FC frame.
    02: VP(CanTp.EB.RxIndication.InvalidRxId_3):
        Check that Det error CANTP_E_INVALID_RX_ID is reported.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.RxIndication.InvalidRxId_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>647</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1365</internalId></specobject>
    <specobject>
      <id>TS_CANTP_FC_InvalidRxId</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>21848</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that Det error will be reported if FC frame is received with CanTpRxPduId corresponding
    to a Rx-N-Sdu, which is configured for standard addressing.
  
Test Object: 
    Det error reporting while receiving FC frame.
  
Test Precondition: 
   CanTp should be initialized.
   Used N-Sdu should be configured for standard addressing.
  
Test Execution: 
    01: Simulate reception of FC CTS with CanTpRxPduId corresponding to an Rx-N-Sdu which is
        configured for standard addressing.
    02: VP(CanTp.EB.RxIndication.InvalidRxId_2):
        Check that Det error CANTP_E_INVALID_RX_ID is reported.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.RxIndication.InvalidRxId_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>646</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1366</internalId></specobject>
    <specobject>
      <id>TS_CANTP_N_Cs_SmallerBuffer</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>21916</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the CAN TP can do multiple requests using PduR_CanTpCopyTxData() to obtain the data to send.
    Part 1/2: when no data is given (BUFREQ_E_BUSY).
  
Test Object: 
    Message transmission
  
Test Precondition: 
  
Test Execution: 
    01: PduR_CanTpCopyTxData() shall return BUFREQ_E_BUSY.
    02: Call CanTp_Transmit() with PduId 0 and SduLength 13 and check that it returns E_OK.
    03: Elapse N_Cs mainfunction invocations.
    04: VP(CanTp.SWS_CanTp_00184):
        Check that module retries with call to PduR_CanTpCopyTxData().
    05: Check if PduR is not notified.
    06: Elapse mainfunction tick and simulated N_Cs timeout.
    07: VP(CanTp.SWS_CanTp_00167_2):
        Check that the transmission is aborted and PduR_CanTpTxConfirmation() was called with
        result E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00184</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>206</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00167_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>202</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1367</internalId></specobject>
    <specobject>
      <id>TS_CANTP_Normal_Functional</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>22021</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a request to transmit data of length 7 is accepted when corresponding NSdu is
    configured for normal addressing and functional communication type.
  
Test Object: 
    Message transmission
  
Test Precondition: 
   - Use normal addressing format and functional communication type
   - CanTp should be initialized
  
Test Execution: 
    01: VP(CanTp.11299, CanTp.ISO15765.SF.Format):
        Call CanTp_Transmit() with PduId 0 and SduLength 7 (maximum size of SF)
        in normal addressing mode and check that it returns E_OK.
    02: Elapse a MainFunction tick.
    03: VP(CanTp.ASR40.SWS_CanTp_00226):
        Verify whether PduR_CanTpCopyTxData() is called.
    04: VP(CanTp.SWS_CanTp_00216_1):
        Verify whether CanIf_Transmit() is called to transmit SF with SduLength 8 and verify
        that the data transmitted is same as that provided by PduR.
    05: Call CanTp_TxConfirmation() to confirm the Pdu sent.
    06: Check whether PduR_CanTpTxConfirmation is called with result E_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00226</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>25</internalId></provcov>
        <provcov>
          <linksto>CanTp.11299</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>844</internalId></provcov>
        <provcov>
          <linksto>CanTp.ISO15765.SF.Format</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>840</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00216_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>403</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1368</internalId></specobject>
    <specobject>
      <id>TS_CANTP_SF_RECEPTION_POSTONED</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>22127</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that SF is postponed for RxIndication.
  
Test Object: 
    CanTp_PostPoneRxIndication()
  
Test Precondition: 
  
Test Execution: 
    01: Simulate the reception of segmented message with length 10.
    02: Verify if FC is transmitted and confirmed.
    03: Complete the reception.
    04: Simulate the reception of SF.
    05: VP(CanTp.ASR40.SWS_CanTp_00257, CanTp.SWS_CanTp_00262_1):
        Verify that Channel if is lock.
  
Test Input: 
    send FF (only 1 CF missing), call cancellation request -&gt; request rejected (ERROR returned)
    send SF, call postponed request -&gt; request rejected (ERROR returned).
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00262_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>375</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00262_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>376</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00257</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>50</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.CanTp_RxIndication.SFPostPoneRxIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>757</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1369</internalId></specobject>
    <specobject>
      <id>TS_CANTP_Ncs_SmallerThan_STmin</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>22236</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that PduR buffer for CF is requested until it becomes available,
    before N_Cs expire and CF is sent when STmin expires without requesting
    buffer again.
    Verify that transmission is aborted when PduR buffer is not available.
  
Test Object: 
  
Test Precondition: 
  
Test Execution: 
    01: Transmit FF.
    02: Confirm FF.
    03: Receive FC with STmin = 4 and BS = 3.
    04: Transmit CF with N_Cs value 2.
    05: Confirm first CF.
    06: Make PduR buffer busy.
    07: Elapse a MainFunction cycle and check that PduR data were requested.
    08: Make PduR buffer available.
    09: Check that PduR buffer was again requested before N_Cs timeout.
    10: Transmit CF at STmin timeout.
    11: Confirm CF.
    12: Check that transmission is done.
    13: Transmit FF.
    14: Confirm FF.
    15: Receive FC with STmin = 4 and BS = 3.
    16: Transmit CF with N_Cs value 2.
    17: Confirm first CF.
    18: Make PduR buffer busy.
    19: Elapse a MainFunction cycle and check that PduR data were requested.
    20: Make PduR buffer not available.
    21: Check that PduR buffer was again requested before N_Cs timeout.
    22: Check that transmission is done with result E_NOT_OK because of PduR returning BUFREQ_E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.11236</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>894</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1370</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_30329</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_2/source/application/Tests.c</sourcefile>
      <sourceline>167</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CAN TP sends FC(WT) frames immediately if N_Br is set to 0.
  
Test Object: 
    N_Br
  
Test Precondition: 
    N_Br = 0
  
Test Execution: 
    01: PduR shall return BUFREQ_E_BUSY.
    02: Transmit a FF - PDU Id = 8, length = 16 - standard addressing - Padding is on.
    03: Elapse a MainFunction tick and verify that buffer is requested to PduR through
        PduR_CanTpCopyRxData.
    04: VP(CanTp.ASR40.SWS_CanTp_00082_2):
        Wait frame must have been sent and confirm.
    05: PduR shall return BUFREQ_OK and provide enough buffer for the FF(but not for
        next block and elapse one main function cycle.
    06: Verify whether FC WAIT frame is sent as enough buffer is not available for the next block.
    07: Confirm the wait frame.
    08: Prepare PduR to return BUFREQ_OK and enough buffer for rest of the frame.
    09: Elapse one mainfunction tick and verify whether FC CTS frame is sent.
    10: Confirm the CTS frame and finish the reception successfully.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00082_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>22</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1371</internalId></specobject>
    <specobject>
      <id>TS_CANTP_ZeroBrForFF</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_2/source/application/Tests.c</sourcefile>
      <sourceline>296</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CAN TP sends FC(WT) frames immediately if buffer is not available during FF
    reception and if N_Br is set to 0.
    Verify that reception will be aborted after WFTmax consecutive FC(WAIT) frames.
  
Test Object: 
    N_Br handling
  
Test Precondition: 
    N_Br = 0
  
Test Execution: 
    01: Prepare PduR_CanTpCopyRxData to return BUFREQ_E_BUSY.
    02: Receive an FF with length 16 and verify the PduR calls.
    03: VP(CanTp.ASR40.SWS_CanTp_00166_1):
        Verify that the WAIT frame is transmitted immediately as N_Br = 0 indicating
        that the behavior during timeout is handled correctly even though N_Br = 0.
    04: Confirm the WAIT frame.
    05: Loop over steps 06 to 08 for CanTpRxWftMax = 3 times.
    06: Elapse a MainFunction tick and verify that buffer is requested.
    07: VP(CanTp.SWS_CanTp_00223_1):
        Verify that the WAIT frame is transmitted.
    08: Confirm the WAIT frame.
    09: Call CanTp_MainFunction.
    10: VP(CanTp.SWS_CanTp_00223_2):
        Verify that the reception is aborted as maximum of WFTmax consecutive FC(WAIT) frames
        were sent and E_NOT_OK is reported to PduR.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00166_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>14</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00223_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>172</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00223_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>173</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1372</internalId></specobject>
    <specobject>
      <id>TS_CANTP_ZeroBrForBlockLF</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_2/source/application/Tests.c</sourcefile>
      <sourceline>417</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CAN TP sends FC(WT) frames immediately if buffer is not available during reception
    of last frame of block and if N_Br is set to 0.
  
Test Object: 
    N_Br handling
  
Test Precondition: 
    - CanTp should be initialized
    - Configure normal addressing mode
    - N_Br = 0
  
Test Execution: 
    01: Prepare PduR to return BUFREQ_OK and available bufferSize as 20.
    02: Receive FF with message length 32 and verify the PduR calls.
    03: Verify that the FC CTS frame is transmitted with BS 2
        ( Buffer available for block = 20- 6(FF) = 14;
          BS = (no: of CFs which can be received with available buffer = 14/7 = 2;
        ).
    04: Confirm the FC.
    05: VP(CanTp.ISO2004.UnexpectedCF_1):
        Receive the first CF which is expected and verify that the buffer is requested.
    06: Prepare PduR to return less buffer than required for next block.
    07: VP(CanTp.ISO2004.UnexpectedCF_1):
        Receive second CF which is the last CF of block and verify that the CF is accepted.
    08: VP(CanTp.ASR40.SWS_CanTp_00166_3, CanTp.SWS_CanTp_00325):
        Verify that the WAIT frame is transmitted immediately as N_Br = 0 indicating
        that the behavior during timeout is handled correctly even though N_Br = 0 and confirm
        the frame.
    09: VP(CanTp.ISO2004.UnexpectedCF_2):
        Receive unexpected CF and verify that the CF is ignored.
    10: Loop over steps 11 to 13 for CanTpRxWftMax = 3 times.
    11: Elapse a MainFunction tick and verify that buffer is requested.
    12: VP(CanTp.SWS_CanTp_00223_1):
        Verify that the WAIT frame is transmitted.
    13: Confirm the WAIT frame.
    14: Call CanTp_MainFunction to elapse the timeout CanTpRxWftMax*(N_Br+N_Ar) = 3*(0+1).
    15: VP(CanTp.SWS_CanTp_00223_2):
        Verify that the reception is aborted as maximum of WFTmax consecutive FC(WAIT) frames
        were sent and E_NOT_OK is reported to PduR.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00166_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>16</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00223_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>172</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00223_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>173</internalId></provcov>
        <provcov>
          <linksto>CanTp.ISO2004.UnexpectedCF_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>899</internalId></provcov>
        <provcov>
          <linksto>CanTp.ISO2004.UnexpectedCF_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>900</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00325</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>168</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1373</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30275</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_2/source/application/Tests.c</sourcefile>
      <sourceline>600</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CAN TP handles Tx Confirmations called during the call of CanIf_Transmit() for a SF
    correctly.
  
Test Object: 
    Express Tx confirmation.
  
Test Precondition: 
  
Test Execution: 
    01: Transmit one byte as SF via CanTp Tx PDU 0.
    02: Check if CanIf_Transmit() was called during the transmission.
    03: Verify correct transmission.
    04: VP(CanTp.EB.ExpressTxConfirmation):
        Check if CanTp_TxConfirmation() for SF, called from CanIf_Transmit callout function
        is accepted and PduR is notified of successful transmission.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.ExpressTxConfirmation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>601</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1374</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30280</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_2/source/application/Tests.c</sourcefile>
      <sourceline>683</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CAN TP handles Tx Confirmations called during the call of CanIf_Transmit() for
    a FF and CF correctly.
  
Test Object: 
    Express Tx confirmation.
  
Test Precondition: 
  
Test Execution: 
    01: Transmit 10 bytes via CanTp Tx PDU 0.
    02: Check that CanIf_Transmit() is called to transmit FF and to confirm the FF.
    03: Indicate FlowControl on FC Pdu Id = 9, corresponds to NSduId 0,
        with BS = 0 and StMin = 0.
    04: Check that CanIf_Transmit() is called to transmit CF and to confirm the CF.
    05: VP(CanTp.EB.ExpressTxConfirmation):
        Check if transmission is completed.
    06: Check if CanIf_Transmit() was called during the transmission.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.ExpressTxConfirmation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>601</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1375</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30281</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_2/source/application/Tests.c</sourcefile>
      <sourceline>777</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CAN TP handles Tx Confirmations called during the call of CanIf_Transmit() for a
    FC CTS correctly.
  
Test Object: 
    Express Tx confirmation
  
Test Precondition: 
  
Test Execution: 
    01: Receive a FF - PDU Id = 8, length = 10 - standard addressing - Padding is on.
    02: Check if CanIf_Transmit() was called to transmit CTS and to confirm the frame, during the
        reception.
    03: Receive a CF - PDU Id = 8, SN = 1.
    04: VP(CanTp.EB.ExpressTxConfirmation):
        Verify that the CF is accepted indicating that the FF got already confirmed from
        CanIf_Transmit().
    05: Verify correct reception.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.ExpressTxConfirmation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>601</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1376</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30283</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_2/source/application/Tests.c</sourcefile>
      <sourceline>856</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CAN TP handles Tx Confirmations called during the call of CanIf_Transmit()
    for a FC OVFLW correctly.
  
Test Object: 
    Express Tx confirmation.
    Padding is disabled.
    Standard addressing.
  
Test Precondition: 
  
Test Execution: 
    01: PduR_CanTpStartOfReception shall return BUFREQ_E_OVFL.
    02: Start a segmented reception (standard addressing) with message length 10.
    03: VP():
        Since padding is disabled, verify that FC(OVFL) is sent with L-SDU length = 3.
    04: VP(CanTp.EB.ExpressTxConfirmation):
        Verify that the FC confirmation is performed successfully in the context of
        CanIf_Transmit().
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.ExpressTxConfirmation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>601</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1377</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30279</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_2/source/application/Tests.c</sourcefile>
      <sourceline>930</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CAN TP handles GPT callbacks called during the call of Gpt_StartTimer() correctly.
  
Test Object: 
    Express GPT callback
  
Test Precondition: 
  
Test Execution: 
    01: Transmit 14 bytes via CanTp Tx PDU 0 with FC Pdu Id = 9.
    02: Confirm the FF.
    03: Receive FlowControl: Pdu Id = 9, continue to send BS = 0, StMin = 100us.
    04: Confirm the first CF.
    05: VP(CanTp.EB.Gpt.STminHandling_2b ):
        Verify whether Gpt is started which makes an express Gpt call to Channel 1.
    06: Confirm the second and last CF.
    07: Verify correct transmission.
    08: Check if transmission is completed.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.Gpt.STminHandling_2b</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>556</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1378</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30285</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_2/source/application/Tests.c</sourcefile>
      <sourceline>1029</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CAN TP handles Rx Indications of a FC called during the call of CanIf_Transmit()
    correctly.
  
Test Object: 
    Express Rx indication.
  
Test Precondition: 
  
Test Execution: 
    01: Transmit 10 bytes via CanTp Tx PDU 0.
    02: Verify that FF is transmitted.
    03: VP(CanTp.EB.ExpressTxConfirmation, CanTp.EB.ExpressRxIndication):
        Verify that CanIf_Transmit is called for CF, indicating that
        FF is confirmed and FC is also received from CanIf_Transmit call of FF.
    04: Verify correct transmission.
    05: Check if the transmission is completed.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.ExpressTxConfirmation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>601</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.ExpressRxIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>602</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1379</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30286</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_2/source/application/Tests.c</sourcefile>
      <sourceline>1122</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CAN TP handles Rx Indications of a CF called during the call of CanIf_Transmit()
    correctly.
  
Test Object: 
    Express Rx indication
  
Test Precondition: 
  
Test Execution: ]
    01: Receive a FF - PDU Id = 8, length = 10 - standard addressing - Padding is on.
    02: Check if CanIf_Transmit() was called to transmit and to confirm the CTS, during the
        reception.
    03: VP(CanTp.EB.ExpressTxConfirmation, CanTp.EB.ExpressRxIndication):
        Verify that the reception is successfully completed as the confirmation for FC and
        indication of CF frame is already received from CanIf_Transmit.
  
Test Input: 
  
Test Output: 
    The reception of the PDU will be correctly processed.
    The reception succeeds.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.ExpressTxConfirmation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>601</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.ExpressRxIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>602</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1380</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30287</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_2/source/application/Tests.c</sourcefile>
      <sourceline>1205</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CAN TP module throws a Det error when a postponed frame is overwritten.
    correctly.
  
Test Object: 
    Det error will be reported, when a postponed frame is overwritten.
  
Test Precondition: 
  
Test Execution: ]
    01: Receive a FF - PDU Id = 8, length = 30 - standard addressing - Padding is on.
    02: Check if CanIf_Transmit() was called to transmit and to confirm the CTS, during the
        reception.
    03: VP(CanTp.EB.OverwritePostponedFrame):
        Check that Det error will be reported, if a postponed frame is overwritten.
  
Test Input: 
  
Test Output: 
    The reception does not succeed.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.ExpressTxConfirmation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>601</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.ExpressRxIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>602</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.OverwritePostponedFrame</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>641</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1381</internalId></specobject>
    <specobject>
      <id>TS_CANTP_STmin_MF_CLBK</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_2/source/application/Tests.c</sourcefile>
      <sourceline>1281</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that CanTp_CancelTransmit will cancel the transmission while waiting for STmin and when
    CanTpSTminTimeoutHandling is controlled by CanTp_MainFunction.
  
Test Object: 
    STmin handling
  
Test Precondition: 
    CanTp should be initialized.
    Gpt usage should be enabled.
    Configure CanTpMainFunction for STmin timeout handling for CanTpChannel_1.
  
Test Execution: 
    01: Simulate transmission of FF with message length 20 bytes.
    02: Call CanTp_MainFunction.
    03: Check that the FF has been sent correctly.
    04: Confirm the FF.
    05: Send the FC frame so that CAN TP continues the transfer.
    06: Verify that CAN TP has sent the first CF.
    07: Confirm the CF.
    08: VP(CanTp.EB.MainFunction.STminHandling_1):
        Call CanTp_MainFunction and verify that no CF is transmitted as CanTp has to wait for
        STmin.
    09: Call CanTp_CancelTransmit while waiting for STmin to cancel the transmission
        and verify that it is accepted.
    10: VP(CanTp.SWS_CanTp_00274, CanTp.SWS_CanTp_00243):
        Check whether transmission got cancelled and PduR is notified with E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MainFunction.STminHandling_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>551</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00274</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>145</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00243</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>146</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1382</internalId></specobject>
    <specobject>
      <id>TS_CANTP_Con02_FirstTxDataRequest</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_2/source/application/Tests.c</sourcefile>
      <sourceline>1410</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test shall verify that the first call of PduR_CanTpCopyTxData() shall be used to get the
    amount of actual available data. PduR_CanTpCopyTxData() shall be called with
    info-&gt;SduDataPtr = NULL_PTR and info-&gt;SduLength = 0.
  
Test Object: None.
Test Precondition: 
    - CanTp shall be initialized.
    - TxNSdu shall be configured for standard addressing.
    - CanTpSTminTimeoutHandling shall be set to CanTpMainFunction.
  
Test Execution: 
    01: Start a transmission with message length of 10 bytes.
    02: Call CanTp_MainFunction to perform transmission.
    03: VP(CanTp.ASR40.CopyTxData.RequestFirstData)
        Verify that the first call PduR_CopyTxData uses info-&gt;SduDataPtr = NULL_PTR and
        info-&gt;SduLength = 0.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.CopyTxData.RequestFirstData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>514</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1383</internalId></specobject>
    <specobject>
      <id>TS_CANTP_Con02_TxNoDataRequest</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_2/source/application/Tests.c</sourcefile>
      <sourceline>1517</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test shall verify that if no data are announced by the upper layer, the module shall call
    PduR_CanTpCopyTxData() with info-&gt;SduDataPtr = NULL_PTR and info-&gt;SduLength = 0.
  
Test Object: None.
Test Precondition: 
    - CanTp shall be initialized.
    - TxNSdu shall be configured for standard addressing.
    - CanTpSTminTimeoutHandling shall be set to CanTpMainFunction.
  
Test Execution: 
    01: Start a transmission with message length of 9 bytes.
    02: Prepare the PduR to only provide the data for the first frame.
    03: Perform transmission of the FF.
    04: Prepare the PduR to provide the data for the last CF.
    05: Continue transmission.
    06: VP: Verify that the module requests more data since AvailableDatatPtr of the last call of
        PduR_CanTpCopyTxData() announced zero.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.CopyTxData.RequestMoreData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>516</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1384</internalId></specobject>
    <specobject>
      <id>TS_CANTP_Con02_TxDataRequest</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_2/source/application/Tests.c</sourcefile>
      <sourceline>1635</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test shall verify that the module does not request more data to transmit as announced by
    the upper layer during the last call of PduR_CanTpCopyTxData().
  
Test Object: 
    STmin handling
  
Test Precondition: 
    - CanTp shall be initialized.
    - TxNSdu shall be configured for standard addressing.
    - CanTpSTminTimeoutHandling shall be set to CanTpMainFunction.
    - Padding shall be disabled to verify correct data transmission.
  
Test Execution: 
    01: Start a transmission with message length of 30 bytes.
    02: Provide the data in 8 byte blocks and provide only a new block if all available data is
        consumed.
    03: Perform transmission of the FF.
    04: VP: Verify that module does not request more data as announced by the upper layer.
    Loop until transmission is finished
      04: VP: Verify that module does not request more data as announced by the upper layer.
      05: Provide the data in 8 byte blocks and provide only a new block if all available data is
          consumed.
      06: Confirm every sent frame to continue transmission.
      07: If no frame is sent, call CanTp_MainFunction to continue transmission.
      08: VP: Verify that module does not request more data as announced by the upper layer.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.CopyTxData.RequestData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>515</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1385</internalId></specobject>
    <specobject>
      <id>TS_CANTP_Con02_TxNoDataAvailable</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_2/source/application/Tests.c</sourcefile>
      <sourceline>1854</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test shall verify that if no data are announced by the upper layer, the module shall call
    PduR_CanTpCopyTxData() with info-&gt;SduDataPtr = NULL_PTR and info-&gt;SduLength = 0.
  
Test Object: None.
Test Precondition: 
    - CanTp shall be initialized.
    - TxNSdu shall be configured for standard addressing.
    - CanTpSTminTimeoutHandling shall be set to CanTpMainFunction.
  
Test Execution: 
    01: Start a transmission with message length of 9 bytes.
    02: Prepare the PduR to provide no data.
    03: VP():
        Verify whether the buffer request is again made in the next cycle with SduLength as 0.
    04: Prepare the PduR to provide the data for FF.
    05: Verify and confirm transmission of FF.
    06: Prepare the PduR to provide no data for the last CF.
    07: Receive FC frame.
    08: VP():
        Verify whether the buffer request is again made in the next cycle with SduLength as 0.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.CopyTxData.RequestMoreData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>516</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1386</internalId></specobject>
    <specobject>
      <id>TS_CANTP_Con03_ST_MIX_EXT_CAN20_SF_Transmission_PduLengthLessThan8</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_2/source/application/Tests.c</sourcefile>
      <sourceline>1995</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test shall verify that CAN 2.0 Single Frame transmission with STANDARD, MIXED or
    EXTENDED addressing format is possible even if it has a PduLength configured to a value
    smaller than 8 bytes.
  
Test Object: None.
Test Precondition: 
    - CanTp shall be initialized.
    - Addressing format for TxNSdu shall be configured to the bellow defined values:
        CANTP_STANDARD
        CANTP_MIXED
        CANTP_EXTENDED
    - Padding is off
    - Flexible Data support is disabled
    - TaType is FUNCTIONAL
  
Test Execution: 

    Testing if transmission of a TxNSdu with a CANTP_STANDARD addressing format, with the below define value
    for PduLength i possible
    - PduLength 2:  1
    - PduLength 3:  1, 2
    - PduLength 4:  1, 2, 3
    - PduLength 5:  1, 2, 3, 4
    - PduLength 6:  1, 2, 3, 4, 5
    - PduLength 7:  1, 2, 3, 4, 5, 6
    01: Init stubs and variables
    02: Send SF with CANTP_STANDARD addressing format
    03: Check that PduR_CanTpCopyTxData was called
    04: Check that CanIf_Transmit was called
    05: Confirm sent SF
    06: Verify successful transmission

    Testing that transmission of a CanTpTxNSdu with a payload length of 1 byte
    and with CANTP_MIXED or CANTP_EXTENDED addressing format is possible
    07: Send SF with CANTP_MIXED or CANTP_EXTENDED addressing format
    08: Call CanTp_MainFunction to trigger transmission of a SF with EXTENDED/MIXED addressing format
    09: Check that PduR_CanTpCopyTxData was called
    10: Check that CanIf_Transmit was called
    11: Confirm sent SF
    12: Verify successful transmission

  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.TX.STANDARD_AddressingFormat_PaddingOff_PduLengthSmallerThan8</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>667</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.TX.MIXED_AddressingFormat_PaddingOff_PduLengthSmallerThan8</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>668</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.TX.EXTENDED_AddressingFormat_PaddingOff_PduLengthSmallerThan8</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>669</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1387</internalId></specobject>
    <specobject>
      <id>TS_CANTP_Con04_ST_MIX_EXT_CAN20_SF_Reception_PduLengthLessThan8</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_2/source/application/Tests.c</sourcefile>
      <sourceline>2226</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test shall verify that CAN 2.0 Single Frame reception with STANDARD, MIXED or
    EXTENDED addressing format is possible even if it has a PduLength configured to a value
    smaller than 8 bytes.
  
Test Object: None.
Test Precondition: 
    - CanTp shall be initialized.
    - Addressing format for RxNSdu shall be configured to the bellow defined values:
        CANTP_STANDARD
        CANTP_MIXED
        CANTP_EXTENDED
    - Padding is off
    - Flexible Data support is disabled
    - TaType is FUNCTIONAL
  
Test Execution: 
    01: Receive SF with STANDARD addressing format and length of 1 byte
    02: Check that SF was successfully received and that PduR was notified
    03: Receive SF with STANDARD addressing format and length of 2 bytes
    04: Check that SF was successfully received and that PduR was notified
    05: Receive SF with STANDARD addressing format and length of 3 bytes
    06: Check that SF was successfully received and that PduR was notified
    07: Receive SF with STANDARD addressing format and length of 4 bytes
    08: Check that SF was successfully received and that PduR was notified
    09: Receive SF with STANDARD addressing format and length of 5 bytes
    10: Check that SF was successfully received and that PduR was notified
    11: Receive SF with STANDARD addressing format and length of 6 bytes
    12: Check that SF was successfully received and that PduR was notified
    13: Receive SF with MIXED addressing format and length of 1 byte
    14: Check that SF was successfully received and that PduR was notified
    15: Receive SF with EXTENDED addressing format and length of 1 byte
    16: Check that SF was successfully received and that PduR was notified
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.RX.STANDARD_AddressingFormat_PaddingOff_PduLengthSmallerThan8</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>670</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.RX.MIXED_AddressingFormat_PaddingOff_PduLengthSmallerThan8</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>671</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.RX.EXTENDED_AddressingFormat_PaddingOff_PduLengthSmallerThan8</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>672</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1388</internalId></specobject>
    <specobject>
      <id>TS_CANTP_Check_Against_NULL_PTR</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_2/source/application/Tests.c</sourcefile>
      <sourceline>2414</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanTp_ReadParameter is protected against NULL_PTR.
  
Test Object: 
  
Test Precondition: 
  
Test Execution: 
    01: Call CanTp_ReadParameter with NULL_PTR.
    02: Verify Det was called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanTp_ReadParameter.CheckAgainstValueNULL_PTR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>759</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1389</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_30295</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_3/source/application/Tests.c</sourcefile>
      <sourceline>118</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that the CAN TP respects separation time (STmin). Part 1/3 (STmin in ms).
  
Test Object: 
    STmin handling
  
Test Precondition: 
  
Test Execution: 
    01: Check CanTp_Transmit to transmit a message of length 20 bytes and the FF has been sent.
    02: Confirm the FF sent.
    03: A FF should have been sent with a SduLength of 8 (2 NP_CI + 6 data).
    04: Send the FC frame so that CAN TP continues the transfer.
    05: Verify that CAN TP has sent the first CF and is waiting for STmin to expire
        before sending the second CF.
    06: Call MainFunction periodically to simulate Schedule Manager 10ms will result
        in a counter value of 11.
    07: VP(CanTp.EB.MainFunction.STminHandling_1, CanTp.11222, CanTp.EB.MainFunction.STminHandling_2):
        Check timing.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MainFunction.STminHandling_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>551</internalId></provcov>
        <provcov>
          <linksto>CanTp.11222</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>880</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MainFunction.STminHandling_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>553</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1390</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30296</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_3/source/application/Tests.c</sourcefile>
      <sourceline>254</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that the CAN TP respects separation time (STmin). Part 2/3 (STmin in us).
  
Test Object: 
    STmin handling
  
Test Precondition: 
   * Main function period is set to 1ms.
  
Test Execution: 
    01: Start a segmented transmission with message length 20 bytes.
    02: Send the FC(CTS) frame with STmin = 500us and continue transmission.
    03: Call main function to simulate progress of time until STmin elapsed.
    04: VP(CanTp.EB.MainFunction.STminHandling_1, CanTp.11269):
        Verify that STmin will elapse at the second main function call.
        (STmin = 0.5ms will be round up to wait for at least 1 full main function period.)
        Verify that next CF is sent when STmin elapsed.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MainFunction.STminHandling_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>551</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MainFunction.STminHandling_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>553</internalId></provcov>
        <provcov>
          <linksto>CanTp.11269</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>881</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1391</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30324</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_3/source/application/Tests.c</sourcefile>
      <sourceline>363</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that the CAN TP respects separation time (STmin). Part 3/3 (invalid STmin value).
    - Verify that CanTp will be using a default value 0x7F for STmin if an FC with invalid STmin
      value is received .
  
Test Object: 
    STmin handling
  
Test Precondition: 
   - Configure normal addressing type for CanTpTxNSdu4.
   - CanTp should be initialized.
  
Test Execution: 
    01: Simulate segmented transmission for data length of 20 bytes (FF+2CFs).
    02: Check that the FF has been sent with a SduLength of 8 (2 NP_CI + 6 data).
    03: Send the FC frame with Stmin as 0xFD(reserved value).
    04: Verify that CAN TP has sent the first CF.
    05: Confirm the first CF, which will start the STmin timeout.
        (As STmin received is a reserved value, CanTp will use the value 0x7F =127ms
         as specified by ISO)
    06: VP(CanTp.EB.MainFunction.STminHandling_1, CanTp.11270):
        Call MainFunction periodically to simulate STmin timeout and verify that second CF
        will be transmitted after STmin(127) timeout.
    07: VP(CanTp.EB.MainFunction.STminHandling_2):
        Elapse one main cycle so that STmin timeout(127ms) is reached and verify that last CF is
        sent.
    08: Confirm the last CF and verify that PduR is notified about the successful transmission.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MainFunction.STminHandling_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>551</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MainFunction.STminHandling_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>553</internalId></provcov>
        <provcov>
          <linksto>CanTp.11270</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>882</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1392</internalId></specobject>
    <specobject>
      <id>TS_CANTP_Mixed_Functional_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_3/source/application/Tests.c</sourcefile>
      <sourceline>500</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a request to transmit data of length 6 is accepted when corresponding N-Sdu is
    configured for mixed addressing and functional communication type.
  
Test Object: 
    Message transmission
  
Test Precondition: 
   - Use mixed addressing format and functional communication type
   - CanTp should be initialized
  
Test Execution: 
    01: VP(CanTp.ISO15765.SF.Format):
        Call CanTp_Transmit() with PduId 0 and SduLength 6 (maximum size of SF)
        in normal addressing mode and check that it returns E_OK.
    02: Elapse a MainFunction tick.
    03: VP(CanTp.ASR40.SWS_CanTp_00226):
        Verify whether PduR_CanTpCopyTxData() is called.
    04: VP(CanTp.SWS_CanTp_00216_1):
        Verify whether CanIf_Transmit() is called.
    05: Call CanTp_TxConfirmation() to confirm the Pdu sent.
    06: Check whether PduR_CanTpTxConfirmation is called with result E_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00226</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>25</internalId></provcov>
        <provcov>
          <linksto>CanTp.ISO15765.SF.Format</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>840</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00216_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>403</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1393</internalId></specobject>
    <specobject>
      <id>TS_CANTP_Mixed_Functional_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_3/source/application/Tests.c</sourcefile>
      <sourceline>594</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a request to transmit data of length 7 is rejected when corresponding N-Sdu is
    configured for mixed addressing and functional communication type.
  
Test Object: 
    Message transmission
  
Test Precondition: 
   - Use mixed addressing format and functional communication type
   - CanTp should be initialized
  
Test Execution: 
    01: VP(CanTp.SWS_CanTp_00092):
        Call CanTp_Transmit() with PduId 1 and SduLength 7.
        mixed addressing mode is set, functional addressing.
        Check that it returns E_NOT_OK.
    02: VP(CanTp.EB.Functional.MixedAddr):
        Det error TEST_CANTP_E_INVALID_TATYPE is reported.
    03: Check that PduR_CanTpTxConfirmation() was not called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.Functional.MixedAddr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>655</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00092</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>222</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1394</internalId></specobject>
    <specobject>
      <id>TS_CANTP_NPduNSaFiltering</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_3/source/application/Tests.c</sourcefile>
      <sourceline>672</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test shall verify that if a frame with extended addressing is received, the module shall
    compare the configuration parameter CanTpNSa of each matching Rx N-Pdu with the target address
    of the frame to get the right Rx N-Sdu.
  
Test Object: 
    Reception on two different N-Sdus with same N-Pdu Id and different NSa.
  
Test Precondition: 
    - CanTp should be initialized.
    - Configure extended addressing mode.
    - Use the following configuration
      N-SDU           N_Sa       N_Pdu Id
      CanTpRxNSdu1    245U         1
      CanTpRxNSdu2    242U         1
  
Test Execution: 
    01: Simulate reception of SF with N_Pdu Id 1 and N_TA as 245.
    02: VP(CanTp.EB.NPduNSaFiltering):
        Verify that the buffer is requested to PduR correctly after identifying the correct N-Sdu.
        PduR calls are made with PduRSourcePduHandleId of the Routing Path referenced
        by CanTpRxNSdu1, as the received N_TA corresponds to the N_SA of CanTpRxNSdu1.
    03: Verify that the reception on CanTpRxNSdu1 got successfully completed.
    04: Simulate reception of FF with N_PDU Id as 1, N_TA as 242U and message length as 8.
    05: VP(CanTp.EB.NPduNSaFiltering):
        Verify that the buffer is requested to PduR correctly after identifying the correct N-Sdu.
        PduR calls are made with PduRSourcePduHandleId of the Routing Path referenced
        by CanTpRxNSdu2, as the received N_TA corresponds to the N_SA of CanTpRxNSdu2.
    06: Verify whether CanIf_Transmit() is called to send FC frame and confirm the FC with correct
        CanTpTxFcNPduConfirmationPduId corresponding to CanTpRxNSdu2.
    07: Simulate reception of first/last CF and finish the reception on CanTpRxNSdu2.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.NPduNSaFiltering</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>656</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1395</internalId></specobject>
    <specobject>
      <id>TS_CANTP_FcNPduNSaFiltering</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_3/source/application/Tests.c</sourcefile>
      <sourceline>809</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test shall verify that if a FC frame with extended addressing is received, the module shall
    compare the configuration parameter CanTpNSa of each matching (same FcNPduId) Rx N-FcPdu with
    the target address of the frame to get the right Tx N-Sdu.
  
Test Object: 
    Reception of FC frames on two different N-Sdus with same FcNPduId and different NSA.
  
Test Precondition: 
    - CanTp should be initialized.
    - Configure extended addressing mode.
    - Use the following configuration
      N-SDU           N_SA       CanTpRxFcNPduId
      CanTpTxNSdu2    190         9
      CanTpTxNSdu3    188         9
  
Test Execution: 
    01: Simulate a segmented transmission on CanTpTxNSdu2 with message length as 8.
    02: Call CanTp_MainFunction and verify that FF is transmitted and confirm the FF.
    03: Simulate reception of FC CTS frame with CanTpRxFcNPduId as 9 and N_TA as 190U.
    04: VP(CanTp.EB.FcNPduNSaFiltering):
        Verify that the FC frame is accepted and buffer is requested to PduR correctly
        after identifying the correct N-Sdu.
        PduR calls are made with PduRDestPduHandleId of the Routing Path referenced
        by CanTpTxNSdu2, as the received N_TA corresponds to the N_SA of CanTpTxNSdu2.
    05: Verify that CF is transmitted and confirm the CF.
        Verify that the transmission on CanTpTxNSdu2 is finished completely.
    06: Simulate a segmented transmission on CanTpTxNSdu3 with message length as 9.
    07: Call CanTp_MainFunction and verify that FF is transmitted and confirm the FF.
    08: Simulate reception of FC CTS frame with CanTpRxFcNPduId as 9 and N_TA as 188U.
    09: VP(CanTp.EB.FcNPduNSaFiltering):
        Verify that the FC frame is accepted and buffer is requested to PduR correctly
        after identifying the correct N-Sdu.
        PduR calls are made with PduRDestPduHandleId of the Routing Path referenced
        by CanTpTxNSdu3, as the received N_TA corresponds to the N_SA of CanTpTxNSdu3.
    10: Verify that CF is transmitted and confirm the CF.
        Verify that the transmission on CanTpTxNSdu3 is finished completely.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.FcNPduNSaFiltering</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>657</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1396</internalId></specobject>
    <specobject>
      <id>TS_CANTP_NPduNAeFiltering</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_3/source/application/Tests.c</sourcefile>
      <sourceline>968</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test shall verify that if a frame with mixed addressing is received, the module shall
    compare the configuration parameter CanTpNAe of each matching Rx N-Pdu with the N_Ae value
    of the frame to get the right Rx N-Sdu.
  
Test Object: 
    Reception on two different N-Sdus with same N-Pdu Id and different CanTpNAe.
  
Test Precondition: 
    - CanTp should be initialized.
    - Configure mixed addressing mode.
    - Use the following configuration
      N-SDU           N_Ae       N_Pdu Id
      CanTpRxNSdu3    210U         2
      CanTpRxNSdu4    200U         2
  
Test Execution: 
    01: Simulate reception of FF with N_Pdu Id as 2 and N_Ae as 210.
    02: VP(CanTp.EB.NPduNAeFiltering):
        Verify that the buffer is requested to PduR correctly after identifying the correct N-Sdu.
        PduR calls are made with PduRSourcePduHandleId of the Routing Path referenced
        by CanTpRxNSdu3, as the received N_TA corresponds to the N_AE of CanTpRxNSdu3.
    03: Verify whether CanIf_Transmit() is called to send FC frame and confirm the FC with correct
        CanTpTxFcNPduConfirmationPduId corresponding to CanTpRxNSdu3.
    04: Simulate reception of first(last) CF and finish the reception on CanTpRxNSdu3.
    05: Simulate reception of FF with N_PDU Id as 2, N_TA as 200U and message length as 8.
    06: VP(CanTp.EB.NPduNAeFiltering):
        Verify that the buffer is requested to PduR correctly after identifying the correct N-Sdu.
        PduR calls are made with PduRSourcePduHandleId of the Routing Path referenced
        by CanTpRxNSdu4, as the received N_TA corresponds to the N_AE of CanTpRxNSdu4.
    07: Verify whether CanIf_Transmit() is called to send FC frame and confirm the FC with correct
        CanTpTxFcNPduConfirmationPduId corresponding to CanTpRxNSdu4.
    08: Simulate reception of first(last) CF and finish the reception on CanTpRxNSdu4.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.NPduNAeFiltering</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>658</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1397</internalId></specobject>
    <specobject>
      <id>TS_CANTP_FcNPduNAeFiltering</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_3/source/application/Tests.c</sourcefile>
      <sourceline>1114</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test shall verify that if a FC frame with mixed addressing is received, the module shall
    compare the configuration parameter CanTpNAe of each matching Rx N-FcPdu with N_Ae value
    of the frame to get the right Tx N-Sdu.
  
Test Object: 
    Reception of FC frames on two different N-Sdus with same FcNPduId and different CanTpNAe.
  
Test Precondition: 
    - CanTp should be initialized.
    - Configure mixed addressing mode.
    - Use the following configuration
      N-SDU           N_SA       CanTpRxFcNPduId
      CanTpTxNSdu6    130         12
      CanTpTxNSdu7    110         12
  
Test Execution: 
    01: Simulate a segmented transmission on CanTpTxNSdu6 with message length as 8.
    02: Call CanTp_MainFunction and verify that FF is transmitted and confirm the FF.
    03: Simulate reception of FC CTS frame with CanTpRxFcNPduId as 12 and N_TA as 130U.
    04: VP(CanTp.EB.FcNPduNAeFiltering):
        Verify that the FC frame is accepted and buffer is requested to PduR correctly
        after identifying the correct N-Sdu.
        PduR calls are made with PduRDestPduHandleId of the Routing Path referenced
        by CanTpTxNSdu6, as the received N_TA corresponds to the N_Ae of CanTpTxNSdu6.
    05: Verify that CF is transmitted and confirm the CF.
        Verify that the transmission on CanTpTxNSdu6 is finished completely.
    06: Simulate a segmented transmission on CanTpTxNSdu7 with message length as 9.
    07: Call CanTp_MainFunction and verify that FF is transmitted and confirm the FF.
    08: Simulate reception of FC CTS frame with CanTpRxFcNPduId as 12 and N_TA as 110U.
    09: VP(CanTp.EB.FcNPduNAeFiltering):
        Verify that the FC frame is accepted and buffer is requested to PduR correctly
        after identifying the correct N-Sdu.
        PduR calls are made with PduRDestPduHandleId of the Routing Path referenced
        by CanTpTxNSdu7, as the received N_TA corresponds to the N_Ae of CanTpTxNSdu7.
    10: Verify that CF is transmitted and confirm the CF.
        Verify that the transmission on CanTpTxNSdu7 is finished completely.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.FcNPduNAeFiltering</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>659</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1398</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_30304</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_4/source/application/Tests.c</sourcefile>
      <sourceline>93</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test maximum data transmission with standard FF format (4095 bytes). Limit
    the Tx buffer given by PduR to a size higher
    than 255 bytes (but not all at once) on each request.
  
Test Object: 
    Message transmission
  
Test Precondition: 
  
Test Execution: 
    01: Set PduR size limit to e.g. 314 bytes.
    02: Transmit 4095 bytes of random data via CanTp.
    03: VP(CanTp.11266):
        Check if random data is successfully transmitted via CanIf.
    04: Transmit FCcts via CanIf and call CanTp MainFunction whenever CanTp expects it.
    05: VP(CanTp.SWS_CanTp_00086):
        PduR_CanTpCopyTxData should get triggered correctly.
    06: Verify Transmitted data.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00086</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>203</internalId></provcov>
        <provcov>
          <linksto>CanTp.11266</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>851</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1399</internalId></specobject>
    <specobject>
      <id>TS_CANTP_30326</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_4/source/application/Tests.c</sourcefile>
      <sourceline>143</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test transmission of 14 Bytes (14 = 6+7+1 -&amp;gt; this means 1 FF, 2 CFs).
    Limit the Tx buffer given by the PduR to the minimum possible size (1 byte) for each request.
  
Test Object: 
    Message transmission and correct buffer request
  
Test Precondition: 
  
Test Execution: 
    01: Prepare PduR to provide a buffer of 1byte.
    02: Simulate transmission of 14 bytes of data.
    03: Receive FC CTS with BS as 0 and call CanTp MainFunction whenever CanTp expects it.
    04: VP(CanTp.SWS_CanTp_00086):
        Verify whether PduR_CanTpCopyTxData is called correctly for different CF and finish
        the transmission correctly(1 FF + 2 CFs) .
    05: Verify Transmitted data.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00086</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>203</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1400</internalId></specobject>
    <specobject>
      <id>TS_CANTP_BS_Unlimited</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_4/source/application/Tests.c</sourcefile>
      <sourceline>187</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test segmented reception handling more than 255 CFs and PduR providing whole buffer.
  
Test Object: 
    Message reception
  
Test Precondition: 
   - Configuration parameter BS (set to 0) does not limit the maximum possible BS value.
   - Use standard addressing format
   - CanTp should be initialized
  
Test Execution: 
    01: (CanTp.ASR40.RxIndication.Precondition1 PART 1/2):
        PduR_CanTpStartOfReception shall return BUFREQ_E_BUSY but PduR_CanTpCopyRxData
        should return BUFREQ_OK and provides enough buffer.
    02: Simulate reception of FF on PduId 0 with message length 4094.
    03: Check for call of PduR_CanTpStartOfReception() with SduLength of 4094
    04: Elapse one main function cycle
    05: VP(CanTp.EB.StartOfReception.BUFREQ_E_BUSY.LL):
        Check that PduR_CanTpCopyRxData() is called with buffer size as 0U and another call is made
        for copying FF data.
    06: VP(CanTp.EB.BS.Unlimited):
        Check if connection is accepted and CanIf_Transmit() is called to send FC with BS 0
        as more than 255 CFs are expected.
    07: Confirm the FC frame.
    08: Receive the required 584 CFs and verify whether those are accepted
    09: VP(CanTp.ASR40.RxIndication.Precondition1 PART 2/2):
        Check if PduR_CanTpRxIndication() is called with result E_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.BS.Unlimited</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>619</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.StartOfReception.BUFREQ_E_BUSY.LL</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.RxIndication.Precondition1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>494</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1401</internalId></specobject>
    <specobject>
      <id>CanTp_ConTest04_BS_EnoughBufffer</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_4/source/application/Tests.c</sourcefile>
      <sourceline>346</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    It shall be verified that for a segmented reception CanTp sends the configured block size value
    if PduR provides enough buffer for the whole frame.

    This test shall verify that if configured block size value is zero, also the block size value
    of the FC(CTS) frame will be zero.
  
Test Object: 
    Block size in FC(CTS)
  
Test Precondition: 
   - Configuration parameter BS set to 0.
   - Use standard addressing format.
   - CanTp is initialized.
  
Test Execution: 
    01: Prepare PduR to provide enough buffer for the whole frame.
    02: Call CanTp_RxIndication() with SduLength 20.
    03: VP(CanTp.EB.BS.Unlimited):
        Check that CanIf_Transmit() is called to send FC(CTS) with BS 0.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.BS.Unlimited</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>619</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1402</internalId></specobject>
    <specobject>
      <id>TS_CANTP_Rx_MaxDataLength</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_4/source/application/Tests.c</sourcefile>
      <sourceline>423</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test segmented reception for maximum possible message length(4095) when PduR is ready to provide
    more buffer than message length during initial request(PduR_CanTpStartOfReception) itself.
    (CanTp will take only the required buffer from PduR even though PduR provided more buffer than
     message length, here it is 4095.)
  
Test Object: 
    Message reception
  
Test Precondition: 
   - Configuration parameter BS (set to 0) does not limit the maximum possible BS value.
   - Use standard addressing format
   - CanTp should be initialized
  
Test Execution: 
    01: VP(CanTp.Design.CopyRxData.BufferSize, CanTp.Design.StartOfReception.BufferSize):
        Prepare PduR_CanTpStartOfReception() and PduR_CanTpCopyRxData() to provide
        a buffer of 4100 bytes.
    02: Simulate reception of FF on PduId 0 with message length 4095.
    03: Check the calls to PduR_CanTpStartOfReception() with SduLength of 4095 and
        PduR_CanTpCopyRxData.
    04: VP(CanTp.EB.BS.Unlimited):
        Check if connection is accepted and CanIf_Transmit() is called to send FC with BS 0
        as more than 255 CFs are expected.
    05: Confirm the FC frame.
    06: Receive the required 585 CFs and verify whether those are accepted.
    07: Check if PduR_CanTpRxIndication() is called with result E_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.BS.Unlimited</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>619</internalId></provcov>
        <provcov>
          <linksto>CanTp.Design.CopyRxData.BufferSize</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>113</internalId></provcov>
        <provcov>
          <linksto>CanTp.Design.StartOfReception.BufferSize</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>115</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1403</internalId></specobject>
    <specobject>
      <id>TS_CANTP_BS_Limited</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_4/source/application/Tests.c</sourcefile>
      <sourceline>561</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test segmented reception handling more than 255 CFs and PduR has provided buffer for only 255
    CFs.
  
Test Object: 
    Message reception including more than 255 CFs
  
Test Precondition: 
  
Test Execution: 
    01: Prepare PduR to return a buffer of 1791 bytes.
    02: Simulate reception of FF on PduId 0 with message length 1798.
    03: Check for call of PduR_CanTpStartOfReception() with SduLength of 1798.
    04: VP(CanTp.EB.BS.Limited, CanTp.11264):
        Check if connection is accepted and CanIf_Transmit() is called to send FC with BS 0xFF.
        as more than 255 CFs are expected but buffer is available only for 255 CFs.(255 *7 = 1785).
    05: Confirm the FC frame.
    06: Receive the required 255 CFs and verify whether those are accepted.
    07: Provide a buffer for rest of the data, i.e. 7 bytes.
    08: Elapse one MF cycle and verify that buffer is requested.
    09: Verify whether FC CTS frame is transmitted for next block and confirm the CTS.
    10: Receive the last CF with 7 bytes of data.
    11: Check if PduR_CanTpRxIndication() is called with result E_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.BS.Limited</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>621</internalId></provcov>
        <provcov>
          <linksto>CanTp.11264</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>878</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1404</internalId></specobject>
    <specobject>
      <id>TS_CANTP_BS_Limited_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_4/source/application/Tests.c</sourcefile>
      <sourceline>726</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test segmented reception handling more than 255 CFs.
    PduR has provided buffer which is less than message length but for more than 255 CFs.
  
Test Object: 
    Message reception including more than 255 CFs.
  
Test Precondition: 
  
Test Execution: 
    01: Prepare PduR to return a buffer of 2106 bytes.
    02: Simulate reception of FF on PduId 0 with message length 2121.
    03: Check for call of PduR_CanTpStartOfReception() with SduLength of 2121.
    04: VP(CanTp.EB.BS.Limited):
        Check if connection is accepted and CanIf_Transmit() is called to send FC with BS 0xFF.
        as more than 255 CFs are expected.
    05: Confirm the FC frame.
    06: Receive the required 255 CFs and verify whether those are accepted.
    07: Provide a buffer for rest of the data, i.e. 330 bytes.
    08: Elapse one MF cycle and verify that buffer is requested.
    09: VP(CanTp.SWS_CanTp_00067_BS):
        Verify whether FC CTS frame is transmitted for next block with same BS(FF) as before
        and confirm the CTS.
    10: Receive rest of the data.
    11: Check if PduR_CanTpRxIndication() is called with result E_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.BS.Limited</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>621</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00067_BS</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>192</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1405</internalId></specobject>
    <specobject>
      <id>TS_CANTP_BS_Unlimited_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_4/source/application/Tests.c</sourcefile>
      <sourceline>884</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test segmented reception for maximum possible message length(4095) when PduR is ready to provide
    more buffer than message length during PduR_CanTpCopyRxData call.
    (CanTp will take only the required buffer from PduR even though PduR provided more buffer than
     message length, here it is 4095.)
  
Test Object: 
    Message reception
  
Test Precondition: 
   - Configuration parameter BS (set to 0) does not limit the maximum possible BS value.
   - Use standard addressing format
   - CanTp should be initialized
  
Test Execution: 
    01: Prepare PduR_CanTpStartOfReception to provide no buffer and PduR_CanTpCopyRxData to provide
        a buffer of 4100 bytes.
    02: Simulate reception of FF on PduId 0 with message length 4095.
    03: Check for call of PduR_CanTpStartOfReception() with SduLength of 4095.
    04: VP(CanTp.SWS_CanTp_00080):
        Elapse one main function cycle and verify that PduR_CanTpCopyRxData
        is called for enough buffer as PduR_CanTpStartOfReception didn't provided required buffer.
        Now PduR_CanTpCopyRxData will provide more buffer than required.
    05: VP(CanTp.EB.BS.Unlimited):
        Check if connection is accepted and CanIf_Transmit() is called to send FC with BS 0
        as more than 255 CFs are expected.
    06: Confirm the FC frame.
    07: Receive the required 585 CFs and verify whether those are accepted.
    08: Check if the reception is finished successfully and PduR is notified with E_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.BS.Unlimited</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>619</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00080</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>162</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1406</internalId></specobject>
    <specobject>
      <id>TS_CANTP_MaxBuffSize</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_4/source/application/Tests.c</sourcefile>
      <sourceline>1026</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test transmission of a Single Frame if PduR has provided a buffer more than maximum CAN message
    length.
  
Test Object: 
    Message transmission
  
Test Precondition: 
    - CanTp should be initialized
    - Configure normal addressing mode
  
Test Execution: 
    01: Prepare PduR to provide a buffer of 4120 bytes (&gt; CANTP_MAX_MESSAGE_LENGTH)
    02: Call CanTp_Transmit() with PduId 0 and SduLength 6 in normal addressing mode and
        check that it returns E_OK.
    03: Elapse a MainFunction tick.
    04: VP(CanTp.SWS_CanTp_00299_1):
        Verify whether PduR_CanTpCopyTxData() is called with SduLength 6.
    05: VP(CanTp.SWS_CanTp_00231_1, CanTp.Design.CopyTxData.BufferSize):
        Verify whether CanIf_Transmit() is called to transmit SF with SduLength 7.
    06: Call CanTp_TxConfirmation() to confirm the Pdu sent.
    07: Verify whether PduR_CanTpTxConfirmation is called with result E_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00231_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>353</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00299_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>364</internalId></provcov>
        <provcov>
          <linksto>CanTp.Design.CopyTxData.BufferSize</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>114</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1407</internalId></specobject>
    <specobject>
      <id>TS_CANTP_Extented_Functional</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_4/source/application/Tests.c</sourcefile>
      <sourceline>1133</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanTp refuses transmission of segmented messages if the N-Sdu is configured with
    extended addressing and functional communication type.
  
Test Object: 
    Message transmission
  
Test Precondition: 
   - Use extended addressing format and functional communication type
   - CanTp should be initialized
  
Test Execution: 
    01: VP(CanTp.11300):
        Call CanTp_Transmit() with PduId 1 and SduLength 8.
        extended addressing mode is set, functional addressing.
        Check that it returns E_NOT_OK.
    02: VP(CanTp.EB.Functional.ExtendedAddr):
        Det error TEST_CANTP_E_INVALID_TATYPE is reported.
    03: Check that PduR_CanTpTxConfirmation() was not called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.Functional.ExtendedAddr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>654</internalId></provcov>
        <provcov>
          <linksto>CanTp.11300</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>845</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1408</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_30401</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_5/source/application/Tests.c</sourcefile>
      <sourceline>101</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test simultaneous reception on multiple channels while at the same time, a transmission is
    going on a different channel.
  
Test Object: 
    Simultaneous transmission and reception
  
Test Precondition: 
    Each Pdu (Tx and Rx) has its own, unique channel. The channel Ids are mixed.
  
Test Execution: 
    01: Initiate a segmented transmission. Do not call the Mainfunction.
    02: VP(CanTp.SWS_CanTp_00030_1b):
        Indicate FF to CAN TP (6 bytes sent, 14 to go) on first channel.
        Verify that the CTS is transmitted with STmin as 2 which is the configured value and confirm
        the CTS.
    03: Indicated FF to CAN TP (6 bytes sent, 14 to go) on second channel.
        Continue until FC CTS is confirmed.
    04: Complete reception on the first channel.
    05: VP(CanTp.SWS_CanTp_00122, CanTp.SWS_CanTp_00190):
        Check for a successful reception on first channel.
    06: Call  Mainfunction for the transmission. Continue until FF is confirmed.
    07: Indicate FF to CAN TP (6 bytes sent, 14 to go) on third channel.
        Continue until FC CTS is confirmed.
    08: Complete reception on the second channel.
    09: VP(CanTp.SWS_CanTp_00122, CanTp.SWS_CanTp_00190):
        Check for successful reception on the second channel.
    10: Indicate reception of the flow control frame for transmission.
        Continue until CF is confirmed.
    11: VP(CanTp.SWS_CanTp_00122, CanTp.SWS_CanTp_00190):
        Check if transmission is completed successfully.
    12: Complete reception on the third channel.
    13: VP(CanTp.SWS_CanTp_00122, CanTp.SWS_CanTp_00190):
        Check for successful reception on third channel.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00122</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>242</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00190</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>243</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00030_1b</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1409</internalId></specobject>
    <specobject>
      <id>TS_CANTP_ConfigBS</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_5/source/application/Tests.c</sourcefile>
      <sourceline>362</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verifying the effect of configured block size during segmented reception.
  
Test Object: 
    Segmented reception
  
Test Precondition: 
    Configured BS is 1.
    Address type should be configured as STANDARD.
    CanTp should be initialized.
  
Test Execution: 
    01: Prepare PduR to return a buffer of 20 bytes (less than ML = 27 but enough for a BS = 2).
    02: Receive a FF with message length 27 on CanTpChannel_Rx_3.
    03: Verify the PduR calls.
    04: VP(CanTp.SWS_CanTp_00091_2): Verify whether a FC CTS frame is transmitted with BS = 1.
       (Though PduR has provided enough buffer for a BS of 2, CanTp has transmitted a FC with BS = 1
        as the calculated BS(2) is greater than configured block size(1))
    05: Confirm the first Flow Control.
    06: Prepare PduR to return a buffer(20) which is big enough for receiving the next block
       (Buffer is available for a block size of 2 but CanTp will send FC with BS 1 which is the
        first calculated BS).
    07: Simulate reception of first CF.
    08: VP(CanTp.SWS_CanTp_00278, CanTp.SWS_CanTp_00067_BS):
        Verify that a FC CTS frame is transmitted after receiving one CF with BS = 1 for next block.
    09: Receive rest of the CF and finish the reception successfully.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00278</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>190</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00067_BS</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>192</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00091_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>221</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1410</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_30403</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_6/source/application/Tests.c</sourcefile>
      <sourceline>104</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify whether transmission and reception is handled properly even if the configured N-PDUs are
    not zero based and consecutive.
    Verify whether Det checks calls correctly.
  
Test Object: 
    PDU ID checks
  
Test Precondition: 
    - Configure each N-Pdu which does not have to be zero-based consecutive such that its id is
      larger than the number of the configured CanTp N-Sdus.
    - PduR should provide enough buffer for each Tx/Rx request correctly.
  
Test Execution: 
    01: Initiate transmission. Continue until CF is sent.
    02: Indicate FF to CAN TP (6 bytes sent, 14 to go) on first channel.
        Continue until end of successful reception on this channel.
    03: VP(CanTp.EB.NPdus):
        CAN TP should report a successful reception.
    04: Indicate FF to CAN TP (6 bytes sent, 14 to go) on second channel.
        Continue until end of successful reception.
    05: VP(CanTp.EB.NPdus):
        CAN TP should report a successful reception.
    06: Indicate FF to CAN TP (6 bytes sent, 14 to go) on third channel.
        Continue until end of successful reception.
    07: VP(CanTp.EB.NPdus):
        CAN TP should report a successful reception.
    08: Confirm CF sent on transmission channel.
    09: VP(CanTp.EB.NPdus):
        Check successful transmission.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.NPdus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>618</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1411</internalId></specobject>
    <specobject>
      <id>TS_CANTP_ConfTest06_SF_Buffering</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_6/source/application/Tests.c</sourcefile>
      <sourceline>397</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test shall verify that a SF gets buffered when upper layer does not provide a buffer.
    In this test PduR_CanTpStartOfReception() returns BUFREQ_E_BUSY and therefore, copying of the
    SF data shall be performed during the next main function call.
  
Test Object: 
    Buffering of SF data.
  
Test Precondition: 
    - Normal addressing mode.
    - Padding is disabled.
  
Test Execution: 
    01: Set return value of PduR_CanTpStartOfReception() to BUFREQ_E_BUSY and provide no Rx buffer.
    02: Indicate SF reception.
    03: Prepare enough Rx buffer for next call of PduR_CanTpCopyRxData().
    04: Call CanTp_MainFunction() to perform copying of SF data.
    05: VP:
        Verify that the SF data are correctly copied to upper layer during the CanTp_MainFunction()
        call.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.SF.Buffering</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>547</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1412</internalId></specobject>
    <specobject>
      <id>TS_CANTP_ConfTest06_FF_Buffering</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_6/source/application/Tests.c</sourcefile>
      <sourceline>512</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test shall verify that a FF gets buffered when upper layer does not provide a buffer.
    In this test PduR_CanTpStartOfReception() returns BUFREQ_E_OK but no buffer and therefore,
    copying of the FF data shall be performed during the next main function call.
  
Test Object: 
    Buffering of FF data.
  
Test Precondition: 
    - Normal addressing mode.
    - Padding is disabled.
  
Test Execution: 
    01: Prepare PduR_CanTpStartOfReception() and PduR_CanTpCopyRxData() to return not enough
        buffer for FF frame data.
    02: Indicate FF reception.
    03: Prepare enough Rx buffer for next call of PduR_CanTpCopyRxData().
    04: Call CanTp_MainFunction() to perform copying of FF data.
    05: VP(CanTp.EB.FF.Buffering):
        Verify that the FF data are correctly copied to upper layer during the CanTp_MainFunction()
        call.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.FF.Buffering</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>546</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1413</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_RX_BUSY_CF</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_BS/source/application/Tst_Tests.c</sourcefile>
      <sourceline>172</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that reception will be aborted if PduR returns BUFREQ_E_BUSY during block reception
  
Test Object: 
    Reception when PduR returns BUFREQ_E_BUSY in between
  
Test Precondition: 
  
Test Execution: 
    01: Prepare PduR_CanTpStartOfReception to return BUFREQ_E_BUSY and PduR_CanTpCopyRxData
        to return BUFREQ_OK and enough buffer.
    02: Prepare and simulate reception of FF on PduId 0 with SduLength 8.
    03: Verify whether PduR_CanTpStartOfReception() is called with TpSduLength 20.
    04: Verify whether PduR_CanTpCopyRxData() is called with SduLength 8.
    05: Verify whether CanIf_Transmit() is called to send FC(CTS) frame.
    06: Call CanTp_TxConfirmation() to confirm transmission of FC frame.
    07: Prepare for reception of first CF and simulate reception.
    08: Prepare PduR to return BUFREQ_E_BUSY.
    09: Prepare for reception of second CF and simulate reception.
    10: VP(CanTp.ASR40.RxNoBuffer_1, CanTp.ASR40.CopyRxData.BufferNotReserved.2b):
        Verify whether PduR_CanTpRxIndication is called with result E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.RxNoBuffer_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>544</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.CopyRxData.BufferNotReserved.2b</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>484</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1414</internalId></specobject>
    <specobject>
      <id>TS_CANTP_31102</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_BS/source/application/Tst_Tests.c</sourcefile>
      <sourceline>339</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Use configured/set BS (instead of 0) in (several) FC frames with more
    buffer than necessary:
    Reception of a segmented message (without padding). The message is longer
    than FF + BS * CF and the PduR provides enough buffer.
  
Test Object: 
    Transmitted FC frames during a segmented message reception
  
Test Precondition: 
    - The API CanTp_ChangeParameter() is enabled in the test sequence.
    The used Rx N-SDU
    - has padding disabled.
    - is of type standard addressing (not important for the test itself but for
      frame checking).
  
Test Execution: 
    01: Change the BS of the used Rx N-SDU to 1 via CanTp_ChangeParameter().
    02: Prepare and simulate reception of FF.
    03: Verify whether PduR_CanTpStartOfReception() is called with TpSduLength 21.
    04: Verify whether PduR_CanTpCopyRxData() is called.
    05: Verify whether CanIf_Transmit() is called to send FC(CTS) frame.
    06: Call CanTp_TxConfirmation() to confirm transmission of FC frame.
    07: Prepare and send full CFs as long as data length allows with different SN.
    08: VP(CanTp.ISO2004.UnexpectedCF_1):
        Verify whether CanIf_Transmit() is called to send next FC(CTS) frame for each reception
        with BS = 1 indicating the previous CF is accepted.
    09: Call CanTp_TxConfirmation() to confirm transmission of FC frame for each reception.
    10: Prepare and send last CF and Call CanTp_RxIndication() to simulate reception.
    11: Verify whether PduR_CanTpCopyRxData() is called.
    12: Verify whether PduR_CanTpRxIndication is called with result E_OK.
    13: Check if the data was correctly written in the buffer.
    14: Verify the number of transmitted messages.
    15: Restore the BS of the used Rx N-SDU to the configured value..
    16: Ensure no DET error is reported finally.
  
Test Input: 
  
Test Output: 
    The FF and CF are correctly received which means:
    - A buffer is requested from the PduR.
    - The received data are written to that buffer.
    - The reception is reported to the PduR as successful.
    After the FF and each CF (except the last one) a FC(CTS) frame is sent:
    - The BS given in the FC frame has the set value (1).
    - The FC(CTS) frame length is 3 byte (no padding, standard addressing).
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ISO2004.UnexpectedCF_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>899</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1415</internalId></specobject>
    <specobject>
      <id>TS_CANTP_RX_InitialBS</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_BS/source/application/Tst_Tests.c</sourcefile>
      <sourceline>570</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    - Reception of a segmented message (without padding).
    - Verification of BS values in FC frames.
    - PduR provides not enough buffer initially (but fast enough to have no reception issue).
  
Test Object: 
    Buffer handling
  
Test Precondition: 
    The used Rx N-SDU
    - has a BS parameter not equal to 1.
    - has padding disabled.
    - is of type standard addressing (not important for the test itself but for
      frame checking).
  
Test Execution: 
    01: Prepare Rx stub callout to provide 1 byte per call
    02: Prepare and simulate reception of FF with msg length 22.(standard addressing)
    03: Verify whether PduR_CanTpStartOfReception() is called with TpSduLength 22 and
        PduR_CanTpCopyRxData is called for enough buffer.
    04: Verify whether PduR_CanTpCopyRxData() is called till enough buffer is achieved for FF.
    05: Verify that PduR_CanTpCopyRxData is called for copying the FF data when enough buffer is
        available.
    06: Provide a buffer of 14 bytes for receiving the block
    07: Elapse one mainfunction and verify that FC CTS is transmitted with block size 2U
        and confirm the FC
    08: Prepare data and simulate reception of first CF.
    09: Prepare PduR to provide a larger buffer of 30 bytes
        (more than that needed for receiving rest of the data)
    10: VP(CanTp.SWS_CanTp_00278):
        Verify that no FC frame is transmitted after receiving first CF even though enough buffer
        is available
    11: Prepare data and simulate reception of second CF.
    12: VP(CanTp.SWS_CanTp_00067_BS, CanTp.SWS_CanTp_00278):
        Verify whether CanIf_Transmit() is called to send FC(CTS) frame(only after 2 CFs got
        received) with initially calculated BS value, i.e. 2(even though only one CF is required
        to complete reception).
    13: Call CanTp_TxConfirmation() to confirm transmission of FC frame.
    14: Prepare data and simulate reception of third(last) CF.
    15: Verify whether PduR_CanTpRxIndication is called with result E_OK.
    16: Check if the data was correctly written in the buffer.
    17: Verify that no further calls occurred.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00067_BS</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>192</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00278</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>190</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1416</internalId></specobject>
    <specobject>
      <id>TS_CANTP_31104</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_BS/source/application/Tst_Tests.c</sourcefile>
      <sourceline>836</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that if upper layer has not enough buffer to receive FF data, CanTp will send a FC(WT)
    after the timeout N_Br has elapsed. As soon as enough buffer is available CanTp shall send
    FC(CTS).
  
Test Object: 
    Segmented reception with temporarily not enough buffer for CF reception.
  
Test Precondition: 
    - The API CanTp_ChangeParameter() is enabled in the test sequence.
    - The used Rx N-SDU is configured for extended addressing (not important
      for the test itself but for frame checking).
  
Test Execution: 
    01: Prepare PduR stub callout to provide less buffer for FF.
    02: Indicate segmented reception with length 10 (extended addressing).
    03: Call CanTp_MainFunction() until N_Br expires.
    04: VP(CanTp.ASR40.SWS_CanTp_00082_2):
        Verify if the last main function call has triggered the FC(WT) frame.
    05: Call CanTp_TxConfirmation() to confirm transmission of FC frame.
    06: Provide a enough buffer for the reception.
    07: Call CanTp_MainFunction() to trigger a FC(CTS) frame for FF and confirm it.
    08: Indicate first (= last) CF.
    09: VP(CanTp.ASR40.RxIndication.Precondition1):
        Verify whether PduR_CanTpRxIndication is called with result E_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00082_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>22</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.RxIndication.Precondition1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>494</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1417</internalId></specobject>
    <specobject>
      <id>TS_CANTP_ReqestMoreBuffer</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_BS/source/application/Tst_Tests.c</sourcefile>
      <sourceline>985</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    For a segmented reception and during the timeout N_Br it shall be verified that CanTp will
    call PduR_CanTpCopyRxData() with parameter SduLength set to 0U and SduDataPtr set to NULL_PTR
    to get information about the available buffer.
  
Test Object: 
    Buffer request during timeout N_Br.
  
Test Precondition: 
    - The API CanTp_ChangeParameter() is enabled in the test sequence.
    - Extended addressing.
  
Test Execution: 
    01: Set block size to 2.
    02: Prepare PduR stub to receive just the FF and the whole next block (2 CF).
    03: Start a segmented reception (extended addressing) with size 1 FF and 3 CF and perform the
        reception until the first block is received.
    04: Call CanTp_MainFunction() a few times in a loop.
    05: VP(CanTp.SWS_CanTp_00222):
        Verify that PduR_CanTpCopyRxData() is called with parameter SduLength set to 0U and
        SduDataPtr set to NULL_PTR.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00222</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>169</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1418</internalId></specobject>
    <specobject>
      <id>TS_CANTP_31105</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_BS/source/application/Tst_Tests.c</sourcefile>
      <sourceline>1133</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that an FC(OVFLW) uses the correct BS and STmin information.
  
Test Object: 
    BS and STmin in FC(OVFLW) frames
  
Test Precondition: 
    - The used Rx N-SDU is configured for extended addressing (not important
      for the test itself but for frame checking).
  
Test Execution: 
    01: Prepare and simulate reception of FF,
        PduR_CanTpStartOfReception() shall return BUFREQ_E_OVFL.
    02: Verify whether PduR_CanTpStartOfReception() is called with TpSduLength 23.
    03: VP(CanTp.ASR40.SWS_CanTp_00318_1, CanTp.EB.FC.OVFLOW):
        Verify whether an FC OVFLW frame with configured BS is transmitted as PduR has returned
        BUFREQ_E_OVFL.
    04: Call CanTp_TxConfirmation() to confirm transmission of FC frame.
    05: Verify the number of transmitted messages.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00318_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>18</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.FC.OVFLOW</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>559</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1419</internalId></specobject>
    <specobject>
      <id>TS_CANTP_31106</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_BS/source/application/Tst_Tests.c</sourcefile>
      <sourceline>1258</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that a segmented reception is correctly aborted if no Rx buffer is
    available after the reception of a CF (no FC frame due).
  
Test Object: 
    Reception is correctly aborted if no buffer is available
  
Test Precondition: 
    - The used Rx N-SDU is configured for extended addressing (not important
      for the test itself but for frame checking) and has BS set to
      a value &amp;gt;= 2.
  
Test Execution: 
    01: Prepare and simulate reception of FF.
    02: Verify whether PduR_CanTpStartOfReception() is called with TpSduLength 20.
    03: Verify whether PduR_CanTpCopyRxData() is called.
    04: Verify whether CanIf_Transmit() is called to send FC(CTS) frame configured BS.
        (Whole message can be received PduR has already provided buffer for whole message).
    05: Call CanTp_TxConfirmation() to confirm transmission of FC frame.
    06: Prepare data to simulate reception of first CF with PduR returning BUFREQ_E_NOT_OK.
    07: Call CanTp_RxIndication() to simulate reception.
    08: Verify if another PduR_CanTpCopyRxData() is called.
    09: VP(CanTp.ASR40.SWS_CanTp_00318_2):
        Verify whether PduR_CanTpRxIndication is called with result E_NOT_OK.
    10: Verify the number of transmitted messages.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00318_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>19</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1420</internalId></specobject>
    <specobject>
      <id>TS_CANTP_31109</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_BS/source/application/Tst_Tests.c</sourcefile>
      <sourceline>1413</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that a segmented reception is aborted by the N_Ar timeout if no Tx
    confirmation for the FC(CTS) frame is received. Do this for a FC frame that
    is transmitted after a CF (and not the one after the FF).
  
Test Object: 
    N_Ar timeout
  
Test Precondition: 
    - The API CanTp_ChangeParameter() is enabled in the test sequence.
    - The used Rx N-SDU is configured for extended addressing (not important
      for the test itself but for frame checking).
  
Test Execution: 
    01: Change the BS of the used Rx N-SDU to 1 via CanTp_ChangeParameter().
    02: Verify whether CanTp_ChangeParameter() is called.
    03: Prepare and simulate reception of FF.
    04: Verify whether PduR_CanTpStartOfReception() is called with TpSduLength 30.
    05: Verify whether PduR_CanTpCopyRxData() is called.
    06: Verify whether CanIf_Transmit() is called to send FC(CTS) frame.
    07: Call CanTp_TxConfirmation() to confirm transmission of FC frame.
    08: Prepare data to simulate reception of first CF.
    09: VP(CanTp.11268_4):
        Verify whether CanIf_Transmit() is called to send FC(CTS) frame.
    10: Call MF until N_Ar - 1 call expires(Before confirming the transmission of the FC frame).
    11: Clear all stub traces and all MF once to make N_Ar timeout expire.
    12: VP(CanTp.SWS_CanTp_00311, CanTp.11238):
        Verify whether PduR_CanTpRxIndication is called with result E_NOT_OK.
    13: Verify the number of transmitted messages.
    14: Restore the BS of the used Rx N-SDU to the configured value.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.11238</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>895</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00311</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>174</internalId></provcov>
        <provcov>
          <linksto>CanTp.11268_4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>865</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1421</internalId></specobject>
    <specobject>
      <id>TS_CANTP_31110</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_BS/source/application/Tst_Tests.c</sourcefile>
      <sourceline>1617</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that a segmented reception is aborted after the transmission of
    WFTmax wait frames, if the upper layer could not provide another buffer
    until then. Do this for a FC frame that is transmitted after a CF (and not
    the one after the FF).
  
Test Object: 
    N_Br timeout
  
Test Precondition: 
    - The API CanTp_ChangeParameter() is enabled in the test sequence.
    - The used Rx N-SDU is configured for extended addressing (not important
      for the test itself but for frame checking).
  
Test Execution: 
    01: Change the BS of the used Rx N-SDU to 1 via CanTp_ChangeParameter().
    02: Verify whether CanTp_ChangeParameter() is called.
    03: Prepare and simulate reception of FF.
    04: Verify whether PduR_CanTpStartOfReception() is called with TpSduLength 30.
    05: Verify whether PduR_CanTpCopyRxData() is called.
    06: Verify whether CanIf_Transmit() is called to send FC(CTS) frame.
    07: Call CanTp_TxConfirmation() to confirm transmission of FC frame.
    08: Prepare PduR to return less buffer for next block and simulate reception of first(last) CF
    09: Verify whether PduR_CanTpCopyRxData() is called.
    10: Wait N_Br till next FC(WT) frame until WFTmax FC(WT) frames were sent.
    11: VP(CanTp.SWS_CanTp_00325):
        Wait for N_Br timeout and check if FC(WT) frame is sent.
    12: Call MF until N_Br call expires.
    13: VP(CanTp.SWS_CanTp_00222):
        Verify whether PduR_CanTpCopyRxData() is called by each MF call.
    14: Call MF to make N_Br timeout expire.
    15: VP(CanTp.SWS_CanTp_00223_2):
        Verify whether PduR_CanTpRxIndication is called with result E_NOT_OK
        due to N_Br timeout and WFTmax wait frames.
    16: VP(CanTp.SWS_CanTp_00223_1):
        Verify the correct number of transmitted wait frames.
    17: Restore the BS of the used Rx N-SDU to the configured value.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00222</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>169</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00223_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>172</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00325</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>168</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1422</internalId></specobject>
    <specobject>
      <id>TS_CANTP_RxCancel_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_BS/source/application/Tst_Tests.c</sourcefile>
      <sourceline>1880</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that CanTp_CancelReceive() is accepted when CanTp is in buffer request state for FF
  
Test Object: 
    CanTp_CancelReceive()
  
Test Precondition: 
    - The API CanTp_CancelReceive() is enabled in the test sequence.
    - The used Rx N-SDU is configured for extended addressing (not important
      for the test itself but for frame checking).
  
Test Execution: 
      1: PduR_CanTpStartOfReception() shall return BUFREQ_OK
      2: PduR_CanTpCopyRxData() shall return BUFREQ_E_BUSY
      3: Receive FF with message length as 10
      4: Call CanTp_CancelReceive() and check that it returns E_OK.
      5: VP(CanTp.SWS_CanTp_00261):
         Check that Channel was closed PduR_CanTpRxIndication() is called with E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00261</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>373</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1423</internalId></specobject>
    <specobject>
      <id>TS_CANTP_RxCancel_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_BS/source/application/Tst_Tests.c</sourcefile>
      <sourceline>1986</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that CanTp_CancelReceive() is not accepted after N_Cr is started
    for the last CF.
    (Check this for a message of at least FF + 2 CFs and no FC frame before the last CF.)
  
Test Object: 
    CanTp_CancelReceive()
  
Test Precondition: 
    - The API CanTp_CancelReceive() is enabled in the test sequence.
    - The used Rx N-SDU is configured for extended addressing (not important
      for the test itself but for frame checking) and the BS is at least 2.
    - CanTp should be initialized.
    - PduR should provide buffer for whole message during the first request itself.
  
Test Execution: 
    01: Receive FF with message length 17. Continue till FC CTS is sent and confirm the CTS.
    02: Receive the first CF (6 bytes of data).
    03: VP(CanTp.SWS_CanTp_00262_2):
        Call CanTp_CancelReceive() (after N_Cr is started for the last CF) and
        check that it returns E_NOT_OK.
    04: VP(CanTp.SWS_CanTp_00269_1):
        Simulate reception of last frame and verify that PduR_CanTpCopyRxData is called with
        remaining length 6 and PduR_CanTpRxIndication is called with E_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00262_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>376</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00269_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>177</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1424</internalId></specobject>
    <specobject>
      <id>TS_CANTP_SegExtRxMultBufStBs_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_BS/source/application/Tst_Tests.c</sourcefile>
      <sourceline>2167</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the CAN TP requests multiple reception buffers and correctly
    reassembles the message in case of a segmented message reception with
    extended addressing if the internal buffer contains data of the last two
    CFs in a block before sending the next FC frame and static BS handling is
    enabled.
  
Test Object: 
    Buffer handling with extended frames
  
Test Precondition: 
    - The API CanTp_ChangeParameter() is enabled in the test sequence.
    - The used Rx N-SDU has extended addressing format configured.
  
Test Execution: 
    01: Change the BS of the used Rx N-SDU to 2 via CanTp_ChangeParameter().
    02: Prepare and simulate reception of FF.
    03: VP(CanTp.SWS_CanTp_00080):
        Verify whether PduR_CanTpStartOfReception() is called with TpSduLength 28.
    04: Verify whether PduR_CanTpCopyRxData() is called.
    05: VP(CanTp.SWS_CanTp_00224):
        Verify whether CanIf_Transmit() is called to send FC(CTS) frame.
    06: Call CanTp_TxConfirmation() to confirm transmission of FC frame.
    07: Prepare and simulate first CF.
    08: Prepare second CF.
    09: Check if no further FC frame and buffer request are made till now.
    10: Simulate Second CF.
    11: Verify whether PduR_CanTpCopyRxData() is called.
    12: VP(CanTp.SWS_CanTp_00224):
        Verify whether CanIf_Transmit() is called to send FC(CTS) frame.
    13: Call CanTp_TxConfirmation() to confirm transmission of FC frame.
    14: Prepare and simulate third CF.
    15: Verify whether PduR_CanTpCopyRxData() is called for last set of data.
    16: Prepare and simulate fourth and last CF.
    17: Verify whether PduR_CanTpRxIndication is called with result E_OK.
    18: Check if the data was correctly written in the buffer.
    19: Restore the BS of the used Rx N-SDU to the configured value.
    20: Verify the number of transmitted messages.
    21: Ensure no DET error is reported finally.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00080</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>162</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00224</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>175</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1425</internalId></specobject>
    <specobject>
      <id>TS_CANTP_SegExtRxMultBufStBs_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_BS/source/application/Tst_Tests.c</sourcefile>
      <sourceline>2451</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the CAN TP requests multiple reception buffers and correctly
    reassembles the message in case of a segmented message reception with
    extended addressing.
  
Test Object: 
    Buffer handling with extended frames
  
Test Precondition: 
    - The API CanTp_ChangeParameter() is enabled in the test sequence.
    - The used Rx N-SDU has extended addressing format configured.
  
Test Execution: 
    01: Change the BS of the used Rx N-SDU to 1 via CanTp_ChangeParameter().
    02: Prepare and simulate reception of FF.
    03: Verify whether PduR_CanTpStartOfReception() is called with TpSduLength 17.
    04: Verify whether PduR_CanTpCopyRxData() is called.
    05: VP(CanTp.SWS_CanTp_00224):
        Verify whether CanIf_Transmit() is called to send FC(CTS) frame.
    06: Call CanTp_TxConfirmation() to confirm transmission of FC frame.
    07: Prepare and simulate first CFs.
    08: Prepare second CFs.
    09: Check if no further FC frame and buffer request are made till now.
    10: Check if PduR_CanTpRxIndication() is not called yet.
    11: Simulate Second CFs.
    12: Verify whether PduR_CanTpCopyRxData() is called.
    13: Verify whether PduR_CanTpRxIndication is called with result E_OK.
    14: Check if the data was correctly written in the buffer.
    15: Restore the BS of the used Rx N-SDU to the configured value.
    16: Ensure that no DET error is reported finally and no other calls are made.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00224</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>175</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1426</internalId></specobject>
    <specobject>
      <id>CanTp_ConTest_BS_UseConfigValue</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_BS/source/application/Tst_Tests.c</sourcefile>
      <sourceline>2649</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test shall verify for a segmented reception that CanTp sends FC(CTS) with configured
    block size value if PduR provides enough buffer for the whole frame.

    It shall be tested that configured block size value is used even though the provided buffer is
    smaller as the configured block size.
  
Test Object: 
    Block size
  
Test Precondition: 
    - The used Rx N-SDU is configured for extended addressing (not important
      for the test itself but for frame checking).
    - Configured block size shall be 8.
  
Test Execution: 
    01: Prepare PduR to provide a buffer of 10 (FF (5 byte) CF (5 byte)).
    02: Call CanTp_RxIndication() to start a segmented reception of 10 bytes.
    03: VP(CanTp.EB.BS.EnoughBuffer):
    Verify that CanIf_Transmit() is called to send FC(CTS) with configured block size.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.BS.EnoughBuffer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>620</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1427</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_Conf07001_Change_Read_STmin</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_ChangeParameter/source/application/Tst_Conf_ChangeParameter.c</sourcefile>
      <sourceline>71</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test shall verify that STmin value can be changed and will be correctly set in the
    corresponding FC(CTS) and can be read through CanTp_ReadParameter() API.
  
Test Object: 
    CanTp_ChangeParameter().
    CanTp_ReadParameter().
  
Test Precondition: 
    - STmin is configured to 0.
    - Standard addressing.
  
Test Execution: 
    01: Change STmin to 2.
    02: Call CanTp_ReadParameter() API to read STmin value.
    03: Verify that the updated STmin value will be stored in newSTmin_Value through CanTp_ReadParameter() API.
    04: Perform segmented reception (message length 13 = FF + CF) until FC(CTS) is sent.
    05: VP(): Verify that new STmin is transmitted and not the configured value.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00302_E_OK_STmin</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>56</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00323_E_OK_STmin</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>388</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1428</internalId></specobject>
    <specobject>
      <id>TS_CANTP_Conf07002_Change_Read_BS</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_ChangeParameter/source/application/Tst_Conf_ChangeParameter.c</sourcefile>
      <sourceline>185</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test shall verify that the block size value can be changed and will be correctly set in the
    corresponding FC(CTS) and can be read through CanTp_ReadParameter() API.
  
Test Object: 
    CanTp_ChangeParameter()
    CanTp_ReadParameter()
  
Test Precondition: 
    - BS is configured to 2.
    - Standard addressing.
  
Test Execution: 
    01: Change block size to 1.
    02: Call CanTp_ReadParameter() API to read BS value.
    03: Verify that the updated BS value will be stored in newBS_Value through CanTp_ReadParameter() API.
    04: Set PduR buffer to 20. (Calculated BS is higher than maximum BS).
    05: Perform segmented reception (message length 19 = FF + CF + CF) until FC(CTS) is sent.
    06: VP(): Verify that new BS is transmitted as maximum and not the configured value.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00302_E_OK_BS</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>55</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00323_E_OK_BS</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>387</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1429</internalId></specobject>
    <specobject>
      <id>TS_CANTP_Conf07003_AllowChangeParameter</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_ChangeParameter/source/application/Tst_Conf_ChangeParameter.c</sourcefile>
      <sourceline>312</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check if the function CanTp_ChangeParameter() changes
    the values for STmin and BS when called in idle.
  
Test Object: 
    CanTp_ChangeParameter().
  
Test Precondition: 
    - CanTp shall be initialized.
    - Standard addressing.
  
Test Execution: 
    01: VP(CanTp.ASR40.ChangeParameter.E_OK):
        Set BS to a initial value first before any reception begins.
    02: VP(CanTp.ASR40.ChangeParameter.E_OK):
        Set STmin to a initial value first before any reception begins.
    03: Simulate reception of a FF with length 20.
    04: VP(CanTp.ASR40.ChangeParameter.E_OK):
        Check if FC was sent with Id 14 and STmin and BS as set before.
    05: Simulate a confirmation for the FC frame.
    06: Simulate reception of consecutive frame now to trigger another flow control.
    07: VP(CanTp.ASR40.ChangeParameter.E_OK):
        Check if FC was sent with Id 14 and the initial STmin and BS.
    08: Simulate a confirmation for the FC frame.
    09: Finish the transmission with a second consecutive frame (7 bytes left).
    10: Check that reception is finished.
    11: VP(CanTp.ASR40.ChangeParameter.E_OK):
        Set BS to a new (2nd) value for the next transfer and verify that the request is accepted.
    12: VP(CanTp.ASR40.ChangeParameter.E_OK):
        Set STmin to a new (2nd) value for the next transfer.
    13: Simulate reception of a FF with length 25.
    14: VP(CanTp.ASR40.ChangeParameter.E_OK):
        Check if FC was sent with Id 14 and the new STmin and BS values.
    15: Simulate a confirmation for the FC frame.
    16: Simulate reception of consecutive frame.
    17: Simulate reception of 2nd CF to trigger another FC (BS is 2 now!).
    18: VP(CanTp.ASR40.ChangeParameter.E_OK):
        Check if FC was sent with Id 14 and the new STmin and BS values.
    19: Simulate a confirmation for the FC frame.
    20: Finish the transmission with a third consecutive frame (5 bytes left).
    21: Check if the reception is finished.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.ChangeParameter.E_OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>530</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1430</internalId></specobject>
    <specobject>
      <id>TS_CANTP_Conf07004_DenyChangeParameter</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_ChangeParameter/source/application/Tst_Conf_ChangeParameter.c</sourcefile>
      <sourceline>575</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check if the function CanTp_ChangeParameter() does not change
    the values for STmin and BS when called during an ongoing reception.
  
Test Object: 
    CanTp_ChangeParameter().
  
Test Precondition: 
    CanTp is initialized.
  
Test Execution: 
    01: Set BS to a initial value first before any reception begins.
    02: Set STmin to a initial value first before any reception begins.
    03: Simulate reception of FF with length 20.
    04: VP(CanTp.SWS_CanTp_00067_STmin):
        A FC should have been sent with Id 14 and STmin and BS as set before.
    05: Simulate a confirmation for the FC frame.
    06: VP(CanTp.SWS_CanTp_00304):
        Check that it shall not be possible to change any STmin value during ongoing reception.
    07: VP(CanTp.SWS_CanTp_00304):
        Check that it shall not be possible to change any BS value during ongoing reception.
    08: Verify that a change parameter request for an N-Sdu is accepted if called for a Channel
        which is in Rx mode for another N-Sdu.
    09: Simulate reception of consecutive frame now to trigger another flow control.
    10: VP(CanTp.SWS_CanTp_00067_STmin):
        A FC should have been sent with Id 14 and the initial STmin and BS.
    11: Simulate a confirmation for the FC frame.
    12: Finish the transmission with a second consecutive frame (7 bytes left).
    13: Check if the reception is finished.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00067_STmin</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>193</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00304</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>380</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1431</internalId></specobject>
    <specobject>
      <id>TS_CANTP_Conf07005_ChangeRx_Read_STmin</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_ChangeParameter/source/application/Tst_Conf_ChangeParameter.c</sourcefile>
      <sourceline>759</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test shall verify that STmin value can be changed and will be correctly set in the
    corresponding FC(CTS) and can be read through CanTp_ReadParameter() API.
  
Test Object: 
    CanTp_ChangeRxParameter().
    CanTp_ReadParameter().
  
Test Precondition: 
    - STmin is configured to 0.
    - Standard addressing.
  
Test Execution: 
    01: Change STmin to 2.
    02: Call CanTp_ReadParameter() API to read STmin value.
    03: Verify that the updated STmin value will be stored in newSTmin_Value through CanTp_ReadParameter() API.
    04: Perform segmented reception (message length 13 = FF + CF) until FC(CTS) is sent.
    05: VP(): Verify that new STmin is transmitted and not the configured value.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00302_E_OK_STmin</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>56</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00323_E_OK_STmin</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>388</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.CanTp_ChangeRxParameter</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>752</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1432</internalId></specobject>
    <specobject>
      <id>TS_CANTP_Conf07006_ChangeRx_Read_BS</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_ChangeParameter/source/application/Tst_Conf_ChangeParameter.c</sourcefile>
      <sourceline>874</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test shall verify that the block size value can be changed and will be correctly set in the
    corresponding FC(CTS) and can be read through CanTp_ReadParameter() API.
  
Test Object: 
    CanTp_ChangeRxParameter()
    CanTp_ReadParameter()
  
Test Precondition: 
    - BS is configured to 2.
    - Standard addressing.
  
Test Execution: 
    01: Change block size to 1.
    02: Call CanTp_ReadParameter() API to read BS value.
    03: Verify that the updated BS value will be stored in newBS_Value through CanTp_ReadParameter() API.
    04: Set PduR buffer to 20. (Calculated BS is higher than maximum BS).
    05: Perform segmented reception (message length 19 = FF + CF + CF) until FC(CTS) is sent.
    06: VP(): Verify that new BS is transmitted as maximum and not the configured value.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00302_E_OK_BS</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>55</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00323_E_OK_BS</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>387</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.CanTp_ChangeRxParameter</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>752</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1433</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_Mixed_SF_InvalidLength</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_ConfigOptMixed/source/application/Tst_OptMixed.c</sourcefile>
      <sourceline>91</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify the behavior when SF is received with message length greater than 6 bytes
    for mixed addressing.
  
Test Object: 
    Det reporting while SF is received with invalid message length.
  
Test Precondition: 
    CanTp should be initialized.
    Configure mixed addressing format.
    Padding is disabled.
  
Test Execution: 
    01: Simulate reception of SF on a N-Sdu configured for mixed addressing with
        message length as 7.
    02: VP(CanTp.EB.SF.InvalidRxLength_4):
        Check that the module ignores the SF and reports CANTP_E_INVALID_RX_LENGTH to DET.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.SF.InvalidRxLength_4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>634</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1434</internalId></specobject>
    <specobject>
      <id>TS_CANTP_Mixed_FF_InvalidLength</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_ConfigOptMixed/source/application/Tst_OptMixed.c</sourcefile>
      <sourceline>161</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify the behavior when FF is received with message length greater than 6 bytes
    for mixed addressing.
  
Test Object: 
    Invalid frame handling
  
Test Precondition: 
    CanTp should be initialized.
    Configure mixed addressing.
    Padding disabled.
  
Test Execution: 
    01: Simulate reception of FF with message length 5U(which can fit in a SF) on a N-Pdu
        configured for mixed addressing.
    02: VP(CanTp.EB.FF.InvalidRxLength_3):
        Check the module ignores the FF and reports CANTP_E_INVALID_RX_LENGTH to DET.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.FF.InvalidRxLength_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>637</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1435</internalId></specobject>
    <specobject>
      <id>TS_CANTP_Mixed_FF_InvalidLength_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_ConfigOptMixed/source/application/Tst_OptMixed.c</sourcefile>
      <sourceline>230</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify the behavior when FF is received with PDU length smaller than 3 bytes
    for mixed addressing.
  
Test Object: 
    Invalid frame handling
  
Test Precondition: 
    CanTp should be initialized.
    Configure mixed addressing.
    Padding disabled.
  
Test Execution: 
    01: Simulate reception of FF with message length 5U and PDU length 2U
        configured for mixed addressing.
    02: VP(CanTp.EB.FF.InvalidRxLength_5):
        Check the module ignores the FF and reports CANTP_E_INVALID_RX_LENGTH to DET.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.FF.InvalidRxLength_5</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>639</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1436</internalId></specobject>
    <specobject>
      <id>TS_CANTP_FC_Mixed_InvalidLength</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_ConfigOptMixed/source/application/Tst_OptMixed.c</sourcefile>
      <sourceline>300</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that Det error CANTP_E_INVALID_RX_LENGTH is reported when a FC frame is received with
    N-Pdu length less than 4 bytes in case of mixed addressing.
  
Test Object: 
    Det error reporting when FC is received with invalid N_Pdu length.
  
Test Precondition: 
    CanTp should be initialized.
    Configure mixed addressing.
    Padding disabled.
  
Test Execution: 
    01: Simulate reception of FF on CanTpTxNSdu_0 which is configured for mixed addressing with
        message length as 7 and verify that FF is transmitted correctly.
    02: Call CanTp_TxConfirmation to confirm the transmission of FF.
    03: Simulate the reception of FC CTS with N-Pdu length as 3 bytes which is invalid.
    04: VP(CanTp.EB.Receiving.RxFC.UnexpectedLengths):
        Check that Det error CANTP_E_INVALID_RX_LENGTH is reported.
    05: Simulate the reception of FC CTS with correct N-Pdu length, i.e 4 bytes.
    06: Finish the transmission successfully.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.Receiving.RxFC.UnexpectedLengths</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>744</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1437</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_31001</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_FullDuplex/source/application/Tst_Tests.c</sourcefile>
      <sourceline>237</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Reception of a SF while a segmented transmission is in progress on the same
    channel.
  
Test Object: 
    Message reception
  
Test Precondition: 
    CanTp should be initialized.
  
Test Execution: 
    01: VP(CanTp.EB.PBSelectable.Master): Check that CanTp_PBcfg.h exists and can be included
    02: VP(CanTp.EB.PBSelectable.FileName): Verify that files CanTp_V1_PBcfg.h and
       CanIf_V2_PBcfg.h exist.
    03: VP(CanTp.EB.PBSelectable.TypeName): Verify that types CanTp_V2_ConstConfigLayoutType
       and CanTp_V2_ConfigLayoutType exist.
    04: VP(CanTp.EB.PBSelectable.TypeName, CanTp.EB.PBSelectable.FileName): Verify that configuration
       variables CanTp_V1_ConfigLayout and CanTp_V2_ConfigLayout exist.
       Check indirectly (via usage of CanTp_V1_ConfigLayout and CanTp_V2_ConfigLayout)
       that files CanTp_V1_PBcfg.c and CanTp_V2_PBcfg.c have been included and were compiled.
    05: Call CanTp_Transmit with message length 10 (ML&gt;6).
    06: Expire one MainFunction cycle and verify whether the FF is transmitted.
    07: Confirm the sent FF.
    08: Simulate Reception of SF on same channel.
    09: VP(CanTp.SWS_CanTp_00057_FullDuplex_1):
        Verify that the buffer is requested correctly and PduR is notified with E_OK and
        verify the whether the data is correctly written to PduR buffer.
    10: Receive FC CTS frame which is expected at this time for the continuation of Transmission.
    11: VP(CanTp.SWS_CanTp_00057_FullDuplex_4):
        Verify that the received CF is accepted.
    12: Check that CF was correctly sent and confirm the CF.
    13: Check, that the transmission is correctly reported to the upper layer.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_FullDuplex_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>306</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_FullDuplex_4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>309</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.PBSelectable.TypeName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>746</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.PBSelectable.FileName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>745</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.PBSelectable.Master</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>747</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1438</internalId></specobject>
    <specobject>
      <id>TS_CANTP_31002</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_FullDuplex/source/application/Tst_Tests.c</sourcefile>
      <sourceline>487</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Reception of a segmented message (FF &amp; CF(s)) while a segmented transmission
    is in progress on the same channel.
  
Test Object: 
    Message reception
  
Test Precondition: 
    CanTp should be initialized
  
Test Execution: 
    01: Prepare a segmented transmission on channel FD1 with Msg length 15 (use length &gt; 6).
    02: Start the segmented transmission by calling CanTp_MainFunction and verify the transmitted
        FF.
    03: Confirm correct transmission of FF.
    04: Receive an FF on the same channel while Tx is going on.
    05: VP(CanTp.SWS_CanTp_00057_FullDuplex_2):
        Verify that new reception is accepted by checking buffer requests.
    06: Verify that the reception triggered the transmission of a FC(CTS) frame and
        verify the FC frame.
    07: Confirm the FC frame.
    08: VP(CanTp.SWS_CanTp_00057_FullDuplex_4, CanTp.SWS_CanTp_00057_FullDuplex_9):
        Continue the transmission by receiving FC(CTS) frame  and verify that the
        FC frame is accepted as CanTp was waiting for FC to continue Tx process.
    09: Verify that CF is correctly transmitted.
    10: VP(CanTp.SWS_CanTp_00057_FullDuplex_3, CanTp.SWS_CanTp_00057_FullDuplex_8):
        Receive CF correctly and verify that the reception completed successfully.
    11: Confirm the transmitted CF and finish the transmission successfully.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_FullDuplex_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>307</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_FullDuplex_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>308</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_FullDuplex_4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>309</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_FullDuplex_8</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>313</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_FullDuplex_9</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>314</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1439</internalId></specobject>
    <specobject>
      <id>TS_CANTP_31003</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_FullDuplex/source/application/Tst_Tests.c</sourcefile>
      <sourceline>781</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Reception of a CF (without a previous FF) while a segmented transmission
    is in progress on the same channel.
  
Test Object: 
    Message reception
  
Test Precondition: 
    CanTp should be initialized
  
Test Execution: 
    01: Start a segmented transmission on channel FD1 with length 15(use length &gt; 6).
    02: VP(CanTp.SWS_CanTp_00057_FullDuplex_3):
        Receive an unexpected CF and verify that it is not accepted.
    03: Proceed the segmented transmission by calling main function.
    04: Verify that FF is transmitted correctly.
    05: VP(CanTp.SWS_CanTp_00057_FullDuplex_3):
        Receive an unexpected CF and verify that it is not accepted.
    06: Confirm correct transmission of FF to start the second transmission.
    07: VP(CanTp.SWS_CanTp_00057_FullDuplex_3):
        Receive an unexpected CF and verify that it is not accepted.
    08: Receive FC(CTS) to trigger transmission of next CF.
    09: Verify that the CF is transmitted correctly.
    10: VP(CanTp.SWS_CanTp_00057_FullDuplex_3):
        Receive an unexpected CF and verify that it is not accepted.
    11: Confirm the CF to continue the transmission and finish the transmission successfully.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_FullDuplex_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>308</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1440</internalId></specobject>
    <specobject>
      <id>TS_CANTP_31004</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_FullDuplex/source/application/Tst_Tests.c</sourcefile>
      <sourceline>1010</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Reception of unexpected FC frames while a segmented transmission is in
    progress on the same channel/Tx N-SDU.
  
Test Object: 
    Message reception
  
Test Precondition: 
    CanTp should be initialized
  
Test Execution: 
    01: Start a segmented transmission on channel FD1 with Message length 20.
    02: VP(CanTp.SWS_CanTp_00057_FullDuplex_4):
        Verify that the reception of an unexpected FC frame is ignored at this time.
    03: Expire one Main Function cycle to start the transmission.
    04: Verify the transmitted FF.
    05: VP(CanTp.SWS_CanTp_00057_FullDuplex_4):
        Verify that the reception of an unexpected FC frame is ignored at this time.
    06: Confirm correct transmission of FF to start the second transmission.
    07: VP(CanTp.SWS_CanTp_00057_FullDuplex_4):
        Receive the expected FC(CTS) frame and verify that it is accepted and CF with 5 bytes
        of data is sent.
    08: VP(CanTp.SWS_CanTp_00057_FullDuplex_4):
        Verify that the reception of an unexpected FC frame is ignored at this time.
    09: Confirm the CF to continue the transmission.
    10: Verify that the next CF is sent correctly and proceed the transmission to finish it successfully.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_FullDuplex_4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>309</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1441</internalId></specobject>
    <specobject>
      <id>TS_CANTP_31005</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_FullDuplex/source/application/Tst_Tests.c</sourcefile>
      <sourceline>1286</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Reception of an unknown frame while a segmented transmission is in progress
    on the same channel.
  
Test Object: 
    Message reception
  
Test Precondition: 
    CanTp should be initialized
  
Test Execution: 
    01: Start a segmented transmission on channel FD1 (use length &gt; 6).
    02: VP(CanTp.SWS_CanTp_00057_FullDuplex_5):
        Receive an Unknown Frame and verify that the frame is ignored.
    03: Call CanTp_MainFunction and verify the transmitted FF.
    04: VP(CanTp.SWS_CanTp_00057_FullDuplex_5):
        Receive an Unknown Frame and verify that the frame is ignored.
    05: Confirm the FF.
    06: VP(CanTp.SWS_CanTp_00057_FullDuplex_5):
        Receive an Unknown Frame and verify that the frame is ignored.
    07: Receive FC(CTS) frame which triggers the transmission of next CF.
    08: Verify the transmitted CF.
    09: VP(CanTp.SWS_CanTp_00057_FullDuplex_5):
        Receive an Unknown Frame and verify that the frame is ignored.
    10: Confirm the CF to continue the transmission and verify the next CF transmitted.
    11: VP(CanTp.SWS_CanTp_00057_FullDuplex_5):
        Receive an Unknown Frame and verify that the frame is ignored.
    12: Confirm the last CF and verify that the PduR is notified with E_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_FullDuplex_5</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>310</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1442</internalId></specobject>
    <specobject>
      <id>TS_CANTP_31006</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_FullDuplex/source/application/Tst_Tests.c</sourcefile>
      <sourceline>1525</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Reception of a single frame on a full duplex channel, while a segmented
    reception (and a segmented transmission) is already ongoing.
  
Test Object: 
    Message reception
  
Test Precondition: 
    CanTp should be initialized
  
Test Execution: 
    01: Simulate reception of FF with Message Length 10 and payload length 8.
    02: Verify whether FC frame is transmitted correctly.
    03: Prepare a segmented transmission on channel FD1 (use length &gt; 6).
    04: Start the segmented transmission by calling CanTp_MainFunction.
    05: Verify whether FF is transmitted correctly and confirm the frame.
    06: Simulate reception of SF on the same channel with the same N_SA.
    07: VP(CanTp.SWS_CanTp_00057_FullDuplex_1, CanTp.SWS_CanTp_00057_FullDuplex_6):
        Check that the previous reception was aborted as a new SF has arrived.
    08: VP(CanTp.SWS_CanTp_00057_FullDuplex_1, CanTp.SWS_CanTp_00057_FullDuplex_6):
        Check that the buffer was requested correctly for the SF and verify that PduR is
        notified with result E_OK.
    09: Simulate the reception of FC(CTS) for the final CF to get transmitted.
    10: Check that CF was correctly sent and confirm.
    11: Verify that the transmission is finished successfully and reported to PduR with result
        E_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_FullDuplex_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>306</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_FullDuplex_6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>311</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1443</internalId></specobject>
    <specobject>
      <id>TS_CANTP_31007</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_FullDuplex/source/application/Tst_Tests.c</sourcefile>
      <sourceline>1787</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Reception of a first frame on a full duplex channel, while a segmented
    reception (and a segmented transmission) is already ongoing.
  
Test Object: 
    Message reception
  
Test Precondition: 
    CanTp should be initialized
  
Test Execution: 
    01: Simulate reception of FF and verify the FC frame transmitted.
    02: Confirm the sent FC frame.
    03: Prepare a segmented transmission on same channel FD1 (use length &gt; 6).
    04: Start the segmented transmission by calling CanTp_MainFunction and verify whether
        FF is transmitted correctly.
    05: Confirm correct transmission of FF.
    06: VP(CanTp.SWS_CanTp_00057_FullDuplex_8):
        Simulate reception of first CF and verify whether it is accepted.
    07: Simulate reception of new FF on same channel with same N_SA.
    08: VP(CanTp.SWS_CanTp_00057_FullDuplex_2, CanTp.SWS_CanTp_00057_FullDuplex_7):
        Check that the previous reception was aborted and the new reception is accepted.
    09: Verify whether the new reception triggered the transmission of a FC(CTS) frame.
    10: Confirm the FC frame.
    11: VP(CanTp.SWS_CanTp_00057_FullDuplex_9):
        Simulate the reception of FC frame to continue the transmission section and verify the
        whether CF is transmitted indicating that the FC frame is accepted.
    12: VP(CanTp.SWS_CanTp_00057_FullDuplex_8):
        Simulate reception of first CF and verify whether it is accepted.
    13: Confirm the transmitted CF to finish the transmission.
    14: Simulate reception of last CF to finish the reception successfully.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_FullDuplex_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>307</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_FullDuplex_7</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>312</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_FullDuplex_8</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>313</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_FullDuplex_9</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>314</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1444</internalId></specobject>
    <specobject>
      <id>TS_CANTP_31008</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_FullDuplex/source/application/Tst_Tests.c</sourcefile>
      <sourceline>2154</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Reception of an unexpected FC frame on a full duplex channel, while a segmented
    reception is ongoing.
  
Test Object: 
    Message reception
  
Test Precondition: 
    CanTp should be initialized
  
Test Execution: 
    01: Simulate reception of FF with message length as 7.
    02: VP(CanTp.SWS_CanTp_00057_FullDuplex_12):
        Verify that the reception triggered the transmission of a FC(CTS) frame.
    03: VP(CanTp.SWS_CanTp_00057_FullDuplex_9):
        Receive an unexpected FC WAIT frame and verify that it is ignored.
    04: Confirm the FC frame transmitted.
    05: VP(CanTp.SWS_CanTp_00057_FullDuplex_9):
        Receive an unexpected FC CTS frame and verify that it is ignored.
    06: VP(CanTp.SWS_CanTp_00057_FullDuplex_8):
        Simulate reception of first (and last) CF and verify that it is accepted and
        PduR is notified with E_OK indicating successful reception.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_FullDuplex_8</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>313</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_FullDuplex_9</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>314</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_FullDuplex_12</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>317</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1445</internalId></specobject>
    <specobject>
      <id>TS_CANTP_31009</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_FullDuplex/source/application/Tst_Tests.c</sourcefile>
      <sourceline>2348</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Reception of an unknown frame on a full duplex channel, while a
    segmented reception is already ongoing.
  
Test Object: 
    Message reception
  
Test Precondition: 
    CanTp should be initialized
  
Test Execution: 
    01: Simulate reception of FF to start a segmented reception.
    02: VP(CanTp.SWS_CanTp_00057_FullDuplex_12):
        Verify that the reception triggered the transmission of a FC(CTS) frame.
    03: VP(CanTp.SWS_CanTp_00057_FullDuplex_10):
        Receive an Unknown frame and verify that it is not accepted.
    04: Confirm the FC frame.
    05: VP(CanTp.SWS_CanTp_00057_FullDuplex_10):
        Receive an Unknown frame and verify that it is not accepted.
    06: VP(CanTp.SWS_CanTp_00057_FullDuplex_8):
        Simulate reception of CF (last) and verify that it is accepted.
    07: Check that PduR got notified with result E_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_FullDuplex_8</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>313</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_FullDuplex_10</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>315</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_FullDuplex_12</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>317</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1446</internalId></specobject>
    <specobject>
      <id>TS_CANTP_31010</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_FullDuplex/source/application/Tst_Tests.c</sourcefile>
      <sourceline>2520</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Reception of a SF on an idle full duplex channel.
  
Test Object: 
    Message reception
  
Test Precondition: 
    CanTp should be initialized
  
Test Execution: 
    01: Simulate reception of SF.
    02: VP(CanTp.SWS_CanTp_00057_FullDuplex_11):
        Verify that the frame is accepted and buffer is requested to PduR.
    03: Verify that the reception is finished successfully and PduR is notified with E_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_FullDuplex_11</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>316</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1447</internalId></specobject>
    <specobject>
      <id>TS_CANTP_31011</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_FullDuplex/source/application/Tst_Tests.c</sourcefile>
      <sourceline>2633</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Reception of a CF on an idle full duplex channel.
  
Test Object: 
    Message reception
  
Test Precondition: 
    CanTp should be initialized
  
Test Execution: 
    01: VP(CanTp.SWS_CanTp_00057_FullDuplex_13):
        Simulate the reception of an unexpected CF and verify that the frame is not accepted.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_FullDuplex_13</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>318</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1448</internalId></specobject>
    <specobject>
      <id>TS_CANTP_31012</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_FullDuplex/source/application/Tst_Tests.c</sourcefile>
      <sourceline>2695</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Reception of an (unexpected) FC frame on an idle full duplex channel.
  
Test Object: 
    Message reception
  
Test Precondition: 
    CanTp should be initialized
  
Test Execution: 
    01: VP(CanTp.SWS_CanTp_00057_FullDuplex_14):
        Simulate the reception of unexpected FC CTS frame in idle state and verify that it
        is not accepted.
    02: VP(CanTp.SWS_CanTp_00057_FullDuplex_14):
        Simulate the reception of unexpected FC WAIT frame in idle state and verify that it
        is not accepted.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_FullDuplex_14</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>319</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1449</internalId></specobject>
    <specobject>
      <id>TS_CANTP_31013</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_FullDuplex/source/application/Tst_Tests.c</sourcefile>
      <sourceline>2782</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Reception of an unknown frame (wrong N_PCI) on an idle full duplex channel.
  
Test Object: 
    Message reception
  
Test Precondition: 
    CanTp should be initialized
  
Test Execution: 
    01: VP(CanTp.SWS_CanTp_00057_FullDuplex_15):
        Simulate the reception of an unknown frame and verify that it is not accepted.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_FullDuplex_15</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>320</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1450</internalId></specobject>
    <specobject>
      <id>TS_CANTP_31015</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_FullDuplex/source/application/Tst_Tests.c</sourcefile>
      <sourceline>2844</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Segmented message transmission with an STmin of not 0 on a full duplex
    channel with STmin being controlled by the Gpt.
    Failed transmission is initiated on a separate channel to check if the first channel continues normal functioning.
  
Test Object: 
    Message reception
  
Test Precondition: 
    CanTp should be initialized
  
Test Execution: 
    01: Start a segmented transmission on channel FD3 with message length 23.
    02: Verify whether FF is transmitted correctly and confirm the FF.
    03: Simulate reception of FC(CTS) to start CF transmission.
    04: Check that the first CF transmission was correctly requested.
    05: Verify that no Gpt call occurred until now.
    06: Confirm the CF so that STmin will get started.
    07: VP(CanTp.EB.Gpt.STminHandling_1):
        Verify that Gpt timer started.
    08: Simulate 1 main function call which is less than STmin and check that buffer was requested
        for next CF.
    09: Start a segmented transmission on channel 2 which will
        trigger a BUFREQ_E_NOT_OK response from PduR.
    10: Simulate 2 main function calls which is less than STmin and check that buffer was requested
        for next CF.
    11: VP(CanTp.EB.Gpt.STminHandling_1):
        Check that no new frame was sent as STmin is still not elapsed.
    12: VP(CanTp.EB.Gpt.STminHandling_2b):
        Call the Gpt callback to finish waiting for STmin.
    13: Check that second CF transmission was correctly requested.
    14: Confirm the CF  and verify the Gpt call to start timer.
    15: Simulate a few main function calls less than STmin and check that buffer
         was requested for next CF.
    16: VP(CanTp.EB.Gpt.STminHandling_1):
        Check that no new frame was sent.
    17: VP(CanTp.EB.Gpt.STminHandling_2b):
        Call the Gpt callback to finish waiting for STmin.
    18: Check that the last CF transmission was correctly requested.
    19: Confirm the CF to continue the transmission and verify that PduR is notified about the
        successful transmission.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.Gpt.STminHandling_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>552</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Gpt.STminHandling_2b</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>556</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1451</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_MetaDataParallelHandling_ReceiveSF</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_MetadataParallelHandling_Support/source/application/Tests.c.m4</sourcefile>
      <sourceline>59</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
      Check that a SF is processed when CanTpMetaDataParallelHandling is enabled.
  
Test Object: 
  
Test Precondition: 
  
Test Execution: 
      01: Start reception of SF by calling CanTp_RxIndication() and check EcuC API's.
      02: VP(CanTp.EB.CanTpMetaDataParallelHandling_Reception)
          Check that EcuC_GetMetaDataCanId called for NPdu
      03: VP(CanTp.EB.CanTpMetaDataParallelHandling_RxDifferentMetadata)
          Check that reception was performed with success.
      04: Check that reception was performed with success.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanTpMetaDataParallelHandling_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>812</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.CanTpMetaDataParallelHandling_Reception</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>816</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.CanTpMetaDataParallelHandling_RxDifferentMetadata</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>818</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1452</internalId></specobject>
    <specobject>
      <id>TS_CANTP_MetaDataParallelHandling_ReceiveMultiframe</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_MetadataParallelHandling_Support/source/application/Tests.c.m4</sourcefile>
      <sourceline>139</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
      This test checks that a multiframe reception is performed with success for a PDU with MetaData.
  
Test Object: 
  
Test Precondition: 
  
Test Execution: 
      01: Start reception of FF by calling CanTp_RxIndication() and check EcuC API's.
      02: VP(CanTp.EB.CanTpMetaDataParallelHandling_Reception)
          Check that EcuC_GetMetaDataCanId called for NPdu
      03: VP(CanTp.EB.CanTpMetaDataParallelHandling_RxDifferentMetadata)
          Check that reception was performed with success.
      04: Check that reception was performed with success.
      05: Check that FF reception has triggered FC transmission.
      06: Confirm FC transmission.
      07: Simulate reception of CF with SN 1.
      08: VP(CanTp.EB.CanTpMetaDataParallelHandling_RxDifferentMetadata)
          Check that EcuC_GetMetaDataCanId is called twice, one time for received NPdu and
          one more time for the NSdu that haves a multiframe reception ongoing.
      09: Check that reception was performed with success
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanTpMetaDataParallelHandling_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>812</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.CanTpMetaDataParallelHandling_Reception</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>816</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.CanTpMetaDataParallelHandling_RxDifferentMetadata</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>818</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1453</internalId></specobject>
    <specobject>
      <id>TS_CANTP_MetaDataParallelHandling_MultiRx</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_MetadataParallelHandling_Support/source/application/Tests.c.m4</sourcefile>
      <sourceline>268</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
      This test checks that a multiframe reception is performed with success for a PDU with MetaData.
  
Test Object: 
  
Test Precondition: 
  
Test Execution: 
      01: Start reception of FF by calling CanTp_RxIndication() and check EcuC API's.
      02: VP(CanTp.EB.CanTpMetaDataParallelHandling_Reception)
          Check that EcuC_GetMetaDataCanId called for NPdu
      03: VP(CanTp.EB.CanTpMetaDataParallelHandling_RxDifferentMetadata)
          Check that reception was performed with success.
      04: Check that reception was performed with success.
      05: Check that FF reception has triggered FC transmission.
      06: Start reception of FF by calling CanTp_RxIndication() and check EcuC API's.
      07: Check that reception was performed with success.
      08: Check that FF reception has triggered FC transmission with the correct TxPduId.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanTpMetaDataParallelHandling_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>812</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.CanTpMetaDataParallelHandling_Reception</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>816</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.CanTpMetaDataParallelHandling_RxDifferentMetadata</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>818</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1454</internalId></specobject>
    <specobject>
      <id>TS_CANTP_MetaDataParallelHandling_ReceiveMultiframe_Fail</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_MetadataParallelHandling_Support/source/application/Tests.c.m4</sourcefile>
      <sourceline>382</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
      This test checks that a received CF is not processed if it haves a different metadata
      than the received FF.
  
Test Object: 
  
Test Precondition: 
  
Test Execution: 
      01: Start reception of FF by calling CanTp_RxIndication() and check EcuC API's.
      02: VP(CanTp.EB.CanTpMetaDataParallelHandling_Reception)
          Check that EcuC_GetMetaDataCanId called for NPdu
      03: VP(CanTp.EB.CanTpMetaDataParallelHandling_RxDifferentMetadata)
          Check that reception was performed with success.
      04: Check that reception was performed with success.
      05: Check that FF reception has triggered FC transmission.
      06: Confirm FC transmission.
      07: Simulate reception of CF with SN 1 and wrong metadata.
      08: VP(CanTp.EB.CanTpMetaDataParallelHandling_RxDifferentMetadataCF)
          Check that received CF was not processed.
      09: Simulate reception of CF with expected metadata.
      10: Check that reception was performed with success.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanTpMetaDataParallelHandling_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>812</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.CanTpMetaDataParallelHandling_RxDifferentMetadataCF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>819</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1455</internalId></specobject>
    <specobject>
      <id>TS_CANTP_MetaDataParallelHandling_ReceiveMultiframeOngoing_FullDuplex</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_MetadataParallelHandling_Support/source/application/Tests.c.m4</sourcefile>
      <sourceline>528</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
      Check that a FF that has the same metadata as an ongoing reception is processed and the ongoing one is discarded.
      Check that a FF is not processed when the pool is full.
  
Test Object: 
  
Test Precondition: 
  
Test Execution: 
      01: Start reception of FF by calling CanTp_RxIndication() and check EcuC API's.
      02: Check that reception was performed with success
      03: Check that FF reception has triggered FC transmission.
      04: Confirm FC transmission.
      05: Simulate reception of a FF with same metadata as the previous one(mutiframe reception still ongoing).
      06: VP(CanTp.EB.CanTpMetaDataParallelHandling_RxSameMetadata)
          Check that first reception was aborted.
      07: Check that FF reception has triggered FC transmission.
      08: Simulate reception of several FF with different metadata to fill the pool.
      09: VP(CanTp.EB.CanTpMetaDataParallelHandling_RxNSduNotAvailable)
          Check that latest received FF was not processed because the pool if full.
      10: Simulate reception of CF with SN 1 for all received FF in order to bring channels to idle.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanTpMetaDataParallelHandling_RxSameMetadata</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>817</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.CanTpMetaDataParallelHandling_RxNSduNotAvailable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>820</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.CanTpMetaDataParallelHandling_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>812</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1456</internalId></specobject>
    <specobject>
      <id>TS_CANTP_MetaDataParallelHandling_TransmitSF</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_MetadataParallelHandling_Support/source/application/Tests.c.m4</sourcefile>
      <sourceline>776</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
        Simulate transmission of a SF and check that metadata from NSdu is set on NPdu.
  
Test Object: 
  
Test Precondition: 
  
Test Execution: 
      01: Initiate SF transmission and check that metadata from NSdu is set on NPdu.
      02: VP(CanTp.EB.CanTpMetaDataParallelHandling_SF_Transmission)
          Check that metadata is read from TxNSdu and it is set on TxNPdu
      03: Call CanTp_MainFunction().
      04: Verify PduR_CanTpCopyTxData() is called.
      05: CanTp should transmit the SF by calling CanIf_Transmit().
      06: Finish SF transmission.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanTpMetaDataParallelHandling_SF_Transmission</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>821</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.CanTpMetaDataParallelHandling_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>812</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1457</internalId></specobject>
    <specobject>
      <id>TS_CANTP_MetaDataParallelHandling_TransmitMultiframe</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_MetadataParallelHandling_Support/source/application/Tests.c.m4</sourcefile>
      <sourceline>860</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
      This test  checks that a multiframe transmission is performed with success for a PDU with MetaData.
  
Test Object: 
  
Test Precondition: 
  
Test Execution: 
      01: Initiate FF transmission and check that metadata from NSdu is set on NPdu.
      02: VP(CanTp.EB.CanTpMetaDataParallelHandling_FF_Transmission)
          Check that metadata is read from TxNSdu and it is set on TxNPdu
      03: VP(CanTp.EB.CanTpMetaDataParallelHandling_FF_Transmission)
          Get metadata for RxFcNpdu.
      04: Call CanTp_MainFunction().
      05: Verify PduR_CanTpCopyTxData() is called.
      06: CanTp should transmit the FF by calling CanIf_Transmit().
      07: Confirm FF transmission
      08: Start reception of a FC by calling CanTp_RxIndication() and check EcuC API's.
      09: Check whether PduR_CanTpCopyTxData() is called for 1st CF.
      10: CanTp should transmit the CF by calling CanIf_Transmit().
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanTpMetaDataParallelHandling_FF_Transmission</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>822</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.CanTpMetaDataParallelHandling_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>812</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1458</internalId></specobject>
    <specobject>
      <id>TS_CANTP_MetaDataParallelHandling_TransmitMultiframe_Fail</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_MetadataParallelHandling_Support/source/application/Tests.c.m4</sourcefile>
      <sourceline>977</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
      This test  checks that CF transmission is not triggered by a received FC with wrong metadata.
  
Test Object: 
  
Test Precondition: 
  
Test Execution: 
      01: Initiate FF transmission and check that metadata from NSdu is set on NPdu.
      02: VP(CanTp.EB.CanTpMetaDataParallelHandling_FF_Transmission)
          Check that metadata is read from TxNSdu and it is set on TxNPdu
      03: VP(CanTp.EB.CanTpMetaDataParallelHandling_FF_Transmission)
          Get metadata for RxFcNpdu.
      04: Call CanTp_MainFunction().
      05: Verify PduR_CanTpCopyTxData() is called.
      06: CanTp should transmit the FF by calling CanIf_Transmit().
      07: Confirm FF transmission
      08: Start reception of a FC with wrong metadata.
      09: VP(CanTpMetaDataParallelHandling_FC_Reception)
          Check that received FC was not processed.
      10: Start reception of a FC with correct metadata and check that the transmission is finished with success.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanTpMetaDataParallelHandling_FC_Reception</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>823</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.CanTpMetaDataParallelHandling_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>812</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1459</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_MetaDataParallelHandling_ReceiveMultiframe_Invalid_RxPduId</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_MetadataParallelHandling_Support_DetOff/source/application/Tests.c.m4</sourcefile>
      <sourceline>59</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
      This test checks that CanTp_RxIndication doesn't call EcuC_GetMetaDataCanId when given an invalid RxPduId
      and Det is turned off.
  
Test Object: 
  
Test Precondition: 
  
Test Execution: 
      01: Start reception of FF by calling CanTp_RxIndication() and using invalid RxPduId.
      02: VP(CanTp.EB.CanTpMetaDataParallelHandling_Conf)
            Check that EcuC_GetMetaDataCanId was not called
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanTpMetaDataParallelHandling_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>812</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1460</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_MetaDataSupport_ReceiveSF</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_MetadataSupport/source/application/Tests.c.m4</sourcefile>
      <sourceline>59</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
      First test suite is checking that EcuC API's are called successfully and the right SA and TA are set.
      Second test suite is checking that SF reception is ignored when TA from CanId is different than the configured one.
      Third test suite is checking that SF reception is ignored when TaType form CanId is different than the configured one.
  
Test Object: 
  
Test Precondition: 
  
Test Execution: 
      0.1: Start reception of SF by calling CanTp_RxIndication() and check EcuC API's.
      0.2: Check that reception was performed with success.
      1.1: Set CanID with different TA than the configured one.
      1.2: Start reception of SF with N_TAtype - Physical.
      1.3: Check that after CanId was checked, the reception was ignored due to different TA in the CanID.
      2.1: Set CanID with N_TAtype - Functional.
      2.2: Start reception of SF with N_TAtype - Physical.
      2.3: Check that after CanId was checked, the reception was ignored due to different TaType in the CanID.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetRxNTaFromCanId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>774</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.SetRxNTa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>777</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.SetRxNSa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>778</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetRxNSaGenConnectionOn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>775</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetRxNSaGenConnectionOff</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>776</internalId></provcov>
        <provcov>
          <linksto>CanTp.ECUC_CanTp_00303</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>424</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1461</internalId></specobject>
    <specobject>
      <id>TS_CANTP_MetaDataSupport_ReceiveMultiframe</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_MetadataSupport/source/application/Tests.c.m4</sourcefile>
      <sourceline>172</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
      This test checks that a multiframe reception is performed with success for a PDU with MetaData.
  
Test Object: 
  
Test Precondition: 
  
Test Execution: 
      01: Start reception of FF by calling CanTp_RxIndication() and check EcuC API's.
      02: Check that reception was performed with success.
      03: Check that MetaData APIs were called with success to get N_TA, N_AS and set CanID.
      04: Check that FF reception has triggered FC transmission.
      05: Confirm FC transmission.
      06: Simulate reception of CF with SN 1.
      07: Check that MetaData APIs were called with success to get N_TA, N_SA and CanID.
      08: Check that N_TA and N_SA matched with CanId and reception was performed.
      09: Start reception of a frame with invalid N_PCI and see that it is ignored for a PDU with MetaData.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetRxNTaFromCanId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>774</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.SetRxNTa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>777</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.SetRxNSa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>778</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetRxNSaGenConnectionOn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>775</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetRxNSaGenConnectionOff</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>776</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.CheckRxNTa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>779</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.CheckRxNSa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>780</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetNSaTxFc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>781</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetNTaTxFc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>782</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.SetTxFcMetaDataCanId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>783</internalId></provcov>
        <provcov>
          <linksto>CanTp.ECUC_CanTp_00303</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>424</internalId></provcov>
        <provcov>
          <linksto>CanTp.ECUC_CanTp_00253</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>465</internalId></provcov>
        <provcov>
          <linksto>CanTp.ECUC_CanTp_00139</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>463</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1462</internalId></specobject>
    <specobject>
      <id>TS_CANTP_MetaDataSupport_ReceiveMultiframeOngoing_HalfDuplex</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_MetadataSupport/source/application/Tests.c.m4</sourcefile>
      <sourceline>331</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
      First test suite checks that a multiframe reception is aborted if it is interrupted by a SF on a HalfDuplex Channel.
      Second test suite checks that a multiframe reception is aborted if it is interrupted by a FF on a HalfDuplex Channel.
  
Test Object: 
  
Test Precondition: 
  
Test Execution: 
      0.1: Start reception of FF by calling CanTp_RxIndication() and check EcuC API's.
      0.2: Check that reception was performed with success.
      0.3: Check that MetaData APIs were called with success to get N_TA, N_AS and set CanID.
      0.4: Check that FF reception has triggered FC transmission.
      0.5: Confirm FC transmission.
      0.6: Simulate reception of CF with SN 1.
      0.7: Check that MetaData APIs were called with success to get N_TA, N_SA and CanID.
      0.8: Check that N_TA and N_SA matched with CanId and reception was performed.
      0.9: Trigger reception of a SF and check EcuC API's.
      0.10: Check that multiframe reception was aborted.
      0.11: Check that SF reception was performed with success.
      1.1: Start reception of FF by calling CanTp_RxIndication() and check EcuC API's.
      1.2: Check that reception was performed with success.
      1.3: Check that MetaData APIs were called with success to get N_TA, N_AS and set CanID.
      1.4: Check that FF reception has triggered FC transmission.
      1.5: Confirm FC transmission.
      1.6: Simulate reception of CF with SN 1.
      1.7: Check that MetaData APIs were called with success to get N_TA, N_SA and CanID.
      1.8: Check that N_TA and N_SA matched with CanId and reception was performed.
      1.9: Trigger reception of a FF and check EcuC API's.
      1.10: Check that first multiframe reception was aborted.
      1.11: Check that FF reception was performed with success.
      1.12: Check that MetaData APIs were called with success to get N_TA, N_AS and set CanID.
      1.13: Check that FF reception has triggered FC transmission.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetRxNTaFromCanId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>774</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.SetRxNTa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>777</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.SetRxNSa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>778</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetRxNSaGenConnectionOn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>775</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetRxNSaGenConnectionOff</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>776</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.CheckRxNTa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>779</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.CheckRxNSa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>780</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetNSaTxFc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>781</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetNTaTxFc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>782</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.SetTxFcMetaDataCanId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>783</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_HalfDuplex_7</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>296</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_HalfDuplex_6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>295</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1463</internalId></specobject>
    <specobject>
      <id>TS_CANTP_MetaDataSupport_ReceiveMultiframeOngoing_FullDuplex</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_MetadataSupport/source/application/Tests.c.m4</sourcefile>
      <sourceline>633</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
      First test suite checks that a multiframe reception is aborted if it is interrupted by a SF on a FullDuplex PDU with MetaData.
      Second test suite checks that a multiframe reception is aborted if it is interrupted by a FF on a FullDuplex PDU with MetaData.
  
Test Object: 
  
Test Precondition: 
  
Test Execution: 
      0.1: Start reception of FF by calling CanTp_RxIndication() and check EcuC API's.
      0.2: Check that reception was performed with success.
      0.3: Check that MetaData APIs were called with success to get N_TA, N_AS and set CanID.
      0.4: Check that FF reception has triggered FC transmission.
      0.5: Confirm FC transmission.
      0.6: Simulate reception of CF with SN 1.
      0.7: Check that MetaData APIs were called with success to get N_TA, N_SA and CanID.
      0.8: Check that N_TA and N_SA matched with CanId and reception was performed.
      0.9: Trigger SF reception and check EcuC API's.
      0.10: Check that multiframe reception was aborted.
      0.11: Process SF.
      1.1: Start reception of FF by calling CanTp_RxIndication() and check EcuC API's.
      1.2: Check that reception was performed with success
      1.3: Check that MetaData APIs were called with success to get N_TA, N_AS and set CanID.
      1.4: Check that FF reception has triggered FC transmission.
      1.5: Confirm FC transmission.
      1.6: Simulate reception of CF with SN 1.
      1.7: Check that MetaData APIs were called with success to get N_TA, N_SA and CanID.
      1.8: Check that N_TA and N_SA matched with CanId and reception was performed.
      1.9: Trigger FF reception and check EcuC API's.
      1.10: Check that multiframe reception was aborted.
      1.11: Process FF.
      1.12: Check that MetaData APIs were called with success to get N_TA, N_AS and set CanID.
      1.13: Check that FC was sent.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetRxNTaFromCanId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>774</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.SetRxNTa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>777</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.SetRxNSa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>778</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetRxNSaGenConnectionOn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>775</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetRxNSaGenConnectionOff</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>776</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.CheckRxNTa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>779</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.CheckRxNSa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>780</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetNSaTxFc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>781</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetNTaTxFc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>782</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.SetTxFcMetaDataCanId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>783</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_FullDuplex_7</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>312</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_FullDuplex_6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>311</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1464</internalId></specobject>
    <specobject>
      <id>TS_CANTP_MetaDataSupport_TransmitSF</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_MetadataSupport/source/application/Tests.c.m4</sourcefile>
      <sourceline>931</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
        First test suite checks that a SF transmission is performed with success for a PDU with MetaData.
        Second test suite checks that a SF transmission is aborted when SA's are not the same.
        Third test suite is executed for TxNsdu with TaType-Functional
  
Test Object: 
  
Test Precondition: 
  
Test Execution: 
      0.1: Initiate SF transmission.
      0.2: Call CanTp_MainFunction().
      0.3: Verify PduR_CanTpCopyTxData() is called.
      0.4: Check that MetaData APIs were called with success to set N_TA and N_SA.
      0.5: CanTp should transmit the SF by calling CanIf_Transmit().
      0.6: Finish SF transmission.
      1.1: Initiate SF transmission.
      1.2: Call CanTp_MainFunction().
      1.3: Verify PduR_CanTpCopyTxData() is called.
      1.4: Check that MetaData APIs were called with success to set N_TA and N_SA.
      1.5: Check that SF transmission was aborted due to different SA.
      2.1: Initiate SF transmission.
      2.2: Call CanTp_MainFunction().
      2.3: Verify PduR_CanTpCopyTxData() is called.
      2.4: Check that MetaData APIs were called with success to set N_TA and N_SA.
      2.5: CanTp should transmit the SF by calling CanIf_Transmit().
      2.6: Finish SF transmission.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetTxNSa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>784</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetTxNTaGenConnectionOff</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>785</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetTxNTaGenConnectionOn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>786</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.SetTxMetaDataCanId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>787</internalId></provcov>
        <provcov>
          <linksto>CanTp.ECUC_CanTp_00303</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>424</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1465</internalId></specobject>
    <specobject>
      <id>TS_CANTP_MetaDataSupport_TransmitMultiframe</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_MetadataSupport/source/application/Tests.c.m4</sourcefile>
      <sourceline>1098</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
      This test  checks that a multiframe transmission is performed with success for a PDU with MetaData.
  
Test Object: 
  
Test Precondition: 
  
Test Execution: 
      01: Initiate FF transmission.
      02: Call CanTp_MainFunction().
      03: Verify PduR_CanTpCopyTxData() is called.
      04: Check that MetaData APIs were called with success to set N_TA and N_SA
      05: CanTp should transmit the FF by calling CanIf_Transmit().
      06: Confirm FF transmission
      07: Start reception of a FC by calling CanTp_RxIndication() and check EcuC API's.
      08: Check whether PduR_CanTpCopyTxData() is called for 1st CF.
      09: Check that MetaData APIs were called with success to set CanID.
      10: CanTp should transmit the CF by calling CanIf_Transmit().
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetTxNSa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>784</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetTxNTaGenConnectionOff</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>785</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetTxNTaGenConnectionOn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>786</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.SetTxMetaDataCanId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>787</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.CheckRxFcNSa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>788</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.CheckRxFcNTa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>789</internalId></provcov>
        <provcov>
          <linksto>CanTp.ECUC_CanTp_00303</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>424</internalId></provcov>
        <provcov>
          <linksto>CanTp.ECUC_CanTp_00253</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>465</internalId></provcov>
        <provcov>
          <linksto>CanTp.ECUC_CanTp_00139</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>463</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1466</internalId></specobject>
    <specobject>
      <id>TS_CANTP_MetaDataSupport_IgnoreCF_DifferentTA</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_MetadataSupport/source/application/Tests.c.m4</sourcefile>
      <sourceline>1230</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
      This test checks that TA shall match the value from the FF.
  
Test Object: 
  
Test Precondition: 
  
Test Execution: 
      01: Start reception of FF by calling CanTp_RxIndication(). and check EcuC API's
      02: Check that reception was performed with success
      03: Check that MetaData APIs were called with success to set CanID.
      04: Check that FF reception has triggered FC transmission.
      05: Confirm FC transmission.
      06: Set different value for TA than the one from  CanID.
      07: Simulate reception of CF with SN 1.
      08: Check that MetaData APIs were called with success to get N_TA, N_AS and CanID.
      09: Check that PduR_CanTpCopyRxData was not called for CF when TA don't match.
      10: Set the same TA for both CanID and TA stub.
      11: Simulate reception of the CF with SN 1 but this time with correct TA.
      12: Check that MetaData APIs were called with success to get N_TA, N_AS and CanID.
      13: Check reception of CF was performed .
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetRxNTaFromCanId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>774</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.SetRxNTa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>777</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.SetRxNSa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>778</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetRxNSaGenConnectionOn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>775</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetRxNSaGenConnectionOff</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>776</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.CheckRxNTa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>779</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetNSaTxFc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>781</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetNTaTxFc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>782</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.SetTxFcMetaDataCanId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>783</internalId></provcov>
        <provcov>
          <linksto>CanTp.ECUC_CanTp_00253</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>465</internalId></provcov>
        <provcov>
          <linksto>CanTp.ECUC_CanTp_00139</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>463</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1467</internalId></specobject>
    <specobject>
      <id>TS_CANTP_MetaDataSupport_IgnoreCF_DifferentSA</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_MetadataSupport/source/application/Tests.c.m4</sourcefile>
      <sourceline>1401</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
      This test checks that CF reception is ignored when SA from CanId set by FC don't match with received one.
  
Test Object: 
  
Test Precondition: 
  
Test Execution: 
      01: Start reception of FF by calling CanTp_RxIndication(). and check EcuC API's
      02: Check that reception was performed with success.
      03: Check that MetaData APIs were called with success to set N_TA and N_AS for FC transmission.
      04: Check that FF reception has triggered FC transmission.
      05: Confirm FC transmission.
      06: Set different value for SA than the one from  CanID.
      07: Simulate reception of CF with SN 1.
      08: Check that MetaData APIs were called with success to get N_TA, N_AS and CanID.
      09: Check that PduR_CanTpCopyRxData was not called for FC when TA don't match.
      10: Set the same SA for both CanID and SA stub.
      11: Simulate reception of the CF with SN 1 but this time with correct TA.
      12: Check that MetaData APIs were called with success to get N_TA, N_AS and CanID.
      13: Check reception of CF was performed .
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetRxNTaFromCanId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>774</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.SetRxNTa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>777</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.SetRxNSa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>778</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetRxNSaGenConnectionOn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>775</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetRxNSaGenConnectionOff</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>776</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.CheckRxNSa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>780</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetNSaTxFc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>781</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetNTaTxFc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>782</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.SetTxFcMetaDataCanId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>783</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1468</internalId></specobject>
    <specobject>
      <id>TS_CANTP_MetaDataSupport_IgnoreFC_DifferentSA</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_MetadataSupport/source/application/Tests.c.m4</sourcefile>
      <sourceline>1568</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
      This test checks that FC reception is ignored when SA from CanId set by FF don't match with received one.
  
Test Object: 
  
Test Precondition: 
  
Test Execution: 
      01: Initiate FF transmission.
      02: Call CanTp_MainFunction().
      03: Verify PduR_CanTpCopyTxData() is called.
      04: Check that MetaData APIs were called with success to set CanID.
      05: CanTp should transmit the FF by calling CanIf_Transmit().
      06: Confirm FF transmission
      07: Set different value for SA than the one from  CanID.
      08: Start reception of a FC by calling CanTp_RxIndication() and check EcuC API's.
      09: Check that PduR_CanTpCopyRxData was not called for FC when SA don't match.
      10: Set the same SA for both CanID and SA stub.
      11: Re trigger reception of a FC by calling CanTp_RxIndication() and check EcuC API's.
      12: Check PduR_CanTpCopyTxData was called to transmit CF.
      13: Check that MetaData APIs were called with success to set CanID.
      14: CanTp should transmit the CF by calling CanIf_Transmit().
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetTxNSa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>784</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetTxNTaGenConnectionOff</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>785</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetTxNTaGenConnectionOn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>786</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.SetTxMetaDataCanId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>787</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.CheckRxFcNSa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>788</internalId></provcov>
        <provcov>
          <linksto>CanTp.ECUC_CanTp_00253</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>465</internalId></provcov>
        <provcov>
          <linksto>CanTp.ECUC_CanTp_00139</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>463</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1469</internalId></specobject>
    <specobject>
      <id>TS_CANTP_MetaDataSupport_IgnoreFC_DifferentTA</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_MetadataSupport/source/application/Tests.c.m4</sourcefile>
      <sourceline>1726</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
      This test checks that FC reception is ignored when TA from CanId set by FF don't match with received one.
  
Test Object: 
  
Test Precondition: 
  
Test Execution: 
      01: Initiate FF transmission.
      02: Call CanTp_MainFunction().
      03: Verify PduR_CanTpCopyTxData() is called.
      04: Check that MetaData APIs were called with success to set CanID.
      05: CanTp should transmit the FF by calling CanIf_Transmit().
      06: Confirm FF transmission
      07: Set different value for TA than the one from  CanID.
      08: Start reception of a FC by calling CanTp_RxIndication() and check EcuC API's.
      09: Check that PduR_CanTpCopyRxData was not called for FC when TA don't match.
      10: Set the same TA for both CanID and TA stub.
      11: Re trigger reception of a FC by calling CanTp_RxIndication() and check EcuC API's.
      12: Check PduR_CanTpCopyTxData was called to transmit CF.
      13: Check that MetaData APIs were called with success to set CanID.
      14: CanTp should transmit the CF by calling CanIf_Transmit().
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetTxNSa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>784</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetTxNTaGenConnectionOff</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>785</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetTxNTaGenConnectionOn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>786</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.SetTxMetaDataCanId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>787</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.CheckRxFcNTa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>789</internalId></provcov>
        <provcov>
          <linksto>CanTp.ECUC_CanTp_00253</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>465</internalId></provcov>
        <provcov>
          <linksto>CanTp.ECUC_CanTp_00139</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>463</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1470</internalId></specobject>
    <specobject>
      <id>TS_CANTP_MetaDataSupport_ReceiveSF_FunctionalTaType</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_MetadataSupport/source/application/Tests.c.m4</sourcefile>
      <sourceline>1884</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
      This test checks SF reception of a pdu with Functional TaType configured.
      Firstly it is checked that reception is performed with success when received CanId
      also haves Functional TaType, and then it is checked that SF is ignored when received
      CanId has TaType - Physical.
  
Test Object: 
  
Test Precondition: 
  
Test Execution: 
      01: Start reception of SF by calling CanTp_RxIndication() and check EcuC API's.
      02: Check that reception was performed with success.
      03: Set CanID with N_TAtype - Physical.
      04: Start reception of SF with N_TAtype - Functional.
      05: Check that after CanId was checked, the reception was ignored due to different CanIDs.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetRxNTaFromCanId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>774</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.SetRxNTa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>777</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.SetRxNSa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>778</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1471</internalId></specobject>
    <specobject>
      <id>TS_CANTP_MetaDataSupport_ChangeParameter</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_MetadataSupport/source/application/Tests.c.m4</sourcefile>
      <sourceline>1980</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
      This test checks that CanTp_ChangeParameter() works fine for a PDU with MetaData.
  
Test Object: 
  
Test Precondition: 
  
Test Execution: 
      01: Set STmin value to 2 and check that it was changed after call of CanTp_ChangeParameter (configuration value - 0)
      02: Start reception of FF by calling CanTp_RxIndication() and check EcuC API's.
      03: Check that reception was performed with success.
      04: Check that MetaData APIs were called with success to get N_TA, N_AS and set CanID.
      05: Check that FF reception has triggered FC transmission.
      06: Check that STmin was updated.
      07: Confirm FC transmission.
      08: Simulate reception of CF with SN 1.
      09: Check that MetaData APIs were called with success to get N_TA, N_SA and CanID.
      10: Check that N_TA and N_SA matched with CanId and reception was performed.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetRxNTaFromCanId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>774</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.SetRxNTa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>777</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.SetRxNSa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>778</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetRxNSaGenConnectionOn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>775</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetRxNSaGenConnectionOff</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>776</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.CheckRxNTa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>779</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.CheckRxNSa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>780</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetNSaTxFc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>781</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetNTaTxFc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>782</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.SetTxFcMetaDataCanId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>783</internalId></provcov>
        <provcov>
          <linksto>CanTp.ECUC_CanTp_00303</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>424</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00338</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>381</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1472</internalId></specobject>
    <specobject>
      <id>TS_CANTP_MetaDataSupport_ReceiveSF_DifferentSA</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_MetadataSupport/source/application/Tests.c.m4</sourcefile>
      <sourceline>2136</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
      This test checks that a SF received with different SA than the configured one will be ignored.
  
Test Object: 
  
Test Precondition: 
  
Test Execution: 
      01: Set CanID with different SA than the configured one.
      02: Start reception of SF with N_TAtype - Physical.
      03: Check that after CanId was checked, the reception was ignored due to different SA's.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetRxNTaFromCanId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>774</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetRxNSaGenConnectionOff</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>776</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1473</internalId></specobject>
    <specobject>
      <id>TS_CANTP_MetaDataSupport_TransmitSF_DifferentTA</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_MetadataSupport/source/application/Tests.c.m4</sourcefile>
      <sourceline>2201</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
      This test case checks that SF transmission is aborted when TA doesn't match with the configured one.
  
Test Object: 
  
Test Precondition: 
  
Test Execution: 
      01: Initiate SF transmission.
      02: Call CanTp_MainFunction().
      03: Verify PduR_CanTpCopyTxData() is called.
      04: Check that MetaData APIs were called with success to get N_TA and N_SA.
      05: Check that SF transmission was aborted due to different SA.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetTxNSa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>784</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.GetTxNTaGenConnectionOff</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>785</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1474</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_30406</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_RxOnly/source/application/Tests.c</sourcefile>
      <sourceline>82</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that mapping of received N-PDUs to N-SDUs works correctly for a configuration using
    Rx N-SDUs only and extended addressing.
  
Test Object: 
    Configuration with only Rx N-SDUs.
    PduR_CanTpStartOfReception should return BUFREQ_E_NOT_OK so that the reception will get
    constantly aborted.
  
Test Precondition: 
  
Test Execution: 
    01: Initialize CanTp module.
    02: Receive an extended SF for first N_SA.
    03: VP(CanTp.SWS_CanTp_00079,CanTp.SWS_CanTp_00281_ExtendedAdr,CanTp.SWS_CanTp_00095_ExtendedAdr):
        PduR_CanTpStartOfReception() should get called with corresponding N-SDU.
    04: Receive an extended SF for second N_SA.
    05: VP(CanTp.SWS_CanTp_00079,CanTp.SWS_CanTp_00281_ExtendedAdr,CanTp.SWS_CanTp_00095_ExtendedAdr):
        PduR_CanTpStartOfReception() should get called with corresponding N-SDU.
    06: Receive an extended SF for third N_SA.
    07: VP(CanTp.SWS_CanTp_00079,CanTp.SWS_CanTp_00281_ExtendedAdr,CanTp.SWS_CanTp_00095_ExtendedAdr):
        PduR_CanTpStartOfReception() should get called with corresponding N-SDU.
    08: Receive a standard SF.
    09: VP(CanTp.SWS_CanTp_00079,CanTp.SWS_CanTp_00281_ExtendedAdr,CanTp.SWS_CanTp_00095_ExtendedAdr):
        PduR_CanTpStartOfReception() should get called with corresponding N-SDU.
    10: VP(CanTp.ASR40.RxIndication.Precondition1):
        PduR_CanTpRxIndication should not get called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00079</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>151</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00281_ExtendedAdr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>226</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00095_ExtendedAdr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>235</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.RxIndication.Precondition1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>494</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1475</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_30441</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_SameRxId/source/application/Tests.c</sourcefile>
      <sourceline>65</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Transmission and reception using the same Rx N-PDU identifier.
  
Test Object: 
    Shared Rx N-PDU
  
Test Precondition: 
  
Test Execution: 
    01: Call CanTp_Transmit() for CanTpTxSduId 0U to start transmission of a segmented message.
    02: Call CanTp_MainFunction().
    03: Verify whether PduR_CanTpCopyTxData() is called with ID 0U.
    04: CanTp should transmit the FF by calling CanIf_Transmit().
    05: Confirm the transmission.
    06: Receive an SF with RxPduID 0U and length 3U while waiting for FC frame.
    07: Verify whether PduR_CanTpStartOfReception() and PduR_CanTpCopyRxData() is called with
        RxNsduID 0U.
    08: VP(CanTp.SWS_CanTp_00120):
        Verify whether PduR_CanTpRxIndication() is called with RxNsduID 0U and result
        E_OK.
    09: Simulate the reception of FC(CTS) frame with the same RxNPduID 0U.
    10: Verify whether the last frame is transmitted through PduR_CanTpCopyTxData and
        CanIf_Transmit call.
    11: Confirm the transmission.
    12: VP(CanTp.SWS_CanTp_00120):
        Verify whether PduR_CanTpTxConfirmation() is called with NsduId 0U and result as E_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00120</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>238</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1476</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_SF_Transmission_Pending_FC</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_SameTxIDs/source/application/Tests.c.m4</sourcefile>
      <sourceline>76</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    If a SF was sent (via CanIf_Transmit()) on a Tx Npdu referencing the same CanIf Npdu as a Tx FcNpdu,
    the CanIf shall postpone the transmission of the FC (of an ongoing segmented reception) until the SF transmission is confirmed.
  
Test Object: 
    Shared Tx NPdu is handled successfully in both reception and transmission serialized by TxConfirmation.
  
Test Precondition: 
  
Test Execution: 
    01: Call CanTp_Transmit() for CanTpTxSduId 1U to start transmission of a SF.
    02: Call CanTp_MainFunction().
    03: Verify PduR_CanTpCopyTxData() is called with ID 1U.
    04: CanTp should transmit the SF by calling CanIf_Transmit().
    05: Start reception of FF by calling CanTp_RxIndication().
    06: Check that CanIf_Transmit() was not called for FC.
    07: Confirm SF transmission.
    08: Check that SF confirmation has triggered a FC transmission.
    09: Confirm FC transmission.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.SameTxNpduFCandData_transmit_SF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>762</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00086</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>203</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00090</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>217</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1477</internalId></specobject>
    <specobject>
      <id>TS_CANTP_SF_Transmission_Timeout_Pending_FC</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_SameTxIDs/source/application/Tests.c.m4</sourcefile>
      <sourceline>201</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    If a SF was sent (via CanIf_Transmit()) on a Tx Npdu referencing the same CanIf Npdu as a Tx FcNpdu,
    the CanIf shall postpone the transmission of the FC (of an ongoing segmented reception) until the SF timeout occurs.
  
Test Object: 
    Shared Tx NPdu is handled successfully in both reception and transmission serialized by TxConfirmation.
  
Test Precondition: 
  
Test Execution: 
    01: PduR shall not have buffer for reception.
    02: Call CanTp_Transmit() for CanTpTxSduId 1U to start transmission of a SF.
    03: Call CanTp_MainFunction().
    04: Verify that PduR_CanTpCopyTxData() is called with ID 1U.
    05: CanTp should transmit the SF by calling CanIf_Transmit().
    06: Start reception of FF by calling CanTp_RxIndication().
    07: Check that CanIf_Transmit() was not called for FC.
    08: Elapse few CanTp_MainFunction() to trigger a N_Br timeout.
    09: Elapse few more CanTp_MainFunction() to trigger also N_As timeout.
    10: Handle timeout by checking that PduR was called with E_NOT_OK parameter.
    11: Check that the postponed FC was sent.
    12: Confirm FC transmission.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.SameTxNpduFCandData_transmit_SF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>762</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00310</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>209</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1478</internalId></specobject>
    <specobject>
      <id>TS_CANTP_FF_Transmission_Pending_FC</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_SameTxIDs/source/application/Tests.c.m4</sourcefile>
      <sourceline>343</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    If a FF was sent (via CanIf_Transmit()) on a Tx Npdu referencing the same CanIf Npdu as a Tx FcNpdu,
    the CanIf shall postpone the transmission of the FC (of an ongoing segmented reception) until the FF transmission is confirmed.
  
Test Object: 
    Shared Tx NPdu is handled successfully in both reception and transmission serialized by TxConfirmation.
  
Test Precondition: 
  
Test Execution: 
    01: Call CanTp_Transmit() for CanTpTxSduId 1U to start transmission of a FF.
    02: Call CanTp_MainFunction().
    03: Verify that PduR_CanTpCopyTxData() is called with ID 1U.
    04: CanTp should transmit the FF by calling CanIf_Transmit().
    05: Start reception of FF by calling CanTp_RxIndication().
    06: Check that CanIf_Transmit() was not called for FC.
    07: Confirm FF transmission.
    08: Check that FF confirmation has triggered FC transmission
    09: Confirm FC transmission.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.SameTxNpduFCandData_transmit_FF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>763</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00086</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>203</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1479</internalId></specobject>
    <specobject>
      <id>TS_CANTP_FF_Transmission_Timeout_Pending_FC</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_SameTxIDs/source/application/Tests.c.m4</sourcefile>
      <sourceline>462</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    If a FF was sent (via CanIf_Transmit()) on a Tx Npdu referencing the same CanIf Npdu as a Tx FcNpdu,
    the CanIf shall postpone the transmission of the FC (of an ongoing segmented reception) until the FF timeout occurs.
  
Test Object: 
    Shared Tx NPdu is handled successfully in both reception and transmission serialized by TxConfirmation.
  
Test Precondition: 
  
Test Execution: 
    01: Prepare PduR_CanTpStartOfReception() to return BUFREQ_E_OVFL.
    02: Call CanTp_Transmit() for CanTpTxSduId 1U to start transmission of a FF.
    03: Call CanTp_MainFunction().
    04: Verify that PduR_CanTpCopyTxData() is called with ID 1U.
    05: CanTp should transmit the FF by calling CanIf_Transmit().
    06: Start reception of FF by calling CanTp_RxIndication().
    07: Check that CanIf_Transmit() was not called for FC.
    08: Elapse few CanTp_MainFunction() to trigger a N_As timeout.
    09: Handle timeout by checking that PduR was called with E_NOT_OK parameter.
    10: Check that the postponed FC was sent.
    11: Confirm FC transmission.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.SameTxNpduFCandData_transmit_FF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>763</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00310</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>209</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1480</internalId></specobject>
    <specobject>
      <id>TS_CANTP_CF_Transmission_Pending_FC</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_SameTxIDs/source/application/Tests.c.m4</sourcefile>
      <sourceline>594</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    If a CF was sent on a Tx Npdu referencing the same CanIf Npdu as a Tx FcNpdu, the CanIf shall postpone the
    transmission of the FC (of an ongoing segmented reception) until the CF transmission is confirmed.
  
Test Object: 
    Shared Tx NPdu is handled successfully in both reception and transmission serialized by TxConfirmation.
  
Test Precondition: 
  
Test Execution: 
    01: Call CanTp_Transmit() for CanTpTxSduId 1U to start transmission of a FF.
    02: Call CanTp_MainFunction().
    03: Verify that PduR_CanTpCopyTxData() is called with ID 1U.
    04: CanTp should transmit the FF by calling CanIf_Transmit().
    05: Confirm FF transmission.
    06: Start reception of a FC by calling CanTp_RxIndication().
    07: Check whether PduR_CanTpCopyTxData() is called with SduLength 7 for 1st CF.
    08: Check that CanIf_Transmit() is called for CF.
    09: Start reception of FF by calling CanTp_RxIndication().
    10: Check that CanIf_Transmit() was not called for FC.
    11: Confirm CF transmission.
    12: Check that CF confirmation has triggered FC transmission.
    13: Confirm FC transmission.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.SameTxNpduFCandData_transmit_CF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>764</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00086</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>203</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1481</internalId></specobject>
    <specobject>
      <id>TS_CANTP_CF_Transmission_Timeout_Pending_FC</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_SameTxIDs/source/application/Tests.c.m4</sourcefile>
      <sourceline>742</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    If a CF was sent on a Tx Npdu referencing the same CanIf Npdu as a Tx FcNpdu, the CanIf shall postpone the
    transmission of the FC (of an ongoing segmented reception) until the CF timeout occurs.
  
Test Object: 
    Shared Tx NPdu is handled successfully in both reception and transmission serialized by TxConfirmation.
  
Test Precondition: 
  
Test Execution: 
    01: Call CanTp_Transmit() for CanTpTxSduId 1U to start transmission of a FF.
    02: Call CanTp_MainFunction().
    03: Verify that PduR_CanTpCopyTxData() is called with ID 1U.
    04: CanTp should transmit the FF by calling CanIf_Transmit().
    05: Confirm FF transmission.
    06: Start reception of a FC by calling CanTp_RxIndication().
    07: Check whether PduR_CanTpCopyTxData() is called with SduLength 7 for 1st CF.
    08: Check that CanIf_Transmit() is called for CF.
    09: Start reception of FF by calling CanTp_RxIndication.
    10: Check that CanIf_Transmit() was not called for FC.
    11: Elapse few CanTp_MainFunction() to trigger a N_As timeout.
    12: Handle timeout by checking that PduR was called with E_NOT_OK parameter.
    13: Check that the postponed FC was sent.
    14: Confirm FC transmission.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.SameTxNpduFCandData_transmit_CF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>764</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00310</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>209</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1482</internalId></specobject>
    <specobject>
      <id>TS_CANTP_FC_Transmission_Pending_SF</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_SameTxIDs/source/application/Tests.c.m4</sourcefile>
      <sourceline>899</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    In case of an ongoing FC transmission (multiframe reception), if a SF transmission was triggered (via CanTp_Transmit())
    using the same PDU ref (see req CanTp.EB.SameTxNpduFCandData_CONFIG), the SF should be postponed until the FC transmission is confirmed.
  
Test Object: 
    Shared Tx NPdu is handled successfully in both reception and transmission serialized by TxConfirmation.
  
Test Precondition: 
  
Test Execution: 
    01: Start reception of a FF by calling CanTp_RxIndication().
    02: Check that CanIf_Transmit() was called for FC.
    03: Call CanTp_Transmit() for CanTpTxSduId 1U to start transmission of a SF.
    04: Call CanTp_MainFunction().
    05: Verify that PduR_CanTpCopyTxData() is called with ID 1U.
    06: Check that CanIf_Transmit() was not called for SF.
    07: Confirm FC transmission.
    08: CanTp should transmit the SF by calling CanIf_Transmit().
    09: Confirm SF transmission.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.SameTxNpduFCandData_transmit_FC_SF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>765</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00224</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>175</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1483</internalId></specobject>
    <specobject>
      <id>TS_CANTP_FC_Transmission_Pending_FF</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_SameTxIDs/source/application/Tests.c.m4</sourcefile>
      <sourceline>1018</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    In case of an ongoing FC transmission (multiframe reception), if a FF transmission was triggered (via CanTp_Transmit())
    using the same PDU ref (see req CanTp.EB.SameTxNpduFCandData_CONFIG), the FF should be postponed until the FC transmission is confirmed.
  
Test Object: 
    Shared Tx NPdu is handled successfully in both reception and transmission serialized by TxConfirmation.
  
Test Precondition: 
  
Test Execution: 
    01: Start reception of a FF by calling CanTp_RxIndication().
    02: Check that CanIf_Transmit() was called for FC.
    03: Call CanTp_Transmit() for CanTpTxSduId 1U to start transmission of a FF.
    04: Call CanTp_MainFunction().
    05: Verify that PduR_CanTpCopyTxData() is called with ID 1U.
    06: Check that CanIf_Transmit() was not called for FF.
    07: Confirm FC transmission.
    08: CanTp should transmit the FF by calling CanIf_Transmit().
    09: Confirm FF transmission.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.SameTxNpduFCandData_transmit_FC_FF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>766</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00224</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>175</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1484</internalId></specobject>
    <specobject>
      <id>TS_CANTP_FC_Transmission_Pending_CF</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_SameTxIDs/source/application/Tests.c.m4</sourcefile>
      <sourceline>1135</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    In case of an ongoing FC transmission (multiframe reception), if a CF transmission was triggered using the same PDU ref
    (see req CanTp.EB.SameTxNpduFCandData_CONFIG), the CF should be postponed until the FC transmission is confirmed.
  
Test Object: 
    Shared Tx NPdu is handled successfully in both reception and transmission serialized by TxConfirmation.
  
Test Precondition: 
  
Test Execution: 
    01: Call CanTp_Transmit() for CanTpTxSduId 1U to start transmission of a FF.
    02: Call CanTp_MainFunction().
    03: Verify that PduR_CanTpCopyTxData() is called with ID 1U.
    04: CanTp should transmit the FF by calling CanIf_Transmit().
    05: Confirm FF transmission.
    06: Start reception of FF by calling CanTp_RxIndication().
    07: Check that FF reception triggered a FC transmission.
    08: Start reception of a FC by calling CanTp_RxIndication().
    09: Check that CanIf_Transmit() was not called for CF.
    10: Confirm FC transmission.
    11: Transmit postponed CF.
    12: Confirm CF transmission.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.SameTxNpduFCandData_transmit_FC_CF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>767</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00224</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>175</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1485</internalId></specobject>
    <specobject>
      <id>TS_CANTP_FC_Transmission_Timeout_Pending_SF</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_SameTxIDs/source/application/Tests.c.m4</sourcefile>
      <sourceline>1279</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    In case of an ongoing FC transmission (multiframe reception), if a SF transmission was triggered (via CanTp_Transmit())
    using the same PDU ref (see req CanTp.EB.SameTxNpduFCandData_CONFIG), the SF should be postponed until the FC timeout occurs.
  
Test Object: 
    Shared Tx NPdu is handled successfully in both reception and transmission serialized by TxConfirmation.
  
Test Precondition: 
  
Test Execution: 
    01: Start reception of FF by calling CanTp_RxIndication().
    02: Check that CanIf_Transmit() was called for FC.
    03: Call CanTp_Transmit() for CanTpTxSduId 1U to start transmission of a SF.
    04: Call CanTp_MainFunction().
    05: Verify that PduR_CanTpCopyTxData() is called with ID 1U.
    06: Check that CanIf_Transmit() was not called for SF.
    07: Elapse few CanTp_MainFunction() to trigger a N_Ar timeout.
    08: Handle timeout by checking that PduR was called with E_NOT_OK parameter.
    09: CanTp should transmit the SF by calling CanIf_Transmit().
    10: Confirm SF transmission.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.SameTxNpduFCandData_transmit_FC_SF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>765</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00311</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>174</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1486</internalId></specobject>
    <specobject>
      <id>TS_CANTP_FC_Transmission_Timeout_Pending_FF</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_SameTxIDs/source/application/Tests.c.m4</sourcefile>
      <sourceline>1406</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    In case of an ongoing FC transmission (multiframe reception), if a FF transmission was triggered (via CanTp_Transmit())
    using the same PDU ref (see req CanTp.EB.SameTxNpduFCandData_CONFIG), the FF should be postponed until the FC timeout occurs.
  
Test Object: 
    Shared Tx NPdu is handled successfully in both reception and transmission serialized by TxConfirmation.
  
Test Precondition: 
  
Test Execution: 
    01: Start reception of FF by calling CanTp_RxIndication().
    02: Check that CanIf_Transmit() was called for FC.
    03: Call CanTp_Transmit() for CanTpTxSduId 1U to start transmission of a FF.
    04: Call CanTp_MainFunction().
    05: Verify that PduR_CanTpCopyTxData() is called with ID 1U.
    06: Check that CanIf_Transmit() was not called for FF.
    07: Elapse few CanTp_MainFunction() to trigger a N_Ar timeout.
    08: Handle timeout by checking that PduR was called with E_NOT_OK parameter.
    09: CanTp should transmit the FF by calling CanIf_Transmit().
    10: Confirm FF transmission.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.SameTxNpduFCandData_transmit_FC_FF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>766</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00311</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>174</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1487</internalId></specobject>
    <specobject>
      <id>TS_CANTP_FC_Transmission_Timeout_Pending_CF</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_SameTxIDs/source/application/Tests.c.m4</sourcefile>
      <sourceline>1531</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    In case of an ongoing FC transmission (multiframe reception), if a CF transmission was triggered using the same PDU ref
    (see req CanTp.EB.SameTxNpduFCandData_CONFIG), the CF should be postponed until the FC timeout occurs.
  
Test Object: 
    Shared Tx NPdu is handled successfully in both reception and transmission serialized by TxConfirmation.
  
Test Precondition: 
  
Test Execution: 
    01: Call CanTp_Transmit() for CanTpTxSduId 1U to start transmission of a FF.
    02: Call CanTp_MainFunction().
    03: Verify that PduR_CanTpCopyTxData() is called with ID 1U.
    04: CanTp should transmit the FF by calling CanIf_Transmit().
    05: Confirm FF transmission.
    06: Start reception of FF by calling CanTp_RxIndication().
    07: Check that FF reception triggered a FC transmission.
    08: Start reception of a FC by calling CanTp_RxIndication().
    09: Check that CanIf_Transmit() was not called for CF.
    10: Elapse few CanTp_MainFunction() to trigger a N_Ar timeout.
    11: Handle timeout by checking that PduR was called with E_NOT_OK parameter.
    12: Transmit postponed CF.
    13: Confirm CF transmission.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.SameTxNpduFCandData_transmit_FC_CF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>767</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00311</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>174</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1488</internalId></specobject>
    <specobject>
      <id>TS_CANTP_SF_Transmission_Pending_FC_Wait</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_SameTxIDs/source/application/Tests.c.m4</sourcefile>
      <sourceline>1685</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    If a SF was sent (via CanIf_Transmit()) on a Tx Npdu referencing the same CanIf Npdu as a Tx FcNpdu,
    the CanIf shall postpone the transmission of the FC WAIT(of an ongoing segmented reception) until the SF transmission is confirmed.
  
Test Object: 
    Shared Tx NPdu is handled successfully in both reception and transmission serialized by TxConfirmation.
  
Test Precondition: 
  
Test Execution: 
    01: PduR shall not have buffer for reception.
    02: Call CanTp_Transmit() for CanTpTxSduId 0U to start transmission of a SF.
    03: Call CanTp_MainFunction().
    04: Verify PduR_CanTpCopyTxData() is called with ID 1U.
    05: CanTp should transmit the SF by calling CanIf_Transmit().
    06: Start reception of a FF by calling CanTp_RxIndication().
    07: Verify no FC frame is sent.
    08: Elapse few CanTp_MainFunction() in order to let N_Br expire.
    09: Check that FC transmission was not triggered by the expiration of N_Br.
    10: Confirm SF transmission.
    11: Check that SF confirmation has triggered postponed FC transmission.
    12: Confirm FC transmission.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.SameTxNpduFCandData_transmit_SF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>762</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00082_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>22</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1489</internalId></specobject>
    <specobject>
      <id>TS_CANTP_SF_Transmission_Pending_FC_Overflow</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_SameTxIDs/source/application/Tests.c.m4</sourcefile>
      <sourceline>1824</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    If a SF was sent (via CanIf_Transmit()) on a Tx Npdu referencing the same CanIf Npdu as a Tx FcNpdu,
    the CanIf shall postpone the transmission of the FC OVERFLOW(of an ongoing segmented reception) until the SF transmission is confirmed.
  
Test Object: 
    Shared Tx NPdu is handled successfully in both reception and transmission serialized by TxConfirmation.
  
Test Precondition: 
  
Test Execution: 
    01: Prepare PduR_CanTpStartOfReception() to return BUFREQ_E_OVFL.
    02: Call CanTp_Transmit() for CanTpTxSduId 0U to start transmission of a SF.
    03: Call CanTp_MainFunction().
    04: Verify PduR_CanTpCopyTxData() is called with ID 1U.
    05: CanTp should transmit the SF by calling CanIf_Transmit().
    06: Start reception of a FF by calling CanTp_RxIndication().
    07: Check that CanIf_Transmit() was not called for FC.
    08: Confirm SF transmission.
    09: Check that CanIf_Transmit() was called for FC.
    10: Confirm FC transmission.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.SameTxNpduFCandData_transmit_SF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>762</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00318_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>18</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1490</internalId></specobject>
    <specobject>
      <id>TS_CANTP_FC_Wait_Transmission_Pending_SF</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_SameTxIDs/source/application/Tests.c.m4</sourcefile>
      <sourceline>1946</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    In case of an ongoing FC WAIT transmission (multiframe reception), if a SF transmission was triggered (via CanTp_Transmit())
    using the same PDU ref (see req CanTp.EB.SameTxNpduFCandData_CONFIG), the SF should be postponed until the FC WAIT transmission is confirmed.
  
Test Object: 
    Shared Tx NPdu is handled successfully in both reception and transmission serialized by TxConfirmation.
  
Test Precondition: 
  
Test Execution: 
    01: PduR shall not have buffer for reception.
    02: Start reception of a FF by calling CanTp_RxIndication().
    03: Check that CanIf_Transmit() was not called for FC.
    04: Elapse few CanTp_MainFunction() in order to let N_Br expire.
    05: Check that CanIf_Transmit() was called for FC.
    06: Call CanTp_Transmit() for CanTpTxSduId 1U to start transmission of a SF.
    07: Call CanTp_MainFunction().
    08: Verify that PduR_CanTpCopyTxData() is called with ID 1U.
    09: Check that CanIf_Transmit() was not called for SF.
    10: Confirm FC transmission.
    11: CanTp should transmit the SF by calling CanIf_Transmit().
    12: Confirm SF transmission.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.SameTxNpduFCandData_transmit_FC_SF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>765</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00082_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>22</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1491</internalId></specobject>
    <specobject>
      <id>TS_CANTP_FC_Overflow_Transmission_Pending_SF</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_SameTxIDs/source/application/Tests.c.m4</sourcefile>
      <sourceline>2086</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    In case of an ongoing FC WAIT transmission (multiframe reception), if a SF transmission was triggered (via CanTp_Transmit())
    using the same PDU ref (see req CanTp.EB.SameTxNpduFCandData_CONFIG), the SF should be postponed until the FC WAIT transmission is confirmed.
  
Test Object: 
    Shared Tx NPdu is handled successfully in both reception and transmission serialized by TxConfirmation.
  
Test Precondition: 
  
Test Execution: 
    01: Prepare PduR_CanTpStartOfReception() to return BUFREQ_E_OVFL.
    02: Start reception of a FF by calling CanTp_RxIndication().
    03: Check that CanIf_Transmit() was called for FC.
    04: Call CanTp_Transmit() for CanTpTxSduId 1U to start transmission of a SF.
    05: Call CanTp_MainFunction().
    06: Verify that PduR_CanTpCopyTxData() is called with ID 1U.
    07: Check that CanIf_Transmit() was not called for SF.
    08: Confirm FC transmission.
    09: CanTp should transmit the SF by calling CanIf_Transmit().
    10: Confirm SF transmission.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.SameTxNpduFCandData_transmit_FC_SF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>765</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00318_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>18</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1492</internalId></specobject>
    <specobject>
      <id>TS_CANTP_FF_Transmission_Pending_FC_WAIT</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_SameTxIDs/source/application/Tests.c.m4</sourcefile>
      <sourceline>2208</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    If a FF was sent (via CanIf_Transmit()) on a Tx Npdu referencing the same CanIf Npdu as a Tx FcNpdu,
    the CanIf shall postpone the transmission of the FC WAIT(of an ongoing segmented reception) until the FF transmission is confirmed.
  
Test Object: 
    Shared Tx NPdu is handled successfully in both reception and transmission serialized by TxConfirmation.
  
Test Precondition: 
  
Test Execution: 
    01: PduR shall not have buffer for reception.
    02: Call CanTp_Transmit() for CanTpTxSduId 1U to start transmission of a FF.
    03: Call CanTp_MainFunction().
    04: Verify that PduR_CanTpCopyTxData() is called with ID 1U.
    05: CanTp should transmit the FF by calling CanIf_Transmit().
    06: Start reception of FF by calling CanTp_RxIndication().
    07: Check that CanIf_Transmit() was not called for FC.
    08:Elapse few CanTp_MainFunction() in order to let N_Br expire.
    09: Check that FC transmission was not triggered by the expiration of N_Br.
    10: Confirm FF transmission.
    11: Check that FF confirmation has triggered FC transmission.
    12: Confirm FC transmission.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.SameTxNpduFCandData_transmit_FF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>763</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.SameTxNpduFCTransmissionRetry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>769</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00082_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>22</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1493</internalId></specobject>
    <specobject>
      <id>TS_CANTP_FF_Transmission_Pending_FC_OVERFLOW</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_SameTxIDs/source/application/Tests.c.m4</sourcefile>
      <sourceline>2349</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    If a FF was sent (via CanIf_Transmit()) on a Tx Npdu referencing the same CanIf Npdu as a Tx FcNpdu,
    the CanIf shall postpone the transmission of the FC OVERFLOW(of an ongoing segmented reception) until the FF transmission is confirmed.
  
Test Object: 
    Shared Tx NPdu is handled successfully in both reception and transmission serialized by TxConfirmation.
  
Test Precondition: 
  
Test Execution: 
    01: Prepare PduR_CanTpStartOfReception() to return BUFREQ_E_OVFL.
    02: Call CanTp_Transmit() for CanTpTxSduId 1U to start transmission of a FF.
    03: Call CanTp_MainFunction().
    04: Verify that PduR_CanTpCopyTxData() is called with ID 1U.
    05: CanTp should transmit the FF by calling CanIf_Transmit().
    06: Start reception of FF by calling CanTp_RxIndication().
    07: Check that CanIf_Transmit() was not called for FC.
    08: Confirm FF transmission.
    09: Check that FF confirmation has triggered FC transmission
    10: Confirm FC transmission.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.SameTxNpduFCandData_transmit_FF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>763</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00318_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>18</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1494</internalId></specobject>
    <specobject>
      <id>TS_CANTP_CF_Transmission_Pending_FC_WAIT</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_SameTxIDs/source/application/Tests.c.m4</sourcefile>
      <sourceline>2471</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    If a CF was sent on a Tx Npdu referencing the same CanIf Npdu as a Tx FcNpdu, the CanIf shall postpone the
    transmission of the FC WAIT(of an ongoing segmented reception) until the CF transmission is confirmed.
  
Test Object: 
    Shared Tx NPdu is handled successfully in both reception and transmission serialized by TxConfirmation.
  
Test Precondition: 
  
Test Execution: 
    01: PduR shall not have buffer for reception.
    02: Call CanTp_Transmit() for CanTpTxSduId 1U to start transmission of a FF.
    03: Call CanTp_MainFunction().
    04: Verify that PduR_CanTpCopyTxData() is called with ID 1U.
    05: CanTp should transmit the FF by calling CanIf_Transmit().
    06: Confirm FF transmission.
    07: Start reception of a FC by calling CanTp_RxIndication().
    08: Check whether PduR_CanTpCopyTxData() is called with SduLength 7 for 1st CF.
    09: Check that CanIf_Transmit() is called for CF.
    10: Start reception of FF by calling CanTp_RxIndication().
    11: Check that CanIf_Transmit() was not called for FC.
    12: Elapse few CanTp_MainFunction() in order to let N_Br expire.
    13: Check that FC transmission was not triggered by the expiration of N_Br.
    14: Confirm CF transmission.
    15: Check that CF confirmation has triggered FC transmission.
    16: Confirm FC transmission.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.SameTxNpduFCandData_transmit_CF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>764</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.SameTxNpduFCTransmissionRetry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>769</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00082_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>22</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1495</internalId></specobject>
    <specobject>
      <id>TS_CANTP_CF_Transmission_Pending_FC_OVERFLOW</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_SameTxIDs/source/application/Tests.c.m4</sourcefile>
      <sourceline>2641</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    If a CF was sent on a Tx Npdu referencing the same CanIf Npdu as a Tx FcNpdu, the CanIf shall postpone the
    transmission of the FC OVERFLOW(of an ongoing segmented reception) until the CF transmission is confirmed.
  
Test Object: 
    Shared Tx NPdu is handled successfully in both reception and transmission serialized by TxConfirmation.
  
Test Precondition: 
  
Test Execution: 
    01: Prepare PduR_CanTpStartOfReception() to return BUFREQ_E_OVFL.
    02: Call CanTp_Transmit() for CanTpTxSduId 1U to start transmission of a FF.
    03: Call CanTp_MainFunction().
    04: Verify that PduR_CanTpCopyTxData() is called with ID 1U.
    05: CanTp should transmit the FF by calling CanIf_Transmit().
    06: Confirm FF transmission.
    07: Start reception of a FC by calling CanTp_RxIndication().
    08: Check whether PduR_CanTpCopyTxData() is called with SduLength 7 for 1st CF.
    09: Check that CanIf_Transmit() is called for CF.
    10: Start reception of FF by calling CanTp_RxIndication().
    11: Check that CanIf_Transmit() was not called for FC.
    12: Confirm CF transmission.
    13: Check that CF confirmation has triggered FC transmission.
    14: Confirm FC transmission.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.SameTxNpduFCandData_transmit_CF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>764</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00318_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>18</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1496</internalId></specobject>
    <specobject>
      <id>TS_CANTP_CF_Reception_Pending_FC_Transmission</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_SameTxIDs/source/application/Tests.c.m4</sourcefile>
      <sourceline>2792</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    If a CF was received on a Tx Npdu referencing the same CanIf Npdu as a Tx FcNpdu and a FF transmission
    is ongoing, the CanIf shall postpone the transmission of the FC (of an ongoing segmented reception) until the FF
    transmission is confirmed.
  
Test Object: 
    Shared Tx NPdu is handled successfully in both reception and transmission serialized by TxConfirmation.
  
Test Precondition: 
  
Test Execution: 
    01: Start reception of FF by calling CanTp_RxIndication().
    02: Check that FF reception has triggered FC transmission.
    03: Confirm FC transmission.
    04: Call CanTp_Transmit() for CanTpTxSduId 1U to start transmission of a FF.
    05: Call CanTp_MainFunction().
    06: Verify that PduR_CanTpCopyTxData() is called with ID 1U.
    07: CanTp should transmit the FF by calling CanIf_Transmit().
    08: Simulate reception of a CF with SN 1 with SduLength 8.
    09: Start reception of CF by calling CanTp_RxIndication().
    10: check that CanIf_Transmit() was not called for FC.
    11: Confirm FF transmission.
    12: Check that FF confirmation has triggered FC transmission.
    13: Confirm FC transmission.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.SameTxNpduFCandData_transmit_FF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>763</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00312_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>181</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1497</internalId></specobject>
    <specobject>
      <id>TS_CANTP_SF_Transmission_Pending_FC_Wait_Timeout</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_SameTxIDs/source/application/Tests.c.m4</sourcefile>
      <sourceline>2949</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    In case of N_Ar timeout occurrence (no FC frame sent due to ongoing SF/FF/CF transmission on the same N-Pdu) the CanTp module shall
    abort reception and notify the upper layer of this failure by calling the indication function PduR_CanTpRxIndication()
    with the result E_NOT_OK.
  
Test Object: 
    Shared Tx NPdu is handled successfully in both reception and transmission serialized by TxConfirmation.
  
Test Precondition: 
  
Test Execution: 
    01: PduR shall not have buffer for reception.
    02: Call CanTp_Transmit() for CanTpTxSduId 2U to start transmission of a SF.
    03: Call CanTp_MainFunction().
    04: Verify PduR_CanTpCopyTxData() is called with ID 2U.
    05: CanTp should transmit the SF by calling CanIf_Transmit().
    06: Start reception of a FF by calling CanTp_RxIndication().
    07: Verify no FC frame is sent.
    08: Elapse few CanTp_MainFunction() in order to let N_Br expire.
    09: Check that FC transmission was not triggered by the expiration of N_Br.
    10: Elapse few CanTp_MainFunction() in order to let N_Ar expire.
    11: Check that reception has been aborted due to N_Ar timeout .
    12: Confirm SF transmission.
    13: Check that SF confirmation has not triggered any transmission.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.SameTxNpduFCTimeout</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>770</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00311</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>174</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1498</internalId></specobject>
    <specobject>
      <id>TS_CANTP_FC_Transmission_Pending_SF_Smaller_NCS</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_SameTxIDs/source/application/Tests.c.m4</sourcefile>
      <sourceline>3091</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    In case of an ongoing FC transmission (multiframe reception), if the time period(N_Cs) of the postponed SF/FF is smaller
    than the remaining time period to transmit the FC, the CanTp will use remaining time of the (N_Ar+N_Br) to send the SF/FF.
  
Test Object: 
    Shared Tx NPdu is handled successfully in both reception and transmission serialized by TxConfirmation.
  
Test Precondition: 
    N_Cs should be smaller than N_Ar.
  
Test Execution: 
    01: Start reception of a FF by calling CanTp_RxIndication().
    02: Check that CanIf_Transmit() was called for FC.
    03: Call CanTp_Transmit() for CanTpTxSduId 1U to start transmission of a SF.
    04: Call CanTp_MainFunction().
    05: Verify that PduR_CanTpCopyTxData() is called with ID 1U.
    06: Check that CanIf_Transmit() was not called for SF.
    07: Confirm FC transmission.
    08: CanTp should transmit the SF by calling CanIf_Transmit().
    09: Confirm SF transmission.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.SameTxNpduUseNCSforDataRetry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>768</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00224</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>175</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1499</internalId></specobject>
    <specobject>
      <id>TS_CANTP_Timeout_FC_Transmission_Nothing_Pending</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_SameTxIDs/source/application/Tests.c.m4</sourcefile>
      <sourceline>3211</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Timeout of a FC transmission.
  
Test Object: 
    Shared Tx NPdu is handled successfully in both reception and transmission serialized by TxConfirmation.
  
Test Precondition: 
    CanTpTxFcNPduConfirmationPduId and CanTpTxNPduConfirmationPduId have the same ID
  
Test Execution: 
    01: Start reception of a FF by calling CanTp_RxIndication().
    02: Check that CanIf_Transmit() was called for FC.
    03: Elapse few CanTp_MainFunction() to trigger a N_Ar timeout.
    04: Handle timeout by checking that PduR was called with E_NOT_OK parameter.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.SameTxNpduFCandData_CONFIG</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>761</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00311</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>174</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1500</internalId></specobject>
    <specobject>
      <id>TS_CANTP_Timeout_SF_Transmission_Nothing_Pending</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_SameTxIDs/source/application/Tests.c.m4</sourcefile>
      <sourceline>3293</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Timeout of a SF transmission.
  
Test Object: 
    Shared Tx NPdu is handled successfully in both reception and transmission serialized by TxConfirmation.
  
Test Precondition: 
    CanTpTxFcNPduConfirmationPduId and CanTpTxNPduConfirmationPduId have the same ID
  
Test Execution: 
    01: Call CanTp_Transmit() for CanTpTxSduId 1U to start transmission of a FF.
    02: Call CanTp_MainFunction().
    03: Verify that PduR_CanTpCopyTxData() is called with ID 1U.
    04: CanTp should transmit the FF by calling CanIf_Transmit().
    05: Elapse few CanTp_MainFunction() to trigger a N_As timeout.
    06: Handle timeout by checking that PduR was called with E_NOT_OK parameter.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.SameTxNpduFCandData_CONFIG</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>761</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00310</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>209</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1501</internalId></specobject>
    <specobject>
      <id>TS_CANTP_FF_Reception_FF_Transmission</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_SameTxIDs/source/application/Tests.c.m4</sourcefile>
      <sourceline>3399</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    In case of a multiframe reception, if there is not enough buffer for reception and FC transmission
    is not performed, a FF transmission should be possible since nothing is ongoing.
  
Test Object: 
    Shared Tx NPdu is handled successfully in both reception and transmission serialized by TxConfirmation.
  
Test Precondition: 
  
Test Execution: 
    01: PduR shall not have buffer for reception.
    02: Start reception of FF by calling CanTp_RxIndication().
    03: Check that CanIf_Transmit() was not called for FC.
    04: Call CanTp_Transmit() for CanTpTxSduId 1U to start transmission of a FF.
    05: Call CanTp_MainFunction().
    06: Verify PduR_CanTpCopyTxData() is called with ID 1U.
    07: CanTp should transmit the FF by calling CanIf_Transmit().
    08: PduR now shall have the necessary buffer.
    09: Confirm FF transmission.
    10: Check that FF confirmation has triggered FC transmission.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.SameTxNpduFCandData_transmit_FF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>763</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00224</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>175</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1502</internalId></specobject>
    <specobject>
      <id>TS_CANTP_CF_Reception_FF_Transmission</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_SameTxIDs/source/application/Tests.c.m4</sourcefile>
      <sourceline>3537</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    In case of a multiframe reception, if there is not enough buffer for reception and FC transmission
    is not performed, a SF transmission should be possible since nothing is ongoing.
  
Test Object: 
    Shared Tx NPdu is handled successfully in both reception and transmission serialized by TxConfirmation.
  
Test Precondition: 
  
Test Execution: 
    01: Start reception of a FF by calling CanTp_RxIndication().
    02: Check that CanIf_Transmit() was called for FC.
    03: Call CanTp_Transmit() for CanTpTxSduId 1U to start transmission of a SF.
    04: Confirm FC transmission.
    05: PduR shall not have buffer for reception.
    06: Check that CanIf_Transmit() was not called for FC.
    07: Call CanTp_MainFunction().
    08: Verify PduR_CanTpCopyTxData() is called with ID 1U.
    09: CanTp should transmit the SF by calling CanIf_Transmit().
    10: PduR now shall have the necessary buffer.
    11: Confirm SF transmission.
    12: Check that SF confirmation has triggered FC transmission.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.SameTxNpduFCandData_transmit_FC_SF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>765</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00224</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>175</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1503</internalId></specobject>
    <specobject>
      <id>TS_CANTP_FF_Transmission_RxCancellation</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_SameTxIDs/source/application/Tests.c.m4</sourcefile>
      <sourceline>3699</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    If a FF was sent (via CanIf_Transmit()) on a Tx Npdu referencing the same CanIf Npdu as a Tx FcNpdu,
    the CanIf shall postpone the transmission of the FC (of an ongoing segmented reception) until the FF transmission is confirmed.
    If CanTp_CancelReceive() is called before FF transmit confirmation, the reception should be aborted (postponed FC is not sent).
  
Test Object: 
    Shared Tx NPdu is handled successfully in both reception and transmission serialized by TxConfirmation.
  
Test Precondition: 
  
Test Execution: 
    01: Call CanTp_Transmit() for CanTpTxSduId 1U to start transmission of a FF.
    02: Call CanTp_MainFunction().
    03: Verify that PduR_CanTpCopyTxData() is called with ID 1U.
    04: CanTp should transmit the FF by calling CanIf_Transmit().
    05: Start reception of FF by calling CanTp_RxIndication().
    06: Check that CanIf_Transmit() was not called for FC.
    07: Call CanTp_CancelReceive() and check that it is canceling reception by returning E_OK.
    08: Confirm FF transmission.
    09: Check that FF confirmation has not triggered postponed FC transmission.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.SameTxNpduFCandData_transmit_FF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>763</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00261</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>373</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1504</internalId></specobject>
    <specobject>
      <id>TS_CANTP_FC_Transmission_TxCancellation</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_SameTxIDs/source/application/Tests.c.m4</sourcefile>
      <sourceline>3815</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    In case of an ongoing FC transmission (multiframe reception), if a FF transmission was triggered (via CanTp_Transmit())
    using the same PDU ref (see req CanTp.EB.SameTxNpduFCandData_CONFIG), the FF should be postponed until the FC transmission is confirmed.
    If CanTp_CancelTransmit() is called before FC transmit confirmation, the transmission should be aborted (postponed FF is not sent).
  
Test Object: 
    Shared Tx NPdu is handled successfully in both reception and transmission serialized by TxConfirmation.
  
Test Precondition: 
  
Test Execution: 
    01: Start reception of a FF by calling CanTp_RxIndication().
    02: Check that CanIf_Transmit() was called for FC.
    03: Call CanTp_Transmit() for CanTpTxSduId 1U to start transmission of a FF.
    04: Call CanTp_MainFunction().
    05: Verify that PduR_CanTpCopyTxData() is called with ID 1U.
    06: Check that CanIf_Transmit() was not called for FF.
    07: Call CanTp_CancelTransmit() and check that it returns E_OK and the postponed FF cancelled.
    08: Confirm FC transmission.
    09: Check that FC confirmation has not triggered transmission of postponed FF.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.SameTxNpduFCandData_transmit_FC_FF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>766</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00243</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>146</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1505</internalId></specobject>
    <specobject>
      <id>TS_CANTP_ParallelChannels_FF_Reception</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_SameTxIDs/source/application/Tests.c.m4</sourcefile>
      <sourceline>3928</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    In case of parallel chanels enabled and a reception is initiated, if there is not enough buffer,
    the FC transmission that should be triggered after the FF reception should not be performed 
    until the buffer becomes available.
  
Test Object: 
  
Test Precondition: 
  
Test Execution: 
    01: PduR shall not have buffer for reception.
    02: Start reception of FF by calling CanTp_RxIndication().
    03: Check that CanIf_Transmit() was not called for FC.
    04: 04: PduR now shall have the necessary buffer.
    05: Check that FF reception has triggered FC transmission.
    06: Confirm FC transmission.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00224</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>175</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1506</internalId></specobject>
    <specobject>
      <id>TS_CANTP_ParallelChannels_CF_Reception</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_SameTxIDs/source/application/Tests.c.m4</sourcefile>
      <sourceline>4018</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    In case of parallel chanels enabled and a reception is initiated, if there is not enough buffer,
    the FC transmission that should be triggered after the last CF reception of a block should not be
    performed until the buffer becomes available.
  
Test Object: 
  
Test Precondition: 
  
Test Execution: 
    01: Start reception of a FF by calling CanTp_RxIndication().
    02: Check that CanIf_Transmit() was called for FC.
    03: Call CanTp_Transmit() for CanTpTxSduId 1U to start transmission of a SF.
    04: Confirm FC transmission.
    05: PduR shall not have buffer for CF reception.
    06: Check that CanIf_Transmit() was not called for FC.
    07: Call CanTp_MainFunction().
    08: PduR now shall have the necessary buffer.
    09: Check that CF reception has triggered FC transmission.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00224</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>175</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00269_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>177</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1507</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>CanTp_Conf_SetGetNSa001_SameNPdu</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_SetGetNSa/source/application/CanTp_ConTest_SetGetNSa.c</sourcefile>
      <sourceline>55</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test shall verify for Rx N-SDUs and Tx N-SDUs with extended addressing and pointing to the
    same RX N-PDU, that CanTp_SetNSa() sets the N_SA value and CanTp_GetNSa() returns the set N_SA
    value independent of the circumstance that all point to the same RX N-PDU.
  
Test Object: 
    Dynamic N_SA handling
  
Test Precondition: 
    CanTp is initialized.
    Configuration: 2 RX N-SDUs with extended addressing pointing to the same RX N-PDU.
                   1 TX N-SDU with extended addressing and FC pointing to the same RX N-PDU. 
  
Test Execution: 
    01: Call CanTp_SetNSa() to set the N_SA for all N-SDUs.
    02: VP(CanTp.EB.SetNSa_Success): CanTp_SetNSa() returns E_OK.
    03: Call CanTp_GetNSa() for all N-SDUs.
    04: VP(CanTp.EB.GetNSa_Success): CanTp_GetNSa() returns E_OK and the new N_SA value.
  
Test Input:   
  
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.SetNSa_Success</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>567</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.GetNSa_Success</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>576</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1508</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_30456</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_SetGetNSa/source/application/Tst_30456.c</sourcefile>
      <sourceline>59</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that for extended addressing N-SDUs CanTp_SetNSa() correctly writes a new N_SA and
    CanTp_GetNSa() returns the currently configured N_SA.
  
Test Object: 
    Dynamic N_SA handling
  
Test Precondition: 
    CanTp is initialized.
  
Test Execution: 
    01: Call CanTp_GetNSa() for a configured transmit NSdu.
    02: VP(CanTp.EB.GetNSa_Success):
        CanTp_GetNSa() should return E_OK and N_SA as 0xEBU.
    03: Call CanTp_SetNSa() for the same Nsdu to change the N_SA value to 0x55U.
    04: VP(CanTp.EB.SetNSa_Success):
        CanTp_SetNSa() should return E_OK.
    05: Call CanTp_GetNSa() for the same transmit NSdu.
    06: VP(CanTp.EB.GetNSa_Success):
        CanTp_GetNSa() should return E_OK and N_SA as 0x55U.
    07: Repeat the steps from 01 to 06 for a configured receive NSdu.
    08: Repeat steps from 03 to 06 for the same receive NSdu to restore the N_SA value
        to 0xEBU.
    09: Repeat steps from 03 to 06 for the same transmit NSdu to restore the N_SA value
        to 0xEBU.
    10: No error should be reported.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.SetNSa_Success</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>567</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.GetNSa_Success</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>576</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1509</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_30457</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_SetGetNSa/source/application/Tst_30457.c</sourcefile>
      <sourceline>57</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    CanTp_GetNSa() reports the development error CANTP_E_INVALID_RX_ID if it is called for a
    standard or mixed addressing Rx N-SDU.
    CanTp_GetNSa() reports the development error CANTP_E_INVALID_TX_ID if it is called for a
    standard or mixed addressing Tx N-SDU.
  
Test Object: 
    CanTp_GetNSa()
  
Test Precondition: 
    CanTp is initialized.
  
Test Execution: 
    01. Call CanTp_GetNSa() for N-SDU CanTpRxNSdu_0.
    02: VP(CanTp.EB.GetNSa_RxNotExtendedAddr):
        CanTp_GetNSa() should return E_NOT_OK and should report the Det error CANTP_E_INVALID_RX_ID.
    03. Call CanTp_GetNSa() for N-SDU CanTpRxNSdu_2.
    04: VP(CanTp.EB.GetNSa_RxNotExtendedAddr):
        CanTp_GetNSa() should return E_NOT_OK and should report the Det error CANTP_E_INVALID_RX_ID.
    05. Call CanTp_GetNSa() for N-SDU CanTpTxNSdu_0.
    06: VP(CanTp.EB.GetNSa_TxNotExtendedAddr):
        CanTp_GetNSa() should return E_NOT_OK and should report the Det error CANTP_E_INVALID_TX_ID.
    07. Call CanTp_GetNSa() for N-SDU CanTpTxNSdu_2.
    08: VP(CanTp.EB.GetNSa_TxNotExtendedAddr):
        CanTp_GetNSa() should return E_NOT_OK and should report the Det error CANTP_E_INVALID_TX_ID.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.GetNSa_TxNotExtendedAddr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>583</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.GetNSa_RxNotExtendedAddr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>582</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1510</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_30458</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_SetGetNSa/source/application/Tst_30458.c</sourcefile>
      <sourceline>56</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    CanTp_SetNSa() reports the development error CANTP_E_INVALID_RX_ID if it is called for a
    standard or mixed addressing Rx N-SDU.
    CanTp_SetNSa() reports the development error CANTP_E_INVALID_TX_ID if it is called for a
    standard or mixed addressing Tx N-SDU.
  
Test Object: 
    CanTp_SetNSa()
  
Test Precondition: 
    CanTp is initialized.
  
Test Execution: 
    01. Call CanTp_SetNSa() for N-SDU CanTpRxNSdu_0.
    02. VP(CanTp.EB.SetNSa_RxNotExtendedAddr):
        CanTp_SetNSa() should return E_NOT_OK and report the development error
        CANTP_E_INVALID_RX_ID.
    03. Call CanTp_SetNSa() for N-SDU CanTpRxNSdu_2.
    04. VP(CanTp.EB.SetNSa_RxNotExtendedAddr):
        CanTp_SetNSa() should return E_NOT_OK and report the development error
        CANTP_E_INVALID_RX_ID.
    05. Call CanTp_SetNSa() for N-SDU CanTpTxNSdu_0.
    06. VP(CanTp.EB.SetNSa_TxNotExtendedAddr):
        CanTp_SetNSa() should return E_NOT_OK and report the development error
        CANTP_E_INVALID_TX_ID.
    07. Call CanTp_SetNSa() for N-SDU CanTpTxNSdu_2.
    08. VP(CanTp.EB.SetNSa_TxNotExtendedAddr):
        CanTp_SetNSa() should return E_NOT_OK and report the development error
        CANTP_E_INVALID_TX_ID.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.SetNSa_TxNotExtendedAddr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>573</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.SetNSa_RxNotExtendedAddr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>572</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1511</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_30459</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_SetGetNSa/source/application/Tst_30459.c</sourcefile>
      <sourceline>56</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The N_SA of extended addressing N-SDUs is correctly set after initialization to the
    configured value. This value is used when receiving messages.
  
Test Object: 
    Dynamic N_SA handling
  
Test Precondition: 
    CanTp is initialized.
    Configure extended addressing.
    No N_SAs were changed since last initialization.
  
Test Execution: 
    01: VP(CanTp.EB.GetNSa_Success):
        Call CanTp_GetNSa() for CanTpRxNSdu_1 and verify that it returned the configured N_Sa
        as no change of N_Sa occurred after initialization.
    02: Simulate a single frame (SF) reception for N-SDU CanTpRxNSdu_1 with the configured N_SA.
    03: PduR_CanTpRxIndication() should get called indicating successful reception and the
        received data should be written into the buffer provided by PduR_CanTpCopyRxData() and
        no error should be reported.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.GetNSa_Success</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>576</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1512</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_30460</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_SetGetNSa/source/application/Tst_30460.c</sourcefile>
      <sourceline>60</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    CanTp_SetNSa() overwrites the N_SA of an extended addressing N-SDU. After setting a new N_SA,
    this new value is used by the CanTp during message reception.
  
Test Object: 
    Dynamic N_SA handling
  
Test Precondition: 
    CanTp is initialized.
  
Test Execution: 
    01: Call CanTp_SetNSa() to set the N_SA of N-SDU CanTpRxNSdu_1.
    02: VP(CanTp.EB.SetNSa_Success):
        CanTp_SetNSa() should return E_OK.
    03: Simulate a single frame (SF) reception for N-SDU CanTpRxNSdu_1 with the newly set N_SA.
    04: VP():
        PduR_CanTpRxIndication() should be called and the received data should be written into the
        buffer provided by PduR_CanTpCopyRxData().
    05: Restore old N_Sa value.
  
Test Input: 
  
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.SetNSa_Success</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>567</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1513</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_30461</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_SetGetNSa/source/application/Tst_30461.c</sourcefile>
      <sourceline>60</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    CanTp_GetNSa() reports the development error CANTP_E_PARAM_DIRECTION if it is called with an invalid direction parameter.
  
Test Object: 
    CanTp_GetNSa()
  
Test Precondition: 
    CanTp is initialized.
  
Test Execution: 
    01: Call CanTp_GetNSa() with an invalid value for the direction parameter.
    02: VP(CanTp.EB.11575):
        CanTp_GetNSa() should report the development error CANTP_E_PARAM_DIRECTION and 
        return E_NOT_OK.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.11575</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>578</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1514</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_30462</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_SetGetNSa/source/application/Tst_30462.c</sourcefile>
      <sourceline>60</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    CanTp_SetNSa() reports the development error CANTP_E_PARAM_DIRECTION if it is called with an invalid direction parameter.
  
Test Object: 
    CanTp_SetNSa()
  
Test Precondition: 
    CanTp is initialized.
  
Test Execution: 
    01: Call CanTp_SetNSa() with an invalid value for the direction parameter.
    02: VP(CanTp.EB.11570):
        CanTp_SetNSa() should report the development error CANTP_E_PARAM_DIRECTION and 
        return E_NOT_OK.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.11570</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>569</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1515</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_30463</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_SetGetNSa/source/application/Tst_30463.c</sourcefile>
      <sourceline>56</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    CanTp_GetNSa() reports the development error CANTP_E_UNINIT if it is called before the module was initialized.
  
Test Object: 
    CanTp_GetNSa()
  
Test Precondition: 
    CanTp is not initialized.
  
Test Execution: 
    01: Call CanTp_GetNSa() with valid parameters.
    02: VP(CanTp.EB.11574):
        CanTp_GetNSa() reports the development error CANTP_E_UNINIT and returns with E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.11574</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>577</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1516</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_30464</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_SetGetNSa/source/application/Tst_30464.c</sourcefile>
      <sourceline>56</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    CanTp_SetNSa() reports the development error CANTP_E_UNINIT if it is called before the module was initialized.
  
Test Object: 
    CanTp_SetNSa()
  
Test Precondition: 
    CanTp is not initialized.
  
Test Execution: 
    01: Call CanTp_SetNSa() with valid parameters.
    02: VP(CanTp.EB.11569):
        CanTp_SetNSa() reports the development error CANTP_E_UNINIT and returns with E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.11569</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>568</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1517</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_30465</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_SetGetNSa/source/application/Tst_30465.c</sourcefile>
      <sourceline>71</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    CanTp_GetNSa() reports the development error CANTP_E_PARAM_POINTER if it is called with a null pointer .
  
Test Object: 
    CanTp_GetNSa()
  
Test Precondition: 
  
Test Execution: 
    01: Call CanTp_Init().
    02: Call CanTp_GetNSa() with CanTpNSaPtr == TS_NULL.
    03: VP(CanTp.EB.11576):
        CanTp_GetNSa() reports the development error CANTP_E_PARAM_POINTER and returns with E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.11576</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>579</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1518</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_30466</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_SetGetNSa/source/application/Tst_30466.c</sourcefile>
      <sourceline>60</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    CanTp_GetNSa() reports the development error CANTP_E_INVALID_RX_ID if it is called with an invalid N-SDU ID for direction "Rx".
    CanTp_GetNSa() reports the development error CANTP_E_INVALID_TX_ID if it is called with an invalid N-SDU ID for direction "Tx".
  
Test Object: 
    CanTp_GetNSa()
  
Test Precondition: 
    CanTp is initialized.
  
Test Execution: 
    01. Call CanTp_GetNSa() with direction "Rx" and an invalid value for CanTpPduId.
    02: VP(CanTp.EB.11578):
        CanTp_GetNSa() reports the development error CANTP_E_INVALID_RX_ID.
    03. Call CanTp_GetNSa() with direction "Tx" and an invalid value for CanTpPduId.
    04: VP(CanTp.EB.11577):
        CanTp_GetNSa() reports the development error CANTP_E_INVALID_TX_ID.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.11577</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>580</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.11578</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>581</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1519</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_30467</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_SetGetNSa/source/application/Tst_30467.c</sourcefile>
      <sourceline>58</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    CanTp_SetNSa() reports the development error CANTP_E_INVALID_RX_ID if it is called with an
    invalid N-SDU ID for direction "Rx".
    CanTp_SetNSa() reports the development error CANTP_E_INVALID_TX_ID if it is called with an
    invalid N-SDU ID for direction "Tx".
  
Test Object: 
    CanTp_SetNSa()
  
Test Precondition: 
    CanTp is initialized.
  
Test Execution: 
    01. Call CanTp_SetNSa() with direction "Rx" and an invalid value for CanTpPduId.
    02: VP(CanTp.EB.11573):
        CanTp_SetNSa() reports the development error CANTP_E_INVALID_RX_ID.
    03. Call CanTp_SetNSa() with direction "Tx" and an invalid value for CanTpPduId.
    04: VP(CanTp.EB.11571):
        CanTp_SetNSa() reports the development error CANTP_E_INVALID_TX_ID.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.11571</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>570</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.11573</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>571</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1520</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_30487</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_SetGetNSa/source/application/Tst_30487.c</sourcefile>
      <sourceline>83</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    CanTp_SetNSa() overwrites the N_SA of an extended addressing Rx N-SDU. After setting a new N_SA, a correct reception of a segmented message with extended addressing (CanTpRxNSdu_1) is tested.
  
Test Object: 
    Dynamic N_SA handling
  
Test Precondition: 
    CanTp is initialized.
  
Test Execution: 
    01: Call CanTp_SetNSa() to set the N_SA of N-SDU CanTpRxNSdu_1.
    02: VP(CanTp.EB.SetNSa_Success):
        CanTp_SetNSa() should return E_OK.
    03: Call CanTp_RxIndication() with a valid first frame (FF) for CanTpRxNSdu_0.
    04: Flow control (FC) frame should be sent (check BS) after the received first frame (FF).
    05: Call CanTp_RxIndication() several times with valid consecutive frames (CF)
        interleaved with CanTp_MainFunction() until the last CF was correctly received.
    06: VP():
        PduR_CanTpRxIndication() should get called indicating the correct frame reception.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.SetNSa_Success</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>567</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1521</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_30488</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_SetGetNSa/source/application/Tst_30488.c</sourcefile>
      <sourceline>90</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    CanTp_SetNSa() overwrites the N_SA of an extended addressing Tx N-SDU.
    After setting a new N_SA, Transmission of a segmented message with extended addressing
    (CanTpTxNSdu_1) is tested.
  
Test Object: 
    Dynamic N_SA handling
  
Test Precondition: 
    CanTp is initialized.
  
Test Execution: 
    01: Call CanTp_SetNSa() to set the N_SA of N-SDU CanTpTxNSdu_1 for TX-Direction.
    02: VP(CanTp.EB.SetNSa_Success):
        CanTp_SetNSa() should return E_OK.
    03: Call CanTp_Transmit() with the corresponding parameters and CanTp_MainFunction() to start
        the transmission of a segmented message with extended addressing format.
    04: Complete the transmission of rest of the frames
        - Simulate successful message transmission via CanTp_TxConfirmation().
        - Simulate PduR_CanTpCopyTxData() to provide a buffer long enough for a segmented
        transmission.
        - Call CanTp_RxIndication() to provide the initial flow control (FC) frame to the CanTp.
        - Call CanTp_MainFunction() several times including corresponding CanTp_TxConfirmation()
        calls to finish the transmission.
    05: VP():
        PduR_CanTpTxConfirmation() should get called indicating the successful transmission.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.SetNSa_Success</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>567</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1522</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_30489</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_SetGetNSa/source/application/Tst_30489.c</sourcefile>
      <sourceline>58</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    CanTp_SetNSa() overwrites the N_SA of an extended addressing N-SDU. After setting a new N_SA,
    the old value is no longer used by the CanTp during message reception.
    It is checked, that only message reception with the new N_SA will be accepted.
  
Test Object: 
    Dynamic N_SA handling
  
Test Precondition: 
    CanTp is initialized.
  
Test Execution: 
    01: Read configured N_Sa value N_SDU configured in receive direction.
    02: VP(CanTp.EB.GetNSa_Success):
         CanTp_GetNSa() should return E_OK and N_Sa as TST_EXP_NSA.
    03: Simulate SF reception with configured N_SA and check whether the reception is successful.
    04: VP(CanTp.EB.SetNSa_Success):
        Set new N_Sa value for N_SDU configured in receive direction.
    05: Read new N_Sa value of N_SDU configured in receive direction.
    06: VP(CanTp.EB.GetNSa_Success):
        CanTp_GetNSa() should return E_OK and N_Sa as TST_NEW_NSA.
    07: Simulate frame reception with configured N_SA and check whether the reception is not.
        successful(this should fail)
    08: Verify that PduR_CanTpRxIndication and PduR_CanTpCopyRxData are not called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.GetNSa_Success</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>576</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.SetNSa_Success</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>567</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1523</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_SetGetNSa_Functional</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Conformance/IN/CanTp_Conf_SetGetNSa/source/application/Tst_Nsa_Functional.c</sourcefile>
      <sourceline>65</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    CanTp_SetNSa() reports the development error CANTP_E_INVALID_TX_ID if it is called for
    functional addressing.
    CanTp_GetNSa() reports the development error CANTP_E_INVALID_TX_ID if it is called for
    functional addressing.
  
Test Object: 
    Det error reporting when CanTp_SetNSa and CanTp_GetNSa are called for functional addressing
  
Test Precondition: 
    CanTp is initialized.
    Configure functional addressing
  
Test Execution: 
    01. Call CanTp_SetNSa() for CanTpTxNSdu_3 which is configured for functional addressing.
    02. VP(CanTp.EB.SetNSa_TxFunctionalAddr):
        CanTp_SetNSa() should return E_NOT_OK and report the development error CANTP_E_INVALID_TX_ID
    03. Call CanTp_GetNSa() CanTpTxNSdu_3 which is configured for functional addressing.
    04. VP(CanTp.EB.GetNSa_TxFunctionalAddr):
        CanTp_GetNSa() should return E_NOT_OK and report the development error CANTP_E_INVALID_TX_ID
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.SetNSa_TxFunctionalAddr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>574</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.GetNSa_TxFunctionalAddr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>584</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1524</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_Gen_00000_OnlyPbCfg</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_00_OnlyPbCfg/source/application/CanTp_GenTest_00_OnlyPBcfg.h</sourcefile>
      <sourceline>27</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that the CANTP post build configuration also compiles stand alone.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
    * Set TS_BUILD_POST_BUILD_BINARY to TRUE in the merged make file to prevent the compilation
      of all other CANTP C files.
    * Remove all generated CANTP C files except post build files if there are any.

Test Execution: 
    The test run is successful when the CANTP compiles under sticking to the precondition and a
    binary file is generated.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.PostBuild_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>968</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1525</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_GenTest_01001_Err_TxNPduId_NotUnique_Standard</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_01_InvalidConfiguration/source/application/CanTp_GenTest_01_InvalidConfiguration.h</sourcefile>
      <sourceline>27</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test checks that the generator issues an error in case the same Tx N-PDU Id is used on more
  than one Tx N-PDU with standard addressing.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00248_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>31</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1526</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01002_Err_RxNPduId_NotUnique_Standard</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_01_InvalidConfiguration/source/application/CanTp_GenTest_01_InvalidConfiguration.h</sourcefile>
      <sourceline>49</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test checks that the generator issues an error in case the same Rx N-PDU Id is used on more
  than one Rx N-PDU with standard addressing.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00248_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>32</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1527</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01003_Err_CanTpTxNPduRef_NotUnique_Standard</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_01_InvalidConfiguration/source/application/CanTp_GenTest_01_InvalidConfiguration.h</sourcefile>
      <sourceline>71</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test checks that the generator issues an error in case the more than one TpTxNPduRef refers
  the same PDU in standard addressing.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00035</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1528</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01004_Err_CanTpRxFcNPduId_Same_CanTpNAe_Same_Mixed</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_01_InvalidConfiguration/source/application/CanTp_GenTest_01_InvalidConfiguration.h</sourcefile>
      <sourceline>93</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test checks that it is not possible to configure two Tx NSduIds using FC frames with mixed
  addressing format and with same RxFcNPduIds and same N_AE pointing to the same CanIf LSdu and
  in case generator issues an error.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00094</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>232</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1529</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01005_Err_CanTpRxFcNPduId_Differ_CanTpNAe_Same_Mixed</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_01_InvalidConfiguration/source/application/CanTp_GenTest_01_InvalidConfiguration.h</sourcefile>
      <sourceline>116</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test check that it is not possible to configure two Tx NSduIds using FC frames with mixed
  addressing format and with different RxFcNPduIds and same N_AE pointing to the same CanIf LSdu and
  in case generator issues an error.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00094</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>232</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1530</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01006_Err_CanTpRxFcNPduId_Same_CanTpNSa_Same_Extended</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_01_InvalidConfiguration/source/application/CanTp_GenTest_01_InvalidConfiguration.h</sourcefile>
      <sourceline>139</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test checks that it is not possible to configure two Tx NSduIds using FC frames with extended
  addressing format and with same RxFcNPduIds and same N_Sa pointing to the same CanIf LSdu and
  in case generator issues an error.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00094</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>232</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1531</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01007_Err_CanTpRxFcNPduId_Differ_CanTpNSa_Same_Extended</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_01_InvalidConfiguration/source/application/CanTp_GenTest_01_InvalidConfiguration.h</sourcefile>
      <sourceline>162</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test checks that it is not possible to configure two Tx NSduIds using FC frames with extended
  addressing format and with different RxFcNPduIds and same N_Sa pointing to the same CanIf LSdu and
  in case generator issues an error.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00094</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>232</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1532</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01008_Err_CanTpTxFcNPduRef_Same_CanTpNAe_Same_Mixed</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_01_InvalidConfiguration/source/application/CanTp_GenTest_01_InvalidConfiguration.h</sourcefile>
      <sourceline>185</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test checks that it is not possible to configure two Rx NSduIds using FC frames with mixed
  addressing format pointing to the same CanIf LSdu and in case generator issues an error.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00094</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>232</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1533</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01009_Err_CanTpTxFcNPduRef_Same_CanTpNTa_Same_Extended</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_01_InvalidConfiguration/source/application/CanTp_GenTest_01_InvalidConfiguration.h</sourcefile>
      <sourceline>207</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test checks that it is not possible to configure two Rx NSduIds using FC frames with extended
  addressing format and pointing to the same CanIf LSdu and in case generator issues an error.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00094</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>232</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1534</internalId></specobject>
    <specobject>
      <id>CanTp_GenTest_01010_Xdm_RxNSduRef_MaxPduLength</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_01_InvalidConfiguration/source/application/CanTp_GenTest_01_InvalidConfiguration.h</sourcefile>
      <sourceline>229</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if CanTpRxNSduRef refers to a PDU with configured length greater than
  65535, the generator will issue an error.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.Xdm.RxNSduRef.MaxPduLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>710</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1535</internalId></specobject>
    <specobject>
      <id>CanTp_GenTest_01011_Xdm_TxNSduRef_MaxPduLength</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_01_InvalidConfiguration/source/application/CanTp_GenTest_01_InvalidConfiguration.h</sourcefile>
      <sourceline>251</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if CanTpTxNSduRef refers to a PDU with configured length greater than
  65535, the generator will issue an error.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.Xdm.TxNSduRef.MaxPduLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>711</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1536</internalId></specobject>
    <specobject>
      <id>CanTp_GenTest_01012_Err_TxNPduRef_TxFcNpduRef</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_01_InvalidConfiguration/source/application/CanTp_GenTest_01_InvalidConfiguration.h</sourcefile>
      <sourceline>273</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if CanTpTxNPduRef and CanTpTxFcNPduRef refers to to the same EcuC Pdu,
  if they doesn't have the same ID's, the generator will issue 2 errors.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.SameTxNpduFCandData_CONFIG</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>761</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1537</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01001_Err_CANTP_NORMALFIXED_CanTpDynIdSupportOFF</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_01_InvalidConfiguration/source/application/CanTp_GenTest_01_InvalidConfiguration.h</sourcefile>
      <sourceline>295</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test checks that configuration generates a error if CanTpDynIdSupport is disabled and
  CanTpRxAddressingFormat is CANTP_NORMALFIXED
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ECUC_CanTp_00302</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>422</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1538</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01001_Err_CANTP_NORMALFIXED_EcuC_Ref</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_01_InvalidConfiguration/source/application/CanTp_GenTest_01_InvalidConfiguration.h</sourcefile>
      <sourceline>317</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test checks that configuration generates a error if EcuC PDU doesn't have a
  MetaDataTypeRef for CanTpRxNsdu and CanTpTxNpdu.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MetaData.NSduMetaDataTypeRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>790</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.NPduMetaDataTypeRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>791</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1539</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01001_Err_CANTP_NORMALFIXED_CanIf_InvalidMask</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_01_InvalidConfiguration/source/application/CanTp_GenTest_01_InvalidConfiguration.h</sourcefile>
      <sourceline>340</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test checks that configuration generates a error at generation if CanIfTxPduCanIdMask
  last 4 bits are different than E000.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.InvalidCanIdMask</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>792</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1540</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01001_Err_CANTP_NORMALFIXED_INVALID_METADATA_ITEMTYPE</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_01_InvalidConfiguration/source/application/CanTp_GenTest_01_InvalidConfiguration.h</sourcefile>
      <sourceline>362</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test checks that configuration generates a error if EcuC PDU doesn't have a
  MetaDataType reference at CAN_ID_32 for the Pdus referring CanIf, SOURCE_ADDRESS_16
  and TARGET_ADDRESS_16 for Pdus referring PDUR.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MetaData.NSduMetaDataTypeRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>790</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.MetaData.NPduMetaDataTypeRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>791</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1541</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01017_Err_PduRDestPduHandleId_Non_Existing</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_01_InvalidConfiguration/source/application/CanTp_GenTest_01_InvalidConfiguration.h</sourcefile>
      <sourceline>386</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test checks that configuration generates a error if EcuC PDU referenced by CanTpTxNSduRef
  is not referenced in PduR, thus PduRDestPduHandleId is unavailable.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00216_5_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>406</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1542</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>CanTp_GenTest_01001_MCG_CanIdType_INV_00</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_01_InvalidConfiguration_CANFD_RX_EXTENDED_CanIdType/source/application/CanTp_GenTest_01_InvalidConfiguration_CANFD_RX_EXTENDED_CanIdType.h</sourcefile>
      <sourceline>29</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if CanTpRxNPduRef refers a PDU with configured length
  greater than 8 and CanIdType is EXTENDED_NO_FD_CAN, then an error shall be generated.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MCG.CanFd.RX.EXTENDED.CanIdType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>716</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1543</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>CanTp_GenTest_01002_MCG_CanIdType_INV_00</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_01_InvalidConfiguration_CANFD_RX_STANDARD_CanIdType/source/application/CanTp_GenTest_01_InvalidConfiguration_CANFD_RX_STANDARD_CanIdType.h</sourcefile>
      <sourceline>28</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if CanTpRxNPduRef refers a PDU with configured length
  greater than 8 and CanIdType is STANDARD_CAN, then an error shall be generated.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MCG.CanFd.RX.STANDARD.CanIdType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>717</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1544</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>CanTp_GenTest_01003_MCG_CanIdType_INV_00</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_01_InvalidConfiguration_CANFD_TX_EXTENDED_CanIdType/source/application/CanTp_GenTest_01_InvalidConfiguration_CANFD_TX_EXTENDED_CanIdType.h</sourcefile>
      <sourceline>28</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if CanTpTxNPduRef refers a PDU with configured length
  greater than 8 and CanIdType is EXTENDED_CAN, then an error shall be generated.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MCG.CanFd.TX.EXTENDED.CanIdType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>718</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1545</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>CanTp_GenTest_01004_MCG_CanIdType_INV_00</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_01_InvalidConfiguration_CANFD_TX_STANDARD_CanIdType/source/application/CanTp_GenTest_01_InvalidConfiguration_CANFD_TX_STANDARD_CanIdType.h</sourcefile>
      <sourceline>28</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if CanTpTxNPduRef refers a PDU with configured length
  greater than 8 and CanIdType is STANDARD_CAN, then an error shall be generated.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MCG.CanFd.TX.STANDARD.CanIdType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>719</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1546</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>CanTp_GenTest_01001_Xdm_CanTpTxNPduRef_INV_00</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_01_InvalidConfiguration_CAN_FD/source/application/CanTp_GenTest_01_InvalidConfiguration_CAN_FD.h</sourcefile>
      <sourceline>28</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if CanTpTxNPduRef or CanTpRxNPduRef refers a PDU with configured length
  less than 8 or other than 8, 12, 16, 20, 24, 32, 48, or 64, then an error shall be generated.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.Xdm.RxNPduRef.MinPduLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>712</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Xdm.TxNPduRef.MinPduLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>713</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Xdm.RxNPduRef.ValidPduLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>714</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Xdm.TxNPduRef.ValidPduLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>715</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1547</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_GenTest_01001_Err_Same_Channel_Referenced</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_01_InvalidConfiguration_DedicatedMainfunction/source/application/CanTp_GenTest_01_InvalidConfiguration.h</sourcefile>
      <sourceline>27</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test checks that the generator issues an error if CanTpDedicatedChannelProcessingSupport is enabled and if multiple CanTpChannelProcessing
  are referencing the same CanTpChannel.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.Multicore.CanTpChannelRef_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>797</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Multicore.CanTpChannelRef_Limitation1_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>804</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Multicore.CanTpDedicatedChannelProcessingSupport_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>794</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1548</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01001_No_Channel_Referenced</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_01_InvalidConfiguration_DedicatedMainfunction/source/application/CanTp_GenTest_01_InvalidConfiguration.h</sourcefile>
      <sourceline>51</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test checks that the generator issues an error if CanTpDedicatedChannelProcessingSupport is enabled and no Channel reference is configured
  for each CanTpChannelProcessing.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.Multicore.CanTpChannelRef_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>797</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Multicore.CanTpChannelRef_Limitation2_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>805</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Multicore.CanTpDedicatedChannelProcessingSupport_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>794</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1549</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01001_No_Partition_Referenced</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_01_InvalidConfiguration_DedicatedMainfunction/source/application/CanTp_GenTest_01_InvalidConfiguration.h</sourcefile>
      <sourceline>75</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test checks that the generator issues an error if CanTpMultiCoreSupport is enabled and no Partition reference is configured
  for each CanTpChannelProcessing.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.Multicore.CanTpEcuCPartitionRef_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>798</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Multicore.CanTpEcuCPartitionRef_Limitation1_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>807</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Multicore.CanTpMultiCoreSupport_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>793</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1550</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01001_No_CanTpChannelProcessing_Configured</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_01_InvalidConfiguration_DedicatedMainfunction/source/application/CanTp_GenTest_01_InvalidConfiguration.h</sourcefile>
      <sourceline>99</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test checks that the generator issues an warning if CanTpDedicatedChannelProcessingSupport is enabled and no CanTpChannelProcessing entry
  is configured.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.Multicore.CanTpChannelProcessing_Limitation1_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>806</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Multicore.CanTpDedicatedChannelProcessingSupport_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>794</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Multicore.CanTpChannelProcessing_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>795</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1551</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01001_Same_Partition_ref</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_01_InvalidConfiguration_DedicatedMainfunction/source/application/CanTp_GenTest_01_InvalidConfiguration.h</sourcefile>
      <sourceline>123</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test checks that the generator issues an warning if CanTpMultiCoreSupport is enabled and all 
  channels are referencing the same partition.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.Multicore.CanTpEcuCPartitionRef_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>798</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Multicore.CanTpEcuCPartitionRef_Limitation2_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>808</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1552</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01001_MaxParallelChannels_Enabled</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_01_InvalidConfiguration_DedicatedMainfunction/source/application/CanTp_GenTest_01_InvalidConfiguration.h</sourcefile>
      <sourceline>146</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test checks that the generator issues an error if both CanTpDedicatedChannelProcessingSupport and MaxParallelChannels are enabled.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.Multicore.ParallelChannelsLimitation_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>802</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Multicore.CanTpDedicatedChannelProcessingSupport_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>794</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1553</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_GenTest_01001_Err_MetaDataParallelChannels</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_01_InvalidConfiguration_MetaDataParallelHandling/source/application/CanTp_GenTest_01_InvalidConfiguration.h</sourcefile>
      <sourceline>27</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test checks that several errors are generated when CanTpMetaDataParallelHandling is enabled and 
  1. CanTpRxAddressingFormat and CanTpTxAddressingFormat are different than CANTP_STANDARD.
  2. CanTpDynIdSupport or CanTpMultiCoreSupport are enabled
  3. MetaDataTypeRef is not configured for any of Rx or Tx NSdu
  4. MetaDataItemType CAN_ID_32 is not configured for CanTpRxNSdu/CanTpTxNSdu/CanTpRxNPdu/CanTpTxFcNPdu/CanTpTxNPdu/CanTpRxFcNPdus.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanTpMetaDataParallelHandling_Conf_Limitation1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>813</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.CanTpMetaDataParallelHandling_Conf_Limitation2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>814</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.CanTpMetaDataParallelHandling_Conf_Limitation3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>815</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1554</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_GenTest_01001_InvalidPartitionEcuC</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_01_InvalidConfiguration_Multicore/source/application/CanTp_GenTest_01_InvalidConfiguration.h</sourcefile>
      <sourceline>28</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test checks that an error stops generation if a RxNsdu is not referencing the same partition as the channel
  to which it belongs. (EcucPduDedicatedPartitionRef or EcucPduDefaultPartitionRef)
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.Multicore.EcuCPartitionRef_Limitation1_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>803</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1555</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01001_InvalidPartitionEcuC_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_01_InvalidConfiguration_Multicore/source/application/CanTp_GenTest_01_InvalidConfiguration.h</sourcefile>
      <sourceline>50</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test checks that an error stops generation if a TxNsdu is not referencing the same partition as the channel
  to which it belongs. (EcucPduDedicatedPartitionRef or EcucPduDefaultPartitionRef)
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.Multicore.EcuCPartitionRef_Limitation1_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>803</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1556</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01001_InvalidPartitionEcuC_3</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_01_InvalidConfiguration_Multicore/source/application/CanTp_GenTest_01_InvalidConfiguration.h</sourcefile>
      <sourceline>72</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test checks that an error stops generation if a CanTpRxNPduRef is not referencing the same partition as the channel
  to which it belongs. (EcucPduDedicatedPartitionRef or EcucPduDefaultPartitionRef)
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.Multicore.EcuCPartitionRef_Limitation1_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>803</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1557</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01001_InvalidPartitionEcuC_4</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_01_InvalidConfiguration_Multicore/source/application/CanTp_GenTest_01_InvalidConfiguration.h</sourcefile>
      <sourceline>94</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test checks that an error stops generation if a CanTpTxNPduRef is not referencing the same partition as the channel
  to which it belongs. (EcucPduDedicatedPartitionRef or EcucPduDefaultPartitionRef)
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.Multicore.EcuCPartitionRef_Limitation1_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>803</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1558</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01001_InvalidPartitionEcuC_5</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_01_InvalidConfiguration_Multicore/source/application/CanTp_GenTest_01_InvalidConfiguration.h</sourcefile>
      <sourceline>116</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test checks that an error stops generation if a CanTpRxFcNPduRef is not referencing the same partition as the channel
  to which it belongs. (EcucPduDedicatedPartitionRef or EcucPduDefaultPartitionRef)
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.Multicore.EcuCPartitionRef_Limitation1_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>803</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1559</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01001_InvalidPartitionEcuC_6</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_01_InvalidConfiguration_Multicore/source/application/CanTp_GenTest_01_InvalidConfiguration.h</sourcefile>
      <sourceline>138</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test checks that an error stops generation if a CanTpTxFcNPduRef is not referencing the same partition as the channel
  to which it belongs. (EcucPduDedicatedPartitionRef or EcucPduDefaultPartitionRef)
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.Multicore.EcuCPartitionRef_Limitation1_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>803</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1560</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>CanTp_GenTest_01001_Xdm_NBrWT_UsedWhenNotSupported</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_02_InvalidConfiguration_N_Br_WAIT/source/application/CanTp_GenTest_02_InvalidConfiguration_N_Br_WAIT.h</sourcefile>
      <sourceline>27</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if CanTpNbrWaitRepeatedSupport is disabled and CanTpNbrWaitRepeated is enabled, then an error shall be generated.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.Xdm.NbrWTRepeated.NbrWTRepeatedSupport_OFF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>739</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1561</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>CanTp_GenTest_01001_MCG_CAN20_NoFD_StandardAddressing_Invalid_RX_PduLength_0</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_03_InvalidConfiguration_PduLength/source/application/CanTp_GenTest_03_InvalidConfiguration_PduLength.h</sourcefile>
      <sourceline>27</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if CanTpRxNSduRef refers to a PDU with configured length equal to 0
  for an NSdu with a CANTP_STANDARD addressing format, padding activation CANTP_OFF,
  NO FD CanIdType and CANTP_FUNCTIONAL TaType, the generator will issue an error.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MCG.RX.CAN20_NOFD_FUNC_TaType_STANDARD_Addressing_InvalidPduLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>723</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1562</internalId></specobject>
    <specobject>
      <id>CanTp_GenTest_01002_MCG_CAN20_NoFD_StandardAddressing_Invalid_TX_PduLength_0</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_03_InvalidConfiguration_PduLength/source/application/CanTp_GenTest_03_InvalidConfiguration_PduLength.h</sourcefile>
      <sourceline>50</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if CanTpTxNSduRef refers to a PDU with configured length equal to 0
  for an NSdu with a CANTP_STANDARD addressing format, padding activation CANTP_OFF,
  NO FD CanIdType and CANTP_FUNCTIONAL TaType, the generator will issue an error.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MCG.TX.CAN20_NOFD_FUNC_TaType_STANDARD_Addressing_InvalidPduLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>720</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1563</internalId></specobject>
    <specobject>
      <id>CanTp_GenTest_01003_MCG_CAN20_NoFD_StandardAddressing_Invalid_RX_PduLength_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_03_InvalidConfiguration_PduLength/source/application/CanTp_GenTest_03_InvalidConfiguration_PduLength.h</sourcefile>
      <sourceline>73</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if CanTpRxNSduRef refers to a PDU with configured length equal to 1
  for an NSdu with a CANTP_STANDARD addressing format, padding activation CANTP_OFF,
  NO FD CanIdType and CANTP_FUNCTIONAL TaType, the generator will issue an error.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MCG.RX.CAN20_NOFD_FUNC_TaType_STANDARD_Addressing_InvalidPduLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>723</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1564</internalId></specobject>
    <specobject>
      <id>CanTp_GenTest_01004_MCG_CAN20_NoFD_StandardAddressing_Invalid_TX_PduLength_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_03_InvalidConfiguration_PduLength/source/application/CanTp_GenTest_03_InvalidConfiguration_PduLength.h</sourcefile>
      <sourceline>96</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if CanTpTxNSduRef refers to a PDU with configured length equal to 1
  for an NSdu with a CANTP_STANDARD addressing format, padding activation CANTP_OFF,
  NO FD CanIdType and CANTP_FUNCTIONAL TaType, the generator will issue an error.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MCG.TX.CAN20_NOFD_FUNC_TaType_STANDARD_Addressing_InvalidPduLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>720</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1565</internalId></specobject>
    <specobject>
      <id>CanTp_GenTest_01005_MCG_CAN20_NoFD_Mixed_Addressing_Invalid_RX_PduLength_0</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_03_InvalidConfiguration_PduLength/source/application/CanTp_GenTest_03_InvalidConfiguration_PduLength.h</sourcefile>
      <sourceline>120</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if CanTpRxNSduRef refers to a PDU with configured length equal to 0
  for an NSdu with a CANTP_MIXED addressing format, padding activation CANTP_OFF,
  NO FD CanIdType and CANTP_FUNCTIONAL TaType, the generator will issue an error.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MCG.RX.CAN20_NOFD_FUNC_TaType_MIXED_Addressing_InvalidPduLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>724</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1566</internalId></specobject>
    <specobject>
      <id>CanTp_GenTest_01006_MCG_CAN20_NoFD_Mixed_Addressing_Invalid_TX_PduLength_0</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_03_InvalidConfiguration_PduLength/source/application/CanTp_GenTest_03_InvalidConfiguration_PduLength.h</sourcefile>
      <sourceline>143</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if CanTpTxNSduRef refers to a PDU with configured length equal to 0
  for an NSdu with a CANTP_MIXED addressing format, padding activation CANTP_OFF,
  NO FD CanIdType and CANTP_FUNCTIONAL TaType, the generator will issue an error.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MCG.TX.CAN20_NOFD_FUNC_TaType_MIXED_Addressing_InvalidPduLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>721</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1567</internalId></specobject>
    <specobject>
      <id>CanTp_GenTest_01007_MCG_CAN20_NoFD_Mixed_Addressing_Invalid_RX_PduLength_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_03_InvalidConfiguration_PduLength/source/application/CanTp_GenTest_03_InvalidConfiguration_PduLength.h</sourcefile>
      <sourceline>166</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if CanTpRxNSduRef refers to a PDU with configured length equal to 1
  for an NSdu with a CANTP_MIXED addressing format, padding activation CANTP_OFF,
  NO FD CanIdType and CANTP_FUNCTIONAL TaType, the generator will issue an error.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MCG.RX.CAN20_NOFD_FUNC_TaType_MIXED_Addressing_InvalidPduLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>724</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1568</internalId></specobject>
    <specobject>
      <id>CanTp_GenTest_01008_MCG_CAN20_NoFD_Mixed_Addressing_Invalid_TX_PduLength_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_03_InvalidConfiguration_PduLength/source/application/CanTp_GenTest_03_InvalidConfiguration_PduLength.h</sourcefile>
      <sourceline>189</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if CanTpTxNSduRef refers to a PDU with configured length equal to 1
  for an NSdu with a CANTP_MIXED addressing format, padding activation CANTP_OFF,
  NO FD CanIdType and CANTP_FUNCTIONAL TaType, the generator will issue an error.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MCG.TX.CAN20_NOFD_FUNC_TaType_MIXED_Addressing_InvalidPduLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>721</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1569</internalId></specobject>
    <specobject>
      <id>CanTp_GenTest_01009_MCG_CAN20_NoFD_Mixed_Addressing_Invalid_RX_PduLength_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_03_InvalidConfiguration_PduLength/source/application/CanTp_GenTest_03_InvalidConfiguration_PduLength.h</sourcefile>
      <sourceline>212</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if CanTpRxNSduRef refers to a PDU with configured length equal to 2
  for an NSdu with a CANTP_MIXED addressing format, padding activation CANTP_OFF,
  NO FD CanIdType and CANTP_FUNCTIONAL TaType, the generator will issue an error.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MCG.RX.CAN20_NOFD_FUNC_TaType_MIXED_Addressing_InvalidPduLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>724</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1570</internalId></specobject>
    <specobject>
      <id>CanTp_GenTest_01010_MCG_CAN20_NoFD_Mixed_Addressing_Invalid_TX_PduLength_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_03_InvalidConfiguration_PduLength/source/application/CanTp_GenTest_03_InvalidConfiguration_PduLength.h</sourcefile>
      <sourceline>235</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if CanTpTxNSduRef refers to a PDU with configured length equal to 2
  for an NSdu with a CANTP_MIXED addressing format, padding activation CANTP_OFF,
  NO FD CanIdType and CANTP_FUNCTIONAL TaType, the generator will issue an error.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MCG.TX.CAN20_NOFD_FUNC_TaType_MIXED_Addressing_InvalidPduLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>721</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1571</internalId></specobject>
    <specobject>
      <id>CanTp_GenTest_01011_MCG_CAN20_NoFD_Extended_Addressing_Invalid_RX_PduLength_0</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_03_InvalidConfiguration_PduLength/source/application/CanTp_GenTest_03_InvalidConfiguration_PduLength.h</sourcefile>
      <sourceline>258</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if CanTpRxNSduRef refers to a PDU with configured length equal to 0
  for an NSdu with a CANTP_EXTENDED addressing format, padding activation CANTP_OFF,
  NO FD CanIdType and CANTP_FUNCTIONAL TaType, the generator will issue an error.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MCG.RX.CAN20_NOFD_FUNC_TaType_EXTENDED_Addressing_InvalidPduLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>725</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1572</internalId></specobject>
    <specobject>
      <id>CanTp_GenTest_01012_MCG_CAN20_NoFD_Extended_Addressing_Invalid_TX_PduLength_0</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_03_InvalidConfiguration_PduLength/source/application/CanTp_GenTest_03_InvalidConfiguration_PduLength.h</sourcefile>
      <sourceline>281</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if CanTpTxNSduRef refers to a PDU with configured length equal to 0
  for an NSdu with a CANTP_EXTENDED addressing format, padding activation CANTP_OFF,
  NO FD CanIdType and CANTP_FUNCTIONAL TaType, the generator will issue an error.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MCG.TX.CAN20_NOFD_FUNC_TaType_EXTENDED_Addressing_InvalidPduLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>722</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1573</internalId></specobject>
    <specobject>
      <id>CanTp_GenTest_01013_MCG_CAN20_NoFD_Extended_Addressing_Invalid_RX_PduLength_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_03_InvalidConfiguration_PduLength/source/application/CanTp_GenTest_03_InvalidConfiguration_PduLength.h</sourcefile>
      <sourceline>304</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if CanTpRxNSduRef refers to a PDU with configured length equal to 1
  for an NSdu with a CANTP_EXTENDED addressing format, padding activation CANTP_OFF,
  NO FD CanIdType and CANTP_FUNCTIONAL TaType, the generator will issue an error.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MCG.RX.CAN20_NOFD_FUNC_TaType_EXTENDED_Addressing_InvalidPduLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>725</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1574</internalId></specobject>
    <specobject>
      <id>CanTp_GenTest_01014_MCG_CAN20_NoFD_Extended_Addressing_Invalid_TX_PduLength_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_03_InvalidConfiguration_PduLength/source/application/CanTp_GenTest_03_InvalidConfiguration_PduLength.h</sourcefile>
      <sourceline>327</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if CanTpTxNSduRef refers to a PDU with configured length equal to 1
  for an NSdu with a CANTP_EXTENDED addressing format, padding activation CANTP_OFF,
  NO FD CanIdType and CANTP_FUNCTIONAL TaType, the generator will issue an error.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MCG.TX.CAN20_NOFD_FUNC_TaType_EXTENDED_Addressing_InvalidPduLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>722</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1575</internalId></specobject>
    <specobject>
      <id>CanTp_GenTest_01015_MCG_CAN20_NoFD_Extended_Addressing_Invalid_RX_PduLength_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_03_InvalidConfiguration_PduLength/source/application/CanTp_GenTest_03_InvalidConfiguration_PduLength.h</sourcefile>
      <sourceline>350</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if CanTpRxNSduRef refers to a PDU with configured length equal to 2
  for an NSdu with a CANTP_EXTENDED addressing format, padding activation CANTP_OFF,
  NO FD CanIdType and CANTP_FUNCTIONAL TaType, the generator will issue an error.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MCG.RX.CAN20_NOFD_FUNC_TaType_EXTENDED_Addressing_InvalidPduLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>725</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1576</internalId></specobject>
    <specobject>
      <id>CanTp_GenTest_01016_MCG_CAN20_NoFD_Extended_Addressing_Invalid_TX_PduLength_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_03_InvalidConfiguration_PduLength/source/application/CanTp_GenTest_03_InvalidConfiguration_PduLength.h</sourcefile>
      <sourceline>373</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if CanTpTxNSduRef refers to a PDU with configured length equal to 2
  for an NSdu with a CANTP_EXTENDED addressing format, padding activation CANTP_OFF,
  NO FD CanIdType and CANTP_FUNCTIONAL TaType, the generator will issue an error.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MCG.TX.CAN20_NOFD_FUNC_TaType_EXTENDED_Addressing_InvalidPduLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>722</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1577</internalId></specobject>
    <specobject>
      <id>CanTp_GenTest_01017_MCG_PHYSICAL_TaType_STANDARD_CAN_CanIdType_Invalid_RX_PduLength_SmallerThan8</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_03_InvalidConfiguration_PduLength/source/application/CanTp_GenTest_03_InvalidConfiguration_PduLength.h</sourcefile>
      <sourceline>397</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if CanTpRxNSduRef refers to a PDU with configured length equal to 3
  for an NSdu with a CANTP_PHYSICAL addressing format (multiframe) and STANDARD_CAN CanIdype, the generator will issue an error.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MCG.RX.PHYSICAL_TaType_STANDARD_CAN_InvalidPduLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>727</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1578</internalId></specobject>
    <specobject>
      <id>CanTp_GenTest_01018_MCG_PHYSICAL_TaType_Invalid_TX_PduLength_SmallerThan8</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_03_InvalidConfiguration_PduLength/source/application/CanTp_GenTest_03_InvalidConfiguration_PduLength.h</sourcefile>
      <sourceline>420</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if CanTpTxNSduRef refers to a PDU with configured length equal to 3
  for an NSdu with a CANTP_PHYSICAL addressing format (multiframe), the generator will issue an error.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MCG.TX.PHYSICAL_TaType_InvalidPduLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>726</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1579</internalId></specobject>
    <specobject>
      <id>CanTp_GenTest_01019_MCG_PHYSICAL_TaType_EXTENDED_CAN_CanIdType_Invalid_RX_PduLength_SmallerThan8</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_03_InvalidConfiguration_PduLength/source/application/CanTp_GenTest_03_InvalidConfiguration_PduLength.h</sourcefile>
      <sourceline>443</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if CanTpRxNSduRef refers to a PDU with configured length equal to 3
  for an NSdu with a CANTP_PHYSICAL addressing format (multiframe) and EXTENDED_CAN CanIdType, the generator will issue an error.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MCG.RX.PHYSICAL_TaType_EXTENDED_CAN_InvalidPduLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>728</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1580</internalId></specobject>
    <specobject>
      <id>CanTp_GenTest_01020_MCG_FUNCTIONAL_TaType_STANDARD_FD_CAN_CanIdType_Invalid_RX_PduLength_SmallerThan8</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_03_InvalidConfiguration_PduLength/source/application/CanTp_GenTest_03_InvalidConfiguration_PduLength.h</sourcefile>
      <sourceline>466</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if CanTpRxNSduRef refers to a PDU with configured length smaller than 8 bytes,
  for an NSdu with a CANTP_FUNCTIONAL addressing format (single frame) and STANDARD_FD_CAN CanIdType, the generator will issue an error.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MCG.RX.FUNC_TaType_STANDARD_FD_CAN_PduLengthLessThan8</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>729</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1581</internalId></specobject>
    <specobject>
      <id>CanTp_GenTest_01021_MCG_FUNCTIONAL_TaType_EXTENDED_FD_CAN_CanIdType_Invalid_RX_PduLength_SmallerThan8</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_03_InvalidConfiguration_PduLength/source/application/CanTp_GenTest_03_InvalidConfiguration_PduLength.h</sourcefile>
      <sourceline>488</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if CanTpRxNSduRef refers to a PDU with configured length smaller than 8 bytes,
  for an NSdu with a CANTP_FUNCTIONAL addressing format (single frame) and EXTENDED_FD_CAN CanIdType, the generator will issue an error.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MCG.RX.FUNC_TaType_EXTENDED_FD_CAN_PduLengthLessThan8</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>730</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1582</internalId></specobject>
    <specobject>
      <id>CanTp_GenTest_01022_MCG_FUNCTIONAL_TaType_STANDARD_FD_CAN_CanIdType_Invalid_TX_PduLength_SmallerThan8</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_03_InvalidConfiguration_PduLength/source/application/CanTp_GenTest_03_InvalidConfiguration_PduLength.h</sourcefile>
      <sourceline>511</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if CanTpTxNSduRef refers to a PDU with configured length smaller than 8 bytes,
  for an NSdu with a CANTP_FUNCTIONAL addressing format (single frame) and STANDARD_FD_CAN CanIdType, the generator will issue an error.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MCG.TX.FUNC_TaType_STANDARD_FD_CAN_PduLengthLessThan8</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>731</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1583</internalId></specobject>
    <specobject>
      <id>CanTp_GenTest_01023_MCG_FUNCTIONAL_TaType_EXTENDED_FD_CAN_CanIdType_Invalid_TX_PduLength_SmallerThan8</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_03_InvalidConfiguration_PduLength/source/application/CanTp_GenTest_03_InvalidConfiguration_PduLength.h</sourcefile>
      <sourceline>533</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if CanTpTxNSduRef refers to a PDU with configured length smaller than 8 bytes,
  for an NSdu with a CANTP_FUNCTIONAL addressing format (single frame) and EXTENDED_FD_CAN CanIdType, the generator will issue an error.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MCG.TX.FUNC_TaType_EXTENDED_FD_CAN_PduLengthLessThan8</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>732</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1584</internalId></specobject>
    <specobject>
      <id>CanTp_GenTest_01024_MCG_PHYSICAL_Std_CanFd_Invalid_RX_PduLength</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_03_InvalidConfiguration_PduLength/source/application/CanTp_GenTest_03_InvalidConfiguration_PduLength.h</sourcefile>
      <sourceline>558</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if CanTpRxNSduRef refers to a PDU with configured length not equal to 64 bytes,
  for an RxNSdu with a CANTP_PHYSICAL addressing format (multi frame), STANDARD_CAN CanIdType, padding activation equal to CANTP_ON_CAN_CAN_FD
  and the frame has a CAN FD format, the generator will issue an error.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MCG.RX.CANTP_ON_CAN_CAN_FD_MandatoryPduLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>733</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1585</internalId></specobject>
    <specobject>
      <id>CanTp_GenTest_01025_MCG_PHYSICAL_Ext_CanFd_Invalid_RX_PduLength</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_03_InvalidConfiguration_PduLength/source/application/CanTp_GenTest_03_InvalidConfiguration_PduLength.h</sourcefile>
      <sourceline>581</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if CanTpRxNSduRef refers to a PDU with configured length not equal to 64 bytes,
  for an RxNSdu with a CANTP_PHYSICAL addressing format (multi frame), EXTENDED_CAN CanIdType, padding activation equal to CANTP_ON_CAN_CAN_FD
  and the frame has a CAN FD format, the generator will issue an error.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MCG.RX.CANTP_ON_CAN_CAN_FD_MandatoryPduLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>733</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1586</internalId></specobject>
    <specobject>
      <id>CanTp_GenTest_01026_MCG_FUNCTIONAL_Std_Classic_Invalid_RX_PduLength</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_03_InvalidConfiguration_PduLength/source/application/CanTp_GenTest_03_InvalidConfiguration_PduLength.h</sourcefile>
      <sourceline>604</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if CanTpRxNSduRef refers to a PDU with configured length not equal to 8 bytes,
  for an RxNSdu with a CANTP_FUNCTIONAL addressing format (single frame), STANDARD_CAN CanIdType, padding activation equal to CANTP_ON_CAN_CAN_FD
  and the frame has a classic CAN 2.0 format, the generator will issue an error.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MCG.RX.CANTP_ON_CAN_CAN_FD_MandatoryPduLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>733</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1587</internalId></specobject>
    <specobject>
      <id>CanTp_GenTest_01027_MCG_FUNCTIONAL_Std_CanFd_Invalid_RX_PduLength</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_03_InvalidConfiguration_PduLength/source/application/CanTp_GenTest_03_InvalidConfiguration_PduLength.h</sourcefile>
      <sourceline>627</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if CanTpRxNSduRef refers to a PDU with configured length not equal to 64 bytes,
  for an RxNSdu with a CANTP_FUNCTIONAL addressing format (single frame), STANDARD_CAN CanIdType, padding activation equal to CANTP_ON_CAN_CAN_FD
  and the frame has a CAN FD format, the generator will issue an error.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MCG.RX.CANTP_ON_CAN_CAN_FD_MandatoryPduLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>733</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1588</internalId></specobject>
    <specobject>
      <id>CanTp_GenTest_01028_MCG_FUNCTIONAL_Ext_Classic_Invalid_RX_PduLength</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_03_InvalidConfiguration_PduLength/source/application/CanTp_GenTest_03_InvalidConfiguration_PduLength.h</sourcefile>
      <sourceline>650</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if CanTpRxNSduRef refers to a PDU with configured length not equal to 8 bytes,
  for an RxNSdu with a CANTP_FUNCTIONAL addressing format (single frame), EXTENDED_CAN CanIdType, padding activation equal to CANTP_ON_CAN_CAN_FD
  and the frame has a classic CAN 2.0 format, the generator will issue an error.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MCG.RX.CANTP_ON_CAN_CAN_FD_MandatoryPduLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>733</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1589</internalId></specobject>
    <specobject>
      <id>CanTp_GenTest_01029_MCG_FUNCTIONAL_Ext_CanFd_Invalid_RX_PduLength</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Generic/IN/CanTp_GenTest_03_InvalidConfiguration_PduLength/source/application/CanTp_GenTest_03_InvalidConfiguration_PduLength.h</sourcefile>
      <sourceline>673</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if CanTpRxNSduRef refers to a PDU with configured length not equal to 64 bytes,
  for an RxNSdu with a CANTP_FUNCTIONAL addressing format (single frame), EXTENDED_CAN CanIdType, padding activation equal to CANTP_ON_CAN_CAN_FD
  and the frame has a CAN FD format, the generator will issue an error.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MCG.RX.CANTP_ON_CAN_CAN_FD_MandatoryPduLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>733</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1590</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_ChangeTx_ResetTx_NoInit</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_ImpTest_ChangeTxParameter/source/application/Tst_Conf_ChangeTxParameter.c</sourcefile>
      <sourceline>73</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that, when development error detection is enabled, CanTp checks if
    the module was initialized before.
  
Test Object: 
    Error detection
  
Test Precondition: 
    Module compiled with DET enabled.
  
Test Execution: 
    01: Call CanTp_ChangeTxParameter() before module initialization.
    02: VP():
        Check that Det error CANTP_E_UNINIT is reported.
    03: Call CanTp_ResetTxParameter() before module initialization.
    04: VP():
        Check that Det error CANTP_E_UNINIT is reported.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanTp_ChangeTxParameter</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>748</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.CanTp_ResetTxParameter</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>754</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.CanTp_ResetTxParameter.ErrorDetection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>756</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1591</internalId></specobject>
    <specobject>
      <id>TS_CANTP_ChangeTx_STmin_ResetTx_InvalidParam</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_ImpTest_ChangeTxParameter/source/application/Tst_Conf_ChangeTxParameter.c</sourcefile>
      <sourceline>153</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that, when development error detection is enabled, all parameters are checked for
    validity and that invalid errors are reported.
  
Test Object: 
    Error detection
  
Test Precondition: 
    Module compiled with DET enabled.
  
Test Execution: 
    01: Call CanTp_ChangeTxParameter() with invalid SDU ID.
    02: VP():
        Check that Det error CANTP_E_PARAM_ID is reported.
    03: Call CanTp_ChangeTxParameter() with invalid TP-Parameter.
    04: VP():
        Check that Det error CANTP_E_PARAM_ID is reported.
    05: Call CanTp_ChangeTxParameter() with invalid TP value.
    06: VP():
        Check that Det error CANTP_E_PARAM_ID is reported.
    07: Call CanTp_ResetTxParameter() with invalid SDU ID.
    08: VP():
        Check that Det error CANTP_E_PARAM_ID is reported.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanTp_ChangeTxParameter.STmin</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>749</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.CanTp_ResetTxParameter.ErrorDetection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>756</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1592</internalId></specobject>
    <specobject>
      <id>TS_CANTP_ChangeTx_STmin_NoTxPending</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_ImpTest_ChangeTxParameter/source/application/Tst_Conf_ChangeTxParameter.c</sourcefile>
      <sourceline>275</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test shall verify that STmin value can be changed (via CanTp_ChangeTxParameter) and
    will be correctly used as reference time when sending CFs.
  
Test Object: 
    CanTp_ChangeTxParameter().
  
Test Precondition: 
    Module initialized.
  
Test Execution: 
    01: Change STmin to 2 before the transmission starts.
    02: Start a segmented transmission (message length 53 = FF + 8 * CF).
    03: VP():
        Check that the FF was sent.
    04: Confirm the sent FF.
    05: Receive the FC with STmin set to 1.
    06: VP():
        Check if the first CF is sent out.
    07: Confirm the sent CF.
    08: Wait for the STmin value (equal to 2) to expire before sending the next CF.
    09: VP():
        Check if the second CF is sent after STmin expires.
    10: Confirm the sent CF.
    11: Receive the FC with STmin = 1 and BS = 2.
    12: VP():
        Check if the CF is sent out.
    13: Confirm the sent CF.
    14: Wait for the STmin value (equal to 2) to expire before sending the next CF.
    15: VP():
        Check if the second CF is sent after STmin expires.
    16: Confirm the sent CF.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanTp_ChangeTxParameter.STmin</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>749</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.CanTp_ChangeTxParameter.ErrorDetection_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>751</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1593</internalId></specobject>
    <specobject>
      <id>TS_CANTP_Allow_ChangeTx_STmin_OngoingTx</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_ImpTest_ChangeTxParameter/source/application/Tst_Conf_ChangeTxParameter.c</sourcefile>
      <sourceline>468</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test shall verify that STmin value can be changed (via CanTp_ChangeTxParameter) and
    will be correctly used as reference time when sending CFs even if the transmission is
    ongoing.
  
Test Object: 
    CanTp_ChangeTxParameter().
  
Test Precondition: 
    Module initialized.
  
Test Execution: 
    01: After 2 CFs were sent (previous FC with BS = 2), receive another FC with StMin = 0.
    02: Send the first CF after FC.
    03: Confirm the CF.
    04: Wait until the STmin set via CanTp_ChangeTxParameter() expires.
    05: VP():
        Check if the next CF was sent.
    06: Call CanTp_ChangeTxParameter() just before CanTp_Confirmation().
    07: Confirm the previous sent out CF.
    08: VP():
        Check if the time set via CanTp_ChangeTxParameter() is considered.
    09: 07: Confirm the last sent out CF.
    10: VP():
        Check that the transmission is correctly reported to the upper layer.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanTp_ChangeTxParameter.Modify</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>750</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1594</internalId></specobject>
    <specobject>
      <id>TS_CANTP_Allow_ResetTx_STmin_OngoingTx</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_ImpTest_ChangeTxParameter/source/application/Tst_Conf_ChangeTxParameter.c</sourcefile>
      <sourceline>586</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test shall verify that the STmin value can be changed/reset and will be correctly used by the
    intermediate CFs of a block.
  
Test Object: 
    CanTp_ChangeTxParameter()
    CanTp_ResetTxParameter()
  
Test Precondition: 
    Module initialized.
  
Test Execution: 
    01: Change the STmin to 5 by calling the CanTp_ChangeTxParameter() API.
    02: Start a new transmission session (message length 48 = FF + 6 * CF).
    03: VP():
        Check that the FF frame was sent.
    04: Confirm the FF.
    05: Receive the FC(CTS) with BS = 4, STmin = 0.
    06: VP():
        Verify that first CF is transmitted.
    07: Confirm the first CF.
    08: Wait until the STmin set via CanTp_ChangeTxParameter() expires.
    09: VP():
        Check if the next CF was sent.
    10: Confirm the sent CF.
    11: Wait until the STmin set via CanTp_ChangeTxParameter() expires.
    12: Reset the STmin value set via CanTp_ChangeTxParameter() by calling the
        CanTp_ResetTxParameter() API.
    13: VP():
        Check if the next CF was sent (STmin = 5 set via CanTp_ChangeTxParameter() is
        considered).
    14: Confirm the sent CF.
    15: VP():
        Check if the STmin = 0 set within the first FC (set at step 05) was loaded at
        CanTp_TxConfirmation(); the last CF of the block shall be sent.
    16: Confirm the last CF sent.
    17: Receive a new FC(CTS) with BS = 2, STmin = 1 after the first block.
    18: VP():
        Check that the fist CF of the block was sent.
    19: Confirm the first sent CF of the block.
    20: VP():
        Check if the STmin = 1 set within the second FC (set at step 17) was loaded at
        CanTp_TxConfirmation(); the second CF of the block shall be sent.
    21: Confirm the second sent CF of the block.
    22: VP():
        Check that the transmission is correctly reported to the upper layer.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanTp_ResetTxParameter.Stmin</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>755</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1595</internalId></specobject>
    <specobject>
      <id>TS_CANTP_STmin_InvalidValue</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_ImpTest_ChangeTxParameter/source/application/Tst_Conf_ChangeTxParameter.c</sourcefile>
      <sourceline>789</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that the CAN TP respects separation time (STmin).
    - Verify that CanTp will be using a default value 0x7F for STmin if an FC with invalid STmin
      value is received.
  
Test Object: 
    STmin handling
  
Test Precondition: 
   - Configure normal addressing type for CanTpTxNSdu4.
   - CanTp should be initialized.
  
Test Execution: 
    01: Simulate segmented transmission for data length of 20 bytes (FF+2CFs).
    02: Check that the FF has been sent.
    03: Send the FC frame with Stmin as 0xFD(reserved value).
    04: Verify that CAN TP has sent the first CF.
    05: Confirm the first CF, which will start the STmin timeout.
        (As STmin received is a reserved value, CanTp will use the value 0x7F =127ms
         as specified by ISO)
    06: VP(CanTp.11270):
        Call MainFunction periodically to simulate STmin timeout and verify that second CF
        will be transmitted after STmin(127) timeout.
    07: VP():
        Elapse one main cycle so that STmin timeout(127ms) is reached and verify that last CF is
        sent.
    08: Confirm the last CF and verify that PduR is notified about the successful transmission.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.11270</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>882</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1596</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_40048</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_Impl_1/source/application/TS_CANTP_40048.c.m4</sourcefile>
      <sourceline>22</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that common published information can be accessed via macros.
  
Test Object: None.
Test Precondition: 
    Only CanTp.h is included
  
Test Execution: 
    01: VP(CanTp.ASR40.SWS_CanTp_00266, CanTp.SWS_CanTp_00267):
        The macros CANTP_SW_MAJOR_VERSION, CANTP_SW_MINOR_VERSION, CANTP_SW_PATCH_VERSION,
        CANTP_AR_RELEASE_MAJOR_VERSION, CANTP_AR_RELEASE_MINOR_VERSION,
        CANTP_AR_RELEASE_REVISION_VERSION must be present.
    02: VP(CanTp.ASR40.SWS_CanTp_00115):
        The macro CANTP_MODULE_ID must be present.
    03: VP(CanTp.ASR40.SWS_CanTp_00266, CanTp.SWS_CanTp_00267):
        Check that all macros defined in test step 01 correspond to the values in
        config.mk.
    04: VP(CanTp.ASR40.SWS_CanTp_00115):
        Check that CANTP_MODULE_ID corresponds to the value in config.mk.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00266</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>7</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00267</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00115</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>39</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1597</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_LCFG_C</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_Impl_1/source/application/TS_CANTP_LCFG.c.m4</sourcefile>
      <sourceline>22</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanTp_Lcfg.c contains the CanTp_LcfgSignature value.
  
Test Object: None.
Test Precondition: 
    Only CanTp_Lcfg.c is included
  
Test Execution: 
    01: VP(CanTp.EB.PBCFGM105):
        Check that CanTp_LcfgSignature has the expected value.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.PBCFGM105</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>963</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1598</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_40040</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_Impl_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>124</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test reception of FF while the channel is locked and in Rx state (receiving segmented message).
  
Test Object: 
    Rx post processing
  
Test Precondition: 
    CanTp initialized
  
Test Execution: 
    01: Indicate reception of FF to CAN TP (6 bytes sent, 14 to go).
    02: Confirm the FC frame sent.
    03. Indicate reception of CF to CAN TP (6+7 bytes sent, 7 to go).
    04: Now simulate a locked channel for the Pdu in current reception.
    05: Indicate reception of the unexpected FF to the CAN TP with same PDU ID.
    06: VP(CanTp.SWS_CanTp_00124_Same_N_AI)
        Check that CAN TP has called PduR_CanTpRxIndication() to indicate that
        the current reception failed.
    07: Confirm the FC frame sent.
    08: Indicated the CF of new reception.
    09: Check that PduR is notified of successful reception.
    10: Check that the invalid Tx channel-ID is consistent in generator and macro
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00124_Same_N_AI</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>249</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1599</internalId></specobject>
    <specobject>
      <id>TS_CANTP_40041</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_Impl_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>250</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test reception of a segmented message while the channel is locked and in Idle state
  
Test Object: 
    Rx post processing
  
Test Precondition: 
    CanTp initialized
  
Test Execution: 
    01: Simulate a locked channel for the Pdu for reception.
    02: Indicate reception of FF to CAN TP (6 bytes sent, 14 to go) on the locked channel.
    03: Simulated RxIndication-call has finished its processing and
        release the channel again.
    04: VP(CanTp.SWS_CanTp_00124_Same_N_AI):
        Check if received message is passed to PduR indicating the frame is considered.
    05: Confirm the FC frame sent.
    06: Indicate reception of first CF to CAN TP (6+7 bytes sent, 7 to go).
    07: Check if received message is passed to PduR.
    08: Indicate reception of second CF to CAN TP (6+7+7 bytes sent, 0 to go).
    09: Check if received message is passed to PduR.
    10: Check if PduR is notified of successful reception.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00124_Same_N_AI</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>249</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1600</internalId></specobject>
    <specobject>
      <id>TS_CANTP_40042</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_Impl_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>360</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that a FF reception is postponed if it is initiated during the processing of an last CF.
  
Test Object: 
    Rx post processing
  
Test Precondition: 
    CanTp initialized
  
Test Execution: 
    01: Indicate reception of FF to CAN TP (6 bytes sent, 20 to go).
    02: Confirm the FC frame sent.
    03. Indicate reception of CF to CAN TP (6+7 bytes sent, 13 to go).
    04. Indicate reception of CF to CAN TP (6+7+7 bytes sent, 6 to go).
    05. Simulate reception of the last CF after the channel is locked by CanTp_CancelReceive()
    06. Make buffer available and simulate reception of a FF at PduR_CanTpCopyRxData() execution.
    07. Check that last CF was processed with success.
    08. Check that FF was processed with success.
    09: Confirm the FC frame sent.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanTp_RxIndication.FFPostPoneRxIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>758</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1601</internalId></specobject>
    <specobject>
      <id>TS_CANTP_40043</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_Impl_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>472</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that a FF reception is postponed if it is initiated during the processing of an last CF.
  
Test Object: 
    Rx post processing
  
Test Precondition: 
    CanTp initialized
  
Test Execution: 
    01: Indicate reception of FF to CAN TP (6 bytes sent, 20 to go).
    02: Confirm the FC frame sent.
    03. Indicate reception of CF to CAN TP (6+7 bytes sent, 13 to go).
    04. Indicate reception of CF to CAN TP (6+7+7 bytes sent, 6 to go).
    05. Simulate reception of the last CF at PduR_CanTpRxIndication() execution.
        It will be postponed due to channel lock.
    06. Check that timeout was reported.
    07. Check that postponed CF was not processed.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanTp_RxIndication.FFPostPoneRxIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>758</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1602</internalId></specobject>
    <specobject>
      <id>TS_CANTP_40045</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_Impl_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>579</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test signaling of TxConfirmation while the channel is locked and waiting for a confirmation
  
Test Object: 
    Tx post processing
  
Test Precondition: 
    CanTp initialized
  
Test Execution: 
    01: Start transmission of segmented message.
    02: Check whether FF has been sent with a SduLength of 8 (2 NP_CI + 6 data).
    03: Indicate reception of FC frame.
    04: Verify that CAN TP has sent the first CF.
    05: Verify that the GPT has not been called yet.(must be called after TxConfirmation)
    06: Now simulate a locked channel.
    07: Call Tx confirmation.
    08: Verify that the GPT has still not been called yet as the confirmation is given in lock state.
        (TxConfirmation not yet processed)
    09: Release the channel.
    10: VP(CanTp.Design.ChannelLock.TxConfirmation):
        Verify that the GPT has been called and CAN TP has set the timeout to the correct value
        ((10ms+2us)/3us + 1).
    11: Simulate a timeout of the timer, CAN TP should now send the second CF.
    12: Confirm the last CF sent.
    13: Check that PduR is notified.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.Design.ChannelLock.TxConfirmation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>110</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1603</internalId></specobject>
    <specobject>
      <id>TS_CANTP_40148</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_Impl_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>725</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test signaling of Tx confirmation with two concurrent transmissions and the smaller channel
    locked (ASCCANTP-517)
  
Test Object: 
    Tx post processing
  
Test Precondition: 
    CanTp initialized
  
Test Execution: 
    01: Start transmission of SF on two different channels.
    02: Elapse a mainfunction tick to start transmission.
    03: Check that the SFs have been sent.
    04: Now simulate a locked channel for CanTpChannel_0.
    05: Confirm SF on CanTpChannel_0.
    06: Check that confirmation not handled because channel is locked.
    07: Confirm SF on CanTpChannel_9.
    08: VP(CanTp.SWS_CanTp_00122):
        Check that PduR is notified for CanTpChannel_9 even though other channel is locked
        indicating that different channels use different resources.
    09: Release CanTpChannel_0.
    10: Check that post processing of TxConfirmation occurred and PduR is notified.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00122</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>242</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1604</internalId></specobject>
    <specobject>
      <id>TS_CANTP_40046</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_Impl_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>846</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test signaling of GPT callback while the channel is locked and waiting for a confirmation
  
Test Object: 
    Timeout post processing
  
Test Precondition: 
    CanTp initialized. CanTp channel number should be != 0.
  
Test Execution: 
    01: Start transmission of segmented message on CanTpChannel_1.
    02: Check that the FF has been sent with a SduLength of 8 (2 NP_CI + 6 data).
    03: Confirm the FF sent.
    04: Indicate FC frame reception.
    05: Verify that CAN TP has sent the first CF and is waiting for STmin to expire
        before sending the second CF.
    06: Confirm the CF sent.
    07: VP(CanTp.EB.Gpt.STminHandling_1):
        Verify that CAN TP has set the timeout to the correct value ((10ms+2us)/3us + 1).
    08: Simulate a locked channel.
    09: Simulate a timeout of the timer.
    10: Verify that the CanIf_Transmit has not been called yet (GPT callback not yet processed)
    11: Release the channel again.
    12: VP(CanTp.EB.Gpt.STminHandling_2b):
        CAN TP should now send the second CF as the channel got unlocked and Gpt callback was
        already triggered.
    13: Confirm the CF sent.
    14: Check if PduR is notified of successful transmission.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.Gpt.STminHandling_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>552</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Gpt.STminHandling_2b</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>556</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1605</internalId></specobject>
    <specobject>
      <id>TS_CANTP_40052</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_Impl_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>1003</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test calling CanTp_MainFunction while a channel is locked during segmented transmission
  
Test Object: 
    Main function during internal channel lock
  
Test Precondition: 
    CanTp initialized
  
Test Execution: 
    01: PduR_CanTpCopyTxData shall return BUFREQ_E_BUSY.
    02: Start a transmission on CanTpChannel_1.
    03: Mainfunction shall be called until 5 times before N_Cs timeout occurs.
    04: Now simulate a locked channel.
    05: Elapse three MainFunction ticks while channel is locked.
    06: Release the channel.
    07: Check that no timeout has been reported.
    08: Simulate a locked channel.
    09: Elapse three MainFunction calls while channel is locked.
    10: Check that no timeout has been reported as channel is locked.
    11: Release the channel, which shall trigger the timeout.
    12: VP(CanTp.Design.ChannelLock.MainFunctionTimeout, CanTp.SWS_CanTp_00280)
        CanTp must have indicated a timeout to the upper layer.
    13: Check that the invalid Rx channel-ID is consistent in generator and macro
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.Design.ChannelLock.MainFunctionTimeout</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>112</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00280</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>207</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1606</internalId></specobject>
    <specobject>
      <id>TS_CANTP_STMIN_BS_VAR</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_Impl_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>1134</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check if the function CanTp_ChangeParameter() changes the reception parameter STmin
    and BS for all N-Sdu Ids. Checking the reception parameter STmin and BS is done via macro
    CanTp_ReadParameter() API.
  
Test Object: 
    basic functionality of API function CanTp_ChangeParameter().
  
Test Precondition: 
  
Test Execution: 
    01: VP(CanTp.EB.CanTp306):
        Set STmin values.  Check that the API returned E_OK.
    02: VP(CanTp.EB.CanTp306):
        Set BS values. Check that the API return E_OK.
    03: VP(CanTp.EB.CanTp306):
        Read back STmin values and check that the values are set as
        passed with CanTp_ChangeParameter().
    04: VP(CanTp.EB.CanTp306):
        Read back BS values and check that the values are set as
        passed with CanTp_ChangeParameter().
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanTp306</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>604</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1607</internalId></specobject>
    <specobject>
      <id>TS_CANTP_CancelRx_CHLOCK</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_Impl_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>1258</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test Receive Cancellation when channel is locked
  
Test Object: 
    CanTp_CancelReceive
  
Test Precondition: 
    Channel is locked
  
Test Execution: 
    01: Indicate reception of FF.
    02: Confirm the FF sent.
    03: Simulate a locked channel.
    04: VP(CanTp.Design.ChannelLock.RxCancellation):
        Call CanTp_CancelReceive and check that it returns E_NOT_OK.
    05: Release the channel.
    06: Indicate reception of first CF.
    07: Indicate reception of second CF.
    08: Check that PduR was notified of successful message reception.
    09: Check if correct data is passed to the PduR.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.Design.ChannelLock.RxCancellation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>108</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1608</internalId></specobject>
    <specobject>
      <id>TS_CANTP_TxConfirm</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_Impl_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>1393</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test signaling of TxConfirmation while the channel is locked and not waiting for a confirmation
  
Test Object: 
    Tx post processing
  
Test Precondition: 
    CanTp initialized
    Configure normal addressing mode
  
Test Execution: 
    01: Start transmission of segmented message.
    02: Now simulate a locked channel.
    03: Call Tx confirmation even though channel is not waiting for that.
    04: VP(CanTp.Design.ChannelLock.TxConfirmation):
        Verify that the TxConfirmation is not processed.
    05: Release the channel.
    06: Elapse one main cycle for FF to get transmitted.
    07: Check whether FF has been sent with a SduLength of 8 (2 NP_CI + 6 data).
    08: Confirm the FF.
    09: Indicate reception of FC frame.
    10: Verify that CAN TP has sent the first(last) CF.
    11: Call CanTp_TxConfirmation for the first CF.
    12: Check that PduR is notified after confirming the last CF using CanTp_TxConfirmation.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.Design.ChannelLock.TxConfirmation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>110</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1609</internalId></specobject>
    <specobject>
      <id>TS_CANTP_CancelTx_CHLOCK</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_Impl_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>1510</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test Transmit Cancellation while channel is locked
  
Test Object: 
    Tx cancellation while channel is locked.
  
Test Precondition: 
    CanTp should be initialized
  
Test Execution: 
    01: Start transmission of FF on CanTpChannel_1.
    02: Elapse a mainfunction tick to start transmission.
    03: Check that the FF have been sent.
    04: Now simulate a channel lock for CanTpChannel_1.
    05: VP(CanTp.SWS_CanTp_00274, CanTp.Design.ChannelLock.TxCancellation):
        Call CancelTransmit while channel is locked and verify that it is not accepted
    06: Release CanTpChannel_1.
    07: Confirm FF on CanTpChannel_1.
    08: Indicate FC frame reception and finish the transmission successfully.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00274</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>145</internalId></provcov>
        <provcov>
          <linksto>CanTp.Design.ChannelLock.TxCancellation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>109</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1610</internalId></specobject>
    <specobject>
      <id>TS_CANTP_ChannelLock_MF</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_Impl_1/source/application/Tests.c.m4</sourcefile>
      <sourceline>1638</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test shall verify that if CanTp_MainFunction() is called while requested channel is
    in process and locked, then the module shall suspend the process of this channel until the
    next main function call.
  
Test Object: 
    Main function during internal channel lock
  
Test Precondition: 
    CanTp initialized
  
Test Execution: 
    01: Prepare PduR_CanTpCopyTxData and PduR_CanTpCopyRxData to return BUFREQ_E_BUSY.
    02: Start an unsegmented transmission on CanTpChannel_1.
    03: Indicate reception of FF on CanTpChannel_0 with messahe length 8.
    04: Verify that the buffer is requested correctly for reception on CanTpChannel_0.
    05: Lock the two channels.
    06: Call CanTp_MainFunction().
    07: VP(CanTp.Design.ChannelLock.MainFunction):
        Verify that the transmission and reception process is not continued as the channel is
        locked.
    08: Release the channels.
    09: Prepare the PduR calls to return BUFREQ_OK.
    10: Call CanTp_MainFunction().
    11: VP(CanTp.Design.ChannelLock.MainFunction):
        Verify that the suspended transmission and reception is continued with this Main Function
        as the channel got unlocked.
    12: Check that PduR was notified of successful message reception on CanTpChannel_0.
    13: Finish the transmission by confirming the CF sent.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.Design.ChannelLock.MainFunction</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>111</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1611</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_SF_Transmission</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_Impl_2/source/application/Tests.c</sourcefile>
      <sourceline>59</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    Test CanTp_NonIdleChannelCounter values while transmission of a Single Frame (before, during, after)
  
Test Object: 
    Single frame transmission
  
Test Precondition: 
    - Padding disabled
    - CanTp should be initialized.
    - Normal addressing mode.
  
Test Execution: 
    01: Check that CanTp_NonIdleChannelCounter is equal to 0 (no transmission or reception is in progress after module initialization)
    02: Call CanTp_Transmit() with PduId 0 and SduLength 7 (maximum size of SF)
        in normal addressing mode and check that it returns E_OK.
    03: Check that CanTp_NonIdleChannelCounter is incremented to 1 (one current transmission started).
    04: Elapse a MainFunction tick.
    05: Check if PduR_CanTpCopyTxData() is called with SduLength 7 and RetryInfoPtr as NULL_PTR.
    06: Check if CanIf_Transmit() is called to transmit SF with SduLength 8 and
        that the data transmitted is same as that provided by PduR.
    07: Check that CanTp_NonIdleChannelCounter is still 1 (one current transmission is still in progress).
    08: Call CanTp_TxConfirmation() to confirm the sent Pdu.
    09: Check if PduR_CanTpTxConfirmation is called with result E_OK.
    10: Check that CanTp_NonIdleChannelCounter is decremented to 0 (Transmission is done and all channels are idle again).

  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.IdleChannels</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>665</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1612</internalId></specobject>
    <specobject>
      <id>TS_CANTP_MF_Transmission</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_Impl_2/source/application/Tests.c</sourcefile>
      <sourceline>172</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    Test CanTp_NonIdleChannelCounter values while transmission of a Multiple message frames (before, during, after)
  
Test Object: 
    Multiple frames transmission
  
Test Precondition: 
    - Padding disabled
    - CanTp should be initialized.
    - Normal addressing mode.
  
Test Execution: 
    01: Check that CanTp_NonIdleChannelCounter is equal to 0
        (no transmission or reception is in progress after module initialization)
    02: 02: Call CanTp_Transmit() with PduId 0 and SduLength 8 (minimum size of segmented message).
         in normal addressing mode and check that it returns E_OK.
    03: Check that CanTp_NonIdleChannelCounter is incremented to 1 (one current transmission started).
    04: Elapse a MainFunction tick.
    05: Check if PduR_CanTpCopyTxData() is called with
         TxPduId = PduRConf_PduRRoutingPath_0_PduRDestPdu_0 (PduRDestPduHandleId of PduRDestPdu_0
                   which is referenced to Pdu that is also referenced by CanTpTxNSdu0)
         SduLength = 6.
    06: Check if CanIf_Transmit() called to transmit FF with SduLength 8 and 6 data bytes.
    07: Check that CanTp_NonIdleChannelCounter is still 1 (one current transmission is still in progress).
    08: Call CanTp_TxConfirmation() to confirm transmission of FF.
    09: Check that CanTp_NonIdleChannelCounter is still 1 (one current transmission is still in progress).
    10: Simulate the reception of FC CTS frame with PduId 9.
    11: Check if PduR_CanTpCopyTxData() is called with SduLength 2.
    12: Check if CanIf Transmit() is called to transmit CF with SduLength 3.
    13: Check that CanTp_NonIdleChannelCounter is still 1 (one current transmission is still in progress).
    14: Call CanTp_TxConfirmation() to confirm transmission of CF.
    15: Check if PduR_CanTpTxConfirmation is called with
         TxPduId = PduRConf_PduRRoutingPath_0_PduRDestPdu_0(PduRDestPduHandleId of PduRDestPdu_0
                   which is referenced to Pdu that is also referenced by CanTpTxNSdu0)
         Result = E_OK.
    16: Check that CanTp_NonIdleChannelCounter is decremented to 0 (Transmission is done and all channels are idle again).
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.IdleChannels</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>665</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1613</internalId></specobject>
    <specobject>
      <id>TS_CANTP_SF_Reception</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_Impl_2/source/application/Tests.c</sourcefile>
      <sourceline>332</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test CanTp_NonIdleChannelCounter values while reception of a Single Frame (before, during, after)
  
Test Object: 
    Single Frame reception
  
Test Precondition: 
    - Padding disabled
    - CanTp should be initialized.
    - Normal addressing mode.
  
Test Execution: 
    01: Check that CanTp_NonIdleChannelCounter is equal to 0
        (no transmission or reception is in progress after module initialization).
    02: Start reception of a single message. Simulate Single Frame and Check that the
        reception request is accepted as CanTp is in CANTP_ON state.
    03: Check that CanTp_NonIdleChannelCounter is still 0 after reception of a single frame
        (The channels are free again).
    04: Check that the data is properly reassembled after reception.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.IdleChannels</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>665</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1614</internalId></specobject>
    <specobject>
      <id>TS_CANTP_MF_Reception</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_Impl_2/source/application/Tests.c</sourcefile>
      <sourceline>422</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test CanTp_NonIdleChannelCounter values while reception of a Multiple message frames (before, during, after)
  
Test Object: 
    Multiple frames reception
  
Test Precondition: 
    - Padding disabled
    - CanTp should be initialized.
    - Normal addressing mode.
  
Test Execution: 
    01: Check that CanTp_NonIdleChannelCounter is equal to 0
        (no transmission or reception is in progress after module initialization).
    02: Start reception of a segmented message. Simulate First Frame and verify that the
        reception request is accepted as CanTp is in CANTP_ON state.
    03: Check that CanTp_NonIdleChannelCounter is incremented to 1 (one current reception started).
    04: simulate sent FC.
    05: Check if Flow Control Frame via a call for CanIf_Transmit.
    06: Check that CanTp_NonIdleChannelCounter is still 1 (one current reception is in progress).
    07: Start reception for the CF.
    08: Check that the data is properly reassembled after reception.
    09: Check that CanTp_NonIdleChannelCounter is decremented to 0 (reception is done and all channels are idle again).
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.IdleChannels</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>665</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1615</internalId></specobject>
    <specobject>
      <id>TS_CANTP_MF_Transmission_and_Reception</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_Impl_2/source/application/Tests.c</sourcefile>
      <sourceline>541</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test CanTp_NonIdleChannelCounter values while:
    transmission for Multiple message frames on channel 0 and
    reception of a Multiple message frames on channel 1
  
Test Object: 
    Multiple frames transmission and reception on different channels.
  
Test Precondition: 
    - Padding disabled
    - CanTp should be initialized.
    - Normal addressing mode.
  
Test Execution: 
    01: (Rx_session) Check that CanTp_NonIdleChannelCounter is equal to 0
                     (no transmission or reception is in progress after module initialization).
    02: (Rx_session) Start reception of a segmented message. Simulate First Frame and verify that the
                     reception request is accepted as CanTp is in CANTP_ON state.
    03: (Rx_session) Check that CanTp_NonIdleChannelCounter is incremented to 1 (one current reception started).
    04: (Rx_session) simulate sent FC.
    05: (Rx_session) Check if Flow Control Frame via a call for CanIf_Transmit.
    06: (Rx_session) Check that CanTp_NonIdleChannelCounter is still 1 (one current reception is in progress).
    07: (Tx_session) Call CanTp_Transmit() with PduId 9 and SduLength 8 (minimum size of segmented message)
                     in normal addressing mode and check that it returns E_OK.
    08: (Tx_session) Check that CanTp_NonIdleChannelCounter is incremented to 2 (two channels has ongoing session).
    09: (Tx_session) Elapse a MainFunction tick.
    10: (Tx_session) Check if PduR_CanTpCopyTxData() is called with
             TxPduId = PduRConf_PduRRoutingPath_9_PduRDestPdu_0 (PduRDestPduHandleId of PduRDestPdu_0
                       which is referenced to Pdu that is also referenced by CanTpTxNSdu0)
             SduLength = 6.
    11: (Tx_session) Check if CanIf_Transmit() called to transmit FF with SduLength 8 and 6 data bytes.
    12: (Tx_session) Check that CanTp_NonIdleChannelCounter is still 2 (two channels has ongoing session).
    13: (Tx_session) Call CanTp_TxConfirmation() to confirm transmission of FF.
    14: (Tx_session) Check that CanTp_NonIdleChannelCounter is still 1 (one current transmission is still in progress).
    15: (Tx_session) Simulate the reception of FC CTS frame.
    16: (Tx_session) Check if PduR_CanTpCopyTxData() is called with SduLength 2.
    17: (Tx_session) Check if CanIf Transmit() is called to transmit CF with SduLength 3.
    18: (Tx_session) Check that CanTp_NonIdleChannelCounter is still 1 (one current transmission is still in progress).
    19: (Rx_session) Start reception for the CF.
    20: (Rx_session) Check that the data is properly reassembled after reception.
    21: (Rx_session) Check that CanTp_NonIdleChannelCounter is decremented to 1
                     (reception is done and one channel only is still not Idle).
    22: (Tx_session) Call CanTp_TxConfirmation() to confirm transmission of CF.
    23: (Tx_session) Check if PduR_CanTpTxConfirmation is called with
             TxPduId = PduRConf_PduRRoutingPath_9_PduRDestPdu_0(PduRDestPduHandleId of PduRDestPdu_0
                       which is referenced to Pdu that is also referenced by CanTpTxNSdu0)
             Result = E_OK.
    24: (Tx_session) Check that CanTp_NonIdleChannelCounter is decremented to 0 (all channels are idle again).
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.IdleChannels</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>665</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1616</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_DedicatedMF_uninitialized</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_Impl_Dedicated_MainFunctions/source/application/Tests.c</sourcefile>
      <sourceline>67</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that nothing happens if CanTp_MainFunction() is called before CanTp_Init().
  
Test Object: 
  
Test Precondition: 
  
Test Execution: 
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.Multicore.MainFunctions_name</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>799</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1617</internalId></specobject>
    <specobject>
      <id>TS_CANTP_DedicatedMF_Transmission</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_Impl_Dedicated_MainFunctions/source/application/Tests.c</sourcefile>
      <sourceline>107</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    Check that transmission of a NSdu will be handled only by the specific main function.
  
Test Object: 
    Transmit NSdu with id 0 and see that it is handled by CanTp_MainFunction_CanTpChannelProcessing_0().
    Transmit NSdu with id 0 and see that it is NOT handled by CanTp_MainFunction_CanTpChannelProcessing_1() or CanTp_MainFunction().
  
Test Precondition: 
  
Test Execution: 
    01.Start transmission of a FF which should be processed by CanTp_MainFunction_CanTpChannelProcessing_0().
    02.Check that frame transmission ended with success.
    03.Start transmission of a FF which should be processed by CanTp_MainFunction_CanTpChannelProcessing_0().
    04.Check that frame was not processed neither by CanTp_MainFunction_CanTpChannelProcessing_1() or CanTp_MainFunction().
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.Multicore.MainFunctions_name</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>799</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Multicore.MainFunctions_handling</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>800</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Multicore.MainFunctions_1_handling</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>801</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1618</internalId></specobject>
    <specobject>
      <id>TS_CANTP_DedicatedMF_Transmission_ClassicMF</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_Impl_Dedicated_MainFunctions/source/application/Tests.c</sourcefile>
      <sourceline>209</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    Check that transmission of a NSdu which is not mapped to any Dedicated Main Function
    will be handled only by the classic CanTp_Mainfunction().
  
Test Object: 
    Transmit NSdu with id 2 and see that it is handled by CanTp_MainFunction().
    Transmit NSdu with id 2 and see that it is NOT handled by CanTp_MainFunction_CanTpChannelProcessing_0() or CanTp_MainFunction_CanTpChannelProcessing_1().
  
Test Precondition: 
  
Test Execution: 
    01.Start transmission of a FF which is not mapped to any Dedicated Main Function and should be processed by classic CanTp_MainFunction().
    02.Check that frame transmission ended with success.
    03.Start transmission of a FF which is not mapped to any Dedicated Main Function and should be processed by classic CanTp_MainFunction().
    04.Check that frame was not processed neither by CanTp_MainFunction_CanTpChannelProcessing_0()
       or CanTp_MainFunction_CanTpChannelProcessing_1().
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.Multicore.MainFunctions_name</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>799</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Multicore.MainFunctions_handling</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>800</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Multicore.MainFunctions_1_handling</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>801</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1619</internalId></specobject>
    <specobject>
      <id>TS_CANTP_DedicatedMF_Reception</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_Impl_Dedicated_MainFunctions/source/application/Tests.c</sourcefile>
      <sourceline>316</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    Check that buffer for reception of a NSdu is requested only by the specific main function.
  
Test Object: 
    Start reception if NSdu with id 1 and see that buffer request is handled by CanTp_MainFunction_CanTpChannelProcessing_1().
    Start reception if NSdu with id 1 and see that buffer request is NOT handled by CanTp_MainFunction_CanTpChannelProcessing_0() or CanTp_MainFunction().
  
Test Precondition: 
  
Test Execution: 
    01. Make no buffer available for reception.
    02. Start reception of a FF.
    03. Call CanTp_MainFunction_CanTpChannelProcessing_1() in order to see that buffer is requested on each call.
    04. Make buffer available for reception.
    05. Check that buffer is not requested on CanTp_MainFunction_CanTpChannelProcessing_0() and CanTp_MainFunction() calls.
    06. Call CanTp_MainFunction_CanTpChannelProcessing_1() in order to see that buffer is requested and FC transmission is triggered.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.Multicore.MainFunctions_name</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>799</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Multicore.MainFunctions_handling</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>800</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Multicore.MainFunctions_1_handling</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>801</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1620</internalId></specobject>
    <specobject>
      <id>TS_CANTP_DedicatedMF_Timeout</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_Impl_Dedicated_MainFunctions/source/application/Tests.c</sourcefile>
      <sourceline>404</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that after few Dedicated Main Function cycles are elapsed, a timeout will occur.
  
Test Object: 
    Transmit NSdu with id 0 and see that it is handled by CanTp_MainFunction_CanTpChannelProcessing_0().
    Elapse few CanTp_MainFunction_CanTpChannelProcessing_0 cycles and see that this will lead to a timeout.
  
Test Precondition: 
  
Test Execution: 
    01.Start transmission of a FF which should be processed by CanTp_MainFunction_CanTpChannelProcessing_0().
    02.Elapse few CanTp_MainFunction_CanTpChannelProcessing_0() and see that this will lead to N_As timeout.
    03.Start transmission of a FF which should be processed by CanTp_MainFunction_CanTpChannelProcessing_0().
    04.Elapse the same amount of CanTp_MainFunction_CanTpChannelProcessing_1() and CanTp_MainFunction() as above
       and check that timeout wasn't triggered.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.Multicore.MainFunctions_name</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>799</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Multicore.MainFunctions_handling</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>800</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Multicore.MainFunctions_1_handling</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>801</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1621</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_FullDuplex_Different_N_AI</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_Impl_FullDuplex/source/application/Tests.c</sourcefile>
      <sourceline>109</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the SF received while channel is locked(during buffer request for last CF)
    is accepted and handled after the ongoing reception is completed.
  
Test Object: 
    Rx post processing
  
Test Precondition: 
    - CanTp initialized
    - CanTpRxNSdu_FD3_1 and CanTpRxNSdu_FD3_2 should be configured for same channel
    - CanTpRxNSdu_FD3_1 and CanTpRxNSdu_FD3_2 configured for extended address type
    - Channel should be configured as FULL DUPLEX
  
Test Execution: 
    01: Indicate reception of FF on CanTpRxNSdu_FD3_1 (5 bytes sent, 12 to go).
    02: Verify the PduR calls for buffer requests and the FC frame transmitted
    03: Confirm the FC frame sent.
    04. Indicate reception of first CF to CAN TP (5+6 bytes sent, 6 to go).
    05: Receive a SF on CanTpRxNSdu_FD3_2 with message length 4 while channel is locked.
    06: VP(CanTp.SWS_CanTp_00124_Diff_N_AI):
        Check if SF reception is ignored.
    07: Receive a FF on CanTpRxNSdu_FD3_2 with message length 10 while channel is locked.
    08: VP(CanTp.SWS_CanTp_00124_Diff_N_AI):
        Check if FF reception is ignored.
    09: Indicate reception of last CF to CAN TP (5+6+6 bytes sent, 0 to go).
    10: Check that PduR is notified about successful reception on CanTpRxNSdu_FD3_1.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00124_Diff_N_AI</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>250</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1622</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_40073</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_Impl_JtServ_AllFunc/source/application/Tst_40073.c</sourcefile>
      <sourceline>53</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Perform a segmented message transmission via the Gpt channel. In this way check, that the
    following funcitons are correctly called via the default exit jump table:
    - CanIf_Transmit
    - PduR_CanTpCopyTxData
    - PduR_CanTpTxConfirmation
    - Gpt_StartTimer

    To trigger the Gpt callback, also the corresponding entry for CanTp_STminCallback is called via
    the entry jump table.
  
Test Object: 
    Exit jump table
  
Test Precondition: 
    CanTp is initialized and the used channel is idle.
  
Test Execution: 
    01: Start a segmented transmission with a valid Tx N-SDU
        using the entry jump table. Using the entry table proves the
        existence.
    02: Invoke CanTp_MainFunction to start the transmission.
    03: Check if PduR_CanTpCopyTxData was called.
    04: Check if CanIf_Transmit was called for the first frame.
    05: Check the sent header for addressing format.
    06: Confirm the FF sent.
    07: Transmit the remaining frames.
    08: Check if Gpt_StartTimer is called for CFs.
    09: Check if PduR_CanTpTxConfirmation was called at end of transmission.
  
Test Input: 
  
Test Output: 
   VP(CanTp.JTM_0001): All APIs are called via entry table to perform
   a successful transmission.
   VP(CanTp.JTM_0011): The server uses the upper layer callback
   functions defined in the exit table (TstJt_...).
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.JTM_0001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>918</internalId></provcov>
        <provcov>
          <linksto>CanTp.JTM_0011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>928</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1623</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_40074</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_Impl_JtServ_AllFunc/source/application/Tst_40074.c</sourcefile>
      <sourceline>53</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that the following APIs are correctly called via the entry jump table:
    - CanTp_GetVersionInfo
    - CanTp_Transmit
    - CanTp_CancelTransmit
    - CanTp_MainFunction
    - CanTp_RxIndication
    - CanTp_TxConfirmation
    - CanTp_GetNSa
    - CanTp_SetNSa

    Furthermore check that Det_ReportError is correctly called via the default exit jump table.
  
Test Object: 
    Entry jump table
  
Test Precondition: 
    CanTp is not initialized.
  
Test Execution: 
    01: Call CanTp_GetVersionInfo with NULL pointer via entry jump table and check that Det error
        CANTP_E_PARAM_POINTER is reported.
    02: Call CanTp_Transmit via entry jump table and check that
        Det error TST_CANTP_E_UNINIT is reported.
    03: Call CanTp_CancelTransmit via entry jump table and check that Det error
        CANTP_E_UNINIT is reported.
    04: Call CanTp_MainFunction via entry jump table and check that no Det error is reported.
    05: Call CanTp_RxIndication via entry jump table and check that Det error
        CANTP_E_UNINIT is reported.
    06: Call CanTp_TxConfirmation via entry jump table and check that Det error
        CANTP_E_UNINIT is reported.
    07: Call CanTp_GetNSa via entry jump table and check that Det error
        CANTP_E_UNINIT is reported.
    08: Call CanTp_SetNSa via entry jump table and check that Det error
        CANTP_E_UNINIT is reported.
  
Test Input: 
  
Test Output: 
    VP(CanTp.JTM_0000): All function calls are performed via entry table.
    This proves the existence of the entry table.
    VP(CanTp.JTM_0001): All APIs are provided via entry table.
    VP(CanTp.JTM_0010, CanTp.JTM_0011): The server uses the upper layer callback
    functions defined in the exit table (TstJt_...). This proves the existence of the exit table.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.JTM_0000</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>917</internalId></provcov>
        <provcov>
          <linksto>CanTp.JTM_0001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>918</internalId></provcov>
        <provcov>
          <linksto>CanTp.JTM_0010</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>927</internalId></provcov>
        <provcov>
          <linksto>CanTp.JTM_0011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>928</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1624</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_40075</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_Impl_JtServ_AllFunc/source/application/Tst_40075.c</sourcefile>
      <sourceline>53</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Initialize the CanTp via the entry jump table.

    This also checks that the following functions are correctly called via the default exit jump table:
    - SchM_Enter_CanTp
    - SchM_Exit_CanTp
    - Gpt_EnableNotification
  
Test Object: 
    Entry jump table
  
Test Precondition: 
  
Test Execution: 
    01: Check that the CanTp jump table server is uninitialized.
    02: VP(CanTp.JTM_0001, CanTp.JTM_0027)
        Call CanTp_Init via the entry jump table.
    03: Check that CanTp jump table server is initialized.
    04: VP(CanTp.JTM_0011):
        Check if SchM Enter and Exit calls are correctly made via exit jump table.
    05: VP(CanTp.JTM_0011):
        Check if Gpt_EnableNotification is called for each CanTp channel via exit jump table.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.JTM_0001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>918</internalId></provcov>
        <provcov>
          <linksto>CanTp.JTM_0011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>928</internalId></provcov>
        <provcov>
          <linksto>CanTp.JTM_0027</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>945</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1625</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_40076</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_Impl_JtServ_AllFunc/source/application/Tst_40076.c</sourcefile>
      <sourceline>53</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Perform a message reception and in this way check the following calls via the default exit jump table:
    - PduR_CanTpCopyRxData
    - PduR_CanTpRxIndication
  
Test Object: 
    Exit jump table
  
Test Precondition: 
    CanTp is initialized and the used channel is idle.
  
Test Execution: 
    01: Simulate reception of FF of a segmented message.
    02: Check if PduR_CanTpStartOfReception and PduR_CanTpCopyRxData calls are made.
    03: Call MainFunction and check if CanIf_Transmit is called for FC frame with correct
        STMin and BS values.
    04: Receive CFs, check if PduR_CanTpCopyRxData is called after each CF is received.
    05: Check if PduR_CanTpRxIndication is called after the last CF is successfully received.
  
Test Input: 
  
Test Output: 
    VP(CanTp.JTM_0011) The server uses the upper layer callback
    functions defined in the exit table (TstJt_...).
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.JTM_0011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>928</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1626</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_40077</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_Impl_JtServ_AllFunc/source/application/Tst_40077.c</sourcefile>
      <sourceline>53</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Start a segmented message transmission and stop it while waiting for the Gpt
    STmin callback.
    This test shall test that the following functions are correctly called via the default exit jump table:
    - Gpt_StopTimer
  
Test Object: 
    Exit jump table
  
Test Precondition: 
  
Test Execution: 
    01: Start a segmented transmission with a valid Tx N-SDU.
    02: Call CanTp_MainFunction to start the transmission.
    03: Check if FF is transmitted and confirm FF sent.
    04: Indicate reception of the first flow control frame.
    05: Check if the first CF was sent and confirm it.
    06: Check if the Gpt is started for STmin.
    07: Call the internal function CanTp_StopChannel() to stop all communication.
        The CanTp state variable is set to uninitialized in order to avoid side
        effects on the testsequence.
    08: Check if Gpt_StopTimer was called and timer is stopped.
  
Test Input: 
  
Test Output: 
    VP(CanTp.JTM_0011) The server uses the upper layer callback
    functions defined in the exit table (TstJt_...).
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.JTM_0011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>928</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1627</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_40079</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_Impl_JtServ_AllFunc/source/application/Tst_40079.c</sourcefile>
      <sourceline>65</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Register a new (alternate) exit jump table for the following tests and re-initialize the
    CanTp again.
  
Test Object: 
    Exit jump table
  
Test Precondition: 
    Previous test is finished and CanTp is shut down.
  
Test Execution: 
    01: Simulate C startup -&gt; shut down CanTp and registration of an alternate jump table.
    02: VP(CanTp.JTM_0001): Call CanTp_Init via the entry jump table.
    03: Check that CanTp is initialized and CanTp_State is set to CANTP_ON.
    04: VP(CanTp.JTM_0011):
        Check if Gpt_EnableNotification is called for each CanTp channel via exit jump table.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.JTM_0001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>918</internalId></provcov>
        <provcov>
          <linksto>CanTp.JTM_0011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>928</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1628</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_40080</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_Impl_JtServ_AllFunc/source/application/Tst_40080.c</sourcefile>
      <sourceline>53</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Initialize the CanTp via the entry jump table (same as TS_CANTP_40075).
  
Test Object: 
    Entry jump table
  
Test Precondition: 
  
Test Execution: 
    See TS_CANTP_40075.
  
Test Input: 
  
Test Output: 
    In general, see TS_CANTP_40075.
    The external functions are called via the alternate exit jump table.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.JTM_0011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>928</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1629</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_40081</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_Impl_JtServ_AllFunc/source/application/Tst_40081.c</sourcefile>
      <sourceline>53</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Perform a segmented message transmission via the Gpt channel (same as TS_CANTP_40073)
    with an other exit jump table.
  
Test Object: 
    Exit jump table
  
Test Precondition: 
    See TS_CANTP_40073
  
Test Execution: 
    See TS_CANTP_40073
  
Test Input: 
  
Test Output: 
    In general, see TS_CANTP_40073.
    The external functions are called via the alternate exit jump table.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.JTM_0011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>928</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1630</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_40083</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_Impl_JtServ_AllFunc/source/application/Tst_40083.c</sourcefile>
      <sourceline>53</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Perform a message reception (same as TS_CANTP_40076).
  
Test Object: 
    Exit jump table
  
Test Precondition: 
    See TS_CANTP_40076
  
Test Execution: 
    See TS_CANTP_40076
  
Test Input: 
  
Test Output: 
    In general, see TS_CANTP_40076.
    The external functions are called via the alternate exit jump table.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.JTM_0011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>928</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1631</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_40084</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_Impl_JtServ_AllFunc/source/application/Tst_40084.c</sourcefile>
      <sourceline>53</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    Start a segmented message transmission and stop it while waiting for the Gpt STmin callback (same as TS_CANTP_40077).
  
Test Object: 
    Exit jump table
  
Test Precondition: 
    See TS_CANTP_40077
  
Test Execution: 
    See TS_CANTP_40077
  
Test Input: 
  
Test Output: 
    In general, see TS_CANTP_40077.
    The external functions are called via the alternate exit jump table.
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.JTM_0011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>928</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1632</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_40085</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_Impl_JtServ_AllFunc/source/application/Tst_40085.c</sourcefile>
      <sourceline>53</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that Det_ReportError is correctly called via the exit jump table (same as TS_CANTP_40074).
  
Test Object: 
    Exit jump table
  
Test Precondition: 
    See TS_CANTP_40074
  
Test Execution: 
    See TS_CANTP_40074.
  
Test Input: 
  
Test Output: 
    In general, see TS_CANTP_40074.
    The external functions are called via the alternate exit jump table.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.JTM_0011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>928</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1633</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_40088</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_Impl_JtServ_AllFunc/source/application/Tst_40088.c</sourcefile>
      <sourceline>35</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Perform a call to API service CanTp_CancelReceive and check the call to
    PduR_CanTpRxIndication via the default exit jump table.
  
Test Object: 
    Exit jump table
  
Test Precondition: 
    CanTp is initialized.
  
Test Execution: 
    01: PduR_CanTpCopyRxData shall return BUFREQ_E_BUSY.
    02: Indicate reception of segmented message.
    03: Call CanTp_CancelReceive and check that it returns E_OK.
    04: VP(CanTp.ASR40.CancelReceive.RxIndication):
        Check if PduR_CanTpRxIndication was called with E_NOT_OK.
    05: Check if Det error is reported.
    06: PduR_CanTpCopyRxData shall have enough buffer.
    07: Indicate reception of segmented message.
    08: Call CanTp_CancelReceive and check that it returns E_NOT_OK.
    09: Check if PduR_CanTpRxIndication is not called.
    10: Indicate the reception of two CFs.
    11: Check if PduR_CanTpRxIndication is called after successful reception.
  
Test Input: 
  
Test Output: 
    VP(CanTp.JTM_0011) The server uses the upper layer callback
    functions defined in the exit table (TstJt_...).
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.JTM_0011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>928</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.CancelReceive.RxIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>523</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1634</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_40100</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_Impl_JtServ_AllFunc/source/application/Tst_40100.c</sourcefile>
      <sourceline>35</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Perform a call to API service CanTp_CancelReceive and check the call to
    PduR_CanTpRxIndication via the alternate exit jump table.
  
Test Object: 
    Exit jump table
  
Test Precondition: 
    CanTp is initialized.
  
Test Execution: 
    01: PduR_CanTpCopyRxData shall return BUFREQ_E_BUSY.
    02: Indicate reception of segmented message.
    03: Call CanTp_CancelReceive and check that it returns E_OK.
    04: VP(CanTp.ASR40.CancelReceive.RxIndication):
        Check if PduR_CanTpRxIndication was called with E_NOT_OK.
    05: Check if Det error is reported.
    06: PduR_CanTpCopyRxData shall have enough buffer.
    07: Indicate reception of segmented message.
    08: Call CanTp_CancelReceive and check that it returns E_NOT_OK.
    09: Check if PduR_CanTpRxIndication is not called.
    10: Indicate the reception of two CFs.
    11: Check if PduR_CanTpRxIndication is called after successful reception.
  
Test Input: 
  
Test Output: 
    VP(CanTp.JTM_0011) The server uses the upper layer callback
    functions defined in the exit table (TstJt_...).
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.JTM_0011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>928</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.CancelReceive.RxIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>523</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1635</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_Transmit_SF_ParallelChannelsHandling</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_Impl_ParallelChannels/source/application/Tests.c</sourcefile>
      <sourceline>146</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks three transmission scenarios:
     1. Upper layer asks CanTp module for a transmission and all parallel channels are free
        =&gt; transmission will take place and parallel channels will be used consecutively
     2. Upper layer asks CanTp module for a transmission of a CAN-FD SF and all parallel channels are busy
        =&gt; transmission is canceled
     3. Upper layer asks CanTp for a transmission of a CAN-FD SF and at least one parallel channel is released
        =&gt; transmission will take place and the first released parallel channel will be used
  
Test Object: 
    The purpose of this test is to check SF transmission in all the following scenarios:
      1. Transmission when all parallel channels are free
      2. Transmission when all parallel channels are busy
      3. Transmission when at least one parallel channel is released
  
Test Precondition: 
    CanTp module shall be initialized
    Maximum number of Tx parallel channels shall be greater than 1
    Maximum number of Rx parallel channels shall be greater than 1
  
Test Execution: 
    01: Initialization phase
    02: Try to send all 4 CAN-FD SFs from all 4 configured channels
    03: Call CanTp_MainFunction triggering data to be sent.
    04: Check that CanTp requests available buffer for SF (CAN FD) from channel 1
        by calling PduR_CanTpCopyTxData()
    05: Check that CanIf_Transmit() was called for Single Frame transmission on parallel channel 1
    06: Check that CanTp requests available buffer for SF (CAN FD) from channel 0
        by calling PduR_CanTpCopyTxData
    07: Check that CanIf_Transmit() was called for Single Frame transmission on parallel channel 0
    08: Check that SF from channel 2 and channel 3 were not transmitted,
        because all Tx parallel channels were busy
    09: TxConfirmation for SF from channel 1 arrives, parallel channel 1 will be released
    10: Check that PduR_CanTpTxConfirmation was called
    11: Try to send the last SFs from channel 2 and 3
    12: Call CanTp_MainFunction triggering data to be sent.
    13: Check that CanTp requests available buffer for SF (CAN FD) from channel 2
        by calling PduR_CanTpCopyTxData
    14: Check that for the next SF transmission,
        the first released channel will be used (channel 1 from the maximum number of 2 parallel channels)
    15: Check that SF from channel 3 was not transmitted,
        because just one channel was freed, and that channel was used
        for the transmission of the SF from channel 2
    16: TxConfirmation for SF from channel 0 arrives, parallel channel 0 will be released
    17: Check that PduR_CanTpTxConfirmation was called for SF from parallel channel 0
    18: TxConfirmation for SF from channel 2 arrives, parallel channel 1 will also be released
    19: Check that PduR_CanTpTxConfirmation was called for SF from parallel channel 1
    20: Prepare length and SduData for the last SF transmission from channel 3
    21: Call CanTp_MainFunction triggering data to be sent.
    22: Check that CanTp requests available buffer for SF (CAN FD) from channel 3 by calling PduR_CanTpCopyTxData
    23: Check that for the transmission of SF from channel 3,
        if at least one channel will be released, the first freed one will be used
        (in out case channel 0 will be used)

  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.Transmission.AllParallelChannelsFree</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>698</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Transmission.AllParallelChannelsBusy</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>696</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Transmission.AtLeastOneParallelChannelFree</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>697</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1636</internalId></specobject>
    <specobject>
      <id>TS_CANTP_Transmit_MF_ParallelChannelsHandling</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_Impl_ParallelChannels/source/application/Tests.c</sourcefile>
      <sourceline>365</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks three transmission scenarios:
     1. Upper layer asks CanTp module for transmission of MFs and all parallel channels are free
        =&gt; transmission will take place and parallel channels will be used consecutively
     2. Upper layer asks CanTp module for a transmission of a CAN-FD MF and all parallel channels are busy
        =&gt; transmission is canceled
     3. Upper layer asks CanTp for a transmission of a CAN-FD MF and at least one parallel channel is released
        =&gt; transmission will take place and the first released parallel channel will be used
  
Test Object: 
    The purpose of this test is to check FF transmission in all the following scenarios:
      1. Transmission when all parallel channels are free
      2. Transmission when all parallel channels are busy
      3. Transmission when at least one parallel channel is released
  
Test Precondition: 
    CanTp module shall be initialized
    Maximum number of Tx parallel channels shall be greater than 1
    Maximum number of Rx parallel channels shall be greater than 1
  
Test Execution: 
    01: Initialization phase
    02: Try to send all 4 CAN 2.0 MFs from all 4 configured channels
    03: Call CanTp_MainFunction triggering data to be sent.
    04: Check that CanTp requests available buffer for MF (CAN FD) from channel 1
        by calling PduR_CanTpCopyTxData
    05: Check that CanIf_Transmit() was called for MF transmission on parallel channel 1
    06: Check that CanTp requests available buffer for MF (CAN FD) from channel 0 by calling PduR_CanTpCopyTxData
    07: Check that CanIf_Transmit() was called for MF transmission on parallel channel 0
    08: Check that MF from channel 2 and channel 3 were not transmitted,
        because all Tx parallel channels were busy
    09: Confirm sent MF from channel 0
    10: Send a FC to CAN TP informing it no more FCs will be sent during transmission.
    11: Verify that PduR_CanTpCopyTxData() is called with correct parameters.
    12: Check if CanIf_Transmit() is called with correct parameters for the first CF from parallel channel 1
    13: Confirmation for CF1 arrives, send next CF on parallel channel 1
    14: Check that PduR_CanTpCopyTxData was called for CF
    15: Check that next CF was transmitted, on parallel channel 1
    16: Confirm sent CF
    17: Check CanIf is called with correct L-SDU ID, frame type and serial number.
    18: Confirm last sent CF, parallel channel 1 is released
    19: Notify PduR that multi-frame from parallel channel 1, was send successfully by calling PduR_CanTpTxConfirmation
    20: Try to send MFs from configured channels 2 and 3
    21: Call MainFunction to trigger transmission of multi-frame, on recently released parallel channel 1
    22: Check that CanTp requests available buffer only for FF (CAN FD) from configured channel 2
        by calling PduR_CanTpCopyTxData
    23: Check that CanIf_Transmit() was called for multiple frame transmission on parallel channel 1
    24: Check that CanIf_Transmit was not called for MF from configured channel 3,
        because all 2 parallel channels were busy
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.Transmission.AllParallelChannelsFree</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>698</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Transmission.AllParallelChannelsBusy</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>696</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Transmission.AtLeastOneParallelChannelFree</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>697</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1637</internalId></specobject>
    <specobject>
      <id>TS_CANTP_Transmit_MF_ParallelChannelsHandling_UseTheCorrespondingLockedChannel_FirstChannelFreeAndSecondLocked_TakesSecond</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_Impl_ParallelChannels/source/application/Tests.c</sourcefile>
      <sourceline>612</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    This test checks three transmission scenarios:
     1. Upper layer asks CanTp module for transmission of MFs and all parallel channels are free
        =&gt; transmission will take place and parallel channels will be used consecutively
     2. Upper layer asks CanTp module for a transmission of a CAN-FD MF and all parallel channels are busy
        =&gt; transmission is canceled
     3. Upper layer asks CanTp for a transmission of a CAN-FD MF and at least one parallel channel is released
        =&gt; transmission will take place and the first released parallel channel will be used
  
Test Object: 
    The purpose of this test is to check FF transmission in all the following scenarios:
      1. Transmission when all parallel channels are free
      2. Transmission when all parallel channels are busy
      3. Transmission when at least one parallel channel is released
  
Test Precondition: 
    CanTp module shall be initialized
    Maximum number of Tx parallel channels shall be greater than 1
    Maximum number of Rx parallel channels shall be greater than 1
  
Test Execution: 
    01: Initialization phase
    02: Try to send all 4 CAN 2.0 MFs from all 4 configured channels
    03: Call CanTp_MainFunction triggering data to be sent.
    04: Check that CanTp requests available buffer for MF (CAN FD) from channel 1
        by calling PduR_CanTpCopyTxData
    05: Check that CanIf_Transmit() was called for MF transmission on parallel channel 1
    06: Check that CanTp requests available buffer for MF (CAN FD) from channel 0 by calling PduR_CanTpCopyTxData
    07: Check that CanIf_Transmit() was called for MF transmission on parallel channel 0
    08: Check that MF from channel 2 and channel 3 were not transmitted,
        because all Tx parallel channels were busy
    09: Confirm sent MF from channel 0
    10: FC is received for channel 0
    11: Verify that PduR_CanTpCopyTxData() is called with correct parameters.
    12: Check if CanIf_Transmit() is called with correct parameters for the first CF from parallel channel 0
    13: Confirmation for CF1 arrives, send next CF on parallel channel 0
    14: Check that PduR_CanTpCopyTxData was called for CF
    15: Check that next CF was transmitted, on parallel channel 0
    16: Confirm last sent CF, parallel channel 0 is released
    17: Check CanIf is called with correct L-SDU ID, frame type and serial number.
    18: Confirm last sent CF, parallel channel 0 is released
    19: Notify PduR that multi-frame from parallel channel 0, was send successfully by calling PduR_CanTpTxConfirmation =&gt; channel 0 is free now
    20: TxConfirmation for channel 1 arrives
    21: FC for channel 1 is received
    22: PduR_CanTpCopyTxData() is called for CF1 from channel 1
    23: Check if CanIf_Transmit() is called with correct parameters for the first CF from parallel channel 1
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.Transmission.AllParallelChannelsFree</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>698</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Transmission.AllParallelChannelsBusy</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>696</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Transmission.AtLeastOneParallelChannelFree</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>697</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1638</internalId></specobject>
    <specobject>
      <id>TS_CANTP_Transmit_MF_ParallelChannelsHandling_UseTheCorrespondingLockedChannel_FirstChannelLockedAndSecondFree_TakesFirst</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_Impl_ParallelChannels/source/application/Tests.c</sourcefile>
      <sourceline>838</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    This test checks three transmission scenarios:
     1. Upper layer asks CanTp module for transmission of MFs and all parallel channels are free
        =&gt; transmission will take place and parallel channels will be used consecutively
     2. Upper layer asks CanTp module for a transmission of a CAN-FD MF and all parallel channels are busy
        =&gt; transmission is canceled
     3. Upper layer asks CanTp for a transmission of a CAN-FD MF and at least one parallel channel is released
        =&gt; transmission will take place and the first released parallel channel will be used
  
Test Object: 
    The purpose of this test is to check FF transmission in all the following scenarios:
      1. Transmission when all parallel channels are free
      2. Transmission when all parallel channels are busy
      3. Transmission when at least one parallel channel is released
  
Test Precondition: 
    CanTp module shall be initialized
    Maximum number of Tx parallel channels shall be greater than 1
    Maximum number of Rx parallel channels shall be greater than 1
  
Test Execution: 
    01: Initialization phase
    02: Try to send all 4 CAN 2.0 MFs from all 4 configured channels
    03: Call CanTp_MainFunction triggering data to be sent.
    04: Check that CanTp requests available buffer for MF (CAN FD) from channel 1
        by calling PduR_CanTpCopyTxData
    05: Check that CanIf_Transmit() was called for MF transmission on parallel channel 1
    06: Check that CanTp requests available buffer for MF (CAN FD) from channel 1 by calling PduR_CanTpCopyTxData
    07: Check that CanIf_Transmit() was called for MF transmission on parallel channel 1
    08: Check that MF from channel 2 and channel 3 were not transmitted,
        because all Tx parallel channels were busy
    09: Confirm sent MF from channel 1
    10: FC is received for channel 1
    11: Verify that PduR_CanTpCopyTxData() is called with correct parameters.
    12: Check if CanIf_Transmit() is called with correct parameters for the first CF from parallel channel 1
    13: Confirmation for CF1 arrives, send next CF on parallel channel 1
    14: Check that PduR_CanTpCopyTxData was called for CF
    15: Check that next CF was transmitted, on parallel channel 1
    16: Confirm last sent CF, parallel channel 1 is released
    17: Check CanIf is called with correct L-SDU ID, frame type and serial number.
    18: Confirm last sent CF, parallel channel 1 is released
    19: Notify PduR that multi-frame from parallel channel 1, was send successfully by calling PduR_CanTpTxConfirmation =&gt; channel 1 is free now
    20: TxConfirmation for channel 0 arrives
    21: FC for channel 0 is received
    22: PduR_CanTpCopyTxData() is called for CF1 from channel 0
    23: Check if CanIf_Transmit() is called with correct parameters for the first CF from parallel channel 0
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.Transmission.AllParallelChannelsFree</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>698</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Transmission.AllParallelChannelsBusy</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>696</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Transmission.AtLeastOneParallelChannelFree</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>697</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1639</internalId></specobject>
    <specobject>
      <id>TS_CANTP_ReceptionInterrupts_SegmentedTransmission</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_Impl_ParallelChannels/source/application/Tests.c</sourcefile>
      <sourceline>1065</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    This test checks following scenarios:
     - if PduR returns E_BUSY and parallel channel is free =&gt; transmission will not take place
     - if PduR return E_OK and parallel channel if free =&gt; transmission will take place
     - if a segmented transmission is interrupted by a reception =&gt; reception will be processed on a full duplex channel
  
Test Object: 
    The purpose of this test is to check that if a reception interrupts a segmented transmission,
	reception will be processed on a full duplex channel.
  
Test Precondition: 
    CanTp module shall be initialized
    Maximum number of Tx parallel channels shall be greater than 1
    Maximum number of Rx parallel channels shall be greater than 1
  
Test Execution: 
    01: Initialization phase
    02: Try to transmit FFs from all configured channels when all parallel channels are free,
        but PduR returns E_BUSY
    03: Call CanTp_MainFunction to trigger transmission on all 2 Tx parallel channels
    04: Check that PduR_CanTpCopyTxData was called from parallel channel 0 and 1
    05: Check that no FF was sent if PduR return E_BUSY, even if parallel channels were free
    06: Wait until N_Cs timer expires
    07: N_Cs expired, parallel channels 0 and 1 are unlocked
    08: Check that PduR was notified about the cancellation of MF from parallel channel 0
    09: Check that PduR was notified about the cancellation of MF from parallel channel 1
    10: Try to transmit FF from configured channels 2 when all parallel channels are free,
        and PduR returns E_OK
    11: Parallel channel 0 is unlocked
    12: Check that PduR_CanTpCopyTxData was called for MF from parallel channel 0
    13: Check that CanIf_Transmit was called for the MF from parallel channel 0
    14: TxConfirmation arrives for sent MF
    15: Update remaining data bytes no. to be sent to CanTp.
    16: Send a FC to CAN TP informing it no more FCs will be sent during transmission.
    17: Verify that PduR_CanTpCopyTxData() is called with correct parameters.
    18: Check if CanIf_Transmit() is called with correct parameters for the CF1 from parallel channel 0
    19: Prepare buffer for reception
    20: Call CanTp_RxIndication() for SF with id
    21: Check that PduR_CanTpStartOfReception and PduR_CanTpCopyRxData were called for SF from parallel channel 0
    22: Check that SF was accepted and that PduR was not notified about SF reception
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00167_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>202</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00280</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>207</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00226</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>25</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00057_FullDuplex_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>306</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1640</internalId></specobject>
    <specobject>
      <id>TS_CANTP_Receive_MF_ParallelChannelsHandling</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_Impl_ParallelChannels/source/application/Tests.c</sourcefile>
      <sourceline>1294</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks three reception scenarios:
     1. Lower layer notifies CanTp module about a new MF reception and all parallel channels are free
        =&gt; reception will take place and parallel channels will be used consecutively
     2. Lower layer notifies CanTp module about a new MF reception and
        all parallel channels are busy and none of them with the same NSduId
        =&gt; reception is canceled
     3. Lower layer notifies CanTp module about a new MF reception and at least one parallel channel is released
        =&gt; reception will take place and the first released parallel channel will be used
  
Test Object: 
    The purpose of this test is to check if SF reception is accepted or not in all
    of the following scenarios.
      1. Reception when all parallel channels are free
      2. Reception when all parallel channels are busy
      3. Reception when at least one parallel channel is released
  
Test Precondition: 
    CanTp module shall be initialized
    Maximum number of Tx parallel channels shall be greater than 1
    Maximum number of Rx parallel channels shall be greater than 1
  
Test Execution: 
    01: Initialization phase
    02: Try to receive all 4 CAN-FD SFs from all 4 configured channels
    03: Check that PduR_CanTpStartOfReception and PduR_CanTpCopyTxData were called
    04: Check that CanIf_Transmit was called for the FC from parallel channel 0
    05: Check that PduR_CanTpStartOfReception and PduR_CanTpCopyRxData were called
        for MF from parallel channels 1
    06: Check that CanIf_Transmit was called for the FC from parallel channel 1
    07: Check that FCs corresponding to configured channel 2 and 3 were not transmitted,
        because all parallel channels were busy
    08: TxConfirmation for FC from parallel channel 1 arrives
    09: Update remaining data bytes no. to be sent to CanTp.
    10: Call CanTp_RxIndication for CFs from parallel channel 1
    11: Check that CopyRxData was called for each CF
    12: Received last CF from parallel channel 1
    13: Check that PduR_CanTpCopyRxData was called for last CF
    14: Check that PduR was notified about a successful MF reception using parallel channel 2
    15: Parallel channel 1 is free now, try to process the next received MF from configured channel 2
    16: Call PduR_CanTpCopyRxData for MF from last configured channel
    17: Check that CanIf_Transmit was called for MF from the configured channel 2 and the
        the channel used for the transmission is the recently released parallel channel 1
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.Reception.AllParallelChannelsFree</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>701</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Reception.AllParallelChannelsBusy</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>699</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Reception.AtLeastOneParallelChannelFree</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>700</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1641</internalId></specobject>
    <specobject>
      <id>TS_CANTP_WaitingSTmin_CancelTransmit_Ignored</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_Impl_ParallelChannels/source/application/Tests.c</sourcefile>
      <sourceline>1529</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that CanTp_CancelTransmit will cancel the transmission while waiting for STmin and when
    CanTpSTminTimeoutHandling is controlled by CanTp_MainFunction.
  
Test Object: 
    STmin handling
  
Test Precondition: 
    CanTp should be initialized.
    Gpt usage should be enabled.
    Configure CanTpMainFunction for STmin timeout handling for CanTpChannel_1.
  
Test Execution: 
    01: Simulate transmission of FF with message length 20 bytes.
    02: Call CanTp_MainFunction.
    03: Check that the FF has been sent correctly.
    04: Confirm the FF.
    05: Send the FC frame so that CAN TP continues the transfer.
    06: Verify that CAN TP has sent the first CF.
    07: Confirm the CF.
    08: VP(CanTp.EB.MainFunction.STminHandling_1):
        Call CanTp_MainFunction and verify that no CF is transmitted as CanTp has to wait for
        STmin.
    09: Call CanTp_CancelTransmit while waiting for STmin to cancel the transmission
        and verify that it is accepted.
    10: VP(CanTp.SWS_CanTp_00274, CanTp.SWS_CanTp_00243):
        Check whether transmission got cancelled and PduR is notified with E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.MainFunction.STminHandling_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>551</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00274</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>145</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00243</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>146</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1642</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_Impl_RxConfigLength/source/application/Tests.c.m4</sourcefile>
      <sourceline>74</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
      Test that a received frame with length equal to the one configured in EcuC is accepted successfully.
  
Test Object: 
  
Test Precondition: 
  
Test Execution: 
    01: Start multiframe reception and check that it was received successfully.
    02: Check that FF reception has triggered a FC transmission.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanTpFixedRxPduLengthSupport_Enabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>810</internalId></provcov>
        <provcov>
          <linksto>CanTp.ISO2016.InvalidFF_DL</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>902</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1643</internalId></specobject>
    <specobject>
      <id>TS_CANTP_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_Impl_RxConfigLength/source/application/Tests.c.m4</sourcefile>
      <sourceline>136</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
       Test that a received frame with length different to the one configured in EcuC is not accepted
       and a DET will be reported.
  
Test Object: 
  
Test Precondition: 
  
Test Execution: 
    01: Simulate reception of an Pdu with wrong length:
    02: Check that DET was reported.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanTpFixedRxPduLengthSupport_Enabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>810</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.CanTpFixedRxPduLengthSupport_InvalidLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>811</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1644</internalId></specobject>
    <specobject>
      <id>TS_CANTP_3</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_Impl_RxConfigLength/source/application/Tests.c.m4</sourcefile>
      <sourceline>198</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
       Test that during an ongoing multiframe reception, if a frame with invalid length will be received, this
       one will not be processed, a DET will be reported, and the reception of the multiframe will continue afterwards.
  
Test Object: 
  
Test Precondition: 
  
Test Execution: 
    01: Start multiframe reception and check that it was received successfully.:
    02: Check that FC was transmitted and confirm it.
    03: Simulate reception of an Pdu with wrong length.
    04: Check that DET was reported.
    05: Continue CF reception.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanTpFixedRxPduLengthSupport_Enabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>810</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.CanTpFixedRxPduLengthSupport_InvalidLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>811</internalId></provcov>
        <provcov>
          <linksto>CanTp.ISO2016.InvalidFF_DL</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>902</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1645</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_BurstOfCF_Reception</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Implementation/IN/CanTp_Impl_StallHandling_Disabled/source/application/Tests.c</sourcefile>
      <sourceline>62</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks that CanTp can handle a burst of CF without logging DTC CANTP_E_OVERWRITE_FRAME.
  
Test Object: 
    Multiframe reception triggered in CanTp_MainFunction() by CANTP_LEAVE_CRITICAL_SECTION().
  
Test Precondition: 
  
Test Execution: 
      01: Start reception of FF by calling CanTp_RxIndication().
      02: Check that FF reception has triggered FC transmission.
      03: Confirm FC transmission.
      04: Call CanTp_MainFunction().
      05: Check reception of the 2 CF triggered by CANTP_LEAVE_CRITICAL_SECTION().
      06: Check that after 2 CF reception, FC transmission has been triggered ( BS=2 ).
      07: Start reception of the last CF.
      08: Check that frame reception is done.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00079</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>151</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00269_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>177</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.StateHandlingSupport_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>771</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1646</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_49017</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_CompileCommon/source/application/Application.c</sourcefile>
      <sourceline>43</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    CanTp Testcase 01

    DET enabled; at least 1 Rx-PDU configured; at least 1 Tx-PDU configured;
    Test for existence of version macros
    Test if CANTP_DEV_ERROR_DETECT==STD_ON

    Check for existence and syntax of API functions. Call:

    CanTp_Init();
    CanTp_GetVersionInfo();
    CanTp_Shutdown();
    CanTp_Transmit();
    CanTp_CancelTransmit();
    CanTp_CancelReceive();
    CanTp_ChangeParameter();
    CanTp_ReadParameter();
    CanTp_MainFunction();
    CanTp_RxIndication();
    CanTp_TxConfirmation();

    Check that compiling and linking of the file succeeds without warnings.

    ACG-5.0-X4 (and later): CanTp_Shutdown() is no longer supported and thus not tested for
    those version.

    Verify the Version number macros(MacroTest.h).
  
Test Object: 
    Compile test
  
Test Precondition: 
    CanTpCancelReceiveApi and CanTpCancelTransmitApi should be enabled
  
Test Execution: 
    Compile test
  
Test Input: 
  
Test Output: 
    Test correctly generates and compiles.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00076</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>148</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00078</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00006</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>37</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00208</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>343</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00212</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>43</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00214</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>397</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00215</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>60</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00210</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>346</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00213</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>392</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00246</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>45</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00257</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>50</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00297</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>106</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00302</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>54</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00323</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>386</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00267</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.CancelTransmitApiEnabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>591</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.CancelReceiveApiEnabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>588</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1647</internalId></specobject>
    <specobject>
      <id>TS_CANTP_NSa</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_CompileCommon/source/application/Application.c</sourcefile>
      <sourceline>166</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 

  Check for existence and syntax of API functions. Call:

    CanTp_GetNSa();
    CanTp_SetNSa();

    Check that compiling and linking of the file succeeds without warnings.

    Verify the Version number macros(MacroTest.h).
  
Test Object: 
    Compile test
  
Test Precondition: 
  
Test Execution: 
    Compile test
  
Test Input: 
  
Test Output: 
    Test correctly generates and compiles.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.GetNSa_Api</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>575</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.SetNSa_Api</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>566</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.GetNSa_ApiEnabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>563</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.SetNSa_ApiEnabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>562</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1648</internalId></specobject>
    <specobject>
      <id>TS_CANTP_49002</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_CompileCommon/source/application/Application.c</sourcefile>
      <sourceline>219</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    CanTp Testcase 02

    DET disabled; at least 1 Rx-PDUs configured; at least 1 Tx-PDUs configured
    Optional API functions disabled
    Test for existence of version macros
    Test if CANTP_DEV_ERROR_DETECT==STD_OFF
  
Test Object: 
    Compile test
  
Test Precondition: 
    None
  
Test Execution: 
    Compile test
  
Test Input: 
  
Test Output: 
    Compile succeeds.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00006</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>37</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1649</internalId></specobject>
    <specobject>
      <id>TS_CANTP_49027</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_CompileCommon/source/application/Application.c</sourcefile>
      <sourceline>258</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    CanTp Testcase 05

    Configuration as in Testcase 01, but without any Tx PDU configured.
  
Test Object: 
    Compile test
  
Test Precondition: 
  
Test Execution: 
    Compile test
  
Test Input: 
  
Test Output: 
    Test is correctly generated and compiled.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.TxNSdus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>624</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1650</internalId></specobject>
    <specobject>
      <id>TS_CANTP_49028</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_CompileCommon/source/application/Application.c</sourcefile>
      <sourceline>293</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    CanTp Testcase 06

    Configuration as in Testcase 01, but without any Rx PDU configured.
  
Test Object: 
    Compile test
  
Test Precondition: 
  
Test Execution: 
    Compile test
  
Test Input: 
  
Test Output: 
    Test is correctly generated and compiled.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.RxNSdus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>623</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1651</internalId></specobject>
    <specobject>
      <id>TS_CANTP_49030</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_CompileCommon/source/application/Application.c</sourcefile>
      <sourceline>328</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    CanTp_Compile_JtServ_SchMF

    Configuration as in Testcase 01 with the following specialities:
    Jumptable support is enabled
    CanTp is used as server (provides the entry jumptable and all functionality)
    SchM functions are used and therefore added to the exit jumptable
  
Test Object: 
    Jumptable support
  
Test Precondition: 
  
Test Execution: 
    Compile test
  
Test Input: 
  
Test Output: 
    Test is correctly generated and compiled.
    VP(CanTp.JTM_0011) The exit table contains all upper layer callback functions needed by the
    jump table server.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.JTM_0011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>928</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1652</internalId></specobject>
    <specobject>
      <id>TS_CANTP_49032</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_CompileCommon/source/application/Application.c</sourcefile>
      <sourceline>368</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    CanTp_Compile_JtServ_SchMM

    Configuration as in testcase CanTp_Compile_JtServ_SchMF with the following difference:
    SchM macros are used and therefore there is no SchM entry in the exit jumptable
  
Test Object: 
    Jumptable support
  
Test Precondition: 
  
Test Execution: 
    Compile test
  
Test Input: 
  
Test Output: 
    Test is correctly generated and compiled.
    VP(CanTp.JTM_0011) The exit table contains all upper layer callback functions needed by the
    jump table server.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.JTM_0011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>928</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1653</internalId></specobject>
    <specobject>
      <id>TS_CANTP_49034</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_CompileCommon/source/application/Application.c</sourcefile>
      <sourceline>406</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    CanTp_Compile_JtCli_ApiF_SchMF

    Configuration as in Testcase 01 with the following specialities:
    All API functions (including EB specific ones) are enabled
    Jumptable support is enabled
    CanTp is used as client (uses the entry jumptable, does not provide the functionality itself)
    API wrapper functions are used
    SchM functions are used and therefore added to the exit jumptable
  
Test Object: 
    Jumptable support
  
Test Precondition: 
  
Test Execution: 
    Compile test
  
Test Input: 
  
Test Output: 
    Test is correctly generated and compiled.
    01: VP(CanTp.JTM_0002): The CanTp jump table client shall provide
        all CanTp APIs allowed for this configuration.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.JTM_0002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>919</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1654</internalId></specobject>
    <specobject>
      <id>TS_CANTP_49036</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_CompileCommon/source/application/Application.c</sourcefile>
      <sourceline>448</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    CanTp_Compile_JtCli_ApiM_SchMF

    Configuration as in testcase CanTp_Compile_JtCli_ApiF_SchMF with the following difference:
    API wrapper macros are used instead of functions
  
Test Object: 
    Jumptable support
  
Test Precondition: 
  
Test Execution: 
    Compile test
  
Test Input: 
  
Test Output: 
    Test is correctly generated and compiled.
    01: VP(CanTp.JTM_0002): The CanTp jump table client shall provide
        all CanTp APIs allowed for this configuration.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.JTM_0002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>919</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1655</internalId></specobject>
    <specobject>
      <id>TS_CANTP_49038</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_CompileCommon/source/application/Application.c</sourcefile>
      <sourceline>486</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    CanTp_Compile_JtCli_ApiF_SchMM

    Configuration as in testcase CanTp_Compile_JtCli_ApiF_SchMF with the following difference:
    SchM macros are used and therefore there is no SchM entry in the exit jumptable
  
Test Object: 
    Jumptable support
  
Test Precondition: 
  
Test Execution: 
    Compile test
  
Test Input: 
  
Test Output: 
    Test is correctly generated and compiled.
    01: VP(CanTp.JTM_0002): The CanTp jump table client shall provide
        all CanTp APIs allowed for this configuration.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.JTM_0002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>919</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1656</internalId></specobject>
    <specobject>
      <id>TS_CANTP_49040</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_CompileCommon/source/application/Application.c</sourcefile>
      <sourceline>524</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    CanTp_Compile_JtCli_ApiM_SchMM

    Configuration as in testcase CanTp_Compile_JtCli_ApiF_SchMF with the following difference:
    API wrapper macros are used instead of functions
    SchM macros are used and therefore there is no SchM entry in the exit jumptable
  
Test Object: 
    Jumptable support
  
Test Precondition: 
  
Test Execution: 
    Compile test
  
Test Input: 
  
Test Output: 
    Test is correctly generated and compiled.
    01: VP(CanTp.JTM_0002): The CanTp jump table client shall provide
        all CanTp APIs allowed for this configuration.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.JTM_0002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>919</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1657</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_30414</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_Conf_ConfigOptBase/source/application/Tst_30414.c</sourcefile>
      <sourceline>75</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    - Reception of a single frame for all three Rx N-SDUs (this means one frame
      for standard, extended and mixed addressing format).
    - Verification of correct handling of SF data while using mixed addressing format
  
Test Object: 
    Message reception
  
Test Precondition: 
    - There is an Rx N-SDU configured for each addressing format.
  
Test Execution: 
    01: Simulate the reception of a single frame for all three Rx N-SDUs.
    02: VP(CanTp.ISO15765.SF.Format, CanTp.SWS_CanTp_00095_MixedAdr
           CanTp.SWS_CanTp_00281_MixedAdr
          ):
        Check for calls to PduR_CanTpStartOfReception and PduR_CanTpCopyRxData with
        appropriate arguments.
    03: VP(CanTp.EB.SF.RxDataLength_MixedAddressing, CanTp.EB.SF.RxMinDataLength_MixedAddressing):
        Check for correctness of the received data.
    04: Check if PduR_CanTpRxIndication is called to indicate successful reception.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ISO15765.SF.Format</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>840</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00095_MixedAdr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>236</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00281_MixedAdr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>227</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.SF.RxDataLength_MixedAddressing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>609</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.SF.RxMinDataLength_MixedAddressing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>610</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1658</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_30415</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_Conf_ConfigOptBase/source/application/Tst_30415.c</sourcefile>
      <sourceline>70</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Correct reception of a segmented message with standard addressing (CanTpRxNSdu_0).
  
Test Object: 
    Message reception
  
Test Precondition: 
  
Test Execution: 
    01: Indicated reception of first frame with msg length 21 and verify the PduR calls.
    02: Elapse mainfunction tick to send flow control frame and confirm it.
    03: VP(CanTp.ECUC_CanTp_00276):
        Check the FC (CTS) sent with proper BS(2) and STmin values.
    04: Indicated reception of two consecutive frames (CF).
    05: VP(CanTp.SWS_CanTp_00067_BS):
        Check the FC (CTS) sent with BS same as in previous FC CTS and confirm.
    06: Indicate reception of third consecutive frame.
    07: Check if PduR is notified.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ECUC_CanTp_00276</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>430</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00067_BS</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>192</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1659</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_30416</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_Conf_ConfigOptBase/source/application/Tst_30416.c</sourcefile>
      <sourceline>91</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Correct reception of a segmented message with extended addressing (CanTpRxNSdu_1).
  
Test Object: 
    Message reception
  
Test Precondition: 
  
Test Execution: 
    01: Indicate reception of FF in extended addressing.
    02: Invoke mainfunction to send flow control frame.
    03: VP(CanTp.SWS_CanTp_00281_ExtendedAdr, CanTp.ECUC_CanTp_00276,
           CanTp.SWS_CanTp_00030_1c):
        Check if CTS sent for extended addressing format with correct BS value and N_TA.
    04: Indicate reception of consecutive frames, invoke mainfunction between CFs.
    05: Check if PduR is notified of correct reception.
    06: Check if CTS is sent only once.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00281_ExtendedAdr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>226</internalId></provcov>
        <provcov>
          <linksto>CanTp.ECUC_CanTp_00276</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>430</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00030_1c</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>132</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1660</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_30418</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_Conf_ConfigOptBase/source/application/Tst_30418.c</sourcefile>
      <sourceline>59</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Transmission of a single frame for all three Tx N-SDUs (this means one
    frame for each addressing format). PADDING is ON and OFF depending on the used
    configuration.
  
Test Object: 
    Message transmission
  
Test Precondition: 
    - There is a Tx N-SDU configured for each addressing format.
  
Test Execution: 
    01: Simulate the transmission of a single frame for all three Tx N-SDUs.
    02: Call CanTp_Transmit() with the corresponding parameters.
    03: Call CanTp_MainFunction() to make sure that the transmission is performed.
    04: Check if PduR_CanTpCopyTxData() is called with correct arguments
        to get data for transmission.
    05: VP(CanTp.SWS_CanTp_00095_MixedAdr, CanTp.SWS_CanTp_00281_MixedAdr,
           CanTp.SWS_CanTp_00283_MixedAdr, CanTp.ASR40.SWS_CanTp_00040_1
          ):
        Check if CanIf_Transmit() is called with correct arguments, frame content represents a
        single frame (SF) of the correct addressing format and with the correct addressing
        information if applicable. to transmit the message. If padding is enabled, 8 bytes are sent
        to CanIf. If padding is disabled, only the correct number of data bytes is sent to CanIf.
    06: Check if PduR_CanTpTxConfirmation was called to indicate successful transmission.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00095_MixedAdr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>236</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00281_MixedAdr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>227</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00283_MixedAdr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>231</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00040_1</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>34</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1661</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_30424</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_Conf_ConfigOptBase/source/application/Tst_30424.c</sourcefile>
      <sourceline>65</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Transmission of a segmented message with extended addressing (CanTpTxNSdu_1)
  
Test Object: 
    Message transmission
  
Test Precondition: 
  
Test Execution: 
    01: Start transmission via CanTp_Transmit, extended addressing.
    02: Check if PduR_CanTpCopyTxData has been called.
    03: Check if CanIf_Transmit has been called for the first frame (FF).
    04: VP(CanTp.SWS_CanTp_00281_ExtendedAdr):
        Check the sent header for appropriate addressing format (FF; data are not important).
    05: Confirm the correct transmission.
    06: Transmit the remaining frames.
    07: Check whether PduR is notified of successful transmission.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00281_ExtendedAdr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>226</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1662</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_30426</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_Conf_ConfigOptBase/source/application/Tst_30426.c</sourcefile>
      <sourceline>77</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Correct reception of a segmented message (extended addressing) in which the CanTp triggers a
    FC wait frame.
  
Test Object: 
    Message reception
  
Test Precondition: 
  
Test Execution: 
    01: Initialize PduR to return "busy" with next buffer request.
    02: Indicate reception of first frame, extended addressing.
    03: Wait for N_Br to really get a "wait" flow control frame.
    04: VP(CanTp.SWS_CanTp_00281_ExtendedAdr):
        Check if sent flow control frame (wait) is for extended addressing format.
    05: PduR shall return BUFREQ_OK for the next request.
    06: VP(CanTp.SWS_CanTp_00281_ExtendedAdr):
        Check if sent flow control frame (CTS) is for extended addressing format.
    07: Indicate reception of consecutive frame (CF).
    08: Check if PduR is notified of successful reception.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00281_ExtendedAdr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>226</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1663</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_30427</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_Conf_ConfigOptBase/source/application/Tst_30427.c</sourcefile>
      <sourceline>67</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Failed reception of a segmented message (standard addressing) in which the CanTp triggers a FC overflow frame.
  
Test Object: 
    Message reception
  
Test Precondition: 
  
Test Execution: 
    01: Initialize PduR_CanTpStartOfReception() to return BUFREQ_E_OVFL with next buffer request.
    02: Indicate reception of first frame.
    03: VP(CanTp.ASR40.SWS_CanTp_00318_1):
         Check if sent flow control frame (OVFL) is for standard addressing format.
    04: Call mainfunction to finish the failed reception.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00318_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>18</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1664</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_30428</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_Conf_ConfigOptBase/source/application/Tst_30428.c</sourcefile>
      <sourceline>72</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Failed reception of a segmented message (extended addressing) in which the CanTp triggers a
    FC overflow frame.
  
Test Object: 
    Message reception
  
Test Precondition: 
  
Test Execution: 
    01: Initialize PduR_CanTpStartOfReception() to return BUFREQ_E_OVFL with next buffer request.
    02: Indicate reception of first frame.
    03: VP(CanTp.SWS_CanTp_00281_ExtendedAdr):
         Check if sent flow control frame (OVFL) is for extended addressing format.
    04: Call mainfunction to finish the failed reception.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00281_ExtendedAdr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>226</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1665</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_30446</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_Conf_ConfigOptBase/source/application/Tst_30446.c</sourcefile>
      <sourceline>85</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Correct expiry of N_Ar after reception of a segmented message.
  
Test Object: 
    Message reception
  
Test Precondition: 
  
Test Execution: 
    Loop over steps 01 to 02 for different N-Sdus with different addressing types.
    01: Simulate reception of a first frame of a segmented message.
    02: Check that CanTp has sent a FC frame (CTS) to CanIf.
    03: Do not provide a CanTp_TxConfirmation() for the transmission of the FC frame.
    04: Simulate expiration of N_Ar timer.
    05: Call CanTp_MainFunction() several times(loop with N_Ar-1).
    06: Check one counter tick before expiry of N_Ar
    07: Call CanTp_MainFunction() once more.
    08: VP(CanTp.SWS_CanTp_00311):
        Check if N_Ar timeout has occurred and CanTp will abort the reception and notify the upper
        layer of this failure by calling PduR_CanTpRxIndication() with result E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00311</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>174</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1666</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_30447</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_Conf_ConfigOptBase/source/application/Tst_30447.c</sourcefile>
      <sourceline>85</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Correct expiry of N_Br after reception of a segmented message, when PduR does not provide a
    receive buffer.
  
Test Object: 
    Message reception
  
Test Precondition: 
  
Test Execution: 
    01: The PduR buffer request returns BUFREQ_E_BUSY.
    02: Simulate reception of a first frame of a segmented message.
    03: Check, that CanTp has sent no FC frame (WAIT) to CanIf.
    04: Call CanTp_MainFunction() several times(loop with N_Br-1).
    05: Check one counter tick before expiry of N_Br, that no FC_Frame was sent.
    06: Call CanTp_MainFunction() once more.
    Loop over steps 07 for different N-Sdus with different addressing types.
    07: VP(CanTp.ASR40.SWS_CanTp_00166_1, CanTp.ASR40.SWS_CanTp_00082_2):
        Check that CanTp has sent a FC frame (WAIT) to CanIf.
  
Test Input: 
  
Test Output: 
    The FC(WAIT) frame was sent to CanIf after expiry of N_Br.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00166_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>14</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00082_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>22</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1667</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_30448</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_Conf_ConfigOptBase/source/application/Tst_30448.c</sourcefile>
      <sourceline>86</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Correct expiry of N_Cr. After reception of a segmented message (first frame) the consecutive
    frame (CF) is not provided.
  
Test Object: 
    Message reception
  
Test Precondition: 
  
Test Execution: 
    Loop over steps 01 to 05 for different N-Sdus with different addressing types.
    01: Simulate a reception of the first frame of a segmented message,
        which is answered by FlowControl.
    02: Call CanTp_MainFunction() several times(loop with N_Cr-1).
    03: Check one counter tick before expiry of N_Cr.
    04: Call CanTp_MainFunction() to reach N_Cr timeout.
    05: VP(CanTp.SWS_CanTp_00313, CanTp.SWS_CanTp_00312_2):
        Check if PduR_CanTpRxIndication() has been called with Result: E_NOT_OK.
        E_NOT_OK also confirms that N_Cr timeout, set after FC(CTS) was confirmed,
        was reached.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00313</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>182</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00312_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>181</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1668</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_30449</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_Conf_ConfigOptBase/source/application/Tst_30449.c</sourcefile>
      <sourceline>80</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Correct handling of expiry of N_As after transmission of a segmented message which is not
    confirmed from CanIf.
  
Test Object: 
    Message transmission
  
Test Precondition: 
  
Test Execution: 
    01: Simulate transmission of a FF.
    02: Call CanTp_Transmit() with the corresponding parameters and CanTp_MainFunction()
        to start the transmission. FF is not confirmed.
    03: Call CanTp_MainFunction several times(loop N_As-1)
    04: Call CanTpMainFunction() again.
    05: VP(CanTp.SWS_CanTp_00310):
        Check, that PduR_TxConfirmation was called with Result E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00310</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>209</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1669</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_30450</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_Conf_ConfigOptBase/source/application/Tst_30450.c</sourcefile>
      <sourceline>80</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Correct handling of expiry of N_Bs after transmission of a segmented message which is confirmed
    by CanIf, but not confirmed by FlowControl.
  
Test Object: 
    Message transmission
  
Test Precondition: 
  
Test Execution: 
    01: Simulate transmission of a FF message.
    02: Call CanTp_Transmit() with the corresponding parameters and
        CanTp_MainFunction() to start the transmission.
    03: Call CanTp_TxConfirmation(). Do not indicate FC frame.
    04: Call CanTp_MainFunction several times(loop N_Bs-1).
    05: Call CanTpMainFunction() again.
    06: VP(CanTp.SWS_CanTp_00316):
        Check, that PduR_TxConfirmation() was called with Result E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00316</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>216</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1670</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_30451</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_Conf_ConfigOptBase/source/application/Tst_30451.c</sourcefile>
      <sourceline>81</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Correct handling of expiry of N_Cs when PduR is not providing a valid Tx buffer for
    segmented transmission.
  
Test Object: 
    N_Cs timeout during segmented transmission.
  
Test Precondition: 
  
Test Execution: 
    Test is repeated for different Tx N-Sdus with different addressing modes.
    01: Prepare PduR_CanTpCopyTxData to return BUFREQ_E_BUSY.
    02: Call CanTp_Transmit() for segmented transmission.
    03: Call CanTp_MainFunction() several times(loop N_Cs-1).
    04: Check, that Det_ReportError() was not called.
    05: Call CanTpMainFunction() again to expire N_Cs timer.
    06: VP(CanTp.ASR40.SWS_CanTp_00185, CanTp.SWS_CanTp_00167_1, CanTp.SWS_CanTp_00280):
        Check, that PduR_TxConfirmation() was called with Result E_NOT_OK indicating that
        the transmission is aborted as N_Cs timeout occurred.
  
Test Input: 
  
Test Output: 
    Timer N_Cs is expired in configured time.
    PduR_CanTpTxConfirmation() was called with E_NOT_OK.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00280</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>207</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00167_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>201</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00185</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>26</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1671</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_30452</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_Conf_ConfigOptBase/source/application/Tst_30452.c</sourcefile>
      <sourceline>85</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that the configured STmin value is sent correct in the FC-frame on reception of a
    segmented message.
  
Test Object: 
    Message reception
  
Test Precondition: 
  
Test Execution: 
    Loop over steps 01 to 03 for different N-Sdus with different addressing types. 
    01: Simulate a reception of a segmented message.
    02: Call CanTp_MainFunction() and check if flow control frame is sent.
    03: VP(CanTp.ECUC_CanTp_00252):
        Check, that the value of STmin in the flow control message is sent as configured.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ECUC_CanTp_00252</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>439</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1672</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_30453</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_Conf_ConfigOptBase/source/application/Tst_30453.c</sourcefile>
      <sourceline>92</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check correct handling of the WftMax value.
  
Test Object: 
    Message reception
  
Test Precondition: 
  
Test Execution: 
    01: PduR shall return BUFREQ_E_BUSY.
    Loop over steps 01 to 07 for different N-Sdus with different addressing types.
    02: Simulate the reception of a segmented message.
    03: Call CanTp_MainFunction() till N_Br has expired.
    04: Check that flow control frame (wait) was sent.
    05: Call CanTp_TxConfirmation() for the transmission of the FC frame.
    06: Execute steps 03 to 05 several times.
    07: VP(CanTp.SWS_CanTp_00223_1):
        Check that after WftMax no more FC frames are sent to CanIf.
    08: VP(CanTp.SWS_CanTp_00223_2):
        Check if PduR_CanTpRxIndication() has been called with Status E_NOT_OK.
  
Test Input: 
  
Test Output: 
    The number of transmitted FC wait frames shall be equal to WftMax.
    WftMax shall have the same value as configured.
    After exit the loop, PduR_CanTpRxIndication() was called with E_NOT_OK.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00223_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>172</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00223_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>173</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1673</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_30454</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_Conf_ConfigOptBase/source/application/Tst_30454.c</sourcefile>
      <sourceline>70</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Transmit 1 data byte to CanIf and check that padding is performed correctly (i.e DLC set to 8 and
    configured padding byte set if padding is activated for PDU).
  
Test Object: 
    Message transmission
  
Test Precondition: 
    Padding is enabled.
  
Test Execution: 
    01: Call CanTp_Transmit and invoke main function to get data transfered to CanIf.
    02: Set expected N_PCI value based on message format.
    03: Set expected DLC based on message format.
    04: VP(CanTp.SWS_CanTp_00059_1):
        Check whether the length is correct.
    05: VP(CanTp.SWS_CanTp_00059_1, CanTp.ASR40.SWS_CanTp_00040_1):
        Check whether the padding is enabled and if so check the sent message
        for the padding bytes.
    06: Confirm the message sent.
    07: Check whether PduR is notified of successful transmission.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00059_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>259</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00040_1</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>34</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1674</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_30477</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_Conf_ConfigOptBase/source/application/Tst_30477.c</sourcefile>
      <sourceline>95</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that reception of a single frame does fail, if the reported length of data
    (CanTpRxPduPtr-&amp;gt;SduLength) is greater than allowed.
    This does check, that optimized padding is working correct.

    CanTpRxNSdu_0 and CanTpRxNSdu_1 are used.
  
Test Object: 
    Message reception
  
Test Precondition: 
  
Test Execution: 
    01: Initialize PduInfo struct, SduLength having invalid length (9U).
    02: Prepare FF.
    03: simulate first frame reception.
    04: VP(CanTp.ASR40.SWS_CanTp_00021, CanTp.ASR40.SWS_CanTp_00132, CanTp.EB.RxIndication.InvalidRxLength):
        Check, that a DET error CANTP_E_INVALID_RX_LENGTH is reported.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00021</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>86</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00132</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>93</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.RxIndication.InvalidRxLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>626</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1675</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_30478</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_Conf_ConfigOptBase/source/application/Tst_30478.c</sourcefile>
      <sourceline>95</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that reception of a single frame does fail, if the reported length of data
    (CanTpRxPduPtr-&amp;gt;SduLength) is smaller than the received data.
    This does check, that optimized padding is working correct if  Padding is configured to OFF.

    It is checked for Rx PDUs where Padding is configured to OFF.

    CanTpRxNSdu_0 is used for this test.
  
Test Object: 
    Message reception
  
Test Precondition: 
  
Test Execution: 
    01: Setup the PduInfo struct with a SduLength value = 4U,
        which is smaller than the length of received data, 6 Bytes.
    02: Prepare SF and simulate reception of SF.
    03: VP(CanTp.ASR40.SWS_CanTp_00098, CanTp.ASR40.SWS_CanTp_00021,
           CanTp.ASR40.SWS_CanTp_00132, CanTp.EB.SF.InvalidRxLength):
        Check, that Det error CANTP_E_INVALID_RX_LENGTH has been reported.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00098</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>88</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00021</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>86</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00132</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>93</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.SF.InvalidRxLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>630</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1676</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_30479</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_Conf_ConfigOptBase/source/application/Tst_30479.c</sourcefile>
      <sourceline>95</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that reception of a single frame does fail, if the reported length of data
    (CanTpRxPduPtr-&amp;gt;SduLength) is smaller than 8.
    This does check, that optimized padding is working correct if Padding is configured to ON.

    CanTpRxNSdu_1 is used for this test.
  
Test Object: 
    Message reception
  
Test Precondition: 
    Padding is enabled
  
Test Execution: 
    01: Setup the PduInfo struct with a SduLength value 7.
    02: Call CanTp_RxIndication() and indicate reception of SF.
    03: VP(CanTp.ASR40.SWS_CanTp_00040_2, CanTp.ASR40.SWS_CanTp_00021,
           CanTp.ASR40.SWS_CanTp_00132, CanTp.EB.Rx.Padding.InvalidRxLength):
        Check that Det error, CANTP_E_INVALID_RX_LENGTH has been reported.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00040_2</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>35</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00021</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>86</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00132</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>93</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Rx.Padding.InvalidRxLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>627</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1677</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_30480</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_Conf_ConfigOptBase/source/application/Tst_30480.c</sourcefile>
      <sourceline>93</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that reception of a segmented frame in standard addressing mode does fail, if the
    reported length of data (CanTpRxPduPtr-&amp;gt;SduLength) for the last consecutive frame (CF)
    is smaller than the remaining received data.

    The last consecutive frame will be repeated with correct length and the segemented frame will
    be checked for correct reception.

    This does check, that optimized padding is working correct if  Padding is configured to OFF.

    CanTpRxNSdu_0 is used for this test.
  
Test Object: 
    Message reception
  
Test Precondition: 
   - Standard addressing mode.
  
Test Execution: 
    01: Simulate frame reception.
    02: VP(CanTp.SWS_CanTp_00116_3):
        Check if only data is provided to PduR.
    03: Elapse MainFunction tick to sent a FC frame.
    04: Indicate first CF.
    05: VP(CanTp.SWS_CanTp_00116_3):
        Check if only data is provided to PduR.
    06: Indicate second CF.
    07: VP(CanTp.SWS_CanTp_00116_3):
        Check if only data is provided to PduR.
    08: Elapse MainFunction tick and check if FC is transmitted.
    09: Set too small SduLength for the next(last) CF.
    10: Indicate last CF.
    11: VP(CanTp.ASR40.SWS_CanTp_00098, CanTp.ASR40.SWS_CanTp_00021,
           CanTp.ASR40.SWS_CanTp_00132, CanTp.EB.LastFrame.InvalidRxLength):
        Check, that a DET error CANTP_E_INVALID_RX_LENGTH is reported.
    12: Set correct value of SduLength for next CF.
    13: Indicate CF.
    14: Check for PduR notification of successful reception.
    15: Check if data is correctly received.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00098</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>88</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00116_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>256</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00021</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>86</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00132</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>93</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.LastFrame.InvalidRxLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>640</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1678</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_30481</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_Conf_ConfigOptBase/source/application/Tst_30481.c</sourcefile>
      <sourceline>106</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
   -Check that reception of a segmented frame in extended addressing mode does fail, if the reported
    length of data (CanTpRxPduPtr-&amp;gt;SduLength) for the last consecutive frame (CF) is smaller
    than the remaining received data.
   -The last consecutive frame will be repeated with correct length and the segemented frame will be
    checked for correct reception.
    This does check, that optimized padding is working correct if  Padding is configured to ON.

    CanTpRxNSdu_1 is used for this test.
  
Test Object: 
    Message reception
  
Test Precondition: 
  
Test Execution: 
    01: Indicate reception of first frame.
    02: VP(CanTp.SWS_CanTp_00116_1):
        Check if correct data is provided to PduR.
    03: Elapse a mainfunction tick and check that FC frame is sent.
    04: Indicate reception of first and second CFs.
    05: Set the small SduLength than required for the last CF.
    06: Indicate last CF.
    07: VP(CanTp.ASR40.SWS_CanTp_00040_2, CanTp.ASR40.SWS_CanTp_00021,
           CanTp.ASR40.SWS_CanTp_00132, CanTp.EB.LastFrame.InvalidRxLength):
        Check that Det error CANTP_E_INVALID_RX_LENGTH is reported.
    08: Set the correct value for SduLength.
    09: Indicate last CF.
    10: VP(CanTp.SWS_CanTp_00116_1):
        Check that reception is successful and verify that only used data bytes are copied to PduR 
        and PduR is notified.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00040_2</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>35</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00021</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>86</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00132</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>93</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.LastFrame.InvalidRxLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>640</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00116_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>254</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1679</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_30482</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_Conf_ConfigOptBase/source/application/Tst_30482.c</sourcefile>
      <sourceline>110</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that transmission of a segmented frame in standard addressing mode does fail, if the
    reported length of data (CanTpRxPduPtr-&amp;gt;SduLength) for the received FC frames is smaller
    than 3 bytes.
    This does check, that optimized padding is working correct if Padding is configured to OFF.

    CanTpTxNSdu_0 is used for this test.
  
Test Object: 
    Message transmission
  
Test Precondition: 
  
Test Execution: 
    01: Start a segmented transmission  with standard addressing.
    02: Check if PduR_CanTpCopyTxData was called.
    03: Check if CanIf_Transmit was called to transmit FF.
    04: Check whether the sent header of FF has correct addressing format.
    05: Check whether the data has been sent to CanIf correctly.
    06: Confirm the correct transmission of FF.
    07: Simulate reception of FC frame with short DLC.
    08: VP(CanTp.ASR40.SWS_CanTp_00098, CanTp.ASR40.SWS_CanTp_00021,
           CanTp.ASR40.SWS_CanTp_00132, CanTp.EB.Receiving.RxFC.UnexpectedLengths):
        Check if Det error CANTP_E_INVALID_RX_LENGTH was reported.
    09: Indicate FC frame with correct DLC.
    10: Invoke mainfunction and check that CF is sent.
    11: Check the sent header. Note that SN is 1 for the first CF, 2 for the second, etc.
    12: Check, that correct data has been sent to CanIf.
    13: Confirm the sent message.
    14: Check if PduR is notified of successful transmission.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00098</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>88</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00021</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>86</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00132</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>93</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Receiving.RxFC.UnexpectedLengths</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>744</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1680</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_30483</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_Conf_ConfigOptBase/source/application/Tst_30483.c</sourcefile>
      <sourceline>110</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that transmission of a segmented frame in extended addressing mode does fail,
    if the reported length of data (CanTpRxPduPtr-&amp;gt;SduLength) for the received FC frames is
    smaller than 8 bytes.
    This does check, that optimized padding is working correct if Padding is configured to ON.
    CanTpTxNSdu_1 is used for this test.
  
Test Object: 
    Message reception error handling
  
Test Precondition: 
  
Test Execution: 
    01: Start a segmented transmission with extended addressing.
    02: Check if PduR_CanTpCopyTxData was called.
    03: Check if CanIf_Transmit was called to transmit FF.
    04: Check whether the sent header of FF has correct addressing format.
    05: Check whether the data has been sent to CanIf correctly.
    06: Confirm the correct transmission of FF.
    07: Simulate reception of FC frame with short DLC.
    08: VP(CanTp.ASR40.SWS_CanTp_00021, CanTp.ASR40.SWS_CanTp_00132,
           CanTp.EB.Rx.Padding.InvalidRxLength, CanTp.ASR40.SWS_CanTp_00040_2):
        Check if Det error CANTP_E_INVALID_RX_LENGTH was reported.
    09: Indicate FC frame with correct DLC.
    10: Invoke mainfunction and check that CF is sent.
    11: Check the sent header. Note that SN is 1 for the first CF, 2 for the second, etc.
    12: Check, that correct data has been sent to CanIf.
    13: Confirm the sent message.
    14: Check if PduR is notified of successful transmission.
  
Test Input: 
  
Test Output: 
    Det_ErrorReport() has been called with CANTP_E_INVALID_RX_LENGTH.
    Transmission shall be successful confirmed.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00040_2</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>35</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00021</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>86</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00132</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>93</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Rx.Padding.InvalidRxLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>627</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1681</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_30255</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_Conf_ConfigOptBase/source/application/Tst_CommonTests.c</sourcefile>
      <sourceline>72</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a DET error is reported when the function CanTp_TxConfirmation is given a wrong
    argument (1/1).
  
Test Object: 
    Error handling
  
Test Precondition: 
    Module compiled with DET enabled.
  
Test Execution: 
    01: Call CanTp_TxConfirmation with invalid PduId (no such PduId configured for CanTp)
        in CanTpTxPduId.
    02: VP(CanTp.ASR40.SWS_CanTp_00021, CanTp.ASR40.SWS_CanTp_00132, CanTp.EB.TxConfirmation.InvalidTxId):
        Check if Det error CANTP_E_INVALID_TX_ID is reported.
    03: Execute step 01 another invalid PduId.
    04: VP(CanTp.ASR40.SWS_CanTp_00021, CanTp.ASR40.SWS_CanTp_00132, CanTp.EB.TxConfirmation.InvalidTxId):
        Check if Det error CANTP_E_INVALID_TX_ID is reported.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00021</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>86</internalId></provcov>
        <provcov>
          <linksto>CanTp.ASR40.SWS_CanTp_00132</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>93</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.TxConfirmation.InvalidTxId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>643</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1682</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_SegRxMixedAdr</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_Conf_ConfigOptBase/source/application/Tst_SegRxMixedAdr.c</sourcefile>
      <sourceline>60</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    - Correct reception of a segmented message with mixed addressing (CanTpRxNSdu_2).
    - Correct reception of last frame with/without padding bytes for mixed addressing
  
Test Object: 
    Message reception
  
Test Precondition: 
    padding disabled
  
Test Execution: 
    01: Loop over steps 02 to 14 for different values of message length
    02: Simulate reception of first frame with message length as mentioned in input section,
        mixed addressing format.
    03: Invoke mainfunction.
    04: VP(CanTp.ECUC_CanTp_00276,
           CanTp.SWS_CanTp_00095_MixedAdr, CanTp.SWS_CanTp_00281_MixedAdr,
           CanTp.SWS_CanTp_00283_MixedAdr, CanTp.SWS_CanTp_00030_1d,
           CanTp.SWS_CanTp_00030_1e
          ):
        Check if FC(CTS) is sent with Mixed addressing format with configured N_Ae value.
    05: Indicate reception of first consecutive frames (CF).
    06: Invoke mainfunction.
    07: VP(CanTp.ECUC_CanTp_00276,
           CanTp.SWS_CanTp_00095_MixedAdr, CanTp.SWS_CanTp_00281_MixedAdr,
           CanTp.SWS_CanTp_00283_MixedAdr
          ):
        Check if FC(CTS) is sent with Mixed addressing format.
    08: Simulate reception of second CF.
    09: Elapse a mainfunction tick.
    10: VP(CanTp.ECUC_CanTp_00276,
           CanTp.SWS_CanTp_00095_MixedAdr, CanTp.SWS_CanTp_00281_MixedAdr,
           CanTp.SWS_CanTp_00283_MixedAdr
          ):
        Check if FC(CTS) is sent with Mixed addressing format.
    11: Indicate third (last)CF as in input section
    12: No further FC frames must have been sent.
    13: Check that the message must have been correctly received and provided to the PduR.
    14: VP(CanTp.EB.LastCF.RxMinDataLength_MixedAddressing, CanTp.EB.LastCF.RxDataLength_MixedAddressing):
        Check whether the correct data must have been received and the padded bytes in the last frame
        is not passed to PduR.
  
Test Input: 
   02: 21U
       23 U
   11: N_Ae(1byte) + N_PCI(1byte) +remaining 4 data bytes + 2 bytes for padding
       N_Ae(1byte) + N_PCI(1byte) +remaining 6 data bytes
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.ECUC_CanTp_00276</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>430</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00095_MixedAdr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>236</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00281_MixedAdr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>227</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00283_MixedAdr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>231</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.LastCF.RxMinDataLength_MixedAddressing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>616</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.LastCF.RxDataLength_MixedAddressing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>615</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00030_1d</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00030_1e</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>134</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1683</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_SegRxOvflwMixedAdr</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_Conf_ConfigOptBase/source/application/Tst_SegRxOvflwMixedAdr.c</sourcefile>
      <sourceline>46</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Failed reception of a segmented message (mixed addressing) in which the
    CanTp triggers a FC overflow frame.
  
Test Object: 
    Message reception
  
Test Precondition: 
  
Test Execution: 
    01: Initialize PduR to return BUFREQ_E_OVFL with next buffer request.
    02: Indicate reception of first frame, mixed addressing format.
    03: VP(
            CanTp.SWS_CanTp_00283_MixedAdr, CanTp.SWS_CanTp_00281_MixedAdr,
            CanTp.SWS_CanTp_00095_MixedAdr
          ):
        Check sent flow control frame (overflow).
    04: Invoke mainfunction to finish the failed reception.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00095_MixedAdr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>236</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00281_MixedAdr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>227</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00283_MixedAdr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>231</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1684</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_SegRxWithWaitMixedAdr</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_Conf_ConfigOptBase/source/application/Tst_SegRxWithWaitMixedAdr.c</sourcefile>
      <sourceline>66</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Correct reception of a segmented message with mixed addressing
    (CanTpRxNSdu_2) in which the CanTp triggers a FC wait frame.
  
Test Object: 
    Message reception
  
Test Precondition: 
  
Test Execution: 
    01: Initialize PduR to return BUFREQ_E_BUSY with next buffer request.
    02: Indicate reception of first frame.
    03: Wait for N_Br to really get a "wait" flow control frame..
    04: Elapse a mainfunction tick.
    05: VP(
           CanTp.SWS_CanTp_00095_MixedAdr, CanTp.SWS_CanTp_00281_MixedAdr,
           CanTp.SWS_CanTp_00283_MixedAdr,
          ):
        Check for flow control frame (wait).
    06: Let PduR return BUFREQ_OK during the next request.
    07: Elapse a mainfunction tick and check if flow control frame (CTS) is sent.
    08: Indicate reception of consecutive frame (CF).
    09: Check if no further FC frames have been sent.
    10: Check if the message must have been correctly received and provided to the PduR.
    11: Check if the correct data has been received.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00095_MixedAdr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>236</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00281_MixedAdr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>227</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00283_MixedAdr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>231</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1685</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_SegTxMixedAdr</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_Conf_ConfigOptBase/source/application/Tst_SegTxMixedAdr.c</sourcefile>
      <sourceline>66</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Transmission of a segmented message with mixed addressing (CanTpTxNSdu_2)
  
Test Object: 
    Message transmission
  
Test Precondition: 
    Padding disabled
  
Test Execution: 
    01: Start a segmented transmission with mixed addressing format.
    02: Check if PduR_CanTpCopyTxData has been called.
    03: CanIf_Transmit was called for the first frame (FF).
    04: VP(
            CanTp.SWS_CanTp_00095_MixedAdr, CanTp.SWS_CanTp_00281_MixedAdr,
            CanTp.SWS_CanTp_00283_MixedAdr
          ):
        Check the sent header with proper N_AE value for a Mixed addressing format.(FF)
    05: Check FF data is correct.
    06: Confirm the correct transmission.
    07: VP(CanTp.EB.Padding.CANTP_OFF.Receiving.CAN20_RxFC.AcceptedLengths.EXTENDED.MIXED):
        Receive the FC frame with length &gt; (N_AE + N_PCI) and verify that it is correctly
        accepted and finish the transmission.
    08: Check that message transmission is correctly confirmed.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00095_MixedAdr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>236</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00281_MixedAdr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>227</internalId></provcov>
        <provcov>
          <linksto>CanTp.SWS_CanTp_00283_MixedAdr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>231</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.Padding.CANTP_OFF.Receiving.CAN20_RxFC.AcceptedLengths.EXTENDED.MIXED</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>741</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1686</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_40090</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_Impl_JtCli_Tmpl/source/application/Tst_40090.c</sourcefile>
      <sourceline>73</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    CanTp_Init shall be called correctly via the entry jump table.
  
Test Object: 
    Entry jump table
  
Test Precondition: 
    The address of the entry jump table is provided via configuration parameter
    as:modconf('CanTp')[1]/CanTpJumpTable/CanTpJumpTableAddress.
  
Test Execution: 
    01: Call CanTp_Init.
    02: VP(CanTp.JTM_0001, CanTp.JTM_0007):
        Check if TstJt_Init() is called, which implies that the CanTp_Init function referenced by
        the entry jump table is called correctly.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.JTM_0001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>918</internalId></provcov>
        <provcov>
          <linksto>CanTp.JTM_0007</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>924</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1687</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_40091</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_Impl_JtCli_Tmpl/source/application/Tst_40091.c</sourcefile>
      <sourceline>56</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    CanTp_GetVersionInfo calls the corresponding entry jump table function.
  
Test Object: 
    Entry jump table
  
Test Precondition: 
    The address of the entry jump table is provided via configuration parameter
    as:modconf('CanTp')[1]/CanTpJumpTable/CanTpJumpTableAddress.
  
Test Execution: 
    01: Call CanTp_GetVersionInfo.
    02: VP(CanTp.JTM_0007):
        Check if the CanTp_GetVersionInfo function referenced by the entry jump table
        is called with the correct parameter.
  
Test Input: 
  
Test Output: 

  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.JTM_0007</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>924</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1688</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_40093</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_Impl_JtCli_Tmpl/source/application/Tst_40093.c</sourcefile>
      <sourceline>56</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    CanTp_Transmit calls the corresponding entry jump table function.
  
Test Object: 
    Entry jump table
  
Test Precondition: 
    The address of the entry jump table is provided via configuration parameter
    as:modconf('CanTp')[1]/CanTpJumpTable/CanTpJumpTableAddress.
  
Test Execution: 
    01: Call CanTp_Transmit.
    02: VP(CanTp.JTM_0007):
        Check if the CanTp_Transmit function referenced by the entry jump table is called
        with the correct parameters and the return value of this function is returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.JTM_0007</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>924</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1689</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_40094</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_Impl_JtCli_Tmpl/source/application/Tst_40094.c</sourcefile>
      <sourceline>56</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    CanTp_CancelTransmit calls the corresponding entry jump table function.
  
Test Object: 
    Entry jump table
  
Test Precondition: 
    The address of the entry jump table is provided via configuration parameter
    as:modconf('CanTp')[1]/CanTpJumpTable/CanTpJumpTableAddress.
  
Test Execution: 
    01: Call CanTp_CancelTransmit
    02: VP(CanTp.JTM_0007):
        Check if the CanTp_CancelTransmit function referenced by the entry jump table
        is called with the correct parameters and the return value of this function is returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.JTM_0007</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>924</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1690</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_40095</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_Impl_JtCli_Tmpl/source/application/Tst_40095.c</sourcefile>
      <sourceline>56</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    CanTp_MainFunction calls the corresponding entry jump table function.
  
Test Object: 
    Entry jump table
  
Test Precondition: 
    The address of the entry jump table is provided via configuration parameter
    as:modconf('CanTp')[1]/CanTpJumpTable/CanTpJumpTableAddress.
  
Test Execution: 
    01: Call CanTp_MainFunction
    02: VP(CanTp.JTM_0007):
        Check if the CanTp_MainFunction function referenced by the entry jump table is called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.JTM_0007</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>924</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1691</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_40096</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_Impl_JtCli_Tmpl/source/application/Tst_40096.c</sourcefile>
      <sourceline>57</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    CanTp_RxIndication calls the corresponding entry jump table function.
  
Test Object: 
    Entry jump table
  
Test Precondition: 
    The address of the entry jump table is provided via configuration parameter
    as:modconf('CanTp')[1]/CanTpJumpTable/CanTpJumpTableAddress.
  
Test Execution: 
    01: Call CanTp_RxIndication.
    02: VP(CanTp.JTM_0007):
        Check if the CanTp_RxIndication function referenced by the entry jump table is
        called with the correct parameters.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.JTM_0007</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>924</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1692</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_40097</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_Impl_JtCli_Tmpl/source/application/Tst_40097.c</sourcefile>
      <sourceline>57</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    CanTp_TxConfirmation calls the corresponding entry jump table function.
  
Test Object: 
    Entry jump table
  
Test Precondition: 
    The address of the entry jump table is provided via configuration parameter
    as:modconf('CanTp')[1]/CanTpJumpTable/CanTpJumpTableAddress.
  
Test Execution: 
    01: Call CanTp_TxConfirmation.
    02: VP(CanTp.JTM_0007):
        Check if the CanTp_TxConfirmation function referenced by the entry jump table
        is called with the correct parameter.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.JTM_0007</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>924</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1693</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_40098</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_Impl_JtCli_Tmpl/source/application/Tst_40098.c</sourcefile>
      <sourceline>62</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    The Gpt callback function calls the corresponding entry jump table function.
  
Test Object: 
    Entry jump table
  
Test Precondition: 
    The address of the entry jump table is provided via configuration parameter
    as:modconf('CanTp')[1]/CanTpJumpTable/CanTpJumpTableAddress.
  
Test Execution: 
    01: Call the configured Gpt callback function.
    02: VP(CanTp.JTM_0007):
        Check if the CanTp_STminCallback function referenced by the entry jump table is called
        with the correct parameter.
    03: Call the another configured Gpt callback function.
    04: VP(CanTp.JTM_0007):
        Check if the CanTp_STminCallback function referenced by the entry jump table is called
        with the correct parameter.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.JTM_0007</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>924</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1694</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_40109</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_Impl_JtCli_Tmpl/source/application/Tst_40109.c</sourcefile>
      <sourceline>56</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    CanTp_GetNSa calls the corresponding entry jump table function.
  
Test Object: 
    Entry jump table
  
Test Precondition: 
    The address of the entry jump table is provided via configuration parameter
    as:modconf('CanTp')[1]/CanTpJumpTable/CanTpJumpTableAddress.
  
Test Execution: 
    01: Call CanTp_GetNSa.
    02: VP(CanTp.JTM_0007):
        Check if the CanTp_GetNSa function referenced by the entry jump table is called with the
        correct parameters and the return value of this function is returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.JTM_0007</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>924</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1695</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_40110</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_Impl_JtCli_Tmpl/source/application/Tst_40110.c</sourcefile>
      <sourceline>56</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    CanTp_SetNSa calls the corresponding entry jump table function.
  
Test Object: 
    Entry jump table
  
Test Precondition: 
    The address of the entry jump table is provided via configuration parameter
    as:modconf('CanTp')[1]/CanTpJumpTable/CanTpJumpTableAddress.
  
Test Execution: 
    01: Call CanTp_SetNSa.
    02: VP(CanTp.JTM_0007):
        Check if the CanTp_SetNSa function referenced by the entry jump table is called with the
        correct parameters and the return value of this function is returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.JTM_0007</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>924</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1696</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_40111_ChangeParameter</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_Impl_JtCli_Tmpl/source/application/Tst_40111.c</sourcefile>
      <sourceline>56</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    CanTp_ChangeParameter calls the corresponding entry jump table function.
  
Test Object: 
    Entry jump table
  
Test Precondition: 
    The address of the entry jump table is provided via configuration parameter
    as:modconf('CanTp')[1]/CanTpJumpTable/CanTpJumpTableAddress.
  
Test Execution: 
    01: Call CanTp_ChangeParameter.
    02: VP(CanTp.JTM_0007):
        Check if the CanTp_ChangeParameter function referenced by the entry jump table is called.
        All function parameters shall be within valid ranges. The return value of this function
        is returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.JTM_0007</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>924</internalId></provcov>
        <provcov>
          <linksto>CanTp.EB.CanTp_ChangeRxParameter.BSandSTmin</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>753</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1697</internalId></specobject>
    <specobject>
      <id>TS_CANTP_40111_ReadParameter</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_Impl_JtCli_Tmpl/source/application/Tst_40111.c</sourcefile>
      <sourceline>153</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    CanTp_ReadParameter calls the corresponding entry jump table function.
  
Test Object: 
    Entry jump table
  
Test Precondition: 
    The address of the entry jump table is provided via configuration parameter
    as:modconf('CanTp')[1]/CanTpJumpTable/CanTpJumpTableAddress.
  
Test Execution: 
    01: Call CanTp_ReadParameter.
    02: VP(CanTp.JTM_0007):
        Check if the CanTp_ReadParameter function referenced by the entry jump table is called.
        All function parameters shall be within valid ranges. The return value of this function
        is returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.JTM_0007</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>924</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1698</internalId></specobject>
    <specobject>
      <id>TS_CANTP_40111_ChangeTxParameter</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_Impl_JtCli_Tmpl/source/application/Tst_40111.c</sourcefile>
      <sourceline>242</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    CanTp_ChangeTxParameter calls the corresponding entry jump table function.
  
Test Object: 
    Entry jump table
  
Test Precondition: 
    The address of the entry jump table is provided via configuration parameter
    as:modconf('CanTp')[1]/CanTpJumpTable/CanTpJumpTableAddress.
  
Test Execution: 
    01: Call CanTp_ChangeTxParameter.
    02: VP():
        Check if the CanTp_ChangeTxParameter function referenced by the entry jump table is called.
        All function parameters shall be within valid ranges. The return value of this function
        is returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanTp_ChangeTxParameter</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>748</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1699</internalId></specobject>
    <specobject>
      <id>TS_CANTP_40111_ResetTxParameter</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_Impl_JtCli_Tmpl/source/application/Tst_40111.c</sourcefile>
      <sourceline>315</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    CanTp_ResetTxParameter calls the corresponding entry jump table function.
  
Test Object: 
    Entry jump table
  
Test Precondition: 
    The address of the entry jump table is provided via configuration parameter
    as:modconf('CanTp')[1]/CanTpJumpTable/CanTpJumpTableAddress.
  
Test Execution: 
    01: Call CanTp_ResetTxParameter.
    02: VP():
        Check if the CanTp_ResetTxParameter function referenced by the entry jump table is called.
        All function parameters shall be within valid ranges. The return value of this function
        is returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.EB.CanTp_ResetTxParameter</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>754</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1700</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_40112</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_Impl_JtCli_Tmpl/source/application/Tst_40112.c</sourcefile>
      <sourceline>51</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    CanTp_CancelReceive calls the corresponding entry jump table function.
  
Test Object: 
    Entry jump table
  
Test Precondition: 
    The address of the entry jump table is provided via configuration parameter
    as:modconf('CanTp')[1]/CanTpJumpTable/CanTpJumpTableAddress.
  
Test Execution: 
    01: Call CanTp_CancelReceive.
    02: VP(CanTp.JTM_0007):
        Check if the CanTp_CancelReceive function referenced by the entry jump table is called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.JTM_0007</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>924</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1701</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_40115</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_Impl_JtServ_Tmpl/source/application/Tst_40115.c</sourcefile>
      <sourceline>58</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Initialize the CanTp via the entry jump table.
  
Test Object: 
    Entry jump table
  
Test Precondition: 
  
Test Execution: 
    01: VP(CanTp.JTM_0001) Call CanTp_Init via the entry jump table.
    02: VP(CanTp.JTM_0028) Check if CanTp is initialized and CanTp_State is set to CANTP_ON.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.JTM_0001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>918</internalId></provcov>
        <provcov>
          <linksto>CanTp.JTM_0028</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>946</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1702</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_40116</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_Impl_JtServ_Tmpl/source/application/Tst_40116.c</sourcefile>
      <sourceline>57</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Get the modules version information via the entry jump table.
  
Test Object: 
    Entry jump table
  
Test Precondition: 
    CanTp is initialized.
  
Test Execution: 
    01: VP(CanTp.JTM_0001): Call CanTp_GetVersionInfo via the entry jump table.
    02: Check if the returned version information is correct.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.JTM_0001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>918</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1703</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_40118</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_Impl_JtServ_Tmpl/source/application/Tst_40118.c</sourcefile>
      <sourceline>53</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    Perform a segmented message transmission. In this way check, that the following funcitons are correctly called via the default exit jump table:
    - CanIf_Transmit
    - PduR_CanTpCopyTxData
    - PduR_CanTpTxConfirmation

    Note: All CanTp API and callback calls are performed via the entry jump table.
  
Test Object: 
    Exit jump table
  
Test Precondition: 
    CanTp is initialized and the used channel is idle.
  
Test Execution: 
    01: Start segmented transmission with a valid Tx N-SDU.
    02: Invoke CanTp_MainFunction to start the transmission.
    03: Check if data is requested with the call of PduR_CanTpCopyTxData.
    04: Check if FF is transmitted with appropriate header information.
    05: Confirm the FF sent.
    06: Transmit the remaining bytes.
    07: Check if PduR_CanTpTxConfirmation is called at the end of transmission
        of the last CF.
  
Test Input: 
  
Test Output: 
    VP(CanTp.JTM_0001): All CanTp jump table server APIs are sucessfully accessed via entry jump
    table.
    VP(CanTp.JTM_0011): The server uses the upper layer callback
    functions defined in the exit table (TstJt_...).
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.JTM_0001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>918</internalId></provcov>
        <provcov>
          <linksto>CanTp.JTM_0011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>928</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1704</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_40119</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_Impl_JtServ_Tmpl/source/application/Tst_40119.c</sourcefile>
      <sourceline>53</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Perform a message reception and in this way check the following calls via the default exit jump table:
    - PduR_CanTpCopyRxData
    - PduR_CanTpRxIndication

    Note: All CanTp API and callback calls are performed via the entry jump table.
  
Test Object: 
    Exit jump table
  
Test Precondition: 
    CanTp is initialized and the used channel is idle.
  
Test Execution: 
    01: Simulate reception of segmented message. Indicate FF.
    02: Check if PduR_CanTpCopyRxData is called to pass the received message.
    03: Call Mainfunction and check if FC frame is sent with
        correct BS and STmin values.
    04: Confirm the FC sent.
    05: Indicate CFs with interleaving mainfunction calls.
    06: After the 2nd CF check if FC is sent, confirm it.
    07: Receive the third CF and check that PduR_CanTpRxIndication is called.
  
Test Input: 
  
Test Output: 
    VP(CanTp.JTM_0001): All CanTp jump table server APIs are sucessfully accessed via entry jump
    table.
    VP(CanTp.JTM_0011): The server uses the upper layer callback
    functions defined in the exit table (TstJt_...).
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.JTM_0001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>918</internalId></provcov>
        <provcov>
          <linksto>CanTp.JTM_0011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>928</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1705</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_40121</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_Impl_JtServ_Tmpl/source/application/Tst_40121.c</sourcefile>
      <sourceline>58</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Register a new (alternate) exit jump table for the following tests and re-initialize the
    CanTp again.
  
Test Object: 
    Exit jump table
  
Test Precondition: 
  
Test Execution: 
    01: Simulate C startup -&gt; shut down CanTp and registration of an alternate jumptable.
    02: VP(CanTp.JTM_0001) Call CanTp_Init via the entry jump table.
    03: VP(CanTp.JTM_0028) Check that CanTp is initialized and CanTp_State is set to CANTP_ON.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.JTM_0001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>918</internalId></provcov>
        <provcov>
          <linksto>CanTp.JTM_0028</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>946</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1706</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_40123</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_Impl_JtServ_Tmpl/source/application/Tst_40123.c</sourcefile>
      <sourceline>53</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Perform a segmented message transmission (same as TS_CANTP_40118).
  
Test Object: 
    Exit jump table
  
Test Precondition: 
    See TS_CANTP_40118
  
Test Execution: 
    See TS_CANTP_40118
  
Test Input: 
  
Test Output: 
    In general, see TS_CANTP_40118.
    The external functions are called via the alternate exit jump table.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.JTM_0011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>928</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1707</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANTP_40124</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTp)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTp/test/ts5/Include/CanTp_Impl_JtServ_Tmpl/source/application/Tst_40124.c</sourcefile>
      <sourceline>53</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Perform a message reception (same as TS_CANTP_40119).
  
Test Object: 
    Exit jump table
  
Test Precondition: 
    See TS_CANTP_40119
  
Test Execution: 
    See TS_CANTP_40119
  
Test Input: 
  
Test Output: 
    In general, see TS_CANTP_40119.
    The external functions are called via the alternate exit jump table.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTp.JTM_0011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>928</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1708</internalId></specobject>
  </specobjects>
  </specdocument>
  <violations/>
  <oreqmViolations/>
</tracingresults>
