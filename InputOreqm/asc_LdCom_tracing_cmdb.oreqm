<?xml version="1.0" encoding="UTF-8"?>
<tracingresults>
  <environment>
    <toolname>ReqM2</toolname>
    <toolversion>1.30.0 (stable)</toolversion>
    <toolcopyright>Copyright 2010 - 2018 Elektrobit Automotive GmbH</toolcopyright>
    <libxmlversion>2.0207</libxmlversion>
    <libxml2compileversion>2.9.10</libxml2compileversion>
    <libxml2runtimeversion>20912</libxml2runtimeversion>
    <perlversion>v5.32.1</perlversion>
    <perlptrsize>64</perlptrsize>
    <commandline>-t -q -o asc_LdCom_tracing_cmdb.oreqm -O /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/TestProtocols/LogBase/requirements -c /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_PluginBuildEnv/common/config/AutoCoreReqM2Rules_RMP4_0.xml -s approved,rejected --wfatal WDUPLICATEID,WDUPLICATEIDANDVER /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/build/reqm/ReqM2_Native/asc_LdCom_requirements_AUTOSAR_SWS_LargeDataCOM.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/build/reqm/ReqM2_Native/asc_LdCom_requirements_LdCom_EB_Extension.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/build/reqm/ReqM2_Native/asc_LdCom_requirements_LdCom_PbcfgM_EB_Extension.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/build/reqm/common_req/LdCom_DbgInst_EB_Extension.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/build/reqm/common_req/LdCom_PbcfgM_EB_Extension.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/build/reqm/common_req/LdCom_PduLengthType_EB_Extension.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/build/reqm/common_req/LdCom_VerifyStub_EB_Extension.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/build/reqm/ReqM2_GenericImporter/reqm_DEV.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/build/reqm/ReqM2_GenericImporter/reqm_IMPL.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/build/reqm/ReqM2_GenericImporter/reqm_IMPLXML.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/build/reqm/ReqM2_OldCImporter/reqm_SWUTS_LEGACY.reqm</commandline>
    <timestamp>Mon Jun 17 19:42:35 2024</timestamp>
  </environment>
  <cmdline>
    <cmdparam>
      <name>I</name>
      <values>
        <value>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/TestProtocols/LogBase/requirements</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>O</name>
      <values>
        <value>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/TestProtocols/LogBase/requirements</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>c</name>
      <values>
        <value>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_PluginBuildEnv/common/config/AutoCoreReqM2Rules_RMP4_0.xml</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>o</name>
      <values>
        <value>asc_LdCom_tracing_cmdb.oreqm</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>q</name>
    </cmdparam>
    <cmdparam>
      <name>s</name>
      <values>
        <value>approved</value>
        <value>rejected</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>t</name>
    </cmdparam>
    <cmdparam>
      <name>wfatal</name>
      <values>
        <value>WDUPLICATEID</value>
        <value>WDUPLICATEIDANDVER</value>
      </values>
    </cmdparam>
  </cmdline>
  <inputfiles>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/build/reqm/ReqM2_Native/asc_LdCom_requirements_AUTOSAR_SWS_LargeDataCOM.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/build/reqm/ReqM2_Native/asc_LdCom_requirements_LdCom_EB_Extension.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/build/reqm/ReqM2_Native/asc_LdCom_requirements_LdCom_PbcfgM_EB_Extension.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/build/reqm/common_req/LdCom_DbgInst_EB_Extension.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/build/reqm/common_req/LdCom_PbcfgM_EB_Extension.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/build/reqm/common_req/LdCom_PduLengthType_EB_Extension.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/build/reqm/common_req/LdCom_VerifyStub_EB_Extension.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/build/reqm/ReqM2_GenericImporter/reqm_DEV.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/build/reqm/ReqM2_GenericImporter/reqm_IMPL.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/build/reqm/ReqM2_GenericImporter/reqm_IMPLXML.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/build/reqm/ReqM2_OldCImporter/reqm_SWUTS_LEGACY.reqm</inputfile>
  </inputfiles>
  <configuration>
    <doctypes>
    <regexs>
      <!-- external level -->
      <regex>creq</regex>       <!-- since 10/1018: introduced for updated tracing model-->

      <!-- product line level -->
      <regex>fea</regex>
      <regex>swpad</regex>      <!-- since 10/1018: introduced for updated tracing model-->
      <regex>swts</regex>

      <!-- bundle level -->
      <regex>swrs</regex>
      <regex>swad</regex>
      <regex>swintts</regex>

      <!-- module level -->
      <regex>swdd</regex>
      <regex>swurs</regex>      <!-- since 10/1018: introduced for updated tracing model-->
      <regex>swmts</regex>      <!-- since 01/1010: introduced for updated tracing model RMP4.0-->
      <regex>swuts</regex>
      <regex>impl</regex>

      <!-- legacy items -->
      <regex>dev</regex>
      <regex>man</regex>
      <regex>lim</regex>
    </regexs>
  </doctypes>
    <rules>
    <!-- The Ruleset for RMP4.0 is currently identical to the previous rule set. This rule is
        intoduce to show that the right file is uses. It will be removed when the RMP4.0 rule set is
    reworked -->
    <rule>
      <name>INFO.Rule set RMP4.0</name>
      <description>This rules indicates that RMP4.0 rule set is used.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status!='approved') and (./status!='rejected')]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>WRN.general.doctypes</name>
      <description>The used doctype is not part of the tracing model</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobjects/@doctype</applyto>
          <condition>((. != 'creq') or (. != 'fea') or (. != 'swpad') or (. != 'swts') or (. != 'swrs') or (. !='swad') or (. != 'swintts') or (.!= 'swdd') or (. != 'swurs') or (. != 'swmts') or (. != 'swuts') or (. != 'impl') or (. != 'dev') or (. != 'man') or (. != 'lim'))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.status</name>
      <description>All specification objects must be either in status=approved or in status=rejected. Other
        statuses are not allowed. How to fix: Set status to rejected or approved.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status!='approved') and (./status!='rejected')]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.rejected</name>
      <description>Status status=rejected is only allowed for requirements. How to fix: set to approved for specification object that are not requirements.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype!='swrs')  and (../@doctype!='swmrs') and (../@doctype!='swurs') and (./status='rejected')]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.comment</name>
      <description>Specification objects with status=rejected shall have a comment or rationale that
        starts with on of the following texts: "This requirement is informational only", "This requirement is not applicable".
        How to fix: Add some text starting with "This requirement is informational only"
        or "This requirement is not applicable" to either the comment or to the rationale.
        Comment: Implementation of check checks for contains instead of starts-with since there is
        no trim function in the used XPATH engine.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status='rejected')]</applyto>
          <condition>contains(./comment,"This requirement is informational only") or contains(./rationale,"This requirement is informational only") or contains(./comment,"This requirement is not applicable") or contains(./rationale,"This requirement is not applicable")</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.rejected.coverage</name>
      <description>Specification objects with status=rejected shall not need coverage. How to fix: remove need for coverage.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status='rejected')]</applyto>
          <condition>count(./needscoverage)=0</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swurs.needscoverage.count</name>
      <description>Unit requirements with status=approved need to be covered, exceptions from
      this rule: configuration requirements (postfix "_CONF" or "_Conf" or prefix "ECUC_") and requirements with
      a comment starting with "The adherence to this requirement is ensured by the following
      release check (URL to the checklist template plus ID of the check):".
      How to fix: Provide a needsobj element for those specobjects or comment according to the rule.
      </description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swurs') and (./status='approved') and count(./needscoverage/needsobj)=0 and count(./fulfilledby/ffbObj)=0]</applyto>
          <!--This condition is false if the id of a specification object does not end with '_Conf' or '_CONF' or does not start with ECUC_ -->
          <condition>substring-after(./id,"ECUC_")!="" or substring-before(./id,"_Conf")!="" or substring-before(./id,"_CONF")!="" or contains(./comment,"The adherence to this requirement is ensured by the following release check (URL to the checklist template plus ID of the check):")</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swurs.needscoverage.rationale</name>
      <description>Requirements with status=approved and without coverage needs that are
        configuration requirements (postfix "_CONF" or "_Conf" or prefix "ECUC_") shall have a comment or rationale
        with the following text: "This is a configuration parameter requirement without functional
        specification.". How to fix: Add some text starting with "This is a configuration parameter
        requirements without functional specification" to either the comment or to the rationale.</description>
      <regexchecks>
        <regexcheck>
          <applyto>//specobject[(../@doctype='swurs') and (./status='approved') and count(./needscoverage/needsobj)=0 and (substring-after(./id,"ECUC_")!="" or substring-before(./id,"_CONF")!="" or substring-before(./id,"_Conf")!="")]</applyto>
          <regex>This is a configuration parameter requirement without functional specification.</regex>
        </regexcheck>
      </regexchecks>
    </rule>

    <rule>
      <name>ERR.swrs.needscoverage.rationale</name>
      <description>Requirements with status=approved and without coverage needs that are
        configuration requirements (postfix "_CONF" or "_Conf" or prefix "ECUC_") shall have a comment or rationale
        with the following text: "This is a configuration parameter requirement without functional
        specification.". How to fix: Add some text starting with "This is a configuration parameter
        requirements without functional specification" to either the comment or to the rationale.</description>
      <regexchecks>
        <regexcheck>
          <applyto>//specobject[(../@doctype='swrs') and (./status='approved') and count(./needscoverage/needsobj)=0 and (substring-after(./id,"ECUC_")!="" or substring-before(./id,"_CONF")!="" or substring-before(./id,"_Conf")!="")]</applyto>
          <regex>This is a configuration parameter requirement without functional specification.</regex>
        </regexcheck>
      </regexchecks>
    </rule>

    <rule>
      <name>ERR.swurs.releases</name>
      <description>Requirements which originates from AUTOSAR (source tag contains term 'AUTOSAR_SWS', 'AUTOSAR_TPS',
        'AUTOSAR_ASWS' or 'AUTOSAR_TR') shall have their release tag set to 'AUTOSAR {major}.{minor}.{patch}' (e.g. 'AUTOSAR 4.3.0').
        Other requirements (including refinements of AUTOSAR requirements) must not contain any of the listed prefixes as
        part of the source tag.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swurs') and (contains(./source,'AUTOSAR_SWS') or contains(./source,'AUTOSAR_TPS') or contains(./source,'AUTOSAR_ASWS') or contains(./source,'AUTOSAR_TR'))]</applyto>
          <condition>contains(./releases/release,'AUTOSAR')</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swrs.releases</name>
      <description>Requirements which originates from AUTOSAR (source tag contains term 'AUTOSAR_SWS', 'AUTOSAR_TPS',
        'AUTOSAR_ASWS' or 'AUTOSAR_TR') shall have their release tag set to 'AUTOSAR {major}.{minor}.{patch}' (e.g. 'AUTOSAR 4.3.0').
        Other requirements (including refinements of AUTOSAR requirements) must not contain any of the listed prefixes as
        part of the source tag.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swrs') and (contains(./source,'AUTOSAR_SWS') or contains(./source,'AUTOSAR_TPS') or contains(./source,'AUTOSAR_ASWS') or contains(./source,'AUTOSAR_TR'))]</applyto>
          <condition>contains(./releases/release,'AUTOSAR')</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swdd.needscoverage.count</name>
      <description>Design elements with status=approved need to be covered.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swdd') and (./status='approved') and count(./needscoverage/needsobj)=0]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swurs.needscoverage.doctypes</name>
      <description>Requirements can be covered only by swurs, swad, dev, lim, swdd, impl, swuts, swmts, or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swurs')]</applyto>
          <condition>(./needscoverage/needsobj="swurs" or ./needscoverage/needsobj="swad" or ./needscoverage/needsobj="dev" or ./needscoverage/needsobj="lim" or ./needscoverage/needsobj="swdd" or ./needscoverage/needsobj="impl" or ./needscoverage/needsobj="swuts" or ./needscoverage/needsobj="swmts" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swrs.needscoverage.doctypes</name>
      <description>Requirements of type swrs can be covered only by swrs, swurs, swad, swintts or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swrs')]</applyto>
          <condition>(./needscoverage/needsobj="swrs" or ./needscoverage/needsobj="swurs" or ./needscoverage/needsobj="swad" or ./needscoverage/needsobj="swuts" or ./needscoverage/needsobj="swintts" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swdd.needscoverage.doctypes</name>
      <description>Design elements of type swdd can only be covered by swdd, swurs, impl, swuts, lim or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swdd')]</applyto>
          <condition>(./needscoverage/needsobj="swdd" or ./needscoverage/needsobj="swurs" or ./needscoverage/needsobj="impl" or ./needscoverage/needsobj="swuts" or ./needscoverage/needsobj="swmts" or ./needscoverage/needsobj="lim" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.dev.needscoverage.count</name>
      <description>Deviations shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='dev')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swuts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swuts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swmts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swmts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swintts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swintts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.man.needscoverage.count</name>
      <description>Manual test cases shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='man')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.impl.needscoverage.count</name>
      <description>Source code shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='impl')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.lim.needscoverage.count</name>
      <description>Limitations shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='lim')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.fea.needscoverage.test</name>
      <description>Features shall be tested by software test ('swts') or manuel test ('man'). If no test is planned a justification shall be given.
                   A justification can be given in the futherinfo tag. The justification shall start with this rule name.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='fea')]</applyto>
          <condition>(
               ./needscoverage/needsobj="swts" or ./needscoverage/needsobj="man" or ./fulfilledby/ffbObj/ffbType="swts" or ./fulfilledby/ffbObj/ffbType="man" or contains(./furtherinfo,"fea.needscoverage.test") or contains(./furtherinfo,"fea.needscoverage.doctypes"))</condition>
        </conditioncheck>
      </conditionchecks>
          </rule>

    <rule>
      <name>WRN.fea.needscoverage.impl</name>
      <description>Features shall be covered by implementation fea, swrs, swad, swpad, swurs, man and swts. For lagacy features a justification is acceppted. A justification can be given in the futherinfo tag. The justification shall start with this rule name.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='fea')]</applyto>
          <condition>( ./needscoverage/needsobj="swrs" or ./fulfilledby/ffbObj/ffbType="swrs" or ./fulfilledby/ffbObj/ffbType="swad" or ./needscoverage/needsobj="swpad" or ./fulfilledby/ffbObj/ffbType="swpad" or ./needscoverage/needsobj="swurs" or ./fulfilledby/ffbObj/ffbType="swurs" or ./needscoverage/needsobj="fea" or ./fulfilledby/ffbObj/ffbType="fea" or contains(./furtherinfo,"fea.needscoverage.impl"))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>


    <rule>
      <name>ERR.swad.fulfilledby.doctypes</name>
      <description>Architectural design objects of type swad can only be covered by swurs, swad, swdd, swintts, man, otherwise they should be refined with swrs</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swad')]</applyto>
          <condition>(./fulfilledby/ffbObj/ffbType="swurs" or ./needscoverage/needsobj="swurs" or ./fulfilledby/ffbObj/ffbType="req" or ./needscoverage/needsobj="req" or ./fulfilledby/ffbObj/ffbType="swad" or ./needscoverage/needsobj="swad" or ./fulfilledby/ffbObj/ffbType="swdd" or ./fulfilledby/ffbObj/ffbType="swintts" or ./needscoverage/needsobj="swintts" or ./fulfilledby/ffbObj/ffbType="man" or ./needscoverage/needsobj="man") </condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swmts.providescoverage.doctypes</name>
      <description>Test case specifications (tcs) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='tcs')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.man.providescoverage.doctypes</name>
      <description>Manual test case specification (man) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='man')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

   <rule>
      <name>ERR.swuts.providescoverage.doctypes</name>
      <description>Software unit test case specification (swuts) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swuts')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

   <rule>
      <name>ERR.swintts.providescoverage.doctypes</name>
      <description>Software integration test case specification (swintts) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swintts')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

   <rule>
      <name>ERR.swts.providescoverage.doctypes</name>
      <description>Software test case specification (swts) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swts')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

  </rules>
    <oreqmRules>

        <rule>
            <name>WRN.swts.needscoverage.count</name>
            <description>Violated if there are more than 10 swts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
        <rule>
            <name>WRN.man.needscoverage.count</name>
            <description>Violated if there are more than 10 man specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='man']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='man']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>man.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
        <rule>
            <name>WRN.swintts.needscoverage.count</name>
            <description>Violated if there are more than 10 swintts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swintts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swintts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swintts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
        <rule>
            <name>WRN.swmts.needscoverage.count</name>
            <description>Violated if there are more than 10 swmts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swmts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swmts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swmts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swuts.needscoverage.count</name>
            <description>Violated if there are more than 10 swuts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swuts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swuts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swuts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swpad.needscoverage.count</name>
            <description>Violated if there are more than 10 swpad specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swpad']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swpad']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swpad.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swrs.needscoverage.count</name>
            <description>Violated if there are more than 10 swrs specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swrs']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swrs']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swrs.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swad.needscoverage.count</name>
            <description>Violated if there are more than 10 swad specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swad']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swad']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swad.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swurs.needscoverage.count</name>
            <description>Violated if there are more than 10 swurs specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swurs']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swurs']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swurs.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swdd.needscoverage.count</name>
            <description>Violated if there are more than 10 swdd specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swdd']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swdd']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swdd.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.impl.needscoverage.count</name>
            <description>Violated if there are more than 10 impl specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='impl']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='impl']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>impl.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swrs.fulfilledby.count</name>
            <description>Violated if there are more than 10 swrs specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swrs'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swrs'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swrs.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swad.fulfilledby.count</name>
            <description>Violated if there are more than 10 swad specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swad'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swad'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swad.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swurs.fulfilledby.count</name>
            <description>Violated if there are more than 10 swurs specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swurs'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swurs'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swurs.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swdd.fulfilledby.count</name>
            <description>Violated if there are more than 10 swdd specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swdd'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swdd'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swdd.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
  </oreqmRules>
  </configuration>
  <specdocument>
    <specobjects doctype="swurs">

    <specobject>
      <id>LdCom.SWS_LDCOM_00001</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 4.2.2</source>
      <version>1</version>
      <description>
        The LdCom.c file shall include:
         - PduR_LdCom.h
         - Rte_Cbk.h
         - LdCom_Lcfg.h
         - LdCom_PBcfg.h
        (SRS_BSW_00346, SRS_BSW_00381, SRS_BSW_00412)
      </description>
      <comment>
        Clarification about following includes required by SWS:
          - LdCom_Cbk.h
          - Det.h

        The implementation of LdCom.c has no usage for the Rte_Cbk.h.
        The declaration of the callbacks are needed by the LdCom_Lcfg.h which includes the Rte_Cbk.h.

        Incorporated Bugzilla RfC 70339 'Naming convention for Header file LdCom_PBCfg.h is incorrect',
        see https://www.autosar.org/bugzilla/show_bug.cgi?id=70339.
      </comment>
      <releases>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/LdCom.c.m4_40</srcid><srcstatus/><internalId>151</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/LdCom.c.m4_44</srcid><srcstatus/><internalId>152</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/LdCom.c.m4_48</srcid><srcstatus/><internalId>153</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>0</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LDCOM_00002</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 4.2.2</source>
      <version>1</version>
      <description>
        The LdCom.h file shall include:
          - LdCom_Cfg.h
          - ComStack_Types.h
          - LdCom_Types.h
        (SRS_BSW_00346, SRS_BSW_00381, SRS_BSW_00412)
      </description>
      <comment>
        Clarification about following includes required by SWS (see RfC 63921):
          - LdCom_MemMap.h
      </comment>
      <releases>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/LdCom.h_9</srcid><srcstatus/><internalId>132</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/include/LdCom.h_13</srcid><srcstatus/><internalId>133</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/include/LdCom.h_15</srcid><srcstatus/><internalId>134</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00050</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        The LdCom implementation shall include Det.h if LdComDevErrorDetect is enabled.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/LdCom.c.m4_51</srcid><srcstatus/><internalId>154</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00007</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        The AUTOSAR LdCom module's initialization function LdCom_Init shall initialize all internal
        data.
      </description>
      <comment>
        The only data to be considered is LdCom_State.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_IMP_01001_Init_State</srcid><srcstatus/><internalId>232</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>3</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00008</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        The AUTOSAR LdCom module shall provide the API function LdCom_DeInit for de-initialization of
        the AUTOSAR LdCom module. Inside this function call all de-initialization shall take place.
      </description>
      <comment>
        The only data to be considered is LdCom_State.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_IMP_01002_DeInit_State</srcid><srcstatus/><internalId>233</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>4</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00005</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        When called by PduR LdCom shall use the passed PDU Id as Handle Id (LdComHandleId
        ECUC_LdCom_00005), to derive the actualAPI from configuration and use it when passing the
        call towards RTE.
      </description>
      <comment>
        This comprises the APIs:
        - Rte_LdComCbkRxIndication
        - Rte_LdComCbkTriggerTransmit
        - Rte_LdComCbkTxConfirmation
        - Rte_LdComCbkStartOfReception
        - Rte_LdComCbkCopyRxData
        - Rte_LdComCbkTpRxIndication
        - Rte_LdComCbkCopyTxData
        - Rte_LdComCbkTpTxConfirmation
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_CON_02001_RxInd_InvokeUp</srcid><srcstatus/><internalId>208</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_CON_02002_TrigTx_InvokeUp</srcid><srcstatus/><internalId>209</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_CON_02007_TrigTx_InvokeUp_Data</srcid><srcstatus/><internalId>210</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_CON_02003_TxConf_InvokeUp</srcid><srcstatus/><internalId>211</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_CON_02010_StartOfReception_InvokeUp</srcid><srcstatus/><internalId>215</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_CON_02011_CopyRxData_InvokeUp</srcid><srcstatus/><internalId>216</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_CON_02012_TpRxInd_InvokeUp</srcid><srcstatus/><internalId>217</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_CON_02013_CopyTxData_InvokeUp</srcid><srcstatus/><internalId>218</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_CON_02014_TpTxConf_InvokeUp</srcid><srcstatus/><internalId>219</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>5</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00009</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        When called by the RTE, LdCom shall use the Signal Id ("id" parameter in the call) as
        LdComHandleId (ECUC_LdCom_00005) to look-up the correct LdComIPdu in the LdCom configuration.
        Using the LdComPduRef configuration parameter (ECUC_LdCom_00010)the corresponding PDU Id in the
        PduR'S configuration shall be derived. This PDU Id shall then be used when forwarding the call
        towards the PduR.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_CON_02020_Transmit_InvokeLoTp</srcid><srcstatus/><internalId>225</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_CON_02021_Transmit_InvokeLoIf</srcid><srcstatus/><internalId>226</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>6</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00010</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        When LdCom_Transmit is invoked, LdCom shall invoke PduR_LdComTransmit by replacing the Signal
        Id by the according PDU Id.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_CON_02020_Transmit_InvokeLoTp</srcid><srcstatus/><internalId>225</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_CON_02021_Transmit_InvokeLoIf</srcid><srcstatus/><internalId>226</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.LdCom.UnsupportedSignalId</srcid><srcstatus/><internalId>130</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>7</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00011</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        When LdCom_TriggerTransmit is invoked, LdCom shall invoke Rte_LdComCbkTriggerTransmit_&lt;sn&gt;
        based on the PDU Id passed to of LdCom_TriggerTransmit as parameter.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>LdCom.SWS_LdCom_00011.1</srcid><srcstatus/><internalId>9</internalId></linkedfrom><linkedfrom><srcid>LdCom.SWS_LdCom_00011.2</srcid><srcstatus/><internalId>10</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>8</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00011.1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        When LdCom_TriggerTransmit is invoked by PduR and parameter LdComTriggerTransmit is configured,
        LdCom shall call the configured Rte_LdComCbkTriggerTransmit_&lt;sn&gt; based on the PDU Id
        passed to LdCom_TriggerTransmit.
      </description>
      <comment>
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_CON_02002_TrigTx_InvokeUp</srcid><srcstatus/><internalId>209</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_CON_02007_TrigTx_InvokeUp_Data</srcid><srcstatus/><internalId>210</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>8</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>9</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00011.2</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If parameter LdComTriggerTransmit is not configured but LdCom_TriggerTransmit is invoked by PduR, LdCom shall
        call the LdCom_TriggerTransmit dummy callback.
      </description>
      <comment>
        Based on ASCLDCOM-42 and Bugzilla RfC 70498 'Clarification regarding the existence of Rte_LdCom callback functions',
        see https://www.autosar.org/bugzilla/show_bug.cgi?id=70498
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_CON_02005_TrigTx_InvokeUp_Dummy</srcid><srcstatus/><internalId>213</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>LdCom.EB.SWS_LdCom_00042_DummyCbk</srcid><srcstatus/><internalId>99</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>8</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>10</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00046</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        When LdCom_TxConfirmation is invoked, LdCom shall invoke Rte_LdComCbkTxConfirmation_&lt;sn&gt; based
        on the PDU Id passed to of LdCom_TxConfirmation as parameter
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>LdCom.SWS_LdCom_00046.1</srcid><srcstatus/><internalId>12</internalId></linkedfrom><linkedfrom><srcid>LdCom.SWS_LdCom_00046.2</srcid><srcstatus/><internalId>13</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>11</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00046.1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        When LdCom_TxConfirmation is invoked by PduR and parameter LdComTxConfirmation is configured,
        LdCom shall call the configured Rte_LdComCbkTxConfirmation_&lt;sn&gt; based on the PDU Id
        passed to LdCom_TxConfirmation.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_CON_02003_TxConf_InvokeUp</srcid><srcstatus/><internalId>211</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00046</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>11</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>12</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00046.2</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If parameter LdComTxConfirmation is not configured but LdCom_TxConfirmation is invoked by PduR, LdCom shall
        call the LdCom_TxConfirmation dummy callback.
      </description>
      <comment>
        Based on ASCLDCOM-42 and Bugzilla RfC 70498 'Clarification regarding the existence of Rte_LdCom callback functions',
        see https://www.autosar.org/bugzilla/show_bug.cgi?id=70498
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_CON_02006_TxConf_InvokeUp_Dummy</srcid><srcstatus/><internalId>214</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>LdCom.EB.SWS_LdCom_00053_DummyCbk</srcid><srcstatus/><internalId>100</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00046</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>11</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>13</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00012</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        LdCom shall pass invocations of LdCom_Transmit to PduR_LdComTransmit by replacing the Signal Id
        by the according PDU Id.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_CON_02020_Transmit_InvokeLoTp</srcid><srcstatus/><internalId>225</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>14</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00013</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        LdCom shall forward invocations of LdCom_CopyTxData and LdCom_TpTxConfirmation to RTE by
        invoking the corresponding Rte_LdComCbkCopyTxData_&lt;sn&gt; or Rte_LdComCbkTpTxConfirmation_&lt;sn&gt;
        based on the PDU Id passed to LdCom_CopyTxData and LdCom_TpTxConfirmation as parameter.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>LdCom.SWS_LdCom_00013.1</srcid><srcstatus/><internalId>16</internalId></linkedfrom><linkedfrom><srcid>LdCom.SWS_LdCom_00013.2</srcid><srcstatus/><internalId>17</internalId></linkedfrom><linkedfrom><srcid>LdCom.SWS_LdCom_00013.3</srcid><srcstatus/><internalId>18</internalId></linkedfrom><linkedfrom><srcid>LdCom.SWS_LdCom_00013.4</srcid><srcstatus/><internalId>19</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>15</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00013.1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        When LdCom_CopyTxData is invoked by PduR and parameter LdComCopyTxData is configured,
        LdCom shall call the configured Rte_LdComCbkCopyTxData_&lt;sn&gt; based on the PDU Id
        passed to LdCom_CopyTxData.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_CON_02013_CopyTxData_InvokeUp</srcid><srcstatus/><internalId>218</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00013</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>15</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>16</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00013.2</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If parameter LdComCopyTxData is not configured but LdCom_CopyTxData is invoked by PduR, LdCom shall
        call the LdCom_CopyTxData dummy callback.
      </description>
      <comment>
        Based on ASCLDCOM-42 and Bugzilla RfC 70498 'Clarification regarding the existence of Rte_LdCom callback functions',
        see https://www.autosar.org/bugzilla/show_bug.cgi?id=70498
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_CON_02018_CopyTxData_InvokeUp_Dummy</srcid><srcstatus/><internalId>223</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>LdCom.EB.SWS_LdCom_00036_DummyCbk</srcid><srcstatus/><internalId>96</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00013</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>15</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>17</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00013.3</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        When LdCom_TpTxConfirmation is invoked by PduR and parameter LdComTpTxConfirmation is configured,
        LdCom shall call the configured Rte_LdComCbkTpTxConfirmation_&lt;sn&gt; based on the PDU Id
        passed to LdCom_TpTxConfirmation.
      </description>
      <comment>
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_CON_02014_TpTxConf_InvokeUp</srcid><srcstatus/><internalId>219</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00013</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>15</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>18</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00013.4</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If parameter LdComTpTxConfirmation is not configured but LdCom_TpTxConfirmation is invoked by PduR, LdCom shall
        call the LdCom_TpTxConfirmation dummy callback.
      </description>
      <comment>
        Based on ASCLDCOM-42 and Bugzilla RfC 70498 'Clarification regarding the existence of Rte_LdCom callback functions',
        see https://www.autosar.org/bugzilla/show_bug.cgi?id=70498
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_CON_02019_TpTxConf_InvokeUp_Dummy</srcid><srcstatus/><internalId>224</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>LdCom.EB.SWS_LdCom_00037_DummyCbk</srcid><srcstatus/><internalId>97</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00013</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>15</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>19</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00014</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        When LdCom_RxIndication is invoked,LdCom shall call the corresponding Rte_LdComCbkRxIndication_&lt;
        sn&gt; based on the PDU Id passed to of LdCom_RxIndication as parameter.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>LdCom.SWS_LdCom_00014.1</srcid><srcstatus/><internalId>21</internalId></linkedfrom><linkedfrom><srcid>LdCom.SWS_LdCom_00014.2</srcid><srcstatus/><internalId>22</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>20</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00014.1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        When LdCom_RxIndication is invoked by PduR and parameter LdComRxIndication is configured,
        LdCom shall call the configured Rte_LdComCbkRxIndication_&lt;sn&gt; based on the PDU Id
        passed to LdCom_RxIndication.
      </description>
      <comment>
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_CON_02001_RxInd_InvokeUp</srcid><srcstatus/><internalId>208</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00014</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>20</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>21</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00014.2</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If parameter LdComRxIndication is not configured but LdCom_RxIndication is invoked by PduR, LdCom shall
        call the LdCom_RxIndication dummy callback.
      </description>
      <comment>
        Based on ASCLDCOM-42 and Bugzilla RfC 70498 'Clarification regarding the existence of Rte_LdCom callback functions',
        see https://www.autosar.org/bugzilla/show_bug.cgi?id=70498
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_CON_02004_RxInd_InvokeUp_Dummy</srcid><srcstatus/><internalId>212</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>LdCom.EB.SWS_LdCom_00041_DummyCbk</srcid><srcstatus/><internalId>98</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00014</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>20</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>22</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00015</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        When LdCom_StartOfReception is invoked by PduR,LdCom shall call the corresponding
        Rte_LdComCbkStartOfReception_&lt;sn&gt;&gt; based on the PDU Id passed to of LdCom_StartOfReception as
        parameter.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>LdCom.SWS_LdCom_00015.1</srcid><srcstatus/><internalId>24</internalId></linkedfrom><linkedfrom><srcid>LdCom.SWS_LdCom_00015.2</srcid><srcstatus/><internalId>25</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>23</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00015.1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        When LdCom_StartOfReception is invoked by PduR and parameter LdComStartOfReception is configured,
        LdCom shall call the configured Rte_LdComCbkStartOfReception_&lt;sn&gt; based on the PDU Id
        passed to LdCom_StartOfReception.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_CON_02010_StartOfReception_InvokeUp</srcid><srcstatus/><internalId>215</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00015</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>23</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>24</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00015.2</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If parameter LdComStartOfReception is not configured but LdCom_StartOfReception is invoked by PduR, LdCom shall
        call the LdCom_StartOfReception dummy callback.
      </description>
      <comment>
        Based on ASCLDCOM-42 and Bugzilla RfC 70498 'Clarification regarding the existence of Rte_LdCom callback functions',
        see https://www.autosar.org/bugzilla/show_bug.cgi?id=70498
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_CON_02015_StartOfReception_InvokeUp_Dummy</srcid><srcstatus/><internalId>220</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>LdCom.EB.SWS_LdCom_00038_DummyCbk</srcid><srcstatus/><internalId>93</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00015</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>23</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>25</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00016</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        When LdCom_CopyRxData is invoked by PduR,LdCom shall call Rte_LdComCbkCopyRxData_&lt;sn&gt; based on
        the PDU Id passed to of LdCom_CopyRxData as parameter.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>LdCom.SWS_LdCom_00016.1</srcid><srcstatus/><internalId>27</internalId></linkedfrom><linkedfrom><srcid>LdCom.SWS_LdCom_00016.2</srcid><srcstatus/><internalId>28</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>26</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00016.1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        When LdCom_CopyRxData is invoked by PduR and parameter LdComCopyRxData is configured,
        LdCom shall call the configured Rte_LdComCbkCopyRxData_&lt;sn&gt; based on the PDU Id
        passed to LdCom_CopyRxData.
      </description>
      <comment>
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_CON_02011_CopyRxData_InvokeUp</srcid><srcstatus/><internalId>216</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00016</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>26</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>27</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00016.2</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If parameter LdComCopyRxData is not configured but LdCom_CopyRxData is invoked by PduR, LdCom shall
        call the LdCom_CopyRxData dummy callback.
      </description>
      <comment>
        Based on ASCLDCOM-42 and Bugzilla RfC 70498 'Clarification regarding the existence of Rte_LdCom callback functions',
        see https://www.autosar.org/bugzilla/show_bug.cgi?id=70498
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_CON_02016_CopyRxData_InvokeUp_Dummy</srcid><srcstatus/><internalId>221</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>LdCom.EB.SWS_LdCom_00039_DummyCbk</srcid><srcstatus/><internalId>94</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00016</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>26</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>28</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00017</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        When LdCom_TpRxIndication is invoked by PduR,LdCom shall call the corresponding
        Rte_LdComTpRxIndication_&lt;sn&gt; based on the PDU Id passed to of LdCom_TpRxIndication as parameter.
      </description>
      <comment>
        The naming convention on Rte_LdComTpRxIndication_&lt;sn&gt; is not applied in this requirement.
        The name without the Cbk is only used in this requirement (see: SWS_LDCOM_00005, SWS_LDCOM_00040).
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>LdCom.SWS_LdCom_00017.1</srcid><srcstatus/><internalId>30</internalId></linkedfrom><linkedfrom><srcid>LdCom.SWS_LdCom_00017.2</srcid><srcstatus/><internalId>31</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>29</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00017.1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        When LdCom_TpRxIndication is invoked by PduR and parameter LdComTpRxIndication is configured,
        LdCom shall call the configured Rte_LdComCbkTpRxIndication_&lt;sn&gt; based on the PDU Id
        passed to LdCom_TpRxIndication.
      </description>
      <comment>
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_CON_02012_TpRxInd_InvokeUp</srcid><srcstatus/><internalId>217</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00017</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>29</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>30</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00017.2</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If parameter LdComTpRxIndication is not configured but LdCom_TpRxIndication is invoked by PduR, LdCom shall
        call the LdCom_TpRxIndication dummy callback.
      </description>
      <comment>
        Based on ASCLDCOM-42 and Bugzilla RfC 70498 'Clarification regarding the existence of Rte_LdCom callback functions',
        see https://www.autosar.org/bugzilla/show_bug.cgi?id=70498
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_CON_02017_TpRxInd_InvokeUp_Dummy</srcid><srcstatus/><internalId>222</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>LdCom.EB.SWS_LdCom_00040_DummyCbk</srcid><srcstatus/><internalId>95</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00017</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>29</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>31</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00018</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        Development Error Types See "SWS_LargeDataCOM__Table_7"
        Type of error                              | Related error code             | Value [hex]
        Error code if any other API service, except
        LdCom_GetVersionInfo is called before the
        AUTOSAR LdCom module was initialized with
        LdCom_Init or after a call to LdCom_Deinit | LDCOM_E_UNINIT                 | 0x02
        API service called with a NULL pointer. In
        case of this error, the API service shall
        return immediately without any further
        action, except for reporting this
        development error.                         | LDCOM_E_PARAM_POINTER          | 0x03
        API service called with wrong PDU-ID       | LDCOM_E_INVALID_PDU_SDU_ID     | 0x04
        API service called with wrong Signal-ID    | LDCOM_E_INVALID_SIGNAL_ID      | 0x05
        Invalid configuration set selection        | LDCOM_E_INIT_FAILED            | 0x06
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>LdCom.SWS_LdCom_00018.UNINIT</srcid><srcstatus/><internalId>33</internalId></linkedfrom><linkedfrom><srcid>LdCom.SWS_LdCom_00018.PARAM_POINTER</srcid><srcstatus/><internalId>34</internalId></linkedfrom><linkedfrom><srcid>LdCom.SWS_LdCom_00018.INVALID_PDU_SDU_ID</srcid><srcstatus/><internalId>35</internalId></linkedfrom><linkedfrom><srcid>LdCom.SWS_LdCom_00018.INVALID_SIGNAL_ID</srcid><srcstatus/><internalId>36</internalId></linkedfrom><linkedfrom><srcid>LdCom.SWS_LdCom_00018.INIT_FAILED</srcid><srcstatus/><internalId>37</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>32</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00018.UNINIT</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        Development Error Types:

        Type of error                           | Related error code   | Value [hex]
        ----------------------------------------------------------------------------
        Error code if any other API service,    | LDCOM_E_UNINIT       | 0x02
        except LdCom_GetVersionInfo is called   |                      |
        before the AUTOSAR LdCom module was     |                      |
        initialized with LdCom_Init or after a  |                      |
        call to LdCom_Deinit                    |                      |
      </description>
      <furtherinfo>
        Justifying rule: WRN.swuts.needscoverage.count violation.
        As this is development type error which is checked by all public APIs, it cannot be refined
        for all public apis
      </furtherinfo>
      <comment>
        This comprises the APIs:
        - LdCom_RxIndication
        - LdCom_TriggerTransmit
        - LdCom_TxConfirmation

        - LdCom_StartOfReception
        - LdCom_CopyRxData
        - LdCom_TpRxIndication
        - LdCom_CopyTxData
        - LdCom_TpTxConfirmation

        - LdCom_Transmit

        EB specific LdCom_IsValidConfig is excluded.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_01001_RxInd_Uninit</srcid><srcstatus/><internalId>175</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_01002_TrigTx_Uninit</srcid><srcstatus/><internalId>176</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_01003_TxConf_Uninit</srcid><srcstatus/><internalId>177</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_01010_StartOfReception_Uninit</srcid><srcstatus/><internalId>178</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_01011_CopyRxData_Uninit</srcid><srcstatus/><internalId>179</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_01012_TpRxInd_Uninit</srcid><srcstatus/><internalId>180</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_01020_CopyTxData_Uninit</srcid><srcstatus/><internalId>181</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_01021_TpTxConf_Uninit</srcid><srcstatus/><internalId>182</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_01030_Transmit_Uninit</srcid><srcstatus/><internalId>183</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_01031_GetVersionInfo_Uninit</srcid><srcstatus/><internalId>184</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_IMP_02001_ErrorCodes</srcid><srcstatus/><internalId>236</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00018</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>32</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>33</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00018.PARAM_POINTER</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        Development Error Types:

        Type of error                           | Related error code   | Value [hex]
        ----------------------------------------------------------------------------
        API service called with a NULL pointer. | LDCOM_E_PARAM_POINTER| 0x03
        In case of this error, the API service  |                      |
        shall return immediately without any    |                      |
        further action, except for reporting    |                      |
        this development error.                 |                      |
      </description>
      <furtherinfo>
        Justifying rule: WRN.swuts.needscoverage.count violation.
        As this is development type error which is checked by all public APIs, it cannot be refined
        for all public apis
      </furtherinfo>
      <comment>
        This comprises the APIs:
        - LdCom_RxIndication
        - LdCom_TriggerTransmit

        - LdCom_StartOfReception
        - LdCom_CopyRxData
        - LdCom_CopyTxData (RetryInfo allowed to be null)

        - LdCom_Transmit

        - LdCom_GetVersionInfo
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_01050_RxInd_ParamNull</srcid><srcstatus/><internalId>187</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_01051_TriggerTx_ParamNull</srcid><srcstatus/><internalId>188</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_01060_StartOfReception_ParamNull</srcid><srcstatus/><internalId>189</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_01061_CopyRxData_ParamNull</srcid><srcstatus/><internalId>190</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_01062_CopyRxData_Param2Null</srcid><srcstatus/><internalId>191</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_01070_CopyTxData_ParamNull</srcid><srcstatus/><internalId>192</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_01071_CopyTxData_ParamNull2</srcid><srcstatus/><internalId>193</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_01080_Transmit_ParamNull</srcid><srcstatus/><internalId>194</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_01081_GetVersionInfo_ParamNull</srcid><srcstatus/><internalId>195</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_IMP_02001_ErrorCodes</srcid><srcstatus/><internalId>236</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00018</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>32</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>34</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00018.INVALID_PDU_SDU_ID</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        Development Error Types:
        Type of error                           | Related error code   | Value [hex]
        ----------------------------------------------------------------------------
        API service called with wrong PDU-ID    | LDCOM_E_INVALID_PDU_SDU_ID| 0x04
      </description>
      <furtherinfo>
        Justifying rule: WRN.swuts.needscoverage.count violation.
        As this is development type error which is checked by all public APIs, it cannot be refined
        for all public apis
      </furtherinfo>
      <comment>
        This comprises the APIs:
        - LdCom_RxIndication
        - LdCom_TriggerTransmit
        - LdCom_TxConfirmation

        - LdCom_StartOfReception
        - LdCom_CopyRxData
        - LdCom_TpRxIndication
        - LdCom_CopyTxData (RetryInfo allowed to be null)
        - LdCom_TpTxConfirmation

        - LdCom_Transmit
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_01090_RxInd_PduIdInvalid</srcid><srcstatus/><internalId>196</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_01091_TrigTx_PduIdInvalid</srcid><srcstatus/><internalId>197</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_01092_TxConf_PduIdInvalid</srcid><srcstatus/><internalId>198</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_01100_StartOfReception_PduIdInvalid</srcid><srcstatus/><internalId>199</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_01101_CopyRxData_PduIdInvalid</srcid><srcstatus/><internalId>200</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_01102_TpRxInd_PduIdInvalid</srcid><srcstatus/><internalId>201</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_01110_CopyTxData_PduIdInvalid</srcid><srcstatus/><internalId>202</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_01111_TpTxConf_PduIdInvalid</srcid><srcstatus/><internalId>203</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_01120_Transmit_PduIdInvalid</srcid><srcstatus/><internalId>204</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_IMP_02001_ErrorCodes</srcid><srcstatus/><internalId>236</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_03020_Transmit_NotAvailable</srcid><srcstatus/><internalId>244</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_03021_Transmit_NotAvailable</srcid><srcstatus/><internalId>245</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00018</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>32</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>35</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00018.INVALID_SIGNAL_ID</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        Development Error Types:

        Type of error                           | Related error code       | Value [hex]
        --------------------------------------------------------------------------------
        API service called with wrong Signal-ID | LDCOM_E_INVALID_SIGNAL_ID| 0x05
      </description>
      <comment>
      </comment>
        <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_IMP_02001_ErrorCodes</srcid><srcstatus/><internalId>236</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00018</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>32</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>36</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00018.INIT_FAILED</id>
      <status>approved</status>
      <source>Bugzilla RfC 70341</source>
      <version>1</version>
      <description>
        Development Error Types:

        Type of error                           | Related error code   | Value [hex]
        ----------------------------------------------------------------------------
        Invalid configuration set selection     | LDCOM_E_INIT_FAILED  | 0x06
      </description>
      <comment>
       Based on Bugzilla RfC 70341 'In case of Postbuild if ConfigPtr is NULL_PTR then the error code LDCOM_E_INIT_FAILED
       should be reported', see https://www.autosar.org/bugzilla/show_bug.cgi?id=70341
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_01040_InitNull_RepError</srcid><srcstatus/><internalId>185</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_01041_InitValidConfig</srcid><srcstatus/><internalId>186</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_IMP_02001_ErrorCodes</srcid><srcstatus/><internalId>236</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00018</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>32</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>37</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00020</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        Module         | Header File      | Imported Type
        ComStack_Types | ComStack_Types.h | BufReq_ReturnType
                         ComStack_Types.h | PduIdType
                         ComStack_Types.h | PduInfoType
                         ComStack_Types.h | PduLengthType
                         ComStack_Types.h | RetryInfoType
                         ComStack_Types.h | TpDataStateType
        Std            | Std_Types.h      | Std_ReturnType
                         Std_Types.h      | Std_VersionInfoType
      </description>
      <comment>AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>LdCom_ComTest_03_ImportedTypes</srcid><srcstatus/><internalId>168</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>38</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00052</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        Name          | LdCom_ConfigType
        Kind          | Structure
        Elements      | implementation specific
                        Type     | --
                        Comment  | The contents of the initialization data structure are
                        implementation specific
        Description   | This type contains the implementation-specific post build configuration
                        structure.
        Available via | LdCom.h
      </description>
      <comment>AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/xgen/LdCom.xgen_63</srcid><srcstatus/><internalId>159</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>39</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00022</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        Service Name       | LdCom_Init
        Syntax             | void LdCom_Init (const LdCom_ConfigType* config)
        Service ID         | 0x01
        [hex]
        Sync/Async         | Synchronous
        Reentrancy         | Non Reentrant
        Parameters (in)    | config | Pointer to the AUTOSAR LdCom module's configuration data.
        Parameters (inout) | None
        Parameters (out)   | None
        Return value       | None
        Description        | This service initializes internal and external interfaces and variables
                             of the AUTOSAR LdCom module for the further processing.
        Available via      | LdCom.h
      </description>
      <comment>AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>LdCom_ComTest_01</srcid><srcstatus/><internalId>167</internalId></linkedfrom><linkedfrom><srcid>LdCom_ComTest_06_TpOnly</srcid><srcstatus/><internalId>169</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_IMP_02002_SID</srcid><srcstatus/><internalId>237</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>40</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00023</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        Service Name         | LdCom_DeInit
        Syntax               | void LdCom_DeInit (void)
        Service ID [hex]     | 0x02
        Sync/Async           | Synchronous
        Reentrancy           | Non Reentrant
        Parameters (in)      | None
        Parameters (inout)   | None
        Parameters (out)     | None
        Return value         | None
        Description          | With a call to LdCom_DeInit the AUTOSAR LdCom module is put into an
                               not initialized state.
        Available via        | LdCom.h
      </description>
      <comment>AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>LdCom_ComTest_01</srcid><srcstatus/><internalId>167</internalId></linkedfrom><linkedfrom><srcid>LdCom_ComTest_06_TpOnly</srcid><srcstatus/><internalId>169</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_IMP_02002_SID</srcid><srcstatus/><internalId>237</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>41</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00024</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        Service Name         | LdCom_GetVersionInfo
        Syntax               | void LdCom_GetVersionInfo (Std_VersionInfoType* versioninfo)
        Service ID [hex]     | 0x03
        Sync/Async           | Synchronous
        Reentrancy           | Non Reentrant
        Parameters (in)      | None
        Parameters (inout)   | None
        Parameters (out)     | versioninfo | Pointer to where to store the version information of
                                             this module.
        Return value         | None
        Description          | Returns the version information of this module.
        Available via        | LdCom.h
      </description>
      <comment>AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>LdCom_ComTest_01</srcid><srcstatus/><internalId>167</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_CON_02030_GetVersionInfo</srcid><srcstatus/><internalId>227</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_IMP_02002_SID</srcid><srcstatus/><internalId>237</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>42</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00045</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        The API LdCom_GetVersionInfo shall be configured byLdComVersionInfoAPI.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>LdCom_ComTest_09_IfRxOnly</srcid><srcstatus/><internalId>172</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_IMP_02003_PreCompileSwitches</srcid><srcstatus/><internalId>238</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>43</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00026</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>2</version>
      <description>
        Service Name          | LdCom_Transmit
        Syntax                | Std_ReturnType LdCom_Transmit (PduIdType Id, const PduInfoType* InfoPtr)
        Service ID [hex]      | 0x49
        Sync/Async            | Synchronous
        Reentrancy            | Reentrant for different Ids. Non reentrant for the same Id.
        Parameters (in)       | Id      | Identifier of the signal to be transmitted.
                              | InfoPtr | Length of and pointer to the signal data and pointer to
                                          MetaData.
        Parameters (inout)    | None
        Parameters (out)      | None
        Return value          | Std_ReturnType | E_OK: Transmit request has been accepted.
                                               | E_NOT_OK: Transmit request has not been accepted.
        Description           | Requests transmission of a signal.
        Available via         | LdCom.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>LdCom_ComTest_01</srcid><srcstatus/><internalId>167</internalId></linkedfrom><linkedfrom><srcid>LdCom_ComTest_06_TpOnly</srcid><srcstatus/><internalId>169</internalId></linkedfrom><linkedfrom><srcid>LdCom_ComTest_08_TxOnly</srcid><srcstatus/><internalId>171</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_IMP_02002_SID</srcid><srcstatus/><internalId>237</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>44</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00048</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        LdCom_CopyTxData, LdCom_TpTxConfirmation shall only be available if at least one LdComIPdu has
        LdComIPduDirection configured to LDCOM_SEND and LdComApiType configured to LDCOM_TP.
      </description>
      <comment>
        What's meant by 'available' leaves room for interpretation.
        EB interpretes it that way that all APIs are defined but functionality is only provided
        as specified.
        If no single LdComIPdu is configured for the considered pair of LdComIPduDirection and
        LdComApiType, no other functionality is executed than:
        - a negative return value delivered if possible by syntax and
        - the error code LDCOM_E_INVALID_PDU_SDU_ID reported for enabled Det.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_IMP_02003_PreCompileSwitches</srcid><srcstatus/><internalId>238</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_03010_CopyTxData_NotAvailable</srcid><srcstatus/><internalId>242</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_03030_PreCompileSwitches</srcid><srcstatus/><internalId>246</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>45</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00049</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        LdCom_StartOfReception, LdCom_CopyRxData, LdCom_TpRxIndicationshall only be available if at
        least one LdComIPdu has LdComIPduDirection configured to LDCOM_RECEIVE and LdComApiType
        configured to LDCOM_TP.
      </description>
      <comment>
        What's meant by 'available' leaves room for interpretation.
        EB interpretes it that way that all APIs are defined but functionality is only provided
        as specified.
        If no single LdComIPdu is configured for the considered pair of LdComIPduDirection and
        LdComApiType, no other functionality is executed than:
        - a negative return value delivered if possible by syntax and
        - the error code LDCOM_E_INVALID_PDU_SDU_ID reported for enabled Det.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_IMP_02003_PreCompileSwitches</srcid><srcstatus/><internalId>238</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_03000_StartOfReception_NotAvailable</srcid><srcstatus/><internalId>239</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_03001_CopyRxData_NotAvailable</srcid><srcstatus/><internalId>240</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_03002_TpRxInd_NotAvailable</srcid><srcstatus/><internalId>241</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_03011_TpTxConf_NotAvailable</srcid><srcstatus/><internalId>243</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_03030_PreCompileSwitches</srcid><srcstatus/><internalId>246</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>46</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00054</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        LdCom_TxConfirmation shall only be available if at least one LdComIPdu has LdComIPduDirection
        configured to LDCOM_SEND and LdComApiType configured to LDCOM_IF.
      </description>
      <comment>
        What is meant by 'available' leaves room for interpretation.
        EB interprets it that way that all APIs are defined but functionality is only provided
        as specified.
        If no single LdComIPdu is configured for the considered pair of LdComIPduDirection and
        LdComApiType, no other functionality is executed than:
        - a negative return value delivered if possible by syntax and
        - the error code LDCOM_E_INVALID_PDU_SDU_ID reported for enabled Det.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_IMP_02003_PreCompileSwitches</srcid><srcstatus/><internalId>238</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_04003_LdCom_TxConfirmation_NotAvailable</srcid><srcstatus/><internalId>249</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_04004_PreCompileSwitches</srcid><srcstatus/><internalId>250</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>47</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00055</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        LdCom_RxIndication shall only be available if at least one LdComIPdu has LdComIPduDirection
        configured to LDCOM_RECEIVE and LdComApiType configured to LDCOM_IF.
      </description>
      <comment>
        What's meant by 'available' leaves room for interpretation.
        EB interprets it that way that all APIs are defined but functionality is only provided
        as specified.
        If no single LdComIPdu is configured for the considered pair of LdComIPduDirection and
        LdComApiType, no other functionality is executed than:
        - a negative return value delivered if possible by syntax and
        - the error code LDCOM_E_INVALID_PDU_SDU_ID reported for enabled Det.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_IMP_02003_PreCompileSwitches</srcid><srcstatus/><internalId>238</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_04001_LdCom_RxIndication_NotAvailable</srcid><srcstatus/><internalId>247</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_04004_PreCompileSwitches</srcid><srcstatus/><internalId>250</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>48</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00027</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>2</version>
      <description>
        Service Name           | LdCom_CopyTxData
        Syntax                 | BufReq_ReturnType LdCom_CopyTxData (
                                   PduIdType id, const PduInfoType* info,
                                   const RetryInfoType* retry, PduLengthType* availableDataPtr)
        Service ID [hex]       | 0x43
        Sync/Async             | Synchronous
        Reentrancy             | Reentrant
        Parameters (in)        | id   | Identification of the transmitted I-PDU.
                               | info | Provides the destination buffer (SduDataPtr) and the number
                                        of bytes to be copied (SduLength). If not enough transmit
                                        data is available, no data is copied by the upper layer
                                        module and BUFREQ_E_BUSY is returned. The lower layer module
                                        may retry the call. An SduLength of 0 can be used to indicate
                                        state changes in the retry parameter or to query the current
                                        amount of available data in the upper layer module. In this
                                        case, the SduDataPtr may be a NULL_PTR.
                               |retry | This parameter is used to acknowledge transmitted data or to
                                        retransmit data after transmission problems. If the retry
                                        parameter is a NULL_PTR, it indicates that the transmit
                                        data can be removed from the buffer immediately after it has
                                        been copied. Otherwise, the retry parameter must point to a
                                        valid RetryInfoType element.
                                        If TpDataState indicates TP_CONFPENDING, the previously
                                        copied data must remain in the TP buffer to be available for
                                        error recovery. TP_DATACONF indicates that all data that has
                                        been copied before this call is confirmed and can be removed
                                        from the TP buffer. Data copied by this API call is excluded
                                        and will be confirmed later. TP_DATARETRY indicates that this
                                        API call shall copy previously copied data in order to
                                        recover from an error. In this case TxTpDataCnt specifies the
                                        offset in bytes from the current data copy position.
        Parameters (inout)     | None
        Parameters (out)       | availableDataPtr | Indicates the remaining number of bytes that are
                                                    available in the upper layer module's Tx buffer.
                                                    availableDataPtr can be used by TP modules that
                                                    support dynamic payload lengths (e.g. FrIsoTp)
                                                    to determine the size of the following CFs.
        Return value           | BufReq_ReturnType| BUFREQ_OK: Data has been copied to the transmit
                                                    buffer completely as requested.
                                                    BUFREQ_E_BUSY: Request could not be fulfilled,
                                                    because the required amount of Tx data is not
                                                    available. The lower layer module may retry this
                                                    call later on. No data has been copied.
                                                    BUFREQ_E_NOT_OK: Data has not been copied. Request
                                                    failed.
        Description            | This function is called to acquire the transmit data of an I-PDU
                                 segment (N-PDU) Each call to this function provides the next part
                                 of the I-PDU data unless retry-&gt;TpDataState is TP_DATARETRY. In
                                 this case the function restarts to copy the data beginning at the
                                 offset from the current position indicated by retry-&gt;TxTpDataCnt.
                                 The size of the remaining data is written to the position indicated
                                 by availableDataPtr.
        Available via          | LdCom.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.LdCom.ReentrancyTpCallbacks</srcid><srcstatus/><internalId>129</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>LdCom_ComTest_01</srcid><srcstatus/><internalId>167</internalId></linkedfrom><linkedfrom><srcid>LdCom_ComTest_06_TpOnly</srcid><srcstatus/><internalId>169</internalId></linkedfrom><linkedfrom><srcid>LdCom_ComTest_08_TxOnly</srcid><srcstatus/><internalId>171</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_IMP_02002_SID</srcid><srcstatus/><internalId>237</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>49</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00028</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        Service Name             | LdCom_TpTxConfirmation
        Syntax                   | void LdCom_TpTxConfirmation (PduIdType id, Std_ReturnType result)
        Service ID [hex]         | 0x48
        Sync/Async               | Synchronous
        Reentrancy               | Reentrant
        Parameters (in)          | id     | Identification of the transmitted I-PDU.
                                   result | Result of the transmission of the I-PDU.
        Parameters (inout)       | None
        Parameters (out)         | None
        Return value             | None
        Description              | This function is called after the I-PDU has been transmitted on
                                   its network, the result indicates whether the transmission was
                                   successful or not.
        Available via            | LdCom.h
      </description>
      <comment>AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>LdCom_ComTest_01</srcid><srcstatus/><internalId>167</internalId></linkedfrom><linkedfrom><srcid>LdCom_ComTest_06_TpOnly</srcid><srcstatus/><internalId>169</internalId></linkedfrom><linkedfrom><srcid>LdCom_ComTest_08_TxOnly</srcid><srcstatus/><internalId>171</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_IMP_02002_SID</srcid><srcstatus/><internalId>237</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.LdCom.ReentrancyTpCallbacks</srcid><srcstatus/><internalId>129</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>50</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00029</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        Service Name          | LdCom_StartOfReception
        Syntax                | BufReq_ReturnType LdCom_StartOfReception (
                                PduIdType id, const PduInfoType* info, PduLengthType TpSduLength,
                                PduLengthType* bufferSizePtr)
        Service ID [hex]      | 0x46
        Sync/Async            | Synchronous
        Reentrancy            | Reentrant
        Parameters (in)       | id    | Identification of the I-PDU.
                                info  | Pointer to a PduInfoType structure containing the payload
                                        data (without protocol information) and payload length of the
                                        first frame or single frame of a transport protocol I-PDU
                                        reception, and the MetaData related to this PDU. If neither
                                        first/single frame data nor MetaData are available, this
                                        parameter is set to NULL_PTR.
                                TpSdu | Total length of the N-SDU to be received.
                                Length
        Parameters (inout)    | None
        Parameters (out)      | bufferSizePtr | Available receive buffer in the receiving module.
                                                This parameter will be used to compute the Block Size
                                                (BS) in the transport protocol module.
        Return value          | BufReq_ReturnType | BUFREQ_OK: Connection has been accepted.
                                                    bufferSizePtr indicates the available receive
                                                    buffer; reception is continued. If no buffer
                                                    of the requested size is available, a receive buffer
                                                    size of 0 shall be indicated by bufferSizePtr.
                                                    BUFREQ_E_NOT_OK: Connection has been rejected;
                                                    reception is aborted. bufferSizePtr remains unchanged.
                                                    BUFREQ_E_OVFL: No buffer of the required length can be
                                                    provided; reception is aborted. bufferSizePtr remains
                                                    unchanged.
        Description           | This function is called at the start of receiving an N-SDU. The N-SDU
                                might be fragmented into multiple N-PDUs (FF with one or more
                                following CFs) or might consist of a single N-PDU (SF). The service
                                shall provide the currently available maximum buffer size when
                                invoked with TpSduLength equal to 0.
        Available via         | LdCom.h
      </description>
      <comment>
        Parameter Info is not implemented in order to be consistent with AUTOSAR 4.0.3 modules.
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>LdCom_ComTest_01</srcid><srcstatus/><internalId>167</internalId></linkedfrom><linkedfrom><srcid>LdCom_ComTest_06_TpOnly</srcid><srcstatus/><internalId>169</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_01133_StartOfReception_PduInfoPtrNull</srcid><srcstatus/><internalId>207</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_IMP_02002_SID</srcid><srcstatus/><internalId>237</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.LdCom.ReentrancyTpCallbacks</srcid><srcstatus/><internalId>129</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>51</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00030</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        Service Name            | LdCom_CopyRxData
        Syntax                  | BufReq_ReturnType LdCom_CopyRxData (PduIdType id,
                                    const PduInfoType* info, PduLengthType* bufferSizePtr)
        Service ID [hex]        | 0x44
        Sync/Async              | Synchronous
        Reentrancy              | Reentrant
        Parameters (in)         | id   | Identification of the received I-PDU.
                                  info | Provides the source buffer (SduDataPtr) and the number of
                                         bytes to be copied (SduLength) An SduLength of 0 can be used
                                         to query the current amount of available buffer in the upper
                                         layer module. In this case, the SduDataPtr may be a NULL_PTR.
        Parameters (inout)      | None
        Parameters (out)        | bufferSizePtr | Available receive buffer after data has been copied.
        Return value            | BufReq_ReturnType | BUFREQ_OK: Data copied successfully
                                                      BUFREQ_E_NOT_OK: Data was not copied because
                                                      an error occurred.
        Description             | This function is called to provide the received data of an I-PDU
                                  segment (N-PDU) to the upper layer. Each call to this function
                                  provides the next part of the I-PDU data. The size of the remaining
                                  buffer is written to the position indicated by bufferSizePtr.
        Available via           | LdCom.h
      </description>
      <comment>AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>LdCom_ComTest_01</srcid><srcstatus/><internalId>167</internalId></linkedfrom><linkedfrom><srcid>LdCom_ComTest_06_TpOnly</srcid><srcstatus/><internalId>169</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_IMP_02002_SID</srcid><srcstatus/><internalId>237</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.LdCom.ReentrancyTpCallbacks</srcid><srcstatus/><internalId>129</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>52</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00031</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        Service Name         | LdCom_TpRxIndication
        Syntax               | void LdCom_TpRxIndication (PduIdType id, Std_ReturnType result)
        Service ID [hex]     | 0x45
        Sync/Async           | Synchronous
        Reentrancy           | Reentrant
        Parameters (in)      | id | Identification of the received I-PDU.
                               result | Result of the reception.
        Parameters (inout)   | None
        Parameters (out)     | None
        Return value         | None
        Description          | Called after an I-PDU has been received via the TP API, the result
                               indicates whether the transmission was successful or not.
        Available via        | LdCom.h
      </description>
      <comment>AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>LdCom_ComTest_01</srcid><srcstatus/><internalId>167</internalId></linkedfrom><linkedfrom><srcid>LdCom_ComTest_06_TpOnly</srcid><srcstatus/><internalId>169</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_IMP_02002_SID</srcid><srcstatus/><internalId>237</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.LdCom.ReentrancyTpCallbacks</srcid><srcstatus/><internalId>129</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>53</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00032</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        Service Name        | LdCom_RxIndication
        Syntax              | void LdCom_RxIndication (PduIdType RxPduId, const PduInfoType* PduInfoPtr)
        Service ID [hex]    | 0x42
        Sync/Async          | Synchronous
        Reentrancy          | Reentrant for different PduIds. Non reentrant for the same PduId.
        Parameters (in)     | RxPduId | ID of the received PDU.
                              PduInfoPtr | Contains the length (SduLength) of the received PDU, a
                              pointer to a buffer (SduDataPtr) containing the PDU, and the MetaData
                              related to this PDU.
        Parameters (inout)  | None
        Parameters (out)    | None
        Return value        | None
        Description         | Indication of a received PDU from a lower layer communication
                              interface module.
        Available via       | LdCom.h
      </description>
      <comment>
        Parameter PduInfoPtr is implemented without qualifier const to be consistent with AUTOSAR 4.0.3 modules.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>LdCom_ComTest_01</srcid><srcstatus/><internalId>167</internalId></linkedfrom><linkedfrom><srcid>LdCom_ComTest_09_IfRxOnly</srcid><srcstatus/><internalId>172</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_IMP_02002_SID</srcid><srcstatus/><internalId>237</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>54</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00056</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>2</version>
      <description>
        Service Name        | LdCom_TxConfirmation
        Syntax              | void LdCom_TxConfirmation (PduIdType TxPduId, Std_ReturnType result)
        Service ID [hex]    | 0x40
        Sync/Async          | Synchronous
        Reentrancy          | Reentrant for different PduIds. Non reentrant for the same PduId.
        Parameters (in)     | TxPduId | ID of the PDU that has been transmitted.
                              result | E_OK: The PDU was transmitted. E_NOT_OK: Transmission of the
                              PDU failed.
        Parameters (inout)  | None
        Parameters (out)    | None
        Return value        | None
        Description         | The lower layer communication interface module confirms the
                              transmission of a PDU, or the failure to transmit a PDU.
        Available via       | LdCom.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>LdCom_ComTest_01</srcid><srcstatus/><internalId>167</internalId></linkedfrom><linkedfrom><srcid>LdCom_ComTest_08_TxOnly</srcid><srcstatus/><internalId>171</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_IMP_02002_SID</srcid><srcstatus/><internalId>237</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>55</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00033</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        Service Name       | LdCom_TriggerTransmit
        Syntax             | Std_ReturnType LdCom_TriggerTransmit (PduIdType TxPduId,
                               PduInfoType* PduInfoPtr)
        Service ID [hex]   | 0x41
        Sync/Async         | Synchronous
        Reentrancy         | Reentrant for different PduIds. Non reentrant for the same PduId.
        Parameters (in)    | TxPduId | ID of the SDU that is requested to be transmitted.
        Parameters (inout) | PduInfoPtr | Contains a pointer to a buffer (SduDataPtr) to where the
                                          SDU data shall be copied, and the available buffer size in
                                          SduLengh. On return, the service will indicate the length
                                          of the copied SDU data in SduLength.
        Parameters (out)   | None
        Return value       | Std_ReturnType | E_OK: SDU has been copied and SduLength indicates the
                                              number of copied bytes.
                                              E_NOT_OK: No SDU data has been copied. PduInfoPtr must
                                              not be used since it may contain a NULL pointer or point
                                              to invalid data.
        Description        | Within this API, the upper layer module (called module) shall check
                             whether the available data fits into the buffer size reported by
                             PduInfoPtr-&gt;SduLength. If it fits, it shall copy its data into the
                             buffer provided by PduInfoPtr-&gt;SduDataPtr and update the length of
                             the actual copied data in PduInfoPtr-&gt;SduLength. If not, it returns
                             E_NOT_OK without changing PduInfoPtr.
        Available via      | LdCom.h
      </description>
      <comment>AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>LdCom_ComTest_01</srcid><srcstatus/><internalId>167</internalId></linkedfrom><linkedfrom><srcid>LdCom_ComTest_08_TxOnly</srcid><srcstatus/><internalId>171</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_IMP_02002_SID</srcid><srcstatus/><internalId>237</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>56</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00047</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        LdCom_TriggerTransmit shall only be available if at least one LdComIPdu has
        LdComTxTriggerTransmit configured.
      </description>
      <comment>
        What's meant by 'available' leaves room for interpretation.
        EB interprets it that way that all APIs are defined but functionality is only provided
        as specified.
        If no single LdComIPdu is configured for the considered pair of LdComIPduDirection and
        LdComApiType, no other functionality is executed than:
        - a negative return value delivered if possible by syntax and
        - the error code LDCOM_E_INVALID_PDU_SDU_ID reported for enabled Det.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_IMP_02003_PreCompileSwitches</srcid><srcstatus/><internalId>238</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_04002_LdCom_TriggerTransmit_NotAvailable</srcid><srcstatus/><internalId>248</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_04004_PreCompileSwitches</srcid><srcstatus/><internalId>250</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>57</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00035</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        API Function       | Header File  | Description
        Det_ReportError    | Det.h        | Service to report development errors.
        PduR_LdComTransmit | PduR_LdCom.h | Requests transmission of a PDU.
      </description>
      <comment>
        {code=[LdCom_Transmit]}
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>LdCom_ComTest_01</srcid><srcstatus/><internalId>167</internalId></linkedfrom><linkedfrom><srcid>LdCom_ComTest_06_TpOnly</srcid><srcstatus/><internalId>169</internalId></linkedfrom><linkedfrom><srcid>LdCom_ComTest_09_IfRxOnly</srcid><srcstatus/><internalId>172</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_IMP_02003_PreCompileSwitches</srcid><srcstatus/><internalId>238</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>58</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00036</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>2</version>
      <description>
        Service Name        | Rte_LdComCbkCopyTxData_&lt;sn&gt;
        Syntax              | BufReq_ReturnType Rte_LdComCbkCopyTxData_&lt;sn&gt; (
                                const PduInfoType* info, const RetryInfoType* retry,
                                PduLengthType* availableDataPtr)
        Sync/Async          | Synchronous
        Reentrancy          | Non Reentrant for same sn, otherwise Reentrant
        Parameters (in)     | info | Provides the destination buffer (SduDataPtr) and the number of
                                     bytes to be copied (SduLength). If not enough transmit data is
                                     available, no data is copied by the upper layer module and
                                     BUFREQ_E_BUSY is returned. The lower layer module may retry the
                                     call. An SduLength of 0 can be used to indicate state changes in
                                     the retry parameter or to query the current amount of available
                                     data in the upper layer module. In this case, the SduDataPtr
                                     may be a NULL_PTR.
                              retry | Will not be handled by LdCom and its upper layer.
        Parameters (inout)  | None
        Parameters (out)    | availableDataPtr | Indicates the remaining number of bytes that are
                                                 available in the upper layer module's Tx buffer.
                                                 availableDataPtr can be used by TP modules that
                                                 support dynamic payload lengths (e.g. FrIsoTp) to
                                                 determine the size of the following CFs.
        Return value        | BufReq_ReturnType | BUFREQ_OK: Data has been copied to the transmit
                                                  buffer completely as requested.
                                                  BUFREQ_E_BUSY: Request could not be fulfilled,
                                                  because the required amount of Tx data is not
                                                  available. The lower layer module may retry this
                                                  call later on. No data has been copied.
                                                  BUFREQ_E_NOT_OK: Data has not been copied. Request
                                                  failed.
        Description         | This function is called to acquire the transmit data of an I-PDU
                              segment (N-PDU) Each call to this function provides the next part of
                              the I-PDU data unless retry-&gt;TpDataState is TP_DATARETRY. In this
                              case the function restarts to copy the data beginning at the offset
                              from the current position indicated by retry-&gt;TxTpDataCnt. The size
                              of the remaining data is written to the position indicated by
                              availableDataPtr
        Available via       | Rte_Cbk.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/LdCom_Cbk.h_43</srcid><srcstatus/><internalId>138</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>59</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00037</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        Service Name          | Rte_LdComCbkTpTxConfirmation_&lt;sn&gt;
        Syntax                |void Rte_LdComCbkTpTxConfirmation_&lt;sn&gt; (Std_ReturnType result)
        Sync/Async            | Synchronous
        Reentrancy            | Non Reentrant for same sn, otherwise Reentrant
        Parameters (in)       | result | E_OK - transmission successful E_NOT_OK - transmission not
                                         successful
        Parameters (inout)    | None
        Parameters (out)      | None
        Return value          | None
        Description           | This function is called after a Signal has been transmitted via the TP-API on its
        network.
        Available via         | Rte_Cbk.h
      </description>
      <comment>
        Only the syntax of the Rte callback is of relevance.
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/LdCom_Cbk.h_51</srcid><srcstatus/><internalId>139</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>60</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00038</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>2</version>
      <description>
        Service Name          | Rte_LdComCbkStartOfReception_&lt;sn&gt;
        Syntax                | BufReq_ReturnType Rte_LdComCbkStartOfReception_&lt;sn&gt; (
                                  const PduInfoType* info, PduLengthType TpSduLength,
                                  PduLengthType* bufferSizePtr)
        Sync/Async            | Synchronous
        Reentrancy            | Non Reentrant for same sn, otherwise Reentrant
        Parameters (in)       | info | Pointer to a PduInfoType structure containing the payload
                                       data (without protocol information) and payload length of the
                                       first frame or single frame of a transport protocol I-PDU
                                       reception, and the MetaData related to this PDU. If neither
                                       first/single frame data nor MetaData are available, this
                                       parameter is set to NULL_PTR.
                                TpSduLength | Total length of the N-SDU to be received.
        Parameters (inout)    | None
        Parameters (out)      | bufferSizePtr | Available receive buffer in the receiving module.
                                                This parameter will be used to compute the Block Size
                                                (BS) in the transport protocol module.
        Return value          | BufReq_ReturnType | BUFREQ_OK: Connection has been accepted.
                                                    bufferSizePtr indicates the available receive
                                                    buffer; reception is continued. If no buffer
                                                    of the requested size is available, a receive
                                                    buffer size of 0 shall be indicated by bufferSizePtr.
                                                    BUFREQ_E_NOT_OK: Connection has been rejected;
                                                    reception is aborted. bufferSizePtr remains
                                                    unchanged.
                                                    BUFREQ_E_OVFL: No buffer of the required length
                                                    can be provided; reception is aborted.
                                                    bufferSizePtr remains unchanged.
        Description           | This function is called at the start of receiving an N-SDU. The N-SDU
                                might be fragmented into multiple N-PDUs (FF with one or more
                                following CFs) or might consist of a single N-PDU (SF). The service
                                shall provide the currently available maximum buffer size when
                                invoked with TpSduLength equal to 0.
        Available via         | Rte_Cbk.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/LdCom_Cbk.h_22</srcid><srcstatus/><internalId>135</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>61</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00039</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>2</version>
      <description>
        Service Name           | Rte_LdComCbkCopyRxData_&lt;sn&gt;
        Syntax                 | BufReq_ReturnType Rte_LdComCbkCopyRxData_&lt;sn&gt; (
                                   const PduInfoType* info, PduLengthType* bufferSizePtr)
        Sync/Async             | Synchronous
        Reentrancy             | Non Reentrant for same sn, otherwise Reentrant
        Parameters (in)        | info | Provides the source buffer (SduDataPtr) and the number of
                                        bytes to be copied (SduLength). An SduLength of 0 can be
                                        used to query the current amount of available buffer in the
                                        upper layer module. In this case, the SduDataPtr may be a NULL_PTR.
        Parameters (inout)     | None
        Parameters (out)       | bufferSizePtr | Available receive buffer after data has been copied.
        Return value           | BufReq_ReturnType | BUFREQ_OK: Data copied successfully
                                                     BUFREQ_E_NOT_OK: Data was not copied because an
                                                     error occurred.
        Description            | This function is called to provide the received data of an I-PDU
                                 segment (N-PDU) to the upper layer. Each call to this function
                                 provides the next part of the I-PDU data. The size of the remaining
                                 data is written to the position indicated by bufferSizePtr.
        Available via          | Rte_Cbk.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/LdCom_Cbk.h_30</srcid><srcstatus/><internalId>136</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>62</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00040</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>2</version>
      <description>
        Service Name           | Rte_LdComCbkTpRxIndication_&lt;sn&gt;
        Syntax                 | void Rte_LdComCbkTpRxIndication_&lt;sn&gt; (Std_ReturnType result)
        Sync/Async             | Synchronous
        Reentrancy             | Non Reentrant for same sn, otherwise Reentrant
        Parameters (in)        | result | Result of the reception.
        Parameters (inout)     | None
        Parameters (out)       | None
        Return value           | None
        Description            | Called after an I-PDU has been received via the TP API, the result
                                 indicates whether the transmission was successful or not.
        Available via          | Rte_Cbk.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/LdCom_Cbk.h_37</srcid><srcstatus/><internalId>137</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>63</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00041</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>2</version>
      <description>
        Service Name          | Rte_LdComCbkRxIndication_&lt;sn&gt;
        Syntax                | void Rte_LdComCbkRxIndication_&lt;sn&gt; (
                                  const PduInfoType* PduInfoPtr)
        Sync/Async            | Synchronous
        Reentrancy            | Non Reentrant for same sn, otherwise Reentrant
        Parameters (in)       | PduInfoPtr | Contains the length (SduLength) of the received PDU,
                                             a pointer to a buffer (SduDataPtr) containing the PDU,
                                             and the MetaData related to this PDU.
        Parameters (inout)    | None
        Parameters (out)      | None
        Return value          | None
        Description           | Indication of a received PDU from a lower layer communication
                                interface module.
        Available via         | Rte_Cbk.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/LdCom_Cbk.h_57</srcid><srcstatus/><internalId>140</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>64</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00042</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        Service Name         | Rte_LdComCbkTriggerTransmit_&lt;sn&gt;
        Syntax               | Std_ReturnType Rte_LdComCbkTriggerTransmit_&lt;sn&gt; (
                                 PduInfoType* PduInfoPtr)
        Sync/Async           | Synchronous
        Reentrancy           | Non Reentrant for same sn, otherwise Reentrant
        Parameters (in)      | None
        Parameters (inout)   | PduInfoPtr | Contains a pointer to a buffer (SduDataPtr) to where the
                                            SDU data shall be copied, and the available buffer size
                                            in SduLengh. On return, the service will indicate the
                                            length of the copied SDU data in SduLength.
        Parameters (out)     | None
        Return value         | Std_ReturnType | E_OK: SDU has been copied and SduLength indicates
                                               the number of copied bytes.
                                               E_NOT_OK: No SDU data has been copied. PduInfoPtr
                                               must not be used since it may contain a NULL pointer
                                               or point to invalid data.
        Description          | Within this API, the upper layer module (called module) shall check
                               whether the available data fits into the buffer size reported by
                               PduInfoPtr-&gt;SduLength. If it fits, it shall copy its data into the
                               buffer provided by PduInfoPtr-&gt;SduDataPtr and update the length of
                               the actual copied data in PduInfoPtr-&gt;SduLength. If not, it
                               returns E_NOT_OK without changing PduInfoPtr.
        Available via        | Rte_Cbk.h
      </description>
      <comment>
        Only the syntax of the Rte callback is of relevance.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/LdCom_Cbk.h_63</srcid><srcstatus/><internalId>141</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>65</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LDCOM_00043</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 4.2.2</source>
      <version>1</version>
      <description>
        LdCom shall support the configuration variants pre-compile, link-time and post-build.
        (SRS_BSW_00344, SRS_BSW_00405, SRS_BSW_00345)
      </description>
      <comment>
      </comment>
      <releases>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.LdCom.UnsupportedVariantPreCompile</srcid><srcstatus/><internalId>128</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>66</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LDCOM_00051</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 4.2.2</source>
      <version>1</version>
      <description>
        The LdCom implementation shall additionally provide
        LdCom_Lcfg.c and LdComPBcfg.c. (SRS_BSW_00344, SRS_BSW_00405,
        SRS_BSW_00345)
      </description>
      <comment>
        Renamed LdComPBcfg.c to LdCom_PBcfg.c.
      </comment>
      <releases>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_CON_03001_FileStructure</srcid><srcstatus/><internalId>230</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>67</internalId></specobject>

    <specobject>
      <id>LdCom.SWS_LdCom_00053</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>2</version>
      <description>
        Service Name            | Rte_LdComCbkTxConfirmation_&lt;sn&gt;
        Syntax                  | void Rte_LdComCbkTxConfirmation_&lt;sn&gt; (Std_ReturnType result)
        Sync/Async              | Synchronous
        Reentrancy              | Non Reentrant for same sn, otherwise Reentrant
        Parameters (in)         | result | E_OK: The PDU was transmitted. E_NOT_OK: Transmission of
                                           the PDU failed.
        Parameters (inout)      | None
        Parameters (out)        | None
        Return value            | None
        Description             | The lower layer communication interface module confirms the
                                  transmission of a PDU, or the failure to transmit a PDU.
        Available via           | Rte_Cbk.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/LdCom_Cbk.h_69</srcid><srcstatus/><internalId>142</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>68</internalId></specobject>

    <specobject>
      <id>LdCom.ECUC_LdCom_00001</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        See"LdCom_x_Module"
        Module Name                | LdComLdCom
        Module Description         | Configuration of the AUTOSAR LdCom module.
        Post-Build Variant Support | true
        Supported Config Variants  | VARIANT-LINK-TIME, VARIANT-POST-BUILD, VARIANT-PRE-COMPILE
        Included containers: "LdCom_x_Included_Containers"
        Included Containers
        Container Name             | Multiplicity | Scope / Dependency
        LdComConfig                | 1            | This container contains the configuration
                                                    parameters and sub containers of the AUTOSAR
                                                    LdCom module.
        LdComGeneral               | 1            | Contains the general configuration parameters of
                                                    the LdCom module.
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification (checked by VSMD checker).
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>69</internalId></specobject>

    <specobject>
      <id>LdCom.ECUC_LdCom_00003</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        Name: LdComConfig
        Container Type: Container
        Sub-Containers: LdComIPdu
        Description: This container contains the configuration parameters and sub containers of the
        AUTOSAR LdCom module.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification (checked by VSMD checker).
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>70</internalId></specobject>

    <specobject>
      <id>LdCom.ECUC_LdCom_00004</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        Name: LdComGeneral
        Container Type: Container
        Description: Contains the general configuration parameters of the LdCom module.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification (checked by VSMD checker).
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>71</internalId></specobject>

    <specobject>
      <id>LdCom.ECUC_LdCom_00020</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        Name: LdComDevErrorDetect
        Parameter Type: Boolean
        Parent Containers: LdComGeneral,
        Description: Switches the development error detection and notification on or off.
        Introduction: * true: detection and notification is enabled. * false: detection and
        notification is disabled.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <comment>
        This is a configuration parameter requirement with some functional specification
        (partly checked by VSMD checker).
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>LdCom_ComTest_01</srcid><srcstatus/><internalId>167</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_IMP_02003_PreCompileSwitches</srcid><srcstatus/><internalId>238</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>72</internalId></specobject>

    <specobject>
      <id>LdCom.ECUC_LdCom_00012</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        Name: LdComVersionInfoApi
        Parameter Type: Boolean
        Parent Containers: LdComGeneral,
        Description: Activate/Deactivate the version information API (LdCom_GetVersionInfo)
        Introduction: * True: version information API activated * False: version information API
        deactivated
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification (checked by VSMD checker).
        The requirements of '8.3.3 LdCom_GetVersionInfo' handle the issue completely.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>73</internalId></specobject>

    <specobject>
      <id>LdCom.ECUC_LdCom_00006</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        Name: LdComIPdu
        Container Type: Sub-Container
        Parent Containers: LdComConfig,
        Description: Contains the configuration parameters of the IPdu inside LdCom.
        Lower Multiplicity: 0
        infinite
        Post-Build-Variant-Multiplicity: true
        Multiplicity-Configuration Class: LINK, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification (checked by VSMD checker).
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.LdCom.UnsupportedPostBuildSelectable</srcid><srcstatus/><internalId>131</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>74</internalId></specobject>

    <specobject>
      <id>LdCom.ECUC_LdCom_00002</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        Name: LdComApiType
        Parameter Type: Enumeration
        Parent Containers: LdComIPdu,
        Description: Defines if this I-PDU is a normal I-PDU that shall be sent unfragmented or if this
        is a large I-PDU that shall be sent via the Transport Protocol of the underlying bus.
        Introduction: This setting is used by RTE to invoke the proper API.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: LINK, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Enumeration Literal: LDCOM_IF, AUTOSAR_ECUC
        Enumeration Literal: LDCOM_TP, AUTOSAR_ECUC
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification (checked by VSMD checker).
        The requirements of '8.4 Call-back functions and notifications' handle the issue completely.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>75</internalId></specobject>

    <specobject>
      <id>LdCom.ECUC_LdCom_00005</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        Name: LdComHandleId
        Parameter Type: Integer
        Parent Containers: LdComIPdu,
        Description: This is the ID used by RTE to invoke LdCom.
        Introduction: A corresponding shortName is created, which is used for the invocations of the
        RTE. The same ID is used for invocations by PduR.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: true
        Max-Value: 65535 (Type:
        Min-Value: 0 (Type:
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>LdCom_ComTest_07_HandleIdGenerator</srcid><srcstatus/><internalId>170</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>76</internalId></specobject>

    <specobject>
      <id>LdCom.ECUC_LdCom_00007</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        Name: LdComIPduDirection
        Parameter Type: Enumeration
        Parent Containers: LdComIPdu,
        Description: The direction defines if this IPdu, and therefore the contributing signal, shall
        be sent or received.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: LINK, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Enumeration Literal: LDCOM_RECEIVE, AUTOSAR_ECUC
        Enumeration Literal: LDCOM_SEND, AUTOSAR_ECUC
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification (checked by VSMD checker).
      Refers to the requirements of '8.4 Call-back functions and notifications'.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>77</internalId></specobject>

    <specobject>
      <id>LdCom.ECUC_LdCom_00013</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        Name: LdComRxCopyRxData
        Parameter Type: FunctionRef
        Parent Containers: LdComIPdu,
        Description: Only on receiver side: Name of Rte_LdComCbkCopyRxData callback function to be
        called.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: false
        Post-Build-Variant-Value: false
        Multiplicity-Configuration Class: LINK, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: LINK, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: LINK, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        FunctionName Def Condition:Max-Length: , Min-Length
      </description>
      <comment>
        This is a configuration parameter requirement with some functional specification
        (partly checked by VSMD checker).
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_CON_02011_CopyRxData_InvokeUp</srcid><srcstatus/><internalId>216</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>78</internalId></specobject>

    <specobject>
      <id>LdCom.ECUC_LdCom_00014</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        Name: LdComRxIndication
        Parameter Type: FunctionRef
        Parent Containers: LdComIPdu,
        Description: Only on receiver side: Name of Rte_LdComCbkRxIndication callback function to be
        called.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: false
        Post-Build-Variant-Value: false
        Multiplicity-Configuration Class: LINK, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: LINK, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: LINK, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        FunctionName Def Condition:Max-Length: , Min-Length
      </description>
      <comment>
        This is a configuration parameter requirement with some functional specification
        (partly checked by VSMD checker).
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_CON_02001_RxInd_InvokeUp</srcid><srcstatus/><internalId>208</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>79</internalId></specobject>

    <specobject>
      <id>LdCom.ECUC_LdCom_00015</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        Name: LdComRxStartOfReception
        Parameter Type: FunctionRef
        Parent Containers: LdComIPdu,
        Description: Only on receiver side: Name of Rte_LdComCbkStartOfReception callback function to
        be called.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: false
        Post-Build-Variant-Value: false
        Multiplicity-Configuration Class: LINK, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: LINK, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: LINK, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        FunctionName Def Condition:Max-Length: , Min-Length
      </description>
      <comment>
        This is a configuration parameter requirement with some functional specification
        (partly checked by VSMD checker).
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_CON_02010_StartOfReception_InvokeUp</srcid><srcstatus/><internalId>215</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>80</internalId></specobject>

    <specobject>
      <id>LdCom.ECUC_LdCom_00016</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        Name: LdComTpRxIndication
        Parameter Type: FunctionRef
        Parent Containers: LdComIPdu,
        Description: Only on receiver side: Name of Rte_LdComCbkTpRxIndication callback function to be
        called.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: false
        Post-Build-Variant-Value: false
        Multiplicity-Configuration Class: LINK, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: LINK, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: LINK, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        FunctionName Def Condition:Max-Length: , Min-Length
      </description>
      <comment>
        This is a configuration parameter requirement with some functional specification
        (partly checked by VSMD checker).
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_CON_02012_TpRxInd_InvokeUp</srcid><srcstatus/><internalId>217</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>81</internalId></specobject>

    <specobject>
      <id>LdCom.ECUC_LdCom_00017</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        Name: LdComTpTxConfirmation
        Parameter Type: FunctionRef
        Parent Containers: LdComIPdu,
        Description: Only on sender side: Name of Rte_LdComCbkTpTxConfirmation callback function to be
        called.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: false
        Post-Build-Variant-Value: false
        Multiplicity-Configuration Class: LINK, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: LINK, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: LINK, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        FunctionName Def Condition:Max-Length: , Min-Length
      </description>
      <comment>
        This is a configuration parameter requirement with some functional specification
        (partly checked by VSMD checker).
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_CON_02014_TpTxConf_InvokeUp</srcid><srcstatus/><internalId>219</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>82</internalId></specobject>

    <specobject>
      <id>LdCom.ECUC_LdCom_00021</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        Name: LdComTxConfirmation
        Parameter Type: FunctionRef
        Parent Containers: LdComIPdu,
        Description: Only on sender side: Name of Rte_LdComCbkTxConfirmation callback function to be
        called.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: false
        Post-Build-Variant-Value: false
        Multiplicity-Configuration Class: LINK, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: LINK, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: LINK, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        FunctionName Def Condition:Max-Length: , Min-Length
      </description>
      <comment>
        This is a configuration parameter requirement with some functional specification
        (partly checked by VSMD checker).
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_CON_02003_TxConf_InvokeUp</srcid><srcstatus/><internalId>211</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>83</internalId></specobject>

    <specobject>
      <id>LdCom.ECUC_LdCom_00018</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        Name: LdComTxCopyTxData
        Parameter Type: FunctionRef
        Parent Containers: LdComIPdu,
        Description: Only on sender side: Name of Rte_LdComCbkCopyTxData callback function to be called.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: false
        Post-Build-Variant-Value: false
        Multiplicity-Configuration Class: LINK, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: LINK, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: LINK, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        FunctionName Def Condition:Max-Length: , Min-Length
      </description>
      <comment>
        This is a configuration parameter requirement with some functional specification
        (partly checked by VSMD checker).
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_CON_02013_CopyTxData_InvokeUp</srcid><srcstatus/><internalId>218</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>84</internalId></specobject>

    <specobject>
      <id>LdCom.ECUC_LdCom_00019</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        Name: LdComTxTriggerTransmit
        Parameter Type: FunctionRef
        Parent Containers: LdComIPdu,
        Description: Only on sender side: Name of Rte_LdComCbkTriggerTransmit callback function to be
        called. If defined TriggerTransmit has to be supported for this signal.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: false
        Post-Build-Variant-Value: false
        Multiplicity-Configuration Class: LINK, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: LINK, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: LINK, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        FunctionName Def Condition:Max-Length: , Min-Length
      </description>
      <comment>
        This is a configuration parameter requirement with some functional specification
        (partly checked by VSMD checker).
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_CON_02002_TrigTx_InvokeUp</srcid><srcstatus/><internalId>209</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>85</internalId></specobject>

    <specobject>
      <id>LdCom.ECUC_LdCom_00010</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        Name: LdComPduRef
        Parameter Type: Reference
        Parent Containers: LdComIPdu,
        Description: Reference to the global Pdu.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: LINK, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Destination: /AUTOSAR/EcucDefs/EcuC/EcucConfigSet/EcucPduCollection/Pdu
        Destination type: ECUC-PARAM-CONF-CONTAINER-DEF
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification (checked by VSMD checker).
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>86</internalId></specobject>

    <specobject>
      <id>LdCom.ECUC_LdCom_00011</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_LargeDataCOM.pdf, Release 20-11</source>
      <version>1</version>
      <description>
        See"LdCom_x_Container_x_LdComIPdu_x_Parameter_x_LdComSystemTemplateSignalRef"
        Name | LdComSystemTemplateSignalRefLdComIPdu.LdComSystemTemplateSignalRef
        Parent Container | LdComIPdu
        Description | Reference to the ISignalToIPduMapping that contains a reference to the ISignal (
        System Template)
        Multiplicity | 0..1
        Type | Foreign reference to [ I-SIGNAL-TO-I-PDU-MAPPING
        Post-Build Variant Multiplicity | true
        Post-Build Variant Value | true
        Multiplicity Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE
        Link time | X | VARIANT-LINK-TIME
        Post-build time | X | VARIANT-POST-BUILD
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE
        Link time | X | VARIANT-LINK-TIME
        Post-build time | X | VARIANT-POST-BUILD
        Scope / Dependency | scope: ECU
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification (checked by VSMD checker).
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.LdCom.UnsupportedPostBuildSelectable</srcid><srcstatus/><internalId>131</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>87</internalId></specobject>

  </specobjects>
    <specobjects doctype="swurs">

<!--
  Requirements bekommen folgendes Namenschema: "<Moduleprefix>.EB.<RequirementID>".
-->

<!--  General requirements -->

  <specobject>
    <id>LdCom.EB.HandleIdGenerator</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      A generator shall automatically produce the handle IDs of configuration parameters
      LdComHandleId according to the 'Handle ID concept' given in 'Specification of ECU
      Configuration'.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>LdCom_ComTest_07_HandleIdGenerator</srcid><srcstatus/><internalId>170</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>88</internalId></specobject>

  <specobject>
    <id>LdCom.EB.PublishedInformation</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      The correct definition of the common published information shall be provided in the module
      header file, according to the General Basic Software Module Requirement [SWS_BSW_00059].

      The following published information element names shall be defined in the header file:

      LDCOM_VENDOR_ID
      LDCOM_MODULE_ID
      LDCOM_AR_RELEASE_MAJOR_VERSION
      LDCOM_AR_RELEASE_MINOR_VERSION
      LDCOM_AR_RELEASE_REVISION_VERSION
      LDCOM_SW_MAJOR_VERSION
      LDCOM_SW_MINOR_VERSION
      LDCOM_SW_PATCH_VERSION
      LDCOM_INSTANCE_ID

    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_CON_02031_PublishedInformation</srcid><srcstatus/><internalId>228</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>89</internalId></specobject>

  <specobject>
    <id>LdCom.EB.InitializationState_1</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      The LdCom shall maintain a boolean information (Initialization state)
      that is only set to TRUE, if the module has been successfully initialized via
      a call to LdCom_Init(). Otherwise, it is set to FALSE.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_01131_StateType</srcid><srcstatus/><internalId>205</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_IMP_01001_Init_State</srcid><srcstatus/><internalId>232</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>90</internalId></specobject>

  <specobject>
    <id>LdCom.EB.InitializationState_2</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      In case of deinitialization (invocation of LdCom_DeInit()), the module initialization
      state shall be set to FALSE.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_01131_StateType</srcid><srcstatus/><internalId>205</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_IMP_01002_DeInit_State</srcid><srcstatus/><internalId>233</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>91</internalId></specobject>

  <specobject>
    <id>LdCom.EB.SWS_LdCom_00019</id>
    <status>approved</status>
    <source>AUTOSAR_SWS_LargeDataCOM R20-11</source>
    <version>1</version>
    <description>
      When development error detection is enabled and the LdCom module
      has detected an error, it shall report the error to DET module, exit the
      concerned function and return an error if possible (e.g. by returning
      E_NOT_OK in case Std_ReturnType is used).
    </description>
    <furtherinfo>
      Justifying rule: WRN.swuts.needscoverage.count violation.
      As this is development type error which is checked by all public APIs, it cannot be refined
      for all public apis
    </furtherinfo>
    <comment>
      The original requirement LdCom.SWS_LdCom_00019 was removed from SWS since part of
      SWS BSW General. Here it is handled by EB specific LdCom.EB.SWS_LdCom_00019.
    </comment>
    <releases>
       <release>AUTOSAR R20-11</release>
     <release>AUTOSAR 4.2.2</release>
    </releases>
    <needscoverage>
      <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_01002_TrigTx_Uninit</srcid><srcstatus/><internalId>176</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_01010_StartOfReception_Uninit</srcid><srcstatus/><internalId>178</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_01011_CopyRxData_Uninit</srcid><srcstatus/><internalId>179</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_01020_CopyTxData_Uninit</srcid><srcstatus/><internalId>181</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_01030_Transmit_Uninit</srcid><srcstatus/><internalId>183</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_01040_InitNull_RepError</srcid><srcstatus/><internalId>185</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_01051_TriggerTx_ParamNull</srcid><srcstatus/><internalId>188</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_01060_StartOfReception_ParamNull</srcid><srcstatus/><internalId>189</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_01061_CopyRxData_ParamNull</srcid><srcstatus/><internalId>190</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_01062_CopyRxData_Param2Null</srcid><srcstatus/><internalId>191</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_01070_CopyTxData_ParamNull</srcid><srcstatus/><internalId>192</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_01071_CopyTxData_ParamNull2</srcid><srcstatus/><internalId>193</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_01080_Transmit_ParamNull</srcid><srcstatus/><internalId>194</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_01091_TrigTx_PduIdInvalid</srcid><srcstatus/><internalId>197</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_01100_StartOfReception_PduIdInvalid</srcid><srcstatus/><internalId>199</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_01101_CopyRxData_PduIdInvalid</srcid><srcstatus/><internalId>200</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_01110_CopyTxData_PduIdInvalid</srcid><srcstatus/><internalId>202</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_01120_Transmit_PduIdInvalid</srcid><srcstatus/><internalId>204</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_CON_02002_TrigTx_InvokeUp</srcid><srcstatus/><internalId>209</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_CON_02010_StartOfReception_InvokeUp</srcid><srcstatus/><internalId>215</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_CON_02011_CopyRxData_InvokeUp</srcid><srcstatus/><internalId>216</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_CON_02013_CopyTxData_InvokeUp</srcid><srcstatus/><internalId>218</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_CON_02020_Transmit_InvokeLoTp</srcid><srcstatus/><internalId>225</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_CON_02021_Transmit_InvokeLoIf</srcid><srcstatus/><internalId>226</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_03020_Transmit_NotAvailable</srcid><srcstatus/><internalId>244</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_03021_Transmit_NotAvailable</srcid><srcstatus/><internalId>245</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>92</internalId></specobject>

   <specobject>
    <id>LdCom.EB.SWS_LdCom_00038_DummyCbk</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        Service name: LdCom_DummyCbkStartOfReception
        Syntax: BufReq_ReturnType LdCom_DummyCbkStartOfReception(
                                                                 const PduInfoType* SduInfoPtr,
                                                                 PduLengthType SduLength,
                                                                 PduLengthType* RxBufferSizePtr
                                                                 )
        Parameters (in):    SduInfoPtr      ignored
                            SduLength       ignored
        Parameters (inout): None
        Parameters (out):   RxBufferSizePtr    does not change

        Return value: BufReq_ReturnType
                                         BUFREQ_E_NOT_OK: Default return value for dummy callback function.

        Description: Only returns BUFREQ_E_NOT_OK by default.
    </description>
    <comment>
      Parameter SduInfoPtr is not implemented in order to be consistent with AUTOSAR 4.0.3 modules.
    </comment>
    <needscoverage>
      <!-- tcs for return value check -->
      <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_CON_02015_StartOfReception_InvokeUp_Dummy</srcid><srcstatus/><internalId>220</internalId></linkedfrom></coveredby></needscov>
      <!-- src refers to syntax -->
      <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/LdCom_DummyCbk.h_30</srcid><srcstatus/><internalId>143</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00015.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>25</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>93</internalId></specobject>

  <specobject>
    <id>LdCom.EB.SWS_LdCom_00039_DummyCbk</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        Service name: LdCom_DummyCbkCopyRxData
        Syntax: BufReq_ReturnType LdCom_DummyCbkCopyRxData(
                                                           const PduInfoType* SduInfoPtr,
                                                           PduLengthType* RxBufferSizePtr
                                                           )

        Parameters (in):    SduInfoPtr       ignored
        Parameters (inout): None
        Parameters (out):   RxBufferSizePtr  does not change

        Return value: BufReq_ReturnType
                                         BUFREQ_E_NOT_OK: Default return value for dummy callback function.

        Description: Only returns BUFREQ_E_NOT_OK by default.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <!-- tcs for return value check -->
      <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_CON_02016_CopyRxData_InvokeUp_Dummy</srcid><srcstatus/><internalId>221</internalId></linkedfrom></coveredby></needscov>
      <!-- src refers to syntax -->
      <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/LdCom_DummyCbk.h_51</srcid><srcstatus/><internalId>144</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00016.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>28</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>94</internalId></specobject>

  <specobject>
    <id>LdCom.EB.SWS_LdCom_00040_DummyCbk</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        Service name: LdCom_DummyCbkTpRxIndication
        Syntax: void LdCom_DummyCbkTpRxIndication(
                                                  Std_ReturnType Result
                                                  )
        Parameters (in):    Result    ignored
        Parameters (inout): None
        Parameters (out):   None
        Return value:       None
        Description: Dummy function does nothing.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <!-- src refers to syntax -->
      <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/LdCom_DummyCbk.h_70</srcid><srcstatus/><internalId>145</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00017.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>31</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>95</internalId></specobject>

  <specobject>
    <id>LdCom.EB.SWS_LdCom_00036_DummyCbk</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        Service name: LdCom_DummyCbkCopyTxData
        Syntax: BufReq_ReturnType LdCom_DummyCbkCopyTxData(
                                                           const PduInfoType* SduInfoPtr,
                                                           RetryInfoType* RetryInfoPtr,
                                                           PduLengthType* TxDataCntPtr
                                                           )
        Parameters (in):    SduInfoPtr     ignored
                            RetryInfoPtr   ignored
        Parameters (inout): None
        Parameters (out):   TxDataCntPtr    does not change
        Return value: Std_ReturnType
                                         BUFREQ_E_NOT_OK: Default return value for dummy callback function.

        Description: Only returns BUFREQ_E_NOT_OK by default.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <!-- tcs for return value check -->
      <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_CON_02018_CopyTxData_InvokeUp_Dummy</srcid><srcstatus/><internalId>223</internalId></linkedfrom></coveredby></needscov>
      <!-- src refers to syntax -->
      <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/LdCom_DummyCbk.h_85</srcid><srcstatus/><internalId>146</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00013.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>17</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>96</internalId></specobject>

  <specobject>
    <id>LdCom.EB.SWS_LdCom_00037_DummyCbk</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        Service name: LdCom_DummyCbkTpTxConfirmation
        Syntax: void LdCom_DummyCbkTpTxConfirmation (
                                                    Std_ReturnType Result
                                                    )
        Parameters (in):    Result  ignored
        Parameters (inout): None
        Parameters (out):   None
        Return value:       None
        Description: Dummy function does nothing.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <!-- src refers to syntax -->
      <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/LdCom_DummyCbk.h_106</srcid><srcstatus/><internalId>147</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00013.4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>19</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>97</internalId></specobject>

   <specobject>
    <id>LdCom.EB.SWS_LdCom_00041_DummyCbk</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        Service name: LdCom_DummyCbkRxIndication
        Syntax: void LdCom_DummyCbkRxIndication(
                                                const PduInfoType* PduInfoPtr
                                                )
        Parameters (in):    Result  ignored
        Parameters (inout): None
        Parameters (out):   None
        Return value:       None
        Description: Dummy function does nothing.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <!-- src refers to syntax -->
      <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/LdCom_DummyCbk.h_120</srcid><srcstatus/><internalId>148</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00014.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>22</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>98</internalId></specobject>

  <specobject>
    <id>LdCom.EB.SWS_LdCom_00042_DummyCbk</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        Service name: LdCom_DummyCbkTriggerTransmit
        Syntax: Std_ReturnType LdCom_DummyCbkTriggerTransmit(
                                                             PduInfoType* PduInfoPtr
                                                             )
        Parameters (in):    PduInfoPtr    ignored
        Parameters (inout): None
        Parameters (out):   None
        Return value: Std_ReturnType
                                         E_NOT_OK: Default return value for dummy callback function.
        Description: Only returns E_NOT_OK by default.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <!-- tcs for return value check -->
      <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_CON_02005_TrigTx_InvokeUp_Dummy</srcid><srcstatus/><internalId>213</internalId></linkedfrom></coveredby></needscov>
      <!-- src refers to syntax -->
      <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/LdCom_DummyCbk.h_135</srcid><srcstatus/><internalId>149</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00011.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>10</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>99</internalId></specobject>

  <specobject>
    <id>LdCom.EB.SWS_LdCom_00053_DummyCbk</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
        Service name: LdCom_DummyCbkTxConfirmation
        Syntax: void LdCom_DummyCbkTxConfirmation(
                                                  void
                                                  )
        Parameters (in):    void
        Parameters (inout): None
        Parameters (out):   None
        Return value:       None
        Description: Dummy function does nothing.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <!-- src refers to syntax -->
      <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/LdCom_DummyCbk.h_149</srcid><srcstatus/><internalId>150</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00046.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>13</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>100</internalId></specobject>

  <specobject>
    <id>LdCom.EB.MultipleConfiguationContainer</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      The configuration container LdComConfig shall be flagged as MULTIPLE-CONFIGURATION-CONTAINER.
    </description>
    <rationale>
      This allows proper initialization of the LdCom module (without multiple configuration
      container) via Base_Modules.h.
    </rationale>
    <needscoverage>
      <!-- src refers to schema file -->
      <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/LdCom.xdm.m4_61</srcid><srcstatus/><internalId>155</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/config/LdCom_Extension.xdm.m4_52</srcid><srcstatus/><internalId>158</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>101</internalId></specobject>

  <specobject>
    <id>LdCom.EB.ShortNameOfLdComConfigContainer</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      The shortName of configuration container LdComConfig shall be used as C identifier name for
      the generated instance of LdCom_ConfigLayoutType.
    </description>
    <rationale>
      This allows proper initialization of the LdCom module (without multiple configuration
      container) via Base_Modules.h.
    </rationale>
    <needscoverage>
      <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>LdCom_ComTest_08_TxOnly</srcid><srcstatus/><internalId>171</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>102</internalId></specobject>

  <specobject>
    <id>LdCom.EB.ReferencedPdu</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      The generator shall issue a error if the PduR module does not reference
      a configured Pdu within the LdCom module.
    </description>
    <needscoverage>
      <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_GEN_01</srcid><srcstatus/><internalId>174</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>103</internalId></specobject>
  <!-- Support for custom header file for LdCom callbacks -->
  <specobject>
    <id>LdCom.EB.CustomHeaderFiles_Conf</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      Name: LdComUpperLayerHeaderFile
      Description: Header file of upper layer which declares the callback functions of LdCom.
      Multiplicity: 0..*
      Type: EcucStringParamDef
      Default value: –
      Post-Build Variant Value: false
      Value Configuration Class:
        Pre-compile time: All Variants
        Link time: --
        Post-build time: --
      Scope / Dependency: scope ECU
    </description>
    <comment>
      This is a configuration parameter requirement without additional functional specification.
      The functional description herein is fully covered by the requirement LdCom.EB.CustomHeaderFiles.Includes.
    </comment>
    <needscoverage>
      <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/LdCom_EBParameters.xdm.m4_72</srcid><srcstatus/><internalId>157</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>104</internalId></specobject>

  <specobject>
    <id>LdCom.EB.CustomHeaderFiles.Includes</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      The list of header files which are defined in LdComUpperLayerHeaderFile shall be included in LdCom_Lcfg.c.
      If the list is empty Rte_Cbk.h shall be included.
    </description>
    <needscoverage>
      <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_01132_NoCustomHeaderFile</srcid><srcstatus/><internalId>206</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_CON_03002_CustomHeaderFiles</srcid><srcstatus/><internalId>231</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>105</internalId></specobject>
  <!-- End of support for custom header file for LdCom callbacks -->
</specobjects>
    <specobjects doctype="swurs">

    <specobject>
      <id>LdCom.EB.Local.PBCFGM107</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The PbcfgM support shall be enabled or disabled via the macro
        LDCOM_PBCFGM_SUPPORT_ENABLED defined in the file LdCom_Cfg.h. If the
        PbcfgM configuration references the LdCom module the macro is set to STD_ON otherwise
        set to STD_OFF.
      </description>
      <!--
        Test cases overview:
        p0: PbcfgMBswModuleRef: contains a reference to LdCom.
            LDCOM_PBCFGM_SUPPORT_ENABLED shall be STD_ON
            Test: LdCom_Test_IsValidConfig with identical centralized req. LdCom.EB.PBCFGM107
        p1: PbcfgMBswModuleRef: no reference to LdCom.
            LDCOM_PBCFGM_SUPPORT_ENABLED shall be STD_OFF
            Test: TS_LDCOM_IMP_01051_MacroCheck_PbcfgMSupport_p1
        p2: PbcfgM is not part of this configuration.
            LDCOM_PBCFGM_SUPPORT_ENABLED shall be STD_OFF
            Test: LdCom_Test_PBcfgM_Off with identical centralized req. LdCom.EB.PBCFGM107
      -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_IMP_01051_MacroCheck_PbcfgMSupport_p1</srcid><srcstatus/><internalId>235</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>106</internalId></specobject>

    <specobject>
      <id>LdCom.EB.Local.PBCFGM108</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If the LdCom module is referenced by the PbcfgM, the parameter regarding the
        relocatable feature, shall not be editable and the MCG shall use the configuration of
        the PbcfgM.
      </description>
      <!--
        Some of the possible permutations are handled by centralized and identical requirement
        LdCom.EB.PBCFGM108. Macro LDCOM_RELOCATABLE_CFG_ENABLE is considered there especially with
        centralized requirement LdCom.EB.PbcfgM_General_3.

        The MCG check is covered by identical centralized requirement LdCom.EB.PBCFGM108.

        Test cases overview:
        p0: PbcfgMBswModuleRef: no reference to LdCom.
            PbcfgMRelocatableCfgEnable: true
            LdComRelocatablePbcfgEnable: true
            LDCOM_RELOCATABLE_CFG_ENABLE shall follow LdComRelocatablePbcfgEnable (STD_ON).
            Test: TS_LDCOM_IMP_01050_PbcfgM_MacroCheck_Reloc_p0
        p1: PbcfgMBswModuleRef: no reference to LdCom.
            PbcfgMRelocatableCfgEnable: true
            LdComRelocatablePbcfgEnable: false
            LDCOM_RELOCATABLE_CFG_ENABLE shall follow LdComRelocatablePbcfgEnable (STD_OFF).
            Test: TS_LDCOM_IMP_04050_PbcfgM_MacroCheck_Reloc_p1
        p2: PbcfgMBswModuleRef: contains reference to LdCom.
            PbcfgMRelocatableCfgEnable: true
            LdComRelocatablePbcfgEnable: true
            LDCOM_RELOCATABLE_CFG_ENABLE shall follow PbcfgMRelocatableCfgEnable (STD_ON).
            Test: TS_LDCOM_IMP_09050_PbcfgM_MacroCheck_Reloc_p2
        p3: PbcfgMBswModuleRef: contains reference to LdCom.
            PbcfgMRelocatableCfgEnable: false
            LdComRelocatablePbcfgEnable: true
            LDCOM_RELOCATABLE_CFG_ENABLE shall follow PbcfgMRelocatableCfgEnable (STD_OFF).
            Test: TS_LDCOM_IMP_10050_Pbcfg_MacroCheck_Reloc_p3
        p4: PbcfgM is not part of this configuration.
            LdComRelocatablePbcfgEnable: true
            LDCOM_RELOCATABLE_CFG_ENABLE shall follow LdComRelocatablePbcfgEnable (STD_ON).
            Test: TS_LDCOM_IMP_06050_PbcfgM_MacroCheck_Reloc_p4
        centralized: PbcfgM is not part of this configuration.
            LdComRelocatablePbcfgEnable: false
            LDCOM_RELOCATABLE_CFG_ENABLE shall follow LdComRelocatablePbcfgEnable (STD_OFF).
            Test: Handled by centralized test case LdCom_ComTest_27_PbcfgMOff via identical
              centralized requirement LdCom.EB.PBCFGM108.
        centralized: PbcfgMBswModuleRef: contains reference to LdCom.
            PbcfgMRelocatableCfgEnable: true
            LdComRelocatablePbcfgEnable: false
            LDCOM_RELOCATABLE_CFG_ENABLE shall follow PbcfgMRelocatableCfgEnable (STD_ON).
            Test: Handled by centralized test case LdCom_ComTest_26_PbcfgMOn via identical
              centralized requirement LdCom.EB.PBCFGM108.
      -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_IMP_01050_PbcfgM_MacroCheck_Reloc_p0</srcid><srcstatus/><internalId>234</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>107</internalId></specobject>
    
    <specobject>
      <id>LdCom.EB.RelocatablePBCfg</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        In order to support post-build-time configuration data handled by relative offsets to the
        configuration start address,the container LdCom must be extended by the configuration 
        parameter LdComRelocatablePbcfgEnable.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>LdCom_Test_PBcfgM_Off</srcid><srcstatus/><internalId>163</internalId></linkedfrom><linkedfrom><srcid>LdCom_Test_PBcfgM_On</srcid><srcstatus/><internalId>164</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_IMP_01050_PbcfgM_MacroCheck_Reloc_p0</srcid><srcstatus/><internalId>234</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>108</internalId></specobject>
    
  </specobjects>
    <specobjects doctype="swurs">

    <specobject>
      <id>LdCom.EB.DBGINST001</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Every public API of the module shall have debug instrumentation.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LdCom_DBGINST_001</srcid><srcstatus/><internalId>160</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>109</internalId></specobject>

    <specobject>
      <id>LdCom.EB.DBGINST002</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The parameter of a API shall be available in the entry instrumentation.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LdCom_DBGINST_001</srcid><srcstatus/><internalId>160</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>110</internalId></specobject>

    <specobject>
      <id>LdCom.EB.DBGINST003</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The parameter of a API shall be available in the exit instrumentation.
        If the API has a return value, the very first parameter of the macro shall contain the expected return value.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LdCom_DBGINST_001</srcid><srcstatus/><internalId>160</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>111</internalId></specobject>

    <specobject>
      <id>LdCom.EB.DBGINST004</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The default implementation of the debug instrumentation shall be an empty macro.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LdCom_DBGINST_001</srcid><srcstatus/><internalId>160</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>112</internalId></specobject>

    <specobject>
      <id>LdCom.EB.DBGINST005</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The module shall include the header files Base_Dbg.h in order to allow changing the default implementation of the debug instrumentation.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LdCom_DBGINST_001</srcid><srcstatus/><internalId>160</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>113</internalId></specobject>

  </specobjects>
    <specobjects doctype="swurs">

    <specobject>
      <id>LdCom.EB.PBCFGM101</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Service name: LdCom_IsValidConfig
        Syntax: Std_ReturnType LdCom_IsValidConfig( void* ConfigPtr )
        Sync/Async: Synchronous
        Reentrancy: Reentrant
        Parameters (in): ConfigPtr, post build configuration manager
        configuration.
        Parameters (inout): None
        Parameters (out): None
        Return value: Returns E_OK if the LdCom configuration is valid otherwise E_NOT_OK. A
        null pointer is interpreted as invalid configuration.
        Description: This function determines if the LdCom configuration is valid. This
        function can be called also before the LdCom is initialized. No error reporting
        is necessary within this function.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>LdCom_Test_IsValidConfig</srcid><srcstatus/><internalId>161</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>114</internalId></specobject>

    <specobject>
      <id>LdCom.EB.PBCFGM102</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        A configuration is valid
        - if the platform signature in the post build configuration equals the value
          determined by the macro TS_PlatformSigIsValid.
        - if the link time signature in the post build configuration equals the link time
          signature in the link time configuration file.
        - if the compile time signature in the post build configuration equals the value of
          the macro LDCOM_CFG_SIGNATURE.
        - if the compile time signature of Published information in the post build configuration
          equals the value of the macro LDCOM_PUBLIC_INFO_SIGNATURE.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>LdCom_Test_IsValidConfig</srcid><srcstatus/><internalId>161</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>115</internalId></specobject>

    <specobject>
      <id>LdCom.EB.PBCFGM104</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For generalized consistency of the post build configuration versus the compile time
        configuration:
        - the post build configuration structure shall contain the uint32 value
          CfgSignature.
        - the LdCom_Cfg.h file shall contain the macro
          LDCOM_CFG_SIGNATURE.
        - the MCG shall generate this signature value of compile time parameters. The x-path
          function asc:getConfigSignature(nodeset) shall be used to determine the signature out
          of a list of parameters. The list of compile time parameters shall determined with the
          function asc:getConfigClassNodeList(cassString).
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>LdCom_Test_IsValidConfig</srcid><srcstatus/><internalId>161</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>116</internalId></specobject>

    <specobject>
      <id>LdCom.EB.PBCFGM104_1</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For generalized consistency of the post build configuration versus the compile time
        configuration:
        - the post build configuration structure shall contain the uint32 value
          PublicInfoSignature.
        - the LdCom_Cfg.h file shall contain the macro
          LDCOM_PUBLIC_INFO_SIGNATURE.
        - The MCG shall generate this signature value from the list of parameters of
          configuration class 'PublishedInformation' except 'Release'. The XPath function
          asc:getConfigSignature(nodeset) shall be used to determine the signature out of the
          list of parameters. The list of parameters shall be determined with the function
          asc:getConfigClassNodeList(cassString).
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>LdCom_Test_IsValidConfig</srcid><srcstatus/><internalId>161</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>117</internalId></specobject>

    <specobject>
      <id>LdCom.EB.PBCFGM105</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For generalized consistency of the post build configuration versus the link time
        configuration:
        - the post build configuration structure shall contain the uint32 value
          LcfgSignature.
        - the link time configuration shall contain the uint32 value
          LdCom_LcfgSignature.
        - the MCG shall generate this signature value of link time parameters. The x-path
          function asc:getConfigSignature(nodeset) shall be used to determine the signature out
          of a list of parameters. The list of link time parameters shall determined with the
          function asc:getConfigClassNodeList(cassString).
      </description>
      <comment>
        See also:
        https://infohub.automotive.elektrobit.com/display/PRJEBTRESOS/PostBuild#PostBuild-Consistencypostbuildconfig
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>LdCom_Test_IsValidConfig</srcid><srcstatus/><internalId>161</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>118</internalId></specobject>

    <specobject>
      <id>LdCom.EB.PBCFGM106</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For Platform verification:
        - the LdCom post build configuration structure shall contain the value
          uint32 PlatformSignature. This uint32 must be the first value of the post build
          configuration structure to guarantee the correct access not disturbed by any padding
          bytes.
        - the MCG shall generate this signature for the selected target. The generator shall
          use the x-path function asc:getPlatformSignature() to determine this value.
      </description>
      <comment>
        See also:
        https://infohub.automotive.elektrobit.com/display/PRJEBTRESOS/PostBuild#PostBuild-Consistencypostbuildconfig
        https://issue.ebgroup.elektrobit.com/browse/ASCBASE-1485
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>LdCom_Test_IsValidConfig</srcid><srcstatus/><internalId>161</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>119</internalId></specobject>

    <specobject>
      <id>LdCom.EB.PBCFGM107</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The PbcfgM support shall be enabled or disabled via the macro
        LDCOM_PBCFGM_SUPPORT_ENABLED defined in the file
        LdCom_Cfg.h.
        If the PbcfgM configuration references the LdCom configuration
        the macro is set to STD_ON otherwise, or if no PbcfgM configuration is
        available it is set to STD_OFF.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>LdCom_Test_IsValidConfig</srcid><srcstatus/><internalId>161</internalId></linkedfrom><linkedfrom><srcid>LdCom_Test_PBcfgM_Off</srcid><srcstatus/><internalId>163</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>120</internalId></specobject>

    <specobject>
      <id>LdCom.EB.PBCFGM108</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If the LdCom is referenced by the PbcfgM, the parameter regarding the
        relocatable feature, shall not be editable and the MCG shall use the configuration of
        the PbcfgM.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>LdCom_Test_PBcfgM_Off</srcid><srcstatus/><internalId>163</internalId></linkedfrom><linkedfrom><srcid>LdCom_Test_PBcfgM_On</srcid><srcstatus/><internalId>164</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/LdCom_EBParameters.xdm.m4_67</srcid><srcstatus/><internalId>156</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>121</internalId></specobject>

    <specobject>
      <id>LdCom.EB.PBCFGM110</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The LdCom_Init() function must be extended to enable the PbcgfM
        features.
        The initialization function shall obtain the LdCom configuration
        from the PbcfgM if the PbcfgM support is enabled within this LdCom
        and the initialization function is called with a null pointer.
        The validity of the configuration shall be checked by the function
        LdCom_IsValidConfig(). The validity shall be check regardless the PbcfgM
        support is enabled or not.
        If no valid configuration can be obtained the initialization function shall
        return, leaving the LdCom uninitialized.
        In the case error reporting is enabled and no valid configuration can be obtained
        an erroneous parameter shall be indicated.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>LdCom_Test_VerifyInitWithPcfgM</srcid><srcstatus/><internalId>162</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>122</internalId></specobject>

    <specobject>
      <id>LdCom.EB.PostBuild_1</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The LdCom module shall compile and build an executable even in the absence
        of a post build configuration, i.e. without any post build generated .c and .h files
        available.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_Gen_PBcfgM_00000_OnlyPbCfg</srcid><srcstatus/><internalId>165</internalId></linkedfrom><linkedfrom><srcid>LdCom_ComTest_10_NoPbCfg</srcid><srcstatus/><internalId>173</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>123</internalId></specobject>

    <specobject>
      <id>LdCom.EB.PbcfgM_General_3</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The LdCom shall provide the following macros in the header file
        LdCom_Cfg.h:
        - LDCOM_RELOCATABLE_CFG_ENABLE which is set to STD_ON
          if relocatable config shall be enabled, otherwise it's set to STD_OFF.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>LdCom_Test_PBcfgM_On</srcid><srcstatus/><internalId>164</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>124</internalId></specobject>

    <specobject>
      <id>LdCom.EB.PbcfgM_General_6</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If PbcfgM support is enabled LdCom shall define the following macros in
        LdCom_PBCfg.c:
        - TS_PB_CFG_LAYOUT_TYPE: Shall expand to the type definition of the Postbuild
          configuration layout type (e.g. LdCom_ConstConfigLayoutType)
        - TS_PB_CFG_NAME: Shall expand to the name of the structure defining the Postbuild
          configuration layout (e.g. LdCom_ConfigLayout)
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>LdCom_Test_PBcfgM_Off</srcid><srcstatus/><internalId>163</internalId></linkedfrom><linkedfrom><srcid>LdCom_Test_PBcfgM_On</srcid><srcstatus/><internalId>164</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>125</internalId></specobject>

  </specobjects>
    <specobjects doctype="swurs">

    <specobject>
      <id>LdCom.EB.PDULENGTHTYPE001</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The LdCom module shall support the following values of PduLengthType:
        [UINT32, UINT16]
      </description>
      <verifycrit>
        Use case 1 - Modules not capable of handling more than 64 kbytes of data:
          - use PduLengthType value 'UINT32' with conformance test
          - verify successful test run, verify absence of metric violations
            (MISRA-C:2012, static code analysis, compiler warnings)
        Use case 2 - Modules capable of handling more than 64 kbytes of data:
          - use conformance test which handles more than 64 kbytes of data
          - apply "boundary" tests using data length of:
            [&lt;&lt;65535,65535, 65536, &gt;131072][bytes]
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LDCOM_CON_02001_RxInd_InvokeUp</srcid><srcstatus/><internalId>208</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_CON_02002_TrigTx_InvokeUp</srcid><srcstatus/><internalId>209</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_CON_02007_TrigTx_InvokeUp_Data</srcid><srcstatus/><internalId>210</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_CON_02004_RxInd_InvokeUp_Dummy</srcid><srcstatus/><internalId>212</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_CON_02005_TrigTx_InvokeUp_Dummy</srcid><srcstatus/><internalId>213</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_CON_02011_CopyRxData_InvokeUp</srcid><srcstatus/><internalId>216</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_CON_02013_CopyTxData_InvokeUp</srcid><srcstatus/><internalId>218</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_CON_02016_CopyRxData_InvokeUp_Dummy</srcid><srcstatus/><internalId>221</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_CON_02018_CopyTxData_InvokeUp_Dummy</srcid><srcstatus/><internalId>223</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_CON_02020_Transmit_InvokeLoTp</srcid><srcstatus/><internalId>225</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_CON_02021_Transmit_InvokeLoIf</srcid><srcstatus/><internalId>226</internalId></linkedfrom><linkedfrom><srcid>TS_LDCOM_CON_02040_PduLengthType</srcid><srcstatus/><internalId>229</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations><ruleid>WRN.swuts.needscoverage.count</ruleid></oreqmViolations><covstatus>covered</covstatus><internalId>126</internalId></specobject>

  </specobjects>
    <specobjects doctype="swurs">

    <specobject>
      <id>LdCom.EB.Interface.Consistency</id>
       <status>approved</status>
       <source>EB</source>
       <version>1</version>
       <description>
        The module shall provide a mechanism to guarantee consistency of interfaces and
        types between its implementation and its code stub.
       </description>
       <comment>
        The code stub of a module shall provide the same external view than the module itself.
        This is mandatory because unit test of modules test against the code stubs of
        adjacent modules. Inconsistent stubs may result in the situation that incompatible
        interfaces are not detected as unit test stage.
       </comment>
       <verifycrit>
        Create a compile test with two permutations that call all interfaces of a module
        (in both permutations).
        p0: Behave like a regular compile test; call the module generator and compile against
        the implementation of the module.
        p1: Do not generate module code and do not compile the implementation of the module.
        Instead the module shall be replaced with its own code stub.
       </verifycrit>
       <needscoverage>
          <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_LdCom_VerifyCodeStub</srcid><srcstatus/><internalId>166</internalId></linkedfrom></coveredby></needscov>
       <containerCovstatus>covered</containerCovstatus></needscoverage>
       
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>127</internalId></specobject>

  </specobjects>
    <specobjects doctype="dev">
    <specobject>
      <id>dev.LdCom.UnsupportedVariantPreCompile</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>175</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LDCOM_00043</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>66</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>128</internalId></specobject>
    <specobject>
      <id>dev.LdCom.ReentrancyTpCallbacks</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>207</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00027</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>49</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00028</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>50</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00029</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>51</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00030</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>52</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00031</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>53</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>129</internalId></specobject>
    <specobject>
      <id>dev.LdCom.UnsupportedSignalId</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>225</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00010</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>7</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>130</internalId></specobject>
    <specobject>
      <id>dev.LdCom.UnsupportedPostBuildSelectable</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>251</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>LdCom.ECUC_LdCom_00011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>87</internalId></provcov>
        <provcov>
          <linksto>LdCom.ECUC_LdCom_00006</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>131</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/include/LdCom.h_9</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/src/Autosar/include/LdCom.h</sourcefile>
      <sourceline>9</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LDCOM_00002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>132</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/LdCom.h_13</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/src/Autosar/include/LdCom.h</sourcefile>
      <sourceline>13</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LDCOM_00002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>133</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/LdCom.h_15</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/src/Autosar/include/LdCom.h</sourcefile>
      <sourceline>15</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LDCOM_00002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>134</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/include/LdCom_Cbk.h_22</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/src/Autosar/include/LdCom_Cbk.h</sourcefile>
      <sourceline>22</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00038</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>61</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>135</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/LdCom_Cbk.h_30</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/src/Autosar/include/LdCom_Cbk.h</sourcefile>
      <sourceline>30</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00039</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>62</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>136</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/LdCom_Cbk.h_37</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/src/Autosar/include/LdCom_Cbk.h</sourcefile>
      <sourceline>37</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00040</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>63</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>137</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/LdCom_Cbk.h_43</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/src/Autosar/include/LdCom_Cbk.h</sourcefile>
      <sourceline>43</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00036</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>138</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/LdCom_Cbk.h_51</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/src/Autosar/include/LdCom_Cbk.h</sourcefile>
      <sourceline>51</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00037</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>60</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>139</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/LdCom_Cbk.h_57</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/src/Autosar/include/LdCom_Cbk.h</sourcefile>
      <sourceline>57</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00041</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>64</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>140</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/LdCom_Cbk.h_63</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/src/Autosar/include/LdCom_Cbk.h</sourcefile>
      <sourceline>63</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00042</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>65</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>141</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/LdCom_Cbk.h_69</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/src/Autosar/include/LdCom_Cbk.h</sourcefile>
      <sourceline>69</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00053</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>68</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>142</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/include/LdCom_DummyCbk.h_30</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/src/Autosar/include/LdCom_DummyCbk.h</sourcefile>
      <sourceline>30</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>LdCom.EB.SWS_LdCom_00038_DummyCbk</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>93</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>143</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/LdCom_DummyCbk.h_51</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/src/Autosar/include/LdCom_DummyCbk.h</sourcefile>
      <sourceline>51</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>LdCom.EB.SWS_LdCom_00039_DummyCbk</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>94</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>144</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/LdCom_DummyCbk.h_70</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/src/Autosar/include/LdCom_DummyCbk.h</sourcefile>
      <sourceline>70</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>LdCom.EB.SWS_LdCom_00040_DummyCbk</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>95</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>145</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/LdCom_DummyCbk.h_85</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/src/Autosar/include/LdCom_DummyCbk.h</sourcefile>
      <sourceline>85</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>LdCom.EB.SWS_LdCom_00036_DummyCbk</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>96</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>146</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/LdCom_DummyCbk.h_106</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/src/Autosar/include/LdCom_DummyCbk.h</sourcefile>
      <sourceline>106</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>LdCom.EB.SWS_LdCom_00037_DummyCbk</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>97</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>147</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/LdCom_DummyCbk.h_120</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/src/Autosar/include/LdCom_DummyCbk.h</sourcefile>
      <sourceline>120</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>LdCom.EB.SWS_LdCom_00041_DummyCbk</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>98</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>148</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/LdCom_DummyCbk.h_135</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/src/Autosar/include/LdCom_DummyCbk.h</sourcefile>
      <sourceline>135</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>LdCom.EB.SWS_LdCom_00042_DummyCbk</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>99</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>149</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/LdCom_DummyCbk.h_149</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/src/Autosar/include/LdCom_DummyCbk.h</sourcefile>
      <sourceline>149</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>LdCom.EB.SWS_LdCom_00053_DummyCbk</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>100</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>150</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/src/LdCom.c.m4_40</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/src/Autosar/src/LdCom.c.m4</sourcefile>
      <sourceline>40</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LDCOM_00001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>0</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>151</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/LdCom.c.m4_44</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/src/Autosar/src/LdCom.c.m4</sourcefile>
      <sourceline>44</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LDCOM_00001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>0</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>152</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/LdCom.c.m4_48</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/src/Autosar/src/LdCom.c.m4</sourcefile>
      <sourceline>48</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LDCOM_00001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>0</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>153</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/LdCom.c.m4_51</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/src/Autosar/src/LdCom.c.m4</sourcefile>
      <sourceline>51</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00050</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>2</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>154</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/config/LdCom.xdm.m4_61</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/src/Autosar/config/LdCom.xdm.m4</sourcefile>
      <sourceline>61</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>LdCom.EB.MultipleConfiguationContainer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>101</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>155</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/config/LdCom_EBParameters.xdm.m4_67</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/src/Autosar/config/LdCom_EBParameters.xdm.m4</sourcefile>
      <sourceline>67</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>LdCom.EB.PBCFGM108</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>156</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/LdCom_EBParameters.xdm.m4_72</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/src/Autosar/config/LdCom_EBParameters.xdm.m4</sourcefile>
      <sourceline>72</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>LdCom.EB.CustomHeaderFiles_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>104</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>157</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/config/LdCom_Extension.xdm.m4_52</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/src/Autosar/config/LdCom_Extension.xdm.m4</sourcefile>
      <sourceline>52</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>LdCom.EB.MultipleConfiguationContainer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>101</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>158</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/generate/xgen/LdCom.xgen_63</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/src/Autosar/generate/xgen/LdCom.xgen</sourcefile>
      <sourceline>63</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00052</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>39</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>159</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_LdCom_DBGINST_001</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/build/reqm/common_req/LdCom_DbgInst_Trace_APIs.c</sourcefile>
      <sourceline>40</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
   Test Dbg
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
  VP: Successful compilation test.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.EB.DBGINST001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>109</internalId></provcov>
        <provcov>
          <linksto>LdCom.EB.DBGINST002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>110</internalId></provcov>
        <provcov>
          <linksto>LdCom.EB.DBGINST003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>111</internalId></provcov>
        <provcov>
          <linksto>LdCom.EB.DBGINST004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>112</internalId></provcov>
        <provcov>
          <linksto>LdCom.EB.DBGINST005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>113</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>160</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>LdCom_Test_IsValidConfig</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/build/reqm/common_req/LdCom_PbcfgM_Main_Impl_Test.c</sourcefile>
      <sourceline>71</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the function LdCom_IsValidConfig() is implemented as specified.
  
Test Object: 
    LdCom_IsValidConfig()
  
Test Precondition: 
    The LdCom module is not initialized.
  
Test Execution: 
    01: Call the function LdCom_IsValidConfig() with an NULL_PTR.
    02: VP:
        The function must have returned with E_NOT_OK.
    03: Create an invalid configuration regarding the endianness and alignment.
    04: Call the function LdCom_IsValidConfig() with this invalid configuration.
    05: VP(LdCom.EB.PBCFGM106):
        The function must have returned with E_NOT_OK.
    The following 3 steps are only executed if the module has a link-time configuration:
        06: Create an invalid configuration regarding the link time configuration.
        07: Call the function LdCom_IsValidConfig() with this invalid configuration.
        08: VP(LdCom.EB.PBCFGM105):
                The function must have returned with E_NOT_OK.
    09: Create an invalid configuration regarding the compile time configuration.
    10: Call the function LdCom_IsValidConfig() with this invalid configuration.
    11: VP(LdCom.EB.PBCFGM104):
        The function must have returned with E_NOT_OK.
    12: Create an invalid configuration regarding the published information configuration.
    13: Call the function LdCom_IsValidConfig() with this invalid configuration.
    14: VP(LdCom.EB.PBCFGM104_1):
        The function must have returned with E_NOT_OK.
    15: Call the function LdCom_IsValidConfig() with a valid configuration.
    16: VP:
        The function must have returned with E_OK.
    17: VP(LdCom.EB.PBCFGM107):
        Check if LDCOM_PBCFGM_SUPPORT_ENABLED is set to STD_ON.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.EB.PBCFGM101</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>114</internalId></provcov>
        <provcov>
          <linksto>LdCom.EB.PBCFGM102</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>115</internalId></provcov>
        <provcov>
          <linksto>LdCom.EB.PBCFGM104</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>116</internalId></provcov>
        <provcov>
          <linksto>LdCom.EB.PBCFGM104_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>117</internalId></provcov>
        <provcov>
          <linksto>LdCom.EB.PBCFGM105</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>118</internalId></provcov>
        <provcov>
          <linksto>LdCom.EB.PBCFGM106</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>119</internalId></provcov>
        <provcov>
          <linksto>LdCom.EB.PBCFGM107</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>161</internalId></specobject>
    <specobject>
      <id>LdCom_Test_VerifyInitWithPcfgM</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/build/reqm/common_req/LdCom_PbcfgM_Main_Impl_Test.c</sourcefile>
      <sourceline>225</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the LdCom can be initialized via the PbcfgM.
  
Test Object: 
    LdCom_IsValidConfig()
  
Test Precondition: 
    The LdCom module must not have been initialized.
  
Test Execution: 
    01: Create an invalid configuration regarding the endianness and alignment.
    02: Call the function LdCom_Init() with this invalid configuration.
    03: VP:
        A Det call must have been performed correctly.
    04: Create an invalid configuration regarding the compile time configuration.
    05: Call the function LdCom_Init() with this invalid configuration.
    06: VP:
        A Det call must have been performed correctly.
    The following 3 steps are only executed if the module has a link-time configuration:
        07: Create an invalid configuration regarding the link time configuration.
        08: Call the function LdCom_Init() with this invalid configuration.
        09: VP:
            A Det call must have been performed correctly.
    10: Create an invalid configuration regarding the published information configuration.
    11: Call the function LdCom_Init() with this invalid configuration.
    12: VP:
        A Det call must have been performed correctly.
    13: Initialize the PbcfgM_GetConfig() stub that way that it can return a valid function.
    14: Call the function LdCom_Init() with a null pointer.
    15: VP:
        The function PbcfgM_GetConfig() must have been called once.
    16: VP:
        No Det call must have been performed.
    17: VP:
        The module internal configuration pointer LdCom_RootPtr must equal
        the pointer supplied to the initialization function
    18: PbcfgM_GetConfig shall return E_NOT_OK.
        set the configuration pointer which is returned to NULL_PTR
    19: Call LdCom_Init with NULL_PTR.
    20: VP(LdCom.EB.PBCFGM110):
        Check if Det error is reported.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.EB.PBCFGM110</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>122</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>162</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>LdCom_Test_PBcfgM_Off</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/build/reqm/common_req/LdCom_PbcfgM_Off_Compile_Test.c</sourcefile>
      <sourceline>26</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
      Verify that if PbcfgM support is disabled then LdCom_PBCfg.c shall define
      TS_PB_CFG_LAYOUT_TYPE and TS_PB_CFG_NAME.
      LDCOM_PBCFGM_SUPPORT_ENABLED shall be set to STD_OFF.
      LDCOM_RELOCATABLE_CFG_ENABLE shall be set to STD_OFF.
    
Test Object: None.
Test Precondition: 
      - PbcfgM configuration does not refer to module LdCom (or no config exists)
      - Include LdCom_PBcfg.c only for step 01 and 02.
      - Include LdCom_Cfg.h for step 03.
    
Test Execution: 
        01: VP(LdCom.EB.PbcfgM_General_6):
            Check that symbols TS_PB_CFG_LAYOUT_TYPE and TS_PB_CFG_NAME exists.
        02: VP(LdCom.EB.PbcfgM_General_6):
            Check that symbols TS_PB_CFG_LAYOUT_TYPE and TS_PB_CFG_NAME has the value
            LdCom_ConfigLayoutType and LDCOM_CONFIG_NAME respectively.
        03: VP (LdCom.EB.PBCFGM107):
            Verify that LDCOM_PBCFGM_SUPPORT_ENABLED is set to STD_OFF.
        04: VP(LdCom.EB.PBCFGM108, LdCom.EB.RelocatablePBCfg):
            LDCOM_RELOCATABLE_CFG_ENABLE shall be STD_OFF
    
Test Input: 
    
Test Output: 
    &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.EB.PbcfgM_General_6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>125</internalId></provcov>
        <provcov>
          <linksto>LdCom.EB.PBCFGM107</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>LdCom.EB.PBCFGM108</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>LdCom.EB.RelocatablePBCfg</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>108</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>163</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>LdCom_Test_PBcfgM_On</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/build/reqm/common_req/LdCom_PbcfgM_On_Compile_Test.c</sourcefile>
      <sourceline>24</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
      1.)
      Verify that LDCOM_RELOCATABLE_CFG_ENABLE is defined
      in the header file LdCom_Cfg.h.
      2.)
      Verify that if PbcfgM support is enabled then LdCom_PBCfg.c shall NOT define
      TS_PB_CFG_LAYOUT_TYPE and TS_PB_CFG_NAME.
    
Test Object: None.
Test Precondition: 
        - LDCOM_PBCFGM_SUPPORT_ENABLED = STD_ON
    
Test Execution: 
        ------------------------ 1.) ---------------------
        01: VP (LdCom.EB.PbcfgM_General_3,
                LdCom.EB.PBCFGM108,
                LdCom.EB.RelocatablePBCfg):
            Verify that LDCOM_RELOCATABLE_CFG_ENABLE is set to STD_ON.
        ------------------------ 2.) ---------------------
        02: Include LdCom_PBcfg.c.
        03: VP(LdCom.EB.PbcfgM_General_6):
            Check that symbols TS_PB_CFG_LAYOUT_TYPE and TS_PB_CFG_NAME exist.
    
Test Input: 
        None.
    
Test Output: 
        Binary file.
    &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.EB.PbcfgM_General_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>124</internalId></provcov>
        <provcov>
          <linksto>LdCom.EB.PbcfgM_General_6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>125</internalId></provcov>
        <provcov>
          <linksto>LdCom.EB.PBCFGM108</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>LdCom.EB.RelocatablePBCfg</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>108</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>164</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_LDCOM_Gen_PBcfgM_00000_OnlyPbCfg</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/build/reqm/common_req/LdCom_PbcfgOnly_GenTest_00_OnlyPbCfg.h</sourcefile>
      <sourceline>27</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that the LDCOM post build configuration also compiles stand alone.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
    * Set TS_BUILD_POST_BUILD_BINARY to TRUE to prevent compilation of non post build files.
    * Remove all generated LDCOM C files except post build files if there are any.

Test Execution: 
    The test run is successful when the LDCOM compiles under sticking to the precondition and a
    binary file is generated.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.EB.PostBuild_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>165</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_LdCom_VerifyCodeStub</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/build/reqm/common_req/LdCom_VerifyStub_testspec.h</sourcefile>
      <sourceline>7</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that the code stub of the module is consistent with the
    implementation.
  
Test Object: 
    Relocatable post-build configuration macros generation.
  
Test Precondition: 
    Permutation [VerifyStub == true]:
      - Unit test contains its own code stub
      - Module is excluded from generation and compilation
    Permutation [VerifyStub == false]:
      - unit test excludes its own code stub
  
Test Execution: 
    01: Invoke all module APIs
    02: VP(LdCom.EB.Interface.Consistency):
        Unit test compiles (implicitly tested)
  
Test Input: 
  
Test Output: 
    Test is correctly generated and compiled.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.EB.Interface.Consistency</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>127</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>166</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>LdCom_ComTest_01</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Compile/IN/LdCom_ComTest_01/source/application/LdCom_ComTest_01.c</sourcefile>
      <sourceline>71</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  This test verifies that the LdCom module compiles the
  * general services:
     - LdCom_Init
     - LdCom_DeInit
     - LdCom_GetVersionInfo
  * services called by Rte:
     - LdCom_Transmit
  * communication interface services called by PduR:
     - LdCom_RxIndication
     - LdCom_TriggerTransmit
     - LdCom_TxConfirmation
  * transport protocol services called by PduR:
     - LdCom_StartOfReception
     - LdCom_CopyRxData
     - LdCom_TpRxIndication
     - LdCom_CopyTxData
     - LdCom_TpTxConfirmation
  * EB specific service:
     - LdCom_IsValidConfig (provided with centralized requirement PBCFGM101)

  Permutation:
  p0: This test verifies that the LdCom module compiles with existence of the 'optional' Det API
      Det_ReportError.
      This test verifies that LDCOM_DEV_ERROR_DETECT is set to STD_ON, if LdComDevErrorDetect is enabled.

  p1: This test verifies that the LdCom module compiles with no existence of the 'optional' Det API
      Det_ReportError.
      This test verifies that LDCOM_DEV_ERROR_DETECT is set to STD_OFF, if LdComDevErrorDetect is disabled.


Test Object: None.
Test Precondition: 
  p0: LdComDevErrorDetect is enabled
      EBSTUBS_FUNCENABLED_DET_REPORTERROR is set to STD_ON

  p1: LdComDevErrorDetect is disabled
      EBSTUBS_FUNCENABLED_DET_REPORTERROR is set to STD_OFF


Test Execution: 
  The test run is successful when the LdCom compiles under sticking to the precondition.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00022</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>40</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00023</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>41</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00024</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>42</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00026</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>44</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00027</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>49</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00028</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>50</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00029</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>51</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00030</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>52</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00031</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>53</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00032</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>54</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00056</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>55</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00033</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>56</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00035</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>58</internalId></provcov>
        <provcov>
          <linksto>LdCom.ECUC_LdCom_00020</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>167</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>LdCom_ComTest_03_ImportedTypes</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Compile/IN/LdCom_ComTest_03_ImportedTypes/source/application/EbTest.c</sourcefile>
      <sourceline>50</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Verify that the types listed in SWS_LDCOM_00020 are included:
        Module            Imported Type
      ComStack_Types  BufReq_ReturnType
                      PduIdType
                      PduInfoType
                      PduLengthType
                      RetryInfoType
      Std_Types       Std_ReturnType
                      Std_VersionInfoType
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  The header files ComStack_Types.h and Std_Types.h are available.

Test Execution: 
  01: VP: Instances of the imported types are defined for:
             BufReq_ReturnType   BufReq_Return
             PduIdType           PduId
             PduInfoType         PduInfo
             PduLengthType       PduLength
             RetryInfoType       RetryInfo
             Std_ReturnType      Std_Return
             Std_VersionInfoType Std_VersionInfo

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00020</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>38</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>168</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>LdCom_ComTest_06_TpOnly</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Compile/IN/LdCom_ComTest_06_TpOnly/source/application/LdCom_ComTest_06_TpOnly.c</sourcefile>
      <sourceline>65</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  This test verifies that the LdCom module compiles the
  * general services:
     - LdCom_Init
     - LdCom_DeInit
  * services called by Rte:
     - LdCom_Transmit
  * transport protocol services called by PduR:
     - LdCom_StartOfReception
     - LdCom_CopyRxData
     - LdCom_TpRxIndication
     - LdCom_CopyTxData
     - LdCom_TpTxConfirmation
  * EB specific service:
     - LdCom_IsValidConfig (provided with centralized requirement PBCFGM101)

  This test verifies partly that PduR_LdComTransmit is an optional API (here it exists).


Test Object: None.
Test Precondition: None.
Test Execution: 

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00022</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>40</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00023</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>41</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00026</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>44</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00027</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>49</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00028</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>50</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00029</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>51</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00030</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>52</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00031</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>53</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00035</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>58</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>169</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>LdCom_ComTest_07_HandleIdGenerator</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Compile/IN/LdCom_ComTest_07_HandleIdGenerator/source/application/EbTest.c</sourcefile>
      <sourceline>37</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
   This test checks that running the handle ID wizard creates a valid configuration out of invalid
   distributed PduIds with respect to configuration parameter LdComHandleId.
   These handle IDs are checked for being zero-based and dense for LDCOM_TP and LDCOM_IF with
   respect to LDCOM_RECEIVE and LDCOM_SEND (4 number ranges).
   This test also verifies the correct generation of the symbolic name values.
 
Test Object: None.
Test Precondition: 
     None.
 
Test Execution: 
    The C-code is not part of this test.
    The handle ID wizard is started by command line via the Merged_Makefile.mak.
    The module configuration generator generates file LdCom_SymbolicNames_PBcfg.h
    which is compared to the reference.

Test Input: 
     Usage of a common AUTOSAR configuration having all features configured.
     Configuration holds wrongly assigned handle IDs (non zero-based or non-dense or non-unique)
     Here, all are set to -1.
 
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.ECUC_LdCom_00005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>76</internalId></provcov>
        <provcov>
          <linksto>LdCom.EB.HandleIdGenerator</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>88</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>170</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>LdCom_ComTest_08_TxOnly</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Compile/IN/LdCom_ComTest_08_TxOnly/source/application/LdCom_ComTest_08_TxOnly.c</sourcefile>
      <sourceline>65</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  This test verifies that the LdCom module compiles a configuration holding only Tx IPDUs.
  Especially,
  * services called by Rte:
     - LdCom_Transmit
  * communication interface services called by PduR:
     - LdCom_TriggerTransmit
     - LdCom_TxConfirmation
  * transport protocol services called by PduR:
     - LdCom_CopyTxData
     - LdCom_TpTxConfirmation

  This test also verifies that the shortName of configuration container LdComConfig is used as
  C identifier name for the generated instance of LdCom_ConfigLayoutType.

  Note: The functionality of the APIs is tested within test sequence LdCom_ConTest_02_ApiCalls.

Test Object: None.
Test Precondition: 
  Configuration holds only Tx IPDUs

Test Execution: 
  01: VP: LdCom_Init() is successfully called with the short name of configuration container
      LdComConfig

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00026</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>44</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00027</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>49</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00028</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>50</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00056</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>55</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00033</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>56</internalId></provcov>
        <provcov>
          <linksto>LdCom.EB.ShortNameOfLdComConfigContainer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>102</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>171</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>LdCom_ComTest_09_IfRxOnly</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Compile/IN/LdCom_ComTest_09_IfRxOnly/source/application/LdCom_ComTest_09_IfRxOnly.c</sourcefile>
      <sourceline>76</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  This test verifies that the LdCom module compiles a configuration holding only Rx IPDUs
  for communication interface modules. Especially,
  * communication interface services called by PduR:
     - LdCom_RxIndication

  Note: The functionality of the API is tested within test sequence LdCom_ConTest_02_ApiCalls.

  This test verifies partly that PduR_LdComTransmit are optional APIs
  (here they do not exist).

  This test verifies the deactivation by disabling the LdCom_GetVersionInfo API.

Test Object: None.
Test Precondition: 
  Configuration holds only Rx IPDUs for communication interface modules
  EBSTUBS_FUNCENABLED_PDUR_LDCOMTRANSMIT is set to STD_OFF
  LdComVersionInfoApi is disabled.

Test Execution: 
  The test run is successful when the LdCom compiles under sticking to the precondition.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00032</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>54</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00035</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>58</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00045</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>43</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>172</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>LdCom_ComTest_10_NoPbCfg</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Compile/IN/LdCom_ComTest_10_NoPbCfg/source/application/LdCom_ComTest_10.c</sourcefile>
      <sourceline>35</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that that the LdCom also compiles without any post build information
&lt;/para&gt;

Test Object: None.
Test Precondition: 
    * The merged make file holds a rule which removes all post build files after generation

Test Execution: 
    The test run is successful when the LdCom compiles under sticking to the precondition.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.EB.PostBuild_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>173</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_LDCOM_GEN_01</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Compile/IN/LdCom_GenTest_01/source/application/testspec.h</sourcefile>
      <sourceline>27</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall verify that the generator issues an error if the PduR module does not reference
    a configured Pdu within the LdCom module.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
    VP: LDcom generator shall issue an error which states that the PduR does not reference the
        corresponding Pdu which is configured within the LdCom module.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.EB.ReferencedPdu</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>103</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>174</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_LDCOM_01001_RxInd_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_01_DetCalls/source/application/EbTest.c</sourcefile>
      <sourceline>45</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Check if an error is reported to the Det_ReportError service in development mode if the LdCom
  module has not been initialized when LdCom_RxIndication is called.
&lt;/para&gt;

Test Object: 
  LdCom_RxIndication()

Test Precondition: 
  LdCom_State is equal to LDCOM_UNINIT.

Test Execution: 
  01: call LdCom_RxIndication with valid Rx PDU-ID and valid pointer to PduInfo.
  02: VP: Det_ReportError is called with error code LDCOM_E_UNINIT.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00018.UNINIT</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>33</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>175</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_01002_TrigTx_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_01_DetCalls/source/application/EbTest.c</sourcefile>
      <sourceline>85</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that an error is reported in development mode if the LdCom module
  has not been initialized when LdCom_TriggerTransmit function is called and an
  error is returned.

  This test verifies that an error is returned by the API.
&lt;/para&gt;

Test Object: 
  LdCom_TriggerTransmit

Test Precondition: 
  LdCom_State is equal to LDCOM_UNINIT.

Test Execution: 
  01: call LdCom_TriggerTransmit with valid Tx PDU-ID and valid pointer to PduInfo.
  02: VP (LdCom.SWS_LdCom_00018.UNINIT): Det is called with error code LDCOM_E_UNINIT.
  03: VP (LdCom.EB.SWS_LdCom_00019): Error is returned with E_NOT_OK.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00018.UNINIT</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>33</internalId></provcov>
        <provcov>
          <linksto>LdCom.EB.SWS_LdCom_00019</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>176</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_01003_TxConf_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_01_DetCalls/source/application/EbTest.c</sourcefile>
      <sourceline>134</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Check if an error is reported in development mode if the LdCom module has not been initialized
  when LdCom_TxConfirmation is called.
&lt;/para&gt;

Test Object: 
  LdCom_TxConfirmation

Test Precondition: 
  LdCom_State is equal to LDCOM_UNINIT.

Test Execution: 
  01: call LdCom_TxConfirmation with valid Tx PDU-ID.
  02: VP: Det is called with error code LDCOM_E_UNINIT.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00018.UNINIT</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>33</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>177</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_01010_StartOfReception_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_01_DetCalls/source/application/EbTest.c</sourcefile>
      <sourceline>172</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that an error is reported in development mode if the LdCom module
  has not been initialized when LdCom_StartOfReception is called.

  This test verifies that an error is returned by the API if the LdCom module
  has not been initialized when LdCom_StartOfReception is called.
&lt;/para&gt;

Test Object: 
  LdCom_StartOfReception()

Test Precondition: 
  LdCom_State is equal to LDCOM_UNINIT.

Test Execution: 
  01: call LdCom_StartOfReception with valid Rx PDU-ID, TpSduLength 0 and valid pointer to buffer size.
  02: VP (LdCom.SWS_LdCom_00018.UNINIT): Det is called with error code LDCOM_E_UNINIT.
  03: VP (LdCom.EB.SWS_LdCom_00019): Error is returned with BUFREQ_E_NOT_OK.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00018.UNINIT</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>33</internalId></provcov>
        <provcov>
          <linksto>LdCom.EB.SWS_LdCom_00019</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>178</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_01011_CopyRxData_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_01_DetCalls/source/application/EbTest.c</sourcefile>
      <sourceline>223</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that an error is reported in development mode if the LdCom module
  has not been initialized when LdCom_CopyRxData is called.

  This test verifies that an error is returned by the API if the LdCom module
  has not been initialized when LdCom_CopyRxData is called.
&lt;/para&gt;

Test Object: 
  LdCom_CopyRxData()

Test Precondition: 
  LdCom_State is equal to LDCOM_UNINIT.

Test Execution: 
  01: call LdCom_CopyRxData with valid Rx PDU-ID, valid pointer to PduInfo and valid pointer to
      buffer size.
  02: VP (LdCom.SWS_LdCom_00018.UNINIT): Det is called with error code LDCOM_E_UNINIT.
  03: VP (LdCom.EB.SWS_LdCom_00019): Error is returned with BUFREQ_E_NOT_OK.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00018.UNINIT</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>33</internalId></provcov>
        <provcov>
          <linksto>LdCom.EB.SWS_LdCom_00019</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>179</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_01012_TpRxInd_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_01_DetCalls/source/application/EbTest.c</sourcefile>
      <sourceline>274</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Check if an error is reported in development mode if the LdCom module has not been initialized
  when LdCom_TpRxIndication is called.
&lt;/para&gt;

Test Object: 
  LdCom_RxIndication()

Test Precondition: 
  LdCom_State is equal to LDCOM_UNINIT.

Test Execution: 
  01: call LdCom_TpRxIndication with valid Rx PDU-ID and valid value for Result.
  02: VP: Det is called with error code LDCOM_E_UNINIT.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00018.UNINIT</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>33</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>180</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_01020_CopyTxData_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_01_DetCalls/source/application/EbTest.c</sourcefile>
      <sourceline>312</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that an error is reported in development mode if the LdCom module
  has not been initialized when LdCom_CopyTxData is called.

  This test verifies that an error is returned by the API if the LdCom module
  has not been initialized when LdCom_CopyTxData is called.
&lt;/para&gt;

Test Object: 
  LdCom_CopyTxData

Test Precondition: 
  LdCom_State is equal to LDCOM_UNINIT.

Test Execution: 
  01: call LdCom_CopyTxData with valid Tx PDU-ID, valid pointer to PduInfo,
      valid pointer to RetryInfo and valid pointer to AvailableData.
  02: VP (LdCom.SWS_LdCom_00018.UNINIT): Det is called with error code LDCOM_E_UNINIT.
  03: VP (LdCom.EB.SWS_LdCom_00019): Error is returned with BUFREQ_E_NOT_OK.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00018.UNINIT</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>33</internalId></provcov>
        <provcov>
          <linksto>LdCom.EB.SWS_LdCom_00019</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>181</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_01021_TpTxConf_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_01_DetCalls/source/application/EbTest.c</sourcefile>
      <sourceline>365</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Check if an error is reported in development mode if the LdCom module has not been initialized
  when LdCom_TpTxConfirmation is called.
&lt;/para&gt;

Test Object: 
  LdCom_TxConfirmation

Test Precondition: 
  LdCom_State is equal to LDCOM_UNINIT.

Test Execution: 
  01: call LdCom_TxConfirmation with valid Tx PDU-ID and valid Result.
  02: VP: Det is called with error code LDCOM_E_UNINIT.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00018.UNINIT</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>33</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>182</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_01030_Transmit_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_01_DetCalls/source/application/EbTest.c</sourcefile>
      <sourceline>403</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that an error is reported in development mode if the LdCom module
  has not been initialized when LdCom_Transmit() function is called and an error
  is returned.

  This test verifies that an error is returned by the API.
&lt;/para&gt;

Test Object: 
  LdCom_Transmit()

Test Precondition: 
  LdCom_State is equal to LDCOM_UNINIT.

Test Execution: 
  01: call LdCom_Transmit with valid Tx PDU-ID and valid pointer to PduInfo.
  02: VP (LdCom.SWS_LdCom_00018.UNINIT): Det is called with error code LDCOM_E_UNINIT.
  03: VP (LdCom.EB.SWS_LdCom_00019): Error is returned with E_NOT_OK.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00018.UNINIT</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>33</internalId></provcov>
        <provcov>
          <linksto>LdCom.EB.SWS_LdCom_00019</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>183</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_01031_GetVersionInfo_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_01_DetCalls/source/application/EbTest.c</sourcefile>
      <sourceline>452</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Check if no error is reported in development mode if the LdCom module has not been initialized
  when LdCom_GetVersionInfo is called.
&lt;/para&gt;

Test Object: 
  LdCom_GetVersionInfo()

Test Precondition: 
  LdCom_State is equal to LDCOM_UNINIT.

Test Execution: 
  01: call LdCom_GetVersionInfo with valid pointer to VersionInfo.
  02: VP: Det_ReportError is not called.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00018.UNINIT</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>33</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>184</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_01040_InitNull_RepError</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_01_DetCalls/source/application/EbTest.c</sourcefile>
      <sourceline>495</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Verify if error code LDCOM_E_INIT_FAILED is reported to the Det_ReportError service in
  development mode if the LdCom module is initialized by NULL.
&lt;/para&gt;

Test Object: 
  LdCom_Init()

Test Precondition: 
  LdCom_State is equal to LDCOM_UNINIT.

Test Execution: 
  01: call LdCom_Init with NULL.
  02: VP: Det_ReportError is called with error code LDCOM_E_INIT_FAILED.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00018.INIT_FAILED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>37</internalId></provcov>
        <provcov>
          <linksto>LdCom.EB.SWS_LdCom_00019</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>185</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_01041_InitValidConfig</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_01_DetCalls/source/application/EbTest.c</sourcefile>
      <sourceline>534</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Check if no error is reported in development mode if the LdCom module is initialized with valid
  configuration.
&lt;/para&gt;

Test Object: 
  LdCom_Init()

Test Precondition: 
  LdCom_State is equal to LDCOM_UNINIT.

Test Execution: 
  01: call LdCom_Init with valid configuration.
  02: VP: Det_ReportError() is not called.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00018.INIT_FAILED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>37</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>186</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_01050_RxInd_ParamNull</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_01_DetCalls/source/application/EbTest.c</sourcefile>
      <sourceline>582</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Check if an error is reported to the Det_ReportError service in development mode when
  LdCom_RxIndication is called with parameter PduInfoPtr equal to NULL.
&lt;/para&gt;

Test Object: 
  LdCom_RxIndication()

Test Precondition: 
  LdCom module has been initialized.

Test Execution: 
  01: call LdCom_RxIndication with valid Rx PDU-ID and pointer to PduInfo set to NULL.
  02: VP: Det_ReportError is called with error code LDCOM_E_PARAM_POINTER.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00018.PARAM_POINTER</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>34</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>187</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_01051_TriggerTx_ParamNull</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_01_DetCalls/source/application/EbTest.c</sourcefile>
      <sourceline>621</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that an error is reported in development mode when LdCom_TriggerTransmit
  is called with pointer to PduInfo equal to NULL.

  This test verifies that an error is returned by the API when LdCom_TriggerTransmit
  is called with pointer to PduInfo equal to NULL.
&lt;/para&gt;

Test Object: 
  LdCom_TriggerTransmit

Test Precondition: 
  LdCom module has been initialized.

Test Execution: 
  01: call LdCom_TriggerTransmit with valid Tx PDU-ID and pointer to PduInfo set to NULL.
  02: VP (LdCom.SWS_LdCom_00018.PARAM_POINTER): Det is called with error code LDCOM_E_PARAM_POINTER.
  03: VP (LdCom.EB.SWS_LdCom_00019): Error is returned with E_NOT_OK.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00018.PARAM_POINTER</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>34</internalId></provcov>
        <provcov>
          <linksto>LdCom.EB.SWS_LdCom_00019</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>188</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_01060_StartOfReception_ParamNull</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_01_DetCalls/source/application/EbTest.c</sourcefile>
      <sourceline>669</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that an error is reported in development mode when LdCom_StartOfReception
  is called with parameter pointer to buffer size equal to NULL.

  This test verifies that an error is returned by the API when LdCom_StartOfReception
  is called with parameter pointer to buffer size equal to NULL.
&lt;/para&gt;

Test Object: 
  LdCom_StartOfReception()

Test Precondition: 
  LdCom module has been initialized.

Test Execution: 
  01: call LdCom_StartOfReception with valid Rx PDU-ID, valid TpSduLength but pointer to
      buffer size set to NULL.
  02: VP (LdCom.SWS_LdCom_00018.PARAM_POINTER): Det is called with error code LDCOM_E_PARAM_POINTER.
  03: VP (LdCom.EB.SWS_LdCom_00019): Error is returned with BUFREQ_E_NOT_OK.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00018.PARAM_POINTER</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>34</internalId></provcov>
        <provcov>
          <linksto>LdCom.EB.SWS_LdCom_00019</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>189</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_01061_CopyRxData_ParamNull</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_01_DetCalls/source/application/EbTest.c</sourcefile>
      <sourceline>720</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that an error is reported in development mode when LdCom_CopyRxData
  is called with parameter pointer to PduInfo equal to NULL.

  This test verifies that an error is returned by the API when LdCom_CopyRxData
  is called with parameter pointer to PduInfo equal to NULL.
&lt;/para&gt;

Test Object: 
  LdCom_CopyRxData()

Test Precondition: 
  LdCom module has been initialized.

Test Execution: 
  01: call LdCom_CopyRxData with valid Rx PDU-ID, valid pointer to buffer size but
      pointer to PduInfo set to NULL.
  02: VP (LdCom.SWS_LdCom_00018.PARAM_POINTER): Det is called with error code LDCOM_E_PARAM_POINTER.
  03: VP (LdCom.EB.SWS_LdCom_00019): Error is returned with BUFREQ_E_NOT_OK.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00018.PARAM_POINTER</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>34</internalId></provcov>
        <provcov>
          <linksto>LdCom.EB.SWS_LdCom_00019</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>190</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_01062_CopyRxData_Param2Null</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_01_DetCalls/source/application/EbTest.c</sourcefile>
      <sourceline>770</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that an error is reported in development mode when LdCom_CopyRxData
  is called with parameter pointer to BufferSize equal to NULL.

  This test verifies that an error is returned by the API when LdCom_CopyRxData
  is called with parameter pointer to BufferSize equal to NULL.
&lt;/para&gt;

Test Object: 
  LdCom_CopyRxData()

Test Precondition: 
  LdCom module has been initialized.

Test Execution: 
  01: call LdCom_CopyRxData with valid Rx PDU-ID, valid pointer to PduInfo but
      pointer to buffer size set to NULL.
  02: VP (LdCom.SWS_LdCom_00018.PARAM_POINTER): Det is called with error code LDCOM_E_PARAM_POINTER.
  03: VP (LdCom.EB.SWS_LdCom_00019): Error is returned with BUFREQ_E_NOT_OK.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00018.PARAM_POINTER</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>34</internalId></provcov>
        <provcov>
          <linksto>LdCom.EB.SWS_LdCom_00019</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>191</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_01070_CopyTxData_ParamNull</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_01_DetCalls/source/application/EbTest.c</sourcefile>
      <sourceline>820</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that an error is reported in development mode when LdCom_CopyTxData
  is called with parameter pointer to PduInfo equal to NULL.

  This test verifies that an error is returned by the API when LdCom_CopyTxData
  is called with parameter pointer to PduInfo equal to NULL.
&lt;/para&gt;

Test Object: 
  LdCom_CopyTxData

Test Precondition: 
  LdCom module has been initialized.

Test Execution: 
  01: call LdCom_CopyTxData with valid Tx PDU-ID, valid pointer to RetryInfo,
      valid pointer to AvailableData, but pointer to PduInfo set to NULL.
  02: VP (LdCom.SWS_LdCom_00018.PARAM_POINTER): Det is called with error code LDCOM_E_PARAM_POINTER.
  03: VP (LdCom.EB.SWS_LdCom_00019): Error is returned with BUFREQ_E_NOT_OK.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00018.PARAM_POINTER</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>34</internalId></provcov>
        <provcov>
          <linksto>LdCom.EB.SWS_LdCom_00019</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>192</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_01071_CopyTxData_ParamNull2</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_01_DetCalls/source/application/EbTest.c</sourcefile>
      <sourceline>872</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that an error is reported in development mode when LdCom_CopyTxData
  is called with parameter pointer to AvailableData equal to NULL.

  This test verifies that an error is returned by the API when LdCom_CopyTxData
  is called with parameter pointer to AvailableData equal to NULL.
&lt;/para&gt;

Test Object: 
  LdCom_CopyTxData

Test Precondition: 
  LdCom module has been initialized.

Test Execution: 
  01: call LdCom_CopyTxData with valid Tx PDU-ID, valid pointer to RetryInfo,
      valid pointer to PduInfo, but pointer to AvailableData set to NULL.
  02: VP (LdCom.SWS_LdCom_00018.PARAM_POINTER): Det is called with error code LDCOM_E_PARAM_POINTER.
  03: VP (LdCom.EB.SWS_LdCom_00019): Error is returned with BUFREQ_E_NOT_OK.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00018.PARAM_POINTER</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>34</internalId></provcov>
        <provcov>
          <linksto>LdCom.EB.SWS_LdCom_00019</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>193</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_01080_Transmit_ParamNull</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_01_DetCalls/source/application/EbTest.c</sourcefile>
      <sourceline>924</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that an error is reported in development mode when LdCom_Transmit
  is called with pointer to PduInfo equal to NULL.

  This test verifies that an error is returned by the API when LdCom_Transmit
  is called with pointer to PduInfo equal to NULL.
&lt;/para&gt;

Test Object: 
  LdCom_Transmit()

Test Precondition: 
  LdCom module has been initialized.

Test Execution: 
  01: call LdCom_Transmit with valid Tx PDU-ID and pointer to PduInfo set to NULL.
  02: VP (LdCom.SWS_LdCom_00018.PARAM_POINTER): Det is called with error code LDCOM_E_PARAM_POINTER.
  03: VP (LdCom.EB.SWS_LdCom_00019): Error is returned with E_NOT_OK.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00018.PARAM_POINTER</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>34</internalId></provcov>
        <provcov>
          <linksto>LdCom.EB.SWS_LdCom_00019</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>194</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_01081_GetVersionInfo_ParamNull</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_01_DetCalls/source/application/EbTest.c</sourcefile>
      <sourceline>972</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Check if an error is reported in development mode if the parameter VersionInfo
  is equal to NULL.
&lt;/para&gt;

Test Object: 
  LdCom_GetVersionInfo()

Test Precondition: 
  LdCom module has been initialized.

Test Execution: 
  01: call LdCom_GetVersionInfo with pointer to VersionInfo set to NULL.
  02: VP: Det is called with error code LDCOM_E_PARAM_POINTER.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00018.PARAM_POINTER</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>34</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>195</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_01090_RxInd_PduIdInvalid</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_01_DetCalls/source/application/EbTest.c</sourcefile>
      <sourceline>1017</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Check if an error is reported to the Det_ReportError service in development mode when
  LdCom_RxIndication is called with parameter RxPduId not between 0 (zero) and number
  of Rx paths configured.
&lt;/para&gt;

Test Object: 
  LdCom_RxIndication()

Test Precondition: 
  LdCom module has been initialized.

Test Execution: 
  01: call LdCom_RxIndication with maximum allowed RxPduId increased by one and valid pointer to PduInfo.
  02: VP: Det_ReportError is called with error code LDCOM_E_INVALID_PDU_SDU_ID.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00018.INVALID_PDU_SDU_ID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>35</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>196</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_01091_TrigTx_PduIdInvalid</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_01_DetCalls/source/application/EbTest.c</sourcefile>
      <sourceline>1058</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that error is reported in development mode when LdCom_TriggerTransmit
  is called with parameter TxPduId not between 0 (zero) and number of Tx paths configured.

  This test verifies that an error is returned by the API when LdCom_TriggerTransmit
  is called with parameter TxPduId not between 0 (zero) and number of Tx paths configured.
&lt;/para&gt;

Test Object: 
  LdCom_TriggerTransmit

Test Precondition: 
  LdCom module has been initialized.

Test Execution: 
  01: call LdCom_TriggerTransmit with maximum allowed Tx PDU-ID increased by one and valid pointer
      to PduInfo.
  02: VP (LdCom.SWS_LdCom_00018.INVALID_PDU_SDU_ID): Det is called with error code
      LDCOM_E_INVALID_PDU_SDU_ID.
  03: VP (LdCom.EB.SWS_LdCom_00019): Error is returned with E_NOT_OK.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00018.INVALID_PDU_SDU_ID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>35</internalId></provcov>
        <provcov>
          <linksto>LdCom.EB.SWS_LdCom_00019</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>197</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_01092_TxConf_PduIdInvalid</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_01_DetCalls/source/application/EbTest.c</sourcefile>
      <sourceline>1109</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Check if an error is reported in development mode when LdCom_TxConfirmation is called
  with parameter TxPduId not between 0 (zero) and number of Tx paths configured.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  LdCom module has been initialized

Test Execution: 
  01: call LdCom_TxConfirmation with maximum allowed Tx PDU-ID increased by one.
  02: VP: Det is called with error code LDCOM_E_INVALID_PDU_SDU_ID.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00018.INVALID_PDU_SDU_ID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>35</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>198</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_01100_StartOfReception_PduIdInvalid</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_01_DetCalls/source/application/EbTest.c</sourcefile>
      <sourceline>1145</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that an error is reported in development mode when LdCom_StartOfReception
  is called with parameter RxPduId not between 0 (zero) and number of Rx paths configured.

  This test verifies that an error is returned by the API when LdCom_StartOfReception
  is called with parameter RxPduId not between 0 (zero) and number of Rx paths configured.
&lt;/para&gt;

Test Object: 
  LdCom_StartOfReception()

Test Precondition: 
  LdCom module has been initialized.

Test Execution: 
  01: call LdCom_StartOfReception with maximum allowed RxPduId increased by one,
      valid TpSduLength and valid pointer to buffer size.
  02: VP (LdCom.SWS_LdCom_00018.INVALID_PDU_SDU_ID): Det is called with error code
      LDCOM_E_INVALID_PDU_SDU_ID.
  03: VP (LdCom.EB.SWS_LdCom_00019): Error is returned with BUFREQ_E_NOT_OK.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00018.INVALID_PDU_SDU_ID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>35</internalId></provcov>
        <provcov>
          <linksto>LdCom.EB.SWS_LdCom_00019</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>199</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_01101_CopyRxData_PduIdInvalid</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_01_DetCalls/source/application/EbTest.c</sourcefile>
      <sourceline>1198</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that an error is reported in development mode when LdCom_CopyRxData
  is called with parameter RxPduId not between 0 (zero) and number of Rx paths configured.

  This test verifies that an error is returned by the API when LdCom_CopyRxData
  is called with parameter RxPduId not between 0 (zero) and number of Rx paths configured.
&lt;/para&gt;

Test Object: 
  LdCom_CopyRxData()

Test Precondition: 
  LdCom module has been initialized.

Test Execution: 
  01: call LdCom_CopyRxData with maximum allowed RxPduId increased by one,
      valid pointer to PduInfo and valid pointer to buffer size.
  02: VP (LdCom.SWS_LdCom_00018.INVALID_PDU_SDU_ID): Det is called with error code
      LDCOM_E_INVALID_PDU_SDU_ID.
  03: VP (LdCom.EB.SWS_LdCom_00019): Error is returned with BUFREQ_E_NOT_OK.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00018.INVALID_PDU_SDU_ID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>35</internalId></provcov>
        <provcov>
          <linksto>LdCom.EB.SWS_LdCom_00019</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>200</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_01102_TpRxInd_PduIdInvalid</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_01_DetCalls/source/application/EbTest.c</sourcefile>
      <sourceline>1250</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Check if an error is reported in development mode when LdCom_TpRxIndication is called
  with parameter RxPduId not between 0 (zero) and number of Rx paths configured.
&lt;/para&gt;

Test Object: 
  LdCom_TpRxIndication()

Test Precondition: 
  LdCom module has been initialized.

Test Execution: 
  01: call LdCom_TpRxIndication with maximum allowed RxPduId increased by one and valid value for Result.
  02: VP (LdCom.SWS_LdCom_00018.INVALID_PDU_SDU_ID): Det is called with error
      code LDCOM_E_INVALID_PDU_SDU_ID.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00018.INVALID_PDU_SDU_ID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>35</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>201</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_01110_CopyTxData_PduIdInvalid</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_01_DetCalls/source/application/EbTest.c</sourcefile>
      <sourceline>1289</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that an error is reported in development mode when LdCom_CopyTxData
  is called with parameter TxPduId not between 0 (zero) and number of Rx paths configured.

  This test verifies that an error is returned by the API when LdCom_CopyTxData
  is called with parameter TxPduId not between 0 (zero) and number of Rx paths configured.
&lt;/para&gt;

Test Object: 
  LdCom_CopyTxData

Test Precondition: 
  LdCom module has been initialized.

Test Execution: 
  01: call LdCom_CopyTxData with maximum allowed Tx PDU-ID increased by one,
      valid pointer to PduInfoPtr, valid pointer to RetryInfo and valid pointer to AvailableData.
  02: VP (LdCom.SWS_LdCom_00018.INVALID_PDU_SDU_ID): Det is called with error code
      LDCOM_E_INVALID_PDU_SDU_ID.
  03: VP (LdCom.EB.SWS_LdCom_00019): Error is returned with BUFREQ_E_NOT_OK.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00018.INVALID_PDU_SDU_ID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>35</internalId></provcov>
        <provcov>
          <linksto>LdCom.EB.SWS_LdCom_00019</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>202</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_01111_TpTxConf_PduIdInvalid</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_01_DetCalls/source/application/EbTest.c</sourcefile>
      <sourceline>1342</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Check if an error is reported in development mode when LdCom_TpTxConfirmation is called
  with parameter TxPduId not between 0 (zero) and number of Tx paths configured.
&lt;/para&gt;

Test Object: 
  LdCom_TpTxConfirmation

Test Precondition: 
  LdCom module has been initialized.

Test Execution: 
  01: call LdCom_TpTxConfirmation with maximum allowed Tx PDU-ID increased by one and valid Result.
  02: VP (LdCom.SWS_LdCom_00018.INVALID_PDU_SDU_ID): Det is called with error code
      LDCOM_E_INVALID_PDU_SDU_ID.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00018.INVALID_PDU_SDU_ID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>35</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>203</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_01120_Transmit_PduIdInvalid</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_01_DetCalls/source/application/EbTest.c</sourcefile>
      <sourceline>1381</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that an error is reported in development mode when LdCom_Transmit
  is called with parameter TxPduId not between 0 (zero) and number of Tx paths configured.

  This test verifies that an error is returned by the API  when LdCom_Transmit
  is called with parameter TxPduId not between 0 (zero) and number of Tx paths configured.
&lt;/para&gt;

Test Object: 
  LdCom_Transmit()

Test Precondition: 
  LdCom module has been initialized.

Test Execution: 
  01: call LdCom_Transmit with maximum allowed TxPduId increased by one and valid pointer to PduInfo.
  02: VP (LdCom.SWS_LdCom_00018.INVALID_PDU_SDU_ID): Det is called with error code
      LDCOM_E_INVALID_PDU_SDU_ID.
  03: VP (LdCom.EB.SWS_LdCom_00019): Error is returned with E_NOT_OK.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00018.INVALID_PDU_SDU_ID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>35</internalId></provcov>
        <provcov>
          <linksto>LdCom.EB.SWS_LdCom_00019</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>204</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_01131_StateType</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_01_DetCalls/source/application/EbTest.c</sourcefile>
      <sourceline>1438</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Verify if LdCom_StateType is defined and allows values LDCOM_UNINIT and LDCOM_ONLINE.
&lt;/para&gt;

Test Object: None.
Test Precondition: None.
Test Execution: 
  01: VP: Macros for LDCOM_UNINIT and LDCOM_ONLINE are defined.
  02: VP: LdCom_StateType is defined.
  03: VP: LDCOM_UNINIT holds value '0'.
  04: VP: LDCOM_ONLINE holds value '1'.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.EB.InitializationState_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>90</internalId></provcov>
        <provcov>
          <linksto>LdCom.EB.InitializationState_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>91</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>205</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_01132_NoCustomHeaderFile</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_01_DetCalls/source/application/EbTest.c</sourcefile>
      <sourceline>1485</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that Rte_Cbk.h is included in LdCom_Lcfg.c, when no header file is configured
  in list LdComUpperLayerHeaderFile.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  No custom header file is configured in LdComUpperLayerHeaderFile.

Test Execution: 
  01: VP: LdCom_Lcfg.c compiles only if Rte_Cbk.h is included

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.EB.CustomHeaderFiles.Includes</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>206</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_01133_StartOfReception_PduInfoPtrNull</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_01_DetCalls/source/application/EbTest.c</sourcefile>
      <sourceline>1516</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that an error is not reported in development mode when LdCom_StartOfReception
  is called with PduInfoPtr equal to NULL.

  This test verifies that BUFREQ_OK is returned by the API when LdCom_StartOfReception
  is called with parameter pointer to PduInfo equal to NULL.
&lt;/para&gt;

Test Object: 
  LdCom_StartOfReception()

Test Precondition: 
  LdCom module has been initialized.

Test Execution: 
  01: Call LdCom_StartOfReception with valid  buffer size, valid TpSduLength but
      PduInfoPtr set to NULL.
  02: VP: Rte_LdComCbkStartOfReception is called for the correct signal with
      the same TpSduLength.
  03: It is returned with BUFREQ_OK.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00029</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>51</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>207</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_LDCOM_CON_02001_RxInd_InvokeUp</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_02_ApiCalls/source/application/EbTest.c</sourcefile>
      <sourceline>123</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that Rte_LdComCbkRxIndication (function name given by parameter
  LdComRxIndication) has been invoked when LdCom_RxIndication was called.

  This test verifies that the call of Rte_LdComCbkRxIndication is based on
  the PDU-ID calling LdCom_RxIndication.

  This test verifies that the I-PDU is not modified.

  This test verifies that the module supports the PduLengthType uint16 and uint32.
  This is done inherently in showing no compiler warning/error for incompatible length handling
  (neither by internal handling of the PduInfoPtr nor by passing the parameter).

  Permutation:     LdComDevErrorDetect    PduLengthTypeEnum
  p0               false                  UINT32
  p1               true                   UINT16
&lt;/para&gt;

Test Object: 
  LdCom_RxIndication()

Test Precondition: 
  LdCom is not initialized.

Test Execution: 
  00: Initialize LdCom via PbcfgM for the complete test sequence first.
  01: call LdCom_RxIndication with valid RxPduId and valid pointer to initialized PduInfo.
  02: VP: Rte_LdComCbkRxIndication is called for correct signal and with valid pointer to
      the same PduInfo.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.EB.PDULENGTHTYPE001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>126</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>5</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00014.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>21</internalId></provcov>
        <provcov>
          <linksto>LdCom.ECUC_LdCom_00014</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>79</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>208</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_CON_02002_TrigTx_InvokeUp</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_02_ApiCalls/source/application/EbTest.c</sourcefile>
      <sourceline>203</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that Rte_LdComCbkTriggerTransmit (function name given by parameter
  LdComTxTriggerTransmit) has been invoked when LdCom_TriggerTransmit was called.

  This test verifies that the call of Rte_LdComCbkTriggerTransmit is based on
  the PDU-ID calling LdCom_TriggerTransmit.

  This test verifies that the return value is passed to the PduR.

  This test verifies that the I-PDU is not modified.

  This test verifies that the module supports the PduLengthType uint16 and uint32.
  This is done inherently in showing no compiler warning/error for incompatible length handling
  (neither by internal handling of the PduInfoPtr nor by passing the parameter).

  Permutation:     LdComDevErrorDetect    PduLengthTypeEnum
  p0               false                  UINT32
  p1               true                   UINT16
&lt;/para&gt;

Test Object: 
  LdCom_TriggerTransmit

Test Precondition: 
  LdCom has been initialized.

Test Execution: 
  01: call LdCom_TriggerTransmit with valid TxPduId and valid pointer to PduInfo.
  02: VP: Rte_LdComCbkTriggerTransmit is called for correct signal.
  03: VP: Rte_LdComCbkTriggerTransmit passed &amp;EbTest_PduInfo to Rte_LdComCbkTriggerTransmit_IfTxSignal0_Stub.
  04: VP: Rte_LdComCbkTriggerTransmit passed return value to PduR.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.EB.PDULENGTHTYPE001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>126</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>5</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00011.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>9</internalId></provcov>
        <provcov>
          <linksto>LdCom.EB.SWS_LdCom_00019</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
        <provcov>
          <linksto>LdCom.ECUC_LdCom_00019</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>85</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>209</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_CON_02007_TrigTx_InvokeUp_Data</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_02_ApiCalls/source/application/EbTest.c</sourcefile>
      <sourceline>283</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that Rte_LdComCbkTriggerTransmit has been invoked when
  LdCom_TriggerTransmit was called.

  This test verifies that the call of Rte_LdComCbkTriggerTransmit is based on
  the PDU-ID calling LdCom_TriggerTransmit.

  This test verifies that the return value is passed to the PduR.

  This test verifies that the I-PDU _is_ modified by the filldata callout
  and checks that the data isn't tampered with.

  This test verifies that the module supports the PduLengthType uint16 and uint32.
  This is done inherently in showing no compiler warning/error for incompatible length handling
  (neither by internal handling of the PduInfoPtr nor by passing the parameter).

  Permutation:     LdComDevErrorDetect    PduLengthTypeEnum
  p0               false                  UINT32
  p1               true                   UINT16
&lt;/para&gt;

Test Object: 
  LdCom_TriggerTransmit

Test Precondition: 
  LdCom has been initialized.

Test Execution: 
  01: call LdCom_TriggerTransmit with valid TxPduId and valid pointer to PduInfo.
  02: VP: Rte_LdComCbkTriggerTransmit is called for correct signal.
  03: VP: Rte_LdComCbkTriggerTransmit passed &amp;EbTest_PduInfo to
          Rte_LdComCbkTriggerTransmit_IfTxSignal0_Stub.
  04: VP: Rte_LdComCbkTriggerTransmit passed return value to PduR.
  05: VP: Rte_LdComCbkTriggerTransmit passed changed data buffer length
  06: VP: Rte_LdComCbkTriggerTransmit passed changed data buffer content

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.EB.PDULENGTHTYPE001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>126</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>5</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00011.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>9</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>210</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_CON_02003_TxConf_InvokeUp</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_02_ApiCalls/source/application/EbTest.c</sourcefile>
      <sourceline>403</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that Rte_LdComCbkTxConfirmationCbk (function name given by parameter
  LdComTxConfirmation) has been invoked when LdCom_TxConfirmation was called.

  This test verifies that the call of Rte_LdComCbkTxConfirmationCbk is based on
  the PDU-ID calling LdCom_TxConfirmation.

  Permutation:     LdComDevErrorDetect
  p0               false
  p1               true
&lt;/para&gt;

Test Object: 
  LdCom_TxConfirmation

Test Precondition: 
  The LdCom has been initialized.

Test Execution: 
  01: call LdCom_TxConfirmation with valid TxPduId.
  02: VP: Rte_LdComCbkTxConfirmationCbk is called for correct signal.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>5</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00046.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>12</internalId></provcov>
        <provcov>
          <linksto>LdCom.ECUC_LdCom_00021</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>83</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>211</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_CON_02004_RxInd_InvokeUp_Dummy</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_02_ApiCalls/source/application/EbTest.c</sourcefile>
      <sourceline>458</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that LdCom_DummyCbkRxIndication - Callback has been invoked when
  parameter LdComRxIndication has the LdCom_DummyCbkRxIndication - Callback (see p0)
  configured and LdCom_RxIndication was called.

  This test also verifies that LdCom_DummyCbkRxIndication - Callback has been invoked
  as default value when parameter LdComRxIndication has no - Callback (see p1) configured and
  LdCom_RxIndication was called.

  This test verifies that the module supports the PduLengthType uint16 and uint32.
  This is done inherently in showing no compiler warning/error for incompatible length handling
  (neither by internal handling of the PduInfoPtr nor by passing the parameter).

  Permutation:     LdComDevErrorDetect    PduLengthTypeEnum   LdComRxIndication
  p0               false                  UINT32              LdCom_DummyCbkRxIndication
  p1               true                   UINT16              empty
&lt;/para&gt;

Test Object: 
  LdCom_RxIndication()

Test Precondition: 
  LdCom is not initialized.
  LdCom_DummyCbkRxIndication is configured for LdComRxIndication.

Test Execution: 
  00: Initialize LdCom via PbcfgM for the complete test sequence first.
  01: call LdCom_RxIndication with valid RxPduId and valid pointer to initialized PduInfo.
  02: VP: LdCom_DummyCbkRxIndication is called.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.EB.PDULENGTHTYPE001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>126</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00014.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>22</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>212</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_CON_02005_TrigTx_InvokeUp_Dummy</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_02_ApiCalls/source/application/EbTest.c</sourcefile>
      <sourceline>525</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that LdCom_DummyCbkTriggerTransmit - Callback has been invoked when
  parameter LdComTriggerTransmit has the LdCom_DummyCbkTriggerTransmit - Callback configured and
  LdCom_TriggerTransmit was called.

  This test also verifies that LdCom_DummyCbkTriggerTransmit - Callback has been invoked as
  default value when parameter LdComTriggerTransmit has no - Callback (see p1) configured and
  LdCom_TriggerTransmit was called.

  This test verifies that the return value E_NOT_OK is passed to the PduR.

  This test verifies that the module supports the PduLengthType uint16 and uint32.
  This is done inherently in showing no compiler warning/error for incompatible length handling
  (neither by internal handling of the PduInfoPtr nor by passing the parameter).

  Permutation:     LdComDevErrorDetect    PduLengthTypeEnum   LdComTriggerTransmit
  p0               false                  UINT32              LdCom_DummyCbkTriggerTransmit
  p1               true                   UINT16              empty
&lt;/para&gt;

Test Object: 
  LdCom_TriggerTransmit

Test Precondition: 
  LdCom has been initialized.
  LdCom_DummyCbkTriggerTransmit is configured for LdComTriggerTransmit.

Test Execution: 
  01: call LdCom_TriggerTransmit with valid TxPduId and valid pointer to PduInfo.
  02: VP: LdCom_DummyCbkTriggerTransmit is called.
  03: VP: LdCom_DummyCbkTriggerTransmit passed return value E_NOT_OK to PduR.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.EB.PDULENGTHTYPE001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>126</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00011.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>10</internalId></provcov>
        <provcov>
          <linksto>LdCom.EB.SWS_LdCom_00042_DummyCbk</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>99</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>213</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_CON_02006_TxConf_InvokeUp_Dummy</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_02_ApiCalls/source/application/EbTest.c</sourcefile>
      <sourceline>602</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that LdCom_DummyCbkTxConfirmation - Callback has been invoked when
  parameter LdComTxConfirmation has the LdCom_DummyCbkTxConfirmation - Callback configured and
  LdCom_TxConfirmation was called.

  This test also verifies that LdCom_DummyCbkTxConfirmation - Callback has been invoked as
  default value when parameter LdComTxConfirmation has no - Callback (see p1) configured and
  LdCom_TxConfirmation was called.

  Permutation:     LdComDevErrorDetect    LdComTxConfirmation
  p0               false                  LdCom_DummyCbkTxConfirmation
  p1               true                   empty
&lt;/para&gt;

Test Object: 
  LdCom_TxConfirmation

Test Precondition: 
  The LdCom has been initialized.
  LdCom_DummyCbkTxConfirmation is configured for LdComTxConfirmation.

Test Execution: 
  01: call LdCom_TxConfirmation with valid TxPduId.
  02: VP: LdCom_DummyCbkTxConfirmation is called.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00046.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>13</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>214</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_CON_02010_StartOfReception_InvokeUp</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_02_ApiCalls/source/application/EbTest.c</sourcefile>
      <sourceline>658</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that Rte_LdComCbkStartOfReception (function name given by parameter
  LdComRxStartOfReception) has been invoked when LdCom_StartOfReception was called.

  This test verifies that the call of Rte_LdComCbkStartOfReception is based on
  the PDU-ID calling LdCom_StartOfReception.

  This test verifies that the return value is passed to the PduR.

  Permutation:     LdComDevErrorDetect
  p0               false
  p1               true
&lt;/para&gt;

Test Object: 
  LdCom_StartOfReception()

Test Precondition: 
  LdCom has been initialized.

Test Execution: 
  01: call LdCom_StartOfReception with valid signal_ID, valid TpSduLength and valid pointer to buffer size.
  02: VP: Rte_LdComCbkStartOfReception is called for the correct signal with
      the same TpSduLength and initialized buffer size value passed to PduR.
  03: VP: Rte_LdComCbkStartOfReception passed return value to PduR.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>5</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00015.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>24</internalId></provcov>
        <provcov>
          <linksto>LdCom.EB.SWS_LdCom_00019</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
        <provcov>
          <linksto>LdCom.ECUC_LdCom_00015</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>80</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>215</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_CON_02011_CopyRxData_InvokeUp</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_02_ApiCalls/source/application/EbTest.c</sourcefile>
      <sourceline>734</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that Rte_LdComCbkCopyRxData has been invoked when
  LdCom_CopyRxData was called.

  This test verifies that Rte_LdComCbkCopyRxData (function name given by parameter
  LdComRxCopyRxData) has been invoked when LdCom_CopyRxData was called.

  This test verifies that the return value is passed to the PduR.

  This test verifies that the I-PDU is transferred without modification from the source module
  to the destination module.

  This test verifies that the module supports the PduLengthType uint16 and uint32.
  This is done inherently in showing no compiler warning/error for incompatible length handling
  (neither by internal handling of the PduInfoPtr nor by passing the parameter).

  Permutation:     LdComDevErrorDetect    PduLengthTypeEnum
  p0               false                  UINT32
  p1               true                   UINT16
&lt;/para&gt;

Test Object: 
  LdCom_CopyRxData()

Test Precondition: 
  LdCom has been initialized.

Test Execution: 
  01: call LdCom_CopyRxData with valid RxPduId, valid pointer to PduInfo and valid pointer to
      buffer size.
  02: VP: Rte_LdComCbkCopyRxData is called for correct signal with
      the same PduInfo and initialized buffer size value passed to PduR.
  03: VP: Rte_LdComCbkCopyRxData passed return value to PduR.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.EB.PDULENGTHTYPE001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>126</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>5</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00016.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>27</internalId></provcov>
        <provcov>
          <linksto>LdCom.EB.SWS_LdCom_00019</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
        <provcov>
          <linksto>LdCom.ECUC_LdCom_00013</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>78</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>216</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_CON_02012_TpRxInd_InvokeUp</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_02_ApiCalls/source/application/EbTest.c</sourcefile>
      <sourceline>822</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that Rte_LdComCbkTpRxIndication (function name given by parameter
  LdComTpRxIndication) has been invoked when LdCom_TpRxIndication was called.

  This test verifies that the call of Rte_LdComCbkTpRxIndication is based on
  the PDU-ID calling LdCom_TpRxIndication.

  Permutation:     LdComDevErrorDetect
  p0               false
  p1               true
&lt;/para&gt;

Test Object: 
  LdCom_TpRxIndication()

Test Precondition: 
  LdCom has been initialized.

Test Execution: 
  01: call LdCom_TpRxIndication with valid RxPduId and valid Result.
  02: VP: Rte_LdComCbkTpRxIndication is called for correct signal with
      the same Result.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>5</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00017.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>30</internalId></provcov>
        <provcov>
          <linksto>LdCom.ECUC_LdCom_00016</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>81</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>217</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_CON_02013_CopyTxData_InvokeUp</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_02_ApiCalls/source/application/EbTest.c</sourcefile>
      <sourceline>879</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that Rte_LdComCbkCopyTxData (function name given by parameter
  LdComTxCopyTxData)has been invoked when LdCom_CopyTxData was called.

  This test verifies that the call of Rte_LdComCbkCopyTxData is based on
  the PDU-ID calling LdCom_CopyTxData.

  This test verifies that the return value is passed to the PduR.

  Verify that the I-PDU is transferred without modification from the source module
  to the destination module for this part of a single cast transmission.

  This test verifies that the module supports the PduLengthType uint16 and uint32.
  This is done inherently in showing no compiler warning/error for incompatible length handling
  (neither by internal handling of the PduInfoPtr nor by passing the parameter).

  Permutation:     LdComDevErrorDetect    PduLengthTypeEnum
  p0               false                  UINT32
  p1               true                   UINT16
&lt;/para&gt;

Test Object: 
  LdCom_CopyTxData

Test Precondition: 
  LdCom has been initialized.

Test Execution: 
  01: call LdCom_CopyTxData with valid TxPduId, valid pointer to PduInfo, valid pointer to
      RetryInfo and valid pointer to AvailableData.
  02: VP: Rte_LdComCbkCopyTxData is called for correct signal, the same RetryInfo, the
      same unmodified PduInfo and the initialized AvailableData passed to PduR.
  03: VP: Rte_LdComCbkCopyTxData passed return value to PduR.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.EB.PDULENGTHTYPE001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>126</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>5</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00013.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>16</internalId></provcov>
        <provcov>
          <linksto>LdCom.EB.SWS_LdCom_00019</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
        <provcov>
          <linksto>LdCom.ECUC_LdCom_00018</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>84</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>218</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_CON_02014_TpTxConf_InvokeUp</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_02_ApiCalls/source/application/EbTest.c</sourcefile>
      <sourceline>967</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that Rte_LdComCbkTpTxConfirmation (function name given by parameter
  LdComTpTxConfirmation) has been invoked when LdCom_TpTxConfirmation was called.

  This test verifies that the call of Rte_LdComCbkTpTxConfirmation is based on
  the PDU-ID calling LdCom_TpTxConfirmation.

  Permutation:     LdComDevErrorDetect
  p0               false
  p1               true
&lt;/para&gt;

Test Object: 
  LdCom_TxConfirmation

Test Precondition: 
  LdCom has been initialized.

Test Execution: 
  01: call LdCom_TxConfirmation with valid TxPduId and valid Result.
  02: VP: Rte_LdComCbkTpTxConfirmation is called for correct signal and the Result value
      passed through.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>5</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00013.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>18</internalId></provcov>
        <provcov>
          <linksto>LdCom.ECUC_LdCom_00017</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>82</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>219</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_CON_02015_StartOfReception_InvokeUp_Dummy</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_02_ApiCalls/source/application/EbTest.c</sourcefile>
      <sourceline>1024</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that LdCom_DummyCbkStartOfReception - Callback has been invoked when
  parameter LdComStartOfReception has the LdCom_DummyCbkStartOfReception - Callback configured and
  LdCom_StartOfReception was called.

  This test also verifies that LdCom_DummyCbkStartOfReception - Callback has been invoked as
  default value when parameter LdComStartOfReception has no - Callback (see p1) configured and
  LdCom_StartOfReception was called.

  This test verifies that the return value BUFREQ_E_NOT_OK is passed to the PduR.

  Permutation:     LdComDevErrorDetect    LdComStartOfReception
  p0               false                  LdCom_DummyCbkStartOfReception
  p1               true                   empty
&lt;/para&gt;

Test Object: 
  LdCom_StartOfReception()

Test Precondition: 
  LdCom has been initialized.
  LdCom_DummyCbkStartOfReception is configured for LdComStartOfReception.

Test Execution: 
  01: call LdCom_StartOfReception with valid signal_ID (but no callback defined),
      valid TpSduLength and valid pointer to buffer size.
  02: VP: LdCom_DummyCbkStartOfReception is called.
  03: VP: LdCom_DummyCbkStartOfReception passed return value BUFREQ_E_NOT_OK to PduR.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00015.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>25</internalId></provcov>
        <provcov>
          <linksto>LdCom.EB.SWS_LdCom_00038_DummyCbk</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>93</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>220</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_CON_02016_CopyRxData_InvokeUp_Dummy</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_02_ApiCalls/source/application/EbTest.c</sourcefile>
      <sourceline>1092</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that LdCom_DummyCbkCopyRxData - Callback has been invoked when
  parameter LdComCopyRxData has the LdCom_DummyCbkCopyRxData - Callback configured and
  LdCom_CopyRxData was called.

  This test also verifies that LdCom_DummyCbkCopyRxData - Callback has been invoked as
  default value when parameter LdComCopyRxData has no - Callback (see p1) configured and
  LdCom_CopyRxData was called.

  This test verifies that the return value BUFREQ_E_NOT_OK is passed to the PduR.

  This test verifies that the module supports the PduLengthType uint16 and uint32.
  This is done inherently in showing no compiler warning/error for incompatible length handling
  (neither by internal handling of the PduInfoPtr nor by passing the parameter).

  Permutation:     LdComDevErrorDetect    PduLengthTypeEnum   LdComCopyRxData
  p0               false                  UINT32              LdCom_DummyCbkCopyRxData
  p1               true                   UINT16              empty
&lt;/para&gt;

Test Object: 
  LdCom_CopyRxData()

Test Precondition: 
  LdCom has been initialized.
  LdCom_DummyCbkCopyRxData is configured for LdComCopyRxData.

Test Execution: 
  01: call LdCom_CopyRxData with valid RxPduId, valid pointer to PduInfo and valid pointer to
      buffer size.
  02: VP: LdCom_DummyCbkCopyRxData is called.
  03: VP: LdCom_DummyCbkCopyRxData passed return value BUFREQ_E_NOT_OK to PduR.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.EB.PDULENGTHTYPE001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>126</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00016.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>28</internalId></provcov>
        <provcov>
          <linksto>LdCom.EB.SWS_LdCom_00039_DummyCbk</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>94</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>221</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_CON_02017_TpRxInd_InvokeUp_Dummy</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_02_ApiCalls/source/application/EbTest.c</sourcefile>
      <sourceline>1169</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that LdCom_DummyCbkTpRxIndication - Callback has been invoked when
  parameter LdComTpRxIndication has the LdCom_DummyCbkTpRxIndication - Callback configured and
  LdCom_TpRxIndication was called.

  This test also verifies that LdCom_DummyCbkTpRxIndication - Callback has been invoked as
  default value when parameter LdComTpRxIndication has no - Callback (see p1) configured and
  LdCom_TpRxIndication was called.

  Permutation:     LdComDevErrorDetect    LdComTpRxIndication
  p0               false                  LdCom_DummyCbkTpRxIndication
  p1               true                   empty
&lt;/para&gt;

Test Object: 
  LdCom_TpRxIndication()

Test Precondition: 
  LdCom has been initialized.
  LdCom_DummyCbkTpRxIndication is configured for LdComTpRxIndication.

Test Execution: 
  01: call LdCom_TpRxIndication with valid RxPduId and valid Result.
  02: VP: LdCom_DummyCbkTpRxIndication is called.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00017.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>31</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>222</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_CON_02018_CopyTxData_InvokeUp_Dummy</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_02_ApiCalls/source/application/EbTest.c</sourcefile>
      <sourceline>1225</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that LdCom_DummyCbkCopyTxData - Callback has been invoked when
  parameter LdComCopyTxData has the LdCom_DummyCbkCopyTxData - Callback configured and
  LdCom_CopyTxData was called.

  This test also verifies that LdCom_DummyCbkCopyTxData - Callback has been invoked as
  default value when parameter LdComCopyTxData has no - Callback (see p1) configured and
  LdCom_CopyTxData was called.

  This test verifies that the return value BUFREQ_E_NOT_OK is passed to the PduR.

  This test verifies that the module supports the PduLengthType uint16 and uint32.
  This is done inherently in showing no compiler warning/error for incompatible length handling
  (neither by internal handling of the PduInfoPtr nor by passing the parameter).

  Permutation:     LdComDevErrorDetect    PduLengthTypeEnum   LdComCopyTxData
  p0               false                  UINT32              LdCom_DummyCbkCopyTxData
  p1               true                   UINT16              empty
&lt;/para&gt;

Test Object: 
  LdCom_CopyTxData

Test Precondition: 
  LdCom has been initialized.
  LdCom_DummyCbkCopyTxData is configured for LdComCopyTxData.

Test Execution: 
  01: call LdCom_CopyTxData with valid TxPduId, valid pointer to PduInfo, valid pointer to
      RetryInfo and valid pointer to AvailableData.
  02: VP: LdCom_DummyCbkCopyTxData is called.
  03: VP: LdCom_DummyCbkCopyTxData passed return value BUFREQ_E_NOT_OK to PduR.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.EB.PDULENGTHTYPE001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>126</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00013.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>17</internalId></provcov>
        <provcov>
          <linksto>LdCom.EB.SWS_LdCom_00036_DummyCbk</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>96</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>223</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_CON_02019_TpTxConf_InvokeUp_Dummy</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_02_ApiCalls/source/application/EbTest.c</sourcefile>
      <sourceline>1301</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that LdCom_DummyCbkTpTxConfirmation - Callback has been invoked when
  parameter LdComTpTxConfirmation has the LdCom_DummyCbkTpTxConfirmation - Callback configured and
  LdCom_TpTxConfirmation was called.

  This test also verifies that LdCom_DummyCbkTpTxConfirmation - Callback has been invoked as
  default value when parameter LdComTpTxConfirmation has no - Callback (see p1) configured and
  LdCom_TpTxConfirmation was called.

  Permutation:     LdComDevErrorDetect    LdComTpTxConfirmation
  p0               false                  LdCom_DummyCbkTpTxConfirmation
  p1               true                   empty
&lt;/para&gt;

Test Object: 
  LdCom_TpTxConfirmation

Test Precondition: 
  LdCom has been initialized.
  LdCom_DummyCbkTpTxConfirmation is configured for LdComTpTxConfirmation.

Test Execution: 
  01: call LdCom_TxConfirmation with valid TxPduId and valid Result.
  02: VP: LdCom_DummyCbkTpTxConfirmation is called.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00013.4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>19</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>224</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_CON_02020_Transmit_InvokeLoTp</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_02_ApiCalls/source/application/EbTest.c</sourcefile>
      <sourceline>1356</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that PduR_LdComTransmit has been invoked when
  LdCom_Transmit was called.

  This test verifies that the called LdComHandleId of PduR_LdComTransmit
  is converted to the referenced PduRSourcePduHandleId calling PduR_LdComTransmit for TP-PDU.

  This test verifies that the return value is passed to the Rte.

  This test verifies that the I-PDU is not modified.

  This test verifies that the module supports the PduLengthType uint16 and uint32.
  This is done inherently in showing no compiler warning/error for incompatible length handling
  (neither by internal handling of the PduInfoPtr nor by passing the parameter).

  Permutation:     LdComDevErrorDetect    PduLengthTypeEnum
  p0               false                  UINT32
  p1               true                   UINT16
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  The LdCom has been initialized

Test Execution: 
  01: Call LdCom_Transmit() with valid TxPduId and valid PduInfo.
  02: VP: PduR_LdComTransmit() is called with converted TxPduId and
          the same pointer to PduInfo.
  03: VP: Return value of PduR_LdComTransmit is passed to Rte.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.EB.PDULENGTHTYPE001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>126</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00009</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>6</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00010</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>7</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00012</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>14</internalId></provcov>
        <provcov>
          <linksto>LdCom.EB.SWS_LdCom_00019</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>225</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_CON_02021_Transmit_InvokeLoIf</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_02_ApiCalls/source/application/EbTest.c</sourcefile>
      <sourceline>1436</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that PduR_LdComTransmit has been invoked when
  LdCom_Transmit was called.

  This test verifies that the called LdComHandleId of PduR_LdComTransmit
  is converted to the referenced PduRSourcePduHandleId calling PduR_LdComTransmit for non TP-PDU.

  This test verifies that the return value is passed to the Rte.

  This test verifies that the I-PDU is not modified.

  This test verifies that the module supports the PduLengthType uint16 and uint32.
  This is done inherently in showing no compiler warning/error for incompatible length handling
  (neither by internal handling of the PduInfoPtr nor by passing the parameter).

  Permutation:     LdComDevErrorDetect    PduLengthTypeEnum
  p0               false                  UINT32
  p1               true                   UINT16
&lt;/para&gt;

Test Object: 
  LdCom_Transmit()

Test Precondition: 
  The LdCom has been initialized.

Test Execution: 
  01: Call LdCom_Transmit() with valid TxPduId and valid PduInfo.
  02: VP: PduR_LdComTransmit() is called with converted TxPduId and
          the same pointer to PduInfo.
  03: VP: Return value of PduR_LdComTransmit is passed to Rte.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.EB.PDULENGTHTYPE001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>126</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00009</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>6</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00010</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>7</internalId></provcov>
        <provcov>
          <linksto>LdCom.EB.SWS_LdCom_00019</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>226</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_CON_02030_GetVersionInfo</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_02_ApiCalls/source/application/EbTest.c</sourcefile>
      <sourceline>1525</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that the function LdCom_GetVersionInfo returns the version information
  of this module in the passed argument *versionInfo.
  The version information includes: Module Id, Vendor Id, Vendor specific version numbers.

  Permutation:     LdComDevErrorDetect
  p0               false
  p1               true
&lt;/para&gt;

Test Object: None.
Test Precondition: 
 - LdComDevErrorDetect is disabled
 - LdComVersionInfoApi is enabled
 - Macros LDCOM_VENDOR_ID,.. are defined properly
   (see test case TS_LDCOM_CON_02031_PublishedInformation below)

Test Execution: 
  1: LdCom_GetVersionInfo() is called with valid versionInfo pointer
  2: VP:
     LDCOM_VENDOR_ID, LDCOM_MODULE_ID, LDCOM_SW_MAJOR_VERSION, LDCOM_SW_MINOR_VERSION and
     LDCOM_SW_PATCH_VERSION are returned by versionInfo.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00024</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>42</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>227</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_CON_02031_PublishedInformation</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_02_ApiCalls/source/application/EbTest.c</sourcefile>
      <sourceline>1581</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test shall check the correct definition of the common published information
  provided in the module header file.
&lt;/para&gt;

Test Object: None.
Test Precondition: None.
Test Execution: None.
Test Input: 
1. macro definition LDCOM_VENDOR_ID
2. macro definition LDCOM_MODULE_ID
3. macro definition LDCOM_AR_RELEASE_MAJOR_VERSION
4. macro definition LDCOM_AR_RELEASE_MINOR_VERSION
5. macro definition LDCOM_AR_RELEASE_REVISION_VERSION
6. macro definition LDCOM_SW_MAJOR_VERSION
7. macro definition LDCOM_SW_MINOR_VERSION
8. macro definition LDCOM_SW_PATCH_VERSION
9. macro definition LDCOM_INSTANCE_ID

Test Output: 
Test Pass Criteria:
1. LDCOM_VENDOR_ID shall be defined
   with the value globally provided by the tooling
   environment
2. LDCOM_MODULE_ID shall be defined with 49
3. LDCOM_AR_RELEASE_MAJOR_VERSION shall be defined
   with the value specified in config.mk
4. LDCOM_AR_RELEASE_MINOR_VERSION shall be defined
   with the value specified in config.mk
5. LDCOM_AR_RELEASE_REVISION_VERSION shall be defined
   with the value specified in config.mk
6. LDCOM_SW_MAJOR_VERSION shall be defined
   with the value specified in config.mk
7. LDCOM_SW_MINOR_VERSION shall be defined
    with the value specified in config.mk
8. LDCOM_SW_PATCH_VERSION shall be defined
    with the value specified in config.mk
9. LDCOM_INSTANCE_ID shall be defined with 0U
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.EB.PublishedInformation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>89</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>228</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_CON_02040_PduLengthType</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_02_ApiCalls/source/application/EbTest.c</sourcefile>
      <sourceline>1689</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that PduLengthType is of configured size (uint16 or uint32).

  Permutation:     PduLengthTypeEnum
  p0               UINT32
  p1               UINT16
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
  01: VP:
     - the size of PduLengthType is 4 with PduLengthTypeEnum set to UINT32
     - the size of PduLengthType is 2 with PduLengthTypeEnum set to UINT16

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.EB.PDULENGTHTYPE001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>126</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>229</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_LDCOM_CON_03001_FileStructure</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_03_FileStructure/source/application/EbTest.c</sourcefile>
      <sourceline>27</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that source file LdCom_Lcfg.c and LdCom_PBcfg.c exists.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  Folder 'reference' provides
    - LdCom_Lcfg.c
    - LdCom_PBcfg.c
  for comparison.

Test Execution: 
  01: VP: LdCom_Lcfg.c and LdCom_PBcfg.c is generated.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LDCOM_00051</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>67</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>230</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_CON_03002_CustomHeaderFiles</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Conformance/IN/LdCom_ConTest_03_FileStructure/source/application/EbTest.c</sourcefile>
      <sourceline>60</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies custom header files are included.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  - Rte_Cbk.h is not configured as custom header file by parameter LdComUpperLayerHeaderFile
  - For sake of simplicity, the Rte_Cbk.h is included by the new custom header file
  - Folder 'reference' provides LdCom_Lcfg.c for comparison

Test Execution: 
  01: VP: LdCom_Lcfg.c includes the header files Rte_Callback1.h and Rte_Callback2.h (not the Rte_Cbk.h file).

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.EB.CustomHeaderFiles.Includes</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>231</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_LDCOM_IMP_01001_Init_State</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Implementation/IN/LdCom_ImpTest_01/source/application/EbTest.c</sourcefile>
      <sourceline>37</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies if internal variables are initialized.

  Note: The only internal variable is LdCom_State.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  LdCom_Init() was not called before

Test Execution: 
  01: VP: Verify that LdCom_State is equal to LDCOM_UNINIT (implicitly)
  02: Call LdCom_Init()
  03: VP: Verify that LdCom_State is equal to LDCOM_ONLINE (implicitly)

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00007</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>3</internalId></provcov>
        <provcov>
          <linksto>LdCom.EB.InitializationState_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>90</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>232</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_IMP_01002_DeInit_State</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Implementation/IN/LdCom_ImpTest_01/source/application/EbTest.c</sourcefile>
      <sourceline>92</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies if internal variables are deinitialized.

  Note: The only internal variable is LdCom_State.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  LdCom_Init() was called before

Test Execution: 
  01: VP: Verify that LdCom_State is equal to LDCOM_ONLINE
  02: Call LdCom_DeInit()
  03: VP: Verify that LdCom_State is equal to LDCOM_UNINIT

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>4</internalId></provcov>
        <provcov>
          <linksto>LdCom.EB.InitializationState_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>91</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>233</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_IMP_01050_PbcfgM_MacroCheck_Reloc_p0</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Implementation/IN/LdCom_ImpTest_01/source/application/EbTest.c</sourcefile>
      <sourceline>145</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that the pre-compile macro LDCOM_RELOCATABLE_CFG_ENABLE is set as described for the
    permutation p0 in the overview below.

    Permutation overview:
    p0: PbcfgMBswModuleRef: no reference to LdCom.
        PbcfgMRelocatableCfgEnable: true
        LdComRelocatablePbcfgEnable: true
        LDCOM_RELOCATABLE_CFG_ENABLE shall follow LdComRelocatablePbcfgEnable (STD_ON).
    p1: PbcfgMBswModuleRef: no reference to LdCom.
        PbcfgMRelocatableCfgEnable: true
        LdComRelocatablePbcfgEnable: false
        LDCOM_RELOCATABLE_CFG_ENABLE shall follow LdComRelocatablePbcfgEnable (STD_OFF).
    p2: PbcfgMBswModuleRef: contains reference to LdCom.
        PbcfgMRelocatableCfgEnable: true
        LdComRelocatablePbcfgEnable: true
        LDCOM_RELOCATABLE_CFG_ENABLE shall follow PbcfgMRelocatableCfgEnable (STD_ON).
    p3: PbcfgMBswModuleRef: contains reference to LdCom.
        PbcfgMRelocatableCfgEnable: false
        LdComRelocatablePbcfgEnable: true
        LDCOM_RELOCATABLE_CFG_ENABLE shall follow PbcfgMRelocatableCfgEnable (STD_OFF).
    p4: PbcfgM is not part of this configuration.
        LdComRelocatablePbcfgEnable: true
        LDCOM_RELOCATABLE_CFG_ENABLE shall follow LdComRelocatablePbcfgEnable (STD_ON).
    p5: PbcfgM is not part of this configuration.
        LdComRelocatablePbcfgEnable: false
        LDCOM_RELOCATABLE_CFG_ENABLE shall follow LdComRelocatablePbcfgEnable (STD_OFF).
  
Test Object: None.
Test Precondition: None.
Test Execution: 
    01: VP: LDCOM_RELOCATABLE_CFG_ENABLE shall have the expected value (see description).
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.EB.Local.PBCFGM108</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>107</internalId></provcov>
        <provcov>
          <linksto>LdCom.EB.RelocatablePBCfg</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>108</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>234</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_IMP_01051_MacroCheck_PbcfgMSupport_p1</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Implementation/IN/LdCom_ImpTest_01/source/application/EbTest.c</sourcefile>
      <sourceline>200</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that the pre-compile macro LDCOM_PBCFGM_SUPPORT_ENABLED is set as described for the
    permutation p1 in the overview below.

    Permutation overview:
    p0: PbcfgMBswModuleRef: contains a reference to LdCom.
        LDCOM_PBCFGM_SUPPORT_ENABLED shall be STD_ON
    p1: PbcfgMBswModuleRef: no reference to LdCom.
        LDCOM_PBCFGM_SUPPORT_ENABLED shall be STD_OFF
    p2: PbcfgM is not part of this configuration.
        LDCOM_PBCFGM_SUPPORT_ENABLED shall be STD_OFF
  
Test Object: None.
Test Precondition: None.
Test Execution: 
    01: VP: LDCOM_PBCFGM_SUPPORT_ENABLED shall have the expected value (see description).
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.EB.Local.PBCFGM107</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>106</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>235</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_LDCOM_IMP_02001_ErrorCodes</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Implementation/IN/LdCom_ImpTest_02/source/application/EbTest.c</sourcefile>
      <sourceline>34</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies if all error codes are defined with correct value.
&lt;/para&gt;

Test Object: None.
Test Precondition: None.
Test Execution: 
  01: VP: The error codes are defined by:
  - LDCOM_E_UNINIT shall be defined with value 0x02.
  - LDCOM_E_PARAM_POINTER shall be defined with value 0x03.
  - LDCOM_E_INVALID_PDU_SDU_ID shall be defined with value 0x04.
  - LDCOM_E_INVALID_SIGNAL_ID shall be defined with value 0x05.
  - LDCOM_E_INIT_FAILED shall be defined with value 0x06.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00018.UNINIT</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>33</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00018.PARAM_POINTER</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>34</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00018.INVALID_PDU_SDU_ID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>35</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00018.INVALID_SIGNAL_ID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>36</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00018.INIT_FAILED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>37</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>236</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_IMP_02002_SID</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Implementation/IN/LdCom_ImpTest_02/source/application/EbTest.c</sourcefile>
      <sourceline>100</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test shall check if all service IDs of the APIs are defined correctly.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
  01: VP: The service IDs are defined by:
  - LDCOM_SID_INIT is defined and has value 0x01.
  - LDCOM_SID_DEINIT is defined and has value 0x02.
  - LDCOM_SID_GETVERSIONINFO is defined and has value 0x03.
  - LDCOM_SID_TRANSMIT is defined and has value 0x49.
  - LDCOM_SID_STARTOFRECEPTION is defined and has value 0x46.
  - LDCOM_SID_COPYRXDATA is defined and has value 0x44.
  - LDCOM_SID_TPRXINDICATION is defined and has value 0x45.
  - LDCOM_SID_COPYTXDATA is defined and has value 0x43.
  - LDCOM_SID_TPTXCONFIRMATION is defined and has value 0x48.
  - LDCOM_SID_RXINDICATION is defined and has value 0x42.
  - LDCOM_SID_TRIGGERTRANSMIT is defined and has value 0x41.
  - LDCOM_SID_TXCONFIRMATION is defined and has value 0x40.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00022</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>40</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00023</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>41</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00024</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>42</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00026</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>44</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00027</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>49</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00028</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>50</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00029</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>51</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00030</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>52</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00031</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>53</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00032</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>54</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00056</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>55</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00033</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>56</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>237</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_IMP_02003_PreCompileSwitches</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Implementation/IN/LdCom_ImpTest_02/source/application/EbTest.c</sourcefile>
      <sourceline>223</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies the correct definitions of the pre compile macros:
  - LDCOM_VERSION_INFO_API
  - LDCOM_DEV_ERROR_DETECT
  - LDCOM_PBCFGM_SUPPORT_ENABLED
  - LDCOM_TPRXAPIS_AVAILABLE
  - LDCOM_TPTXAPIS_AVAILABLE
  - LDCOM_IFRXAPIS_AVAILABLE
  - LDCOM_IFTXAPIS_AVAILABLE
  - LDCOM_TRIGGERTRANSMIT_AVAILABLE
  - LDCOM_TXCONFIRMATION_AVAILABLE

&lt;/para&gt;

Test Object: None.
Test Precondition: 
  LdComVersionInfoApi is enabled.
  LdComDevErrorDetect is enabled.
  LdComRelocatablePbcfgEnable is enabled.

Test Execution: 
  01: VP: the macro LDCOM_VERSION_INFO_API is defined and set to STD_ON.
  02: VP: the macro LDCOM_DEV_ERROR_DETECT is defined and set to STD_ON.
  03: VP: the macro LDCOM_PBCFGM_SUPPORT_ENABLED is defined and set to STD_ON.
  04: VP: the macro LDCOM_TPRXAPIS_AVAILABLE is defined and set to STD_ON.
  05: VP: the macro LDCOM_TPTXAPIS_AVAILABLE is defined and set to STD_ON.
  06: VP: the macro LDCOM_IFRXAPIS_AVAILABLE is defined and set to STD_ON.
  07: VP: the macro LDCOM_IFTXAPIS_AVAILABLE is defined and set to STD_ON.
  08: VP: the macro LDCOM_TRIGGERTRANSMIT_AVAILABLE is defined and set to STD_ON.
  09: VP: the macro LDCOM_TXCONFIRMATION_AVAILABLE is defined and set to STD_ON.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00045</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>43</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00048</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>45</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00049</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>46</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00054</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>47</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00055</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>48</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00047</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>57</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00035</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>58</internalId></provcov>
        <provcov>
          <linksto>LdCom.ECUC_LdCom_00020</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>238</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_LDCOM_03000_StartOfReception_NotAvailable</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Implementation/IN/LdCom_ImpTest_03_IfRxOnly/source/application/EbTest.c</sourcefile>
      <sourceline>43</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Check if an error is reported in development mode and an error is returned by the API when
  LdCom_StartOfReception is called with no I-PDU of a transport protocol configured.
  This reflects the EB interpretation of "the API is not available".
&lt;/para&gt;

Test Object: 
  LdCom_StartOfReception()

Test Precondition: 
  LdCom module is not initialized.
  Configuration holds only Rx I-PDUs for communication interface modules.

Test Execution: 
  00: initialize module
  01: call LdCom_StartOfReception
  02: VP (LdCom.SWS_LdCom_00018.INVALID_PDU_SDU_ID): Det is called with error code
      LDCOM_E_INVALID_PDU_SDU_ID.
  03: VP (LdCom.EB.SWS_LdCom_00019): Error is returned with BUFREQ_E_NOT_OK.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00049</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>46</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>239</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_03001_CopyRxData_NotAvailable</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Implementation/IN/LdCom_ImpTest_03_IfRxOnly/source/application/EbTest.c</sourcefile>
      <sourceline>97</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Check if an error is reported in development mode and an error is returned by the API when
  LdCom_CopyRxData is called with no I-PDU of a transport protocol configured.
  This reflects the EB interpretation of "the API is not available".
&lt;/para&gt;

Test Object: 
  LdCom_CopyRxData()

Test Precondition: 
  LdCom module has been initialized.
  Configuration holds only Rx I-PDUs for communication interface modules.

Test Execution: 
  01: call LdCom_CopyRxData.
  02: VP (LdCom.SWS_LdCom_00018.INVALID_PDU_SDU_ID): Det is called with error code
      LDCOM_E_INVALID_PDU_SDU_ID.
  03: VP (LdCom.EB.SWS_LdCom_00019): Error is returned with BUFREQ_E_NOT_OK.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00049</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>46</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>240</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_03002_TpRxInd_NotAvailable</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Implementation/IN/LdCom_ImpTest_03_IfRxOnly/source/application/EbTest.c</sourcefile>
      <sourceline>147</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Check if an error is reported in development mode when LdCom_TpRxIndication is called
  with no I-PDU of a transport protocol configured.
  This reflects the EB interpretation of "the API is not available".
&lt;/para&gt;

Test Object: 
  LdCom_TpRxIndication()

Test Precondition: 
  LdCom module has been initialized.
  Configuration holds only Rx I-PDUs for communication interface modules.

Test Execution: 
  01: call LdCom_TpRxIndication.
  02: VP: Det is called with error code LDCOM_E_INVALID_PDU_SDU_ID.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00049</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>46</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>241</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_03010_CopyTxData_NotAvailable</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Implementation/IN/LdCom_ImpTest_03_IfRxOnly/source/application/EbTest.c</sourcefile>
      <sourceline>188</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Check if an error is reported in development mode and an error is returned by the API when
  LdCom_CopyTxData is called with no I-PDU of a transport protocol configured.
  This reflects the EB interpretation of "the API is not available".
&lt;/para&gt;

Test Object: 
  LdCom_CopyTxData

Test Precondition: 
  LdCom module has been initialized.
  Configuration holds only Rx I-PDUs for communication interface modules.

Test Execution: 
  01: call LdCom_CopyTxData.
  02: VP (LdCom.SWS_LdCom_00018.INVALID_PDU_SDU_ID): Det is called with error code
      LDCOM_E_INVALID_PDU_SDU_ID.
  03: VP (LdCom.EB.SWS_LdCom_00019): Error is returned with BUFREQ_E_NOT_OK.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00048</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>45</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>242</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_03011_TpTxConf_NotAvailable</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Implementation/IN/LdCom_ImpTest_03_IfRxOnly/source/application/EbTest.c</sourcefile>
      <sourceline>239</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Check if an error is reported in development mode when LdCom_TpTxConfirmation is called
  with no I-PDU of a transport protocol configured.
  This reflects the EB interpretation of "the API is not available".
&lt;/para&gt;

Test Object: 
  LdCom_TpTxConfirmation

Test Precondition: 
  LdCom module has been initialized.
  Configuration holds only Rx I-PDUs for communication interface modules.

Test Execution: 
  01: call LdCom_TpTxConfirmation.
  02: VP (LdCom.SWS_LdCom_00018.INVALID_PDU_SDU_ID): Det is called with error code
      LDCOM_E_INVALID_PDU_SDU_ID.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00049</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>46</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>243</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_03020_Transmit_NotAvailable</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Implementation/IN/LdCom_ImpTest_03_IfRxOnly/source/application/EbTest.c</sourcefile>
      <sourceline>281</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Check if an error is reported in development mode and an error is returned by the API when
  LdCom_Transmit is called with no Tx I-PDU of a communication interface configured.
  This reflects the EB interpretation of "the API is not available".
&lt;/para&gt;

Test Object: 
  LdCom_Transmit()

Test Precondition: 
  LdCom module has been initialized.
  Configuration holds only Rx I-PDUs for communication interface modules.

Test Execution: 
  01: call LdCom_Transmit.
  02: VP (LdCom.SWS_LdCom_00018.INVALID_PDU_SDU_ID): Det is called with error code
      LDCOM_E_INVALID_PDU_SDU_ID.
  03: VP (LdCom.EB.SWS_LdCom_00019): Error is returned with E_NOT_OK.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00018.INVALID_PDU_SDU_ID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>35</internalId></provcov>
        <provcov>
          <linksto>LdCom.EB.SWS_LdCom_00019</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>244</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_03021_Transmit_NotAvailable</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Implementation/IN/LdCom_ImpTest_03_IfRxOnly/source/application/EbTest.c</sourcefile>
      <sourceline>331</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Check if an error is reported in development mode and an error is returned by the API when
  LdCom_Transmit is called with no I-PDU of a transport protocol configured.
  This reflects the EB interpretation of "the API is not available".
&lt;/para&gt;

Test Object: 
  LdCom_Transmit()

Test Precondition: 
  LdCom module has been initialized.
  Configuration holds only Rx I-PDUs for communication interface modules.

Test Execution: 
  01: call LdCom_Transmit.
  02: VP (LdCom.SWS_LdCom_00018.INVALID_PDU_SDU_ID): Det is called with error code
      LDCOM_E_INVALID_PDU_SDU_ID.
  03: VP (LdCom.EB.SWS_LdCom_00019): Error is returned with E_NOT_OK.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00018.INVALID_PDU_SDU_ID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>35</internalId></provcov>
        <provcov>
          <linksto>LdCom.EB.SWS_LdCom_00019</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>245</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_03030_PreCompileSwitches</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Implementation/IN/LdCom_ImpTest_03_IfRxOnly/source/application/EbTest.c</sourcefile>
      <sourceline>381</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies the correct definitions of the pre compile macros:
  - LDCOM_TPRXAPIS_AVAILABLE
  - LDCOM_TPTXAPIS_AVAILABLE
  - LDCOM_IFRXAPIS_AVAILABLE
  - LDCOM_IFTXAPIS_AVAILABLE
  - LDCOM_TRIGGERTRANSMIT_AVAILABLE
  - LDCOM_TXCONFIRMATION_AVAILABLE
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  LdCom module has been initialized.
  Configuration holds only Rx I-PDUs for communication interface modules.

Test Execution: 
  01: VP: the macro LDCOM_TPRXAPIS_AVAILABLE is defined and set to STD_OFF.
  02: VP: the macro LDCOM_TPTXAPIS_AVAILABLE is defined and set to STD_OFF.
  03: VP: the macro LDCOM_IFRXAPIS_AVAILABLE is defined and set to STD_ON.
  04: VP: the macro LDCOM_IFTXAPIS_AVAILABLE is defined and set to STD_OFF.
  05: VP: the macro LDCOM_TRIGGERTRANSMIT_AVAILABLE is defined and set to STD_OFF.
  06: VP: the macro LDCOM_TXCONFIRMATION_AVAILABLE is defined and set to STD_OFF.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00048</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>45</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00049</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>46</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>246</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_LDCOM_04001_LdCom_RxIndication_NotAvailable</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Implementation/IN/LdCom_ImpTest_04_TPOnly/source/application/EbTest.c</sourcefile>
      <sourceline>43</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Check if an error is reported in development mode when LdCom_RxIndication
  is called and no I-PDU has LdComIPduDirection configured to LDCOM_RECEIVE
  and LdComApiType configured to LDCOM_IF.
  This reflects the EB interpretation of "the API is not available".
&lt;/para&gt;

Test Object: 
  LdCom_RxIndication()

Test Precondition: 
  LdCom module is not initialized.
  Configuration holds only Tp I-PDUs for communication interface modules.

Test Execution: 
  00: initialize module
  01: call LdCom_RxIndication
  02: VP (LdCom.SWS_LdCom_00055): Det is called with error code
      LDCOM_E_INVALID_PDU_SDU_ID.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00055</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>48</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>247</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_04002_LdCom_TriggerTransmit_NotAvailable</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Implementation/IN/LdCom_ImpTest_04_TPOnly/source/application/EbTest.c</sourcefile>
      <sourceline>92</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Check if an error is reported in development mode and an error is returned
  by the API when LdCom_TriggerTransmit is called and no I-PDU has
  LdComTxTriggerTransmit configured.
  This reflects the EB interpretation of "the API is not available".
&lt;/para&gt;

Test Object: 
  LdCom_TriggerTransmit()

Test Precondition: 
  LdCom module has been initialized.
  Configuration holds only Tp I-PDUs for communication interface modules.

Test Execution: 
  01: call LdCom_TriggerTransmit.
  02: VP (LdCom.SWS_LdCom_00047): Det is called with error code
      LDCOM_E_INVALID_PDU_SDU_ID.
  03: VP (LdCom.SWS_LdCom_00047): Error is returned with E_NOT_OK.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00047</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>57</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>248</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_04003_LdCom_TxConfirmation_NotAvailable</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Implementation/IN/LdCom_ImpTest_04_TPOnly/source/application/EbTest.c</sourcefile>
      <sourceline>142</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Check if an error is reported in development mode when LdCom_TxConfirmation
  is called and no I-PDU has LdComIPduDirection configured to LDCOM_SEND
  and LdComApiType configured to LDCOM_IF.
  This reflects the EB interpretation of "the API is not available".
&lt;/para&gt;

Test Object: 
  LdCom_TxConfirmation()

Test Precondition: 
  LdCom module has been initialized.
  Configuration holds only Tp I-PDUs for communication interface modules.

Test Execution: 
  01: call LdCom_TxConfirmation.
  02: VP: (LdCom.SWS_LdCom_00054): Det is called with error code
      LDCOM_E_INVALID_PDU_SDU_ID.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00054</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>47</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>249</internalId></specobject>
    <specobject>
      <id>TS_LDCOM_04004_PreCompileSwitches</id>
      <status>approved</status>
      <source>EB test case specification (asc_LdCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_LdCom/test/ts5/Implementation/IN/LdCom_ImpTest_04_TPOnly/source/application/EbTest.c</sourcefile>
      <sourceline>185</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies the correct definitions of the pre compile macros:
  - LDCOM_TPRXAPIS_AVAILABLE
  - LDCOM_TPTXAPIS_AVAILABLE
  - LDCOM_IFRXAPIS_AVAILABLE
  - LDCOM_IFTXAPIS_AVAILABLE
  - LDCOM_TRIGGERTRANSMIT_AVAILABLE
  - LDCOM_TXCONFIRMATION_AVAILABLE
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  LdCom module has been initialized.
  Configuration holds only Tp I-PDUs for communication interface modules.

Test Execution: 
  01: VP: the macro LDCOM_TPRXAPIS_AVAILABLE is defined and set to STD_ON.
  02: VP: the macro LDCOM_TPTXAPIS_AVAILABLE is defined and set to STD_ON.
  03: VP: the macro LDCOM_IFRXAPIS_AVAILABLE is defined and set to STD_OFF.
  04: VP: the macro LDCOM_IFTXAPIS_AVAILABLE is defined and set to STD_OFF.
  05: VP: the macro LDCOM_TRIGGERTRANSMIT_AVAILABLE is defined and set to STD_OFF.
  06: VP: the macro LDCOM_TXCONFIRMATION_AVAILABLE is defined and set to STD_OFF.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00054</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>47</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00055</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>48</internalId></provcov>
        <provcov>
          <linksto>LdCom.SWS_LdCom_00047</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>57</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>250</internalId></specobject>
  </specobjects>
  </specdocument>
  <violations/>
  <oreqmViolations/>
</tracingresults>
