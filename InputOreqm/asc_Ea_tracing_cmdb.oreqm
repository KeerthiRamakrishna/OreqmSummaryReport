<?xml version="1.0" encoding="UTF-8"?>
<tracingresults>
  <environment>
    <toolname>ReqM2</toolname>
    <toolversion>1.30.0 (stable)</toolversion>
    <toolcopyright>Copyright 2010 - 2018 Elektrobit Automotive GmbH</toolcopyright>
    <libxmlversion>2.0207</libxmlversion>
    <libxml2compileversion>2.9.10</libxml2compileversion>
    <libxml2runtimeversion>20912</libxml2runtimeversion>
    <perlversion>v5.32.1</perlversion>
    <perlptrsize>64</perlptrsize>
    <commandline>-t -q -o asc_Ea_tracing_cmdb.oreqm -O /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/TestProtocols/LogBase/requirements -c /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_PluginBuildEnv/common/config/AutoCoreReqM2Rules_RMP4_0.xml -s approved,rejected --wfatal WDUPLICATEID,WDUPLICATEIDANDVER /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/build/reqm/ReqM2_Native/asc_Ea_public_modulereference_integration_req.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/build/reqm/ReqM2_Native/asc_Ea_requirements_AUTOSAR_SWS_EEPROMAbstraction_4_0_3.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/build/reqm/ReqM2_Native/asc_Ea_requirements_AUTOSAR_SWS_EEPROMAbstraction_R21-11.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/build/reqm/ReqM2_Native/asc_Ea_requirements_EB_Limitations.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/build/reqm/ReqM2_Native/asc_Ea_requirements_EB_Refinements.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/build/reqm/ReqM2_Native/asc_Ea_requirements_EB_Requirements.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/build/reqm/ReqM2_Native/asc_Ea_test_manTest_ResourceConsumption.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/build/reqm/common_req/Ea_DbgInst_EB_Extension.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/build/reqm/common_req/Ea_VerifyStub_EB_Extension.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/build/reqm/ReqM2_GenericImporter/reqm_DEV.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/build/reqm/ReqM2_GenericImporter/reqm_IMPL.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/build/reqm/ReqM2_GenericImporter/reqm_IMPLXML.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/build/reqm/ReqM2_DocBookImporter/reqm_SWDD.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/build/reqm/ReqM2_OldCImporter/reqm_SWUTS_LEGACY.reqm</commandline>
    <timestamp>Mon Jun 17 22:05:41 2024</timestamp>
  </environment>
  <cmdline>
    <cmdparam>
      <name>I</name>
      <values>
        <value>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/TestProtocols/LogBase/requirements</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>O</name>
      <values>
        <value>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/TestProtocols/LogBase/requirements</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>c</name>
      <values>
        <value>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_PluginBuildEnv/common/config/AutoCoreReqM2Rules_RMP4_0.xml</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>o</name>
      <values>
        <value>asc_Ea_tracing_cmdb.oreqm</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>q</name>
    </cmdparam>
    <cmdparam>
      <name>s</name>
      <values>
        <value>approved</value>
        <value>rejected</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>t</name>
    </cmdparam>
    <cmdparam>
      <name>wfatal</name>
      <values>
        <value>WDUPLICATEID</value>
        <value>WDUPLICATEIDANDVER</value>
      </values>
    </cmdparam>
  </cmdline>
  <inputfiles>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/build/reqm/ReqM2_Native/asc_Ea_public_modulereference_integration_req.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/build/reqm/ReqM2_Native/asc_Ea_requirements_AUTOSAR_SWS_EEPROMAbstraction_4_0_3.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/build/reqm/ReqM2_Native/asc_Ea_requirements_AUTOSAR_SWS_EEPROMAbstraction_R21-11.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/build/reqm/ReqM2_Native/asc_Ea_requirements_EB_Limitations.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/build/reqm/ReqM2_Native/asc_Ea_requirements_EB_Refinements.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/build/reqm/ReqM2_Native/asc_Ea_requirements_EB_Requirements.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/build/reqm/ReqM2_Native/asc_Ea_test_manTest_ResourceConsumption.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/build/reqm/common_req/Ea_DbgInst_EB_Extension.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/build/reqm/common_req/Ea_VerifyStub_EB_Extension.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/build/reqm/ReqM2_GenericImporter/reqm_DEV.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/build/reqm/ReqM2_GenericImporter/reqm_IMPL.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/build/reqm/ReqM2_GenericImporter/reqm_IMPLXML.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/build/reqm/ReqM2_DocBookImporter/reqm_SWDD.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/build/reqm/ReqM2_OldCImporter/reqm_SWUTS_LEGACY.reqm</inputfile>
  </inputfiles>
  <configuration>
    <doctypes>
    <regexs>
      <!-- external level -->
      <regex>creq</regex>       <!-- since 10/1018: introduced for updated tracing model-->

      <!-- product line level -->
      <regex>fea</regex>
      <regex>swpad</regex>      <!-- since 10/1018: introduced for updated tracing model-->
      <regex>swts</regex>

      <!-- bundle level -->
      <regex>swrs</regex>
      <regex>swad</regex>
      <regex>swintts</regex>

      <!-- module level -->
      <regex>swdd</regex>
      <regex>swurs</regex>      <!-- since 10/1018: introduced for updated tracing model-->
      <regex>swmts</regex>      <!-- since 01/1010: introduced for updated tracing model RMP4.0-->
      <regex>swuts</regex>
      <regex>impl</regex>

      <!-- legacy items -->
      <regex>dev</regex>
      <regex>man</regex>
      <regex>lim</regex>
    </regexs>
  </doctypes>
    <rules>
    <!-- The Ruleset for RMP4.0 is currently identical to the previous rule set. This rule is
        intoduce to show that the right file is uses. It will be removed when the RMP4.0 rule set is
    reworked -->
    <rule>
      <name>INFO.Rule set RMP4.0</name>
      <description>This rules indicates that RMP4.0 rule set is used.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status!='approved') and (./status!='rejected')]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>WRN.general.doctypes</name>
      <description>The used doctype is not part of the tracing model</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobjects/@doctype</applyto>
          <condition>((. != 'creq') or (. != 'fea') or (. != 'swpad') or (. != 'swts') or (. != 'swrs') or (. !='swad') or (. != 'swintts') or (.!= 'swdd') or (. != 'swurs') or (. != 'swmts') or (. != 'swuts') or (. != 'impl') or (. != 'dev') or (. != 'man') or (. != 'lim'))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.status</name>
      <description>All specification objects must be either in status=approved or in status=rejected. Other
        statuses are not allowed. How to fix: Set status to rejected or approved.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status!='approved') and (./status!='rejected')]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.rejected</name>
      <description>Status status=rejected is only allowed for requirements. How to fix: set to approved for specification object that are not requirements.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype!='swrs')  and (../@doctype!='swmrs') and (../@doctype!='swurs') and (./status='rejected')]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.comment</name>
      <description>Specification objects with status=rejected shall have a comment or rationale that
        starts with on of the following texts: "This requirement is informational only", "This requirement is not applicable".
        How to fix: Add some text starting with "This requirement is informational only"
        or "This requirement is not applicable" to either the comment or to the rationale.
        Comment: Implementation of check checks for contains instead of starts-with since there is
        no trim function in the used XPATH engine.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status='rejected')]</applyto>
          <condition>contains(./comment,"This requirement is informational only") or contains(./rationale,"This requirement is informational only") or contains(./comment,"This requirement is not applicable") or contains(./rationale,"This requirement is not applicable")</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.rejected.coverage</name>
      <description>Specification objects with status=rejected shall not need coverage. How to fix: remove need for coverage.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status='rejected')]</applyto>
          <condition>count(./needscoverage)=0</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swurs.needscoverage.count</name>
      <description>Unit requirements with status=approved need to be covered, exceptions from
      this rule: configuration requirements (postfix "_CONF" or "_Conf" or prefix "ECUC_") and requirements with
      a comment starting with "The adherence to this requirement is ensured by the following
      release check (URL to the checklist template plus ID of the check):".
      How to fix: Provide a needsobj element for those specobjects or comment according to the rule.
      </description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swurs') and (./status='approved') and count(./needscoverage/needsobj)=0 and count(./fulfilledby/ffbObj)=0]</applyto>
          <!--This condition is false if the id of a specification object does not end with '_Conf' or '_CONF' or does not start with ECUC_ -->
          <condition>substring-after(./id,"ECUC_")!="" or substring-before(./id,"_Conf")!="" or substring-before(./id,"_CONF")!="" or contains(./comment,"The adherence to this requirement is ensured by the following release check (URL to the checklist template plus ID of the check):")</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swurs.needscoverage.rationale</name>
      <description>Requirements with status=approved and without coverage needs that are
        configuration requirements (postfix "_CONF" or "_Conf" or prefix "ECUC_") shall have a comment or rationale
        with the following text: "This is a configuration parameter requirement without functional
        specification.". How to fix: Add some text starting with "This is a configuration parameter
        requirements without functional specification" to either the comment or to the rationale.</description>
      <regexchecks>
        <regexcheck>
          <applyto>//specobject[(../@doctype='swurs') and (./status='approved') and count(./needscoverage/needsobj)=0 and (substring-after(./id,"ECUC_")!="" or substring-before(./id,"_CONF")!="" or substring-before(./id,"_Conf")!="")]</applyto>
          <regex>This is a configuration parameter requirement without functional specification.</regex>
        </regexcheck>
      </regexchecks>
    </rule>

    <rule>
      <name>ERR.swrs.needscoverage.rationale</name>
      <description>Requirements with status=approved and without coverage needs that are
        configuration requirements (postfix "_CONF" or "_Conf" or prefix "ECUC_") shall have a comment or rationale
        with the following text: "This is a configuration parameter requirement without functional
        specification.". How to fix: Add some text starting with "This is a configuration parameter
        requirements without functional specification" to either the comment or to the rationale.</description>
      <regexchecks>
        <regexcheck>
          <applyto>//specobject[(../@doctype='swrs') and (./status='approved') and count(./needscoverage/needsobj)=0 and (substring-after(./id,"ECUC_")!="" or substring-before(./id,"_CONF")!="" or substring-before(./id,"_Conf")!="")]</applyto>
          <regex>This is a configuration parameter requirement without functional specification.</regex>
        </regexcheck>
      </regexchecks>
    </rule>

    <rule>
      <name>ERR.swurs.releases</name>
      <description>Requirements which originates from AUTOSAR (source tag contains term 'AUTOSAR_SWS', 'AUTOSAR_TPS',
        'AUTOSAR_ASWS' or 'AUTOSAR_TR') shall have their release tag set to 'AUTOSAR {major}.{minor}.{patch}' (e.g. 'AUTOSAR 4.3.0').
        Other requirements (including refinements of AUTOSAR requirements) must not contain any of the listed prefixes as
        part of the source tag.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swurs') and (contains(./source,'AUTOSAR_SWS') or contains(./source,'AUTOSAR_TPS') or contains(./source,'AUTOSAR_ASWS') or contains(./source,'AUTOSAR_TR'))]</applyto>
          <condition>contains(./releases/release,'AUTOSAR')</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swrs.releases</name>
      <description>Requirements which originates from AUTOSAR (source tag contains term 'AUTOSAR_SWS', 'AUTOSAR_TPS',
        'AUTOSAR_ASWS' or 'AUTOSAR_TR') shall have their release tag set to 'AUTOSAR {major}.{minor}.{patch}' (e.g. 'AUTOSAR 4.3.0').
        Other requirements (including refinements of AUTOSAR requirements) must not contain any of the listed prefixes as
        part of the source tag.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swrs') and (contains(./source,'AUTOSAR_SWS') or contains(./source,'AUTOSAR_TPS') or contains(./source,'AUTOSAR_ASWS') or contains(./source,'AUTOSAR_TR'))]</applyto>
          <condition>contains(./releases/release,'AUTOSAR')</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swdd.needscoverage.count</name>
      <description>Design elements with status=approved need to be covered.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swdd') and (./status='approved') and count(./needscoverage/needsobj)=0]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swurs.needscoverage.doctypes</name>
      <description>Requirements can be covered only by swurs, swad, dev, lim, swdd, impl, swuts, swmts, or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swurs')]</applyto>
          <condition>(./needscoverage/needsobj="swurs" or ./needscoverage/needsobj="swad" or ./needscoverage/needsobj="dev" or ./needscoverage/needsobj="lim" or ./needscoverage/needsobj="swdd" or ./needscoverage/needsobj="impl" or ./needscoverage/needsobj="swuts" or ./needscoverage/needsobj="swmts" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swrs.needscoverage.doctypes</name>
      <description>Requirements of type swrs can be covered only by swrs, swurs, swad, swintts or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swrs')]</applyto>
          <condition>(./needscoverage/needsobj="swrs" or ./needscoverage/needsobj="swurs" or ./needscoverage/needsobj="swad" or ./needscoverage/needsobj="swuts" or ./needscoverage/needsobj="swintts" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swdd.needscoverage.doctypes</name>
      <description>Design elements of type swdd can only be covered by swdd, swurs, impl, swuts, lim or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swdd')]</applyto>
          <condition>(./needscoverage/needsobj="swdd" or ./needscoverage/needsobj="swurs" or ./needscoverage/needsobj="impl" or ./needscoverage/needsobj="swuts" or ./needscoverage/needsobj="swmts" or ./needscoverage/needsobj="lim" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.dev.needscoverage.count</name>
      <description>Deviations shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='dev')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swuts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swuts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swmts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swmts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swintts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swintts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.man.needscoverage.count</name>
      <description>Manual test cases shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='man')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.impl.needscoverage.count</name>
      <description>Source code shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='impl')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.lim.needscoverage.count</name>
      <description>Limitations shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='lim')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.fea.needscoverage.test</name>
      <description>Features shall be tested by software test ('swts') or manuel test ('man'). If no test is planned a justification shall be given.
                   A justification can be given in the futherinfo tag. The justification shall start with this rule name.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='fea')]</applyto>
          <condition>(
               ./needscoverage/needsobj="swts" or ./needscoverage/needsobj="man" or ./fulfilledby/ffbObj/ffbType="swts" or ./fulfilledby/ffbObj/ffbType="man" or contains(./furtherinfo,"fea.needscoverage.test") or contains(./furtherinfo,"fea.needscoverage.doctypes"))</condition>
        </conditioncheck>
      </conditionchecks>
          </rule>

    <rule>
      <name>WRN.fea.needscoverage.impl</name>
      <description>Features shall be covered by implementation fea, swrs, swad, swpad, swurs, man and swts. For lagacy features a justification is acceppted. A justification can be given in the futherinfo tag. The justification shall start with this rule name.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='fea')]</applyto>
          <condition>( ./needscoverage/needsobj="swrs" or ./fulfilledby/ffbObj/ffbType="swrs" or ./fulfilledby/ffbObj/ffbType="swad" or ./needscoverage/needsobj="swpad" or ./fulfilledby/ffbObj/ffbType="swpad" or ./needscoverage/needsobj="swurs" or ./fulfilledby/ffbObj/ffbType="swurs" or ./needscoverage/needsobj="fea" or ./fulfilledby/ffbObj/ffbType="fea" or contains(./furtherinfo,"fea.needscoverage.impl"))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>


    <rule>
      <name>ERR.swad.fulfilledby.doctypes</name>
      <description>Architectural design objects of type swad can only be covered by swurs, swad, swdd, swintts, man, otherwise they should be refined with swrs</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swad')]</applyto>
          <condition>(./fulfilledby/ffbObj/ffbType="swurs" or ./needscoverage/needsobj="swurs" or ./fulfilledby/ffbObj/ffbType="req" or ./needscoverage/needsobj="req" or ./fulfilledby/ffbObj/ffbType="swad" or ./needscoverage/needsobj="swad" or ./fulfilledby/ffbObj/ffbType="swdd" or ./fulfilledby/ffbObj/ffbType="swintts" or ./needscoverage/needsobj="swintts" or ./fulfilledby/ffbObj/ffbType="man" or ./needscoverage/needsobj="man") </condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swmts.providescoverage.doctypes</name>
      <description>Test case specifications (tcs) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='tcs')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.man.providescoverage.doctypes</name>
      <description>Manual test case specification (man) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='man')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

   <rule>
      <name>ERR.swuts.providescoverage.doctypes</name>
      <description>Software unit test case specification (swuts) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swuts')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

   <rule>
      <name>ERR.swintts.providescoverage.doctypes</name>
      <description>Software integration test case specification (swintts) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swintts')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

   <rule>
      <name>ERR.swts.providescoverage.doctypes</name>
      <description>Software test case specification (swts) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swts')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

  </rules>
    <oreqmRules>

        <rule>
            <name>WRN.swts.needscoverage.count</name>
            <description>Violated if there are more than 10 swts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
        <rule>
            <name>WRN.man.needscoverage.count</name>
            <description>Violated if there are more than 10 man specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='man']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='man']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>man.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
        <rule>
            <name>WRN.swintts.needscoverage.count</name>
            <description>Violated if there are more than 10 swintts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swintts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swintts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swintts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
        <rule>
            <name>WRN.swmts.needscoverage.count</name>
            <description>Violated if there are more than 10 swmts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swmts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swmts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swmts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swuts.needscoverage.count</name>
            <description>Violated if there are more than 10 swuts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swuts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swuts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swuts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swpad.needscoverage.count</name>
            <description>Violated if there are more than 10 swpad specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swpad']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swpad']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swpad.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swrs.needscoverage.count</name>
            <description>Violated if there are more than 10 swrs specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swrs']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swrs']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swrs.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swad.needscoverage.count</name>
            <description>Violated if there are more than 10 swad specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swad']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swad']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swad.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swurs.needscoverage.count</name>
            <description>Violated if there are more than 10 swurs specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swurs']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swurs']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swurs.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swdd.needscoverage.count</name>
            <description>Violated if there are more than 10 swdd specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swdd']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swdd']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swdd.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.impl.needscoverage.count</name>
            <description>Violated if there are more than 10 impl specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='impl']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='impl']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>impl.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swrs.fulfilledby.count</name>
            <description>Violated if there are more than 10 swrs specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swrs'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swrs'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swrs.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swad.fulfilledby.count</name>
            <description>Violated if there are more than 10 swad specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swad'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swad'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swad.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swurs.fulfilledby.count</name>
            <description>Violated if there are more than 10 swurs specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swurs'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swurs'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swurs.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swdd.fulfilledby.count</name>
            <description>Violated if there are more than 10 swdd specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swdd'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swdd'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swdd.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
  </oreqmRules>
  </configuration>
  <specdocument>
    <specobjects doctype="lim">
    <specobject>
      <id>dev.Ea.IntegrationRestrictions</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
      Integration restriction and recommendation.

      The EB memory stack modules NvM, Ea and Fee make only limited
      use of the callback calls from their underlying modules.
      During the integration make sure that the NvM, Ea,
      and Fee main functions are only called from the same task
      context so that they cannot preempt each other.

      The configuration parameter <code>EaPollingMode</code> is only used for
      controlling the availability of callback functions. The
      module operates as if polling mode is always selected. The
      callback functions <code>Ea_JobEndNotification()</code> and
      <code>Ea_JobErrorNotification()</code> can be called but will
      have no effect.
      </description>
      <rationale> 
      This approach enables a simple and lock-free implementation
      resulting in smaller code.
      </rationale>
      <providescoverage>
        <provcov>
          <linksto>Ea.Callback.LimitUse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>164</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>0</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs">
    <specobject>
      <id>Ea.ASR40.ECUC_Ea_00070</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, V2.0.0</source>
      <version>1</version>
      <description>
        Name: EaMaximumBlockingTime
        Parameter Type: FloatValue
        Parent Containers: EaPublishedInformation,
        Description: The maximum time the EA module's API routines shall be blocked (delayed) by 
        internal operations. (EA070)
        Introduction: Note: Internal operations in that case means operations that are not explicitly 
        invoked from the upper layer module but need to be handled for proper operation of this module 
        or the underlying memory driver.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Origin: AUTOSAR_ECUC
        Symbolic-Name-Value: false
        Max-Value: Inf (Type:
        Min-Value: 0 (Type:
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Ea.xdm.m4_799</srcid><srcstatus/><internalId>258</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1</internalId></specobject>

    <specobject>
      <id>Ea.ASR40.ECUC_Ea_00118</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, V2.0.0</source>
      <version>1</version>
      <description>
        Name: EaIndex
        Parameter Type: Integer
        Parent Containers: EaGeneral,
        Description: Specifies the InstanceId of this module instance. If only one instance is present 
        it shall have the Id 0.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Origin: AUTOSAR_ECUC
        Symbolic-Name-Value: false
        Max-Value: 254 (Type:
        Min-Value: 0 (Type:
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2</internalId></specobject>

    <specobject>
      <id>Ea.ASR40.SWS_Ea_00011</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, V2.0.0</source>
      <version>1</version>
      <description>
        The detection of development errors shall be configurable (on/off) at pre-compile time. The 
        switch EA_DEV_ERROR_DETECT shall activate or deactivate the detection of all development errors.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30055</srcid><srcstatus/><internalId>311</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>3</internalId></specobject>

    <specobject>
      <id>Ea.ASR40.SWS_Ea_00013</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, V2.0.0</source>
      <version>1</version>
      <description>
        The EA module shall perform inter module checks to avoid integration of incompatible files: all 
        included header files shall be checked by pre-processing directives. The EA module shall 
        thereby verify that &lt;MODULENAME&gt;_AR_RELEASE_MAJOR_VERSION and &lt;MODULENAME&gt;
        _AR_RELEASE_MINOR_VERSION are identical to the expected values, where &lt;MODULENAME&gt; is the 
        module abbreviation of the external module, which provides the included header file. If the 
        values are not identical, an error shall be raised at compile time.
      </description>
      <comment>
        Inter module checks are performed using Mod_VersionCheck_Tmpl.c.m4
        in the source files which tests the file compatibility.
        #error directives are used to report any incompatibility thus
        DET error EA_E_INCOMPATIBLE_VERSIONS reporting is not done.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30066</srcid><srcstatus/><internalId>265</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>4</internalId></specobject>

    <specobject>
      <id>Ea.ASR40.SWS_Ea_00020</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, V2.0.0</source>
      <version>1</version>
      <description>
        If the current module state is MEMIF_IDLE and if supported by the underlying hardware and 
        device driver, the function Ea_SetMode shall call the function "Eep_SetMode" of the underlying 
        EEPROM driver with the given "Mode" parameter.
      </description>
      <comment>
        our implementation assumes the underlying eep function exists
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30078</srcid><srcstatus/><internalId>285</internalId></linkedfrom><linkedfrom><srcid>TS_EA_SetMode</srcid><srcstatus/><internalId>309</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>NoEa_SetMode</srcid><srcstatus/><internalId>198</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>5</internalId></specobject>

    <specobject>
      <id>Ea.ASR40.SWS_Ea_00045</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, V2.0.0</source>
      <version>1</version>
      <description>
        Detected development errors shall be reported to the Det_ReportError service of the Development 
        Error Tracer (DET) if the pre-processor switch EA_DEV_ERROR_DETECT is set 
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30055</srcid><srcstatus/><internalId>311</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>6</internalId></specobject>

    <specobject>
      <id>Ea.ASR40.SWS_Ea_00048</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, V2.0.0</source>
      <version>1</version>
      <description>
        Values for production code Event Ids are assigned externally by the configuration of the Dem. 
        They are published in the file Dem_IntErrId.h and included via Dem.h.
      </description>
      <comment>
        This requirement is not applicable. There are no DEM errors specified for EA.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>7</internalId></specobject>

    <specobject>
      <id>Ea.ASR40.SWS_Ea_00049</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, V2.0.0</source>
      <version>1</version>
      <description>
        Development error values are of type uint8.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/Ea.h_94</srcid><srcstatus/><internalId>225</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>8</internalId></specobject>

    <specobject>
      <id>Ea.ASR40.SWS_Ea_00057</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, V2.0.0</source>
      <version>1</version>
      <description>
        The code file structure shall not be defined within this specification.
      </description>
      <comment>
        This requirement is informational only. It concerns content of specification.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>9</internalId></specobject>

    <specobject>
      <id>Ea.ASR40.SWS_Ea_00058</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, V2.0.0</source>
      <version>1</version>
      <description>
        The EA module shall include the Dem.h file. By this inclusion the APIs to report errors as well 
        as the required Event Id symbols are included. This specification defines the name of the Event 
        Id symbols which are provided by XML to the DEM configuration tool. The DEM configuration tool 
        assigns ECU dependent values to the Event Id symbols and publishes the symbols in Dem_IntErrId.
        h.
      </description>
      <comment>
        This requirement is not applicable. There are no DEM errors specified for EA.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>10</internalId></specobject>

    <specobject>
      <id>Ea.ASR40.SWS_Ea_00059</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, V2.0.0</source>
      <version>1</version>
      <description>
        If the EA_DEV_ERROR_DETECT switch is enabled, API parameter checking is enabled. The detailed 
        description of the detected errors can be found in chapter 7.2 and chapter 8.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30055</srcid><srcstatus/><internalId>311</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>11</internalId></specobject>

    <specobject>
      <id>Ea.ASR40.SWS_Ea_00060</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, V2.0.0</source>
      <version>1</version>
      <description>
        The detection of production code errors cannot be switched off.
      </description>
      <comment>
        This requirement is not applicable. There are no DEM errors specified for EA.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>12</internalId></specobject>

    <specobject>
      <id>Ea.ASR40.SWS_Ea_00061</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, V2.0.0</source>
      <version>1</version>
      <description>
        The function Ea_GetVersionInfo shall return the version information of this module. The version 
        information includes: Module Id Vendor Id Vendor specific version numbers (BSW00407)
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30094</srcid><srcstatus/><internalId>282</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>13</internalId></specobject>

    <specobject>
      <id>Ea.ASR40.SWS_Ea_00062</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, V2.0.0</source>
      <version>1</version>
      <description>
        The function Ea_GetVersionInfo shall be pre compile time configurable On/Off by the 
        configuration parameter EaVersionInfoApi.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30067</srcid><srcstatus/><internalId>266</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30068</srcid><srcstatus/><internalId>267</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>14</internalId></specobject>

    <specobject>
      <id>Ea.ASR40.SWS_Ea_00081</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, V2.0.0</source>
      <version>1</version>
      <description>
        Production errors shall be reported to Diagnostic Event Manager.
      </description>
      <comment>
        This requirement is not applicable. There are no DEM errors specified for EA.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>15</internalId></specobject>

    <specobject>
      <id>Ea.ASR40.SWS_Ea_00082</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, V2.0.0</source>
      <version>1</version>
      <description>
        If source code for caller and callee of the function Ea_GetVersionInfo is available, the Ea 
        module should realize this function as a macro, defined in the modules header file.
      </description>
      <comment>
        The support for this function is in line with EB implementation.
        A macro is not used in any case.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Ea_GetVersionInfo_NoMacro</srcid><srcstatus/><internalId>210</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>16</internalId></specobject>

    <specobject>
      <id>Ea.ASR40.SWS_Ea_00113</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, V2.0.0</source>
      <version>1</version>
      <description>
        The Ea module shall comply with the following file include structure:
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/include/Ea_Cfg.h_6</srcid><srcstatus/><internalId>219</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/include/Ea.h_8</srcid><srcstatus/><internalId>223</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/include/Ea.h_12</srcid><srcstatus/><internalId>224</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Ea.c.m4_5</srcid><srcstatus/><internalId>229</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>17</internalId></specobject>

    <specobject>
      <id>Ea.ASR40.SWS_Ea_00114</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, V2.0.0</source>
      <version>1</version>
      <description>
        The Ea module shall provide function prototypes of the callback functions in the file Ea_Cbk.h
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/Ea_Cbk.h_2</srcid><srcstatus/><internalId>226</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>18</internalId></specobject>

    <specobject>
      <id>Ea.ASR40.SWS_Ea_00155</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, V2.0.0</source>
      <version>1</version>
      <description>
        The module's job result, the status and the variables used for job control (for externally 
        requested jobs as well as for internal management operations) shall be made globally accessible.
      </description>
      <comment>
        Ea provides support for debugging global variables Ea_MainState, Ea_JobResult and Ea_Status.
        Defined macros DBG_EA_MAINSTATE, DBG_EA_JOBRESULT and DBG_EA_STATUS.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/Ea_Trace.h.m4_16</srcid><srcstatus/><internalId>227</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>19</internalId></specobject>

    <specobject>
      <id>Ea.ASR40.SWS_Ea_00163</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, V2.0.0</source>
      <version>1</version>
      <description>
        VARIANT-PRE-COMPILE
        Only  parameters     with      "Pre-compile  time"  configuration  are         allowed         
        in  this
        variant.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Ea.xdm.m4_40</srcid><srcstatus/><internalId>234</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>20</internalId></specobject>

    <specobject>
      <id>Ea.ASR40.SWS_Ea_00166</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, V2.0.0</source>
      <version>1</version>
      <description>
        If development error detection is enabled for the module: the function Ea_SetMode shall check 
        if the module state is MEMIF_BUSY_INTERNAL. If this is the case, the function Ea_SetMode shall 
        raise the development error EA_E_BUSY_INTERNAL and return to the caller without executing the 
        mode switch.
      </description>
      <comment>
        There are no internal management operations in the Ea module implementation,
        as a consequence the state MEMIF_BUSY_INTERNAL is not used.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Ea.IntrnlMangmntOper1</srcid><srcstatus/><internalId>207</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>21</internalId></specobject>

    <specobject>
      <id>Ea.ASR40.SWS_Ea_00180</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, V2.0.0</source>
      <version>1</version>
      <description>
        description=If development error detection is enabled for the module: if the current module
        status is MEMIF_BUSY_INTERNAL and if it is not possible to suspend or
        abort the internal management operation (because of data consistency 
        module implementation / hardware restrictions), the function Ea_Read
        shall reject the read request, raise the development error
        EA_E_BUSY_INTERNAL and return with E_NOT_OK.
      </description>
      <comment>
        There are no internal management operations in the Ea module implementation,
        as a consequence the state MEMIF_BUSY_INTERNAL is not used.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Ea.IntrnlMangmntOper1</srcid><srcstatus/><internalId>207</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>22</internalId></specobject>

    <specobject>
      <id>Ea.ASR40.SWS_Ea_00182</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, V2.0.0</source>
      <version>1</version>
      <description>
        description=If the write request addresses a block containing immediate data, the function
        Ea_Write shall accept the write request, even if the current module
        status is MEMIF_BUSY_INTERNAL and the internal management operation
        can't be suspended or aborted.
      </description>
      <comment>
        There are no internal management operations in the Ea module implementation,
        as a consequence the state MEMIF_BUSY_INTERNAL is not used.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Ea.IntrnlMangmntOper1</srcid><srcstatus/><internalId>207</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>23</internalId></specobject>

    <specobject>
      <id>Ea.ASR40.SWS_Ea_00183</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, V2.0.0</source>
      <version>1</version>
      <description>
        description=If development error detection is enabled for the module: if the current abort
        the internal management operation (because of data consistency / module
        implementation / hardware restrictions), the function Ea_Write shall
        reject the write request, raise the development error FEE_E_BUSY_INTERNAL
        and return with E_NOT_OK.
      </description>
      <comment>
        There are no internal management operations in the Ea module implementation,
        as a consequence the state MEMIF_BUSY_INTERNAL is not used.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Ea.IntrnlMangmntOper1</srcid><srcstatus/><internalId>207</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>24</internalId></specobject>

    <specobject>
      <id>Ea.ASR40.SWS_Ea_00184</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, V2.0.0</source>
      <version>1</version>
      <description>
        description=If development error detection is enabled for the module: if the current module
        status is MEMIF_BUSY_INTERNAL and if it is not possible to suspend or
        abort the internal management operation (because of data consistency 
        module implementation / hardware restrictions), the function
        Ea_InvalidateBlock shall reject the invalidation request, raise the
        development error EA_E_BUSY_INTERNAL and return with E_NOT_OK.
      </description>
      <comment>
        There are no internal management operations in the Ea module implementation,
        as a consequence the state MEMIF_BUSY_INTERNAL is not used.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Ea.IntrnlMangmntOper1</srcid><srcstatus/><internalId>207</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>25</internalId></specobject>

    <specobject>
      <id>Ea.ASR40.SWS_Ea_00185</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, V2.0.0</source>
      <version>1</version>
      <description>
        description=If development error detection is enabled for the module: if the current module
        status is MEMIF_BUSY_INTERNAL and if it is not possible to suspend or
        abort the internal management operation (because of data consistency 
        module implementation / hardware restrictions), the function
        Ea_EraseImmediateBlock shall reject the request, raise the development
        error EA_E_BUSY_INTERNAL and return with E_NOT_OK.
      </description>
      <comment>
        There are no internal management operations in the Ea module implementation,
        as a consequence the state MEMIF_BUSY_INTERNAL is not used.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Ea.IntrnlMangmntOper1</srcid><srcstatus/><internalId>207</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>26</internalId></specobject>

    <specobject>
      <id>Ea.ASR40.SWS_Ea_00186</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, V2.0.0</source>
      <version>1</version>
      <description>
        description=If the current module status is MEMIF_BUSY_INTERNAL and if the internal
        management operation can be suspended without jeopardizing the data
        consistency: the function Ea_MainFunction shall save all information
        which is necessary to resume the internal management operation, suspend
        the internal management operation and start processing the job requested
        by the upper layer.
      </description>
      <comment>
        There are no internal management operations in the Ea module implementation,
        as a consequence the state MEMIF_BUSY_INTERNAL is not used.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Ea.IntrnlMangmntOper1</srcid><srcstatus/><internalId>207</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>27</internalId></specobject>

    <specobject>
      <id>Ea.ASR40.SWS_Ea_00187</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, V2.0.0</source>
      <version>1</version>
      <description>
        description=If the current module status is MEMIF_BUSY_INTERNAL and if the internal
        management operation can be aborted without jeopardizing the data
        consistency: the function Ea_MainFunction shall save all information
        which is necessary to restart the internal management operation, abort
        the internal management operation and start processing the job requested
        by the upper layer.
      </description>
      <comment>
        There are no internal management operations in the Ea module implementation,
        as a consequence the state MEMIF_BUSY_INTERNAL is not used.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Ea.IntrnlMangmntOper1</srcid><srcstatus/><internalId>207</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>28</internalId></specobject>

    <specobject>
      <id>Ea.ASR40.SWS_Ea_00177</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, V2.0.0</source>
      <version>1</version>
      <description>
        The standardized common published parameters as required by BSW00402 in the
        General Requirements on Basic Software Modules [3] shall be published
        within the header file of this module and need to be provided in the BSW
        Module Description. The according module abbreviation can be found in the
        List of Basic Software Modules [1].
      </description>
      <comment>
        REVIEW: preprocessor symbols are provided via standard M4 macros.
        BSW Module Description are not yet provided by the AutoCore
        modules.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/Ea_Version.h.m4_1</srcid><srcstatus/><internalId>228</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/generate_swcd/swcd/Ea_Bswmd.arxml.m4_225</srcid><srcstatus/><internalId>260</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>29</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs">
    <specobject>
      <id>Ea.ECUC_Ea_00001</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        Name: EaSetModeSupported
        Parameter Type: Boolean
        Parent Containers: EaGeneral,
        Description: Compile switch to enable / disable the function Ea_SetMode. Tags: atp.Status=
        obsolete
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Ea.xdm.m4_540</srcid><srcstatus/><internalId>248</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>30</internalId></specobject>

    <specobject>
      <id>Ea.ECUC_Ea_00039</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        Name: EaGeneral
        Container Type: Container
        Description: General configuration of the EEPROM abstraction module. This container lists block 
        independent configuration parameters.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>31</internalId></specobject>

    <specobject>
      <id>Ea.ECUC_Ea_00040</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        Name: EaBlockConfiguration
        Container Type: Container
        Description: Configuration of block specific parameters for the EEPROM abstraction module.
        Lower Multiplicity: 1
        infinite
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        VSMD check to verify the existence of the containers listed in module schema
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>32</internalId></specobject>

    <specobject>
      <id>Ea.ECUC_Ea_00043</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        Name: EaPublishedInformation
        Container Type: Container
        Description: Additional published parameters not covered by CommonPublishedInformation 
        container.
        Introduction: Note that these parameters do not have any configuration class setting, since 
        they are published information.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>33</internalId></specobject>

    <specobject>
      <id>Ea.ECUC_Ea_00119</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        Name: EaNumberOfWriteCycles
        Parameter Type: Integer
        Parent Containers: EaBlockConfiguration,
        Description: Number of write cycles required for this block.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: 4294967295 (Type:
        Min-Value: 0 (Type:
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Ea.xdm.m4_190</srcid><srcstatus/><internalId>238</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>34</internalId></specobject>

    <specobject>
      <id>Ea.ECUC_Ea_00120</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        Name: EaDevErrorDetect
        Parameter Type: Boolean
        Parent Containers: EaGeneral,
        Description: Switches the development error detection and notification on or off.
        Introduction: * true: detection and notification is enabled. * false: detection and 
        notification is disabled.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/include/Ea_Cfg.h_20</srcid><srcstatus/><internalId>220</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>35</internalId></specobject>

    <specobject>
      <id>Ea.ECUC_Ea_00121</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        Name: EaNvmJobEndNotification
        Parameter Type: FunctionRef
        Parent Containers: EaGeneral,
        Description: Mapped to the job end notification routine provided by the upper layer module (
        NvM_JobEndNotification)
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: false
        Post-Build-Variant-Value: false
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        FunctionName Def Condition:Max-Length: , Min-Length
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Ea.xdm.m4_450</srcid><srcstatus/><internalId>244</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>36</internalId></specobject>

    <specobject>
      <id>Ea.ECUC_Ea_00122</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        Name: EaNvmJobErrorNotification
        Parameter Type: FunctionRef
        Parent Containers: EaGeneral,
        Description: Mapped to the job error notification routine provided by the upper layer module (
        NvM_JobErrorNotification)
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: false
        Post-Build-Variant-Value: false
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        FunctionName Def Condition:Max-Length: , Min-Length
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Ea.xdm.m4_474</srcid><srcstatus/><internalId>245</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>37</internalId></specobject>

    <specobject>
      <id>Ea.ECUC_Ea_00123</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        Name: EaPollingMode
        Parameter Type: Boolean
        Parent Containers: EaGeneral,
        Description: Pre-processor switch to enable and disable the polling mode for this module.
        Introduction: true: Polling mode enabled, callback functions (provided to EEP module) disabled.
        false: Polling mode disabled, callback functions (provided to EEP module) enabled.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Ea.EA123_Conf_PollingMode</srcid><srcstatus/><internalId>177</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>38</internalId></specobject>

    <specobject>
      <id>Ea.ECUC_Ea_00124</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        Name: EaVersionInfoApi
        Parameter Type: Boolean
        Parent Containers: EaGeneral,
        Description: Pre-processor switch to enable / disable the API to read out the modules version 
        information.
        Introduction: true: Version info API enabled. false: Version info API disabled.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Ea.xdm.m4_575</srcid><srcstatus/><internalId>249</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>39</internalId></specobject>

    <specobject>
      <id>Ea.ECUC_Ea_00125</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        Name: EaVirtualPageSize
        Parameter Type: Integer
        Parent Containers: EaGeneral,
        Description: The size in bytes to which logical blocks shall be aligned.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: 65535 (Type:
        Min-Value: 0 (Type:
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Ea.xdm.m4_606</srcid><srcstatus/><internalId>250</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>40</internalId></specobject>

    <specobject>
      <id>Ea.ECUC_Ea_00126</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        Name: EaBlockOverhead
        Parameter Type: Integer
        Parent Containers: EaPublishedInformation,
        Description: Management overhead per logical block in bytes.
        Introduction: Note: If the management overhead depends on the block size or block location a 
        formula has to be provided that allows the configurator to calculate the management overhead 
        correctly.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PUBLISHED-INFORMATION, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: 65535 (Type:
        Min-Value: 0 (Type:
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Ea.xdm.m4_767</srcid><srcstatus/><internalId>257</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>41</internalId></specobject>

    <specobject>
      <id>Ea.ECUC_Ea_00127</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        Name: EaPageOverhead
        Parameter Type: Integer
        Parent Containers: EaPublishedInformation,
        Description: Management overhead per page in bytes.
        Introduction: Note: If the management overhead depends on the block size or block location a 
        formula has to be provided that allows the configurator to calculate the management overhead 
        correctly.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PUBLISHED-INFORMATION, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: 65535 (Type:
        Min-Value: 0 (Type:
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Ea.xdm.m4_842</srcid><srcstatus/><internalId>259</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>42</internalId></specobject>

    <specobject>
      <id>Ea.ECUC_Ea_00128</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        Name: EaBlockSize
        Parameter Type: Integer
        Parent Containers: EaBlockConfiguration,
        Description: Size of a logical block in bytes.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: 65535 (Type:
        Min-Value: 1 (Type:
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Ea.xdm.m4_124</srcid><srcstatus/><internalId>236</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>43</internalId></specobject>

    <specobject>
      <id>Ea.ECUC_Ea_00129</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        Name: EaDeviceIndex
        Parameter Type: Reference
        Parent Containers: EaBlockConfiguration,
        Description: Reference to the device this block is stored in.
        Introduction: This reference is mutually exclusicve to EaMemAccAddressArea.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: false
        Post-Build-Variant-Value: false
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Destination: /AUTOSAR/EcucDefs/Eep/EepGeneral
        Destination type: ECUC-PARAM-CONF-CONTAINER-DEF
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Ea.xdm.m4_233</srcid><srcstatus/><internalId>239</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>44</internalId></specobject>

    <specobject>
      <id>Ea.ECUC_Ea_00130</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        Name: EaBlockNumber
        Parameter Type: Integer
        Parent Containers: EaBlockConfiguration,
        Description: Block identifier (handle)
        Introduction: 0x0000 and 0xFFFF shall not be used for block numbers (see SWS_Ea_00006). Range: 
        min = 2^NVM_DATASET_SELECTION_BITS max = 0xFFFF -2^NVM_DATASET_SELECTION_BITS Note: Depending 
        on the number of bits set aside for dataset selection several other block numbers shall also be 
        left out to ease implementation.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: true
        Max-Value: 65534 (Type:
        Min-Value: 1 (Type:
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        DESIGN:this is mapped to an internal block number that starts from 0 and is continuous.
        (there is a binary search on the list to find the internal number/index)
        The configuration parameter EaBlockNumber must be equal to the logical block
        number passed by the NVRAM manager. This means the EaBlockNumber can be different
        from the page number of the first page of the block.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30066</srcid><srcstatus/><internalId>265</internalId></linkedfrom><linkedfrom><srcid>TS_EA_NonLegSymbolicNames</srcid><srcstatus/><internalId>269</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>45</internalId></specobject>

    <specobject>
      <id>Ea.ECUC_Ea_00131</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        Name: EaImmediateData
        Parameter Type: Boolean
        Parent Containers: EaBlockConfiguration,
        Description: Marker for high priority data.
        Introduction: true: Block contains immediate data. false: Block does not contain immediate data.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Ea.xdm.m4_156</srcid><srcstatus/><internalId>237</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>46</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00005</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        Each configured logical block shall take up an integer multiple of the configured virtual page 
        size (see also Chapter 10.2.3, configuration parameter EA_VIRTUAL_PAGE_SIZE)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/src/Ea_Cfg.c_80</srcid><srcstatus/><internalId>222</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>47</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00006</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        The block numbers 0x0000 and 0xFFFF shall not be configurable for a logical block (see chapter 
        10.2.3, EaBlockNumber for details)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Ea.xdm.m4_114</srcid><srcstatus/><internalId>235</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>48</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00007</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        Depending on the implementation of the EA module and the exact address format used, the 
        functions of the EA module shall combine the 16bit block number and 16bit block offset to 
        derive the physical EEPROM address needed for the underlying EEPROM driver.
      </description>
      <comment>
        this is implicitly covered when API functions using
        block number and offset are covered
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Ea.c.m4_132</srcid><srcstatus/><internalId>230</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>49</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00017</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        The function Ea_Init shall shall set the module state from MEMIF_UNINIT to MEMIF_BUSY_INTERNAL 
        once it starts the module's initialization.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Ea.IntrnlMangmntOper1</srcid><srcstatus/><internalId>207</internalId></linkedfrom><linkedfrom><srcid>dev.Ea.IntrnlMangmntOper</srcid><srcstatus/><internalId>208</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>50</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00021</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        The function Ea_Read shall take the block number and offset and calculate the corresponding 
        memory read address.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30218</srcid><srcstatus/><internalId>300</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30226</srcid><srcstatus/><internalId>302</internalId></linkedfrom><linkedfrom><srcid>TS_EA_40001</srcid><srcstatus/><internalId>326</internalId></linkedfrom><linkedfrom><srcid>TS_EA_40002</srcid><srcstatus/><internalId>327</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>51</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00022</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        If the current module status is MEMIF_IDLE or if the current module status is MEMIF_BUSY 
        INTERNAL, the function Ea_Read shall accept the read request, copy the given / computed 
        parameters to module internal variables, initiate a read job, set the EA module status to 
        MEMIF_BUSY, set the job result to MEMIF_JOB_PENDING and return with E_OK.
      </description>
      <comment>
        There are no internal management operations in the Ea module implementation,
        as a consequence the state MEMIF_BUSY_INTERNAL is not used.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Ea.Ea_Read.Acceptance</srcid><srcstatus/><internalId>165</internalId></linkedfrom><linkedfrom><srcid>Ea.Ea_Read.AcceptanceBusyInternal</srcid><srcstatus/><internalId>166</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>52</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00024</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        The function Ea_Write shall take the block number and calculate the corresponding memory write 
        address. The block offset shall be fixed to zero for this address calculation.
      </description>
      <comment>
        IMPLEMENTATION test
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_40035</srcid><srcstatus/><internalId>325</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>53</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00025</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        If the current module status is MEMIF_IDLE or if the current module status is MEMIF_BUSY 
        INTERNAL, the function Ea_Write shall accept the write request, copy the given / computed 
        parameters to module internal variables, initiate a write job, set the EA module status to 
        MEMIF_BUSY, set the job result to MEMIF_JOB_PENDING and return with E_OK.
      </description>
      <comment>
        There are no internal management operations in the Ea module implementation,
        as a consequence the state MEMIF_BUSY_INTERNAL is not used.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Ea.Ea_Write.Acceptance</srcid><srcstatus/><internalId>167</internalId></linkedfrom><linkedfrom><srcid>Ea.Ea_Write.AcceptanceBusyInternal</srcid><srcstatus/><internalId>168</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>54</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00026</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        The EA module shall execute the write job of the function Ea_Write asynchronously within the EA 
        module's main function.
      </description>
      <comment>
        the statemachine is executed on tick of main function
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30219</srcid><srcstatus/><internalId>284</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30085</srcid><srcstatus/><internalId>286</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30083</srcid><srcstatus/><internalId>287</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>55</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00034</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        The function Ea_GetStatus shall return MEMIF_UNINIT if the module has not (yet) been 
        initialized.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30220</srcid><srcstatus/><internalId>323</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>56</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00035</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        The function Ea_GetJobResult shall return the status of the last job requested by the NVRAM 
        manager.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30092</srcid><srcstatus/><internalId>319</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>57</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00036</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        The function Ea_InvalidateBlock shall take the block number and calculate the corresponding 
        memory block address.
      </description>
      <comment>
        IMPLEMENTATION test
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_40035</srcid><srcstatus/><internalId>325</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>58</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00037</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        Depending on implementation, the function Ea_InvalidateBlock shall invalidate the block &lt;
        BlockNumber&gt; by either calling the erase function of the underlying device driver or changing 
        some module internal management information accordingly.
      </description>
      <comment>
        IMPLEMENTATION test
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_40035</srcid><srcstatus/><internalId>325</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>59</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00046</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        The Ea module shall manage for each block the information, whether this block is "correct" from 
        the point of view of the EA module or not. This consistency information shall only concern the 
        internal handling of the block, not the block's contents.
      </description>
      <comment>
        test: use cancel to interrupt a write, then read back
        DESIGN: use of VLEC
        Note: this can be tested as conformance since how this is managed is
        not specified but that a block in inconsistent on starting to write is.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30112</srcid><srcstatus/><internalId>293</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>60</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00047</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        When a block write operation is started the EA module shall mark the corresponding block as 
        inconsistent[1]. Upon the successful end of the block write operation, the EA module shall mark 
        the block as consistent (again)
      </description>
      <comment>
        test: use cancel to interrupt a write, then read back
        DESIGN: The consistency is ensured by use of VLEC
        Note: this can be tested as conformance since how this is managed is
        not specified but that a block in inconsistent on starting to write is.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_40200</srcid><srcstatus/><internalId>275</internalId></linkedfrom><linkedfrom><srcid>TS_EA_40201</srcid><srcstatus/><internalId>276</internalId></linkedfrom><linkedfrom><srcid>TS_EA_40202</srcid><srcstatus/><internalId>277</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30083</srcid><srcstatus/><internalId>287</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>61</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00051</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        The function Ea_JobEndNotification shall perform any necessary block management operations and 
        shall call the corresponding callback routine of the upper layer module (
        Ea_NvMJobEndNotification)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Ea.Callback.LimitUse</srcid><srcstatus/><internalId>164</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>62</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00053</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        The function Ea_JobErrorNotification shall perform any necessary block management and error 
        handling operations and shall call the corresponding callback routine of the upper layer module 
        Ea_NvMJobErrorNotification)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Ea.Callback.LimitUse</srcid><srcstatus/><internalId>164</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>63</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00054</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        The Ea module shall call the function defined in the configuration parameter 
        EaNvMJobEndNotification upon successful end of an asynchronous read operation after performing 
        all necessary internal management operations. Successful end of an asynchronous read operation 
        implies the read job is finished and the result is OK.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30219</srcid><srcstatus/><internalId>284</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30083</srcid><srcstatus/><internalId>287</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30081</srcid><srcstatus/><internalId>289</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30019</srcid><srcstatus/><internalId>291</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30225</srcid><srcstatus/><internalId>301</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30227</srcid><srcstatus/><internalId>304</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>64</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00055</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        The Ea module shall call the function defined in the configuration parameter 
        EaNvMJobErrorNotification upon failure of an asynchronous read operation after performing all 
        necessary internal management and error handling operations. Failure of an asynchronous read 
        operation implies the read job is finished and has failed (i.e. block invalid or inconsistent)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_40058</srcid><srcstatus/><internalId>272</internalId></linkedfrom><linkedfrom><srcid>TS_EA_40042</srcid><srcstatus/><internalId>273</internalId></linkedfrom><linkedfrom><srcid>TS_EA_40053</srcid><srcstatus/><internalId>274</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30095</srcid><srcstatus/><internalId>292</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30112</srcid><srcstatus/><internalId>293</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30214</srcid><srcstatus/><internalId>295</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30108</srcid><srcstatus/><internalId>296</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30109</srcid><srcstatus/><internalId>297</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30222</srcid><srcstatus/><internalId>305</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30230</srcid><srcstatus/><internalId>308</internalId></linkedfrom><linkedfrom><srcid>TS_EA_40041</srcid><srcstatus/><internalId>329</internalId></linkedfrom><linkedfrom><srcid>TS_EA_40043</srcid><srcstatus/><internalId>330</internalId></linkedfrom><linkedfrom><srcid>TS_EA_40044</srcid><srcstatus/><internalId>331</internalId></linkedfrom><linkedfrom><srcid>TS_EA_40045</srcid><srcstatus/><internalId>332</internalId></linkedfrom><linkedfrom><srcid>TS_EA_40046</srcid><srcstatus/><internalId>333</internalId></linkedfrom><linkedfrom><srcid>TS_EA_40047</srcid><srcstatus/><internalId>334</internalId></linkedfrom><linkedfrom><srcid>TS_EA_40048</srcid><srcstatus/><internalId>335</internalId></linkedfrom><linkedfrom><srcid>TS_EA_40050</srcid><srcstatus/><internalId>337</internalId></linkedfrom><linkedfrom><srcid>TS_EA_40051</srcid><srcstatus/><internalId>338</internalId></linkedfrom><linkedfrom><srcid>TS_EA_40052</srcid><srcstatus/><internalId>339</internalId></linkedfrom><linkedfrom><srcid>TS_EA_40054</srcid><srcstatus/><internalId>340</internalId></linkedfrom><linkedfrom><srcid>TS_EA_40055</srcid><srcstatus/><internalId>341</internalId></linkedfrom><linkedfrom><srcid>TS_EA_40056</srcid><srcstatus/><internalId>342</internalId></linkedfrom><linkedfrom><srcid>TS_EA_40057</srcid><srcstatus/><internalId>343</internalId></linkedfrom><linkedfrom><srcid>TS_EA_40059</srcid><srcstatus/><internalId>344</internalId></linkedfrom><linkedfrom><srcid>TS_EA_40060</srcid><srcstatus/><internalId>345</internalId></linkedfrom><linkedfrom><srcid>TS_EA_40061</srcid><srcstatus/><internalId>346</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations><ruleid>WRN.swuts.needscoverage.count</ruleid></oreqmViolations><covstatus>covered</covstatus><internalId>65</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00056</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        The function Ea_MainFunction shall asynchronously handle the read / write / erase / invalidate 
        jobs requested by the upper layer and internal management operations.
      </description>
      <comment>
        IMPLEMENTATION test
        this function executes the current state machine state
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_40035</srcid><srcstatus/><internalId>325</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>66</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00063</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        The function Ea_EraseImmediateBlock shall take the block number and calculate the corresponding 
        memory block address. The block offset shall be fixed to zero for this address calculation.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_40035</srcid><srcstatus/><internalId>325</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>67</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00064</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        The function Ea_EraseImmediateBlock shall ensure that the EA module can write immediate data. 
        Whether this involves physically erasing a memory area and therefore calling the erase function 
        of the underlying driver depends on the implementation.
      </description>
      <comment>
        Implementation specific test
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_40035</srcid><srcstatus/><internalId>325</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>68</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00065</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        If development error detection for the EA module is enabled, the function 
        Ea_EraseImmediateBlock shall check whether the addressed logical block is configured as 
        containing immediate data (configuration parameter EaImmediateData == TRUE). If not, the 
        function Ea_EraseImmediateBlock shall reject the erase request, raise the deleopment error 
        EA_E_INVALID_BLOCK_NO and return with E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30055</srcid><srcstatus/><internalId>311</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Ea.NoEaEraseImmediateBlock</srcid><srcstatus/><internalId>205</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>69</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00066</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        Only those bits of the 16bit block number, that do not denote a specific dataset or redundant 
        copy shall be used for address calculation.
      </description>
      <comment>
        This requirement is not applicable since for Ea the block management type is not known.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>70</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00068</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        Logical blocks must not overlap each other and must not be contained within one another.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30121</srcid><srcstatus/><internalId>298</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>71</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00072</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        The EA module shall execute the read operation asynchronously within the EA module's main 
        function.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30082</srcid><srcstatus/><internalId>318</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>72</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00073</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        The function Ea_GetStatus shall return MEMIF_BUSY_INTERNAL, if an internal management operation 
        is currently ongoing.
      </description>
      <comment>
        There are no internal management operations in the Ea module implementation,
        as a consequence the state MEMIF_BUSY_INTERNAL is not used.
        Ea_GetStatus shall return MEMIF_UNINIT, MEMIF_IDLE and MEMIF_BUSY only.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Ea.NoEaGetStatus</srcid><srcstatus/><internalId>202</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>73</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00074</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        The function Ea_MainFunction shall check, whether the block requested for reading has been 
        invalidated by the upper layer module. If so, the function Ea_MainFunction shall set the job 
        result to MEMIF_BLOCK_INVALID and call the job error notification function if configured.
      </description>
      <comment>
        IMPLEMENTATION test
        the handling is done in the appropriate state during the async read operation
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30228</srcid><srcstatus/><internalId>303</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30124</srcid><srcstatus/><internalId>320</internalId></linkedfrom><linkedfrom><srcid>TS_EA_40035</srcid><srcstatus/><internalId>325</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>74</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00075</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        The configuration of the Ea module shall be such that the virtual page size (defined in 
        EA_VIRTUAL_PAGE_SIZE) is an integer multiple of the physical page size, i.e. it is not allowed 
        to configure a smaller virtual page than the actual physical page size.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Ea.xdm.m4_638</srcid><srcstatus/><internalId>251</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>75</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00077</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>2</version>
      <description>
        If the current module status is MEMIF_BUSY (i.e. the request to cancel a pending job is 
        accepted by the function Ea_Cancel), the function Ea_Cancel shall call the cancel function of 
        the underlying EEPROM driver.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30113</srcid><srcstatus/><internalId>294</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30234</srcid><srcstatus/><internalId>306</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>76</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00078</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>2</version>
      <description>
        If the current module status is MEMIF_BUSY (i.e. the request to cancel a pending job is 
        accepted by the function Ea_Cancel), the function Ea_Cancel shall reset the EA module's 
        internal variables to make the module ready for a new job request. I.e. the function Ea_Cancel 
        shall set the job result to MEMIF_JOB_CANCELED and the module status to MEMIF_IDLE.
      </description>
      <comment>
        Conformance
        also should test:
        cancel a long read, an erase
        Note
        the eep cancel is called, on completion the ea notification may be called from eep
        (but this does nothing since only polling is supported in the implementation)
        whichever operation is in progress will poll eep and get jobresult (should be MEMIF_JOB_CANCELLED)
        this gets passed up to NvM if callback configured
        the module internal state shall be set to idle
        the Ea jobresult will be set to MEMIF_JOB_CANCELLED
        (this processing takes place in EA_NVM_JOB_ERROR_NOTIFICATION macro)
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30113</srcid><srcstatus/><internalId>294</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30234</srcid><srcstatus/><internalId>306</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>77</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00079</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        The configuration of the Ea module shall define the expected number of erase/write cycles for 
        each logical block in the configuration parameter EaNumberOfWriteCycles.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Ea.xdm.m4_190</srcid><srcstatus/><internalId>238</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>78</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00080</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        If the underlying EEPROM device or device driver does not provide at least the configured 
        number of erase/write cycles per physical memory cell (given in the parameter 
        EepAllowedWriteCycles), the EA module shall provide mechanisms to spread the erase/ write 
        access such that the physical device is not overstressed. This shall also apply to all 
        management data used internally by the EA module.
      </description>
      <comment>
        Design: use of VLEC
        Note: this was EA008, test links updated accordingly
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_40035</srcid><srcstatus/><internalId>325</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>79</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00083</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        Module | Header File | Imported Type 
        MemAcc | MemAcc.h | MemAcc_AddressAreaIdType (draft)
        MemAcc.h | MemAcc_AddressType (draft)
        MemAcc.h | MemAcc_DataType (draft)
        MemAcc.h | MemAcc_JobResultType (draft)
        MemAcc.h | MemAcc_LengthType (draft)
        MemIf | MemIf.h | MemIf_JobResultType (obsolete)
        MemIf.h | MemIf_ModeType (obsolete)
        MemIf.h | MemIf_StatusType 
        Std | Std_Types.h | Std_ReturnType 
        Std_Types.h | Std_VersionInfoType 
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/include/Ea_Cfg.h_6</srcid><srcstatus/><internalId>219</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/include/Ea.h_8</srcid><srcstatus/><internalId>223</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>80</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00084</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        Service Name | Ea_Init 
        Syntax 
        void Ea_Init (const Ea_ConfigType* ConfigPtr)
        Service ID [hex] | 0x00 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | ConfigPtr | Pointer to the selected configuration set.
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | Initializes the EEPROM abstraction module.
        Available via | Ea.h 
      </description>
      <comment>
        COMPILE test
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30066</srcid><srcstatus/><internalId>265</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30067</srcid><srcstatus/><internalId>266</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30068</srcid><srcstatus/><internalId>267</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>81</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00085</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        Service Name | Ea_SetMode (obsolete)
        Syntax 
        void Ea_SetMode (MemIf_ModeType Mode)
        Service ID [hex] | 0x01 
        Sync/Async | Asynchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | Mode | Desired mode for the underlying EEPROM driver 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | Function to switch the mode of the underlying EEPROM Driver Tags: atp.Status=
        obsolete 
        Available via | Ea.h 
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30066</srcid><srcstatus/><internalId>265</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30067</srcid><srcstatus/><internalId>266</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30068</srcid><srcstatus/><internalId>267</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30078</srcid><srcstatus/><internalId>285</internalId></linkedfrom><linkedfrom><srcid>TS_EA_SetMode</srcid><srcstatus/><internalId>309</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>82</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00086</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        Service Name | Ea_Read 
        Syntax 
        Std_ReturnType Ea_Read (uint16 BlockNumber, uint16 BlockOffset, uint8* DataBufferPtr, uint16 
        Length)
        Service ID [hex] | 0x02 
        Sync/Async | Asynchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | BlockNumber | Number of logical block, also denoting start address of that 
        block in EEPROM.
        BlockOffset | Read address offset inside the block 
        Length | Number of bytes to read 
        Parameters (inout) | None 
        Parameters (out) | DataBufferPtr | Pointer to data buffer 
        Return value | Std_ReturnType | E_OK: The requested job has been accepted by the module.
        E_NOT_OK: The requested job has not been accepted by the EA module.
        Description | Reads Length bytes of block Blocknumber at offset BlockOffset into the buffer 
        DataBufferPtr.
        Available via | Ea.h 
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30066</srcid><srcstatus/><internalId>265</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30067</srcid><srcstatus/><internalId>266</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30068</srcid><srcstatus/><internalId>267</internalId></linkedfrom><linkedfrom><srcid>TS_EA_40206</srcid><srcstatus/><internalId>281</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30080</srcid><srcstatus/><internalId>288</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30081</srcid><srcstatus/><internalId>289</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30112</srcid><srcstatus/><internalId>293</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30218</srcid><srcstatus/><internalId>300</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30225</srcid><srcstatus/><internalId>301</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30226</srcid><srcstatus/><internalId>302</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30235</srcid><srcstatus/><internalId>307</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations><ruleid>WRN.swuts.needscoverage.count</ruleid></oreqmViolations><covstatus>covered</covstatus><internalId>83</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00087</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        Service Name | Ea_Write 
        Syntax 
        Std_ReturnType Ea_Write (uint16 BlockNumber, const uint8* DataBufferPtr)
        Service ID [hex] | 0x03 
        Sync/Async | Asynchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | BlockNumber | Number of logical block, also denoting start address of that 
        block in EEPROM.
        DataBufferPtr | Pointer to data buffer 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | Std_ReturnType | E_OK: The requested job has been accepted by the module.
        E_NOT_OK: The requested job has not been accepted by the EA module.
        Description | Writes the contents of the DataBufferPtr to the block BlockNumber.
        Available via | Ea.h 
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Ea.Ea_Write.Service</srcid><srcstatus/><internalId>169</internalId></linkedfrom><linkedfrom><srcid>Ea.Ea_Write.DataBufferPtr.type</srcid><srcstatus/><internalId>170</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>84</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00088</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        Service Name | Ea_Cancel 
        Syntax 
        void Ea_Cancel (void)
        Service ID [hex] | 0x04 
        Sync/Async | Asynchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | None 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | Cancels the ongoing asynchronous operation.
        Available via | Ea.h 
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30066</srcid><srcstatus/><internalId>265</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30067</srcid><srcstatus/><internalId>266</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30068</srcid><srcstatus/><internalId>267</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30113</srcid><srcstatus/><internalId>294</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>85</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00089</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        Service Name | Ea_GetStatus 
        Syntax 
        MemIf_StatusType Ea_GetStatus (void)
        Service ID [hex] | 0x05 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | None 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | MemIf_StatusType | MEMIF_UNINIT: The EA module has not been initialized (yet).
        MEMIF_IDLE: The EA module is currently idle.MEMIF_BUSY: The EA module is currently busy.
        MEMIF_BUSY_INTERNAL: The EA module is currently busy with internal management operations.
        Description | Service to return the Status.
        Available via | Ea.h 
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30066</srcid><srcstatus/><internalId>265</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30067</srcid><srcstatus/><internalId>266</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30068</srcid><srcstatus/><internalId>267</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30018</srcid><srcstatus/><internalId>283</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30089</srcid><srcstatus/><internalId>290</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30235</srcid><srcstatus/><internalId>307</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>86</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00090</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        Service Name | Ea_GetJobResult 
        Syntax 
        MemIf_JobResultType Ea_GetJobResult (void)
        Service ID [hex] | 0x06 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | None 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | MemIf_JobResultType | MEMIF_JOB_OK: The last job has been finished successfully.
        MEMIF_JOB_PENDING: The last job is waiting for execution or currently being executed.
        MEMIF_JOB_CANCELED: The last job has been canceled (which means it failed).MEMIF_JOB_FAILED: 
        The last job was not finished successfully (it failed).MEMIF_BLOCK_INCONSISTENT: The requested 
        block is inconsistent, it may contain corrupted data.MEMIF_BLOCK_INVALID: The requested block 
        has been invalidated, the requested operation can not be performed.
        Description | Service to return the JobResult.
        Available via | Ea.h 
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30066</srcid><srcstatus/><internalId>265</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30067</srcid><srcstatus/><internalId>266</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30068</srcid><srcstatus/><internalId>267</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30235</srcid><srcstatus/><internalId>307</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30092</srcid><srcstatus/><internalId>319</internalId></linkedfrom><linkedfrom><srcid>TS_EA_40003</srcid><srcstatus/><internalId>328</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>87</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00091</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        Service Name | Ea_InvalidateBlock 
        Syntax 
        Std_ReturnType Ea_InvalidateBlock (uint16 BlockNumber)
        Service ID [hex] | 0x07 
        Sync/Async | Asynchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | BlockNumber | Number of logical block, also denoting start address of that 
        block in EEPROM.
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | Std_ReturnType | E_OK: The requested job has been accepted by the module.
        E_NOT_OK - only if DET is enabled: The requested job has not been accepted by the EA module.
        Description | Invalidates the block BlockNumber.
        Available via | Ea.h 
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30066</srcid><srcstatus/><internalId>265</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30067</srcid><srcstatus/><internalId>266</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30068</srcid><srcstatus/><internalId>267</internalId></linkedfrom><linkedfrom><srcid>TS_EA_40206</srcid><srcstatus/><internalId>281</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30123</srcid><srcstatus/><internalId>299</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30228</srcid><srcstatus/><internalId>303</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>88</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00092</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        Service Name | Ea_GetVersionInfo 
        Syntax 
        void Ea_GetVersionInfo (Std_VersionInfoType* VersionInfoPtr)
        Service ID [hex] | 0x08 
        Sync/Async | Synchronous 
        Reentrancy | Reentrant 
        Parameters (in) | None 
        Parameters (inout) | None 
        Parameters (out) | VersionInfoPtr | Pointer to standard version information structure.
        Return value | None 
        Description | Service to get the version information of this module.
        Available via | Ea.h 
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30066</srcid><srcstatus/><internalId>265</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30067</srcid><srcstatus/><internalId>266</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30068</srcid><srcstatus/><internalId>267</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30094</srcid><srcstatus/><internalId>282</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>89</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00093</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        Service Name | Ea_EraseImmediateBlock 
        Syntax 
        Std_ReturnType Ea_EraseImmediateBlock (uint16 BlockNumber)
        Service ID [hex] | 0x09 
        Sync/Async | Asynchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | BlockNumber | Number of logical block, also denoting start address of that 
        block in EEPROM.
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | Std_ReturnType | E_OK: The requested job has been accepted by the module.
        E_NOT_OK - only if DET is enabled: The requested job has not been accepted by the EA module.
        Description | Erases the block BlockNumber.
        Available via | Ea.h 
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30066</srcid><srcstatus/><internalId>265</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30067</srcid><srcstatus/><internalId>266</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30068</srcid><srcstatus/><internalId>267</internalId></linkedfrom><linkedfrom><srcid>TS_EA_40203</srcid><srcstatus/><internalId>278</internalId></linkedfrom><linkedfrom><srcid>TS_EA_40204</srcid><srcstatus/><internalId>279</internalId></linkedfrom><linkedfrom><srcid>TS_EA_40205</srcid><srcstatus/><internalId>280</internalId></linkedfrom><linkedfrom><srcid>TS_EA_40206</srcid><srcstatus/><internalId>281</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30019</srcid><srcstatus/><internalId>291</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30227</srcid><srcstatus/><internalId>304</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>90</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00094</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        Service Name | Ea_JobEndNotification 
        Syntax 
        void Ea_JobEndNotification (void)
        Service ID [hex] | 0x10 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | None 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | Service to report to this module the successful end of an asynchronous operation.
        Available via | Ea.h 
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30066</srcid><srcstatus/><internalId>265</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30067</srcid><srcstatus/><internalId>266</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30068</srcid><srcstatus/><internalId>267</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>91</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00095</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        Service Name | Ea_JobErrorNotification (obsolete)
        Syntax 
        void Ea_JobErrorNotification (void)
        Service ID [hex] | 0x11 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | None 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | Service to report to this module the failure of an asynchronous operation. Tags: 
        atp.Status=obsolete 
        Available via | Ea.h 
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30066</srcid><srcstatus/><internalId>265</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30067</srcid><srcstatus/><internalId>266</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30068</srcid><srcstatus/><internalId>267</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>92</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00096</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        Service Name | Ea_MainFunction 
        Syntax 
        void Ea_MainFunction (void)
        Service ID [hex] | 0x12 
        Description | Service to handle the requested jobs and the internal management operations.
        Available via | SchM_Ea.h 
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30066</srcid><srcstatus/><internalId>265</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30067</srcid><srcstatus/><internalId>266</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30068</srcid><srcstatus/><internalId>267</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>93</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00097</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        API Function | Header File | Description 
        Det_ReportRuntimeError | Det.h | Service to report runtime errors. If a callout has been 
        configured then this callout shall be called.
        Eep_GetStatus | Eep.h | Returns the EEPROM status.
        MemAcc_Cancel (draft) | MemAcc.h | Triggers a cancel operation of the pending job for the 
        address area referenced by the addressAreaId. Cancelling affects only jobs in pending state. 
        For any other states, the request will be ignored. Tags: atp.Status=draft 
        MemAcc_Erase (draft) | MemAcc.h | Triggers an erase job of the given area. Triggers an erase 
        job of the given area defined by targetAddress and length. The result of this service can be 
        retrieved using the Mem_GetJobResult API. If the erase operation was successful, the result of 
        the job is MEM_JOB_OK. If the erase operation failed, e.g. due to a hardware issue, the result 
        of the job is MEM_JOB_FAILED. Tags: atp.Status=draft 
        MemAcc_GetJobResult (draft) | MemAcc.h | Returns the consolidated job result of the address 
        area referenced by addressAreaId. Tags: atp.Status=draft 
        MemAcc_Read (draft) | MemAcc.h | Triggers a read job to copy data from the source address into 
        the referenced destination data buffer. The result of this service can be retrieved using the 
        MemAcc_GetJobResult API. If the read operation was successful, the result of the job is 
        MEMACC_MEM_OK. If the read operation failed, the result of the job is either MEMACC_MEM_FAILED 
        in case of a general error or MEMACC_MEM_ECC_CORRECTED/MEMACC_MEM_ECC_UNCORRECTED in case of a 
        correctable/uncorrectable ECC error. Tags: atp.Status=draft 
        MemAcc_Write (draft) | MemAcc.h | Triggers a write job to store the passed data to the provided 
        address area with given address and length. The result of this service can be retrieved using 
        the MemAcc_GetJobResult API. If the write operation was successful, the job result is 
        MEMACC_MEM_OK. If there was an issue writing the data, the result is MEMACC_MEM_FAILED. Tags: 
        atp.Status=draft 
      </description>
      <comment>
        This requirement is not applicable since this is the spec of mandatory interfaces
        needed from eep to achieve core functionality.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>94</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00098</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        API Function | Header File | Description 
        Det_ReportError | Det.h | Service to report development errors.
      </description>
      <comment>
        This requirement is not applicable. Specification of DET interface.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>95</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00099</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        Service Name | NvM_JobEndNotification 
        Syntax 
        void NvM_JobEndNotification (void)
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | None 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | Function to be used by the underlying memory abstraction to signal end of job 
        without error.
        Available via | NvM_MemIf.h 
      </description>
      <comment>
        This requirement is not applicable since this interfaces are implemented in NvM.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>96</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00100</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        Service Name | NvM_JobErrorNotification 
        Syntax 
        void NvM_JobErrorNotification (void)
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | None 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | Function to be used by the underlying memory abstraction to signal end of job 
        with error.
        Available via | NvM_MemIf.h 
      </description>
      <comment>
        This requirement is not applicable.
        spec of interface to NvM
        configurable item: EaNvmJobErrorNotification
        functional test required by EA055
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>97</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00104</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        The function Ea_MainFunction shall check the consistency of the logical block being read before 
        notifying the caller. If an inconsistency of the block is detected (see SWS_Ea_00046 and 
        SWS_Ea_00047) or if the requested block can't be found, the function Ea_MainFunction shall set 
        the job result to MEMIF_BLOCK_INCONSISTENT and call the error notification routine of the upper 
        layer if configured.
      </description>
      <comment>
        test with cancel on write and readback
        the handling is done in the appropriate state during the async read operation
        not directly in the main function
        Note: this can be tested as conformance since how this is managed is
        not specified but that a block in inconsistent on starting to write is.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_40200</srcid><srcstatus/><internalId>275</internalId></linkedfrom><linkedfrom><srcid>TS_EA_40201</srcid><srcstatus/><internalId>276</internalId></linkedfrom><linkedfrom><srcid>TS_EA_40202</srcid><srcstatus/><internalId>277</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30112</srcid><srcstatus/><internalId>293</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>98</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00117</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>2</version>
      <description>
        The types mentioned in SWS_Ea_00083 shall not be changed or extended for a specific EA module 
        or hardware platform.
      </description>
      <comment>
        This requirement is informational only.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>99</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00128</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        If initialization is finished within Ea_Init, the function Ea_Init shall set the module state 
        from MEMIF_BUSY_INTERNAL to MEMIF_IDLE once initialization has been successfully finished.
      </description>
      <comment>
        There are no internal management operations in the Ea module implementation,
        as a consequence the state MEMIF_BUSY_INTERNAL is not used.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Ea.NoEaInit</srcid><srcstatus/><internalId>206</internalId></linkedfrom><linkedfrom><srcid>dev.Ea.IntrnlMangmntOper1</srcid><srcstatus/><internalId>207</internalId></linkedfrom><linkedfrom><srcid>dev.Ea.IntrnlMangmntOper</srcid><srcstatus/><internalId>208</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>100</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00129</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        If development error detection is enabled for the module: the function Ea_SetMode shall check 
        if the module state is MEMIF_UNINIT. If this is the case, the function Ea_SetMode shall raise 
        the development error EA_E_UNINIT and return to the caller without executing the mode switch.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30220</srcid><srcstatus/><internalId>323</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>101</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00130</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        If development error detection for the module EA is enabled: the function Ea_Read shall check 
        if the module state is MEMIF_UNINIT. If this is the case, the function Ea_Read shall reject the 
        read request, raise the development error EA_E_UNINIT and return with E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30220</srcid><srcstatus/><internalId>323</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>102</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00131</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        If development error detection for the module EA is enabled: the function Ea_Write shall check 
        if the module state is MEMIF_UNINIT. If this is the case, the function Ea_Write shall reject 
        the write request, raise the development error EA_E_UNINIT and return with E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30220</srcid><srcstatus/><internalId>323</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>103</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00132</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        If development error detection for the module EA is enabled: the function Ea_Cancel shall check 
        if the module state is MEMIF_UNINIT. If this is the case, the function Ea_Cancel shall raise 
        the development error EA_E_UNINIT and return to the caller without changing any internal 
        variables.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30220</srcid><srcstatus/><internalId>323</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>104</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00134</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        If development error detection for the module EA is enabled: the function Ea_GetJobResult shall 
        check if the module state is MEMIF_UNINIT. If this is the case, the function Ea_GetJobResult 
        shall raise the development error EA_E_UNINIT and return with MEMIF_JOB_FAILED.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30220</srcid><srcstatus/><internalId>323</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>105</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00135</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        If development error detection for the module Ea is enabled: the function Ea_InvalidateBlock 
        shall check if the module state is MEMIF_UNINIT. If this is the case, the function 
        Ea_InvalidateBlock shall reject the invalidation request, raise the development error 
        EA_E_UNINIT and return with E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30220</srcid><srcstatus/><internalId>323</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>106</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00136</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        If development error detection for the module EA is enabled: the function 
        Ea_EraseImmediateBlock shall check if the module state is MEMIF_UNINIT. If this is the case, 
        the function Ea_EraseImmediateBlock shall reject the erase request, raise the development error 
        EA_E_UNINIT and return with E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30220</srcid><srcstatus/><internalId>323</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Ea.NoEaEraseImmediateBlock</srcid><srcstatus/><internalId>205</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>107</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00137</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        The EEPROM Abstraction (EA) shall only accept one job at a time, i.e. the module shall not 
        provide a queue for pending jobs (that's the job of the NVRAM Manager)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30236</srcid><srcstatus/><internalId>322</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>108</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00141</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        The Ea module shall call the function defined in the configuration parameter 
        EaNvMJobEndNotification upon successful end of an asynchronous write operation after performing 
        all necessary internal management operations. Successful end of an asynchronous write operation 
        implies the write job is finished, the result is OK and the block has been marked as valid.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30219</srcid><srcstatus/><internalId>284</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>109</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00142</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        The Ea module shall call the function defined in the configuration parameter 
        EaNvMJobEndNotification upon successful end of an asynchronous erase operation after performing 
        all necessary internal management operations. Successful end of an asynchronous erase operation 
        implies the erase job for immediate data is finished and the result is OK (see SWS_Ea_00064)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30019</srcid><srcstatus/><internalId>291</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>110</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00143</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        The Ea module shall call the function defined in the configuration parameter 
        EaNvMJobEndNotification upon successful end of an asynchronous block invalidation operation 
        after performing all necessary internal management operations. Successful end of an 
        asynchronous block invalidation operation implies the block invalidation job is finished and 
        the result is OK (i.e. the block has been marked as invalid)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30123</srcid><srcstatus/><internalId>299</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>111</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00144</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        The Ea module shall call the function defined in the configuration parameter 
        EaNvMJobErrorNotification upon failure of an asynchronous write operation after performing all 
        necessary internal management and error handling operations. Failure of an asynchronous write 
        operation implies the write job is finished and has failed and block has been marked as 
        inconsistent.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30108</srcid><srcstatus/><internalId>296</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>112</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00145</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        The Ea module shall call the function defined in the configuration parameter 
        EaNvMJobErrorNotification upon failure of an asynchronous erase operation after performing all 
        necessary internal management and error handling operations. Failure of an asynchronous erase 
        operation implies the erase job for immediate data is finished and has failed (see SWS_Ea_00064)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30109</srcid><srcstatus/><internalId>297</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>113</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00146</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        The Ea module shall call the function defined in the configuration parameter 
        EaNvMJobErrorNotification upon failure of an asynchronous block invalidation operation after 
        performing all necessary internal management and error handling operations. Failure of an 
        asynchronous block invalidation operation implies the block invalidation job is finished and 
        has failed.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_40049</srcid><srcstatus/><internalId>336</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>114</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00147</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        If development error detection is enabled for the module: the function Ea_Read shall check 
        whether the given block number is valid (i.e. inside the configured range). If this is not the 
        case, the function Ea_Read shall reject the read request, raise the development error 
        EA_E_INVALID_BLOCK_NO and return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30055</srcid><srcstatus/><internalId>311</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>115</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00148</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        If development error detection for the module EA is enabled: the function Ea_Write shall check 
        whether the given block number is valid (i.e. inside the configured range). If this is not the 
        case, the function Ea_Write shall reject the write request, raise the development error 
        EA_E_INVALID_BLOCK_NO and return with E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30055</srcid><srcstatus/><internalId>311</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>116</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00149</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        If development error detection for the module EA is enabled: the function Ea_InvalidateBlock 
        shall check whether the given block number is valid (i.e. it has been configured). If this is 
        not the case, the function Ea_InvalidateBlock shall reject the request, raise the development 
        error EA_E_INVALID_BLOCK_NO and return with E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30055</srcid><srcstatus/><internalId>311</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>117</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00150</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        The function Ea_SetMode shall be enabled / disabled via the pre-compile time parameter 
        EaSetModeSupported such that the function is completely removed from the code if it is disabled.
      </description>
      <comment>
        COMPILE test
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30066</srcid><srcstatus/><internalId>265</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30067</srcid><srcstatus/><internalId>266</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30068</srcid><srcstatus/><internalId>267</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>118</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00151</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        The function Ea_Write shall set the length parameter for the write job to the length configured 
        for this logical block.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30235</srcid><srcstatus/><internalId>307</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>119</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00152</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        If development error detection for the module EA is enabled: the function 
        Ea_EraseImmediateBlock shall check whether the given block number is valid (i.e. it has been 
        configured). If this is not the case, the function Ea_EraseImmediateBlock shall reject the 
        erase request, raise the development error EA_E_INVALID_BLOCK_NO and return with E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30055</srcid><srcstatus/><internalId>311</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Ea.NoEaEraseImmediateBlock</srcid><srcstatus/><internalId>205</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>120</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00153</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        If the job result is currently MEMIF_JOB_PENDING, the function Ea_JobEndNotification shall set 
        the job result to MEMIF_JOB_OK, else it shall leave the job result untouched.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Ea.Callback.LimitUse</srcid><srcstatus/><internalId>164</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>121</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00154</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        If the job result is currently MEMIF_JOB_PENDING, the function Ea_JobErrorNotification shall 
        set the job result to MEMIF_JOB_FAILED, else it shall leave the job result untouched.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Ea.Callback.LimitUse</srcid><srcstatus/><internalId>164</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>122</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00156</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>2</version>
      <description>
        The function Ea_GetStatus shall return MEMIF_IDLE if the module is neither processing a request 
        from the upper layer nor is it doing an internal management operation.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30089</srcid><srcstatus/><internalId>290</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30019</srcid><srcstatus/><internalId>291</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>123</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00157</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        The function Ea_GetStatus shall return MEMIF_BUSY if it is currently processing a request from 
        the upper layer.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30083</srcid><srcstatus/><internalId>287</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30089</srcid><srcstatus/><internalId>290</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Ea.NoEaGetStatus</srcid><srcstatus/><internalId>202</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>124</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00158</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        If a read request is rejected by the function Ea_Read, i.e. requirements SWS_Ea_00130, 
        SWS_Ea_00147, SWS_Ea_00167, SWS_Ea_00168, SWS_Ea_00169, SWS_Ea_00170 or SWS_Ea_00179 apply, the 
        function Ea_Read shall not change the current module status or job result.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30055</srcid><srcstatus/><internalId>311</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30237</srcid><srcstatus/><internalId>312</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30231</srcid><srcstatus/><internalId>313</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30232</srcid><srcstatus/><internalId>314</internalId></linkedfrom><linkedfrom><srcid>TS_EA_DetBusy</srcid><srcstatus/><internalId>315</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30220</srcid><srcstatus/><internalId>323</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>125</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00159</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        If a write request is rejected by the function Ea_Write, i.e. requirements SWS_Ea_00131, 
        SWS_Ea_00171, SWS_Ea_00148, SWS_Ea_00172 or SWS_Ea_00181 apply, the function Ea_Write shall not 
        change the current module status or job result.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30055</srcid><srcstatus/><internalId>311</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30237</srcid><srcstatus/><internalId>312</internalId></linkedfrom><linkedfrom><srcid>TS_EA_DetBusy</srcid><srcstatus/><internalId>315</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30220</srcid><srcstatus/><internalId>323</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Ea.NoEaWrite</srcid><srcstatus/><internalId>204</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>126</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00160</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        If the current module status is not MEMIF_BUSY (i.e. the request to cancel a pending job is 
        rejected by the function Ea_Cancel), the function Ea_Cancel shall not change the current module 
        status or job result.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30113</srcid><srcstatus/><internalId>294</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30234</srcid><srcstatus/><internalId>306</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Ea.NoEaCancel</srcid><srcstatus/><internalId>201</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>127</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00161</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        If an invalidation request is rejected by the function Ea_InvalidateBlock, i.e. requirements 
        SWS_Ea_00135, SWS_Ea_00149 or SWS_Ea_00175 apply, the function Ea_InvalidateBlock shall not 
        change the current module status or job result.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30055</srcid><srcstatus/><internalId>311</internalId></linkedfrom><linkedfrom><srcid>TS_EA_DetBusy</srcid><srcstatus/><internalId>315</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30220</srcid><srcstatus/><internalId>323</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>128</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00162</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        If an erase request for an immediate block is rejected by the function Ea_EraseImmediateBlock, 
        i.e. requirements SWS_Ea_00136, SWS_Ea_00176, SWS_Ea_00152 or SWS_Ea_00065 apply, the function 
        Ea_EraseImmediateBlock shall not change the current module status or job result.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30055</srcid><srcstatus/><internalId>311</internalId></linkedfrom><linkedfrom><srcid>TS_EA_DetBusy</srcid><srcstatus/><internalId>315</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30220</srcid><srcstatus/><internalId>323</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>129</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00164</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        If development error detection for the module EA is enabled: the function EA_GetVersionInfo 
        shall check that the given data pointer is valid (i.e. that it is not NULL). If this is not the 
        case, the function Ea_GetVersionInfo shall raise the development error EA_E_PARAM_POINTER.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30238</srcid><srcstatus/><internalId>317</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>130</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00165</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        The function Ea_SetMode shall check if the module state is MEMIF_BUSY. If this is the case, the 
        function Ea_SetMode shall raise the runtime error EA_E_BUSY and return to the caller without 
        executing the mode switch.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_DetBusy</srcid><srcstatus/><internalId>315</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>131</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00167</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        The function Ea_Read shall check if the module state is MEMIF_BUSY. If this is the case, the 
        function Ea_Read shall reject the read request, raise the runtime error EA_E_BUSY and return 
        with E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_DetBusy</srcid><srcstatus/><internalId>315</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>132</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00168</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        If development error detection is enabled for the module: the function Ea_Read shall check that 
        the given block offset is valid (i.e. that it is less than the block length configured for this 
        block). If this is not the case, the function Ea_Read shall reject the read request, raise the 
        development error EA_E_INVALID_BLOCK_OFS and return with E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30231</srcid><srcstatus/><internalId>313</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>133</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00169</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        If development error detection is enabled for the module: the function Ea_Read shall check that 
        the given length information is valid, i.e. that the requested length information plus the 
        block offset do not exceed the block end address (block start address plus configured block 
        length). If this is not the case, the function Ea_Read shall reject the read request, raise the 
        development error EA_E_INVALID_BLOCK_LEN and return with E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30232</srcid><srcstatus/><internalId>314</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>134</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00170</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        If development error detection is enabled for the module: the function Ea_Read shall check that 
        the given data pointer is valid (i.e. that it is not NULL). If this is not the case, the 
        function Ea_Read shall reject the read request, raise the development error EA_E_PARAM_POINTER 
        and return with E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30237</srcid><srcstatus/><internalId>312</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>135</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00171</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        The function Ea_Write shall check if the module state is MEMIF_BUSY. If this is the case, the 
        function Ea_Write shall reject the write request, raise the runtime error EA_E_BUSY and return 
        with E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_DetBusy</srcid><srcstatus/><internalId>315</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>136</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00172</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        If development error detection is enabled for the module: the function Ea_Write shall check 
        that the given data pointer is valid (i.e. that it is not NULL). If this is not the case, the 
        function Ea_Write shall reject the write request, raise the development error 
        EA_E_PARAM_POINTER and return with E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30237</srcid><srcstatus/><internalId>312</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>137</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00173</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        If the current module status is not MEMIF_BUSY (i.e. there is no job to cancel and therefore 
        the request to cancel a pending job is rejected by the function Ea_Cancel), the function 
        Ea_Cancel shall raise the runtime error EA_E_INVALID_CANCEL.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_DetInvalidCancel</srcid><srcstatus/><internalId>316</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>138</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00174</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        Only those jobs which have been requested directly by the upper layer shall have influence on 
        the job result returned by the function Ea_GetJobResult. I.e. jobs which are issued by the EA 
        module itself in the course of internal management operations shall not alter the job result.
      </description>
      <comment>
        There are no internal management operations in the Ea module implementation,
        as a consequence EA module will not issue any job in the course of internal
        management operations.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Ea.Ea_GetJobResult.JobsFromUpperLayer</srcid><srcstatus/><internalId>175</internalId></linkedfrom><linkedfrom><srcid>Ea.Ea_GetJobResult.JobsFromModule</srcid><srcstatus/><internalId>176</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>139</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00175</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        The function Ea_InvalidateBlock shall check if the module state is MEMIF_BUSY. If this is the 
        case, the function Ea_InvalidateBlock shall reject the invalidation request, raise the runtime 
        error EA_E_BUSY and return with E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_DetBusy</srcid><srcstatus/><internalId>315</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>140</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00176</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        The function Ea_EraseImmediateBlock shall check if the module state is MEMIF_BUSY. If this is 
        the case, the function shall reject the erase request, raise the runtime error EA_E_BUSY and 
        return with E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_DetBusy</srcid><srcstatus/><internalId>315</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>141</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00178</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        If the module initialization (started in the function Ea_Init) is completed in the module's 
        main function, the function Ea_MainFunction shall set the module status from 
        MEMIF_BUSY_INTERNAL to MEMIF_IDLE once initialization of the module has been successfully 
        finished.
      </description>
      <comment>
        This requirement is not applicable.
        Initialization of the module is not completed in module's main function. Initialization is
        finished with in Ea_Init() (see EA084).
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>142</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00999</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        These requirements are not applicable to this specification.
      </description>
      <comment>
        This requirement is informational only.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>143</internalId></specobject>

    <specobject>
      <id>Ea.ECUC_Ea_00132</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        Name: EaMainFunctionPeriod
        Parameter Type: FloatValue
        Parent Containers: EaGeneral,
        Description: The period between successive calls to the main function in seconds.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: INF (Type: OPEN)
        Min-Value: 0 (Type: OPEN)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Ea.xdm.m4_431</srcid><srcstatus/><internalId>243</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>144</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00179</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        If the current module status is MEMIF_UNINIT or MEMIF_BUSY, the function Ea_Read shall reject 
        the job request and return with E_NOT_OK.
      </description>
      <comment>
        In Ea module each of the state change is part of the Ea request
        and hence the module state cannot be MEMIF_BUSY_INTERNAL.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Ea.Ea_Read.RejectJobRqst</srcid><srcstatus/><internalId>171</internalId></linkedfrom><linkedfrom><srcid>Ea.Ea_Read.RejectJobRqstBusyInternal</srcid><srcstatus/><internalId>172</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Ea.NoEaRead</srcid><srcstatus/><internalId>203</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>145</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00188</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        If an internal management operation has been suspended because of a job request from the upper 
        layer, the function Ea_MainFunction shall resume this internal management operation once the 
        job requested by the upper layer has been finished.
      </description>
      <comment>
        There are no internal management operations in the Ea module implementation,
        as a consequence the state MEMIF_BUSY_INTERNAL is not used.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Ea.IntrnlMangmntOper1</srcid><srcstatus/><internalId>207</internalId></linkedfrom><linkedfrom><srcid>dev.Ea.IntrnlMangmntOper</srcid><srcstatus/><internalId>208</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>146</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00189</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        If an internal management operation has been aborted because of a job request from the upper 
        layer, the function Ea_MainFunction shall restart this internal management operation once the 
        job requested by the upper layer has been finished.
      </description>
      <comment>
        There are no internal management operations in the Ea module implementation,
        as a consequence the state MEMIF_BUSY_INTERNAL is not used.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Ea.IntrnlMangmntOper1</srcid><srcstatus/><internalId>207</internalId></linkedfrom><linkedfrom><srcid>dev.Ea.IntrnlMangmntOper</srcid><srcstatus/><internalId>208</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>147</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00190</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        Name | Ea_ConfigType 
        Kind | Structure 
        Elements | implementation specific 
        Type 
        Comment 
        Description | Configuration data structure of the Ea module.
        Available via | Ea.h 
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Ea.NoEaConfigType</srcid><srcstatus/><internalId>216</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>148</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00191</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        The configuration pointer ConfigPtr shall always have a NULL_PTR value.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Ea.NoNull_Ptr</srcid><srcstatus/><internalId>214</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>149</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00181</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        If the current module status is MEMIF_UNINIT or MEMIF_BUSY, the function Ea_Write shall reject 
        the job request and return with E_NOT_OK.
      </description>
      <comment>
        In Ea module implementation each of the internal state change is part of the Ea
        request, it cannot be considered as internal management operation and hence the module
        state cannot be MEMIF_BUSY_INTERNAL.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Ea.Ea_Write.RejectJobRqst</srcid><srcstatus/><internalId>173</internalId></linkedfrom><linkedfrom><srcid>Ea.Ea_Write.RejectJobRqstBusyInternal</srcid><srcstatus/><internalId>174</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Ea.NoEaWrite</srcid><srcstatus/><internalId>204</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>150</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00192</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        The function Ea_SetMode shall check if the module state is MEMIF_IDLE or MEMIF_BUSY_INTERNAL. 
        If this is the case the module shall accept the mode change request. The mode change shall be 
        executed asynchronously in the module's main function as soon as the module has finished the 
        internal management operation.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Ea_SetMode</srcid><srcstatus/><internalId>200</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>151</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00193</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        The Ea module shall execute the mode change request asynchronously within the Ea module's main 
        function.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Ea_SetMode</srcid><srcstatus/><internalId>200</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>152</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00194</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        The function Ea_InvalidateBlock shall check if the module state is MEMIF_IDLE or 
        MEMIF_BUSY_INTERNAL. If this is the case the module shall accept the invalidation request, set 
        the Ea module status to MEMIF_BUSY, set the job result to MEMIF_JOB_PENDING and return E_OK to 
        the caller.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>NoEa_InvalidateBlock</srcid><srcstatus/><internalId>199</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>153</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00195</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        The Ea module shall execute the block invalidation request asynchronously within the Ea module'
        s main function.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>NoEa_InvalidateBlock</srcid><srcstatus/><internalId>199</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>154</internalId></specobject>

    <specobject>
      <id>Ea.ECUC_Ea_00133</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        Module Name | EaEa 
        Module Description | Configuration of the Ea (EEPROM Abstraction) module.The module shall 
        abstract from the device specific addressing scheme and segmentation and provide the upper 
        layers with a virtual addressing scheme and segmentation as well as a 'virtually' unlimited 
        number of erase cycles.
        Post-Build Variant Support | false 
        Supported Config Variants | VARIANT-PRE-COMPILE 
        Included Containers 
        Container Name | Multiplicity | Scope / Dependency 
        EaBlockConfiguration | 1..* | Configuration of block specific parameters for the EEPROM 
        abstraction module.
        EaGeneral | 1 | General configuration of the EEPROM abstraction module. This container lists 
        block independent configuration parameters.
        EaPublishedInformation | 1 | Additional published parameters not covered by 
        CommonPublishedInformation container. Note that these parameters do not have any configuration 
        class setting, since they are published information.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Ea.xdm.m4_302</srcid><srcstatus/><internalId>241</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>155</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_91001</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        Type of error | Related error code | Error value 
        API service called while module is not (yet) initialized | EA_E_UNINIT.EA_E_UNINIT | 0x01 
        API service called with invalid block number | EA_E_INVALID_BLOCK_NO.EA_E_INVALID_BLOCK_NO | 
        0x02 
        API service called with invalid block offset | EA_E_INVALID_BLOCK_OFS.EA_E_INVALID_BLOCK_OFS 
        0x03 
        API service called with invalid pointer argument | EA_E_PARAM_POINTER.EA_E_PARAM_POINTER | 
        0x04 
        API service called with invalid block length information | EA_E_INVALID_BLOCK_LEN.
        EA_E_INVALID_BLOCK_LEN | 0x05 
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/Ea.h_94</srcid><srcstatus/><internalId>225</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>156</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_91002</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        Type of error | Related error code | Error value 
        API service called while module is busy | EA_E_BUSY.EA_E_BUSY | 0x06 
        Ea_Cancel called while no job was pending | EA_E_INVALID_CANCEL.EA_E_INVALID_CANCEL | 0x08 
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Ea.ErrorCheck</srcid><srcstatus/><internalId>211</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>157</internalId></specobject>

    <specobject>
      <id>Ea.ECUC_Ea_00134</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        Name: EaMemAccAddressressArea
        Parameter Type: Reference
        Parent Containers: EaBlockConfiguration,
        Description: Reference to the MemAccAddressAreaConfiguration. Tags: atp.Status=draft
        Introduction: This reference is mutually exclusicve to EaDeviceIndex.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: false
        Post-Build-Variant-Value: false
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Destination: /AUTOSAR/EcucDefs/MemAcc/MemAccAddressAreaConfiguration
        Destination type: ECUC-PARAM-CONF-CONTAINER-DEF
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Ea.Ea_MemAccAddress</srcid><srcstatus/><internalId>218</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Ea.xdm.m4_266</srcid><srcstatus/><internalId>240</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>158</internalId></specobject>

    <specobject>
      <id>Ea.ECUC_Ea_00135</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        Name: EaMinimumReadPageSize
        Parameter Type: Integer
        Parent Containers: EaGeneral,
        Description: Minimum Page size will be a multiple of the minimum page size. Ea shall align read 
        requests to this size. Tags: atp.Status=draft
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: 65535 (Type:
        Min-Value: 0 (Type:
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Ea.NoEaMinimumReadPageSize</srcid><srcstatus/><internalId>212</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Ea.xdm.m4_405</srcid><srcstatus/><internalId>242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>159</internalId></specobject>

    <specobject>
      <id>Ea.ECUC_Ea_00136</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        Name: EaBufferAlignmentValue
        Parameter Type: Reference
        Parent Containers: EaGeneral,
        Description: Parameter determines the alignment of the start address that Ea buffers need to 
        have. Tags: atp.Status=draft
        Introduction: Value shall be inherited from MemAccBufferAlignmentValue.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Destination: /AUTOSAR/EcucDefs/MemAcc/MemAccAddressAreaConfiguration
        Destination type: ECUC-PARAM-CONF-CONTAINER-DEF
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Ea.xdm.m4_666</srcid><srcstatus/><internalId>253</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Ea.Ea_MemAccUsage</srcid><srcstatus/><internalId>217</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>160</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00197</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        The Ea shall align internal buffers to the EaBufferAlignmentValueRef.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Ea.NoEaBufferAlignmentValueRef</srcid><srcstatus/><internalId>213</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>161</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00198</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        The Ea shall align read request to the EaMinimumReadPageSize.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Ea.NoEaMinimumReadPageSize</srcid><srcstatus/><internalId>212</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>162</internalId></specobject>

    <specobject>
      <id>Ea.SWS_Ea_00200</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_EEPROMAbstraction.pdf, R21-11</source>
      <version>1</version>
      <description>
        The function Ea_JobEndNotification shall perform any necessary block management and error 
        handling operations and shall call the corresponding callback routine of the upper layer module 
        Ea_NvMJobErrorNotification)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Ea.NoEa_JobEndNotification</srcid><srcstatus/><internalId>215</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>163</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs">
    <specobject>
      <id>Ea.Callback.LimitUse</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>The EB memory stack modules NvM, Ea, and Fee make only limited
        use of the callback calls from their underlying modules.
      </description>
      <needscoverage>
        <needscov><needsobj>lim</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Ea.IntegrationRestrictions</srcid><srcstatus/><internalId>0</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00153</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00154</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>122</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00051</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>62</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00053</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>63</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>164</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs">
    <specobject>
      <id>Ea.Ea_Read.Acceptance</id>
      <status>approved</status>
      <source>EB Refinement</source>
      <version>1</version>
      <description>
        If the current module status is MEMIF_IDLE, the function Ea_Read shall
        accept the read request, copy the given / computed parameters to module
        internal variables, initiate a read job, set the EA module status to MEMIF_BUSY,
        set the job result to MEMIF_JOB_PENDING and return with E_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30082</srcid><srcstatus/><internalId>318</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00022</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>52</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>165</internalId></specobject>

    <specobject>
      <id>Ea.Ea_Read.AcceptanceBusyInternal</id>
      <status>approved</status>
      <source>EB Refinement</source>
      <version>1</version>
      <description>
        If the current module status is MEMIF_BUSY INTERNAL and the internal
        management operation can be suspended or aborted, the function Ea_Read
        shall accept the read request, copy the given / computed parameters to
        module internal variables, initiate a read job, set the EA module status
        to MEMIF_BUSY, set the job result to MEMIF_JOB_PENDING and return with E_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Ea.IntrnlMangmntOper1</srcid><srcstatus/><internalId>207</internalId></linkedfrom><linkedfrom><srcid>dev.Ea.IntrnlMangmntOper</srcid><srcstatus/><internalId>208</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00022</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>52</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>166</internalId></specobject>

    <specobject>
      <id>Ea.Ea_Write.Acceptance</id>
      <status>approved</status>
      <source>EB Refinement</source>
      <version>1</version>
      <description>
        If the current module status is MEMIF_IDLE, the function Ea_Write shall
        accept the write request, copy the given / computed parameters to module internal
        variables, initiate a write job, set the EA module status to MEMIF_BUSY,
        set the job result to MEMIF_JOB_PENDING and return with E_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30219</srcid><srcstatus/><internalId>284</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30085</srcid><srcstatus/><internalId>286</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30083</srcid><srcstatus/><internalId>287</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00025</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>54</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>167</internalId></specobject>

    <specobject>
      <id>Ea.Ea_Write.AcceptanceBusyInternal</id>
      <status>approved</status>
      <source>EB Refinement</source>
      <version>1</version>
      <description>
        If the current module status is MEMIF_BUSY INTERNAL and the internal
        management operation can be suspended or aborted, the function
        Ea_Write shall accept the write request, copy the given / computed parameters
        to module internal variables, initiate a write job, set the EA module status
        to MEMIF_BUSY, set the job result to MEMIF_JOB_PENDING and return with E_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Ea.IntrnlMangmntOper1</srcid><srcstatus/><internalId>207</internalId></linkedfrom><linkedfrom><srcid>dev.Ea.IntrnlMangmntOper</srcid><srcstatus/><internalId>208</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00025</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>54</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>168</internalId></specobject>

    <specobject>
      <id>Ea.Ea_Write.Service</id>
      <status>approved</status>
      <source>Bugzilla #55397</source>
      <version>1</version>
      <description>
        Service name: Ea_Write Service ID[hex]: 0x03
        Sync/Async: Asynchronous Reentrancy: Non Reentrant
        Parameters (in): BlockNumber Number of logical block, also denoting start address of that block in EEPROM.
        DataBufferPtr Pointer to data buffer  Parameters (inout): None
        Parameters (out): None  Std_ReturnType E_OK: The requested job has been
        accepted by the module.  Return value: E_NOT_OK: The requested job has
        not been accepted by the EA module. Description: Writes the contents of
        the DataBufferPtr to the block BlockNumber.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30066</srcid><srcstatus/><internalId>265</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30067</srcid><srcstatus/><internalId>266</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30068</srcid><srcstatus/><internalId>267</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30219</srcid><srcstatus/><internalId>284</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30085</srcid><srcstatus/><internalId>286</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30083</srcid><srcstatus/><internalId>287</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30222</srcid><srcstatus/><internalId>305</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30235</srcid><srcstatus/><internalId>307</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30230</srcid><srcstatus/><internalId>308</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00087</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>84</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>169</internalId></specobject>

    <specobject>
      <id>Ea.Ea_Write.DataBufferPtr.type</id>
      <status>approved</status>
      <source>Bugzilla #55397</source>
      <version>1</version>
      <description>
        Service name: Ea_Write Syntax: Std_ReturnType Ea_Write(  uint16 BlockNumber,
        uint8* DataBufferPtr  )
      </description>
      <comment>
        Ea_Write DataBufferPtr is changed to const uint8* as against uint8*.
      </comment>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Ea.Ea_WriteDataBufferPtrType</srcid><srcstatus/><internalId>209</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00087</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>84</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>170</internalId></specobject>

    <specobject>
      <id>Ea.Ea_Read.RejectJobRqst</id>
      <status>approved</status>
      <source>EB Refinement</source>
      <version>1</version>
      <description>
        If the current module status is MEMIF_UNINIT or MEMIF_BUSY, the function Ea_Read shall reject
        the job request and return with E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_Ea_Read_n_Write</srcid><srcstatus/><internalId>310</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00179</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>145</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>171</internalId></specobject>

    <specobject>
      <id>Ea.Ea_Read.RejectJobRqstBusyInternal</id>
      <status>approved</status>
      <source>EB Refinement</source>
      <version>1</version>
      <description>
        If the current module status is MEMIF_BUSY_INTERNAL and the internal management operation
        can't be suspended or aborted, the function Ea_Read shall reject the job request
        and return with E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Ea.IntrnlMangmntOper1</srcid><srcstatus/><internalId>207</internalId></linkedfrom><linkedfrom><srcid>dev.Ea.IntrnlMangmntOper</srcid><srcstatus/><internalId>208</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00179</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>145</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>172</internalId></specobject>

    <specobject>
      <id>Ea.Ea_Write.RejectJobRqst</id>
      <status>approved</status>
      <source>EB Refinement</source>
      <version>1</version>
      <description>
        If the current module status is MEMIF_UNINIT or MEMIF_BUSY, the function Ea_Write shall reject
        the job request and return with E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_Ea_Read_n_Write</srcid><srcstatus/><internalId>310</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00181</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>173</internalId></specobject>

    <specobject>
      <id>Ea.Ea_Write.RejectJobRqstBusyInternal</id>
      <status>approved</status>
      <source>EB Refinement</source>
      <version>1</version>
      <description>
        If the current module status is MEMIF_BUSY_INTERNAL and the internal management operation
        can't be suspended or aborted, the function Ea_Write shall reject the job request
        and return with E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Ea.IntrnlMangmntOper1</srcid><srcstatus/><internalId>207</internalId></linkedfrom><linkedfrom><srcid>dev.Ea.IntrnlMangmntOper</srcid><srcstatus/><internalId>208</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00181</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>174</internalId></specobject>

    <specobject>
      <id>Ea.Ea_GetJobResult.JobsFromUpperLayer</id>
      <status>approved</status>
      <source>EB Refinement</source>
      <version>1</version>
      <description>
        Jobs which have been requested directly by the upper layer shall have
        influence on the job result returned by the function Ea_GetJobResult.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30225</srcid><srcstatus/><internalId>301</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30228</srcid><srcstatus/><internalId>303</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30227</srcid><srcstatus/><internalId>304</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00174</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>139</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>175</internalId></specobject>

    <specobject>
      <id>Ea.Ea_GetJobResult.JobsFromModule</id>
      <status>approved</status>
      <source>EB Refinement</source>
      <version>1</version>
      <description>
        Jobs which are issued by the EA module itself in the course of
        internal management operations shall not influence the job result returned by
        the function Ea_GetJobResult.
      </description>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Ea.IntrnlMangmntOper1</srcid><srcstatus/><internalId>207</internalId></linkedfrom><linkedfrom><srcid>dev.Ea.IntrnlMangmntOper</srcid><srcstatus/><internalId>208</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00174</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>139</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>176</internalId></specobject>

    <specobject>
      <id>Ea.EA123_Conf_PollingMode</id>
      <status>approved</status>
      <source>EB Refinement</source>
      <version>1</version>
      <description>
        When parameter "EaMemAccUsage" is set to 'true' then Polling mode shall be enabled.
      </description>
      <comment>
        In the current ASR21-11 draft the MemAcc module doesn't support callback notification.
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Ea.xdm.m4_498</srcid><srcstatus/><internalId>246</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/config/Ea.xdm.m4_534</srcid><srcstatus/><internalId>247</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Ea.ECUC_Ea_00123</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>38</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>177</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs">
    <specobject>
      <id>Ea.EB.BSWMDGeneration_1</id>
      <status>rejected</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The Ea module's generator shall generate a basic software
        module description (BSWMD) based on the Ea module's
        configuration containing information on the exclusive areas
        required by the Ea module's implementation.
      </description>
      <comment>
        This requirement is not applicable as the Ea module does not use any exclusive areas.
      </comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>178</internalId></specobject>

    <specobject>
      <id>Ea.EB.BSWMDGeneration_2</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The Ea module's generator shall generate a basic software
        module description (BSWMD) based on the Ea module's
        configuration containing information on the scheduled
        MainFunctions together with the scheduling period.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30067</srcid><srcstatus/><internalId>266</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30068</srcid><srcstatus/><internalId>267</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>179</internalId></specobject>

    <specobject>
      <id>Ea.EB.BSWMDGeneration_3</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The Ea module's BSWMD shall be generated using a generator
        mode named "generate_swcd".
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30067</srcid><srcstatus/><internalId>266</internalId></linkedfrom><linkedfrom><srcid>TS_EA_30068</srcid><srcstatus/><internalId>267</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>180</internalId></specobject>

    <specobject>
      <id>Ea.MainFunction.InitCheck</id>
      <status>approved</status>
      <source>EB: ASCCCB-1403</source>
      <version>1</version>
      <description>
        If a Main function of a un-initialized module is called from the
        BSW Scheduler, then it shall return immediately without
        performing any functionality and without raising any errors.
      </description>
      <comment>
        EB requirement is in line with the AUTOSAR 4.0 General SRS
        requirement BSW00450.
        https://issue.ebgroup.elektrobit.com/browse/ASCCCB-1403
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30221</srcid><srcstatus/><internalId>321</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>181</internalId></specobject>

    <specobject>
      <id>Ea.Mode.DET</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        When development error detection is enabled for the EA module; the
        function Ea_SetMode shall check that the given Mode is
        valid. If this is not the case the function shall reject the
        request, raise the development error EA_E_INVALID_MODE.
      </description>
      <comment>
        There is no DET for SetMode defined in Fee or Ea draft 4.0 specifications.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30233</srcid><srcstatus/><internalId>324</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>182</internalId></specobject>

    <specobject>
      <id>Ea.EB.Ea_Init</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The function Ea_Init shall set the module state from MEMIF_UNINIT to MEMIF_IDLE and the job
        result to MEMIF_JOB_OK after successful module initialization.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_30219</srcid><srcstatus/><internalId>284</internalId></linkedfrom><linkedfrom><srcid>TS_EA_40035</srcid><srcstatus/><internalId>325</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>183</internalId></specobject>

    <specobject>
      <id>Ea.EraseImmediate.Behaviour</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Erase Immediate shall mark the block as INCONSISTENT by writing the Information Flag (IF)
        with the INCONSISTENT pattern (0x55) and erasing the EEPROM memory locations corresponding
        to the next copy of the block.
      </description>
      <comment>
        For more details, please refer to AUTOSAR Bugzilla #58294.
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Ea.c.m4_1628</srcid><srcstatus/><internalId>232</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Ea.c.m4_1669</srcid><srcstatus/><internalId>233</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_40206</srcid><srcstatus/><internalId>281</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>184</internalId></specobject>

    <specobject>
      <id>Ea.EaMemAccUsage.Config</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The Ea shall provide a module specific boolean parameter named EaMemAccUsage with parent container EaGeneral
        to enable usage compatible with systems using MemAcc module.
        If this parameter is enabled, EaBufferAlignmentValue is also enabled.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Ea.xdm.m4_643</srcid><srcstatus/><internalId>252</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>185</internalId></specobject>

    <specobject>
      <id>Ea.EaMemAccUsage.ApiCompliance</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        When "EaMemAccUsage" parameter is set to "True" the Ea module shall use the MemAcc module APIs to
        access flash services.
      </description>
      <comment>
        This applies for the following APIs :
        - MemAcc_Write
        - MemAcc_Read
        - MemAcc_GetJobResult
        - MemAcc_GetJobStatus
        - MemAcc_Cancel
        - MemAcc_Erase
        - MemAcc_BlankCheck
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/include/Ea_Cfg.h_114</srcid><srcstatus/><internalId>221</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_MemAccApiCompliance</srcid><srcstatus/><internalId>270</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>186</internalId></specobject>

    <specobject>
      <id>Ea.EaMemAccUsage.GetJobResultCompatibility</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        When "EaMemAccUsage" parameter is set to "True" the Ea module shall reinterpret the
        MemAcc_GetJobResult return "MemAcc_JobResultType" into "MemIf_JobResultType".
      </description>
      <comment>
      </comment>
       <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Ea.c.m4_579</srcid><srcstatus/><internalId>231</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_EA_MemAccJobResultCompatibility</srcid><srcstatus/><internalId>271</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>187</internalId></specobject>

    <specobject>
      <id>Ea.EaMemAccUsage.BufferAlignmentValue</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        When "EaMemAccUsage" parameter is set to "True" the Ea module shall only support
        'BufferAlignmentValue' parameters of value 1, 2,4 and 8 bytes..
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Ea.xdm.m4_667</srcid><srcstatus/><internalId>254</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>188</internalId></specobject>

    <specobject>
      <id>Ea.EaMemAccUsage.DriverErasedValue</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        When "EaMemAccUsage" parameter is set to "True" the parameter 'EaDriverErasedValue' shall defined 
        the value the driver will return for erased cells.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Ea.xdm.m4_696</srcid><srcstatus/><internalId>255</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>189</internalId></specobject>

    <specobject>
      <id>Ea.EaMemAccUsage.DriverAllowedWriteCycles</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        When "EaMemAccUsage" parameter is set to "True" the parameter 'DriverAllowedWriteCycles' shall defined 
        the number of write cycles allowed by the driver.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Ea.xdm.m4_725</srcid><srcstatus/><internalId>256</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>190</internalId></specobject>
  </specobjects>
    <specobjects doctype="man">
    <specobject>
      <id>TS_Ea_ResourceConsumption</id>
      <status>approved</status>
      <source>EB manual test</source>
      <version>1</version>
      <description>
        01: Get RAM/ROM consumption of Ea_ComTest_ResourceConsumption
        02 VP(Ea.swdd.ROMConsumption_RefCfg1): Check the ROM consumption of
           the test run against the threshold specified in the requirement.
        03 VP(Ea.swdd.RAMConsumption_RefCfg1): Check the RAM consumption of
           the test run against the threshold specified in the requirement.
        Action if test any verification point is not fulfilled:
        If the consumption exceeds the threshold, an analysis shall be started to find the cause
        of the additional resource consumption.
        The result of the analysis shall trigger either:
        * an update of the resource view in the design and the existing threshold if there is a
          rationale for the additional resource consumption.
        OR
        * measurements to reduce the additional resource consumption below the existing threshold
          if there is no rationale for the additional resource consumption.
      </description>
      <providescoverage>
        <provcov>
          <linksto>Ea.swdd.ROMConsumption_RefCfg1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>261</internalId></provcov>
        <provcov>
          <linksto>Ea.swdd.RAMConsumption_RefCfg1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>262</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>191</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs">

    <specobject>
      <id>Ea.EB.DBGINST001</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Every public API of the module shall have debug instrumentation.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Ea_DBGINST_001</srcid><srcstatus/><internalId>263</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>192</internalId></specobject>

    <specobject>
      <id>Ea.EB.DBGINST002</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The parameter of a API shall be available in the entry instrumentation.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Ea_DBGINST_001</srcid><srcstatus/><internalId>263</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>193</internalId></specobject>

    <specobject>
      <id>Ea.EB.DBGINST003</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The parameter of a API shall be available in the exit instrumentation.
        If the API has a return value, the very first parameter of the macro shall contain the expected return value.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Ea_DBGINST_001</srcid><srcstatus/><internalId>263</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>194</internalId></specobject>

    <specobject>
      <id>Ea.EB.DBGINST004</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The default implementation of the debug instrumentation shall be an empty macro.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Ea_DBGINST_001</srcid><srcstatus/><internalId>263</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>195</internalId></specobject>

    <specobject>
      <id>Ea.EB.DBGINST005</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The module shall include the header files Base_Dbg.h in order to allow changing the default implementation of the debug instrumentation.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Ea_DBGINST_001</srcid><srcstatus/><internalId>263</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>196</internalId></specobject>

  </specobjects>
    <specobjects doctype="swurs">

    <specobject>
      <id>Ea.EB.Interface.Consistency</id>
       <status>approved</status>
       <source>EB</source>
       <version>1</version>
       <description>
        The module shall provide a mechanism to guarantee consistency of interfaces and
        types between its implementation and its code stub.
       </description>
       <comment>
        The code stub of a module shall provide the same external view than the module itself.
        This is mandatory because unit test of modules test against the code stubs of
        adjacent modules. Inconsistent stubs may result in the situation that incompatible
        interfaces are not detected as unit test stage.
       </comment>
       <verifycrit>
        Create a compile test with two permutations that call all interfaces of a module
        (in both permutations).
        p0: Behave like a regular compile test; call the module generator and compile against
        the implementation of the module.
        p1: Do not generate module code and do not compile the implementation of the module.
        Instead the module shall be replaced with its own code stub.
       </verifycrit>
       <needscoverage>
          <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Ea_VerifyCodeStub</srcid><srcstatus/><internalId>264</internalId></linkedfrom></coveredby></needscov>
       <containerCovstatus>covered</containerCovstatus></needscoverage>
       
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>197</internalId></specobject>

  </specobjects>
    <specobjects doctype="dev">
    <specobject>
      <id>NoEa_SetMode</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>43</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.ASR40.SWS_Ea_00020</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>5</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>198</internalId></specobject>
    <specobject>
      <id>NoEa_InvalidateBlock</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>58</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00194</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00195</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>154</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>199</internalId></specobject>
    <specobject>
      <id>Ea_SetMode</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>73</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00193</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>152</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00192</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>151</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>200</internalId></specobject>
    <specobject>
      <id>dev.Ea.NoEaCancel</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>89</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00160</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>127</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>201</internalId></specobject>
    <specobject>
      <id>dev.Ea.NoEaGetStatus</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>111</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00157</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>124</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00073</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>73</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>202</internalId></specobject>
    <specobject>
      <id>dev.Ea.NoEaRead</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>127</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00179</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>145</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>203</internalId></specobject>
    <specobject>
      <id>dev.Ea.NoEaWrite</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>148</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00181</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00159</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>126</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>204</internalId></specobject>
    <specobject>
      <id>dev.Ea.NoEaEraseImmediateBlock</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>164</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00136</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>107</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00152</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00065</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>69</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>205</internalId></specobject>
    <specobject>
      <id>dev.Ea.NoEaInit</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>184</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00128</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>100</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>206</internalId></specobject>
    <specobject>
      <id>dev.Ea.IntrnlMangmntOper1</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>211</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.Ea_Read.AcceptanceBusyInternal</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>166</internalId></provcov>
        <provcov>
          <linksto>Ea.Ea_Write.AcceptanceBusyInternal</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>168</internalId></provcov>
        <provcov>
          <linksto>Ea.Ea_Read.RejectJobRqstBusyInternal</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>172</internalId></provcov>
        <provcov>
          <linksto>Ea.Ea_Write.RejectJobRqstBusyInternal</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>174</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00189</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00188</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>146</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00128</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>100</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00017</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>50</internalId></provcov>
        <provcov>
          <linksto>Ea.Ea_GetJobResult.JobsFromModule</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>176</internalId></provcov>
        <provcov>
          <linksto>Ea.ASR40.SWS_Ea_00186</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>27</internalId></provcov>
        <provcov>
          <linksto>Ea.ASR40.SWS_Ea_00187</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>28</internalId></provcov>
        <provcov>
          <linksto>Ea.ASR40.SWS_Ea_00182</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>23</internalId></provcov>
        <provcov>
          <linksto>Ea.ASR40.SWS_Ea_00183</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>24</internalId></provcov>
        <provcov>
          <linksto>Ea.ASR40.SWS_Ea_00184</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>25</internalId></provcov>
        <provcov>
          <linksto>Ea.ASR40.SWS_Ea_00185</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>26</internalId></provcov>
        <provcov>
          <linksto>Ea.ASR40.SWS_Ea_00166</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>21</internalId></provcov>
        <provcov>
          <linksto>Ea.ASR40.SWS_Ea_00180</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>22</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>207</internalId></specobject>
    <specobject>
      <id>dev.Ea.IntrnlMangmntOper</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>240</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.Ea_Read.AcceptanceBusyInternal</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>166</internalId></provcov>
        <provcov>
          <linksto>Ea.Ea_Write.AcceptanceBusyInternal</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>168</internalId></provcov>
        <provcov>
          <linksto>Ea.Ea_Read.RejectJobRqstBusyInternal</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>172</internalId></provcov>
        <provcov>
          <linksto>Ea.Ea_Write.RejectJobRqstBusyInternal</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>174</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00189</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00188</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>146</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00128</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>100</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00017</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>50</internalId></provcov>
        <provcov>
          <linksto>Ea.Ea_GetJobResult.JobsFromModule</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>176</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>208</internalId></specobject>
    <specobject>
      <id>dev.Ea.Ea_WriteDataBufferPtrType</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>265</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.Ea_Write.DataBufferPtr.type</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>170</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>209</internalId></specobject>
    <specobject>
      <id>dev.Ea_GetVersionInfo_NoMacro</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>287</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.ASR40.SWS_Ea_00082</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>16</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>210</internalId></specobject>
    <specobject>
      <id>dev.Ea.ErrorCheck</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>308</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_91002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>157</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>211</internalId></specobject>
    <specobject>
      <id>dev.Ea.NoEaMinimumReadPageSize</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>326</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.ECUC_Ea_00135</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>159</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00198</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>162</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>212</internalId></specobject>
    <specobject>
      <id>dev.Ea.NoEaBufferAlignmentValueRef</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>343</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00197</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>161</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>213</internalId></specobject>
    <specobject>
      <id>dev.Ea.NoNull_Ptr</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>360</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00191</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>149</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>214</internalId></specobject>
    <specobject>
      <id>dev.Ea.NoEa_JobEndNotification</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>377</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00200</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>163</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>215</internalId></specobject>
    <specobject>
      <id>dev.Ea.NoEaConfigType</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>395</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00190</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>148</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>216</internalId></specobject>
    <specobject>
      <id>dev.Ea.Ea_MemAccUsage</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>409</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.ECUC_Ea_00136</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>160</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>217</internalId></specobject>
    <specobject>
      <id>dev.Ea.Ea_MemAccAddress</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>426</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.ECUC_Ea_00134</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>158</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>218</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/generate/include/Ea_Cfg.h_6</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/src/Autosar/generate/include/Ea_Cfg.h</sourcefile>
      <sourceline>6</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00083</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>80</internalId></provcov>
        <provcov>
          <linksto>Ea.ASR40.SWS_Ea_00113</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>17</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>219</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate/include/Ea_Cfg.h_20</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/src/Autosar/generate/include/Ea_Cfg.h</sourcefile>
      <sourceline>20</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.ECUC_Ea_00120</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>35</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>220</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate/include/Ea_Cfg.h_114</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/src/Autosar/generate/include/Ea_Cfg.h</sourcefile>
      <sourceline>114</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.EaMemAccUsage.ApiCompliance</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>186</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>221</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/generate/src/Ea_Cfg.c_80</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/src/Autosar/generate/src/Ea_Cfg.c</sourcefile>
      <sourceline>80</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>47</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>222</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/include/Ea.h_8</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/src/Autosar/include/Ea.h</sourcefile>
      <sourceline>8</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00083</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>80</internalId></provcov>
        <provcov>
          <linksto>Ea.ASR40.SWS_Ea_00113</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>17</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>223</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/Ea.h_12</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/src/Autosar/include/Ea.h</sourcefile>
      <sourceline>12</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.ASR40.SWS_Ea_00113</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>17</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>224</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/Ea.h_94</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/src/Autosar/include/Ea.h</sourcefile>
      <sourceline>94</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.ASR40.SWS_Ea_00049</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>8</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_91001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>156</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>225</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/include/Ea_Cbk.h_2</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/src/Autosar/include/Ea_Cbk.h</sourcefile>
      <sourceline>2</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.ASR40.SWS_Ea_00114</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>18</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>226</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/include/Ea_Trace.h.m4_16</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/src/Autosar/include/Ea_Trace.h.m4</sourcefile>
      <sourceline>16</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.ASR40.SWS_Ea_00155</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>19</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>227</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/include/Ea_Version.h.m4_1</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/src/Autosar/include/Ea_Version.h.m4</sourcefile>
      <sourceline>1</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.ASR40.SWS_Ea_00177</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>29</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>228</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/src/Ea.c.m4_5</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/src/Autosar/src/Ea.c.m4</sourcefile>
      <sourceline>5</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.ASR40.SWS_Ea_00113</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>17</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>229</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Ea.c.m4_132</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/src/Autosar/src/Ea.c.m4</sourcefile>
      <sourceline>132</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00007</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>49</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>230</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Ea.c.m4_579</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/src/Autosar/src/Ea.c.m4</sourcefile>
      <sourceline>579</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.EaMemAccUsage.GetJobResultCompatibility</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>187</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>231</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Ea.c.m4_1628</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/src/Autosar/src/Ea.c.m4</sourcefile>
      <sourceline>1628</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.EraseImmediate.Behaviour</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>184</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>232</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Ea.c.m4_1669</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/src/Autosar/src/Ea.c.m4</sourcefile>
      <sourceline>1669</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.EraseImmediate.Behaviour</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>184</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>233</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/config/Ea.xdm.m4_40</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/src/Autosar/config/Ea.xdm.m4</sourcefile>
      <sourceline>40</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.ASR40.SWS_Ea_00163</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>20</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>234</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Ea.xdm.m4_114</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/src/Autosar/config/Ea.xdm.m4</sourcefile>
      <sourceline>114</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00006</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>48</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>235</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Ea.xdm.m4_124</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/src/Autosar/config/Ea.xdm.m4</sourcefile>
      <sourceline>124</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.ECUC_Ea_00128</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>43</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>236</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Ea.xdm.m4_156</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/src/Autosar/config/Ea.xdm.m4</sourcefile>
      <sourceline>156</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.ECUC_Ea_00131</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>46</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>237</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Ea.xdm.m4_190</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/src/Autosar/config/Ea.xdm.m4</sourcefile>
      <sourceline>190</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00079</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>78</internalId></provcov>
        <provcov>
          <linksto>Ea.ECUC_Ea_00119</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>34</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>238</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Ea.xdm.m4_233</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/src/Autosar/config/Ea.xdm.m4</sourcefile>
      <sourceline>233</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.ECUC_Ea_00129</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>44</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>239</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Ea.xdm.m4_266</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/src/Autosar/config/Ea.xdm.m4</sourcefile>
      <sourceline>266</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.ECUC_Ea_00134</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>158</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>240</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Ea.xdm.m4_302</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/src/Autosar/config/Ea.xdm.m4</sourcefile>
      <sourceline>302</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.ECUC_Ea_00133</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>241</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Ea.xdm.m4_405</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/src/Autosar/config/Ea.xdm.m4</sourcefile>
      <sourceline>405</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.ECUC_Ea_00135</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>159</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>242</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Ea.xdm.m4_431</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/src/Autosar/config/Ea.xdm.m4</sourcefile>
      <sourceline>431</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.ECUC_Ea_00132</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>144</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>243</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Ea.xdm.m4_450</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/src/Autosar/config/Ea.xdm.m4</sourcefile>
      <sourceline>450</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.ECUC_Ea_00121</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>36</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>244</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Ea.xdm.m4_474</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/src/Autosar/config/Ea.xdm.m4</sourcefile>
      <sourceline>474</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.ECUC_Ea_00122</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>37</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>245</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Ea.xdm.m4_498</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/src/Autosar/config/Ea.xdm.m4</sourcefile>
      <sourceline>498</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.EA123_Conf_PollingMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>177</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>246</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Ea.xdm.m4_534</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/src/Autosar/config/Ea.xdm.m4</sourcefile>
      <sourceline>534</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.EA123_Conf_PollingMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>177</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>247</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Ea.xdm.m4_540</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/src/Autosar/config/Ea.xdm.m4</sourcefile>
      <sourceline>540</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.ECUC_Ea_00001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>30</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>248</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Ea.xdm.m4_575</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/src/Autosar/config/Ea.xdm.m4</sourcefile>
      <sourceline>575</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.ECUC_Ea_00124</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>39</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>249</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Ea.xdm.m4_606</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/src/Autosar/config/Ea.xdm.m4</sourcefile>
      <sourceline>606</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.ECUC_Ea_00125</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>40</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>250</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Ea.xdm.m4_638</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/src/Autosar/config/Ea.xdm.m4</sourcefile>
      <sourceline>638</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00075</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>75</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>251</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Ea.xdm.m4_643</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/src/Autosar/config/Ea.xdm.m4</sourcefile>
      <sourceline>643</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.EaMemAccUsage.Config</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>185</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>252</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Ea.xdm.m4_666</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/src/Autosar/config/Ea.xdm.m4</sourcefile>
      <sourceline>666</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.ECUC_Ea_00136</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>160</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>253</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Ea.xdm.m4_667</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/src/Autosar/config/Ea.xdm.m4</sourcefile>
      <sourceline>667</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.EaMemAccUsage.BufferAlignmentValue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>188</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>254</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Ea.xdm.m4_696</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/src/Autosar/config/Ea.xdm.m4</sourcefile>
      <sourceline>696</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.EaMemAccUsage.DriverErasedValue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>255</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Ea.xdm.m4_725</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/src/Autosar/config/Ea.xdm.m4</sourcefile>
      <sourceline>725</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.EaMemAccUsage.DriverAllowedWriteCycles</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>190</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>256</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Ea.xdm.m4_767</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/src/Autosar/config/Ea.xdm.m4</sourcefile>
      <sourceline>767</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.ECUC_Ea_00126</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>41</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>257</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Ea.xdm.m4_799</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/src/Autosar/config/Ea.xdm.m4</sourcefile>
      <sourceline>799</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.ASR40.ECUC_Ea_00070</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>258</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Ea.xdm.m4_842</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/src/Autosar/config/Ea.xdm.m4</sourcefile>
      <sourceline>842</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.ECUC_Ea_00127</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>42</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>259</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/generate_swcd/swcd/Ea_Bswmd.arxml.m4_225</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/src/Autosar/generate_swcd/swcd/Ea_Bswmd.arxml.m4</sourcefile>
      <sourceline>225</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Ea.ASR40.SWS_Ea_00177</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>29</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>260</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd">
    <specobject>
      <id>Ea.swdd.ROMConsumption_RefCfg1</id>
      <status>approved</status>
      <source>Elektrobit Automotive GmbH</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/doc/project/design/basic_software/resource_view.xml</sourcefile>
      <sourceline>132</sourceline>
      <version>1</version>
      <description>
                        The ROM consumption for reference configuration must not exceed 4500 bytes.
                      </description>
      <rationale>
                        The defined ROM consumption is the result of all analysed configuration
                        parameters of reference configuration 1.
                      </rationale>
      <needscoverage>
        <needscov><needsobj>man</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Ea_ResourceConsumption</srcid><srcstatus/><internalId>191</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Ea_ComTest_ResourceConsumption</srcid><srcstatus/><internalId>268</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>261</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd">
    <specobject>
      <id>Ea.swdd.RAMConsumption_RefCfg1</id>
      <status>approved</status>
      <source>Elektrobit Automotive GmbH</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/doc/project/design/basic_software/resource_view.xml</sourcefile>
      <sourceline>174</sourceline>
      <version>1</version>
      <description>
                        The RAM consumption for reference configuration must not exceed 80 bytes.
                      </description>
      <rationale>
                        The defined RAM consumption is the result of all analysed configuration
                        parameters of reference configuration 1.
                      </rationale>
      <needscoverage>
        <needscov><needsobj>man</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Ea_ResourceConsumption</srcid><srcstatus/><internalId>191</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Ea_ComTest_ResourceConsumption</srcid><srcstatus/><internalId>268</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>262</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_Ea_DBGINST_001</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/build/reqm/common_req/Ea_DbgInst_Trace_APIs.c</sourcefile>
      <sourceline>40</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
   Test Dbg
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
  VP: Successful compilation test.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.EB.DBGINST001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>192</internalId></provcov>
        <provcov>
          <linksto>Ea.EB.DBGINST002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>193</internalId></provcov>
        <provcov>
          <linksto>Ea.EB.DBGINST003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>194</internalId></provcov>
        <provcov>
          <linksto>Ea.EB.DBGINST004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>195</internalId></provcov>
        <provcov>
          <linksto>Ea.EB.DBGINST005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>196</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>263</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_Ea_VerifyCodeStub</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/build/reqm/common_req/Ea_VerifyStub_testspec.h</sourcefile>
      <sourceline>7</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that the code stub of the module is consistent with the
    implementation.
  
Test Object: 
    Relocatable post-build configuration macros generation.
  
Test Precondition: 
    Permutation [VerifyStub == true]:
      - Unit test contains its own code stub
      - Module is excluded from generation and compilation
    Permutation [VerifyStub == false]:
      - unit test excludes its own code stub
  
Test Execution: 
    01: Invoke all module APIs
    02: VP(Ea.EB.Interface.Consistency):
        Unit test compiles (implicitly tested)
  
Test Input: 
  
Test Output: 
    Test is correctly generated and compiled.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.EB.Interface.Consistency</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>197</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>264</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_EA_30066</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Compile/IN/Ea_ComTest_1/source/application/test_config.h</sourcefile>
      <sourceline>27</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
    Verify that all APIs of the Ea module are compilable when
    EaDevErrorDetect is disabled.
    Verify that the source can be compiled using the symbolic name generated
    for the configuration parameter EaBlockNumber.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: 
    Call Ea_Init()
    Call Ea_SetMode()
    Call Ea_Read()
    Call Ea_Write()
    Call Ea_Cancel()
    Call Ea_GetStatus()
    Call Ea_GetJobResult()
    Call Ea_InvalidateBlock()
    Call Ea_GetVersionInfo()
    Call Ea_EraseImmediateBlock()
    Call Ea_MainFunction()
    Call Ea_JobEndNotification()
    Call Ea_JobErrorNotification()
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00084</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>81</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00085</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>82</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00086</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>83</internalId></provcov>
        <provcov>
          <linksto>Ea.Ea_Write.Service</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>169</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00088</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>85</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00089</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>86</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00090</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>87</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00091</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>88</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00092</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>89</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00093</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>90</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00094</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>91</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00095</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00096</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>93</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00150</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>118</internalId></provcov>
        <provcov>
          <linksto>Ea.ASR40.SWS_Ea_00013</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>4</internalId></provcov>
        <provcov>
          <linksto>Ea.ECUC_Ea_00130</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>45</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>265</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_EA_30067</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Compile/IN/Ea_ComTest_2/source/application/test_config.h</sourcefile>
      <sourceline>10</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Verify that all APIs of the Ea module are compilable when
      EaDevErrorDetect is enabled.
      Verify that the source can be compiled using the symbolic name generated
      for the configuration parameter EaBlockNumber.
    &lt;/para&gt;
    &lt;para&gt;
      Verify that the Ea module's generator generates a
      syntactically and semantically valid basic software module
      description (BSWMD) when the generator mode "generate_swcd" is
      invoked..
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: 
    Call Ea_Init()
    Call Ea_SetMode()
    Call Ea_Read()
    Call Ea_Write()
    Call Ea_Cancel()
    Call Ea_GetStatus()
    Call Ea_GetJobResult()
    Call Ea_InvalidateBlock()
    Call Ea_GetVersionInfo()
    Call Ea_EraseImmediateBlock()
    Call Ea_MainFunction()
    Call Ea_JobEndNotification()
    Call Ea_JobErrorNotification()
    Ts5 build environment steps:
    The module configuration generator produces the BSWMD. This implicitly
    verifies that the BSWMD is syntactically and semantically correct.
    The code generator produces errors if the BSWMD does not contain
    the correct information.
  
Test Input: 
    Usage of a common ASR configuration having all adjacent ASR modules
    configured.
  
Test Output: 
    Compilation succeeds.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.EB.BSWMDGeneration_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>179</internalId></provcov>
        <provcov>
          <linksto>Ea.EB.BSWMDGeneration_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>180</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00084</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>81</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00085</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>82</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00086</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>83</internalId></provcov>
        <provcov>
          <linksto>Ea.Ea_Write.Service</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>169</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00088</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>85</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00089</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>86</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00090</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>87</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00091</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>88</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00092</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>89</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00093</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>90</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00094</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>91</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00095</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00096</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>93</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00150</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>118</internalId></provcov>
        <provcov>
          <linksto>Ea.ASR40.SWS_Ea_00062</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>14</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>266</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_EA_30068</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Compile/IN/Ea_ComTest_3/source/application/test_config.h</sourcefile>
      <sourceline>10</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Verify that all APIs of the Ea module are compilable when
      EaDevErrorDetect is enabled.
      Verify that the source can be compiled using the symbolic name generated
      for the configuration parameter EaBlockNumber.
    &lt;/para&gt;
    &lt;para&gt;
      Verify that the Ea module's generator generates a
      syntactically and semantically valid basic software module
      description (BSWMD) when the generator mode "generate_swcd" is
      invoked..
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: 
    Call Ea_Init()
    Call Ea_SetMode()
    Call Ea_Read()
    Call Ea_Write()
    Call Ea_Cancel()
    Call Ea_GetStatus()
    Call Ea_GetJobResult()
    Call Ea_InvalidateBlock()
    Call Ea_GetVersionInfo()
    Call Ea_EraseImmediateBlock()
    Call Ea_MainFunction()
    Call Ea_JobEndNotification()
    Call Ea_JobErrorNotification()
    Ts5 build environment steps:
    The module configuration generator produces the BSWMD. This implicitly
    verifies that the BSWMD is syntactically and semantically correct.
    The code generator produces errors if the BSWMD does not contain
    the correct information.
  
Test Input: 
    Usage of a common ASR configuration having all adjacent ASR modules
    configured.
  
Test Output: 
    Compilation succeeds.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.EB.BSWMDGeneration_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>179</internalId></provcov>
        <provcov>
          <linksto>Ea.EB.BSWMDGeneration_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>180</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00084</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>81</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00085</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>82</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00086</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>83</internalId></provcov>
        <provcov>
          <linksto>Ea.Ea_Write.Service</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>169</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00088</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>85</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00089</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>86</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00090</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>87</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00091</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>88</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00092</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>89</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00093</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>90</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00094</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>91</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00095</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00096</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>93</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00150</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>118</internalId></provcov>
        <provcov>
          <linksto>Ea.ASR40.SWS_Ea_00062</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>14</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>267</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>Ea_ComTest_ResourceConsumption</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Compile/IN/Ea_ComTest_ResourceConsumption/source/application/test_config.h</sourcefile>
      <sourceline>10</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
      This test shall be used as a reference test to estimate the RAM and ROM consumption.
    
Test Object: 
      RAM/ROM consumption of reference configuration
    
Test Precondition: None.
Test Execution: 
        This test is intended as compile test only.
    
Test Input: 
    
Test Output: 
        A compiled module.
    &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.swdd.ROMConsumption_RefCfg1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>261</internalId></provcov>
        <provcov>
          <linksto>Ea.swdd.RAMConsumption_RefCfg1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>262</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>268</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_EA_NonLegSymbolicNames</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Compile/IN/Ea_NonLegSymbolicNamesTest/source/application/Ea_Compile_NonLegSymbolicNames.c</sourcefile>
      <sourceline>31</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    Checking the symbolic name macro generated when EA_DONT_PROVIDE_LEGACY_SYMBOLIC_NAMES is ON.
&lt;/para&gt;

Test Object: symbolic name value macros
Test Precondition: 
 EA_DONT_PROVIDE_LEGACY_SYMBOLIC_NAMES is not defined.

Test Execution: 
    01: Check that macros are generated with the names and the values listed in output.

Test Input: 
None.

Test Output: 
    macro generation:
    EaConf_EaBlockConfiguration_EaBlockConfiguration0 20U
    EaConf_EaBlockConfiguration_EaBlockConfiguration1 58U
    EaConf_EaBlockConfiguration_EaBlockConfiguration2 85U
    EaConf_EaBlockConfiguration_EaBlockConfiguration3 3U
    
    EaBlockConfiguration0 must not be defined
    EaBlockConfiguration1 must not be defined
    EaBlockConfiguration2 must not be defined
    EaBlockConfiguration3 must not be defined
    
    Ea_EaBlockConfiguration0 must not be defined
    Ea_EaBlockConfiguration1 must not be defined
    Ea_EaBlockConfiguration2 must not be defined
    Ea_EaBlockConfiguration3 must not be defined
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.ECUC_Ea_00130</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>45</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>269</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_EA_MemAccApiCompliance</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Conformance/IN/Ea_ConTest_MemAcc_Compliance/source/application/Test.c</sourcefile>
      <sourceline>96</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This tests verifies that when MemAcc module usage is enabled then all corresponding API
  from MemAcc are called.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
No special preconditions.

Test Execution: 

Initialize EA and MemAcc Stub.
  Call Ea main function for processing the initialization phase.
Write data
  Trigger a Write data to flash.
  Wait to finish write job by checking Job Result is MEMIF_JOB_OK
  VP(MemAcc_Write) :Check that MemAcc Write API is called
Read data
  Read same block number data from flash
  Wait to finish read job by checking Job Result is MEMIF_JOB_OK
  Check the Ea status is MEMIF_IDLE after read is complete 
  VP(MemAcc_Read) :Check that MemAcc Read API is called
  VP(MemAcc_GetJobResult) :Check that MemAcc GetJobResult API is called
  VP(MemAcc_GetJobStatus) :Check that MemAcc GetJobStatus API is called
Cancel Read data
  Read same block number data from flash
  Call one main function for Read operation to start
  Cancel above read operation that started
  Call Ea main function for processing the job/ canceling of job
  VP(MemAcc_Cancel) :Check that MemAcc Cancel API is called
Erase Immediate data
  Erase block from flash
  Wait to finish read job by checking Job Result is MEMIF_JOB_OK
  Check the Ea status is MEMIF_IDLE after erase is complete
  VP(MemAcc_Erase) :Check that MemAcc Erase API is called

Test Input: 
None

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.EaMemAccUsage.ApiCompliance</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>186</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>270</internalId></specobject>
    <specobject>
      <id>TS_EA_MemAccJobResultCompatibility</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Conformance/IN/Ea_ConTest_MemAcc_Compliance/source/application/Test.c</sourcefile>
      <sourceline>289</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This tests verifies that when MemAcc module usage is enabled then Ea is compatible with the new
  return type that MemAcc returns when GetJobResult/GetJobStatus are called.
  Test verifies compatibility when MemAcc jobs are refused or failed.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
No special preconditions.

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
MemAcc_MainFunction are to be called continuously till the job gets completed.

Initialize EA and MemAcc Stub
Write data
  Trigger a Write data to flash 
  Wait to finish write job by checking Job Result is MEMIF_JOB_OK
Read data Refused
  Initialize MemAcc Read Stub to refuse the Read job.
  Read same block number data from flash
  VP(FailedJob) : Wait to finish read   job by checking Job Result is MEMIF_JOB_FAILED
  Check the Ea status is MEMIF_IDLE after read is complete
Read data Failed
  Initialize MemAcc Stub to return MEMACC_JOB_PENDING status
  Read same block number data from flash 
  Execute 100 MainFunction while MemAcc is MEMACC_JOB_PENDING to reproduce job waiting
  Initialize MemAcc to return a MEMACC_MEM_FAILED Job result
  VP(JOB_FAILED): Wait to finish read job by checking Job Result is MEMIF_JOB_FAILED.
  Check the Ea status is MEMIF_IDLE after read is complete

Test Input: 
None

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.EaMemAccUsage.GetJobResultCompatibility</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>187</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>271</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_EA_40058</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Implementation/IN/Ea_ImpTest_03/source/application/tests_Impl_03.c</sourcefile>
      <sourceline>40</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Test to check the behaviour of Ea in the case the Eep returns a job result MEMIF_JOB_FAILED in
state EA_S_READ_CHECK_MARKER.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
The internal buffer used in EA shall be greater than the block size called for Ea_Read.

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize test stubs for EEPROM driver, Nvm and Det if configured.
  Initialize Ea module.

Write data:
  Call Ea_Write for a logical block.
  Wait till the write job is complete.

Read data:
  Call Ea_Read for the same block.
  Wait till the state is EA_S_READ_CHECK_MARKER.
  Set the Eep Job Result as MEMIF_JOB_FAILED.
  Wait till the read job is complete.
  Check the Ea job result after the completion of the read job.

Check the Nvm notification calls and DET errors if configured.
Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On Write data:
  Write function should return E_OK.

On Read data:
  Read function should return E_OK.
  Ea_GetJobResult should return MEMIF_JOB_FAILED.

Nvm Job End Notification is called once.
Nvm Job error Notification is called once.
No Det errors reported.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00055</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>65</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>272</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_EA_40042</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Implementation/IN/Ea_ImpTest_04/source/application/tests_Impl_04.c</sourcefile>
      <sourceline>40</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Test to check the behaviour of Ea in the case the underlying driver returns E_NOT_OK in
state EA_S_WRITE_DATA.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
The internal buffer used in EA shall be smaller than the block size called for Ea_Write.

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize test stubs for EEPROM driver, Nvm and Det if configured.
  Initialize Ea module.

Write data:
  Call Ea_Write for a logical block.
  Wait till the state is EA_S_WRITE_DATA.
  Set the Eep_Write() return value as E_NOT_OK.
  Wait till the write job is complete.
  Check the Ea job result after the completion of the write job.

Check the Nvm notification calls and DET errors if configured.
Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On Write data:
  Write function should return E_OK.
  Ea_GetJobResult should return MEMIF_JOB_FAILED.

Nvm Job End Notification is not called.
Nvm Job error Notification is called once.
No Det errors reported.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00055</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>65</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>273</internalId></specobject>
    <specobject>
      <id>TS_EA_40053</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Implementation/IN/Ea_ImpTest_04/source/application/tests_Impl_04.c</sourcefile>
      <sourceline>188</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Test to check the behaviour of Ea in the case the Eep returns a job result MEMIF_JOB_FAILED in
state EA_S_WRITE_DATA.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
The internal buffer used in EA shall be smaller than the block size called for Ea_Write.

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize test stubs for EEPROM driver, Nvm and Det if configured.
  Initialize Ea module.

Write data:
  Call Ea_Write for a logical block.
  Wait till the state is EA_S_WRITE_DATA.
  Set the Eep Job Result as MEMIF_JOB_FAILED.
  Wait till the write job is complete.
  Check the Ea job result after the completion of the write job.

Check the Nvm notification calls and DET errors if configured.
Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On Write data:
  Write function should return E_OK.
  Ea_GetJobResult should return MEMIF_JOB_FAILED.

Nvm Job End Notification is not called.
Nvm Job error Notification is called once.
No Det errors reported.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00055</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>65</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>274</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_EA_40200</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Implementation/IN/Ea_TestVLE/source/application/Tests.c</sourcefile>
      <sourceline>86</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
To test that when only one copy of a block is present in EEPROM, Ea_Read() after
an inconsistent (incomplete) write job reports block status MEMIF_BLOCK_INCONSISTENT.

There are two scenarios for this case:
 i. Cancellation of a write request followed by Ea_Read.
 ii. Cancellation of a write request followed by a reset and Ea_Read.

&lt;/para&gt;

Test Object: None.
Test Precondition: 
Configure block 256 with write cycles = EEP write cycles.

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize Ea module. Erase EEPROM memory.
  Initialize test stubs for EEPROM driver, Nvm and Det if configured.

Write data (first copy):
  Initialize the write buffer with some data and write it to block 256.
  Check that the current copy in VLE table for block 256 is updated to 1.

Write data (inconsistent copy):
  Change the data in the write buffer and write block 256 again.
  Before the write job completes, cancel the job. (Block becomes inconsistent)
  Check whether Ea_GetJobResult returns MEMIF_JOB_CANCELED.
  Check whether block 256 is set as inconsistent in VLEC table.

Read Verify:
  Read the contents of EEPROM and ensure that the block data is written incompletely.

Read data 1:
  Initialize the read buffer and call Ea_Read() to read block 256 into the read buffer.
  Check whether Ea_GetJobResult returns MEMIF_BLOCK_INCONSISTENT.
  Check whether the contents of read buffer has not changed.
  Check whether block 256 is set as inconsistent in VLEC table.

Reset module:
  Initialize Ea module.

Read data 2:
  Initialize the read buffer and call Ea_Read() to read the block into the read buffer.
  Check whether Ea_GetJobResult returns MEMIF_BLOCK_INCONSISTENT.
  Check whether the contents of read buffer has not changed.
  Check whether block 256 is set as inconsistent in VLEC table.
  Check that the current copy for block 256 is unknown.

In case any of the above operation returns unexpected value, set result as failure.


Test Input: 

Test Output: 

Init test:
  The result of initialization need not be verified since initialization is already tested.

Write data (first copy):
  Ea_Write() returns E_OK.
  The current copy in VLE table for block 256 is updated to 1.

Write data (inconsistent copy):
  Ea_Write() returns E_OK.
  Ea_GetJobResult returns MEMIF_JOB_CANCELED.
  Block 256 is set as inconsistent in VLEC table.

Read Verify:
  The block data in EEPROM is incompletely written.

Read data 1:
  Ea_Read() returns E_OK.
  Ea_GetJobResult returns MEMIF_BLOCK_INCONSISTENT.
  The contents of read buffer has not been changed.
  Block 256 is set as inconsistent in VLEC table.

Reset module:
  The result of initialization need not be verified since initialization is already tested.

Read data 2:
  Ea_Read() returns E_OK.
  Ea_GetJobResult returns MEMIF_BLOCK_INCONSISTENT.
  The contents of read buffer has not been changed.
  Block 256 is set as inconsistent in VLEC table.
  The current copy for block 256 is set as unknown.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00047</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>61</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00104</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>98</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>275</internalId></specobject>
    <specobject>
      <id>TS_EA_40201</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Implementation/IN/Ea_TestVLE/source/application/Tests.c</sourcefile>
      <sourceline>303</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
To test that when an inconsistent copy of a block is present before an old copy,
Ea_Read() reports the block status MEMIF_BLOCK_INCONSISTENT.

There are two scenarios for this case:
 i. Cancellation of a write request followed by Ea_Read.
 ii. Cancellation of a write request followed by a reset and Ea_Read.

&lt;/para&gt;

Test Object: None.
Test Precondition: 
Configure block 85 with write cycles four times greater than EEP write cycles.
Configure block 58 with write cycles two times greater than EEP write cycles.

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize Ea module. Erase EEPROM memory.
  Initialize test stubs for EEPROM driver, Nvm and Det if configured.

Write data (multiple copies):
  Call Ea_Write with different data until all copies of block 85 are written (4 times).
  Call Ea_Write with different data until all copies of block 58 are written (2 times).
  Check that the current copy in VLE Table is updated to last copy for both blocks.
  Check that the current VLECs for block 58 and 85 are set to the number of copies.

Write data (inconsistent copy):
  Change the data in the write buffer and write to block 85 and 58 again. (Overwrites first copy)
  In both cases, cancel the job before the write job completes. (First copy becomes inconsistent)
  Check whether Ea_GetJobResult returns MEMIF_JOB_CANCELED in both cases.

Read verify:
  Read the contents of EEPROM for block 58 and 85 and ensure that the first copy
  is written incompletely and all other copies are written completely.

Read data 1:
  Initialize the read buffer and call Ea_Read() to read block 85 into the read buffer.
  Initialize the read buffer and call Ea_Read() to read block 58 into the read buffer.
  In both cases, check whether Ea_GetJobResult returns MEMIF_BLOCK_INCONSISTENT and
  the contents of read buffer has not changed.
  Check whether blocks 58 and 85 are set as inconsistent in VLEC table.
  Check that the current copy in VLE Table is updated to last copy for both blocks.
  Check that the current VLECs for block 58 and 85 are set to the number of copies.

Reset module:
  Initialize Ea module.

Read data 2:
  Initialize the read buffer and call Ea_Read() to read block 85 into the read buffer.
  Initialize the read buffer and call Ea_Read() to read block 58 into the read buffer.
  In both cases, check whether Ea_GetJobResult returns MEMIF_BLOCK_INCONSISTENT and
  the contents of read buffer has not changed.
  Check whether blocks 58 and 85 are set as inconsistent in VLEC table.
  Check that the current copy in VLE Table is updated to last copy for both blocks.
  Check that the current VLECs for block 58 and 85 are set to the number of copies.

In case any of the above operation returns unexpected value, set result as failure.


Test Input: 

Test Output: 

Init test:
  The result of initialization need not be verified since initialization is already tested.

Write data (multiple copies):
  Ea_Write() each time returns E_OK.
  The current copy in VLE Table is updated to last copy for both blocks.
  The current VLECs for block 58 and 85 is set to the number of copies.

Write data (inconsistent copy):
  Ea_Write() returns E_OK in both cases.
  Ea_GetJobResult returns MEMIF_JOB_CANCELED in both cases.
  The current copy in VLE Table is updated to last copy for both blocks.

Read verify:
  The first copy is written incompletely in EEPROM; all other copies are written completely.

Read data 1:
  Ea_Read() returns E_OK in both cases.
  Ea_GetJobResult returns MEMIF_BLOCK_INCONSISTENT in both cases.
  The contents of read buffer has not been changed in both cases.
  Blocks 58 and 85 are set as inconsistent in VLEC table.
  The current copy in VLE Table is updated to last copy for both blocks.
  The current VLECs for block 58 and 85 are set to the number of copies.

Reset module:
  The result of initialization need not be verified since initialization is already tested.

Read data 2:
  Ea_Read() returns E_OK in both cases.
  Ea_GetJobResult returns MEMIF_BLOCK_INCONSISTENT in both cases.
  The contents of read buffer has not been changed in both cases.
  Blocks 58 and 85 are set as inconsistent in VLEC table.
  The current copy in VLE Table is updated to last copy for both blocks.
  The current VLECs for block 58 and 85 are set to the number of copies.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00047</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>61</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00104</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>98</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>276</internalId></specobject>
    <specobject>
      <id>TS_EA_40202</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Implementation/IN/Ea_TestVLE/source/application/Tests.c</sourcefile>
      <sourceline>673</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
To test that when an inconsistent copy of a block is present after an old copy,
Ea_Read() reports the block status MEMIF_BLOCK_INCONSISTENT.

There are two scenarios for this case:
 i. Cancellation of a write request followed by Ea_Read.
 ii. Cancellation of a write request followed by a reset and Ea_Read.

&lt;/para&gt;

Test Object: None.
Test Precondition: 
Configure block 85 with write cycles four times greater than EEP write cycles.
Configure block 58 with write cycles two times greater than EEP write cycles.

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize Ea module. Erase EEPROM memory.
  Initialize test stubs for EEPROM driver, Nvm and Det if configured.

Write data (first copy):
  Initialize the write buffer with some data and write it to blocks 85 and 58.
  Check that the current copy in VLE table for blocks 58 and 85 is updated to 1.
  Check that the current VLECs for block 58 and 85 are set to 1.

Write data (inconsistent copy):
  Change the data in the write buffer and write to block 85 and 58 again.
  In both cases, cancel the job before the write job completes. (Second copy becomes inconsistent)
  Check whether Ea_GetJobResult returns MEMIF_JOB_CANCELED in both cases.
  Check whether blocks 58 and 85 are set as inconsistent in VLEC table.
  Check that the current copy in VLE table for both blocks is unchanged.

Read verify:
  Read the contents of EEPROM for block 58 and 85 and ensure that the
  first copy is written completely and second copy is written incompletely.

Read data 1:
  Initialize the read buffer and call Ea_Read() to read block 85 into the read buffer.
  Initialize the read buffer and call Ea_Read() to read block 58 into the read buffer.
  In both cases, check whether Ea_GetJobResult returns MEMIF_BLOCK_INCONSISTENT and
  the contents of read buffer has not changed.
  Check whether blocks 58 and 85 are set as inconsistent in VLEC table.
  Check that the current copy in VLE table for both blocks is updated to 1.
  Check that the current VLECs for block 58 and 85 are set to 1.

Reset module:
  Initialize Ea module.

Read data 2:
  Initialize the read buffer and call Ea_Read() to read block 85 into the read buffer.
  Initialize the read buffer and call Ea_Read() to read block 58 into the read buffer.
  In both cases, check whether Ea_GetJobResult returns MEMIF_BLOCK_INCONSISTENT and
  the contents of read buffer has not changed.
  Check whether blocks 58 and 85 are set as inconsistent in VLEC table.
  Check that the current copy in VLE table for both blocks is updated to 1.

In case any of the above operation returns unexpected value, set result as failure.


Test Input: 

Test Output: 

Init test:
  The result of initialization need not be verified since initialization is already tested.

Write data (first copy):
  Ea_Write() returns E_OK in both cases.
  The current copy in VLE table for blocks 58 and 85 is updated to 1.
  The current VLECs for block 58 and 85 are set to 1.

Write data (inconsistent copy):
  Ea_Write() returns E_OK in both cases.
  Ea_GetJobResult returns MEMIF_JOB_CANCELED in both cases.
  Blocks 58 and 85 are set as inconsistent in VLEC table.
  The current copy in VLE table for both blocks is unchanged.

Read verify:
  The first copy is written completely in EEPROM and second copy is written incompletely.

Read data 1:
  Ea_Read() returns E_OK in both cases.
  Ea_GetJobResult returns MEMIF_BLOCK_INCONSISTENT in both cases.
  The contents of read buffer has not been changed in both cases.
  Blocks 58 and 85 are set as inconsistent in VLEC table.
  The current copy in VLE table for both blocks is updated to 1.
  The current VLECs for block 58 and 85 are set to 1.

Reset module:
  The result of initialization need not be verified since initialization is already tested.

Read data 2:
  Ea_Read() returns E_OK.
  Ea_GetJobResult returns MEMIF_BLOCK_INCONSISTENT in both cases.
  The contents of read buffer has not been changed in both cases.
  Blocks 58 and 85 are set as inconsistent in VLEC table.
  The current copy in VLE table for both blocks is updated to 1.
  The current VLECs for block 58 and 85 are set to 1.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00047</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>61</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00104</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>98</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>277</internalId></specobject>
    <specobject>
      <id>TS_EA_40203</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Implementation/IN/Ea_TestVLE/source/application/Tests.c</sourcefile>
      <sourceline>1032</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
To test that when only one copy of a block is present in EEPROM, Ea_Read() after
Ea_EraseImmediateBlock() reports the block status MEMIF_BLOCK_INCONSISTENT.

There are two scenarios for this case:
 i. Erasure of a block followed by Ea_Read.
 ii. Erasure of a block followed by a reset and Ea_Read.

&lt;/para&gt;

Test Object: None.
Test Precondition: 
Configure block 256 with immediate data and write cycles = EEP write cycles.

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize Ea module. Erase EEPROM memory.
  Initialize test stubs for EEPROM driver, Nvm and Det if configured.
  Check that the current copy for block 256 is unknown.

Write data:
  Initialize the write buffer with some data and write it to block 256.
  Check that the current VLEC for block 256 is 1.

Erase data:
  Call Ea_EraseImmediateBlock() for block 256.

Read verify:
  Read the contents of EEPROM and ensure that the only copy for the block is empty.

Read data 1:
  Initialize the read buffer and call Ea_Read() to read block 256 into the read buffer.
  Check whether Ea_GetJobResult returns MEMIF_BLOCK_INCONSISTENT.

Reset module:
  Initialize Ea module.

Read data 2:
  Initialize the read buffer and call Ea_Read() to read block 256 into the read buffer.
  Check whether Ea_GetJobResult returns MEMIF_BLOCK_INCONSISTENT.
  Check that the current copy for block 256 is unknown.

In case any of the above operation returns unexpected value, set result as failure.


Test Input: 

Test Output: 

Init test:
  The result of initialization need not be verified since initialization is already tested.
  The current copy for block 256 is unknown.

Write data:
  Ea_Write() returns E_OK.
  The current VLEC for block 256 is 1.

Erase data:
  Ea_EraseImmediateBlock() returns E_OK.
  Ea_GetJobResult returns MEMIF_JOB_OK.

Read verify:
  The block contents are empty in EEPROM.

Read data 1:
  Ea_Read() returns E_OK.
  Ea_GetJobResult returns MEMIF_BLOCK_INCONSISTENT.
  The contents of read buffer has not been changed.

Reset module:
  The result of initialization need not be verified since initialization is already tested.

Read data 2:
  Ea_Read() returns E_OK.
  Ea_GetJobResult returns MEMIF_BLOCK_INCONSISTENT.
  The contents of read buffer has not been changed.
  The current copy for block 256 is unknown

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00093</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>90</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>278</internalId></specobject>
    <specobject>
      <id>TS_EA_40204</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Implementation/IN/Ea_TestVLE/source/application/Tests.c</sourcefile>
      <sourceline>1218</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
To test that Ea_Read() when called on an uninitialized EEPROM reports
the block status MEMIF_BLOCK_INCONSISTENT.

To test that when an erased copy of a block is present before its old copy,
Ea_Read() reports the block status MEMIF_BLOCK_INCONSISTENT.

There are two scenarios for this case:
 i. Erasure of a block followed by Ea_Read.
 ii. Erasure of a block followed by a reset and Ea_Read.

&lt;/para&gt;

Test Object: None.
Test Precondition: 
Configure block 85 with immediate data and write cycles four times greater than EEP write cycles.
Configure block 58 with immediate data and write cycles two times greater than EEP write cycles.

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize Ea module. Erase EEPROM memory.
  Initialize test stubs for EEPROM driver, Nvm and Det if configured.

Read data 1:
  Call Ea_Read() for blocks 58 and 85 on uninitialized EEPROM.
  In both cases, check whether Ea_GetJobResult returns MEMIF_BLOCK_INCONSISTENT.
  Check that the current copy in VLE table for both blocks is unknown.
  Check that the current VLECs for block 58 and 85 are set to 0.

Write data (multiple copies):
  Call Ea_Write with different data until all copies of block 85 are written (4 times).
  Call Ea_Write with different data until all copies of block 58 are written (2 times).
  Check that the current copy in VLE table for both blocks is updated to the last copy.
  Check that the current VLECs for block 58 and 85 are set to the number of copies.

Erase data:
  Call Ea_EraseImmediateBlock() for block 85.

Read verify:
  Read the contents of EEPROM for block 58 and 85 and ensure that the first copy
  is erased, the last copy is marked as erased and all other copies (if exist) are kept intact.

Read data 2:
  Initialize the read buffer and call Ea_Read() to read block 85 into the read buffer.
  Initialize the read buffer and call Ea_Read() to read block 58 into the read buffer.
  In both cases, check whether Ea_GetJobResult returns MEMIF_BLOCK_INCONSISTENT.
  Check that the current copy in VLE table for both blocks is updated to the last copy.
  Check that the current VLECs for block 58 and 85 are set to the number of copies.

Reset module:
  Initialize Ea module.

Read data 3:
  Initialize the read buffer and call Ea_Read() to read block 85 into the read buffer.
  Initialize the read buffer and call Ea_Read() to read block 58 into the read buffer.
  In both cases, check whether Ea_GetJobResult returns MEMIF_BLOCK_INCONSISTENT.
  Check that the current copy in VLE table for both blocks is updated to the last copy.
  Check that the current VLECs for block 58 and 85 are set to the number of copies.

In case any of the above operation returns unexpected value, set result as failure.


Test Input: 

Test Output: 

Init test:
  The result of initialization need not be verified since initialization is already tested.

Read data 1:
  Ea_Read() returns E_OK in both cases.
  Ea_GetJobResult returns MEMIF_BLOCK_INCONSISTENT in both cases.
  The current copy in VLE table for both blocks is unknown.
  The current VLECs for block 58 and 85 are set to 0.

Write data (multiple copies):
  Ea_Write() each time returns E_OK in both cases.
  The current copy in VLE table for both blocks is updated to the last copy.
  The current VLECs for block 58 and 85 are set to the number of copies.

Erase data:
  Ea_EraseImmediateBlock() returns E_OK in both cases.
  Ea_GetJobResult returns MEMIF_JOB_OK in both cases.

Read verify:
  In both cases, the first copy for the block is erased, the last copy is marked as erased
  and all other copies are kept intact in EEPROM.

Read data 2:
  Ea_Read() returns E_OK in both cases.
  Ea_GetJobResult returns MEMIF_BLOCK_INCONSISTENT in both cases.
  The current copy in VLE table for both blocks is updated to the last copy.
  The current VLECs for block 58 and 85 are set to the number of copies.

Reset module:
  The result of initialization need not be verified since initialization is already tested.

Read data 3:
  Ea_Read() returns E_OK in both cases.
  Ea_GetJobResult returns MEMIF_BLOCK_INCONSISTENT in both cases.
  The current copy in VLE table for both blocks is updated to the last copy.
  The current VLECs for block 58 and 85 are set to the number of copies.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00093</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>90</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>279</internalId></specobject>
    <specobject>
      <id>TS_EA_40205</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Implementation/IN/Ea_TestVLE/source/application/Tests.c</sourcefile>
      <sourceline>1606</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
To test that when an erased copy of a block is present after an old copy,
Ea_Read() reports the block status MEMIF_BLOCK_INVALID.

There are two scenarios for this case:
 i. Erasure of a block followed by Ea_Read.
 ii. Erasure of a block followed by a reset and Ea_Read.

&lt;/para&gt;

Test Object: None.
Test Precondition: 
Configure block 85 with immediate data and write cycles four times greater than EEP write cycles.
Configure block 58 with immediate data and write cycles two times greater than EEP write cycles.

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize Ea module. Erase EEPROM memory.
  Initialize test stubs for EEPROM driver, Nvm and Det if configured.

Write data (first copy):
  Initialize the write buffer with some data and write it to blocks 58 and 85.
  Check that the current copy in VLE table for both blocks is updated to 1.
  Check that the current VLECs for block 58 and 85 are set to 1.

Write data (second copy):
  Change the data in the write buffer and write block 85 again.

Erase data:
  Call Ea_EraseImmediateBlock() for blocks 85 and 58.

Read verify:
  Read the contents of EEPROM for block 85 and ensure that the third copy is erased,
  the second copy is marked as erased and the first copy is kept intact.
  Read the contents of EEPROM for block 58 and ensure that the second copy is erased,
  and the first copy is marked as erased.

Read data 1:
  Initialize the read buffer and call Ea_Read() to read block 85 into the read buffer.
  Initialize the read buffer and call Ea_Read() to read block 58 into the read buffer.
  In both cases, check whether Ea_GetJobResult returns MEMIF_BLOCK_INCONSISTENT.
  Check that the current copy in VLE table for blocks 85 is updated to 2 and for block
  58 is updated to 1.

Reset module:
  Initialize Ea module.

Read data 2:
  Initialize the read buffer and call Ea_Read() to read block 85 into the read buffer.
  Initialize the read buffer and call Ea_Read() to read block 58 into the read buffer.
  In both cases, check whether Ea_GetJobResult returns MEMIF_BLOCK_INCONSISTENT.
  Check that the current copy in VLE table for blocks 85 is updated to 2 and for block
  58 is updated to 1.
  Check that the current VLECs for block 85 is set to 2 and for block 58 it is set to 1.

In case any of the above operation returns unexpected value, set result as failure.


Test Input: 

Test Output: 

Init test:
  The result of initialization need not be verified since initialization is already tested.

Write data (first copy):
  Ea_Write() returns E_OK in both cases.
  The current copy in VLE table for both blocks is updated to 1.
  The current VLECs for block 58 and 85 are set to 1.

Write data (second copy):
  Ea_Write() returns E_OK in both cases.

Erase data:
  Ea_EraseImmediateBlock() returns E_OK in both cases.
  Ea_GetJobResult returns MEMIF_JOB_OK in both cases.

Read verify:
  The third copy for block 85 is erased, the second copy is marked as erased
  and the first copy is kept intact in EEPROM.

  For block 58, the second copy is erased and the first copy is marked as erased.

Read data 1:
  Ea_Read() returns E_OK in both cases.
  Ea_GetJobResult returns MEMIF_BLOCK_INCONSISTENT in both cases.
  The current copy in VLE table for blocks 85 is updated to 2 and for block 58 is updated to 1.

Reset module:
  The result of initialization need not be verified since initialization is already tested.

Read data 2:
  Ea_Read() returns E_OK in both cases.
  Ea_GetJobResult returns MEMIF_BLOCK_INCONSISTENT in both cases.
  The current copy in VLE table for blocks 85 is updated to 2 and for block 58 is updated to 1.
  The current VLECs for block 85 is set to 2 and for block 58 it is set to 1.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00093</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>90</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>280</internalId></specobject>
    <specobject>
      <id>TS_EA_40206</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Implementation/IN/Ea_TestVLE/source/application/Tests.c</sourcefile>
      <sourceline>1914</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Test the return values of Ea_Read() requests after writing/invalidating/erasing
  blocks in various scenarios.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
Configure block 85 with immediate data and write cycles four times greater than EEP write cycles.
Configure block 58 with immediate data and write cycles two times greater than EEP write cycles.

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize Ea module. Erase EEPROM memory.
  Initialize test stubs for EEPROM driver, Nvm and Det if configured.

Step 1: Call Ea_Read() for blocks 58 and 85 on uninitialized EEPROM
  Read block 85 and check whether Ea_GetJobResult returns MEMIF_BLOCK_INCONSISTENT.
  Check that the current copy for block 85 is unknown.
  Check that the current VLEC for block 85 is 0.
  Read block 58 and check whether Ea_GetJobResult returns MEMIF_BLOCK_INCONSISTENT.
  Check that the current copy for block 85 is unknown.
  Check that the current VLEC for block 58 is 0.

Step 2: Write blocks 85 and 58 and all their copies
  Write data for block 85 (4 copies).
  Check that the current copy for block 85 is updated.
  Check that the current VLEC for block 85 = the number of copies.
  Write data for block 58 (2 copies).
  Check that the current copy for block 58 is updated.
  Check that the current VLEC for block 58 = its number of copies.

Step 3: Erase block 85 and invalidate block 58
  Call Ea_EraseImmediateBlock() for block 85.
  Call Ea_InvalidateBlock() for block 58.

Step 4: Reset module and read blocks
  Check whether the first copy of block 85 is erased.
  Check whether 4th copy of block 85 is marked as inconsistent.
  Check whether all other copies of block 85 are kept intact.
  Check whether the first copy of block 58 is intact.
  Check whether the 1st copy of block 58 is valid.
  Check whether 2nd copy of block 58 is invalidated.
  Read block 85 and check whether Ea_GetJobResult returns MEMIF_BLOCK_INCONSISTENT.
  Read block 58 and check whether Ea_GetJobResult returns MEMIF_BLOCK_INVALID.
  Check that the current copy for block 85 is updated to the last copy.
  Check that the current copy for block 58 is updated to the last copy.
  Check that the current VLEC for block 85 = the number of copies.
  Check that the current VLEC for block 58 = its number of copies.

Step 5: Reset module and read data
  Read block 85 and check whether Ea_GetJobResult returns MEMIF_BLOCK_INCONSISTENT.
  Read block 58 and check whether Ea_GetJobResult returns MEMIF_BLOCK_INVALID.

Step 6: Invalidate block 85 and erase block 58
  Call Ea_InvalidateBlock() for block 85.
  Call Ea_EraseImmediateBlock() for block 58.

Step 7: Read the blocks
  Check whether all other copies of block 85 are kept intact.
  Check whether 4th copy of block 85 is invalidated.
  Check whether the first copy of block 58 is erased.
  Check whether the 2nd copy of block 58 is inconsistent.
  Read block 85 and check whether Ea_GetJobResult returns MEMIF_BLOCK_INVALID.
  Read block 58 and check whether Ea_GetJobResult returns MEMIF_BLOCK_INCONSISTENT.
  Check that the current copy for block 85 is updated to the last copy.
  Check that the current copy for block 58 is updated to the last copy.
  Check that the current VLEC for block 85 = the number of copies.
  Check that the current VLEC for block 58 = its number of copies.

Step 8: Reset module and write blocks 85 and 58
  Read block 85 and check whether Ea_GetJobResult returns MEMIF_BLOCK_INVALID.
  Read block 58 and check whether Ea_GetJobResult returns MEMIF_BLOCK_INCONSISTENT.
  Write block 85.
  Write block 58.

Step 9: Read blocks 85 and 58
  Read block 85 and check whether Ea_GetJobResult returns MEMIF_JOB_OK.
  Read block 58 and check whether Ea_GetJobResult returns MEMIF_JOB_OK.

In case any of the above operation returns unexpected value, set result as failure.


Test Input: 

Test Output: 
  First read:
    Ea_Read() returns MEMIF_BLOCK_INCONSISTENT for block 85.
    Ea_Read() returns MEMIF_BLOCK_INCONSISTENT for block 58.

  Second read:
    Ea_Read() returns MEMIF_BLOCK_INCONSISTENT for block 85.
    Ea_Read() returns MEMIF_BLOCK_INVALID for block 58.

  Third read:
    Ea_Read() returns MEMIF_BLOCK_INVALID for block 85.
    Ea_Read() returns MEMIF_BLOCK_INCONSISTENT for block 58.

  Fourth read:
    Ea_Read() returns MEMIF_JOB_OK for block 85.
    Ea_Read() returns MEMIF_JOB_OK for block 58.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00093</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>90</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00091</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>88</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00086</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>83</internalId></provcov>
        <provcov>
          <linksto>Ea.EraseImmediate.Behaviour</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>184</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>281</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_EA_30094</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Conformance_Common/source/application/GetVersionInfo_test.c.m4</sourcefile>
      <sourceline>43</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
To test the Ea GetVersionInfo API with valid pointer as parameter.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Init test:
  Initialize Ea module.
  Initialize test stubs for EEPROM driver, Nvm and Det.
  Set the Version information values before the call of Ea_GetVersionInfo.

Call Ea_GetVersionInfo:
  Call Ea_GetVersionInfo() with a valid address.
  Check the returned version information.

Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.
  The version information values shall be set to invalid.

On Ea_GetVersionInfo() call:
  The version information returned are those that are configured/hardcoded in the module.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.ASR40.SWS_Ea_00061</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>13</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00092</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>89</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>282</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_EA_30018</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Conformance_Common/source/application/Tests.c</sourcefile>
      <sourceline>48</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Testing Ea_GetStatus() before the initialization of Ea.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Init Stubs:
  Initialize test stubs for EEPROM driver, Nvm and Det if configured.

Status MEMIF_UNINIT:
  Check the status by calling Ea_GetStatus().
  Verify whether the EEP stub was invoked.
  Check DET error if configured.

Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 

Test Output: 

On Init Stubs:
  EEPROM driver, Nvm and Det stubs should be intialized.

Status MEMIF_UNINIT:
  The Ea_GetStatus() returns MEMIF_UNINIT.
  Eep_GetStatus() shall not be called.
  A DET error shall be reported, if configured.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00089</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>86</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>283</internalId></specobject>
    <specobject>
      <id>TS_EA_30219</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Conformance_Common/source/application/Tests.c</sourcefile>
      <sourceline>136</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Testing the Ea_Init functionality.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init Stubs:
  Initialize EEPROM driver and test stubs for Nvm and Det if configured.
  Erase EEPROM memory.

Write data(first time):
  Call Ea_Write() for block &amp;lt;B4&amp;gt;.
  Check the Nvm notification calls and DET errors.

Init Ea module:
  Call Ea_Init().
  Check the Ea status and job result just after init.

Write data(second time):
  Call Ea_Write() for block &amp;lt;B4&amp;gt;.
  Check the Nvm notification calls and DET errors.

Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 

Test Output: 

On Init Stubs:
  EEPROM driver, Nvm and Det stubs should be intialized.

On Write data (first time):
  Write function should return E_NOT_OK.
  No Nvm notifications are called.
  DET error is reported.

On Init Ea module:
  Ea module is intialized.
  Ea_GetStatus should return MEMIF_IDLE
  Ea_GetJobResult should return MEMIF_JOB_OK.

On Write data(second time):
  Write function should return E_OK.
  Nvm Job End Notification is called once.
  Nvm Job error Notification is not called.
  No Det errors reported.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.Ea_Write.Service</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>169</internalId></provcov>
        <provcov>
          <linksto>Ea.Ea_Write.Acceptance</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>167</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00026</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>55</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00054</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>64</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00141</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>109</internalId></provcov>
        <provcov>
          <linksto>Ea.EB.Ea_Init</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>183</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>284</internalId></specobject>
    <specobject>
      <id>TS_EA_30078</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Conformance_Common/source/application/Tests.c</sourcefile>
      <sourceline>291</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
To test the Ea_SetMode API with mode as parameter for both MEMIF_MODE_SLOW and
MEMIF_MODE_FAST.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize Ea module.
  Initialize test stubs for EEPROM driver, Nvm and Det if configured.

Set Mode slow (first time):
  Set the operation mode of the EEPROM driver as MEMIF_MODE_SLOW.
  Check the operation mode of the EEPROM driver.

Set Mode fast (first time):
  Set the operation mode of the EEPROM driver as MEMIF_MODE_FAST.
  Check the operation mode of the EEPROM driver.

Set Mode slow (second time):
  Set the operation mode of the EEPROM driver as MEMIF_MODE_SLOW.
  Check the operation mode of the EEPROM driver.

Set Mode fast (second time):
  Set the operation mode of the EEPROM driver as MEMIF_MODE_FAST.
  Check the operation mode of the EEPROM driver.

Check the Nvm notification calls and DET errors if configured.
Incase any of the above operation returns unexpected value, set result as failure


Test Input: 
None

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested

On Set mode slow (first time):
  Operation mode of the EEPROM driver should be MEMIF_MODE_SLOW

On Set mode fast (first time):
  The operation mode of the EEPROM driver should be MEMIF_MODE_FAST

On Set mode slow (second time):
  Operation mode of the EEPROM driver should be MEMIF_MODE_SLOW

On Set mode fast (second time):
  The operation mode of the EEPROM driver should be MEMIF_MODE_FAST

Nvm Job End Notification is not called.
Nvm Job error Notification is not called.
No Det errors reported.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.ASR40.SWS_Ea_00020</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>5</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00085</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>82</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>285</internalId></specobject>
    <specobject>
      <id>TS_EA_30085</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Conformance_Common/source/application/Tests.c</sourcefile>
      <sourceline>440</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Testing the Ea write functionality(Failure).
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize test stubs for EEPROM driver, Nvm and Det if configured.
  Initialize Ea module.

Write data:
  Simulate that the EEPROM driver rejects the write jobs.
  Call Ea_Write() for block &amp;lt;B4&amp;gt;.

Verify Write:
  Check that Eep_Write() is called.
  Check the Nvm notification calls and DET errors.

Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On Write data :
  Ea_Write() returns E_NOT_OK or sets job result to MEMIF_JOB_FAILED after the
  driver rejects the write access, Eep_Write() is called at least once.

On verification of Write:
  Nvm Job End Notification is not called.
  Nvm Job Error Notification is called once, if Ea_Write() returns E_OK.
  No Det errors reported if configured.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.Ea_Write.Service</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>169</internalId></provcov>
        <provcov>
          <linksto>Ea.Ea_Write.Acceptance</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>167</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00026</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>55</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>286</internalId></specobject>
    <specobject>
      <id>TS_EA_30083</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Conformance_Common/source/application/Tests.c</sourcefile>
      <sourceline>559</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Testing the Ea write functionality(Success).
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize test stubs for EEPROM driver, Nvm and Det if configured.
  Initialize Ea module.

Write data:
  Write a block of data into the Eeprom.

Verify Write:
  Check the Ea status and job result just after write call.
  Check the Ea status after the completion of the write job.
  Check Eep_Write() is called.

Check the Nvm notification calls and DET errors if configured.
Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On Write data :
  Write function should return E_OK.

On verification of Write:
  After write call, Ea_GetStatus should return MEMIF_BUSY and Ea_GetJobResult should return
  MEMIF_JOB_PENDING.
  On completion of write, Ea_GetStatus should return MEMIF_IDLE and Ea_GetJobResult should
  return MEMIF_JOB_OK.
  Eep_Write is called atleast once.

Nvm Job End Notification is called once.
Nvm Job error Notification is not called.
No Det errors are reported if configured.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.Ea_Write.Service</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>169</internalId></provcov>
        <provcov>
          <linksto>Ea.Ea_Write.Acceptance</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>167</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00026</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>55</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00047</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>61</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00054</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>64</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00157</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>124</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>287</internalId></specobject>
    <specobject>
      <id>TS_EA_30080</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Conformance_Common/source/application/Tests.c</sourcefile>
      <sourceline>694</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Testing the Ea Read functionality(Failure).
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize test stubs for EEPROM driver, Nvm and Det if configured.
  Initialize Ea module.

Read data:
  Simulate that the EEPROM driver rejects the read operation.
  Call Ea_Read() for block &amp;lt;B4&amp;gt;.

Verify Read:
  Check the Nvm notification calls and DET errors.

Incase any of the above operation returns unexpected value, set result as failure.

Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On Read data:
  Ea_Read() returns E_NOT_OK or sets job result to MEMIF_JOB_FAILED after the
  driver rejects the read access and Eep_Read() is called atleast once.

On verification of Read:
  Nvm Job End Notification is not called.
  Nvm Job Error Notification is called once, if Ea_Read returns E_OK.
  No Det errors reported.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00086</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>83</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>288</internalId></specobject>
    <specobject>
      <id>TS_EA_30081</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Conformance_Common/source/application/Tests.c</sourcefile>
      <sourceline>807</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Testing the Ea Read functionality(Success).
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize test stubs for EEPROM driver, Nvm and Det if configured.
  Initialize Ea module.

Prepare test scenario:
  Write a block of data into the EEPROM.
  Wait till the block is written completely.

Read data:
  Call Ea_Read() for the same block.

Verify Read:
  Check the Ea status and job result just after read.
  Check the Ea status after the completion of the read job.
  Check Eep_Read() is called.
  Compare source and destination buffers for equality.

Check the Nvm notification calls and DET errors if configured.
Incase any of the above operation returns unexpected value, set result as failure.

Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On test scenario preparation:
  Write function should return E_OK.

On Read data :
  Ea Read function should return E_OK.

On verification of Read:
  After read call, Ea_GetStatus should return MEMIF_BUSY and Ea_GetJobResult should return
  MEMIF_JOB_PENDING.
  On completion of read, Ea_GetStatus should return MEMIF_IDLE and Ea_GetJobResult should
  return MEMIF_JOB_OK.
  Eep_Read() is called atleast once.
  The source and destination buffers should be equal.

Nvm Job End Notification is called once.
Nvm Job error Notification is not called.
No Det errors reported if configured.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00086</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>83</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00054</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>64</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>289</internalId></specobject>
    <specobject>
      <id>TS_EA_30089</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Conformance_Common/source/application/Tests.c</sourcefile>
      <sourceline>976</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Testing Ea_GetStatus() to retrieve the different possible driver states.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Init test:
  Initialize test stubs for EEPROM driver, Nvm and Det if configured.
  Initialize Ea module.

Status MEMIF_IDLE:
  Check the status by calling Ea_GetStatus().

Status MEMIF_BUSY:
  Start an async write operation.
  Check the status by calling Ea_GetStatus().

  Check the Nvm notification calls and DET errors.
  Incase any of the above operation returns unexpected value, set result as failure.

Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

Status MEMIF_IDLE:
  Ea_GetStatus() is called.
  The Ea_GetStatus() returns MEMIF_IDLE.

Status MEMIF_BUSY:
  Ea_GetStatus() is called.
  The Ea_GetStatus() returns MEMIF_BUSY.

  Nvm Job End Notification is called once.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00089</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>86</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00156</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00157</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>124</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>290</internalId></specobject>
    <specobject>
      <id>TS_EA_30019</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Conformance_Common/source/application/Tests.c</sourcefile>
      <sourceline>1106</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Testing the Ea_EraseImmediateBlock functionality when the module is idle.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize test stubs for EEPROM driver, Nvm and Det if configured.
  Initialize Ea module.

Erase immediate block:
  Call Ea_EraseImmediateBlock for a logical block.
  Check the Ea status and job result after the completion of the Erase immediate block job.

Write data:
  Write a block of data into the Eeprom.
  Check the Ea status and job result after the completion of the write job.

Check the Nvm notification calls and DET errors if configured.
Incase any of the above operation returns unexpected value, set result as failure

Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On Erase immediate block:
  Erase immediate block function should return E_OK.
  Job Result should be MEMIF_JOB_OK.
  Status should not be MEMIF_BUSY.

On Write data:
  Write function should return E_OK.
  On completion of write job, Job Result should return MEMIF_JOB_OK and
  Ea_GetStatus should return MEMIF_IDLE.

Nvm Job End Notification is called twice.
Nvm Job error Notification is not called.
No Det errors reported.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00093</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>90</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00054</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>64</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00142</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>110</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00156</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>291</internalId></specobject>
    <specobject>
      <id>TS_EA_30095</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Conformance_Common/source/application/Tests.c</sourcefile>
      <sourceline>1250</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Testing the Ea_Read() functionality that is finished with an error.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize test stubs for EEPROM driver, Nvm and Det if configured.
  Initialize Ea module.

Read data:
  Simulate an error condition by setting the Eep Job Result to MEMIF_JOB_FAILED.
  Call Ea_Read() for block &amp;lt;B4&amp;gt;.

Verify Read:
  Check the Nvm notification calls and DET errors.

Incase any of the above operation returns unexpected value, set result as failure

Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On Read data :
  Ea_Read() returns E_OK.

On verification of Read:
  Nvm Job End Notification is not called.
  Nvm Job Error Notification is called once.
  No Det errors reported.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00055</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>65</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>292</internalId></specobject>
    <specobject>
      <id>TS_EA_30112</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Conformance_Common/source/application/Tests.c</sourcefile>
      <sourceline>1351</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Testing block read for a block which has not been written.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize Eeprom driver and test stubs for Nvm and Det if configured.
  Erase the Eeprom.
  Initialize Ea module.

Read data:
  Read a block from the Eeprom that has not been written.

Verify read:
  Check the Ea status and job result after the completion of the read job.

Check the Nvm notification calls and DET errors if configured.
Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 
None

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On Read data:
  Ea_Read returns E_OK

On verification of read:
  Ea_GetJobResult returns MEMIF_BLOCK_INCONSISTENT.
  Ea_GetStatus returns MEMIF_IDLE.

Nvm Job error Notification is called once.
Nvm Job End Notification is not called.
No Det errors reported if configured.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00086</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>83</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00055</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>65</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00046</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>60</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00104</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>98</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>293</internalId></specobject>
    <specobject>
      <id>TS_EA_30113</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Conformance_Common/source/application/Tests.c</sourcefile>
      <sourceline>1474</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Testing the Ea_Cancel functionality during a read job.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None.

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize Eeprom driver and test stubs for Nvm and Det if configured.
  Initialize Ea module.

Prepare test scenario:
  Write a block of data into the Eeprom.
  Check the Ea status and job result after the completion of the write job.

VP(Ea.SWS_Ea_00077, Ea.SWS_Ea_00078, Ea.SWS_Ea_00160):
  Call Ea_Cancel().
  Check the Ea status and the Job Result.

Make module status BUSY:
  Read Eeprom with same block number(main functions are not called here).

Cancel the read operation:
  Call Ea_Cancel().

VP(Ea.SWS_Ea_00077, Ea.SWS_Ea_00078):
  Verify read(The operation which is cancelled):
  Check the Ea status and the Job Result.

Read data :
  Read Eeprom with same block number.
  Check the Ea status and job result just after read call.
  Check the Ea status and job result after the completion of the read job.
  Compare source and destination buffers for equality.

Check the Nvm notification calls and DET errors if configured.
Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 
None

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On test scenario preparation:
  Write function should return E_OK.
  Ea Status should be MEMIF_IDLE.
  Job Result should be MEMIF_JOB_OK.

VP(Ea.SWS_Ea_00077, Ea.SWS_Ea_00078, Ea.SWS_Ea_00160):
  As the module status is MEMIF_IDLE, Eep_Cancel should not have been called and module status and
  Job Result should remain same.

On making module status BUSY:
  Read function should return E_OK
  Ea Status should be MEMIF_BUSY.
  Job Result should be MEMIF_JOB_PENDING.

On Cancel of read operation:
VP(Ea.SWS_Ea_00077, Ea.SWS_Ea_00078):
  As the module status is MEMIF_BUSY, Eep_Cancel should have been called and module status and
  Job Result should be changed.

  After cancellation Ea status should not be MEMIF_BUSY and
  Job Result should be MEMIF_JOB_CANCELED.

On Read data:
  Read function should return E_OK
  After read call Ea_GetStatus should return MEMIF_BUSY and Ea_GetJobResult should return
  MEMIF_JOB_PENDING.
  On completion of read Ea_GetStatus should return MEMIF_IDLE and Ea_GetJobResult return
  MEMIF_JOB_OK.
  Read/write buffer comparison should be successful.

Nvm Job End Notification is called twice.
Nvm Job Error Notification is called once.
No Det errors are reported if configured.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00088</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>85</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00078</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>77</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00077</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>76</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00160</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>127</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>294</internalId></specobject>
    <specobject>
      <id>TS_EA_30214</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Conformance_Common/source/application/Tests.c</sourcefile>
      <sourceline>1720</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Testing the Ea_Cancel functionality during a write job.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize Ea module.
  Initialize test stubs for EEPROM driver, Nvm and Det if configured.

Write data (First time):
  Perform a successful write operation on block &amp;lt;B2&amp;gt; to make the block consistent.

Read data (First time):
  Read block &amp;lt;B2&amp;gt; to verify that it is consistent.
  Verify that the read data is equal to the written data.

Write data (Second time):
  Start a write operation to block &amp;lt;B2&amp;gt;.
  Call Ea_Cancel().

Read data (Second time):
  Read block &amp;lt;B2&amp;gt; that is now inconsistent.
  Get and check the job result.

Check the Nvm notification calls and DET errors.
Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On Write data (First time):
  Ea_Write() returns with E_OK.

On Read data (First time):
  Ea_Read() shows that the block is consistent. Eep_Read() is called.
  The read data is equal to the written data.

On Write data (Second time):
  Ea_Write() returns with E_OK.

On Read data (Second time):
  Ea_Read() returns with E_OK.
  The job result returned on request is MEMIF_BLOCK_INCONSISTENT.

Nvm Job End Notification is called twice.
Nvm Job error Notification is called twice.
No Det errors are reported if configured.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00055</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>65</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>295</internalId></specobject>
    <specobject>
      <id>TS_EA_30108</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Conformance_Common/source/application/Tests.c</sourcefile>
      <sourceline>1923</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Testing the Ea_Write() functionality that is finished with an error.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize test stubs for EEPROM driver, Nvm and Det if configured.
  Initialize Ea module.

Write data:
  Simulate an error condition by setting the Eep Job Result to MEMIF_JOB_FAILED.
  Call Ea_Write() for block &amp;lt;B4&amp;gt;.

Verify Write:
  Check the Nvm notification calls and DET errors.

Incase any of the above operation returns unexpected value, set result as failure.

Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On Write data :
  Ea_Write() returns E_OK.

On verification of Write:
  Nvm Job  End Notification is not called.
  Nvm Job Error Notification is called once.
  No Det errors reported.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00055</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>65</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00144</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>112</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>296</internalId></specobject>
    <specobject>
      <id>TS_EA_30109</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Conformance_Common/source/application/Tests.c</sourcefile>
      <sourceline>2030</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Testing the Ea_EraseImmediateBlock() functionality that is finished with an error.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize test stubs for EEPROM driver, Nvm and Det if configured.
  Initialize Ea module.

EraseImmediateBlock:
  Simulate an error condition by setting the Eep Job Result to MEMIF_JOB_FAILED.
  Call Ea_EraseImmediateBlock() for block &amp;lt;B3&amp;gt;.

Verify EraseImmediateBlock:
  Check the Nvm notification calls and DET errors.

Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On EraseImmediateBlock:
  Ea_EraseImmediateBlock() returns E_OK.

On verification of EraseImmediateBlock:
  Nvm Job  End Notification is not called.
  Nvm Job Error Notification is called once.
  No Det errors reported.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00055</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>65</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00145</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>113</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>297</internalId></specobject>
    <specobject>
      <id>TS_EA_30121</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Conformance_Common/source/application/Tests.c</sourcefile>
      <sourceline>2134</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
This test checks that the different configured blocks are disjoint.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize test stubs for EEPROM driver, Nvm and Det if configured.
  Initialize Ea module.

Write Data:
  For each block do as many times as are necessary to reach all parts.
  Write the block with a distinct pattern.

Verify Write:
  Check that the blocks have the correct content and do not overlap with other
  blocks by reading the blocks.


Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On Write Data:
  Ea_Write() returns E_OK.
  Nvm Job End Notification is called.

Verification of Write:
  The block information read are those that were previously written.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00068</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>71</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>298</internalId></specobject>
    <specobject>
      <id>TS_EA_30123</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Conformance_Common/source/application/Tests.c</sourcefile>
      <sourceline>2313</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Testing the Ea_InvalidateBlock functionality and read the invalidate block.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed

Init test:
  Initialize test stubs for EEPROM driver, Nvm and Det if configured.
  Initialize Ea module.

Write data:
  Write a block of data into the flash.
  Check the Ea status and job result after the completion of the write job.

Read Data after write:
  Read flash with same block number written before.
  Check the Ea status and job result after the completion of the read job.
  Compare source and destination buffers for equality.

Invalidate Block:
  Invalidate the block which is written.
  Check the Ea status and job result just after invalidate function call.
  Check the Ea status and job result after the completion of the invalidate job.

Read Data after invalidate:
  Read flash with same block number invalidated before.
  Check the Ea status and job result after the completion of the read job.

Check the Nvm notification calls and DET errors if configured.
Incase any of the above operation returns unexpected value, set result as failure.

Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On Write data:
  Write function should return E_OK.
  On completion of write job, GetStatus function should return MEMIF_IDLE and
  GetJobResult should return MEMIF_JOB_OK.

On read data after write:
  Read function should return E_OK.
  On completion of read job, Ea status should return MEMIF_IDLE and GetJobResult
  should return MEMIF_JOB_OK.
  The source and destination buffers should be equal.

On Invalidate the block:
  Invalidate function should return E_OK
  After invalidate Ea_GetStatus should return MEMIF_BUSY and Ea_GetJobResult should return
  MEMIF_JOB_PENDING
  On completion of invalidate job, Ea_GetStatus should return MEMIF_IDLE and GetJobResult return
  MEMIF_JOB_OK.

On read data after invalidate:
  Read function should return E_OK.
  On completion of read job, Ea status should return MEMIF_IDLE and GetJobResult
  should return MEMIF_BLOCK_INVALID.

Nvm Job End Notification is called thrice.
Nvm Job Error Notification is called once.
No Det errors are reported if configured.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00091</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>88</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00143</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>111</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>299</internalId></specobject>
    <specobject>
      <id>TS_EA_30218</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Conformance_Common/source/application/Tests.c</sourcefile>
      <sourceline>2520</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Testing Ea_Read() with given offset read the right data.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize Ea module.
  Initialize test stubs for EEPROM driver, Nvm and Det if configured.

Write data:
  Call Ea_Write() for block &amp;lt;B2&amp;gt;.
  Wait till the write job is complete.

Read data:
  Call Ea_Read() for block &amp;lt;B2&amp;gt; with offset.

Verify Read:
  Check the read data.

Check the Nvm notification calls and DET errors if configured.
Incase any of the above operation returns unexpected value, set result as failure.

Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On Write data:
  Ea_Write() returns E_OK.
  After the write job is complete, the Ea_GetJobResult is MEMIF_JOB_OK.

On Read data:
  Ea_Read() returns E_OK.

Verification of Read:
  Read data should be equal to writen data.

Nvm Job End Notification is called twice.
Nvm Job Error Notification is not called.
No Det errors are reported if configured.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00021</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>51</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00086</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>83</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>300</internalId></specobject>
    <specobject>
      <id>TS_EA_30225</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Conformance_Common/source/application/Tests.c</sourcefile>
      <sourceline>2675</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Testing whether first Ea_Read() works, even when another Ea_Read()
is called before the first one is completed.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize Ea module.
  Initialize test stubs for EEPROM driver, Nvm and Det if configured.

Write data:
  Call Ea_Write() for block &amp;lt;B4&amp;gt;.
  Wait till the write job is complete.

Read data (first time):
  Reset the Nvm Notification counts.
  Call Ea_Read() for block &amp;lt;B4&amp;gt;.

Read data (second time):
  Call Ea_Read() for block &amp;lt;B3&amp;gt; before the first read job is completed.

Verify Read:
  Wait till the first read job is complete.
  Check Eep_Read is called.
  Check the data read is same as written.

Check the Nvm notification calls and DET errors.
Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested

On Write data:
  Ea_Write should return E_OK.

On Read data (first time):
  Ea_Read() function should return E_OK.

On Read data (second time):
  Ea Read function should return E_NOT_OK.

On Verification of Read:
  Eep_Read() should be called at least once.
  The data read should be same as written.

Nvm Job End Notification is called once.
Nvm Job error Notification is not called.
Det error EA_E_BUSY is reported.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00086</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>83</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00054</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>64</internalId></provcov>
        <provcov>
          <linksto>Ea.Ea_GetJobResult.JobsFromUpperLayer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>175</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>301</internalId></specobject>
    <specobject>
      <id>TS_EA_30226</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Conformance_Common/source/application/Tests.c</sourcefile>
      <sourceline>2866</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Testing whether first Ea_Write() works, even when another Ea_Write()
is called before the first one is completed.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed

Init test:
  Initialize Ea module.
  Initialize test stubs for EEPROM driver, Nvm and Det if configured.

Write data (first time):
  Call Ea_Write() for block &amp;lt;B3&amp;gt;.

Write data (second time):
  Call Ea_Write() for block &amp;lt;B2&amp;gt;.
  Ea_Write() is called before the first call is completed.
  Wait till the first write job is complete.

Read data:
  Call Ea_Read() for block &amp;lt;B3&amp;gt; with offset.

Verify Read:
  Check Eep_Read is called.
  Check the data read is same as written.

Check the Nvm notification calls and DET errors.
Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On Write data (first time):
  Ea_Write() returns E_OK.

On Write data (Second time):
  Ea_Write() is rejected and returns E_NOT_OK.

On Read data:
  Ea_Read() returns E_OK.

Verification of Read:
  Read data should be equal to writen data.

Nvm Job End Notification is called twice.
Nvm Job error Notification is not called.
Det error EA_E_BUSY is reported.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00021</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>51</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00086</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>83</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>302</internalId></specobject>
    <specobject>
      <id>TS_EA_30228</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Conformance_Common/source/application/Tests.c</sourcefile>
      <sourceline>3049</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Testing whether first Ea_InvalidateBlock() works, even when another Ea_InvalidateBlock()
is called before the first one is completed.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize Ea module.
  Initialize test stubs for EEPROM driver, Nvm and Det if configured.

Write Data:
  Call Ea_Write() for block &amp;lt;B4&amp;gt;.
  Check Ea_Write returns E_OK.
  Wait till the write job is complete.
  Check Eep_Write is called.

Read Data (first time):
  Call Ea_Read() for block &amp;lt;B4&amp;gt;.
  Check Ea_Read returns E_OK.
  Wait till the read job is complete.
  Call Ea_GetJobResult() after read job is complete.

Invalidate Block (first time):
  Call Ea_InvalidateBlock() for block &amp;lt;B2&amp;gt;.
  Check Ea_InvalidateBlock returns E_OK.

Invalidate Block (Second time):
  Call Ea_InvalidateBlock() for block &amp;lt;B2&amp;gt; before the first invalidate job
  is completed.
  Check Ea_InvalidateBlock returns E_NOT_OK.
  Wait till the first invalidate job is complete.
  Call Ea_GetJobResult() after Invalidate job is complete.

Read Data (second time):
  Call Ea_Read() for block &amp;lt;B4&amp;gt;.
  Wait till the read job is complete.
  Call Ea_GetJobResult() after read job is complete.
  Check Eep_Read() is called.
  Check the Nvm notification calls and DET errors.

Verify Read:
  Wait till the first read job is complete.
  Check Eep_Read is called.
  Check Ea_GetJobResult().

Check the Nvm notification calls and DET errors.
Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On Write Data:
  Ea_Write() returns E_OK.
  Job result is MEMIF_JOB_OK.

On Read Data (first time):
  Ea_Read() returns E_OK.
  Job result is MEMIF_JOB_OK.

On Invalidate Block (first time):
  Ea_InvalidateBlock() returns E_OK.

On Invalidate Block (Second time):
  Ea_InvalidateBlock() call is rejected and returns E_NOT_OK.

On Read Data (second time):
  Ea_Read() returns E_OK.
  Eep_Read() should be called at least once.
  Job result is MEMIF_BLOCK_INVALID.

Nvm Job End Notification is called thrice.
Nvm Job error Notification is called once.
Det error EA_E_BUSY is reported.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00091</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>88</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00074</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
        <provcov>
          <linksto>Ea.Ea_GetJobResult.JobsFromUpperLayer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>175</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>303</internalId></specobject>
    <specobject>
      <id>TS_EA_30227</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Conformance_Common/source/application/Tests.c</sourcefile>
      <sourceline>3287</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Testing whether first Ea_EraseImmediateBlock() works, even when another
Ea_EraseImmediateBlock() is called before the first one is completed.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize test stubs for EEPROM driver, Nvm and Det if configured.
  Initialize Ea module.

Write data :
  Call Ea_Write() for block &amp;lt;B3&amp;gt;.
  Check Ea_Write() returns E_OK.

Erase immediate block (first time):
  Call Ea_EraseImmediateBlock for block &amp;lt;B4&amp;gt.
  Check Ea_EraseImmediateBlock() returns E_OK.

Erase immediate block (second time):
  Call Ea_EraseImmediateBlock for block &amp;lt;B3&amp;gt.
  Check Ea_EraseImmediateBlock() returns E_NOT_OK.
  Wait till the job is complete.

Read data (first time):
  Call Ea_Read() for block &amp;lt;B4&amp;gt;.
  Wait till the first read job is complete.
  Check Eep_Read is called.
  Check Ea_GetJobResult() after read job is complete.

Read data (second time):
  Call Ea_Read() for block &amp;lt;B3&amp;gt;.
  Wait till the first read job is complete.
  Check Eep_Read is called.
  Check Ea_GetJobResult() after read job is complete.

Check the Nvm notification calls and DET errors.
Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On Write data:
  Ea_Write should return E_OK.

On Erase immediate block (first time):
  Ea_EraseImmediateBlock() return E_OK.

On Erase immediate block (second time):
  Ea_EraseImmediateBlock() return E_NOT_OK.

On Read data (first time):
  Eep_Read() should be called at least once
  Ea_GetJobResult returns MEMIF_BLOCK_INCONSISTENT.

On Read data (second time):
  Eep_Read() should be called at least once.
  The data read should be same as written.
  After the second read Ea_GetJobResult should
  returns MEMIF_JOB_OK.

Nvm Job End Notification is called thrice.
Nvm Job error Notification is called once.
Det error EA_E_BUSY is reported.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00093</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>90</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00054</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>64</internalId></provcov>
        <provcov>
          <linksto>Ea.Ea_GetJobResult.JobsFromUpperLayer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>175</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>304</internalId></specobject>
    <specobject>
      <id>TS_EA_30222</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Conformance_Common/source/application/Tests.c</sourcefile>
      <sourceline>3537</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
To test that data is not corrupted on the next write operation, if Ea blocks
are configured to have a single copy and if the block memory layout of a
following block is equal to the preceding one.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize test stubs for EEPROM driver, Nvm and Det if configured.
  Initialize Ea module.

Write data for block B2 (First time):
  Perform a successful write operation on block &amp;lt;B2&amp;gt;.

Read data from block B2 (First time):
  Read block &amp;lt;B2&amp;gt;.
  Verify that the read data is equal to the written data.

Write data for block B3:
  Perform a successful write operation on block &amp;lt;B3&amp;gt;.

Write data for block B2 (Second time):
  Perform a successful write operation on block &amp;lt;B2&amp;gt;.

Read data from block B2 (Second time):
  Read block &amp;lt;B2&amp;gt;.
  Verify that the read data is equal to the written data.

Read data from block B3:
  Read block &amp;lt;B3&amp;gt;.
  Verify that the read data is equal to the written data.

Check the Nvm notification calls and DET errors.
Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested

On Write data to block B2 (First time):
  Ea_Write() returns with E_OK

On Read data from block B2 (First time):
  Eep_Read() is called.
  The read data is equal to the written data.

On Write data to block B3 (First time):
  Ea_Write() returns with E_OK.

On Write data to block B2 (Second time):
  Ea_Write() returns with E_OK.

On Read data from block B2 (Second time):
  Eep_Read() is called.
  The read data is equal to the written data.

On Read data from block B3:
  Verify that Eep_Read() is called.
  The read data is equal to the written data.

Nvm Job End Notification is called six times.
Nvm Job error Notification is not called.
No Det errors are reported if configured.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00055</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>65</internalId></provcov>
        <provcov>
          <linksto>Ea.Ea_Write.Service</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>169</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>305</internalId></specobject>
    <specobject>
      <id>TS_EA_30234</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Conformance_Common/source/application/Tests.c</sourcefile>
      <sourceline>3785</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Testing the Ea_Cancel functionality while invalidating a block.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an EA Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize Eep driver and test stubs for Nvm and Det if configured.
  Initialize Ea module.

Prepare test scenario:
  Write a block to the EEPROM.
  Wait till the job is complete.

VP(EA077, EA078, EA160):
  Call Ea_Cancel().
  Check the Job Result.

Make module status BUSY:
  Invalidate the block which is written.(Do not call Main Functions)

Cancel the invalidation operation:
  Call Cancel.

VP(EA077, EA078):
  Verify Invalidation(The operation which is canceled):
  Check the Ea status and Job Result.

Check the Nvm notification calls and DET errors if configured.
Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 
None

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On test scenario preparation:
  Write function should return E_OK.
  Job Result should be MEMIF_JOB_OK.

VP(Ea.SWS_Ea_00077, Ea.SWS_Ea_00078, Ea.SWS_Ea_00160):
  As the module status is MEMIF_IDLE, Eep_Cancel should not have been called and module status and
  Job Result should remain same.

On making module status BUSY:
  Invalidate function should return E_OK.
  Ea Status should be MEMIF_BUSY.
  Job Result should be MEMIF_JOB_PENDING.

On Cancel the invalidate operation:
VP(Ea.SWS_Ea_00077, Ea.SWS_Ea_00078):
  As the module status is MEMIF_BUSY, Eep_Cancel should have been called and module status and
  Job Result should be changed.

  After cancellation Ea status should not be MEMIF_BUSY and
  Job Result should be MEMIF_JOB_CANCELED.

Nvm Job End Notification is called once.
Nvm Job Error Notification is called once.
No Det errors are reported if configured.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00078</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>77</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00077</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>76</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00160</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>127</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>306</internalId></specobject>
    <specobject>
      <id>TS_EA_30235</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Conformance_Common/source/application/Tests.c</sourcefile>
      <sourceline>3976</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Testing the Ea_Write, Ea_Read, Ea_GetJobResult and Ea_GetStatus funtionalities
to see behaviour on different combination of function calls.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize Eep driver and test stubs for Nvm and Det if configured.
  Initialize Ea module.

Write data:
  Write a block of data into the EEPROM.
  Check the Ea status and job result just after write.
  Check the Ea status and job result after the completion of the write job.

Read data:
  Read from EEPROM with same block number written before.
  Check the Ea status and job result just after read.
  Check the Ea status and job result after the completion of the read job.
  Compare source and destination buffers for equality.

Check the Nvm notification calls and DET errors if configured.
Incase any of the above operation returns unexpected value, set result as failure.

Test Input: 
None

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On Write data:
  Write function should return E_OK.
  After write Ea_GetStatus should return MEMIF_BUSY and Ea_GetJobResult should return
  MEMIF_JOB_PENDING.
  On completion of write job i.e., Ea_GetJobResult no longer returns MEMIF_JOB_PENDING,
  Ea_GetStatus should return MEMIF_IDLE.

On Read data :
  Read function should return E_OK.
  After read Ea_GetStatus should return MEMIF_BUSY and Ea_GetJobResult should return
  MEMIF_JOB_PENDING.
  On completion of read job i.e., Ea_GetJobResult no longer returns MEMIF_JOB_PENDING,
  Ea_GetStatus should return MEMIF_IDLE.
  Read/write buffer comparison should be successful.

Nvm Job End Notification is called twice.
No Det errors are reported if configured.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00086</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>83</internalId></provcov>
        <provcov>
          <linksto>Ea.Ea_Write.Service</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>169</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00090</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>87</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00089</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>86</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00151</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>119</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>307</internalId></specobject>
    <specobject>
      <id>TS_EA_30230</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Conformance_Common/source/application/Tests.c</sourcefile>
      <sourceline>4155</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
To test that data is not corrupted on the next write operation, if Ea blocks are
configured to have two copies and if the block memory layout of a following block
is equal to the preceding one and NvM callback is disabled.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize Ea module
  Initialize test stubs for EEPROM driver, Nvm and Det.

Write data to block B2 (First time):
  Perform a successful write operation on block &amp;lt;B2&amp;gt;.

Read data from block B2 (First time):
  Read block &amp;lt;B2&amp;gt;.
  Verify that Eep_Read() is called.
  Verify that the read data is equal to the written data.

Write data to block B3:
  Perform a successful write operation on block &amp;lt;B3&amp;gt;.

Write data to block B2 (Second time):
  Perform a successful write operation on block &amp;lt;B2&amp;gt;.

Read data from block B2 (Second time):
  Read block &amp;lt;B2&amp;gt;.
  Verify that Eep_Read() is called.
  Verify that the read data is equal to the written data.

Write data to block B2 (Third time):
  Perform a successful write operation on block &amp;lt;B2&amp;gt;.

Read data from block B2 (Third time):
  Read block &amp;lt;B2&amp;gt;.
  Verify that Eep_Read() is called.
  Verify that the read data is equal to the written data.

Read data from block B3:
  Read block &amp;lt;B3&amp;gt;.
  Verify that Eep_Read() is called.
  Verify that the read data is equal to the written data.

Check the Nvm notification calls and DET errors.
Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On Write data to block B2 (First time):
  Ea_Write() returns with E_OK.

On Read data from block B2 (First time):
  Ea_Read() returns with E_OK.
  Eep_Read() is called once.
  The read data is equal to the written data.

On Write data to block B3:
  Ea_Write() returns with E_OK.

On Write data to block B2 (Second time):
  Ea_Write() returns with E_OK.

On Read data from block B2 (Second time):
  Ea_Read() returns with E_OK.
  Eep_Read() is called once.
  The read data is equal to the written data.

On Write data to block B2 (Third time):
  Ea_Write() returns with E_OK.

On Read data from block B2 (Third time):
  Ea_Read() returns with E_OK.
  Eep_Read() is called once.
  The read data is equal to the written data.

On Read data from block B3:
  Ea_Read() returns with E_OK.
  Eep_Read() is called once.
  The read data is equal to the written data.

Nvm Job End Notification is called eight times.
No Det errors are reported if configured.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00055</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>65</internalId></provcov>
        <provcov>
          <linksto>Ea.Ea_Write.Service</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>169</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>308</internalId></specobject>
    <specobject>
      <id>TS_EA_SetMode</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Conformance_Common/source/application/Tests.c</sourcefile>
      <sourceline>4468</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Verify whether Ea_SetMode call the function "Eep_SetMode" only if the current module state
is  MEMIF_IDLE.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 
01. Initialize Ea module.
02. Confirm the module status is MEMIF_IDLE
03. Set the operation mode of the EEPROM driver as MEMIF_MODE_FAST.
04. Confirm the operation mode of the EEPROM driver as MEMIF_MODE_FAST.
05. Set the operation mode of the EEPROM driver as MEMIF_MODE_SLOW.
06. VP(Ea.SWS_Ea_00020):
    Check that Eep_SetMode() is called and mode is changed to SLOW since Ea state is IDLE.
07. Call Ea_Write function with valid Block and valid buffer pointer
    to make the module status as MEMIF_BUSY.
08. Confirm the module status is MEMIF_BUSY
09. Call Ea_SetMode with MEMIF_MODE_FAST as parameter.
10. VP(Ea.SWS_Ea_00020):
    Check that Eep_SetMode() is not called and mode is not changed since Ea state is BUSY.

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00085</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>82</internalId></provcov>
        <provcov>
          <linksto>Ea.ASR40.SWS_Ea_00020</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>5</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>309</internalId></specobject>
    <specobject>
      <id>TS_EA_Ea_Read_n_Write</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Conformance_Common/source/application/Tests.c</sourcefile>
      <sourceline>4590</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Verify whether Ea_Read/Write reject the job request and return with E_NOT_OK if current module
status is MEMIF_UNINIT or MEMIF_BUSY during DET OFF.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
Configuration parameters EaDevErrorDetect and EaSetModeSupported are set to false.

Test Execution: 
01. Call Ea_Write with valid block number and buffer before EA init so that current module status
    is MEMIF_UNINIT.
02. VP(Ea.Ea_Write.RejectJobRqst):
    Check that Ea_Write returns E_NOT_OK.
    Confirm no DET error is reported.
03. Call Ea_Read with valid block number and buffer parameter before EA init.
04. VP(Ea.Ea_Read.RejectJobRqst):
    Check that Ea_Read returns E_NOT_OK.
    Confirm no DET error is reported.
05. Initialize the Eep, DET and EA module
06. Call Ea_Write function with valid Block and valid buffer pointer
    to make the module status as MEMIF_BUSY.
07. Call Ea_Write with valid block number and buffer
08. VP(Ea.Ea_Write.RejectJobRqst):
    Check that Ea_Write returns E_NOT_OK.
    Confirm no DET error is reported.
09. Call Ea_Read with valid block number and buffer parameter
10. VP(Ea.Ea_Read.RejectJobRqst):
    Check that Ea_Read returns E_NOT_OK.
    Confirm no DET error is reported.

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.Ea_Read.RejectJobRqst</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>171</internalId></provcov>
        <provcov>
          <linksto>Ea.Ea_Write.RejectJobRqst</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>173</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>310</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_EA_30055</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Det_Common/source/application/tests_Det.c</sourcefile>
      <sourceline>45</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
To test that DET reports error for the API calls with invalid block number.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Init test:
  Initialize test stubs for EEPROM driver, Nvm and Det.
  Initialize Ea module.

DET check for Ea_Read:
  Call Ea_Read with block number which are not configured.
  Check Det_ReportError() is called.
  Check Ea_Read() returns E_NOT_OK.
  Check Eep_Read() is not called.

DET check for Ea_Write:
  Call Ea_Write() with block number which are not configured.
  Check Det_ReportError() is called.
  Check Ea_Write() returns E_NOT_OK.
  Check Eep_Write() is not called.

DET check for Ea_InvalidateBlock:
  Call Ea_InvalidateBlock() with block number which are not configured.
  Check Det_ReportError() is called.
  Check Ea_InvalidateBlock() returns E_NOT_OK.
  Check Eep_Write() is not called.

DET check for Ea_EraseImmediateBlock:
  Call Ea_EraseImmediateBlock() with block number which are not configured.
  Check Det_ReportError() is called.
  Check Ea_EraseImmediateBlock() returns E_NOT_OK.
  Check Eep_Erase() is not called.

DET check for Ea_EraseImmediateBlock for non-immedate block:
  Call Ea_EraseImmediateBlock() with block number which are not configured as "Immediate".
  Check Det_ReportError() is called.
  Check Ea_EraseImmediateBlock() returns E_NOT_OK.
  Check Eep_Erase() is not called.

Check current module status and JobResult are not changed.


Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

DET check for Ea_Read:
  Ea_Read() calls Det_ReportError() with the error value EA_E_INVALID_BLOCK_NO;
  returns E_NOT_OK.
  Eep_Read() is not called.

DET check for Ea_Write:
  Ea_Write() calls Det_ReportError() with the error value EA_E_INVALID_BLOCK_NO;
  returns E_NOT_OK.
  Eep_Write() is not called.

DET check for Ea_InvalidateBlock:
  Ea_InvalidateBlock() calls Det_ReportError() with the error value EA_E_INVALID_BLOCK_NO;
  returns E_NOT_OK.
  Eep_Write() is not called.

DET check for Ea_EraseImmediateBlock:
  Ea_EraseImmediateBlock() calls Det_ReportError() with the error value EA_E_INVALID_BLOCK_NO;
  returns E_NOT_OK.
  Eep_Erase() is not called.

DET check for Ea_EraseImmediateBlock for non-immedate block:
  Ea_EraseImmediateBlock() calls Det_ReportError() with the error value EA_E_INVALID_BLOCK_NO;
  returns E_NOT_OK.
  Eep_Erase() is not called.

Current module status and JobResult are not changed.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.ASR40.SWS_Ea_00011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>3</internalId></provcov>
        <provcov>
          <linksto>Ea.ASR40.SWS_Ea_00059</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>11</internalId></provcov>
        <provcov>
          <linksto>Ea.ASR40.SWS_Ea_00045</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>6</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00065</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>69</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00147</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>115</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00148</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>116</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00149</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>117</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00152</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00158</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>125</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00161</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>128</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00159</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>126</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00162</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>129</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>311</internalId></specobject>
    <specobject>
      <id>TS_EA_30237</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Det_Common/source/application/tests_Det.c</sourcefile>
      <sourceline>276</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
The sequence calls Ea_Read() and Ea_Write() with DataBufferPtr parameter
as NULL pointer and checks that EA_E_INVALID_DATA_PTR is reported to the DET.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize Det stub.
  Initialize Ea module.

Call Ea_Write:
  Call Ea_Write() with DataBufferPtr as NULL pointer.
  Check Det_ReportError() is called.
  Check Ea_Write() returns E_NOT_OK.
  Check Eep_Write() is not called.

Call Ea_Read:
  Call Ea_Read() with DataBufferPtr as NULL pointer.
  Check Det_ReportError() is called.
  Check Ea_Read() returns E_NOT_OK.
  Check Eep_Read() is not called.

On Status check:
  Check current module status is not changed.
  Check JobResult is not changed.


Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On Ea_Write Call:
  Ea_Write() calls Det_ReportError() with the error value EA_E_INVALID_DATA_PTR;
  returns E_NOT_OK.
  Eep_Write() is not called.

On Ea_Read Call:
  Ea_Read() calls Det_ReportError() with the error value EA_E_INVALID_DATA_PTR;
  returns E_NOT_OK.
  Eep_Read() is not called.

On Status check:
  Current module status is not changed.
  JobResult is not changed.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00170</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>135</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00172</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>137</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00158</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>125</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00159</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>126</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>312</internalId></specobject>
    <specobject>
      <id>TS_EA_30231</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Det_Common/source/application/tests_Det.c</sourcefile>
      <sourceline>431</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Call Ea_Read() with BlockOffset parameter invalid value and
checks that EA_E_INVALID_BLOCK_OFS is reported to the DET.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize Det stub.
  Initialize Ea module.

Call Ea_Read:
  Call Ea_Read() with BlockOffset parameter as invalid value.
  Check Det_ReportError() is called.
  Check Ea_Read() returns E_NOT_OK.
  Check Eep_Read() is not called.

  Check current module status.
  Check JobResult.


Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On Ea_Read Call:
  Ea_Read() calls Det_ReportError() with the error value EA_E_INVALID_BLOCK_OFS;
  returns E_NOT_OK.
  Eep_Read() is not called.

  Current module status is not changed.
  JobResult is not changed.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00168</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00158</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>125</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>313</internalId></specobject>
    <specobject>
      <id>TS_EA_30232</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Det_Common/source/application/tests_Det.c</sourcefile>
      <sourceline>550</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Calls Ea_Read() with Length parameter as invalid value and
checks that EA_E_INVALID_BLOCK_LEN is reported to the DET.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize Det stub.
  Initialize Ea module.

Call Ea_Read:
  Call Ea_Read() with Length parameter as invalid value.
  Check Det_ReportError() is called.
  Check Ea_Read() returns E_NOT_OK.
  Check Eep_Read() is not called.
  Check current module status.
  Check JobResult.


Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On Ea_Read Call:
  Ea_Read() calls Det_ReportError() with the error value EA_E_INVALID_BLOCK_LEN;
  returns E_NOT_OK.
  Eep_Read() is not called.
  Current module status is not changed.
  JobResult is not changed.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00169</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>134</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00158</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>125</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>314</internalId></specobject>
    <specobject>
      <id>TS_EA_DetBusy</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Det_Common/source/application/tests_Det.c</sourcefile>
      <sourceline>667</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
Verify whether development error EA_E_BUSY is reported by Ea_Write, Ea_Read, Ea_SetMode, Ea_InvalidateBlock and Ea_EraseImmediateBlock,
if current module status is MEMIF_BUSY
&lt;/para&gt;

Test Object: None.
Test Precondition: 
Configuration parameters EaDevErrorDetect and EaSetModeSupported are set to true

Test Execution: 
01. Initialize the Eep, DET and EA module
02. Call Ea_Write function with valid Block and valid buffer pointer
    to make the module status as MEMIF_BUSY.
03. Call Ea_SetMode.
04. VP(EA165): Check that error EA_E_BUSY is reported by Ea_SetMode
05. Call Ea_Write with valid block number and buffer
06. VP(EA171): Check that error EA_E_BUSY is reported by Ea_Write
07. Call Ea_Read with valid block number and buffer parameter
08. VP(EA167): Check that error EA_E_BUSY is reported by Ea_Read
09. Call Ea_InvalidateBlock with valid block number
10. VP(EA175): Check that error EA_E_BUSY is reported by Ea_InvalidateBlock
11. Call Ea_EraseImmediateBlock with valid block number
12. VP(EA176): Check that error EA_E_BUSY is reported by Ea_EraseImmediateBlock
13. Call Ea_GetStatus and Ea_GetJobResult.
14. VP(EA158, EA161, EA159, EA162): Check current module status and job result is not changed.

Test Input: 

Test Output: 

</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00165</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00167</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>132</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00171</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>136</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00176</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>141</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00175</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>140</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00158</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>125</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00161</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>128</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00159</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>126</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00162</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>129</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>315</internalId></specobject>
    <specobject>
      <id>TS_EA_DetInvalidCancel</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Det_Common/source/application/tests_Det.c</sourcefile>
      <sourceline>842</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Verify whether Ea_Cancel() reports development error
EA_E_INVALID_CANCEL, if current module status is not MEMIF_BUSY.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
Common configuration parameter EaDevErrorDetect set to true.

Test Execution: 
01. Initialize the Eep, DET and EA module
02. Call Ea_Cancel()
03. VP(EA173): Check that error EA_E_INVALID_CANCEL is reported by Ea_cancel

Test Input: 

Test Output: 

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00173</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>138</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>316</internalId></specobject>
    <specobject>
      <id>TS_EA_30238</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Det_Common/source/application/tests_Det.c</sourcefile>
      <sourceline>910</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Calls Ea_GetVersionInfo() with Null Pointer as parameter;
checks that EA_E_INVALID_DATA_PTR is reported to the DET.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Init test:
  Initialize Det stub.
  Initialize Ea module.

Call Ea_GetVersionInfo:
  Call Ea_GetVersionInfo() with Null pointer.
  Check Det_ReportError() is called.


Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On Ea_SetMode Call:
  Ea_GetVersionInfo() calls Det_ReportError() with the error value EA_E_INVALID_DATA_PTR.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00164</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>130</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>317</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_EA_30082</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_EB_Conformance_Common/source/application/EB_tests.c</sourcefile>
      <sourceline>50</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Testing the Job result and Ea status after Ea_Read for a block
and to check the job is done within Main Function.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize test stubs for EEPROM driver, Nvm and Det if configured.
  Initialize Ea module.

Prepare test scenario:
  Write a block of data into the EEPROM.
  Wait till the block is written completely.

Read data:
  Call Ea_Read() for the same block.

Verify Read:
  Check the Ea status and job result just after read.
  Check the Ea status after the completion of the read job.
  Check Eep_Read() is called.
  Compare source and destination buffers for equality.

Check the Nvm notification calls and DET errors if configured.
Incase any of the above operation returns unexpected value, set result as failure.

Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On test scenario preparation:
  Write function should return E_OK.

On Read data :
  Ea Read function should return E_OK.

On verification of Read:
  After read call, Ea_GetStatus should return MEMIF_BUSY and Ea_GetJobResult should return
  MEMIF_JOB_PENDING.
  On completion of read, Ea_GetStatus should return MEMIF_IDLE and Ea_GetJobResult should
  return MEMIF_JOB_OK.
  Eep_Read() is called atleast once.
  The source and destination buffers should be equal.

Nvm Job End Notification is called once.
Nvm Job error Notification is not called.
No Det errors reported if configured.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.Ea_Read.Acceptance</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>165</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00072</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>318</internalId></specobject>
    <specobject>
      <id>TS_EA_30092</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_EB_Conformance_Common/source/application/EB_tests.c</sourcefile>
      <sourceline>220</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Testing Ea_GetJobResult() to retrieve the different possible driver job results.
MEMIF_BLOCK_INCONSISTENT is tested in implementation tests
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Init test:
  Initialize test stubs for EEPROM driver, Nvm and Det if configured.
  Initialize Ea module.
  Erase Eeprom Memory.

JobResult MEMIF_JOB_FAILED:
  Write a block.
  Set Eep Get Job Result value to MEMIF_JOB_FAILED.
  Wait till the write job fails.
  Check the job result by calling Ea_GetJobResult().

JobResult MEMIF_JOB_OK:
  Write a block, wait for the write job to be finished successfully.
  Check the job result by calling Ea_GetJobResult().

JobResult MEMIF_BLOCK_INVALID:
  Invalidate written data block.
  Read the invalidate block, wait till the read job is finished.
  Check the job result by calling Ea_GetJobResult().

JobResult MEMIF_JOB_PENDING:
  Start writing a block using Ea_Write().
  Check if Eep_Write is not called.
  Check the job result by calling Ea_GetJobResult() before the write job is finished.

JobResult MEMIF_JOB_CANCELED:
  Wait until Eep stub write function is called by calling Ea_MainFunction and Eep_MainFunction.
  Cancel writing immediately so that data is not written properly.
  Check the job result by calling Ea_GetJobResult().


Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

JobResult MEMIF_JOB_FAILED:
  Ea_GetJobResult() returns MEMIF_JOB_FAILED.

JobResult MEMIF_JOB_OK:
  Ea_GetJobResult() returns MEMIF_JOB_OK.

JobResult MEMIF_BLOCK_INVALID:
  Ea_GetJobResult() returns MEMIF_BLOCK_INVALID.

JobResult MEMIF_JOB_PENDING:
  Ea_GetJobResult() returns MEMIF_JOB_PENDING.

JobResult MEMIF_JOB_CANCELED:
  Ea_GetJobResult() returns MEMIF_JOB_CANCELED.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00090</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>87</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00035</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>57</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>319</internalId></specobject>
    <specobject>
      <id>TS_EA_30124</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_EB_Conformance_Common/source/application/EB_tests.c</sourcefile>
      <sourceline>432</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Testing the read of invalidate block.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed

Init test:
  Initialize test stubs for EEPROM driver, Nvm and Det if configured.
  Initialize Ea module.

Write data:
  Write a block of data into the flash.
  Check the Ea status and job result after the completion of the write job.

Invalidate Block:
  Invalidate the block which is written.
  Wait till the invalidate job is complete.

Read Data after invalidate:
  Read flash with same block number invalidated before.
  Check the Ea status and job result after the completion of the read job.

Check the Nvm notification calls and DET errors if configured.
Incase any of the above operation returns unexpected value, set result as failure.

Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On Write data:
  Write function should return E_OK.
  On completion of write job, GetStatus function should return MEMIF_IDLE and
  GetJobResult should return MEMIF_JOB_OK.

On Invalidate the block:
  Invalidate function should return E_OK

On read data after invalidate:
  Read function should return E_OK.
  On completion of read job, Ea status should return MEMIF_IDLE and GetJobResult
  should return MEMIF_BLOCK_INVALID.

Nvm Job End Notification is called thrice.
Nvm Job Error Notification is called once.
No Det errors are reported if configured.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00074</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>320</internalId></specobject>
    <specobject>
      <id>TS_EA_30221</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_EB_Conformance_Common/source/application/EB_tests.c</sourcefile>
      <sourceline>585</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
To check the call of Ea_MainFunction() without module initialization, does not report DET
and does not perform any functionality.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
EA is not initialized.

Test Execution: 

Init test:
  Initialize test stubs for EEPROM driver, Nvm and Det if configured.

Call Ea_MainFunction:
  Call Ea_MainFunction().
  Check Det_ReportError() is not called, if DET is configured.
  Check Eep functions are not called.


Test Input: 

Test Output: 

On Ea_MainFunction Call:
  Ea_MainFunction() shall not call Det_ReportError() if configured.
  No Eep functions are called.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.MainFunction.InitCheck</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>181</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>321</internalId></specobject>
    <specobject>
      <id>TS_EA_30236</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_EB_Conformance_Common/source/application/EB_tests.c</sourcefile>
      <sourceline>665</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Testing a job requested when the module status is MEMIF_BUSY gets rejected.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize Eeprom driver and test stubs for Nvm and Det if configured.
  Initialize Ea module.

Prepare test scenario:
  Call Ea_Write() to make the module busy.
  Check the Ea status is MEMIF_BUSY by calling Ea_GetStatus().
  Do not call Ea_MainFunction and Eep_MainFunction.

Call Ea_Write:
  Call Ea_Write with a valid block number.
  Check write is rejected by giving a return value E_NOT_OK.
  Check Eep_Write() is not called.

Call Ea_Read:
  Call Ea_Read with a valid block number.
  Check read is rejected by giving a return value E_NOT_OK.
  Check Eep_Read() is not called.

Call Ea_InvalidateBlock:
  Call Ea_InvalidateBlock with a valid block number.
  Check invalidate is rejected by giving a return value E_NOT_OK.
  Check Eep_Write() is not called.

  Call Ea_EraseImmediateBlock:
  Call Ea_EraseImmediateBlock with a valid block number.
  Check EraseImmediate is rejected by giving a return value E_NOT_OK.
  Check Eep_Erase() is not called.

Check the Nvm notification calls and DET errors if configured.
Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 
None

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On test scenario preparation:
  Ea_Write() returns E_OK.
  Ea_GetStatus returns MEMIF_BUSY.

On call of Ea_Write:
  Ea_Write() returns E_NOT_OK.
  Eep_Write() is not called.

On call of Ea_Read:
  Ea_Read() returns E_NOT_OK.
  Eep_Read() is not called.

On call of Ea_InvalidateBlock:
  Ea_InvalidateBlock() returns E_NOT_OK.
  Eep_Write() is not called.

On call of Ea_EraseImmediateBlock:
  Ea_EraseImmediateBlock() returns E_NOT_OK.
  Eep_Erase() is not called.

Nvm Job End Notification is not called.
Nvm Job Error Notification is not called.
Det error EA_E_BUSY is reported.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00137</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>108</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>322</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_EA_30220</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_EB_Det_Common/source/application/EB_tests_Det.c</sourcefile>
      <sourceline>47</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
The sequence calls all API-functions except Ea_Init() and Ea_MainFunction() while the EA
is not initialized and checks that EA_E_UNINIT is reported to the DET.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
EA is not initialized

Test Execution: 

Init test:
  Initialize test stubs for EEPROM driver, Nvm and Det.

Call Ea_Write:
  Call Ea_Write() with a valid block number.
  Check Det_ReportError() is called.
  Check Ea_Write() returns E_NOT_OK.
  Check Eep_Write() is not called.

Call Ea_Read:
  Call Ea_Read() with a valid block number.
  Check Det_ReportError() is called.
  Check Ea_Read() returns E_NOT_OK.
  Check Eep_Read() is not called.

Call Ea_InvalidateBlock:
  Call Ea_InvalidateBlock() with a valid block number.
  Check Det_ReportError() is called.
  Check Ea_InvalidateBlock() returns E_NOT_OK.
  Check Eep_Write() is not called.

Call Ea_EraseImmediateBlock:
  Call Ea_EraseImmediateBlock() with a valid block number.
  Check Det_ReportError() is called.
  Check Ea_EraseImmediateBlock() returns E_NOT_OK.
  Check Eep_Erase() is not called.

Call Ea_SetMode:
  Call Ea_SetMode() with valid mode.
  Check Det_ReportError() is called.
  Check Eep_SetMode() is not called.

Call Ea_GetStatus:
  Call Ea_GetStatus().
  Check Det_ReportError() is called.
  Check Ea_GetStatus() returns MEMIF_UNINIT.
  Check Eep_GetStatus() is not called.

Call Ea_GetJobResult:
  Call Ea_GetJobResult().
  Check Det_ReportError() is called.
  Check Ea_GetJobResult() returns MEMIF_JOB_FAILED.
  Check Eep_GetJobResult() is not called.

Call Ea_Cancel:
  Call Ea_Cancel().
  Check Det_ReportError() is called.
  Check Eep_Cancel() is not called.


Test Input: 

Test Output: 

On Ea_Write Call:
  Ea_Write() calls Det_ReportError() with the error value EA_E_UNINIT;
  returns E_NOT_OK.
  Eep_Write() is not called.

On Ea_Read Call:
  Ea_Read() calls Det_ReportError() with the error value EA_E_UNINIT;
  returns E_NOT_OK.
  Eep_Read() is not called.

On Ea_InvalidateBlock Call:
  Ea_InvalidateBlock() calls Det_ReportError() with the error value
  EA_E_UNINIT; returns E_NOT_OK.
  Eep_Write() is not called.

On Ea_EraseImmediateBlock Call:
  Ea_EraseImmediateBlock() calls Det_ReportError() with the error value
  EA_E_UNINIT; returns E_NOT_OK.
  Eep_Erase() is not called.

On Ea_SetMode Call:
  Ea_SetMode() calls Det_ReportError() with the error value
  EA_E_UNINIT; Eep_SetMode() is not called.

On Ea_GetStatus Call:
  Ea_GetStatus() calls Det_ReportError() with the error value
  EA_E_UNINIT; returns MEMIF_UNINIT.
  Eep_GetStatus() is not called.

On Ea_GetJobResult Call:
  Ea_GetJobResult() calls Det_ReportError() with the error value
  EA_E_UNINIT; returns MEMIF_JOB_FAILED.
  Eep_GetStatus() is not called.

On Ea_Cancel Call:
  Ea_Cancel() calls Det_ReportError() with the error value
  EA_E_UNINIT; Eep_Cancel is not called.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00129</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>101</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00130</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>102</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00131</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>103</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00132</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>104</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00134</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00135</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>106</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00136</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>107</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00034</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>56</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00158</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>125</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00161</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>128</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00159</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>126</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00162</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>129</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>323</internalId></specobject>
    <specobject>
      <id>TS_EA_30233</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_EB_Det_Common/source/application/EB_tests_Det.c</sourcefile>
      <sourceline>335</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Calls Ea_SetMode() with invalid value for Mode parameter;
checks that EA_E_INVALID_MODE is reported to the DET.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize Det stub.
  Initialize Ea module.

Call Ea_SetMode:
  Call Ea_SetMode() with invalid value for Mode.
  Check Det_ReportError() is called.
  Check Eep_SetMode() is not called.


Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On Ea_SetMode Call:
  Ea_SetMode() calls Det_ReportError() with the error value EA_E_INVALID_MODE.
  Eep_SetMode() is not called.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.Mode.DET</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>182</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>324</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_EA_40035</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Implementation_Common/source/application/Tests.c</sourcefile>
      <sourceline>67</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
Test operations:
Ea_Read, Ea_Write, Ea_EraseImmediateBlock, Ea_InvalidateBlock

These operations are tested together to check implementation features:
block structure as defined in design spec
use of VLE, VLE search algorithm
memory addressing using memory state checks

Configured blocks shall include:
blocks with and without VLE (determined by write cycles configured)
i) with one copy (no VLE)
ii) with two copies
iii) with 4 copies

blocks with and without immediate data, one with VLE, one without

blocks with data such that:
i) data plus both VLECs fit in first virtual page - 2 pages per block
ii) data plus first VLEC fit in first virtual page - 3 pages per block, only VLEC in second page
iii) data bytes -1 plus first VLEC fit in first virtual page - 3 pages per block, second page has one data byte, padding, VLEC

&lt;/para&gt;

Test Object: None.
Test Precondition: 
Internal memory in stub initialised to erase value

eep stub
erase value used as configured for eep, e.g. 0xff not 0!

virtual page size configured to 1
BUG reference ASCEA-154
Test reference ASCEA-166


Test Execution: 
Unless otherwise stated,  after each module call, the test should call main function (to execute the state machine states)
until the module reaches the idle state.

Check behaviour of EA when eeprom erased:
  call Ea_Read, Ea_GetJobStatus
  call Ea_InvalidateBlock, Ea_GetJobStatus
  call Ea_EraseBlock, Ea_GetJobStatus

Check behaviour of EA during Write/Read, block address calculation, consistency:
loop 5 times to ensure wrap around:
  Write data to each block, Read data back
  check memory of all copies for block

Check invalidation:
  call Ea_InvalidateBlock for block with single copy, also for block with multiple copies
  attempt read on invalidated blocks, call Ea_GetJobStatus

Check erase immediate, block calc:
  call Ea_EraseImmediateBlock for blocks configured as immediate data
  read back from eep with expected address for next copy, check memory has been erased

Check module busy:
  Start a valid read but don't call main function
  (keep in busy state), then
  call Ea_Read, Ea_Write, Ea_InvalidateBlock, Ea_EraseImmediateBlock
  after each call check status - call Ea_GetJobStatus

Check handling when EEP returns errors:
  call Ea_Read, Ea_Write, Ea_EraseImmediate
  after each call check status - call Ea_GetJobStatus



Test Input: 

Test Output: 
Behaviour of EA when eeprom erased:
  on read, module returns MEMIF_BLOCK_INVALID
  on invalidate, module returns MEMIF_JOB_FAILED
  on erase, module returns MEMIF_JOB_OK

Behaviour of  EA during Write/Read:
  read back data should be same as data written
  memory area of all copies should reflect most recent change

Invalidation:
  check memory area of all copies - most recent copy should have invalid flag set to invalid pattern
  on read of invalidated block, getstatus returns MEMIF_BLOCK_INVALID

Erase immediate:
  next copy (if VLE used) or only copy( if no VLE)  of  block is erased

Module busy:
  on each call to the module while in the busy state,
  the function return value should be E_NOT_OK and the job status MEMIF_JOB_PENDING

Handling when EEP returns errors:
  module returns MEMIF_JOB_FAILED for each case

</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00024</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>53</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00036</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>58</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00037</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00056</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>66</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00063</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>67</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00064</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>68</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00074</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
        <provcov>
          <linksto>Ea.EB.Ea_Init</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>183</internalId></provcov>
        <provcov>
          <linksto>Ea.SWS_Ea_00080</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>79</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>325</internalId></specobject>
    <specobject>
      <id>TS_EA_40001</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Implementation_Common/source/application/Tests.c</sourcefile>
      <sourceline>430</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
Test operation:
Ea_Read
Bug reference: ASCEA-155
Test reference: ASCEA-167


Configured blocks shall include:
See test case TS_EA_40035
Additionally,
Internal buffersize into which at least one block fits entirely

&lt;/para&gt;

Test Object: None.
Test Precondition: 
Internal memory in stub initialised to erase value
eep stub:
  erase value used as configured for eep, e.g. 0xff not 0!

Test Execution: 
Unless otherwise stated,  after each module call, the test should call main function (to execute the state machine states)
until the module reaches the idle state.


Check behaviour of EA during Read, block address calculation when user data fits entirely into internal buffer:
  write data to block
  read back data starting at block index 0, 1, datasize-1, datasize
  in each case compare data read back with data written


Test Input: 

Test Output: 
  in each case, data comparison should be successful

</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00021</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>51</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>326</internalId></specobject>
    <specobject>
      <id>TS_EA_40002</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Implementation_Common/source/application/Tests.c</sourcefile>
      <sourceline>547</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
Test operation:
Ea_Read
Bug reference: ASCEA-209

Configured blocks shall include:
See test case TS_EA_40035

&lt;/para&gt;

Test Object: None.
Test Precondition: 
Internal memory in stub initialised to erase value
eep stub:
  erase value used as configured for eep, e.g. 0xff not 0!

Test Execution: 
Unless otherwise stated,  after each module call, the test should call main function (to execute the state machine states)
until the module reaches the idle state.

Check behaviour of EA during Read when block is erased after having once been written
(read erased memory that has not been written is tested in 40035 above)
Choose blocknumber with single copy, then choose block with multiple copies
For each case:
  write data to block
  read back data
  erase block
  attempt read
  check jobresult


Test Input: 

Test Output: 
In each case:
  write data shall be OK
  read back data shall be OK
  erase data shall be OK

in case of single copy:
  on read, GetJobResult shall return MEMIF_BLOCK_INVALID

in case of multiple copies:
  on read, GetJobResult shall return MEMIF_BLOCK_INVALID

</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00021</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>51</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>327</internalId></specobject>
    <specobject>
      <id>TS_EA_40003</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Implementation_Common/source/application/Tests.c</sourcefile>
      <sourceline>659</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Test operation:
Ea_GetJobResult
Bug reference: ASCEA-210/EBAEA-21

Configured blocks shall include:
See test case TS_EA_40035

&lt;/para&gt;

Test Object: None.
Test Precondition: 
Ea initialized

Test Execution: 
  - Set Eep stub value to MEMIF_JOB_CANCELED.
  - Write a block to get Ea to be not in idle state.
  - Call Ea_GetJobResult().

Test Input: 

Test Output: 
  - Eep_GetJobResult() has NOT been called.
  - Ea_GetJobResult() returns MEMIF_JOB_PENDING and not MEMIF_JOB_CANCELED as
    the Eep Stub would.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00090</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>87</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>328</internalId></specobject>
    <specobject>
      <id>TS_EA_40041</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Implementation_Common/source/application/Tests.c</sourcefile>
      <sourceline>766</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Test to check the behaviour of Ea in the case the underlying driver returns E_NOT_OK in
state EA_S_WRITE_START_MARKER.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize test stubs for EEPROM driver, Nvm and Det if configured.
  Initialize Ea module.

Write data:
  Call Ea_Write for a logical block.
  Wait till the state is EA_S_WRITE_START_MARKER.
  Set the Eep_Write() return value as E_NOT_OK.
  Wait till the write job is complete.
  Check the Ea job result after the completion of the write job.

Check the Nvm notification calls and DET errors if configured.
Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On Write data:
  Write function should return E_OK.
  Ea_GetJobResult should return MEMIF_JOB_FAILED.

Nvm Job End Notification is not called.
Nvm Job error Notification is called once.
No Det errors reported.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00055</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>65</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>329</internalId></specobject>
    <specobject>
      <id>TS_EA_40043</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Implementation_Common/source/application/Tests.c</sourcefile>
      <sourceline>914</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Test to check the behaviour of Ea in the case the underlying driver returns E_NOT_OK in
state EA_S_WRITE_END_MARKER.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize test stubs for EEPROM driver, Nvm and Det if configured.
  Initialize Ea module.

Write data:
  Call Ea_Write for a logical block.
  Wait till the state is EA_S_WRITE_END_MARKER.
  Set the Eep_Write() return value as E_NOT_OK.
  Wait till the write job is complete.
  Check the Ea job result after the completion of the write job.

Check the Nvm notification calls and DET errors if configured.
Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On Write data:
  Write function should return E_OK.
  Ea_GetJobResult should return MEMIF_JOB_FAILED.

Nvm Job End Notification is not called.
Nvm Job error Notification is called once.
No Det errors reported.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00055</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>65</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>330</internalId></specobject>
    <specobject>
      <id>TS_EA_40044</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Implementation_Common/source/application/Tests.c</sourcefile>
      <sourceline>1062</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Test to check the behaviour of Ea in the case the underlying driver returns E_NOT_OK in
state EA_S_READ_START_MARKER.
(Only one configuration with buffer size greater than block size is tested since the code
implementation uses only one point of return for an E_NOT_OK response from Eep_Read())
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize test stubs for EEPROM driver, Nvm and Det if configured.
  Initialize Ea module.

Write data:
  Call Ea_Write for a logical block.
  Wait till the write job is complete.

Read data:
  Call Ea_Read for the same block.
  Wait till the state is EA_S_READ_START_MARKER.
  Set the Eep_Read() return value as E_NOT_OK.
  Wait till the read job is complete.
  Check the Ea job result after the completion of the read job.

Check the Nvm notification calls and DET errors if configured.
Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On Write data:
  Write function should return E_OK.

On Read data:
  Read function should return E_OK.
  Ea_GetJobResult should return MEMIF_JOB_FAILED.

Nvm Job End Notification is called once.
Nvm Job error Notification is called once.
No Det errors reported.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00055</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>65</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>331</internalId></specobject>
    <specobject>
      <id>TS_EA_40045</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Implementation_Common/source/application/Tests.c</sourcefile>
      <sourceline>1235</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Test to check the behaviour of Ea in the case the underlying driver returns E_NOT_OK in
state EA_S_READ_END_MARKER.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize test stubs for EEPROM driver, Nvm and Det if configured.
  Initialize Ea module.

Write data:
  Call Ea_Write for a logical block.
  Wait till the write job is complete.

Read data:
  Call Ea_Read for the same block.
  Wait till the state is EA_S_READ_END_MARKER.
  Set the Eep_Read() return value as E_NOT_OK.
  Wait till the read job is complete.
  Check the Ea job result after the completion of the read job.

Check the Nvm notification calls and DET errors if configured.
Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On Write data:
  Write function should return E_OK.

On Read data:
  Read function should return E_OK.
  Ea_GetJobResult should return MEMIF_JOB_FAILED.

Nvm Job End Notification is called once.
Nvm Job error Notification is called once.
No Det errors reported.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00055</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>65</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>332</internalId></specobject>
    <specobject>
      <id>TS_EA_40046</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Implementation_Common/source/application/Tests.c</sourcefile>
      <sourceline>1406</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Test to check the behaviour of Ea in the case the underlying driver returns E_NOT_OK in
state EA_S_READ_DATA.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize test stubs for EEPROM driver, Nvm and Det if configured.
  Initialize Ea module.

Write data:
  Call Ea_Write for a logical block.
  Wait till the write job is complete.

Read data:
  Call Ea_Read for the same block.
  Wait till the state is EA_S_READ_DATA.
  Set the Eep_Read() return value as E_NOT_OK.
  Wait till the read job is complete.
  Check the Ea job result after the completion of the read job.

Check the Nvm notification calls and DET errors if configured.
Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On Write data:
  Write function should return E_OK.

On Read data:
  Read function should return E_OK.
  Ea_GetJobResult should return MEMIF_JOB_FAILED.

Nvm Job End Notification is called once.
Nvm Job error Notification is called once.
No Det errors reported.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00055</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>65</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>333</internalId></specobject>
    <specobject>
      <id>TS_EA_40047</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Implementation_Common/source/application/Tests.c</sourcefile>
      <sourceline>1577</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Test to check the behaviour of Ea in the case the underlying driver returns E_NOT_OK in
state EA_S_ERASE_IMMEDIATE.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize test stubs for EEPROM driver, Nvm and Det if configured.
  Initialize Ea module.

Write data:
  Call Ea_Write for a logical block.
  Wait till the write job is complete.

Erase Immediate data:
  Call Ea_EraseImmediateBlock for the same block.
  Wait till the state is EA_S_ERASE_IMMEDIATE.
  Set the Eep_Erase() return value as E_NOT_OK.
  Wait till the erase immediate job is complete.
  Check the Ea job result after the completion of the erase immediate job.

Check the Nvm notification calls and DET errors if configured.
Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On Write data:
  Write function should return E_OK.

On Erase Immediate data:
  Erase immediate function should return E_OK.
  Ea_GetJobResult should return MEMIF_JOB_FAILED.

Nvm Job End Notification is called once.
Nvm Job error Notification is called once.
No Det errors reported.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00055</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>65</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>334</internalId></specobject>
    <specobject>
      <id>TS_EA_40048</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Implementation_Common/source/application/Tests.c</sourcefile>
      <sourceline>1748</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Test to check the behaviour of Ea in the case the underlying driver returns E_NOT_OK in
state EA_S_INVALIDATE_ERASE.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize test stubs for EEPROM driver, Nvm and Det if configured.
  Initialize Ea module.

Write data:
  Call Ea_Write for a logical block.
  Wait till the write job is complete.

Erase Immediate data:
  Call Ea_EraseImmediateBlock for the same block.
  Wait till the state is EA_S_INVALIDATE_ERASE.
  Set the Eep_Write() return value as E_NOT_OK.
  Wait till the erase immediate job is complete.
  Check the Ea job result after the completion of the erase immediate job.

Check the Nvm notification calls and DET errors if configured.
Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On Write data:
  Write function should return E_OK.

On Erase Immediate data:
  Erase immediate function should return E_OK.
  Ea_GetJobResult should return MEMIF_JOB_FAILED.

Nvm Job End Notification is called once.
Nvm Job error Notification is called once.
No Det errors reported.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00055</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>65</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>335</internalId></specobject>
    <specobject>
      <id>TS_EA_40049</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Implementation_Common/source/application/Tests.c</sourcefile>
      <sourceline>1919</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Test to check the behaviour of Ea in the case the underlying driver returns E_NOT_OK in
state EA_S_INVALIDATE.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize test stubs for EEPROM driver, Nvm and Det if configured.
  Initialize Ea module.

Write data:
  Call Ea_Write for a logical block.
  Wait till the write job is complete.

Invalidate Block:
  Call Ea_InvalidateBlock for the same block.
  Wait till the state is EA_S_INVALIDATE.
  Set the Eep_Write() return value as E_NOT_OK.
  Wait till the Invalidate job is complete.
  Check the Ea job result after the completion of the Invalidate job.

Check the Nvm notification calls and DET errors if configured.
Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On Write data:
  Write function should return E_OK.

On Invalidate Block:
  Invalidate function should return E_OK.
  Ea_GetJobResult should return MEMIF_JOB_FAILED.

Nvm Job End Notification is called once.
Nvm Job error Notification is called once.
No Det errors reported.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00146</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>114</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>336</internalId></specobject>
    <specobject>
      <id>TS_EA_40050</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Implementation_Common/source/application/Tests.c</sourcefile>
      <sourceline>2090</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Test to check the behaviour of Ea in the case the underlying driver returns E_NOT_OK in
state EA_S_VLE_START_MARKER.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize test stubs for EEPROM driver, Nvm and Det if configured.
  Initialize Ea module.

Write data:
  Call Ea_Write for a logical block.
  Wait till the state is EA_S_VLE_START_MARKER.
  Set the Eep_Read() return value as E_NOT_OK.
  Wait till the write job is complete.
  Check the Ea job result after the completion of the write job.

Check the Nvm notification calls and DET errors if configured.
Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On Write data:
  Write function should return E_OK.
  Ea_GetJobResult should return MEMIF_JOB_FAILED.

Nvm Job End Notification is not called.
Nvm Job error Notification is called once.
No Det errors reported.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00055</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>65</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>337</internalId></specobject>
    <specobject>
      <id>TS_EA_40051</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Implementation_Common/source/application/Tests.c</sourcefile>
      <sourceline>2238</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Test to check the behaviour of Ea in the case the underlying driver returns E_NOT_OK in
state EA_S_VLE_END_MARKER.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize test stubs for EEPROM driver, Nvm and Det if configured.
  Initialize Ea module.

Write data:
  Call Ea_Write for a logical block.
  Wait till the state is EA_S_VLE_END_MARKER.
  Set Eep_GetJobResult() return value as MEMIF_JOB_PENDING.
  Wait for 'n' number of Ea_Main cycle period.
  Set the Eep_Read() return value as E_NOT_OK.
  Wait till the write job is complete.
  Check the Ea job result after the completion of the write job.

Check the Nvm notification calls and DET errors if configured.
Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On Write data:
  Write function should return E_OK.
  Ea_GetJobResult should return MEMIF_JOB_FAILED.

Nvm Job End Notification is not called.
Nvm Job error Notification is called once.
No Det errors reported.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00055</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>65</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>338</internalId></specobject>
    <specobject>
      <id>TS_EA_40052</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Implementation_Common/source/application/Tests.c</sourcefile>
      <sourceline>2397</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Test to check the behaviour of Ea in the case the underlying driver returns E_NOT_OK in
state EA_S_VLE_FINAL.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize test stubs for EEPROM driver, Nvm and Det if configured.
  Initialize Ea module.

Write data:
  Call Ea_Write for a logical block.
  Wait till the state is EA_S_VLE_FINAL.
  Set the Eep_Read() return value as E_NOT_OK.
  Wait till the write job is complete.
  Check the Ea job result after the completion of the write job.

Check the Nvm notification calls and DET errors if configured.
Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On Write data:
  Write function should return E_OK.
  Ea_GetJobResult should return MEMIF_JOB_FAILED.

Nvm Job End Notification is not called.
Nvm Job error Notification is called once.
No Det errors reported.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00055</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>65</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>339</internalId></specobject>
    <specobject>
      <id>TS_EA_40054</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Implementation_Common/source/application/Tests.c</sourcefile>
      <sourceline>2545</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Test to check the behaviour of Ea in the case the Eep returns a job result MEMIF_JOB_FAILED in
state EA_S_WRITE_END_MARKER.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize test stubs for EEPROM driver, Nvm and Det if configured.
  Initialize Ea module.

Write data:
  Call Ea_Write for a logical block.
  Wait till the state is EA_S_WRITE_END_MARKER.
  Set the Eep Job Result as MEMIF_JOB_FAILED.
  Wait till the write job is complete.
  Check the Ea job result after the completion of the write job.

Check the Nvm notification calls and DET errors if configured.
Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On Write data:
  Write function should return E_OK.
  Ea_GetJobResult should return MEMIF_JOB_FAILED.

Nvm Job End Notification is not called.
Nvm Job error Notification is called once.
No Det errors reported.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00055</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>65</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>340</internalId></specobject>
    <specobject>
      <id>TS_EA_40055</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Implementation_Common/source/application/Tests.c</sourcefile>
      <sourceline>2693</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Test to check the behaviour of Ea in the case the Eep returns a job result MEMIF_JOB_FAILED in
state EA_S_WRITE_FINAL.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize test stubs for EEPROM driver, Nvm and Det if configured.
  Initialize Ea module.

Write data:
  Call Ea_Write for a logical block.
  Wait till the state is EA_S_WRITE_FINAL.
  Set the Eep Job Result as MEMIF_JOB_FAILED.
  Wait till the write job is complete.
  Check the Ea job result after the completion of the write job.

Check the Nvm notification calls and DET errors if configured.
Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On Write data:
  Write function should return E_OK.
  Ea_GetJobResult should return MEMIF_JOB_FAILED.

Nvm Job End Notification is not called.
Nvm Job error Notification is called once.
No Det errors reported.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00055</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>65</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>341</internalId></specobject>
    <specobject>
      <id>TS_EA_40056</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Implementation_Common/source/application/Tests.c</sourcefile>
      <sourceline>2841</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Test to check the behaviour of Ea in the case the Eep returns a job result MEMIF_JOB_FAILED in
state EA_S_READ_END_MARKER.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize test stubs for EEPROM driver, Nvm and Det if configured.
  Initialize Ea module.

Write data:
  Call Ea_Write for a logical block.
  Wait till the write job is complete.

Read data:
  Call Ea_Read for the same block.
  Wait till the state is EA_S_READ_END_MARKER.
  Set Eep_GetJobResult() return value as MEMIF_JOB_PENDING.
  Wait for 'n' number of Ea_Main cycle period.
  Set the Eep Job Result as MEMIF_JOB_FAILED.
  Wait till the read job is complete.
  Check the Ea job result after the completion of the read job.

Check the Nvm notification calls and DET errors if configured.
Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On Write data:
  Write function should return E_OK.

On Read data:
  Read function should return E_OK.
  Ea_GetJobResult should return MEMIF_JOB_FAILED.

Nvm Job End Notification is called once.
Nvm Job error Notification is called once.
No Det errors reported.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00055</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>65</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>342</internalId></specobject>
    <specobject>
      <id>TS_EA_40057</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Implementation_Common/source/application/Tests.c</sourcefile>
      <sourceline>3023</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Test to check the behaviour of Ea in the case the Eep returns a job result MEMIF_JOB_FAILED in
state EA_S_READ_DATA.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize test stubs for EEPROM driver, Nvm and Det if configured.
  Initialize Ea module.

Write data:
  Call Ea_Write for a logical block.
  Wait till the write job is complete.

Read data:
  Call Ea_Read for the same block.
  Wait till the state is EA_S_READ_DATA.
  Set the Eep Job Result as MEMIF_JOB_FAILED.
  Wait till the read job is complete.
  Check the Ea job result after the completion of the read job.

Check the Nvm notification calls and DET errors if configured.
Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On Write data:
  Write function should return E_OK.

On Read data:
  Read function should return E_OK.
  Ea_GetJobResult should return MEMIF_JOB_FAILED.

Nvm Job End Notification is called once.
Nvm Job error Notification is called once.
No Det errors reported.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00055</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>65</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>343</internalId></specobject>
    <specobject>
      <id>TS_EA_40059</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Implementation_Common/source/application/Tests.c</sourcefile>
      <sourceline>3194</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Test to check the behaviour of Ea in the case the Eep returns a job result MEMIF_JOB_FAILED in
state EA_S_ERASE_IMMEDIATE.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize test stubs for EEPROM driver, Nvm and Det if configured.
  Initialize Ea module.

Write data:
  Call Ea_Write for a logical block.
  Wait till the write job is complete.

Erase Immediate data:
  Call Ea_EraseImmediateBlock for the same block.
  Wait till the state is EA_S_ERASE_IMMEDIATE.
  Set Eep_GetJobResult() return value as MEMIF_JOB_PENDING.
  Wait for 'n' number of Ea_Main cycle period.
  Set the Eep Job Result as MEMIF_JOB_FAILED.
  Wait till the erase immediate job is complete.
  Check the Ea job result after the completion of the erase immediate job.

Check the Nvm notification calls and DET errors if configured.
Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On Write data:
  Write function should return E_OK.

On Erase Immediate data:
  Erase immediate function should return E_OK.
  Ea_GetJobResult should return MEMIF_JOB_FAILED.

Nvm Job End Notification is called once.
Nvm Job error Notification is called once.
No Det errors reported.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00055</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>65</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>344</internalId></specobject>
    <specobject>
      <id>TS_EA_40060</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Implementation_Common/source/application/Tests.c</sourcefile>
      <sourceline>3376</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Test to check the behaviour of Ea in the case the Eep returns a job result MEMIF_JOB_FAILED in
state EA_S_FINAL.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize test stubs for EEPROM driver, Nvm and Det if configured.
  Initialize Ea module.

Write data:
  Call Ea_Write for a logical block.
  Wait till the write job is complete.

Read data:
  Call Ea_Read for the same block.
  Wait till the state is EA_S_FINAL.
  Set the Eep Job Result as MEMIF_JOB_FAILED.
  Wait till the read job is complete.
  Check the Ea job result after the completion of the read job.

Check the Nvm notification calls and DET errors if configured.
Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On Write data:
  Write function should return E_OK.

On Read data:
  Read function should return E_OK.
  Ea_GetJobResult should return MEMIF_JOB_FAILED.

Nvm Job End Notification is called once.
Nvm Job error Notification is called once.
No Det errors reported.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00055</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>65</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>345</internalId></specobject>
    <specobject>
      <id>TS_EA_40061</id>
      <status>approved</status>
      <source>EB test case specification (asc_Ea)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Ea/test/ts5/Include/Ea_Implementation_Common/source/application/Tests.c</sourcefile>
      <sourceline>3547</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Test to check the behaviour of Ea in the case the underlying driver returns E_NOT_OK in
state EA_S_VLE_FINAL.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
None

Test Execution: 

Note: Unless otherwise stated, whenever an Ea Job is requested, Ea_MainFunction and
Eep_MainFunction are to be called continuously till the job gets completed.

Init test:
  Initialize test stubs for EEPROM driver, Nvm and Det if configured.
  Initialize Ea module.

Write data:
  Call Ea_Write for a logical block.
  Wait till the state is EA_S_VLE_FINAL.
  Set Eep_GetJobResult() return value as MEMIF_JOB_PENDING.
  Wait for 'n' number of Ea_Main cycle period.
  Set the Eep Job Result as MEMIF_JOB_FAILED.
  Wait till the write job is complete.
  Check the Ea job result after the completion of the write job.

Check the Nvm notification calls and DET errors if configured.
Incase any of the above operation returns unexpected value, set result as failure.


Test Input: 

Test Output: 

On Init:
  The return of initialization need not be verified since initialization is already tested.

On Write data:
  Write function should return E_OK.
  Ea_GetJobResult should return MEMIF_JOB_FAILED.

Nvm Job End Notification is not called.
Nvm Job error Notification is called once.
No Det errors reported.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Ea.SWS_Ea_00055</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>65</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>346</internalId></specobject>
  </specobjects>
  </specdocument>
  <violations/>
  <oreqmViolations/>
</tracingresults>
